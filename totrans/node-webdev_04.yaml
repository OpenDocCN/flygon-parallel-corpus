- en: Exploring Node.js Modules
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 探索Node.js模块
- en: Modules and packages are the building blocks for breaking down your application
    into smaller pieces. A module encapsulates some functionality, primarily JavaScript
    functions, while hiding implementation details and exposing an API for the module.
    Modules can be distributed by third parties and installed for use by our modules. An
    installed module is called a package.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和包是将应用程序拆分为较小部分的基本构建模块。模块封装了一些功能，主要是JavaScript函数，同时隐藏实现细节并为模块公开API。模块可以由第三方分发并安装供我们的模块使用。已安装的模块称为包。
- en: The npm package repository is a huge library of modules that's available for
    all Node.js developers to use. Within that library are hundreds of thousands of
    packages you can be used to accelerate the development of your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: npm包存储库是一个庞大的模块库，供所有Node.js开发人员使用。在该库中有数十万个包，可以加速您的应用程序开发。
- en: Since modules and packages are the building blocks of your application, understanding
    how they work is vital to your success with Node.js. By the end of this chapter,
    you will have a solid grounding in both CommonJS and ES6 modules, how to structure
    the modules in an application, how to manage dependencies on third-party packages,
    and how to publish your own packages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块和包是应用程序的构建模块，了解它们的工作原理对于您在Node.js中取得成功至关重要。在本章结束时，您将对CommonJS和ES6模块有扎实的基础，了解如何在应用程序中构建模块，如何管理第三方包的依赖关系，以及如何发布自己的包。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Definitions of all types of Node.js modules and how to structure both simple
    and complex modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类型的Node.js模块的定义以及如何构建简单和复杂的模块
- en: Using CommonJS and ES2015/ES6 modules and when to use each
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CommonJS和ES2015/ES6模块以及何时使用每种模块
- en: Understanding how Node.js finds modules and installed packages, so you can better
    structure your application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Node.js如何找到模块和已安装的包，以便更好地构建您的应用程序
- en: Using the npm package management system (and Yarn) to manage application dependencies,
    to publish packages, and to record administrative scripts for the project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用npm包管理系统（以及Yarn）来管理应用程序的依赖关系，发布包，并记录项目的管理脚本
- en: So, let's get on with it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧。
- en: Defining a Node.js module
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Node.js模块
- en: Modules are the basic building blocks for constructing Node.js applications.
    A Node.js module encapsulates functions, hiding details inside a well-protected
    container, and exposing an explicitly declared API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是构建Node.js应用程序的基本构建模块。Node.js模块封装了函数，将细节隐藏在一个受保护的容器内，并公开明确定义的API。
- en: When Node.js was created, the ES6 module system, of course, did not yet exist.
    Ryan Dahl, therefore, based on the Node.js module system on the CommonJS standard.
    The examples we've seen so far are modules written to that format. With ES2015/ES2016,
    a new module format was created for use with all JavaScript implementations. This
    new module format is used by both front-end engineers in their in-browser JavaScript
    code and by Node.js engineers, and for any other JavaScript implementation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当Node.js创建时，当然还不存在ES6模块系统。因此，Ryan Dahl基于CommonJS标准创建了Node.js模块系统。到目前为止，我们看到的示例都是按照该格式编写的模块。随着ES2015/ES2016，为所有JavaScript实现创建了一个新的模块格式。这种新的模块格式被前端工程师用于其浏览器JavaScript代码，也被Node.js工程师和其他JavaScript实现使用。
- en: Because ES6 modules are now the standard module format, the Node.js **Technical
    Steering Committee** (**TSC**) committed to first-class support for ES6 modules
    alongside the CommonJS format. Starting with Node.js 14.x, the Node.js TSC delivered
    on that promise.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ES6模块现在是标准模块格式，Node.js **技术指导委员会**（**TSC**）承诺支持ES6模块与CommonJS格式的一流支持。从Node.js
    14.x开始，Node.js TSC兑现了这一承诺。
- en: Every source file used in an application on the Node.js platform is a *module*.
    Over the next few sections, we'll examine the different types of modules, starting
    with the CommonJS module format.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js平台上应用程序中使用的每个源文件都是一个*模块*。在接下来的几节中，我们将检查不同类型的模块，从CommonJS模块格式开始。
- en: Throughout this book, we'll identify traditional Node.js modules as CommonJS
    modules, and the new module format as ES6 modules.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将传统的Node.js模块标识为CommonJS模块，新的模块格式标识为ES6模块。
- en: To start our exploration of Node.js modules, we must, of course, start at the
    beginning.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始探索Node.js模块，当然要从头开始。
- en: Examining the traditional Node.js module format
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查传统的Node.js模块格式
- en: We already saw CommonJS modules in action in the previous chapter. It's now
    time to see what they are and how they work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中看到了CommonJS模块的实际应用。现在是时候看看它们是什么以及它们是如何工作的了。
- en: 'In the `ls.js` example in [Chapter 2](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml),
    *Setting Up Node.js*, we wrote the following code to pull in the `fs` module,
    giving us access to its functions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml)中的`ls.js`示例中，*设置Node.js*，我们编写了以下代码来引入`fs`模块，从而可以访问其函数：
- en: '[PRE0]js\1'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]js\1'
- en: 'Whether you use `module.exports` or `exports` is up to you. However, do not
    ever do anything like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择使用`module.exports`还是`exports`。但是，绝对不要做以下类似的事情：
- en: '[PRE1]js\1'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE1]js\1'
- en: Some modules do export a single function because that's how the module author
    envisioned delivering the desired functionality.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有些模块导出单个函数，因为这是模块作者设想提供所需功能的方式。
- en: When we said `ls.js` does not export anything, we meant that `ls.js` did not
    assign anything to `module.exports`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说`ls.js`没有导出任何内容时，我们的意思是`ls.js`没有将任何内容分配给`module.exports`。
- en: 'To give us a brief example, let''s create a simple module, named `simple.js`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们一个简单的例子，让我们创建一个简单的模块，名为`simple.js`：
- en: '[PRE2]js\1'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]js\1'
- en: The `exports` object in the module is the object that is returned by `require('./simple')`.
    Therefore, each call to `s.next` calls the `next` function in `simple.js`. Each
    returns (and increments) the value of the local variable, `count`. An attempt
    to access the private field, `count`, shows it's unavailable from outside the
    module.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: This is how Node.js solves the global object problem of browser-based JavaScript.
    The variables that look like they are global variables are only global to the
    module containing the variable. These variables are not visible to any other code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js package format is derived from the CommonJS module system ([http://commonjs.org](http://commonjs.org)).
    When developed, the CommonJS team aimed to fill a gap in the JavaScript ecosystem.
    At that time, there was no standard module system, making it trickier to package
    JavaScript applications. The `require` function, the `exports` object, and other
    aspects of Node.js modules come directly from the CommonJS `Modules/1.0` spec.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The `module` object is a global-to-the-module object injected by Node.js. It
    also injects two other variables: `__dirname` and `__filename`. These are useful
    for helping code in a module know where it is located in the filesystem. Primarily,
    this is used for loading other files using a path relative to the module''s location.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, one can store assets like CSS or image files in a directory relative
    to the module. An app framework can then make the files available via an HTTP
    server. In Express, we do so with this code snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]js\1'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'This lets us see the values we receive:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]js\1'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to `simple.js` but with a few additions to demonstrate further
    features. As before `count` is a private variable that isn't exported, and `next`
    is an exported function that increments `count`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The `export` keyword declares what is being exported from an ES6 module. In
    this case, we have several exported functions and two exported variables. The
    `export` keyword can be put in front of any top-level declaration, such as variable,
    function, or class declarations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]js\1'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'The intent of both is essentially the same: to make a function or other object
    available to code outside the module. But instead of explicitly creating an object,
    `module.exports`, we''re simply declaring what is to be exported. A statement
    such as `export function next()` is a named export, meaning the exported function
    (as here) or object has a name, and that code outside the module uses that name
    to access the object. As we see here, named exports can be functions or objects,
    and they may also be class definitions.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The *default export* from a module, defined with `export default`, can be done
    once per module. The default export is what code outside the module accesses when
    using the module object itself, rather than when using one of the exports from
    the module.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: You can also declare something, such as the `squared` function, and then export
    it later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how to use the ES2015 module. Create a `simpledemo.mjs` file
    with the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]js\1'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: In the past, the ES6 module format was hidden behind an option flag, `--experimental-module`,
    but as of Node.js 13.2 that flag is no longer required. Accessing the `default` export
    is accomplished by accessing the field named `default`. Accessing an exported
    value, such as the `meaning` field, is done without parentheses because it is
    a value and not a function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to see a different way to import objects from a module, create another
    file, named `simpledemo2.mjs`, containing the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]js\1'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: This is a reimplementation of the `ls.js` example in [Chapter 2](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml),
    *Setting Up Node.js*. In both cases, we're using the `promises` submodule of the
    `fs` package. To do this with the `import` statement, we access the `promises`
    export from the `fs` module, and use the `as` clause to rename `fs.promises` to `fs`.
    This way we can use an async function rather than deal with callbacks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[第2章](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml)中`ls.js`示例的重新实现，*设置Node.js*。在这两种情况下，我们都使用了`fs`包的`promises`子模块。要使用`import`语句，我们访问`fs`模块中的`promises`导出，并使用`as`子句将`fs.promises`重命名为`fs`。这样我们就可以使用异步函数而不是处理回调。
- en: Otherwise, we have an `async` function, `listFiles`, that performs filesystem
    operations to read filenames from a directory. Because `listFiles` is `async`,
    it returns a Promise, and we must catch any errors using a `.catch` clause.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们有一个`async`函数`listFiles`，它执行文件系统操作以从目录中读取文件名。因为`listFiles`是`async`，它返回一个Promise，我们必须使用`.catch`子句捕获任何错误。
- en: 'Executing the script gives the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本会得到以下结果：
- en: '[PRE8]js\1'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]js\1'
- en: 'That innocent bit of code results in an error:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个无辜的代码导致了一个错误：
- en: '[PRE9]js\1'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]js\1'
- en: 'Since `__dirname` and `__filename` are not part of the JavaScript specification,
    they are not available within ES6 modules. Enter the `import.meta.url` object,
    from which we can compute `__dirname` and `__filename`. To see it in action, create
    a `dirname-fixed.mjs` file containing the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`__dirname`和`__filename`不是JavaScript规范的一部分，它们在ES6模块中不可用。输入`import.meta.url`对象，我们可以计算`__dirname`和`__filename`。要看它的运行情况，创建一个包含以下内容的`dirname-fixed.mjs`文件：
- en: '[PRE10]js\1'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]js\1'
- en: And we see the `file://` URL of the module, and the computed values for `__dirname`
    and `__filename` using the built-in core functions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到模块的`file://` URL，以及使用内置核心函数计算的`__dirname`和`__filename`的值。
- en: We've talked about both the CommonJS and ES6 module formats, and now it's time
    to talk about using them together in an application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了CommonJS和ES6模块格式，现在是时候讨论在应用程序中同时使用它们了。
- en: Using CommonJS and ES6 modules together
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时使用CommonJS和ES6模块
- en: 'Node.js supports two module formats for JavaScript code: the CommonJS format
    originally developed for Node.js, and the new ES6 module format. The two are conceptually
    similar, but there are many practical differences. Because of this, we will face
    situations of using both in the same application and will need to know how to
    proceed.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js支持JavaScript代码的两种模块格式：最初为Node.js开发的CommonJS格式，以及新的ES6模块格式。这两种格式在概念上是相似的，但在实际上有许多不同之处。因此，我们将面临在同一个应用程序中同时使用两种格式的情况，并需要知道如何进行操作。
- en: 'First is the question of file extensions and recognizing which module format
    to use. The ES6 module format is used in the following situations:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是文件扩展名的问题，以及识别要使用哪种模块格式。以下情况下使用ES6模块格式：
- en: Files where the filename ends in `.mjs`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名以`.mjs`结尾的文件。
- en: If the `package.json` has a field named `type` with the value `module`, then
    filenames ending with `.js`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`package.json`有一个名为`type`且值为`module`的字段，则以`.js`结尾的文件。
- en: If the `node` binary is executed with the `--input-type=module` flag, then any
    code passed through the `--eval` or `--print` argument, or piped in via STDIN
    (the standard input), is interpreted as ES6 module code.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`node`二进制文件使用`--input-type=module`标志执行，则通过`--eval`或`--print`参数传递的任何代码，或者通过STDIN（标准输入）传入的代码，都将被解释为ES6模块代码。
- en: That's fairly straight-forward. ES6 modules are in files named with the `.mjs`
    extension, unless you've declared in the `package.json` that the package defaults
    to ES6 modules, in which case files named with the `.js` extension are also interpreted
    as ES6 modules.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当直截了当的。ES6模块在以`.mjs`扩展名命名的文件中，除非你在`package.json`中声明包默认使用ES6模块，这样以`.js`扩展名命名的文件也会被解释为ES6模块。
- en: 'The CommonJS module format is used in the following situations:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下情况下使用CommonJS模块格式：
- en: Files where the file name ends in `.cjs`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名以`.cjs`结尾的文件。
- en: If the `package.json` does not contain a `type` field, or if it contains a `type`
    field with a value of `commonjs`, the filenames will end with `.js`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`package.json`不包含`type`字段，或者包含一个值为`commonjs`的`type`字段，则文件名将以`.js`结尾。
- en: If the `node` binary is executed with the `--input-type` flag or with the `--type-type=commonjs`
    flag, then any code passed through the `--eval` or `--print` argument, or piped
    in via STDIN (the standard input), is interpreted as CommonJS module code.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`node`二进制文件使用`--input-type`标志或`--type-type=commonjs`标志执行，则通过`--eval`或`--print`参数传递的任何代码，或者通过STDIN（标准输入）传入的代码，都将被解释为CommonJS模块代码。
- en: Again this is straight-forward, with Node.js defaulting to CommonJS modules
    for the `.js` files. If the package is explicitly declared to default to CommonJS
    modules, then Node.js will interpret the `.js` files as CommonJS.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这是直截了当的，Node.js默认使用CommonJS模块来处理`.js`文件。如果包明确声明为默认使用CommonJS模块，则Node.js将把`.js`文件解释为CommonJS。
- en: The Node.js team strongly recommends that package authors include a `type` field
    in `package.json`, even if the type is `commonjs`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js团队强烈建议包作者在`package.json`中包含一个`type`字段，即使类型是`commonjs`。
- en: 'Consider a `package.json` with this declaration:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个具有这个声明的`package.json`：
- en: '[PRE11]js\1'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]js\1'
- en: 'This command will do the same, even without the `package.json` entry:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将执行相同的操作，即使没有`package.json`条目：
- en: '[PRE12]js\1'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]js\1'
- en: 'This is a CommonJS module that''s using an ES6 module we created earlier. It
    simply calls a few of the functions, nothing exciting except that it is using
    an ES6 module when we said earlier `import` only works in ES6 modules. Let''s
    see this module in action:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用我们之前创建的ES6模块的CommonJS模块。它只是调用了一些函数，除了它在我们之前说过的只有ES6模块中才能使用`import`之外，没有什么激动人心的地方。让我们看看这个模块的运行情况：
- en: '[PRE13]js\1'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]js\1'
- en: 'It''s the same code but running in the global scope. In the global scope, we
    cannot use the `await` keyword, so we should expect that `simple2` will contain
    a pending Promise. Running the script gives us this failure:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的代码，但在全局范围内运行。在全局范围内，我们不能使用`await`关键字，所以我们应该期望`simple2`将包含一个挂起的Promise。运行脚本会导致失败：
- en: '[PRE14]js\1'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]js\1'
- en: 'Thus, everything within the module is contained within an anonymous private
    namespace context. This is how the global object problem is resolved: everything in
    a module that looks global is actually contained within a private context. This
    also explains how the injected variables are actually injected into the module.
    They are parameters to the function that creates the module.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模块内的一切都包含在一个匿名的私有命名空间上下文中。这就解决了全局对象问题：模块中看起来全局的一切实际上都包含在一个私有上下文中。这也解释了注入的变量实际上是如何注入到模块中的。它们是创建模块的函数的参数。
- en: The other advantage is code safety. Because the private code in a module is
    stashed in a private namespace, it is impossible for code outside the module to
    access the private code or data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优势是代码安全性。因为模块中的私有代码被隐藏在私有命名空间中，所以模块外部的代码或数据无法访问私有代码。
- en: 'Let''s take a look at a practical demonstration of the encapsulation. Create
    a file named `module1.js`, containing the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个封装的实际演示。创建一个名为`module1.js`的文件，其中包含以下内容：
- en: '[PRE15]js\1'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]js\1'
- en: Using these two modules we can see how each module is its own protected bubble.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个模块，我们可以看到每个模块都是其自己受保护的泡泡。
- en: 'Then run it as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式运行它：
- en: '[PRE16]js\1'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]js\1'
- en: 'That is, the JSON file is read synchronously, and the text is parsed as JSON.
    The resultant object is available as the object exported from the module. Create
    a file named `data.json`, containing the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，JSON文件是同步读取的，文本被解析为JSON。生成的对象作为模块导出的对象可用。创建一个名为`data.json`的文件，其中包含以下内容：
- en: '[PRE17]js\1'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]js\1'
- en: 'It will execute as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它将执行如下：
- en: '[PRE18]js\1'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]js\1'
- en: So far that is equivalent to the CommonJS version of this script, but using
    `import` rather than `require`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这相当于该脚本的CommonJS版本，但使用`import`而不是`require`。
- en: '[PRE19]js\1'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]js\1'
- en: 'There are two ways to use this module:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以使用这个模块：
- en: In a CommonJS module, invoke `require('esm')`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CommonJS模块中，调用`require('esm')`。
- en: On the command line, use `--require esm`, as shown here.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行中使用`--require esm`，如下所示。
- en: In both cases, the effect is the same, to load the `esm` module. This module
    only needs to be loaded once, and we do not have to call any of its methods. Instead
    `esm` retrofits ES6 module support into the Node.js runtime, and is compatible
    with version 6.x and later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，效果是一样的，即加载`esm`模块。这个模块只需要加载一次，我们不必调用它的任何方法。相反，`esm`将ES6模块支持改装到Node.js运行时中，并且与6.x版本及更高版本兼容。
- en: So, we can use this module to retrofit ES6 module support; it does not retrofit
    other features such as `async` functions. Successfully executing the `ls.mjs`
    example requires support for both the `async` functions and arrow functions. Since
    Node.js 6.x does not support either, the `ls.mjs` example will load correctly,
    but will still fail because it uses other unsupported features.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用这个模块来改装ES6模块支持；它不改装其他功能，比如`async`函数。成功执行`ls.mjs`示例需要对`async`函数和箭头函数的支持。由于Node.js
    6.x不支持任何一个，`ls.mjs`示例将能够正确加载，但仍将失败，因为它使用了其他不受支持的功能。
- en: '[PRE20]js\1'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]js\1'
- en: 'This uses an extension-less module identifier to load a module we''ve already
    discussed, `simple.js`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一个无扩展名的模块标识符来加载我们已经讨论过的模块`simple.js`：
- en: '[PRE21]js\1'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]js\1'
- en: We get the error message making it clear that Node.js could not resolve the
    file name. Similarly, in an ES6 module, the file name given to the `import` statement
    must have the file extension.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到了错误消息，清楚地表明Node.js无法解析文件名。同样，在ES6模块中，给`import`语句的文件名必须带有文件扩展名。
- en: Next, let's discuss another side effect of ES6 module identifiers being a URL.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论ES6模块标识符的另一个副作用。
- en: The ES6 import statement takes a URL
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES6的import语句采用URL
- en: The module identifier in the ES6 `import` statement is a URL. There are several
    important considerations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 `import`语句中的模块标识符是一个URL。有几个重要的考虑因素。
- en: Since Node.js only supports the `file://` URLs, we're not allowed to retrieve
    a module over from a web server. There are obvious security implications, and
    the corporate security team would rightfully get anxious if modules could be loaded
    from `http://` URLs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node.js只支持`file://`URL，我们不允许从Web服务器检索模块。这涉及明显的安全问题，如果模块可以从`http://`URL加载，企业安全团队将会感到焦虑。
- en: Referencing a file with an absolute pathname must use the `file:///path/to/file.ext`
    syntax, as mentioned earlier. This is different from `require`, where we would
    use `/path/to/file.ext` instead.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 引用具有绝对路径名的文件必须使用`file:///path/to/file.ext`语法，如前面所述。这与`require`不同，我们将使用`/path/to/file.ext`。
- en: 'Since `?` and `#` have special significance in a URL, they also have special
    significance to the `import` statement, as in the following example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`?`和`#`在URL中具有特殊意义，它们对`import`语句也具有特殊意义，如下例所示：
- en: '[PRE22]js\1'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE22]js\1'
- en: 'And the equivalent in an ES6 module would be as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6模块中的等效代码如下：
- en: '[PRE23]js\1'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]js\1'
- en: The `name` field gives the name of the package. If the `main` field is present,
    it names the JavaScript file to use instead of `index.js` to load when the package
    is loaded. The package manager applications like npm and Yarn support many more
    fields in `package.json`, which they use to manage dependencies and versions and
    everything else.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`字段给出了包的名称。如果存在`main`字段，它将命名要在加载包时使用的JavaScript文件，而不是`index.js`。像npm和Yarn这样的包管理应用程序支持`package.json`中的更多字段，它们用来管理依赖关系、版本和其他一切。'
- en: If there is no `package.json`, then Node.js will look for either `index.js` or `index.node`.
    In such a case, `require('some-library')` will load the file module in `/path/to/some-library/index.js`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`package.json`，那么Node.js将寻找`index.js`或`index.node`。在这种情况下，`require('some-library')`将加载`/path/to/some-library/index.js`中的文件模块。
- en: Installed packages are kept in a directory named `node_modules`. When JavaScript
    source code has `require('some-library')` or `import 'some-library'`, Node.js
    searches through one or more `node_modules` directories to find the named package.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 安装的包保存在一个名为`node_modules`的目录中。当JavaScript源代码有`require('some-library')`或`import
    'some-library'`时，Node.js会在一个或多个`node_modules`目录中搜索以找到命名的包。
- en: Notice that the module identifier, in this case, is just the package name. This
    is different from the file and directory module identifiers we studied earlier
    since both those are pathnames. In this case, the module identifier is somewhat
    abstract, and that's because Node.js has an algorithm for finding packages within
    the nested structure of the `node_modules` directories.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，模块标识符只是包名。这与我们之前学习的文件和目录模块标识符不同，因为这两者都是路径名。在这种情况下，模块标识符有点抽象，这是因为Node.js有一个算法来在嵌套的`node_modules`目录中找到包。
- en: To understand how that works, we need a deeper dive into the algorithm.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这是如何工作的，我们需要深入了解算法。
- en: Finding the installed package in the file system
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在文件系统中找到安装的包
- en: One key to why the Node.js package system is so flexible is the algorithm used
    to search for packages.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js包系统如此灵活的关键之一是用于搜索包的算法。
- en: For a given `require`, `import()`, or `import` statement, Node.js searches upward
    in the file system from the directory containing the statement. It is looking
    for a directory named `node_modules` containing a module satisfying the module
    identifier.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的`require`、`import()`或`import`语句，Node.js会在包含该语句的目录中向上搜索文件系统。它正在寻找一个名为`node_modules`的目录，其中包含满足模块标识符的模块。
- en: 'For example, with a source file named `/home/david/projects/notes/foo.js` and
    a `require` or `import` statement requesting the module identifier `bar.js`, Node.js
    tries the following options:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于名为`/home/david/projects/notes/foo.js`的源文件和请求模块标识符`bar.js`的`require`或`import`语句，Node.js尝试以下选项：
- en: '![](img/b20040f4-8a85-4f12-b445-b49a673a904a.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b20040f4-8a85-4f12-b445-b49a673a904a.png)'
- en: As just said, the search starts at the same level of the file system as `foo.js`.
    Node.js will look either for a file module named `bar.js` or else a directory
    named `bar.js` containing a module as described earlier in *Using a* *Directory
    as a module*. Node.js will check for this package in the `node_modules` directory
    next to `foo.js` and in every directory above that file. It will not, however,
    descend into any directory such as `express` or `express/node_modules`. The traversal
    only moves upward in the file system, not downward.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如刚才所说，搜索从`foo.js`所在的文件系统级别开始。Node.js会查找名为`bar.js`的文件模块，或者包含模块的名为`bar.js`的目录，如*使用目录作为模块*中所述。Node.js将在`foo.js`旁边的`node_modules`目录以及该文件上方的每个目录中检查这个包。但是，它不会进入任何目录，比如`express`或`express/node_modules`。遍历只会向文件系统上方移动，而不会向下移动。
- en: While some of the third-party packages have a name ending in `.js`, the vast
    majority do not. Therefore, we will typically use `require('bar')`. Also typically
    the 3rd party installed packages are delivered as a directory containing a `package.json` file
    and some JavaScript files. Therefore, in the typical case, the package module
    identifier would be `bar`, and Node.js will find a directory named `bar` in one
    of the `node_modules` directories and access the package from that directory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些第三方包的名称以`.js`结尾，但绝大多数不是。因此，我们通常会使用`require('bar')`。通常，第三方安装的包是作为一个包含`package.json`文件和一些JavaScript文件的目录交付的。因此，在典型情况下，包模块标识符将是`bar`，Node.js将在一个`node_modules`目录中找到一个名为`bar`的目录，并从该目录访问包。
- en: 'This act of searching upward in the file system means Node.js supports the
    nested installation of packages. A Node.js package that in turn depends on other
    modules that will have its own `node_modules` directory; that is, the `bar` package
    might depend on the `fred` package. The package manager application might install
    `fred` as `/home/david/projects/notes/node_modules/bar/node_modules/fred`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统中向上搜索的这种行为意味着Node.js支持包的嵌套安装。一个Node.js包可能依赖于其他模块，这些模块将有自己的`node_modules`目录；也就是说，`bar`包可能依赖于`fred`包。包管理应用程序可能会将`fred`安装为`/home/david/projects/notes/node_modules/bar/node_modules/fred`：
- en: '![](img/0d84888b-cc4d-4f3c-881e-dd3dc6c71008.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d84888b-cc4d-4f3c-881e-dd3dc6c71008.png)'
- en: In such a case, when a JavaScript file in the `bar` package uses `require('fred')`
    its search for modules starts in `/home/david/projects/notes/node_modules/bar/node_modules`,
    where it will find the `fred` package. But if the package manager detects that
    other packages used by `notes` also use the `fred` package, the package manager
    will install it as `/home/david/projects/notes/node_modules/fred`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当`bar`包中的JavaScript文件使用`require('fred')`时，它的模块搜索从`/home/david/projects/notes/node_modules/bar/node_modules`开始，在那里它会找到`fred`包。但是，如果包管理器检测到`notes`中使用的其他包也使用`fred`包，包管理器将把它安装为`/home/david/projects/notes/node_modules/fred`。
- en: Because the search algorithm traverses the file system upwards, it will find
    `fred` in either location.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为搜索算法会在文件系统中向上查找，它会在任一位置找到`fred`。
- en: The last thing to note is that this nesting of `node_modules` directories can
    be arbitrarily deep. While the package manager applications try to install packages
    in a flat hierarchy, it may be necessary to nest them deeply.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的是，这种`node_modules`目录的嵌套可以任意深。虽然包管理应用程序尝试在一个平面层次结构中安装包，但可能需要将它们深度嵌套。
- en: One reason for doing so is to enable using two or more versions of the same
    package.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的一个原因是为了能够使用两个或更多版本的同一个包。
- en: Handling multiple versions of the same installed package
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理同一安装包的多个版本
- en: The Node.js package identifier resolution algorithm allows us to install two
    or more versions of the same package. Returning to the hypothetical *notes* project,
    notice that the `fred` package is installed not just for the `bar` package but
    also for the `express` package.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js包标识符解析算法允许我们安装两个或更多版本的同一个包。回到假设的*notes*项目，注意`fred`包不仅为`bar`包安装，也为`express`包安装。
- en: Looking at the algorithm, we know that `require('fred')` in the `bar` package,
    and in the `express` package, will be satisfied by the corresponding `fred` package
    installed locally to each.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 查看算法，我们知道`bar`软件包和`express`软件包中的`require('fred')`将分别满足于本地安装的相应`fred`软件包。
- en: Normally, the package manager applications will detect the two instances of
    the `fred` package and install only one. But, suppose the `bar` package required
    the `fred` version 1.2, while the `express` package required the `fred` version
    2.1.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，软件包管理应用程序将检测`fred`软件包的两个实例并仅安装一个。但是，假设`bar`软件包需要`fred`版本1.2，而`express`软件包需要`fred`版本2.1。
- en: 'In such a case, the package manager application will detect the incompatibility
    and install two versions of the `fred` package as so:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，软件包管理应用程序将检测不兼容性，并安装两个版本的`fred`软件包，如下所示：
- en: In `/home/david/projects/notes/node_modules/bar/node_modules`, it will install
    `fred` version 1.2.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`/home/david/projects/notes/node_modules/bar/node_modules`中，它将安装`fred`版本1.2。
- en: In `/home/david/projects/notes/node_modules/express/node_modules`, it will install `fred` version
    2.1.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`/home/david/projects/notes/node_modules/express/node_modules`中，它将安装`fred`版本2.1。
- en: When the `express` package executes `require('fred')` or `import 'fred'`, it
    will be satisfied by the package in `/home/david/projects/notes/node_modules/express/node_modules/fred`.
    Likewise, the `bar` package will be satisfied by the package in `/home/david/projects/notes/node_modules/bar/node_modules/fred`.
    In both cases, the `bar` and `express` packages have the correct version of the
    `fred` package available. Neither is aware there is another version of `fred`
    installed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当`express`软件包执行`require('fred')`或`import 'fred'`时，它将满足于`/home/david/projects/notes/node_modules/express/node_modules/fred`中的软件包。同样，`bar`软件包将满足于`/home/david/projects/notes/node_modules/bar/node_modules/fred`中的软件包。在这两种情况下，`bar`和`express`软件包都有`fred`软件包的正确版本可用。它们都不知道已安装另一个版本的`fred`。
- en: The `node_modules` directory is meant for packages required by an application.
    Node.js also supports installing packages in a global location so they can be
    used by multiple applications.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`node_modules`目录用于应用程序所需的软件包。Node.js还支持在全局位置安装软件包，以便它们可以被多个应用程序使用。'
- en: Searching for globally installed packages
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索全局安装的软件包
- en: We've already seen that with npm we can perform a *global install* of a package.
    For example, command-line tools like `hexy` or `babel` are convenient if installed
    globally. In such a case the package is installed in another folder outside of
    the project directory. Node.js has two strategies for finding globally installed
    packages.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，使用npm可以执行*全局安装*软件包。例如，如果全局安装了`hexy`或`babel`等命令行工具，那么很方便。在这种情况下，软件包将安装在项目目录之外的另一个文件夹中。Node.js有两种策略来查找全局安装的软件包。
- en: Similar to the `PATH` variable, the `NODE_PATH` environment variable can be
    used to list additional directories in which to search for packages. On Unix-like
    operating systems, `NODE_PATH` is a colon-separated list of directories, and on
    Windows it is semicolon-separated. In both cases, it is similar to how the `PATH`
    variable is interpreted, meaning that `NODE_PATH` has a list of directory names
    in which to find installed modules.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与`PATH`变量类似，`NODE_PATH`环境变量可用于列出额外的目录，以便在其中搜索软件包。在类Unix操作系统上，`NODE_PATH`是一个由冒号分隔的目录列表，在Windows上是用分号分隔的。在这两种情况下，它类似于`PATH`变量的解释，这意味着`NODE_PATH`有一个目录名称列表，用于查找已安装的模块。
- en: The `NODE_PATH` approach is not recommended, because of surprising behavior
    that can happen if people are unaware that this variable must be set. If a specific
    module located in a specific directory referenced in `NODE_PATH` is required for
    a proper function and the variable is not set, the application will likely fail.
    The best practice is for all dependencies to be explicitly declared, and with
    Node.js that means listing all dependencies in the `package.json` file so that `npm` or `yarn` can
    manage the dependencies.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议使用`NODE_PATH`方法，因为如果人们不知道必须设置这个变量，可能会发生令人惊讶的行为。如果需要特定目录中的特定模块以正确运行，并且未设置该变量，应用程序可能会失败。最佳做法是明确声明所有依赖关系，对于Node.js来说，这意味着在`package.json`文件中列出所有依赖项，以便`npm`或`yarn`可以管理依赖项。
- en: This variable was implemented before the module resolution algorithm just described
    was finalized. Because of that algorithm, `NODE_PATH` is largely unnecessary.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚刚描述的模块解析算法之前，已经实现了这个变量。由于该算法，`NODE_PATH`基本上是不必要的。
- en: 'There are three additional locations that can hold modules:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个额外的位置可以存放模块：
- en: '`$HOME/.node_modules`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$HOME/.node_modules`'
- en: '`$HOME/.node_libraries`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$HOME/.node_libraries`'
- en: '`$PREFIX/lib/node`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$PREFIX/lib/node`'
- en: In this case, `$HOME` is what you expect (the user's home directory), and `$PREFIX` is
    the directory where Node.js is installed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`$HOME`是您期望的（用户的主目录），而`$PREFIX`是安装Node.js的目录。
- en: Some recommend against using global packages. The rationale is the desire for repeatability and
    deployability. If you've tested an app and all its code is conveniently located
    within a directory tree, you can copy that tree for deployment to other machines.
    But, what if the app depended on some other file that was magically installed
    elsewhere on the system? Will you remember to deploy such files? The application
    author might write documentation saying to *install this* then *install that*
    and *install something-else* before running *npm install*, but will the users
    of the application correctly follow all those steps?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有人建议不要使用全局软件包。理由是希望实现可重复性和可部署性。如果您已经测试了一个应用程序，并且所有代码都方便地位于一个目录树中，您可以将该目录树复制到其他机器上进行部署。但是，如果应用程序依赖于系统其他位置神奇安装的某些其他文件，该怎么办？您会记得部署这些文件吗？应用程序的作者可能会编写文档，说明在运行*npm
    install*之前*安装这个*，然后*安装那个*，以及*安装其他东西*，但是应用程序的用户是否会正确地遵循所有这些步骤？
- en: The best installation instructions is to simply run *npm install* or *yarn install*.
    For that to work, all dependencies must be listed in `package.json`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的安装说明是简单地运行*npm install*或*yarn install*。为了使其工作，所有依赖项必须在`package.json`中列出。
- en: Before moving forward, let's review the different kinds of module identifiers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们回顾一下不同类型的模块标识符。
- en: Reviewing module identifiers and pathnames
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查模块标识符和路径名
- en: 'That was a lot of details spread out over several sections. It''s useful, therefore,
    to quickly review how the module identifiers are interpreted when using the `require`,
    `import()`, or `import` statements:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是分布在几个部分的许多细节。因此，当使用`require`、`import()`或`import`语句时，快速回顾一下模块标识符是如何解释的是很有用的：
- en: '**Relative module identifiers**: These begin with `./` or `../`, and absolute
    identifiers begin with `/`. The module name is identical to POSIX filesystem semantics.
    The resultant pathname is interpreted relative to the location of the file being
    executed. That is, a module identifier beginning with `./` is looked for in the
    current directory, whereas one starting with `../` is looked for in the parent
    directory.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相对模块标识符**：这些以 `./` 或 `../` 开头，绝对标识符以 `/` 开头。模块名称与POSIX文件系统语义相同。结果路径名是相对于正在执行的文件的位置进行解释的。也就是说，以
    `./` 开头的模块标识符在当前目录中查找，而以 `../` 开头的模块标识符在父目录中查找。'
- en: '**Absolute module identifiers**: These begin with `/` (or `file://` for ES6
    modules) and are, of course, looked for in the root of the filesystem. This is
    not a recommended practice.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绝对模块标识符**：这些以 `/` （或 `file://` 用于ES6模块）开头，当然，会在文件系统的根目录中查找。这不是推荐的做法。'
- en: '**Top-level module identifiers**: These do not begin with those strings and
    are just the module name. These must be stored in a `node_modules` directory,
    and the Node.js runtime has a nicely flexible algorithm for locating the correct
    `node_modules` directory.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶级模块标识符**：这些不以这些字符串开头，只是模块名称。这些必须存储在`node_modules`目录中，Node.js运行时有一个非常灵活的算法来定位正确的`node_modules`目录。'
- en: '**Core modules**: These are the same as the *top-level module identifiers*,
    in that there is no prefix, but the core modules are prebaked into the Node.js
    binary.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心模块**：这些与*顶级模块标识符*相同，即没有前缀，但核心模块已经预先嵌入到Node.js二进制文件中。'
- en: In all cases, except for the core modules, the module identifier resolves to
    a file that contains the actual module, and which is loaded by Node.js. Therefore,
    what Node.js does is to compute the mapping between the module identifier and
    the actual file name to load.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，除了核心模块，模块标识符都会解析为包含实际模块的文件，并由Node.js加载。因此，Node.js所做的是计算模块标识符和实际文件名之间的映射关系。
- en: Using a package manager application is not required. The Node.js module resolution
    algorithm does not depend on a package manager, like npm or Yarn, to set up the
    `node_modules` directories. There is nothing magical about those directories,
    and it is possible to use other means to construct a `node_modules` directory
    containing installed packages. But the simplest mechanism is to use a package
    manager application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要使用包管理器应用程序。Node.js模块解析算法不依赖于包管理器，如npm或Yarn，来设置`node_modules`目录。这些目录并没有什么神奇之处，可以使用其他方法构建包含已安装包的`node_modules`目录。但最简单的机制是使用包管理器应用程序。
- en: Some packages offer what we might call a sub-package included with the main
    package, let's see how to use them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一些包提供了我们可以称之为主包的子包，让我们看看如何使用它们。
- en: Using deep import module specifiers
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用深度导入模块标识符
- en: In addition to a simple module identifier like `require('bar')`, Node.js lets
    us directly access modules contained within a package. A different module specifier
    is used that starts with the module name, adding what's called a *deep import*
    path. For a concrete example, let's look at the `mime` module ([https://www.npmjs.com/package/mime](https://www.npmjs.com/package/mime)),
    which handles mapping a file name to its corresponding MIME type.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 `require('bar')` 这样的简单模块标识符外，Node.js还允许我们直接访问包中包含的模块。使用不同的模块标识符，以模块名称开头，添加所谓的*深度导入*路径。举个具体的例子，让我们看一下
    `mime` 模块（[https://www.npmjs.com/package/mime](https://www.npmjs.com/package/mime)），它处理将文件名映射到相应的MIME类型。
- en: In the normal case, you use `require('mime')` to use the package. However, the
    authors of this package developed a lite version of this package that leaves out
    a lot of vendor-specific MIME types. For that version, you use `require('mime/lite')` instead.
    And of course, in an ES6 module, you use `import 'mime'` and `import 'mime/lite'`,
    as appropriate.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，你使用 `require('mime')` 来使用该包。然而，该包的作者开发了一个精简版本，省略了许多特定供应商的MIME类型。对于该版本，你使用
    `require('mime/lite')`。当然，在ES6模块中，你会相应地使用 `import 'mime'` 和 `import 'mime/lite'`。
- en: The specifier `mime/lite` is an example of a deep import module specifier.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`mime/lite`是深度导入模块标识符的一个例子。'
- en: With such a module identifier, Node.js first locates the `node_modules` directory
    containing the main package. In this case, that is the `mime` package. By default,
    the deep import module is simply a path-name relative to the package directory,
    for example, `/path/to/node_modules/mime/lite`. Going by the rules we've already
    examined, it will be satisfied by a file named `lite.js` or a by a directory named
    `lite` containing a file named `index.js` or `index.mjs`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的模块标识符，Node.js首先定位包含主要包的`node_modules`目录。在这种情况下，就是 `mime` 包。默认情况下，深度导入模块只是相对于包目录的路径名，例如，`/path/to/node_modules/mime/lite`。根据我们已经检查过的规则，它将被满足为一个名为
    `lite.js` 的文件，或者一个名为 `lite` 的目录，其中包含一个名为 `index.js` 或 `index.mjs` 的文件。
- en: But it is possible to override the default behavior and have the deep import
    specifier refer to a different file within the module.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是可以覆盖默认行为，使深度导入标识符指向模块中的不同文件。
- en: Overriding a deep import module identifier
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖深度导入模块标识符
- en: 'The deep import module identifier used by code using the package does not have
    to be the pathname used within the package source. We can put declarations in
    `package.json` describing the actual pathname for each deep import identifier.
    For example, a package with interior modules named `./src/cjs-module.js` and `./src/es6-module.mjs`
    can be remapped with this declaration in `package.json`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该包的代码所使用的深度导入模块标识符不必是包源内部使用的路径名。我们可以在 `package.json` 中放置声明，描述每个深度导入标识符的实际路径名。例如，具有内部模块命名为
    `./src/cjs-module.js` 和 `./src/es6-module.mjs` 的包可以在 `package.json` 中使用此声明进行重新映射：
- en: '[PRE24]js\1'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]js\1'
- en: This says the `cookie-parser` module depends on version 0.1.3 of `cookie`, while
    Express depends on version 0.1.5.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示 `cookie-parser` 模块依赖于 `cookie` 的 0.1.3 版本，而 Express 依赖于 0.1.5 版本。
- en: Now that we can recognize what a module is and how they're found in the file
    system, let's discuss when we can use each of the methods to load modules.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以认识到模块是什么，以及它们如何在文件系统中找到，让我们讨论何时可以使用每种方法来加载模块。
- en: Loading modules using require, import, and import()
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 require、import 和 import() 加载模块
- en: Obviously `require` is used in CommonJS modules, and `import` is used in ES6
    modules, but there are some details to go over. We've already discussed the format
    and filename differences between CommonJS and ES6 modules, so let's focus here
    on loading the modules.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，CommonJS 模块中使用 `require`，ES6 模块中使用 `import`，但有一些细节需要讨论。我们已经讨论了 CommonJS 和
    ES6 模块之间的格式和文件名差异，所以让我们在这里专注于加载模块。
- en: The `require` function is only available in CommonJS modules, and it is used
    for loading a CommonJS module. The module is loaded synchronously, meaning that
    when the `require` function returns, the module is completely loaded.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 函数仅在 CommonJS 模块中可用，用于加载 CommonJS 模块。该模块是同步加载的，也就是说当 `require` 函数返回时，模块已完全加载。'
- en: 'By default, a CommonJS module cannot load an ES6 module. But as we saw with
    the `simple-dynamic-import.js` example, a CommonJS module can load an ES6 module
    using `import()`. Since the `import()` function is an asynchronous operation,
    it returns a Promise, and we, therefore, cannot use the resulting module as a
    top-level object. But we can use it inside a function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CommonJS 模块无法加载 ES6 模块。但正如我们在 `simple-dynamic-import.js` 示例中看到的，CommonJS
    模块可以使用 `import()` 加载 ES6 模块。由于 `import()` 函数是一个异步操作，它返回一个 Promise，因此我们不能将结果模块用作顶级对象。但我们可以在函数内部使用它：
- en: '[PRE25]js\1'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25]js\1'
- en: It's the same as the `simple-dynamic-import.js` example, but we are explicitly
    handling the Promise returned by `import()` rather than using an async function.
    While we could assign `simple2` to a global variable, other code using that variable
    would have to accommodate the possibility the assignment hasn't yet been made.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `simple-dynamic-import.js` 示例相同，但我们明确处理了 `import()` 返回的 Promise，而不是使用异步函数。虽然我们可以将
    `simple2` 赋给全局变量，但使用该变量的其他代码必须适应赋值可能尚未完成的可能性。
- en: The module object provided by `import()` contains the fields and functions exported
    with the `export` statements in the ES6 module. As we see here, the default export
    has the `default` name.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`import()` 提供的模块对象包含在 ES6 模块中使用 `export` 语句导出的字段和函数。正如我们在这里看到的，默认导出具有 `default`
    名称。'
- en: In other words, using an ES6 module in a CommonJS module is possible, so long
    as we accommodate waiting for the module to finish loading before using it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在 CommonJS 模块中使用 ES6 模块是可能的，只要我们等待模块完成加载后再使用它。
- en: The `import` statement is used to load ES6 modules, and it only works inside
    an ES6 module. The module specifier you hand to the `import` statement is interpreted
    as a URL.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 语句用于加载 ES6 模块，仅在 ES6 模块内部有效。您传递给 `import` 语句的模块说明符被解释为 URL。'
- en: An ES6 module can have multiple named exports. In the `simple2.mjs` we used
    earlier, these are the functions `next`, `squared`, and `hello`, and the values
    `meaning` and `nocount`. ES6 modules can have a single default export, as we saw
    in `simple2.mjs`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 模块可以有多个命名导出。在我们之前使用的 `simple2.mjs` 中，这些是函数 `next`、`squared` 和 `hello`，以及值
    `meaning` 和 `nocount`。ES6 模块可以有单个默认导出，就像我们在 `simple2.mjs` 中看到的那样。
- en: 'With `simpledemo2.mjs`, we saw that we can import only the required things
    from the module:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `simpledemo2.mjs`，我们看到可以只从模块中导入所需的内容：
- en: '[PRE26]js\1'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]js\1'
- en: 'In this case, we can invoke the function as `simple()`. We can also use what''s
    called a namespace import; that is similar to how we import CommonJS modules:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以调用函数为 `simple()`。我们还可以使用所谓的命名空间导入；这类似于我们导入 CommonJS 模块的方式：
- en: '[PRE27]js\1'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE27]js\1'
- en: 'This is similar to the *default export* method shown for ES6 modules, and we
    can think of the `module.exports` object inside the CommonJS module as the default
    export. Indeed, the `import` can be rewritten as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于 ES6 模块所示的 *默认导出* 方法，我们可以将 CommonJS 模块内的 `module.exports` 对象视为默认导出。实际上，`import`
    可以重写为以下形式：
- en: '[PRE28]js\1'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE28]js\1'
- en: 'A basic `package.json` file is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的 `package.json` 文件如下：
- en: '[PRE29]js\1'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE29]js\1'
- en: The help text will be shown on your screen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助文本将显示在您的屏幕上。
- en: Help information is also available on the npm website at: [https://docs.npmjs.com/cli-documentation/](https://docs.npmjs.com/cli-documentation/).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: npm 网站上也提供了帮助信息：[https://docs.npmjs.com/cli-documentation/](https://docs.npmjs.com/cli-documentation/)。
- en: Before we can look for and install Node.js packages, we must have a project
    directory initialized.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在查找和安装 Node.js 包之前，我们必须初始化项目目录。
- en: Initializing a Node.js package or project with npm init
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 npm init 初始化 Node.js 包或项目
- en: The npm tool makes it easy to initialize a Node.js project directory. Such a
    directory contains at the minimum a `package.json` file and one or more Node.js
    JavaScript files.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: npm 工具使得初始化 Node.js 项目目录变得容易。这样的目录包含至少一个 `package.json` 文件和一个或多个 Node.js JavaScript
    文件。
- en: All Node.js project directories are therefore modules, going by the definition
    we learned earlier. However, in many cases, a Node.js project is not meant to
    export any functionality but instead is an application. Such a project will likely
    require other Node.js packages, and those packages will be declared in the `package.json` file
    so that they're easy to install using npm. The other common use case of a Node.js
    project is a package of functionality meant to be used by other Node.js packages
    or applications. These also consist of a `package.json` file plus one or more
    Node.js JavaScript files, but in this case, they're Node.js modules that export
    functions and can be loaded using `require`, `import()`, or `import`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有Node.js项目目录都是模块，根据我们之前学到的定义。然而，在许多情况下，Node.js项目并不打算导出任何功能，而是一个应用程序。这样的项目可能需要其他Node.js包，并且这些包将在`package.json`文件中声明，以便使用npm轻松安装。Node.js项目的另一个常见用例是一个旨在供其他Node.js包或应用程序使用的功能包。这些包也包括一个`package.json`文件和一个或多个Node.js
    JavaScript文件，但在这种情况下，它们是导出函数的Node.js模块，可以使用`require`、`import()`或`import`加载。
- en: What this means is the key to initializing a Node.js project directory is creating
    the `package.json` file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着初始化Node.js项目目录的关键是创建`package.json`文件。
- en: 'While the `package.json` file can be created by hand – it''s just a JSON file
    after all - the npm tool provides a convenient method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件可以手动创建 - 毕竟它只是一个JSON文件 - npm工具提供了一个方便的方法：'
- en: '[PRE30]js\1'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]js\1'
- en: 'But what if you don''t know the module name? How do you discover the interesting
    modules? The website [http://npmjs.com](http://npmjs.com) publishes a searchable
    index of the modules in the registry. The npm package also has a command-line
    search function to consult the same index:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果您不知道模块名称怎么办？如何发现有趣的模块？网站[http://npmjs.com](http://npmjs.com)发布了一个可搜索的模块注册表索引。npm包还具有命令行搜索功能，可以查询相同的索引：
- en: '![](img/de2ec86a-0e7d-4a98-ad55-6ee68f3e0d15.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de2ec86a-0e7d-4a98-ad55-6ee68f3e0d15.png)'
- en: 'Of course, upon finding a module, it''s installed as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在找到一个模块后，它会被安装如下：
- en: '[PRE31]js\1'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE31]js\1'
- en: The `npm view` command shows us information from `package.json` file for a given
    package, and with the `--json` flag we're shown the raw JSON.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm view`命令向我们显示了给定包的`package.json`文件中的信息，并且使用`--json`标志，我们可以看到原始的JSON数据。'
- en: The `name` tag is of course the package name, and it is used in URLs and command
    names, so choose one that's safe for both. If you desire to publish a package
    in the public `npm` repository, it's helpful to check whether a particular name
    is already being used by searching on [https://npmjs.com](https://npmjs.com) or
    by using the `npm search` command.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`标签当然是包名，它在URL和命令名称中使用，因此选择一个对两者都安全的名称。如果您希望在公共`npm`存储库中发布一个包，最好通过在[https://npmjs.com](https://npmjs.com)上搜索或使用`npm
    search`命令来检查特定名称是否已被使用。'
- en: The `description` tag is a short description that's meant as a brief/terse description
    of the package.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`description`标签是一个简短的描述，旨在作为包的简要描述。'
- en: It is the name and description tags that are shown in npm search results.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在npm搜索结果中显示的是名称和描述标签。
- en: The `keywords` tag is where we list attributes of the package. The npm website
    contains pages listing all packages using a particular keyword. These keyword
    indexes are useful when searching for a package since it lists the related packages
    in one place, and therefore when publishing a package it's useful to land on the
    correct keyword pages.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`keywords`标签是我们列出包的属性的地方。npm网站包含列出使用特定关键字的所有包的页面。当搜索包时，这些关键字索引非常有用，因为它们将相关的包列在一个地方，因此在发布包时，着陆在正确的关键字页面上是很有用的。'
- en: Another source is the contents of the `README.md` file. This file should be
    added to the package to provide basic package documentation. This file is shown
    on the package page on `npmjs.com`, and therefore it is important for this file
    to convince potential users of your package to actually use it. As the file name
    implies, this is a Markdown file.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个来源是`README.md`文件的内容。这个文件应该被添加到包中，以提供基本的包文档。这个文件显示在`npmjs.com`上的包页面上，因此对于这个文件来说，说服潜在用户实际使用它是很重要的。正如文件名所示，这是一个Markdown文件。
- en: Once you have found a package to use, you must install it in order to use the
    package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到要使用的包，您必须安装它才能使用该包。
- en: Installing an npm package
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装npm包
- en: 'The `npm install` command makes it easy to install packages upon finding one
    of your dreams, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install`命令使得在找到梦寐以求的包后安装变得容易，如下所示：'
- en: '[PRE32]js\1'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE32]js\1'
- en: The `version` field obviously declares the current package version. The `dist-tags`
    field lists symbolic tags that the package maintainer can use to aid their users
    in selecting the correct version. This field is maintained by the `npm dist-tag`
    command.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`version`字段显然声明了当前包的版本。`dist-tags`字段列出了包维护者可以使用的符号标签，以帮助用户选择正确的版本。这个字段由`npm
    dist-tag`命令维护。'
- en: 'The `npm install` command supports these variants:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install`命令支持这些变体：'
- en: '[PRE33]js\1'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE33]js\1'
- en: '**GitHub shortcut**: For GitHub repositories, you can list just the repository
    specifier, such as `expressjs/express`. A tag or a commit can be referenced using `expressjs/express#tag-name`.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub快捷方式**：对于GitHub存储库，您可以只列出存储库标识符，例如`expressjs/express`。可以使用`expressjs/express#tag-name`引用标签或提交。'
- en: '**GitLab, BitBucket, and GitHub URL shortcuts**: In addition to the GitHub
    shortcut, npm supports a special URL format for specific Git services with URLs
    like `github:user/repo`, `bitbucket:user/repo`, and `gitlab:user/repo`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitLab、BitBucket和GitHub URL快捷方式**：除了GitHub快捷方式外，npm还支持特定Git服务的特殊URL格式，如`github:user/repo`、`bitbucket:user/repo`和`gitlab:user/repo`。'
- en: '**Local filesystem**: You can install from a local directory using a URL with
    the: `file:../../path/to/dir`.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地文件系统**：您可以使用URL从本地目录安装，格式为：`file:../../path/to/dir`。'
- en: Sometimes we need to install a package for use by several projects, without
    requiring that each project installs the package.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要安装一个包，以供多个项目使用，而不需要每个项目都安装该包。
- en: Global package installs
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局包安装
- en: 'In some instances, you want to install a module globally, so that it can be
    used from any directory. For example, the Grunt or Babel build tools are widely
    useful, and conceivably you will find it useful if these tools are installed globally.
    Simply add the `-g` option:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望全局安装一个模块，以便可以从任何目录中使用它。例如，Grunt或Babel构建工具非常有用，您可能会发现如果这些工具全局安装会很有用。只需添加`-g`选项：
- en: '[PRE34]js\1'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE34]js\1'
- en: This variant, of course, runs `npm install` with elevated permissions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种变体会以提升的权限运行`npm install`。
- en: The npm website offers a guideline with more information at [https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: npm网站提供了更多信息的指南，网址为[https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally)。
- en: 'If a local package install lands in `node_modules`, where does a global package
    install land? On a Unix-like system, it lands in `PREFIX/lib/node_modules`, and
    on Windows, it lands in `PREFIX/node_modules`. In this case, `PREFIX` means the
    directory where Node.js is installed. You can inspect the location of the directory
    as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本地软件包安装到`node_modules`中，全局软件包安装会在哪里？在类Unix系统上，它会安装到`PREFIX/lib/node_modules`中，在Windows上，它会安装到`PREFIX/node_modules`中。在这种情况下，`PREFIX`表示安装Node.js的目录。您可以按以下方式检查目录的位置：
- en: '[PRE35]js\1'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE35]js\1'
- en: 'With the `--save` flag, npm will add a `dependencies` tag to `package.json`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--save`标志，npm将在`package.json`中添加一个`dependencies`标签：
- en: '[PRE36]js\1'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE36]js\1'
- en: This installs the "production" version, which means to install only the modules
    listed in `dependencies` and none of the `devDependencies` modules. For example,
    if we use a build tool like Babel in development, the tool should not be installed
    in production.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装“生产”版本，这意味着只安装`dependencies`中列出的模块，而不安装`devDependencies`中的任何模块。例如，如果我们在开发中使用像Babel这样的构建工具，该工具就不应该在生产环境中安装。
- en: While we can manually maintain dependencies in `package.json`, npm can handle
    this for us.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在`package.json`中手动维护依赖关系，但npm可以为我们处理这些。
- en: Automatically updating package.json dependencies
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动更新package.json的依赖关系
- en: 'With npm@5 (also known as npm version 5), one change was that it''s no longer
    required to add `--save` to the `npm install` command. Instead, `npm` by default
    acts as if you ran the command with `--save`, and will automatically add the dependency
    to `package.json`. This is meant to simplify using `npm`, and it is arguably more
    convenient that `npm` now does this. At the same time, it can be very surprising
    and inconvenient for `npm` to go ahead and modify `package.json` for you. The
    behavior can be disabled by using the `--no-save` flag, or it can be permanently
    disabled using the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用npm@5（也称为npm版本5），一个变化是不再需要向`npm install`命令添加`--save`。相反，`npm`默认会像您使用了`--save`命令一样操作，并会自动将依赖项添加到`package.json`中。这旨在简化使用`npm`，可以说`npm`现在更方便了。与此同时，`npm`自动修改`package.json`对您来说可能会非常令人惊讶和不便。可以使用`--no-save`标志来禁用此行为，或者可以使用以下方法永久禁用：
- en: '[PRE37]js\1'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE37]js\1'
- en: This freezes your dependency on the specific version number. You're free, then,
    to take your time updating your code to work against later releases of the module. Once
    your code is updated, or the upstream project is updated, change the dependency
    appropriately.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将冻结您对特定版本号的依赖。然后，您可以自由地花时间更新您的代码以适应模块的后续版本。一旦您的代码更新了，或者上游项目更新了，就相应地更改依赖关系。
- en: When listing dependencies in `package.json`, it's tempting to be lazy, but that
    leads to trouble.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中列出依赖项时，很容易变懒，但这会导致麻烦。
- en: Explicitly specifying package dependency version numbers
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 明确指定软件包依赖版本号
- en: As we've said several times in this chapter, explicitly declaring your dependencies
    is A Good Thing. We've already touched on this, but it's worth reiterating and
    to see how npm makes this easy to accomplish.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中已经说过多次的那样，明确声明您的依赖关系是一件好事。我们已经提到过这一点，但值得重申并看看npm如何简化这一点。
- en: The first step is ensuring that your application code is checked into a source
    code repository. You probably already know this, and even have the best of intentions
    to ensure that everything is checked in. With Node.js, each module should have
    its own repository rather than putting every single last piece of code in one
    repository.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确保您的应用程序代码已经检入源代码存储库。您可能已经知道这一点，并且甚至打算确保所有内容都已检入。对于Node.js，每个模块应该有自己的存储库，而不是将每一个代码片段都放在一个存储库中。
- en: Each module can then progress on its own timeline. A breakage in one module
    is easy to back out by changing the version dependency in `package.json`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个模块可以按照自己的时间表进行进展。一个模块的故障很容易通过在`package.json`中更改版本依赖来撤消。
- en: The next step is to explicitly declare all dependencies of every module. The
    goal is simplifying and automating the process of setting up every module. Ideally,
    on the Node.js platform, the module setup is as simple as running `npm install`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是明确声明每个模块的所有依赖关系。目标是简化和自动化设置每个模块的过程。理想情况下，在Node.js平台上，模块设置就像运行`npm install`一样简单。
- en: Any additional required steps can be forgotten or executed incorrectly. An automated
    setup process eliminates several kinds of potential mistakes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 任何额外所需的步骤都可能被遗忘或执行不正确。自动设置过程消除了几种潜在的错误。
- en: With the `dependencies` and `devDependencies` sections of `package.json`, we
    can explicitly declare not only the dependencies but the precise version numbers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`package.json`的`dependencies`和`devDependencies`部分，我们不仅可以明确声明依赖关系，还可以指定版本号。
- en: The lazy way of declaring dependencies is putting `*` in the version field.
    That uses the latest version in the npm repository. This will seem to work, until
    that one day the maintainers of that package introduce a bug. You'll type `npm
    update`, and all of a sudden your code doesn't work. You'll head over to the GitHub
    site for the package, look in the issue queue, and possibly see that others have
    already reported the problem you're seeing. Some of them will say that they've
    pinned on the previous release until this bug is fixed. What that means is their `package.json` file
    does not depend on `*` for the latest version, but on a specific version number
    before the bug was created.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰地声明依赖关系的方法是在版本字段中放入`*`。这将使用npm存储库中的最新版本。这似乎有效，直到有一天，该软件包的维护者引入了一个bug。你会输入`npm
    update`，突然间你的代码就无法工作了。你会跳转到软件包的GitHub网站，查看问题队列，可能会看到其他人已经报告了你所看到的问题。其中一些人会说他们已经固定在之前的版本上，直到这个bug被修复。这意味着他们的`package.json`文件不依赖于最新版本的`*`，而是依赖于在bug产生之前的特定版本号。
- en: Don't do the lazy thing, do the smart thing.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 不要做懒惰的事情，做明智的事情。
- en: The other aspect of explicitly declaring dependencies is to not implicitly depend
    on global packages. Earlier, we said that some people in the Node.js community
    caution against installing modules in the global directories. This might seem
    like an easy shortcut to sharing code between applications. Just install it globally,
    and you don't have to install the code in each application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 明确声明依赖关系的另一个方面是不隐式依赖全局软件包。之前，我们说过Node.js社区中有些人警告不要在全局目录中安装模块。这可能看起来像在应用程序之间共享代码的一种简便方法。只需全局安装，你就不必在每个应用程序中安装代码。
- en: But, doesn't that make deployment harder? Will the new team member be instructed
    on all the special files to install here and there to make the application run?
    Will you remember to install that global module on all destination machines?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这会让部署变得更加困难吗？新的团队成员会被指示安装这里和那里的所有特殊文件来使应用程序运行吗？你会记得在所有目标机器上安装那个全局模块吗？
- en: For Node.js, that means listing all the module dependencies in `package.json`,
    and then the installation instructions are simply `npm install`, followed perhaps
    by editing a configuration file.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Node.js来说，这意味着列出`package.json`中的所有模块依赖项，然后安装指令就是简单的`npm install`，然后可能是编辑配置文件。
- en: While most packages in the npm repository are libraries with an API, some are
    tools we can run from the command line.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管npm存储库中的大多数软件包都是带有API的库，但有些是我们可以从命令行运行的工具。
- en: Packages that install commands
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装命令的软件包
- en: Some packages install command-line programs. A side effect of installing such
    packages is a new command that you can type at the shell prompt or use in shell
    scripts. An example is the `hexy` program that we briefly used in [Chapter 2](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml), *Setting
    Up Node.js*. Another example is the widely used Grunt or Babel build tools.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有些软件包安装命令行程序。安装这些软件包的一个副作用是，你可以在shell提示符下输入新的命令，或者在shell脚本中使用。一个例子是我们在[第2章](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml)中简要使用过的`hexy`程序，*设置Node.js*。另一个例子是广泛使用的Grunt或Babel构建工具。
- en: The recommendation to explicitly declare all dependencies in `package.json`
    applies to command-line tools as well as any other package. Therefore these packages
    will typically be installed locally. This requires special care in setting up
    the `PATH` environment variable correctly. As you should already be aware, the
    `PATH` variable is used on both Unix-like systems and Windows to list the directories
    in which the command-line shell searches for commands.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 明确声明所有依赖关系在`package.json`中的建议适用于命令行工具以及任何其他软件包。因此，这些软件包通常会被本地安装。这需要特别注意正确设置`PATH`环境变量。正如你可能已经知道的那样，`PATH`变量在类Unix系统和Windows上都用于列出命令行shell搜索命令的目录。
- en: 'The command can be installed to one of two places:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 命令可以安装到两个地方之一：
- en: '**Global install**: It is installed either to a directory, such as `/usr/local`,
    or to the `bin` directory where Node.js was installed. The `npm bin -g` command
    tells you the absolute pathname for this directory. In this case, it''s unlikely
    you''ll have to modify the PATH environment variable.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局安装**：它安装到一个目录，比如`/usr/local`，或者Node.js安装的`bin`目录。`npm bin -g`命令告诉你这个目录的绝对路径名。在这种情况下，你不太可能需要修改PATH环境变量。'
- en: '**Local install**: Installs to `node_modules/.bin` in the package where the
    module is being installed, the `npm bin` command tells you the absolute pathname
    for the directory. Because the directory is inconveniently located to run commands,
    a change to the PATH variable is useful.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地安装**：安装到正在安装模块的`package`中的`node_modules/.bin`，`npm bin`命令告诉你该目录的绝对路径名。因为该目录不方便运行命令，所以改变PATH变量是有用的。'
- en: To run the command, simply type the command name at a shell prompt. This works
    correctly if the directory where the command is installed happens to be in the
    PATH variable. Let's look at how to configure the PATH variable to handle locally
    installed commands.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行命令，只需在shell提示符下输入命令名称。如果命令安装的目录恰好在PATH变量中，这样就能正确运行。让我们看看如何配置PATH变量以处理本地安装的命令。
- en: Configuring the PATH variable to handle locally installed commands
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置PATH变量以处理本地安装的命令
- en: 'Assume we have installed the `hexy` command like so:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经安装了`hexy`命令，如下所示：
- en: '[PRE38]js\1'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE38]js\1'
- en: 'But this breaks because the command is not in a directory listed in the `PATH`.
    The workaround is to use the full pathname or relative pathname:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但这会出错，因为命令不在`PATH`中列出的目录中。解决方法是使用完整路径名或相对路径名：
- en: '[PRE39]js\1'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE39]js\1'
- en: The next step is adding the command to your login scripts so the variable is
    always set. On `bash`, add the corresponding line to `~/.bashrc`, and on `csh` add
    it to `~/.cshrc`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将命令添加到你的登录脚本中，这样变量就会一直设置。在`bash`上，添加相应的行到`~/.bashrc`，在`csh`上，添加到`~/.cshrc`。
- en: Once this is accomplished the command-line tool executes correctly.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了这一步，命令行工具就能正确执行。
- en: Configuring the PATH variable on Windows
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows上配置PATH变量
- en: 'On Windows, this task is handled through a system-wide settings panel:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，这个任务是通过系统范围的设置面板来处理的：
- en: '![](img/4e178c1e-2d36-4402-8e8e-713142886014.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e178c1e-2d36-4402-8e8e-713142886014.png)'
- en: This pane of the System Properties panel is found by searching for `PATH` in
    the Windows Settings screen. Click on the Environment Variables button, then select
    the Path variable, and finally click on the Edit button. On the screen here, click
    the New button to add an entry to this variable, and enter `.\node_modules\.bin` as
    shown. You'll have to restart any open command shell windows. Once you do, the
    effect will be as shown previously.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows设置屏幕中搜索`PATH`，可以找到`系统属性`面板的这个窗格。点击`环境变量`按钮，然后选择`Path`变量，最后点击`编辑`按钮。在这个屏幕上，点击`新建`按钮添加一个条目到这个变量中，并输入`.\node_modules\.bin`如图所示。你必须重新启动任何打开的命令行窗口。一旦你这样做了，效果就会如前所示。
- en: As easy as it is to modify the PATH variable, we don't want to do this in all
    circumstances.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管修改PATH变量很容易，但我们不希望在所有情况下都这样做。
- en: Avoiding modifications to the PATH variable
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免修改PATH变量
- en: What if you don't want to add these variables to your `PATH` at all times? The `npm-path` module
    may be of interest. This is a small program that computes the correct `PATH` variable
    for your shell and operating system. See the package at [https://www.npmjs.com/package/npm-path](https://www.npmjs.com/package/npm-path).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想始终将这些变量添加到你的`PATH`中怎么办？`npm-path`模块可能会引起你的兴趣。这是一个小程序，可以计算出适合你的shell和操作系统的正确`PATH`变量。查看[https://www.npmjs.com/package/npm-path](https://www.npmjs.com/package/npm-path)上的包。
- en: 'Another option is to use the `npx` command to execute such commands. This tool
    is automatically installed alongside the `npm` command. This command either executes
    commands from a locally installed package or it silently installs commands in
    a global cache:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用`npx`命令来执行这些命令。这个工具会自动安装在`npm`命令旁边。这个命令要么执行来自本地安装包的命令，要么在全局缓存中静默安装命令：
- en: '[PRE40]js\1'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE40]js\1'
- en: 'The report shows the current npm packages, the currently installed version,
    as well as the current version in the `npm` repository. Updating outdated packages
    is very simple:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 报告显示了当前的npm包、当前安装的版本，以及`npm`仓库中的当前版本。更新过时的包非常简单：
- en: '[PRE41]js\1'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE41]js\1'
- en: 'What''s important here is that we can add any script we like, and the `scripts`
    entry records the command to run:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们可以添加任何我们喜欢的脚本，`scripts`条目记录了要运行的命令：
- en: '[PRE42]js\1'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE42]js\1'
- en: With this combination, if the test author types `npm publish`, the `prepublish`
    script will cause the `test` script to run, which in turn uses `mocha` to run
    the test suite.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个组合，如果测试作者输入`npm publish`，`prepublish`脚本将导致`test`脚本运行，然后使用`mocha`运行测试套件。
- en: It is a well-known best practice to automate all administrative tasks, if only
    so that you never forget how to run those tasks. Creating the `scripts` entries
    for every such task not only prevents you from forgetting how to do things, but
    it also documents the administrative tasks for the benefit of others.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化所有管理任务是一个众所周知的最佳实践，即使只是为了你永远不会忘记如何运行这些任务。为每个这样的任务创建`scripts`条目不仅可以防止你忘记如何做事，还可以为他人记录管理任务。
- en: Next, let's talk about how to ensure the Node.js platform on which a package
    is executed supports the required features.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈如何确保执行包的Node.js平台支持所需的功能。
- en: Declaring Node.js version compatibility
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明Node.js版本兼容性
- en: It's important that your Node.js software runs on the correct version of Node.js.
    The primary reason being that the Node.js platform features required by your package
    are available every time your package is run. Therefore, the package author must
    know which Node.js releases are compatible with the package, and then describe
    in `package.json` that compatibility.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，你的Node.js软件必须在正确的Node.js版本上运行。主要原因是你的包运行时需要的Node.js平台功能必须可用。因此，包的作者必须知道哪些Node.js版本与包兼容，然后在`package.json`中描述这种兼容性。
- en: 'This dependency is declared in `package.json` using the `engines` tag:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖在`package.json`中使用`engines`标签声明：
- en: '```js\1'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '```js\1'
- en: The version string is similar to what we can use in `dependencies` and `devDependencies`.
    In this case, we've defined that the package is compatible with Node.js 8.x, 9.x,
    and 10.x.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 版本字符串类似于我们可以在`dependencies`和`devDependencies`中使用的。在这种情况下，我们定义了该包与Node.js 8.x、9.x和10.x兼容。
- en: Now that we know how to construct a package, let's talk about publishing packages.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何构建一个包，让我们谈谈发布包。
- en: Publishing an npm package
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布npm包
- en: All those packages in the npm repository came from people like you with an idea
    of a better way of doing something. It is very easy to get started with publishing
    packages.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: npm仓库中的所有这些包都来自像你一样有更好的做事方式的人。发布包非常容易入门。
- en: Online docs about publishing packages can be found at [https://docs.npmjs.com/getting-started/publishing-npm-packages](https://docs.npmjs.com/getting-started/publishing-npm-packages).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 关于发布包的在线文档可以在[https://docs.npmjs.com/getting-started/publishing-npm-packages](https://docs.npmjs.com/getting-started/publishing-npm-packages)找到。
- en: Also consider this: [https://xkcd.com/927/](https://xkcd.com/927/).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑这个：[https://xkcd.com/927/](https://xkcd.com/927/)。
- en: You first use the `npm adduser` command to register yourself with the npm repository.
    You can also sign up with the website. Next, you log in using the `npm login` command.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用`npm adduser`命令在npm仓库中注册。你也可以在网站上注册。接下来，使用`npm login`命令登录。
- en: Finally, while sitting in the package root directory, use the `npm publish` command.
    Then, stand back so that you don't get stampeded by the crush of thronging fans,
    or, maybe not. There are several zillion packages in the repository, with hundreds
    of packages added every day. To get yours to stand out, you will require some
    marketing skill, which is another topic beyond the scope of this book.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在包的根目录中使用`npm publish`命令。然后，退后一步，以免被涌入的粉丝踩到，或者可能不会。仓库中有数以亿计的包，每天都有数百个包被添加。要使你的包脱颖而出，你需要一些营销技巧，这是本书范围之外的另一个话题。
- en: It is suggested that your first package be a scoped package, for example, `@my-user-name/my-great-package`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你的第一个包是一个作用域包，例如`@my-user-name/my-great-package`。
- en: We've learned a lot in this section about using npm to manage and publish packages.
    But npm is not the only game in town for managing Node.js packages.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学到了很多关于使用npm来管理和发布包。但是npm并不是管理Node.js包的唯一选择。
- en: The Yarn package management system
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Yarn包管理系统
- en: As powerful as npm is, it is not the only package management system for Node.js.
    Because the Node.js core team does not dictate a package management system, the
    Node.js community is free to roll up their sleeves and develop any system they
    feel best. That the vast majority of us use npm is a testament to its value and
    usefulness. But, there is a significant competitor.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管npm非常强大，但它并不是Node.js的唯一包管理系统。因为Node.js核心团队并没有规定一个包管理系统，Node.js社区可以自由地开发他们认为最好的任何系统。我们绝大多数人使用npm是对其价值和有用性的证明。但是，还有一个重要的竞争对手。
- en: Yarn (see [https://yarnpkg.com/en/](https://yarnpkg.com/en/)) is a collaboration
    between engineers at Facebook, Google, and several other companies. They proclaim
    that Yarn is ultrafast, ultra-secure (by using checksums of everything), and ultrareliable
    (by using a `yarn-lock.json` file to record precise dependencies).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Yarn（参见[https://yarnpkg.com/en/](https://yarnpkg.com/en/)）是Facebook、Google和其他几家公司的工程师合作开发的。他们宣称Yarn是超快、超安全（通过使用所有内容的校验和）和超可靠（通过使用`yarn-lock.json`文件记录精确的依赖关系）。
- en: Instead of running their own package repository, Yarn runs on top of the npm
    package repository at `npmjs.com`. This means that the Node.js community is not
    forked by Yarn, but enhanced by having an improved package management tool.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Yarn不是运行自己的包存储库，而是在`npmjs.com`的npm包存储库上运行。这意味着Node.js社区并没有被Yarn分叉，而是通过一个改进的包管理工具得到了增强。
- en: The npm team responded to Yarn in npm@5 (also known as npm version 5) by improving
    performance and by introducing a `package-lock.json` file to improve reliability.
    The npm team has implemented additional improvements in npm@6.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: npm团队在npm@5（也称为npm版本5）中对Yarn做出了回应，通过提高性能和引入`package-lock.json`文件来提高可靠性。npm团队在npm@6中实施了额外的改进。
- en: Yarn has become very popular and is widely recommended over npm. They perform
    extremely similar functions, and the performance is not that different from npm@5\.
    The command-line options are worded differently. Everything we've discussed for
    npm is also supported by Yarn, albeit with slightly different command syntax.
    An important benefit Yarn brings to the Node.js community is that the competition
    between Yarn and npm seems to be breeding faster advances in Node.js package management
    overall.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Yarn已经变得非常流行，并且被广泛推荐用于npm。它们执行非常相似的功能，性能与npm@5并没有太大的不同。命令行选项的表述方式也有所不同。我们讨论过的npm的一切功能Yarn也都支持，尽管命令语法略有不同。Yarn给Node.js社区带来的一个重要好处是，Yarn和npm之间的竞争似乎正在促使Node.js包管理的更快进步。
- en: 'To get you started, these are the most important commands:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你开始，这些是最重要的命令：
- en: '`yarn add`: Adds a package to use in your current package'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn add`：将一个包添加到当前包中使用'
- en: '`yarn init`: Initializes the development of a package'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn init`：初始化一个包的开发'
- en: '`yarn install`: Installs all the dependencies defined in a `package.json` file'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn install`：安装`package.json`文件中定义的所有依赖项'
- en: '`yarn publish`: Publishes a package to a package manager'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn publish`：将包发布到包管理器'
- en: '`yarn remove`: Removes an unused package from your current package'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn remove`：从当前包中移除一个未使用的包'
- en: Running `yarn` by itself does the `yarn install` behavior. There are several
    other commands in Yarn, and `yarn help` will list them all.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`yarn`本身就会执行`yarn install`的行为。Yarn还有其他几个命令，`yarn help`会列出它们所有。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You learned a lot in this chapter about modules and packages for Node.js. Specifically,
    we covered implementing modules and packages for Node.js, the different module
    structures we can use, the difference between CommonJS and ES6 modules, managing
    installed modules and packages, how Node.js locates modules, the different types
    of modules and packages, how and why to declare dependencies on specific package
    versions, how to find third-party packages, and we gained a good grounding in
    using npm or Yarn to manage the packages we use and to publish our own packages.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了很多关于Node.js的模块和包。具体来说，我们涵盖了为Node.js实现模块和包，我们可以使用的不同模块结构，CommonJS和ES6模块之间的区别，管理已安装的模块和包，Node.js如何定位模块，不同类型的模块和包，如何以及为什么声明对特定包版本的依赖关系，如何找到第三方包，以及我们如何使用npm或Yarn来管理我们使用的包并发布我们自己的包。
- en: Now that you've learned about modules and packages, we're ready to use them
    to build applications, which we'll look at in the next chapter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了关于模块和包，我们准备使用它们来构建应用程序，在下一章中我们将看到。

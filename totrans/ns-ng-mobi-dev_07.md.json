["```ts\nnpm install nativescript-audio --save\n```", "```ts\n// libs\nimport { TNSPlayer } from 'nativescript-audio';\n\n// app\nimport { ITrack } from \n\n'./track.model';\n\ninterface ITrackPlayer {\n  trackId: number;\n  duration: number;\n  readonly \n\nplayer: TNSPlayer;\n}\n\nexport class TrackPlayerModel implements ITrackPlayer {\n  public trackId: \n\nnumber;\n  public duration: number;\n\n  private _player: TNSPlayer;\n\n  constructor() {\n\nthis._player = new TNSPlayer();\n  }\n\n  public load(track: ITrack): Promise<number> {\n    return \n\nnew Promise((resolve, reject) => {\n      this.trackId = track.id;\n\n      this._player.initFromFile({\n        audioFile: track.filepath,\n        loop: false\n      }).then(() => {\n\nthis._player.getAudioTrackDuration()\n          .then((duration) => {\n            this.duration = +duration;\n            resolve();\n          });\n      });\n    });\n  }\n\n  public get player(): \n\nTNSPlayer {\n    return this._player;\n  }\n}\n```", "```ts\nexport * from './composition.model';\nexport * from './track-player.model';\nexport * from \n\n'./track.model';\n```", "```ts\n// angular\nimport { Injectable } from '@angular/core';\n\n// libs\nimport { Subject } \n\nfrom 'rxjs/Subject';\nimport { Observable } from 'rxjs/Observable';\n\n// app\nimport { ITrack, CompositionModel, TrackPlayerModel } from '../../shared/models';\n\n@Injectable()\nexport class PlayerService {\n\n  // observable state\n  public playing$: \n\nSubject<boolean> = new Subject();\n public duration$: Subject<number> = new Subject\n\n();\n public currentTime$: Observable<number>;\n\n  // active composition\n  private _composition: CompositionModel;\n  // internal state \n  private _playing: \n\nboolean;\n  // collection of track players\n  private _trackPlayers: Array<TrackPlayerModel> \n\n= [];\n  // used to report currentTime from\n  private _longestTrack: \n\nTrackPlayerModel;\n\n  constructor() {\n    // observe currentTime changes every 1 seconds\n\nthis.currentTime$ = Observable.interval(1000)\n .map(_ => this._longestTrack ?\n this._longestTrack.player.currentTime\n : 0);\n  }\n\n  public set playing(value: boolean) \n\n{\n this._playing = value;\n this.playing$.next(value);\n }\n\n  public get playing(): boolean {\n return \n\nthis._playing;\n }\n\n public get composition(): CompositionModel \n\n{\n return this._composition;\n }\n\n  public set \n\ncomposition(comp: CompositionModel) {\n this._composition = comp;\n\n // clear any previous players\n this._resetTrackPlayers();\n // setup \n\nplayer instances for each track\n let initTrackPlayer = (index: number) => {\n let track = this._composition.tracks[index];\n let trackPlayer = new \n\nTrackPlayerModel();\n trackPlayer.load(track).then(_ => {\n\n this._trackPlayers.push(trackPlayer);\n index++;\n if (index < \n\nthis._composition.tracks.length) {\n initTrackPlayer(index);\n } \n\nelse {\n // report total duration of composition\n this._updateTotalDuration();\n }\n });\n };\n // kick off multi-track player initialization\n initTrackPlayer\n\n(0);\n }\n\n public togglePlay() {\n this.playing = \n\n!this.playing;\n if (this.playing) {\n this.play();\n } else {\n this.pause();\n }\n } \n\n  public play() {\n for (let t of this._trackPlayers) {\n t.player.play();\n }\n }\n\n public \n\npause() {\n for (let t of this._trackPlayers) {\n t.player.pause\n\n();\n }\n }\n\n  ...\n\n  private \n\n_updateTotalDuration() {\n // report longest track as the total duration of the mix\n let totalDuration = Math.max(\n ...this._trackPlayers.map(t => \n\nt.duration));\n // update trackPlayer to reflect longest track \n for (let \n\nt of this._trackPlayers) {\n if (t.duration === totalDuration) {\n this._longestTrack = t;\n break;\n }\n } \n this.duration$.next(totalDuration);\n }\n\n private _resetTrackPlayers() {\n for (let t of this._trackPlayers) {\n t.cleanup();\n }\n this._trackPlayers = [];\n } \n}\n```", "```ts\n...\n// observable state\npublic playing$: Subject<boolean> = new Subject();\npublic duration$: \n\nSubject<number> = new Subject();\npublic currentTime$: Observable<number>;\n\n// active \n\ncomposition\nprivate _composition: CompositionModel;\n// internal state \nprivate _playing: boolean;\n// \n\ncollection of track players\nprivate _trackPlayers: Array<TrackPlayerModel> = [];\n// used to report \n\ncurrentTime from\nprivate _longestTrack: TrackPlayerModel;\n\nconstructor() {\n  // observe currentTime \n\nchanges every 1 seconds\n  this.currentTime$ = Observable.interval(1000)\n    .map(_ => this._longestTrack ?\n      this._longestTrack.player.currentTime\n      : 0);\n  }\n  ...\n```", "```ts\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/observable/interval';\n```", "```ts\nimport './operators';\n...\n```", "```ts\npublic set playing(value: boolean) {\n  this._playing = value;\n  this.playing$.next(value);\n}\n\npublic get playing(): boolean {\n  return this._playing;\n}\n\npublic get composition(): CompositionModel \n\n{\n  return this._composition;\n}\n```", "```ts\npublic set composition(comp: CompositionModel) {\n  this._composition = comp;\n\n  // clear any previous \n\nplayers\n  this._resetTrackPlayers();\n  // setup player instances for each track\n  let initTrackPlayer = \n\n(index: number) => {\n    let track = this._composition.tracks[index];\n    let trackPlayer = new \n\nTrackPlayerModel();\n    trackPlayer.load(track).then(_ => {\n\n      this._trackPlayers.push\n\n(trackPlayer);\n      index++;\n      if (index < this._composition.tracks.length) {\n\ninitTrackPlayer(index);\n      } else {\n        // report total duration of composition\n\nthis._updateTotalDuration();\n      }\n    });\n  };\n  // kick off multi-track player initialization\n\n initTrackPlayer(0);\n}\n...\nprivate _resetTrackPlayers() {\n  for (let t of this._trackPlayers) {\n\n t.cleanup();\n  }\n  this._trackPlayers = [];\n}\n```", "```ts\nprivate _updateTotalDuration() {\n  // report longest track as the total duration of the mix\n  let \n\ntotalDuration = Math.max(\n    ...this._trackPlayers.map(t => t.duration));\n  // update trackPlayer to reflect \n\nlongest track \n  for (let t of this._trackPlayers) {\n    if (t.duration === totalDuration) {\n\nthis._longestTrack = t;\n      break;\n    }\n  }\n  this.duration$.next(totalDuration);\n}\n```", "```ts\npublic togglePlay() {\n  this.playing = !this.playing;\n  if (this.playing) {\n    this.play();\n  } \n\nelse {\n    this.pause();\n  }\n}\n\npublic play() {\n  for (let t of this._trackPlayers) {\n\n t.player.play();\n  }\n}\n\npublic pause() {\n  for (let t of this._trackPlayers) {\n\nt.player.pause();\n  }\n}\n```", "```ts\nprivate _demoComposition(): Array<IComposition> {\n  // starter composition for user to demo on first \n\nlaunch\n  return [\n    {\n      id: 1,\n      name: 'Demo',\n      created: Date.now(),\n\norder: 0,\n      tracks: [\n {\n id: 1,\n name: 'Drums',\n order: 0,\n filepath: \n\n'~/audio/drums.mp3'\n },\n {\n id: 2,\n name: 'Bass',\n order: 1,\n filepath: '~/audio/bass.mp3'\n },\n {\n id: 3,\n name: 'Piano',\n order: \n\n2,\n filepath: '~/audio/piano.mp3'\n }\n ]\n    }\n  ];\n}\n```", "```ts\n<action-bar [title]=\"composition.name\"></action-bar>\n<GridLayout rows=\"*, auto\" columns=\"*\" \n\nclass=\"page\">\n  <track-list [tracks]=\"composition.tracks\" row=\"0\" col=\"0\"> \n  </track-list>\n\n<player-controls [composition]=\"composition\"\n    row=\"1\" col=\"0\"></player-controls>\n</GridLayout>\n```", "```ts\n// angular\nimport { Component, Input } from '@angular/core';\n\n// libs\nimport { Subscription } from 'rxjs/Subscription';\n\n// app\nimport { ITrack, \n\nCompositionModel } from '../../../shared/models';\nimport { PlayerService } from '../../services';\n\n@Component({\n  moduleId: module.id,\n  selector: 'player-controls',\n  templateUrl: 'player-\n\ncontrols.component.html'\n})\nexport class PlayerControlsComponent {\n\n  @Input() composition: \n\nCompositionModel;\n\n  // ui state\n  public playStatus: string = 'Play';\n  public duration: \n\nnumber = 0;\n  public currentTime: number = 0;\n\n  // manage subscriptions\n  private _subPlaying: \n\nSubscription;\n private _subDuration: Subscription;\n private _subCurrentTime: \n\nSubscription;\n\n  constructor(\n    private playerService: PlayerService\n  ) { }\n\npublic togglePlay() {\n this.playerService.togglePlay();\n } \n\n  ngOnInit() {\n    // init audio player for composition\n\nthis.playerService.composition = this.composition;\n    // react to play state\n\nthis._subPlaying = this.playerService.playing$\n .subscribe((playing: boolean) => \n\n{\n        // update button state\n this._updateStatus(playing); \n        // \n\nupdate slider state\n if (playing) {\n this._subCurrentTime = \n\nthis.playerService\n .currentTime$\n .subscribe\n\n((currentTime: number) => {\n this.currentTime = currentTime;\n });\n } else if (this._subCurrentTime) {\n this._subCurrentTime.unsubscribe();\n }\n });\n    // \n\nupdate duration state for slider\n    this._subDuration = this.playerService.duration$\n .subscribe((duration: number) => {\n this.duration = duration;\n });\n  }\n\n  ngOnDestroy() {\n    // cleanup\n\nif (this._subPlaying)\n this._subPlaying.unsubscribe(); \n if \n\n(this._subDuration)\n this._subDuration.unsubscribe(); \n if \n\n(this._subCurrentTime)\n this._subCurrentTime.unsubscribe();\n  } \n\n  private _updateStatus(playing: boolean) {\n this.playStatus = \n\nplaying ? 'Stop' : 'Play';\n }\n}\n```", "```ts\nthis.currentTime$ = Observable.interval(1000)\n  .map(_ => this._longestTrack ?\n\nthis._longestTrack.player.currentTime\n    : 0);\n```", "```ts\n<GridLayout rows=\"100\" columns=\"100,*\"\n  row=\"1\" col=\"0\" class=\"p-x-10\">\n  <Button [text]\n\n=\"playStatus\" (tap)=\"togglePlay()\"\n    row=\"0\" col=\"0\" class=\"btn btn-primary w-\n\n100\"></Button>\n  <Slider [maxValue]=\"duration\" [value]=\"currentTime\" \n    minValue=\"0\" row=\"0\" col=\"1\" class=\"slider\">  \n  </Slider>\n</GridLayout>\n```", "```ts\n... export interface IPlayerError {\n trackId: number;\n error: any;\n}\n\nexport class TrackPlayerModel implements ITrackPlayer {\n\n  ...\n  private _completeHandler: (number) => void;\n private _errorHandler: \n\n(IPlayerError) => void;\n\n  ...\n\n  public load(\n    track: ITrack, \n\ncomplete: (number) => void, \n error: (IPlayerError) => void\n  ): \n\nPromise<number> {\n    return new Promise((resolve, reject) => {\n      ...\n\nthis._completeHandler = complete;\n this._errorHandler = error;\n\nthis._player.initFromFile({\n        audioFile: track.filepath,\n        loop: false,\n\ncompleteCallback: this._trackComplete.bind(this),\n errorCallback: \n\nthis._trackError.bind(this) ... private _trackComplete(args: any) {\n    // TODO: \n\nworks well for multi-tracks with same length\n    // may need to change in future with varied lengths\n\nthis.player.seekTo(0);\n    console.log('trackComplete:', this.trackId);\n    if (this._completeHandler)\n\nthis._completeHandler(this.trackId); \n  }\n\n  private _trackError(args: any) {\n    let error = \n\nargs.error;\n    console.log('trackError:', error);\n    if (this._errorHandler)\n      this._errorHandler({ \n\ntrackId: this.trackId, error }); \n }\n```", "```ts\nthis._player.initFromFile({\n  audioFile: track.filepath,\n  loop: false,\n  completeCallback: \n\nzonedCallback(this._trackComplete.bind(this)),\n  errorCallback: \n\nzonedCallback(this._trackError.bind(this))\n  ...\n```", "```ts\n// app\nimport { ITrack, CompositionModel, TrackPlayerModel, IPlayerError } from \n\n'../../shared/models';\n\n@Injectable()\nexport class PlayerService {\n\n  // observable state\n  ...\n  public complete$: Subject<number> = new Subject();\n  ... public set \n\ncomposition(comp: CompositionModel) {...let initTrackPlayer = (index: \n\nnumber) => {...trackPlayer.load(\n        track,\n\n   this._trackComplete.bind(this),\n        this._trackError.bind(this)\n\n  ...\n\n private _trackComplete(trackId: number) {\n    console.log('track complete:', trackId);\n    this.playing = \n\nfalse;\n    this.complete$.next(trackId);\n  }\n\n  private _trackError(playerError: IPlayerError) {\n\n  console.log(`trackId ${playerError.trackId} error:`,\n      playerError.error);\n  }\n  ...\n```", "```ts\n// angular\nimport { Injectable, NgZone } from '@angular/core';\n\n@Injectable()\n\nexport class PlayerService {\n\n  ...\n  constructor(private ngZone: NgZone) {}\n\n...\n  private _trackComplete(trackId: number) {\n    console.log('track complete:', trackId);\n\nthis.ngZone.run(() => {\n      this.playing = false;\n      this.complete$.next(trackId);\n\n   });\n  }\n  ...\n```", "```ts\nexport class PlayerControlsComponent {\n\n  ...\n  private _subComplete: Subscription;\n  ...\n  ngOnInit() {\n    ...\n    // completion should reset currentTime\n    this._subComplete \n\n= this.playerService.complete$.subscribe(_ => {\n this.currentTime = 0;\n });\n  }\n  ngOnDestroy() {\n    ...\n    if (this._subComplete) this._subComplete.unsubscribe(); \n  }\n  ...\n```", "```ts\n...\n// nativescript\nimport { isIOS } from 'platform';\n...\n\n@Injectable()\nexport class PlayerService {\n\n constructor() {\n   // observe currentTime changes \n\nevery 1 seconds\n   this.currentTime$ = Observable.interval(1000)\n     .map(_ => this._longestTrack ?\n\n  this._standardizeTime(\n this._longestTrack.player.currentTime)\n\n: 0;\n     );\n }\n ...\n private _updateTotalDuration() {\n   ...\n   // iOS: reports \n\nduration in seconds\n // Android: reports duration in milliseconds\n // \n\nstandardize to seconds\n   totalDuration = this._standardizeTime(totalDuration);\n\nconsole.log('totalDuration of mix:', totalDuration);\n   this.duration$.next(totalDuration);\n }\n ...\n\nprivate _standardizeTime(time: number) {\n return isIOS ? time : time * .001;\n }\n ...\n```", "```ts\npublic play() {\n  // for iOS playback sync\n let shortStartDelay = .01;\n let \n\nnow = 0;\n\n for (let i = 0; i < this._trackPlayers.length; i++) {\n let track = this._trackPlayers[i];\n if (isIOS) {\n if (i == 0) now = \n\ntrack.player.ios.deviceCurrentTime;\n (<any>track.player).playAtTime\n\n(now + shortStartDelay);\n } else {\n track.player.play\n\n();\n }\n } \n}\n```", "```ts\npublic pause() {\n  let currentTime = 0;\n\n for (let i = 0; i < \n\nthis._trackPlayers.length; i++) {\n let track = this._trackPlayers[i];\n if \n\n(i == 0) currentTime = track.player.currentTime;\n    track.player.pause();\n    // ensure tracks pause \n\nand remain paused at the same time\n    track.player.seekTo(currentTime);\n  }\n}\n```", "```ts\n<StackLayout row=\"1\" col=\"0\" class=\"controls\">\n  <shuttle-slider [currentTime]\n\n=\"currentTime\" \n [duration]=\"duration\"></shuttle-slider>\n  <Button \n\n[text]=\"playStatus\" (tap)=\"togglePlay()\"\n    class=\"btn btn-primary w-100\"></Button>\n</StackLayout>\n```", "```ts\n<GridLayout #sliderArea rows=\"auto, auto\" columns=\"auto,*,auto\" \n  class=\"slider-area\">\n  <Slider \n\n#slider slim-slider minValue=\"0\" [maxValue]=\"duration\"\n      colSpan=\"3\" class=\"slider\"></Slider>\n\n<Label #currentTimeDisplay text=\"00:00\" class=\"h4 m-x-5\" row=\"1\" col=\"0\">\n  </Label>\n  <Label \n\n[text]=\"durationDisplay\" class=\"h4 text-right m-x-5\"\n    row=\"1\" col=\"2\"></Label>\n</GridLayout>\n```", "```ts\n// angular\nimport { Component, Input, ViewChild, ElementRef } from '@angular/core';\n\n// \n\nnativescript\nimport { GestureTypes } from 'ui/gestures';\nimport { View } from 'ui/core/view';\nimport { Label \n\n} from 'ui/label';\nimport { Slider } from 'ui/slider';\nimport { Observable } from 'data/observable';\nimport \n\n{ isIOS, screen } from 'platform';\n\n// app\nimport { PlayerService } from '../../services';\n\n@Component({\n  moduleId: module.id,\n  selector: 'shuttle-slider',\n  templateUrl: 'shuttle-\n\nslider.component.html',\n  styles: [`\n    .slider-area {\n      margin: 10 10 0 10;\n    }\n\n.slider {\n      padding:0;\n      margin:0 0 5 0;\n      height:5;\n    }\n  `]\n})\nexport \n\nclass ShuttleSliderComponent {\n\n  @Input() currentTime: number; \n  @Input() duration: number; \n\n @ViewChild('sliderArea') sliderArea: ElementRef;\n  @ViewChild('slider') slider: ElementRef;\n\n@ViewChild('currentTimeDisplay') currentTimeDisplay: ElementRef;\n\n  public durationDisplay: string;\n\n  private _sliderArea: View;\n  private _currentTimeDisplay: Label;\n  private _slider: Slider;\n  private \n\n_screenWidth: number;\n  private _seekDelay: number;\n\n  constructor(private playerService: PlayerService) { \n\n}\n\n  ngOnChanges() {\n    if (typeof this.currentTime == 'number')   {\n      this._updateSlider\n\n(this.currentTime);\n    }\n    if (this.duration) {\n      this.durationDisplay = \n\nthis._timeDisplay(this.duration);\n    }\n  }\n\n  ngAfterViewInit() {\n    this._screenWidth = \n\nscreen.mainScreen.widthDIPs;\n    this._sliderArea = <View>this.sliderArea\n\n.nativeElement;\n    this._slider = <Slider>this.slider.nativeElement;\n    this._currentTimeDisplay = \n\n<Label>this.currentTimeDisplay\n                                 .nativeElement;\n\nthis._setupEventHandlers();\n  }\n\n  private _updateSlider(time: number) {\n    if (this._slider) \n\nthis._slider.value = time;\n    if (this._currentTimeDisplay)\n      this._currentTimeDisplay\n        .text = \n\nthis._timeDisplay(time);\n  }\n\n  private _setupEventHandlers() {\n    this._sliderArea.on\n\n(GestureTypes.touch, (args: any) => {\n      this.playerService.seeking = true;\n      let x = args.getX();\n\n      if (x >= 0) {\n        let percent = x / this._screenWidth;\n        if (percent > .5) {\n\n        percent += .05;\n        }\n        let seekTo = this.duration * percent;\n        this._updateSlider\n\n(seekTo);\n\n        if (this._seekDelay) clearTimeout(this._seekDelay);\n        this._seekDelay = setTimeout\n\n(() => {\n          // android requires milliseconds\n          this.playerService\n            .seekTo\n\n(isIOS ? seekTo : (seekTo*1000));\n        }, 600);\n      }\n    });\n  }\n\n  private \n\n_timeDisplay(seconds: number): string {\n    let hr: any = Math.floor(seconds / 3600);\n    let min: any = \n\nMath.floor((seconds - (hr * 3600))/60);\n    let sec: any = Math.floor(seconds - (hr * 3600) \n\n- (min * 60));\n    if (min < 10) { \n      min = '0' + min; \n    }\n    if (sec < 10){ \n\nsec = '0' + sec;\n    }\n    return min + ':' + sec;\n  }\n}\n```", "```ts\n@Input() currentTime: number; \n@Input() duration: number; \n\n// allows these property bindings to flow into our view:\n<shuttle-slider \n [currentTime]\n\n=\"currentTime\" \n  [duration]=\"duration\">\n</shuttle-slider>\n```", "```ts\n@ViewChild('sliderArea') sliderArea: ElementRef;\n@ViewChild('slider') \n\nslider: ElementRef;\n@ViewChild('currentTimeDisplay') currentTimeDisplay: ElementRef;\n\nprivate _sliderArea: StackLayout;\nprivate _currentTimeDisplay: Label;\nprivate _slider: Slider;// provides us with references to these view components<StackLayout \n\n#sliderArea class=\"slider-area\">\n  <Slider #slider slim-slider\n\nminValue=\"0 [maxValue]=\"duration\" class=\"slider\">\n  </Slider>\n  <GridLayout rows=\"auto\" \n\ncolumns=\"auto,*,auto\"\n    class=\"m-x-5\">\n    <Label #currentTimeDisplay text=\"00:00\" \n\nclass=\"h4\"\n      row=\"0\" col=\"0\"></Label>\n    <Label [text]=\"durationDisplay\" class=\"h4 text-right\" \n\n      row=\"0\" col=\"2\"></Label>\n  </GridLayout>\n</StackLayout>\n```", "```ts\nngAfterViewInit() {\n  *this._screenWidth = screen.mainScreen.widthDIPs;*\n  this._sliderArea = \n\n<StackLayout>this.sliderArea\n .nativeElement;\n this._slider = <Slider>this.slider.nativeElement;\n this._currentTimeDisplay = \n\n<Label>this.currentTimeDisplay\n .nativeElement;\n  *this._setupEventHandlers();*\n}\n```", "```ts\nprivate _setupEventHandlers() {\n  this._sliderArea.on(GestureTypes.touch, (args: any) => {\n\n*this.playerService.seeking = true; // TODO*\n\n    let x = args.getX();\n    if (x >= 0) {\n\n  // x percentage of screen left to right\n      let percent = x / this._screenWidth;\n      if (percent > .5) \n\n{\n        percent += .05; // non-precise adjustment\n      }\n      let seekTo = this.duration * percent;\n      this._updateSlider(seekTo);\n\n      if (this._seekDelay) clearTimeout(this._seekDelay);\n\nthis._seekDelay = setTimeout(() => {\n        // android requires milliseconds\n\nthis.playerService.seekTo(\n          isIOS ? seekTo : (seekTo*1000));\n      }, 600);\n    }\n  });\n}\n```", "```ts\nprivate _updateSlider(time: number) {\n  if (this._slider) this._slider.value = time;\n  if \n\n(this._currentTimeDisplay)\n    this._currentTimeDisplay.text = this._timeDisplay(time);\n}\n```", "```ts\nngOnChanges() {\n  if (typeof this.currentTime == 'number') {\n    this._updateSlider(this.currentTime);\n\n }\n  if (this.duration) {\n    this.durationDisplay = this._timeDisplay(this.duration);\n  }\n}\n```", "```ts\n*this.playerService.seeking = true; // TODO*\n```", "```ts\n...\nexport class PlayerService {\n\n  ...\n  // internal state \n  private _playing: boolean;\n  private _seeking: boolean;\n private _seekPaused: boolean;\n private _seekTimeout: number;\n  ...\n  constructor(private ngZone: NgZone) {\n    this.currentTime$ = \n\nObservable.interval(1000)\n      .switchMap(_ => {\n        if (this._seeking) \n\n{\n return Observable.never();\n } else if \n\n(this._longestTrack) {\n          return Observable.of(\n            this._standardizeTime(\n\nthis._longestTrack.player.currentTime));\n        } else {\n          return Observable.of(0);\n        }\n\n   });\n  }\n  ...\n  public set seeking(value: boolean) {\n this._seeking = \n\nvalue;\n if (this._playing && !this._seekPaused) {\n // pause \n\nwhile seeking\n this._seekPaused = true;\n this.pause();\n }\n if (this._seekTimeout) clearTimeout(this._seekTimeout);\n this._seekTimeout = setTimeout(() => {\n this._seeking = false;\n if \n\n(this._seekPaused) {\n // resume play\n this._seekPaused = \n\nfalse;\n this.play();\n }\n }, \n\n1000);\n }\n\n  public seekTo(time: number) {\n for \n\n(let track of this._trackPlayers) {\n track.player.seekTo(time);\n } \n }\n  ...\n```", "```ts\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/switchMap';\nimport \n\n'rxjs/add/observable/interval';\nimport 'rxjs/add/observable/never';\nimport \n\n'rxjs/add/observable/of';\n```", "```ts\n<Slider #slider slim-slider minValue=\"0\" [maxValue]=\"duration\" \n\nclass=\"slider\"></Slider>\n```", "```ts\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({\n selector: '[slim-\n\nslider]'\n})\nexport class SlimSliderDirective {\n\n  constructor(private el: ElementRef) { } \n\nngOnInit() {\n    let uiSlider = <UISlider>this.el.nativeElement.ios;\n    uiSlider.userInteractionEnabled = \n\nfalse;\n    uiSlider.setThumbImageForState(\n      UIImage.new(), UIControlState.Normal);\n  }\n}\n```", "```ts\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({\n  selector: '[slim-\n\nslider]'\n})\nexport class SlimSliderDirective {\n\n  constructor(private el: ElementRef) { } \n\nngOnInit() {\n    let seekBar = <android.widget.SeekBar>this.el\n                  .nativeElement.android;\n    seekBar.setOnTouchListener(\n      new android.view.View.OnTouchListener({\n        onTouch(view, event) {\n          return true;\n        }\n      })\n    );\n    seekBar.getThumb().mutate().setAlpha(0);\n\n}\n}\n```", "```ts\nexport declare class SlimSliderDirective { }\n```", "```ts\nimport { SlimSliderDirective } from './slider.directive';\n\nexport const DIRECTIVES: any[] = [\n\nSlimSliderDirective\n];\n```", "```ts\n...\nimport { DIRECTIVES } from './directives';\n...\n\n@NgModule({\n  ...\n  declarations: [\n    ...COMPONENTS,\n    ...DIRECTIVES\n  ],\n  ...\n})\nexport class PlayerModule { }\n```"]
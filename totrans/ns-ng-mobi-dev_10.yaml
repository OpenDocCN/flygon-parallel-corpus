- en: '@ngrx/store + @ngrx/effects for State Management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing state in any app can become troubling as the app scales over time.
    We want to have full confidence over the predictability of our app's behavior
    and getting a hang of its state is key to gaining that confidence.
  prefs: []
  type: TYPE_NORMAL
- en: State can be broadly defined as the particular condition that someone or something
    is in at a specific time. With regard to our app, the state can encompass whether
    our player is playing or not, whether the recorder is recording or not, and whether
    the track list UI is in mixing mode or not.
  prefs: []
  type: TYPE_NORMAL
- en: Storing state in a single spot allows you to know exactly what the state of
    the app is at any given moment. Without a single store, you usually wind up with
    state buried throughout different components and services, which often leads to
    two or more different versions of state as features are built out. This unwieldy
    growth of state becomes even more troublesome as different features need to interact
    with each other, which may or may not necessarily depend on each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what Redux is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what ngrx is and how it relates to Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining state for an app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating @ngrx/store to manage state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what @ngrx/effects are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating side effects to aid our state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going from *inactive to reactive* with our code base (Mike Ryan/Brandon Roberts^(TM))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Redux and integrating @ngrx/store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux is an open source library that defines itself as a predictable state container
    for JavaScript apps. The concepts are not exactly new, but the details were developed
    by Dan Abramov in 2015 who was influenced by Facebook's Flux and the functional
    programming language, Elm. It quickly gained popularity among the React community
    as it was used throughout Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t want to redefine what Redux is, so we will quote directly from the
    Redux repo ([https://github.com/reactjs/redux](https://github.com/reactjs/redux)):'
  prefs: []
  type: TYPE_NORMAL
- en: The whole state of your app is stored in an object tree inside a single *store*.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to change the state tree is to emit an *action*, an object describing
    what happened.
  prefs: []
  type: TYPE_NORMAL
- en: To specify how the actions transform the state tree, you write pure *reducers*.
  prefs: []
  type: TYPE_NORMAL
- en: That's it!
  prefs: []
  type: TYPE_NORMAL
- en: The concept is fairly simple and quite brilliant. You emit actions (which are
    simple string typed objects with a payload representing the data to be passed
    along) against the system, which wind up hitting a reducer (a pure function) to
    define how state is transformed by these actions.
  prefs: []
  type: TYPE_NORMAL
- en: It's important not to confuse transform with mutate. One of the fundamental
    concepts of Redux is that all state is **immutable**; hence, each reducer is a
    **pure** function.
  prefs: []
  type: TYPE_NORMAL
- en: A pure function always returns the same results given the same parameters. Its
    execution does not depend on the state of the system as a whole [[https://en.wikipedia.org/wiki/Pure_function](https://en.wikipedia.org/wiki/Pure_function)].
  prefs: []
  type: TYPE_NORMAL
- en: So, although a reducer transforms state, it does not mutate it.
  prefs: []
  type: TYPE_NORMAL
- en: In depth, engineering studies have been done on change detection systems and
    how object equality/reference checks are superior in speed when compared to object
    comparison checks on deeply nested properties. We won't go into detail for the
    reasons for this, but immutability of your app's data flow has significant impact
    on how you can fine-tune its performance, especially with regard to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Along with performance enhancements, the concepts of Redux further enhance decoupling
    across your entire code base, leading to the reduction of various dependencies
    spread throughout. With the power of actions describing the various interactions
    our app entails, we no longer need to inject explicit service dependencies to
    execute its APIs. Instead, we can simply emit actions and the principles of Redux
    will work for us to propagate and handle the necessary functionality our app demands,
    all the while maintaining a single and dependable source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: What is @ngrx/store?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Early in the rewrite of Angular (from 1.x to 2.x+), a core team member turned
    developer advocate at Google, Rob Wormald, developed **ngrx/store** as an "*RxJS
    powered state management [system] for Angular applications, inspired by Redux."*
    The key point in that phrase is the term "**RxJS"**. Hence the name **ngrx** derives
    its name from joining "**ng"** for A**ng**ular with "**rx"** from **Rx**JS. The
    open source library quickly gained highly-talented contributors such as Mike Ryan,
    Brian Troncone, and Brandon Roberts and took off to become an extremely intelligent
    and powerful state management system for modern Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is heavily inspired by Redux and utilizes the same concepts, it
    is uniquely different in making RxJS a first-class citizen in how the system is
    wired. It brings **Observables** full circle throughout all the concepts of Redux,
    enabling truly **reactive** user interfaces and apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all these concepts are new to you, Brian Troncone''s thorough post will
    definitely help you gain more understanding as we won''t be able to cover every
    detail of ngrx here. Please see this post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://gist.github.com/btroncone/a6e4347326749f938510](https://gist.github.com/btroncone/a6e4347326749f938510)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the state model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before integrating ngrx, it''s good to first think about the various aspects
    of state throughout your app in addition to which module they might pertain to.
    With our app, here''s a reasonable starter list (*not meant to be complete or
    thorough at this point*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`CoreModule`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user: any;` user-related state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recentUsername: string`; most recently used successful username'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current: any`; authenticated user (if there is one)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MixerModule`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mixer: any`: mixer-related state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compositions: Array<IComposition>`; list of user-saved compositions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activeComposition: CompositionModel`; the active composition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerModule`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`player: any`; various aspects of player state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playing: boolean`; whether audio is playing or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duration: number`; total duration of playback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`completed: boolean`; whether playback reached the end and is completed. This
    will help determine the difference between when the user stops playback or when
    it autostops due to the player reaching the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seeking: boolean`; whether playback seeking is in progress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecorderModule`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recorder: RecordState`; recording state represented simply by an enum'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No module in particular, just state we want to observe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ui: any`; user interface state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trackListViewType: string`; the currently active view toggle for track listing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key point here is not to worry about getting this exactly right the first
    time. It's hard to know the precise state model when you first build an app, and
    it will most likely change a bit over time and that's okay.
  prefs: []
  type: TYPE_NORMAL
- en: State for our app is better known at this time because we have already built
    a working app, so this is a tad bit easier. Typically, mapping this out before
    you build an app is more difficult; however, again, don't worry about getting
    it right the first time! You can easily refactor and tweak it over time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take this state and work it into our app with ngrx.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and integrating @ngrx/store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to first install `@ngrx/store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can now provide the single store to our app via the `StoreModule`. We define
    these initial slices of state in our `CoreModule`, which will be available when
    the app boots, while each lazy loaded feature module adds its own state and reducers
    later when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Providing the initial app state excluding any lazily loaded module state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to start by defining the initial app state, excluding any lazily loaded
    feature module state. Since our `CoreModule` provides `AuthService`, which deals
    with handling our user, we will consider the **user** slice a fundamental key
    to our app's initial state.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, let's begin by defining the shape of our user state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `app/modules/core/states/user.state.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our user state is very simple. It contains a `recentUsername` representing a
    string of the most recently successfully authenticated username (useful if the
    user were to log out and return to log in later). Then, we have **current**, which
    will represent a user object if authenticated, or null if not. We also include
    a `loginCanceled` boolean since we surmise it may be useful for analyzing user
    interaction if we were to start reporting state as analytics data.
  prefs: []
  type: TYPE_NORMAL
- en: Any data points around authentication can be critical to understanding our app's
    user base. For example, it might be insightful to learn whether or not requiring
    authentication to record was causing more canceled logins than signups, which
    may have a direct affect on user retention.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be consistent with our approach throughout this book, also create `app/modules/core/states/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create our user actions; create `app/modules/core/actions/user.action.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, follow up with our standard; create `app/modules/core/actions/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay now, what''s going on with those actions?! Here''s what we''ve defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INIT`: To initialize the user right when the app launches. In other words,
    this action will be used to check persistence and restore a user object onto the
    app''s state at launch time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOGIN`: Begin the login sequence. In our app, this will show the login dialog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOGIN_SUCCESS`: Since login is asynchronous, this action will dispatch once
    login is complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOGIN_CANCELED`: If the user cancels login.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOGOUT`: When user logs out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPDATED`: We will use this as a simple action to update our user state. This
    will generally not be dispatched directly, but will be used in the reducer we''ll
    create in a moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The formalities you see here provide a consistent and strongly-typed structure.
    By utilizing a namespace, we are able to uniquely identify this set of actions
    with a name, `UserActions`. This allows the interior naming to remain the same
    across many other namespaced actions we will create for the lazy loaded modules
    state, providing a great standard to work with. The `CATEGORY` is necessary because
    every action must be unique, not just in this set of actions but across the entire
    app. The interfaces help provide good intelligence when using our actions, in
    addition to type safety. The various action classes help ensure that all actions
    dispatched are new instances and provide a powerful way to strongly type our action
    payloads. This also makes our code easy to refactor down the line. The last utility
    in our structure is the union type at the bottom, which helps our reducer determine
    the applicable actions it should be concerned with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of that reducer, let''s create it now: `app/modules/core/reducers/user.reducer.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The reducer is incredibly simple. As mentioned, it is a pure function that takes
    in the existing state along with an action and returns a new state (as a new Object
    unless it's the default starting case). This maintains immutability and keeps
    things quite elegant. The `UPDATED` action will always be the last in any action
    chain to fire off and ultimately change the user state. In this case, we'll keep
    things simple and allow our `UPDATED` action to be the only action that actually
    changes the user state. The other actions will set up a chain, whereby they end
    up dispatching `UPDATED` if they need the user state to change. You could certainly
    set up more cases here based on our actions to change the state; however, in our
    app, this will be the only action that ultimately changes the user state.
  prefs: []
  type: TYPE_NORMAL
- en: '*Action chain?* What on earth do we mean by an *Action chain*?! You may be
    wondering how we wire these actions to interplay with each other if needed?'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and integrating @ngrx/effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without redefining, let''s look at the description of @ngrx/effects straight
    from the repo ([https://github.com/ngrx/effects](https://github.com/ngrx/effects)):'
  prefs: []
  type: TYPE_NORMAL
- en: In `@ngrx/effects`, effects are the sources of actions. You use the `@Effect()`
    decorator to hint which observables on a service are action sources, and `@ngrx/effects`
    automatically merges your action streams, letting you subscribe them to store.
  prefs: []
  type: TYPE_NORMAL
- en: To help you compose new action sources, `@ngrx/effects` exports an action observable
    service that emits every action dispatched in your application.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we can chain our actions together with effects to provide powerful
    data flow composition throughout our app. They allow us to insert behavior that
    should take place between when an action is dispatched and before the state is
    ultimately changed. The most common use case is to handle HTTP requests and/or
    other asynchronous operations; however, they have many useful applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use, let''s first install `@ngrx/effects`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now let's take a look at what our user actions look like in an effect chain.
  prefs: []
  type: TYPE_NORMAL
- en: Real quickly, though, to remain consistent with our naming structure, let's
    rename `auth.service.ts` to `user.service.ts`. It helps when we have a naming
    standard that is consistent across the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create `app/modules/core/effects/user.effect.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We have clarified the intent of our data flow concerning our `UserService`
    and delegated the responsibility to this effect chain. This allows us to compose
    our data flow in a clear and consistent manner with a great deal of flexibility
    and power. For instance, our `InitAction` chain now allows us to automatically
    initialize the user via the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we were calling a private method--`this._init()`--inside the service
    constructor; however, we no longer need explicit calls like that as effects are
    run and queued up once the module is bootstrapped. The `.startWith` operator will
    cause the observable to fire off one single time (at the point of module creation),
    allowing the init sequence to be executed at a particularly opportune time, when
    our app is initializing. Our initialization sequence is the same as we were previously
    handling in the service; however, this time we''re taking into consideration our
    new `recentUsername` persisted value (if one exists). We then end the init sequence
    with a `UserActions.UpdatedAction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there''s no effect chain wired to `UserActions.ActionTypes.UPDATED`.
    This is because there are no side effects that should occur by the time that `Action`
    occurs. Since there are no more side effects, the observable sequence ends up
    in the reducer that has a `switch` statement to handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This takes the payload (which is typed as the shape of the user state, `IUserState`)
    and overwrites the values in the existing state to return a brand new user state.
    Importantly, `Object.assign` allows any existing values in the source object to
    not be overridden unless explicitly defined by the incoming payload. This allows
    only new incoming payload values to be reflected on our state, while still maintaining
    the existing values.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of our `UserEffect` chain is fairly self-explanatory. Primarily, it's
    handling much of what the service was previously handling, with the exception
    of prompting the login dialog, which the effect chain is utilizing the service
    method to do. However, it's worth mentioning that we can go so far as to completely
    remove this service as the contents of the `promptLogin` method can easily be
    carried out directly in our effect now.
  prefs: []
  type: TYPE_NORMAL
- en: When deciding if you should handle more logic in your effect or a designated
    service, it really comes down to personal preference and/or scalability. If you
    have rather lengthy service logic and more than a couple of methods to handle
    logic while working with effects, creating a designated service will help greatly.
    You can scale more functionality into the service without diluting the clarity
    of your effects chain.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, unit testing will be easier with a designated service with more logic.
    In this case, our logic is fairly simple; however, we'll leave the `UserService`
    for example purposes as well as best practice.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of, let's take a look at how simplified our `UserService` looks now
  prefs: []
  type: TYPE_NORMAL
- en: 'in `app/modules/core/services/user.service.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It's much cleaner now. Okay, so how do we let our app know about all this new
    goodness?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s follow one of our standards by adding an index to our entire
    core module; add `app/modules/core/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We simply export all the goodies our core module now provides, including the
    module itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, open `app/modules/core/core.module.ts` to finish our wiring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we ensure that we define our `user` state key to use the `userReducer`
    and register it with `StoreModule`. We then call `EffectsModule.forRoot()`, with
    a collection of singleton effect providers to register like our `UserEffects`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at how this improves the rest of the code base since
    we were undoubtedly injecting the `UserService` (previously named `AuthService`)
    in a couple of places.
  prefs: []
  type: TYPE_NORMAL
- en: 'We were previously injecting `AuthService` in `AppComponent` to ensure that
    Angular''s dependency injection constructed it early on when the app was bootstrapped,
    creating the necessary singleton our app needed. However, with `UserEffects` automatically
    running now on bootstrap, which in turn injects (now renamed) `UserService`, we
    no longer need this rather silly necessity anymore, so, we can update `AppComponent`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In one swoop, our code base is now getting smarter and slimmer. Let's keep going
    to see other benefits of our ngrx integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app/auth-guard.service.ts`, and we can now make the following simplifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When activating the `/record` route, we dispatch the `LoginAction` every time
    since we require an authenticated user to use the recording features. Our login
    effects chain properly handles if the user is already authenticated, so all we
    need to do is set up our state subscription to react accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Ngrx is flexible, and how you set up your actions and effects chains is purely
    up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Providing lazily loaded feature module state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now build out the scalable ngrx structure into our various feature modules,
    which will provide state. Starting with `MixerModule`, let''s modify `app/modules/mixer/mixer.module.ts`
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are defining what the `MixerModule` state will provide. Now, let's
    define its shape; create
  prefs: []
  type: TYPE_NORMAL
- en: '`app/modules/mixer/states/mixer.state.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To be consistent with our approach throughout this book, also create `app/modules/mixer/states/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create our mixer actions; create `app/modules/mixer/actions/mixer.action.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to our UserActions, we will also use an `INIT` action to autoinitialize
    this state with user-saved compositions (or our sample demo composition to start).
    Here''s a quick rundown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INIT`: To initialize the mixer right when the app launches. Just as we did
    with `UserActions`, this action will be used to check persistence and restore
    any user-saved compositions onto the mixer state at launch time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD`: Show the add new composition dialog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EDIT`: Edit a composition''s name by prompting a dialog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SAVE`: Save compositions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CANCEL`: General action to cancel out of any effect chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT`: Select a composition. We will use this action to drive the Angular
    router to the main selected composition view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPEN_RECORD`: Handle the preparation of opening the recording view, including
    checking for authentication, pausing playback if playing, and opening in modal
    or routing to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPDATE`: Initiate an update to a composition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPDATED`: This will generally not be dispatched directly, but used at the
    end of an effect sequence that the reducer will pick up to finally change the
    mixer state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can create the reducer that is similar to our user reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, let''s create our `MixerEffects` at `app/modules/mixer/effects/mixer.effect.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Probably, the most interesting effect is the`openRecord$` chain. We use `@Effect({
    dispatch: false })` to indicate that it should not dispatch any actions at the
    end as we are using it to execute work directly, such as checking whether the user
    is authenticated or if `activeComposition` contains tracks to conditionally open
    record view in a modal or as a route. We make use of another operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to insert an arbitrary action without affecting the sequence
    of events. In this case, we ensure that playback is always paused when the user
    attempts to open a record view (since they can attempt to open the record view
    while playback is playing). We are presenting a few more advanced usage options
    with this chain, just to show what is possible. We are also stepping ahead a bit
    since we have not shown the creation of `PlayerActions` yet; however, we will
    just be presenting a couple of highlights in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this effect chain, we can simplify our `MixerService` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We've simplified the service logic, leaving most of the result handling work
    inside the effects chain. You might decide to leave the service with more logic and
    keep the effects chain simpler; however, we have designed this setup as an example
    to show more alternate setups with how flexible ngrx is.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish up our lazy loaded state handling, ensure that these effects are
    run; when `MixerModule` loads, we can make these adjustments to the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at how this improves our component handling, starting with `app/modules/mixer/components/mixer.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This time, inside `ngOnInit`, we just set up the component to be reactive to
    our mixer's state by setting the composition to the `activeComposition`. This
    is guaranteed to always be whichever composition the user has currently selected
    and is working on. We dispatch our `OpenRecordAction` inside the `record` method,
    passing along the proper `ViewContainerRef` and a track if the user is rerecording.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the simplification of `app/modules/mixer/components/mix-list.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have removed the `MixerService` injection and made it reactive by setting
    up a state Observable--`mixer$`--and integrated our `MixerActions`. This lightens
    up the component, making it easier to test and maintain since it no longer has
    an explicit dependency on the `MixerService`, which was previously being used
    for view bindings as well. If we take a look at the view, we can now utilize Angular''s
    async pipe to gain access to the user-saved compositions via the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'From the official documentation: Angular''s async pipe subscribes to an Observable
    or Promise and returns the latest value it has emitted. When a new value is emitted,
    the async pipe marks the component to be checked for changes. When the component
    gets destroyed, the async pipe unsubscribes automatically to avoid potential memory
    leaks.'
  prefs: []
  type: TYPE_NORMAL
- en: This is truly remarkable and incredibly handy, allowing us to create reactive
    components that're highly maintainable and flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the code! Exploring more on your own
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since a lot of what we saw earlier are the exact same principles applied to
    the rest of our code base, instead of increasing the size of this book further,
    we invite you to explore the rest of the ngrx integration in the same chapter
    branch on the accompanying code repository to this book.
  prefs: []
  type: TYPE_NORMAL
- en: Looking through the actual code, running it, and even stepping through it will
    hopefully give you a solid understanding of how ngrx fits into your app and the
    many advantages it can bring.
  prefs: []
  type: TYPE_NORMAL
- en: The community is lucky to have members like Rob Wormald, Mike Ryan, Brian Troncone,
    Brandon Roberts, and more, who have helped make ngrx so nice to use, so a **huge
    thank you to all the contributors**!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, you are starting to see a pattern of simplification and clarity to
    the data flow while integrating ngrx. It has helped reduce code, while improving
    data flow by providing consistent effect chains to various actions, which may
    need to occur anywhere (from lazy loaded modules or not). By reducing the overhead
    of managing explicit injected dependencies throughout and instead relying on Store
    and Actions to initiate the appropriate work, we are increasing the maintainability
    and scalability of our app. On top of all that, it is paving a pathway to effective
    testability, which we will cover in [Chapter 12](part0136.html#41MCG0-289fe2426d594f99a90e4363b2c9c34d),
    *Unit Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter highlighted the additional advantages when combining NativeScript
    with Angular by opening up integration potential with rich libraries such as ngrx to
    improve our app's architecture and data flow.
  prefs: []
  type: TYPE_NORMAL
- en: It's been a long time coming, and we couldn't be more excited about [Chapter
    11](part0131.html#3STPM0-289fe2426d594f99a90e4363b2c9c34d), *Polish with SASS*, coming
    up next. Finally, we are ready to polish our app to give it that special spark!
  prefs: []
  type: TYPE_NORMAL

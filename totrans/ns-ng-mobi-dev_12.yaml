- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start this chapter with testing; most people think testing is boring.
    Guess what, they are mostly right! Testing can be fun in that you get to try and
    break your code, but it can sometimes be tedious work. However, it can help you
    catch mistakes before your customers do, and as a bonus, it can prevent you from
    making the same bug occur multiple times. How much is your reputation to your
    clients or customers worth? A little tedious work could mean the difference between
    a Triple-A application, and a mediocre application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular Testing Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NativeScript Testing Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write tests using Jasmine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run Karma tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests are used to test small pieces of application code functionality for
    correctness. This also allows us to verify that the functionality continues to
    work as expected, when you refactor code and/or add new features. Both NativeScript
    and Angular offer unit testing frameworks. We will explore both types of unit
    testing, as they both have pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: Developing tests at any time is good. However, it is preferable to develop them
    alongside your development of the project's code. Your mind will be fresh on the
    new features, modifications, and all the new code you just added. In our case,
    because we are presenting lots of new concepts throughout this book, we haven't
    followed the best practice since it would have complicated the book even more.
    So, although adding tests later is good, adding them before or while adding your
    new code is considered the best practice.
  prefs: []
  type: TYPE_NORMAL
- en: Angular testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first type of unit testing we will cover is Angular unit testing. It is
    based around **Karma** ([https://karma-runner.github.io/](https://karma-runner.github.io/))
    and **Jasmine** ([http://github.com/pivotal/jasmine](http://github.com/pivotal/jasmine)).
    Karma is a full-featured test runner, which was produced by the Angular team.
    When the team was implementing Angular, they ran into issues , such as figuring
    out how to test Angular, so they built Karma. Karma has ended up becoming an industry-standard
    multipurpose test runner. Jasmine is an open source testing framework that implements
    a number of testing constructs helps you do all your testing easily. It has been
    around a lot longer than Karma. Since it was in use by a lot of people before
    Karma, it became the default testing library in the Angular community. You are
    free to use any of the other frameworks, such as Mocha, Chia, or even your own
    home-grown testing framework. However, since almost everything you will see in
    the Angular community is based around Jasmine, we will use it also.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get the pieces you need installed for Angular testing in NativeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You also should probably install Karma globally, especially on Windows. However,
    it is helpful to do so on other platforms also so that you can just type `karma`
    and it runs. In order to do that, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t have TypeScript installed globally, where you can just type `tsc`,
    and it builds, you should install it globally. You have to transpile your TypeScript
    into JavaScript before running any tests. To install TypeScript globally, type
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Karma was designed to run tests inside a browser; however, NativeScript code
    does not run in a browser at all. So, we have to do a couple of things differently
    to make the standard Karma testing system run with some NativeScript application
    code. The normal Angular-specific Karma configuration won't work in most cases.
    If you are going to do any Angular work with the web side of things, you should
    check out the standard Angular testing QuickStart project ([https://github.com/angular/quickstart/](https://github.com/angular/quickstart/)).
    That project will get everything set up for a traditional Angular application
    that runs in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in our case, because we are using NativeScript Angular, we will need
    a totally customized `Karma.conf.js` file. We have included it in the custom config
    file in the git repo, or you can type it from here. Save this file as `Karma.ang.conf.js`**.**
    We are giving a different configuration name because the NativeScript testing
    we discuss later will use the default `Karma.conf.js` name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This configuration sets it up so that Karma will use Jasmine, Browserify, and
    Chrome to run all the tests. Since Karma and Angular were designed for browsers
    first, all the testing still has to run inside a browser. This is the major downside
    for the Angular testing system when doing NativeScript code. It won't support
    any NativeScript-specific code. So, this type of testing is better done on files
    that are data models and/or any code that has no NativeScript-specific code in
    it, which unfortunately in some of your apps might not be very much code. However,
    if you are doing both a NativeScript and web application using the same code base,
    then you should have a lot of code that can run through the standard Angular testing
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Angular testing, you will create Jasmine specification files, and they
    all end with `.spec.ts`. We must create these files in the same directory as the
    code you are testing. So, let''s take a crack at creating a new specification
    file for testing. Since this type of unit testing does not allow you to use any
    NativeScript code, I chose a random model file to show how easy this type of unit
    testing is. Let''s create a file called `track.model.spec.ts` in the `app/modules/shared/models`
    folder; this file will be used to test the `track.model.ts` file in that same
    folder. Here is our test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, let's break this down. The first line fixes an issue with testing inside
    a browser with a TypeScript-built file that uses modules. As I noted in the comments,
    this should be added to all your `spec.ts` files. The next line is where we load
    our model that we will test; you can import any files that you need here, including
    the Angular library.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a `.spec.js` file is just a normal TypeScript file; the only thing
     that differentiates it is that it has access to Jasmine globalized functions,
    and runs in a browser. So, all your normal TypeScript code will work fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line is where we start the actual testing framework. It is a
    Jasmine function that is used to create a test. Jasmine uses a `describe` function
    to start a group of tests. Describe has two parameters: the text description to
    print, and then the actual function to run. So, we basically put in the name of
    the model we are testing and then create the function. Inside each `describe`
    function, we add as many `it` functions as we need. Each `it` is used for a subset
    of the tests. You can also have multiple `describes`, if necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: So, in our test here, we have four separate test groups; the first one is really
    just to verify that everything is correct. It simply makes sure that our model
    gets defined properly. So, we are just using the Jasmine `expect` command to test
    for a valid object that was created with the `.toBeDefined()` function. Simple,
    isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: The next test set attempts to make sure that the defaults are set properly from
    the `beforeEach` function. As you can see, we are using the `expect` command again
    with the `.toBe(value)` function. This is actually highly recommended; it seems
    obvious that the values set should match the values read, but you want to treat
    your modules as a black box. Verify all input and output to make sure that it
    really is set the same way you set it. So, even though we know we set ID to 1,
    we are verifying that when we get the ID, it still equals 1.
  prefs: []
  type: TYPE_NORMAL
- en: The third test function starts testing the mute capability, and the final one
    tests the volume functionality. Note that both the *mute* and *volume* have several
    states and/or impact multiple variables. Anything that is beyond a simple assignment
    should be tested through every single state you know of, both valid and invalid,
    if possible. In our case, we noted that mute affects volume and vice versa. So,
    we verify that when one has changed, the other changes with it. This is used as
    a contract to make sure that, down the road if this class changes, it will remain
    the same externally, or our tests will break. In this case, this is more of a
    brown-box; we know a side-effect of mute, and we are depending on that side-effect
    in the application, so we will test for that side-effect to make sure that it
    never changes.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s run the test by typing `tsc` to create the transpiled JS files,
    and then running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Karma will then find ALL of the `.spec.js` files and then run all of them on
    your Chrome browser, testing all the functionalities that you defined in each
    `.spec.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Unexpected test failure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now isn''t it very interesting that one of our tests actually failed; `TrackModel
    Creation Verify mute FAILED` and **`Expected 1 to be 5.`**. This failure was not
    preplanned for the book; it is actually a real corner case that we just found
    because we started to use unit testing. If you want to take a quick look at the
    code, here is the `TrackModel.ts` code stripped down to just show the relevant
    routines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, I'll give you a few minutes to look at the preceding test code and this
    code and check whether you can spot why the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: Good, I see, you are back; did you see where the corner case is? Don't feel
    bad if you couldn't find it quickly; it took me a few minutes to figure out why
    it was failing also.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, first, look at the error message; it said `Verify Mute FAILED`, so this
    means it was our mute test that failed. Then, we put `Verify mute` in the `it`
    function that tested our mute functionality. The second clue is the error, `Expected
    1 to be 5`.So, we expected something to be 5, but it was actually 1\. So, this
    specific test and this line of code are failing in the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Why did it fail?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the test initialization, `beforeEach`; you will
    see that ``mute: false``. Well, next, let''s look at the constructor; it basically
    does `this.mute = false` and the mute setter then runs down its `else` path, which
    is `this.volume = this._origVolume`. Guess what? `this._origVolume` has not been
    set yet, so it sets `this.volume = undefined`. Now take a look at the volume routine;
    the new volume comes in `undefined`, it is set to `1`, which overrides our original
    setting of 5\. So, the test `Expected 1 to be 5.` fails.'
  prefs: []
  type: TYPE_NORMAL
- en: Interesting corner case; it wouldn't have happened if we hadn't set `mute` to
    `false` as part of testing the initialization of properties. However this is something
    we should test, because maybe in one of the revisions of the application we will
    store the mute value and restore it on start.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we should fix the class a little. We'll let you do the changes
    that you think are necessary to fix this issue. If you get stuck, you can rename
    the `track.model.fixed.ts` based on the `track.model.ts` file; it contains the
    correct code.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have it fixed, run the same `tsc` and then the `karma start karma.ang.conf.js` command;
    you should see everything is successfull.
  prefs: []
  type: TYPE_NORMAL
- en: Test passes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As this example pinpointed, your code might run correctly in some cases, but
    fail in others. Unit testing can pinpoint errors in your logic that you might
    not see readily. This is especially important when adding new features and/or
    fixing bugs. It is highly recommended that you create new tests for both, and
    then you will know at least at a minimum that your new or modified code is behaving
    properly after you make any code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's switch gears slightly, and look at the NativeScript testing framework;
    the Angular framework is pretty cool, but it has the nasty limitation of not having
    NativeScript framework calls available, so it limits a lot of its usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: NativeScript testing framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, be ready to play with the NativeScript testing framework. It is fairly
    simple to install, you simply type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There is no reason to switch testing frameworks, so choose `jasmine` at the
    prompt asking you which testing framework to use with the NativeScript testing
    framework. This will install all the needed resources for the NativeScript testing
    system. NativeScript's testing system also uses Karma, and it supports a couple
    of different testing frameworks, but for consistency, we will want to continue
    to use Jasmine.
  prefs: []
  type: TYPE_NORMAL
- en: Remember earlier when I said Karma uses a browser to do all its tests, and I
    also said that NativeScript code doesn't run in a browser? So, why does NativeScript
    use Karma? How does Karma run the NativeScript code? Excellent questions! Karma
    is actually tricked into thinking that your NativeScript application is a browser.
    Karma uploads the tests to the browser (that is, the NativeScript application),
    and it then runs them. So, in effect, your application is a browser to Karma;
    this is a pretty ingenious solution by the NativeScript team.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the big pro of the NativeScript testing system is that it can actually
    test all your NativeScript code. It will automatically run a special build of
    your application in your emulator (or on a real device) so that it can run all
    the NativeScript code and access the device properly. The biggest con of the NativeScript
    testing system is that it requires a lot more resources because it must use an
    emulator (or real device) to run the tests. So, it can be considerably more time-consuming
    to run testing than the standard unit testing we discussed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so now you have it all installed. Let's move on. All of the NativeScript
    testing files will be in the `app/tests` folder. This folder was created when
    you ran the `tns test init`. If you open up that folder, you will see `example.js`.
    Feel free to delete or leave the file. It is just a dummy test to show you how
    to format your tests using Jasmine.
  prefs: []
  type: TYPE_NORMAL
- en: So, for our NativeScript test, I selected a simple service that uses NativeScript
    code. Let's create our `database.service.test.ts` file in the `app/test` folder.
    Your files in this folder can be named anything but, to keep things easier to
    find, we will end it with `.test.ts`. You can also create subdirectories to organize
    all your tests. In this case, we will test the `app/modules/core/services/database.service.ts`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This specific service, if you look at the code, actually uses the NativeScript
    `AppSettings` module to store and retrieve data from the Android and iOS system-wide
    storage system. So, this is a great file to test. Let''s create our test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You might already be able to read this test file pretty easily. Basically, it
    calls the database service a couple of times to set the same key with different
    values. Then, it asks the database service to return the values stored and verifies
    that the results match what we stored. Then, we tell the database service to delete
    our storage key and verify that the key is gone, all pretty straightforward. The
    only thing different in this file is the `include 'reflect-metadata'`. This is
    because the database service uses metadata in it, so we have to make sure that
    the metadata class is loaded before we load the database service class.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try testing the application; to run your tests, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the testing, and you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that there is an `ERROR` on this screen; this is a false error. Basically,
    when the app finishes running its tests, it quits. Karma sees that the application
    has quit unexpectedly and logs it as an `"ERROR" Disconnected`. The import information
    is the line below the error, where it says `Executed 2 of 2 SUCCESS`. This means
    that it ran two different `described` tests (that is, our `test.ts` file and the
    extra `example.js` file).
  prefs: []
  type: TYPE_NORMAL
- en: You might have also noted that our test file is identical to the Angular testing
    file. That is because they both use Jasmine and Karma. So, the test files can
    be set up almost identically. In this specific case, because the testing is actually
    running inside your application, any plugins, code, and modules, including any
    native code are all available to be tested. This is what makes the NativeScript
    testing harness a lot more powerful and useful. However, its greatest strength
    is also its weakness. Since it has to run inside a running NativeScript application,
    it takes a lot more time to build, start, and run all the tests. This is where
    the standard Angular testing framework can prove beneficial over the NativeScript
    testing framework. Anything that is not using any NativeScript-specific code can
    run from your command line almost instantly, with very little overhead. The quicker
    your tests run, the more likely you are to run them frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to do unit tests and the pros and cons of
    two of the methods of doing unit tests. In a nutshell, Angular testing works for
    generic TypeScript code that does not call any NativeScript-specific code, and
    it runs your tests really quickly. The NativeScript testing harness runs inside
    your NativeScript application and has full access to anything you write and anything
    a normal NativeScript application can do. However, it requires the NativeScript
    application to be running to run its tests, so it might require a full build step
    before it can run your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the two types of unit testing, hang on to your testing
    hat. In the next chapter, we will cover how to do end-to-end testing or full screen
    and application testing of your awesome application.
  prefs: []
  type: TYPE_NORMAL

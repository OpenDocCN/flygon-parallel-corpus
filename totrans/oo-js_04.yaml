- en: Chapter 4. Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've mastered JavaScript's primitive data types, arrays, and functions,
    it's time to stay true to the promise of the book title and talk about objects.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has an eccentric take on the classical Object-oriented programming.
    Object-oriented programming is one of the most popular programming paradigms and
    has been a mainstay in most of programming languages like Java and C++. There
    are well defined ideas proposed by classical OOP that most of these languages
    adopt. JavaScript, however, has a different take on it. We will look JavaScript's
    way of supporting OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create and use objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the constructor functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What types of built-in JavaScript objects exist and what they can do for you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From arrays to objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you already know from [Chapter 2](ch02.html "Chapter 2. Primitive Data Types,
    Arrays, Loops, and Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*,
    an array is just a list of values. Each value has an index (a numeric key) that
    starts from zero and increments by one for each value. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you put the indexes in one column and the values in another, you''ll end
    up with a table of key/value pairs shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | red |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | blue |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | yellow |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | purple |'
  prefs: []
  type: TYPE_TB
- en: An object is similar to an array, but the difference is that you define the
    keys yourself. You're not limited to using only numeric indexes, and you can use
    friendlier keys such as `first_name`, `age`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple object and examine its parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the variable that refers to the object is `hero`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of `[` and `]`, which you use to define an array, you use `{` and `}`
    for objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You separate the elements (called properties) contained in the object with commas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key/value pairs are divided by colons, as in `key:value`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The keys (names of the properties) can optionally be placed in quotation marks.
    For example, these keys are all the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s recommended that you don''t quote the names of the properties (it''s
    less typing), but there are cases when you must use quotes. Some of the cases
    are stated here:'
  prefs: []
  type: TYPE_NORMAL
- en: If the property name is one of the reserved words in JavaScript (see [Appendix
    A](apa.html "Appendix A. Reserved Words"), *Reserved Words*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it contains spaces or special characters (anything other than letters, numbers,
    and the `_` and `$` characters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it starts with a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, if the name you have chosen for a property is not a valid name
    for a variable in JavaScript, then you need to wrap it in quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at this bizarre-looking object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is a valid object. The quotes are required for the second and the third
    properties; otherwise, you'll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, you'll see other ways to define objects and arrays, in
    addition to `[]` and `{}`. However, first, let's introduce this bit of terminology
    - defining an array with `[]` is called **array literal notation**, and defining
    an object using curly braces `{}` is called **object literal notation**.
  prefs: []
  type: TYPE_NORMAL
- en: Elements, properties, methods, and members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When talking about arrays, you say that they contain elements. When talking
    about objects, you say that they contain properties. There isn't any significant
    difference in JavaScript; it's just the terminology that people are used to, probably
    from other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'A property of an object can point to a function, because functions are just
    data. Properties that point to functions are also called methods. In the following
    example, `talk` is a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have seen in the previous chapter, it''s also possible to store functions
    as array elements and invoke them, but you''ll not see much code like this in
    practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can also see people using the word members to refer to the properties of
    an object, most often when it doesn't matter if the property is a function or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Hashes and associative arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some programming languages, there is a distinction between:'
  prefs: []
  type: TYPE_NORMAL
- en: A regular array, also called an **indexed** or **enumerated** array (the keys
    are numbers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An associative array, also called a **hash** or a **dictionary** (the keys are
    strings)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript uses arrays to represent indexed arrays and objects to represent
    associative arrays. If you want a hash in JavaScript, you use an object.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an object's properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to access the property of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the square bracket notation, for example, `hero['occupation']`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the dot notation, for example, `hero.occupation`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dot notation is easier to read and write, but it cannot always be used.
    The same rules apply for quoting property names. If the name of the property is
    not a valid variable name, you cannot use the dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the `hero` object again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is an example for accessing a property with the dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example for accessing a property with the bracket notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example for accessing a non-existing property returns
    `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Objects can contain any data, including other objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To get to the `firstname` property of the object contained in the `author`
    property of the `book` object, you can use the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let see an example using the square brackets notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It works even if you mix both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Another case where you need square brackets is when the name of the property
    you need to access is not known beforehand. During runtime, it''s dynamically
    stored in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Calling an object's methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You know a method is just a property that happens to be a function, so you
    access methods in the same way in which you would access properties-using the
    dot notation or using square brackets. Calling (invoking) a method is the same
    as calling any other function - you just add parentheses after the method name,
    which effectively says Execute!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are any parameters that you want to pass to a method, you would proceed
    as you would with normal functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can use the array-like square brackets to access a property, it means
    you can also use brackets to access and invoke methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not a common practice, unless the method name is not known at the time
    of writing code, but it is instead defined at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No quotes unless you have to use the dot notation to access methods and properties,
    and don't quote properties in your object literals.
  prefs: []
  type: TYPE_NORMAL
- en: Altering properties/methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript allows you to alter the properties and methods of existing objects
    at any time. This includes adding new properties or deleting them. You can start
    with a blank object and add properties later. Let's see how you can go about doing
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'An object without properties is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A "blank" object**'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you started with a "blank" object, `var hero = {}`. Blank is
    in quotes because this object is not really empty and useless. Although at this
    stage it has no properties of its own, it has already inherited some.
  prefs: []
  type: TYPE_NORMAL
- en: You'll learn more about own versus inherited properties later. So, an object
    in ES3 is never really blank or empty. In ES5 though, there is a way to create
    a completely blank object that doesn't inherit anything, but let's not get ahead
    too much.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the code to access an non-existing property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding two properties and a method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting a property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call the method again, it will no longer find the deleted `name` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Malleable objects**'
  prefs: []
  type: TYPE_NORMAL
- en: You can always change any object at any time, such as adding and removing properties
    and changing their values. However, there are exceptions to this rule. A few properties
    of some built-in objects are not changeable (for example, `Math.PI`, as you'll
    see later). Also, ES5 allows you to prevent changes to objects. You'll learn more
    about it in [Appendix C](apc.html "Appendix C. Built-in Objects"), *Built-in Objects*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the this value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, the `sayName()` method used `hero.name` to access
    the `name` property of the `hero` object. When you''re inside a method though,
    there is another way to access the object the method belongs to. This method is
    using the special value `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So, when you say `this`, you're actually saying-this object or the current object.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another way to create objects-using constructor functions. Let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to create an object using this function, you can use the `new` operator
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A benefit of using constructor functions is that they accept parameters, which
    can be used when creating new objects. Let''s modify the constructor to accept
    one parameter and assign it to the `name` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can create different objects using the same constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By convention, you should capitalize the first letter of your constructor functions
    so that you have a visual clue that they are not intended to be called as regular
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you call a function that is designed to be a constructor but you omit the
    `new` operator, it is not an error. However, it doesn''t give you the expected
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What happened here? There is no `new` operator, so a new object was not created.
    The function was called like any other function, so the variable `h` contains
    the value that the function returns. The function does not return anything (there's
    no `return` function), so it actually returns `undefined`, which gets assigned
    to the variable `h`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, what does `this` refer to? It refers to the global object.
  prefs: []
  type: TYPE_NORMAL
- en: The global object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have already learned a bit about global variables (and how you should avoid
    them). You also know that JavaScript programs run inside a host environment (the
    browser, for example). Now that you know about objects, it's time for the whole
    truth, the host environment provides a global object, and all global variables
    are accessible as properties of the global object.
  prefs: []
  type: TYPE_NORMAL
- en: If your host environment is the web browser, the global object is called **window**.
    Another way to access the global object (and this is also true in most other environments)
    is to use `this` keyword outside a constructor function, for example in the global
    program code outside any function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an illustration, you can declare a global variable outside any function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can access this global variable in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: As a variable `a`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a property of the global object, for example, `window['a']` or `window.a`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a property of the global object referred to as `this`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let's go back to the case where you define a constructor function and call it
    without the `new` operator. In such cases, `this` refers to the global object
    and all the properties set to `this` become properties of `window`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring a constructor function and calling it without new returns `"undefined"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As you had `this` keyword inside the function `Hero`, a global variable (a
    property of the global object) called `name` was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call the same constructor function using `new`, then a new object is
    returned, and `this` refers to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in global functions you have seen in [Chapter 3](ch03.html "Chapter 3. Functions"),
    *Functions*, can also be invoked as methods of the `window` object. So, the following
    two calls have the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The constructor property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an object is created, a special property is assigned to it behind the scenes-the
    `constructor` property. It contains a reference to the constructor function used
    to create `this` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `constructor` property contains a reference to a function, you might
    as well call this function to produce a new object. The following code is like
    saying, "I don''t care how object `h2` was created, but I want another one just
    like it":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If an object was created using the object literal notation, its constructor
    is the built-in `Object()` constructor function (there is more about this later
    in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The instanceof operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the `instanceof` operator, you can test whether an object was created
    with a specific `constructor` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that you don't put parentheses after the function name (you don't use `h
    instanceof Hero()`). This is because you're not invoking this function, but just
    referring to it by name, as with any other variable.
  prefs: []
  type: TYPE_NORMAL
- en: Functions that return objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to using `constructor` functions and the `new` operator to create
    objects, you can also use a normal function to create objects without the `new`
    operator. You can have a function that does a bit of preparatory work and has
    an object as a return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s a simple `factory()` function that produces objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example using the `factory()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In fact, you can also use `constructor` functions and `return` objects different
    from `this` keyword. This means you can modify the default behavior of the `constructor`
    function. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the normal constructor scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'However, now, look at this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: What happened here? Instead of returning the `this` object, which contains the
    property `a`, the constructor returned another object that contains the property
    `b`. This is possible only if the return value is an object. Otherwise, if you
    try to return anything that is not an object, the constructor will proceed with
    its usual behavior and return `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think about how objects are created inside constructor functions, you
    can imagine that a variable called `this` is defined at the top of the function
    and then returned at the end. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Passing objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you assign an object to a different variable or pass it to a function,
    you only pass a reference to that object. Consequently, if you make a change to
    the reference, you're actually modifying the original object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of how you can assign an object to another variable and
    then make a change to the copy. As a result, the original object is also changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The same thing applies when passing objects to functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Comparing objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you compare objects, you'll get `true` only if you compare two references
    to the same object. If you compare two distinct objects that happen to have the
    exact same methods and properties, the result would be `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two objects that look the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing them returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a new variable, `mydog`, and assign one of the objects to it.
    This way, the variable `mydog` actually points to the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `benji` is `mydog` because they are the same object (changing
    the `mydog` variable''s properties will change the `benji` variable''s properties).
    The comparison returns `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As `fido` is a different object, it does not compare to `mydog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Objects in the WebKit console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into the built-in objects in JavaScript, let's quickly say a few
    words about working with objects in the WebKit console.
  prefs: []
  type: TYPE_NORMAL
- en: After playing around with the examples in this chapter, you might have already
    noticed how objects are displayed in the console. If you create an object and
    type its name, you'll get an arrow pointing to the word object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object is clickable and expands to show you a list of all of the properties
    of the object. If a property is also an object, there is an arrow next to it too,
    so you can expand this as well. This is handy as it gives you an insight into
    exactly what this object contains. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Objects in the WebKit console](graphics/image_04_001-e1482749176512.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can ignore `__proto__` for now; there's more about it in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Logging using the console.log method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The console also offers you an object called `console` and a few methods, such
    as `console.log()` and `console.error()`, which you can use to display any value
    you want in the console.
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging using the console.log method](graphics/image_04_002-e1482749557416.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `console.log()` method is convenient when you want to quickly test something,
    as well as when you want to dump some intermediate debugging information in your
    real scripts. Here''s how you can experiment with loops, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: ES6 object literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES6 introduces a much succinct syntax while using object literals. ES6 offers
    several shorthands for property initialization and function definitions. ES6 shorthands
    closely resemble a familiar JSON syntax. Consider the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a typical way to assign property values. If the name of the variable
    and the property key is the same, ES6 allows you to use shorthand syntax. The
    preceding code can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar syntax is available for method definitions as well. As we have discussed,
    methods are simply properties of an object whose values are functions. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a compact way to define methods in ES6\. You simply drop the `function`
    keyword and `:`. The equivalent code in ES6 would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'ES6 allows you to compute the key of a property. Until ES6, you could only
    use fixed property names. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are limited to using fixed key names: `prop` and `modifier`
    in this case. However, ES6 allows you to use computed property keys. It is possible
    to create property keys dynamically using values returned by a function as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We are using the value of variable `vehicle` to concatenate with a fixed string
    to derive the property key while creating the `car` object. In the second snippet,
    we are creating a property by concatenating a fixed string with the value returned
    by a function. This way of computing property keys provides great flexibility
    while creating objects, and a lot of boilerplate and repetitive code can be eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'This syntax is applicable to method definition as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Object properties and attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each object has a few properties. Each property, in turn, has a key and attributes.
    A property''s state is stored in these attributes. All properties have the following
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enumerable (boolean)**: This indicates if you can enumerate the properties
    of the object. System properties are non-enumerable while user properties are
    enumerable. Unless there is a strong reason, this property should remain untouched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configurable(boolean)**: If this attribute is `false`, the property cannot
    be deleted or edited (it cannot change any of its attribute).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use the `Object.getOwnPropertyDescriptor()` method to retrieve an object''s
    own properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Meanwhile, the property can be defined using the `Object.defineProperty() method`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Though you would never use these methods, it is important to understand object
    properties and attributes. In the next section, we will discuss how some of the
    `object` methods are used in context of some of these properties.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 object methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 introduces a few static helper methods for objects. `Object.assign` is a
    helper method that replaces popular mixins to perform a shallow copy of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Copy properties using Object.assign
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This method is used to copy properties of the target object into the source
    object. In other words, this method merges the source object with the target object
    and modifies the target object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter to `Object.assign` is the target on which source properties
    are copied. The same target object is returned to the caller. Existing properties
    are overwritten, while properties that aren''t part of the source object are ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.assign` can take multiple source objects. You can write `Object.assign(target,
    source1, source2)`. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we are assigning properties from multiple source objects. Also,
    notice how `Object.assign()` returns the target object, which we in turn use inside
    `console.log()`.
  prefs: []
  type: TYPE_NORMAL
- en: One point to note is that only enumerable own (non-inherited) properties can
    be copied using `Object.assign()`. Properties from the prototype chain (will be
    discussed later in this chapter when we talk about Inheritance) are not considered.
    Our earlier discussion of enumerable properties will help you understand this
    distinction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will create a non-enumerable property using `defineProperty()`
    and validate the fact that `Object.assign()` ignores that property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The property defined as `superpowers` has the enumerable attribute set to `false`.
    While copying properties, this property is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Compare values with Object.is
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES6 provides a slightly precise way of comparing values. We have discussed
    the strict equality operator `===`. However, for `NaN` and `-0` and `+0`, the
    strict equality operator behaves inconsistently. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Apart from these two cases, `Object.is()` can safely be replaced with the `===`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will be working with objects and arrays all the time when you code. JavaScript
    object and array notations resemble the JSON format. You will define objects and
    arrays, and then retrieve elements from them. ES6 gives a convenient syntax that
    significantly improves the way we access properties/members from objects and arrays.
    Let''s consider a typical code you would often write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Here, we extracted values of server and port from the `config` object and assigned
    them to local variables. Pretty straightforward! However, when this object has
    a bunch of properties, some of them nested, this simple operation can get very
    tedious to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES6 destructuring syntax allows an object literal on the left-hand side of
    an assignment statement. In the following example, we will define an object `config`
    with a few properties. Later, we will use destructuring to assign the object `config`
    to assign values to individual properties on the left-hand side of the assignment
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see `server` and `port` are local variables that got assigned properties
    from the `config` object because the name of the properties were the same as that
    of the local variables. You can also pick particular properties while you assign
    them to local variables. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are only picking `timeout` from the `config` object and assign it to
    a local variable `t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the destructuring syntax to assign values to already declared
    variables. In this case, you have to put parentheses around the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'As the destructuring expression evaluates to the right-hand side of the expression,
    it''s possible to use it anywhere you would expect a value. For example, in a
    function call, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If you specify a local variable with a property name that does not exist in
    the object, the local variable gets an `undefined` value. However, while using
    variables in the destructuring assignment, you can optionally specify default
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In this example, for a non-existent property timeout, we provided a default
    value to prevent getting `undefined` values assigned to local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructuring works on arrays as well, and the syntax is also very similar
    to that of the objects. We just need to replace object literal syntax with `array:literals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is the exact same syntax we saw earlier. We defined an
    array `arr` and later used the destructuring syntax to assign elements of that
    array to two local variables, `x` and `y`. Here, the assignment happens based
    on the order of elements in the array. As you only care about the position of
    elements, you can skip some of them if you want to. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we know that we need elements from positions 2 and 3 (an array''s index
    starts from 0), and hence, we ignore elements at positions 0 and 1\. Array destructuring
    can eliminate the use of a `temp` variable while swapping values of two variables.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the rest operator (`...`) to extract remaining elements and assign
    them to an array. The rest operator can only be used as the last operator during
    destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Built-in objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, you came across the `Object()` constructor function.
    It's returned when you create objects with the object literal notation and access
    their `constructor` property. `Object()` is one of the built-in constructors;
    there are a few others, and in the rest of this chapter you'll see all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in objects can be divided into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data wrapper objects**: These are `Object`, `Array`, `Function`, `Boolean`,
    `Number`, and `String`. These objects correspond to the different data types in
    JavaScript. There is a data wrapper object for every different value returned
    by `typeof` (discussed in [Chapter 2](ch02.html "Chapter 2. Primitive Data Types,
    Arrays, Loops, and Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*),
    with the exception of `undefined` and `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility objects**: These are `Math`, `Date`, and `RegExp`, and can come in
    handy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error objects**: These include the generic `Error` object as well as other
    more specific objects that can help your program recover its working state when
    something unexpected happens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only a handful of methods of the built-in objects will be discussed in this
    chapter. For a full reference, see [Appendix C](apc.html "Appendix C. Built-in
    Objects"), *Built-in Objects*.
  prefs: []
  type: TYPE_NORMAL
- en: If you're confused about what a built-in object is and what a built-in constructor
    is, well, they are the same thing. In a moment, you'll see how functions and,
    therefore, constructor functions, are also objects.
  prefs: []
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Object is the parent of all JavaScript objects, which means that every object
    you create inherits from it. To create a new empty object, you can use the literal
    notation or the `Object()` constructor function. The following two lines are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned before, an empty (or blank) object is not completely useless,
    because it already contains several inherited methods and properties. In this
    book, empty means an object like `{}` that has no properties of its own, other
    than the ones it automatically gets. Let''s look at a few of the properties that
    even blank objects already have:'
  prefs: []
  type: TYPE_NORMAL
- en: The `o.constructor` property returns a reference to the constructor function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `o.toString()` is a method that returns a string representation of the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `o.valueOf()` returns a single-value representation of the object; often,
    this is the object itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see these methods in action. First, create an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `toString()` returns a string representation of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toString()` method will be called internally by JavaScript when an object
    is used in a string context. For example, `alert()` works only with strings, so
    if you call the `alert()` function passing an object, the `toString()`method will
    be called behind the scenes. These two lines produce the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Another type of string context is the string concatenation. If you try to concatenate
    an object with a string, the object''s `toString()` method is called first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `valueOf()` method is another method that all objects provide. For the
    simple objects (whose constructor is `Object()`), the `valueOf()` method returns
    the object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: You can create objects either with `var o = {};` (object literal notation, the
    preferred method) or with `var o = new Object();`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any object, no matter how complex, inherits from the `Object` object and therefore,
    offers methods such as `toString()` and properties such as a constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Array()` is a built-in function that you can use as a constructor to create
    arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the array literal notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'No matter how the array is created, you can add elements to it as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the `Array()` constructor, you can also pass values that will be
    assigned to the new array''s elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'An exception to this is when you pass a single number to the constructor. In
    this case, the number is considered to be the length of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'As arrays are created with a constructor, does this mean that arrays are in
    fact objects? Yes, and you can verify this using the `typeof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'As arrays are objects, this means that they inherit the properties and methods
    of the parent object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays are objects, but of a special type because:'
  prefs: []
  type: TYPE_NORMAL
- en: The names of their properties are automatically assigned using numbers starting
    from 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have a `length` property that contains the number of elements in the array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have more built-in methods in addition to those inherited from the parent
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s examine the differences between an array and an object, starting by
    creating the empty array `a` and the empty object `o`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Array objects have a `length` property automatically defined for them, while
    normal objects do not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s ok to add both numeric and non-numeric properties to both arrays and
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The `length` property is always up to date with the number of numeric properties,
    while it ignores the non-numeric ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `length` property can also be set by you. Setting it to a greater value
    than the current number of items in the array makes room for additional elements.
    If you try to access these non-existing elements, you''ll get the value `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the `length` property to a lower value removes the trailing elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: A few array methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the methods inherited from the parent object, array objects also
    have specialized methods for working with arrays, such as `sort()`, `join()`,
    and `slice()`, among others (see [Appendix C](apc.html "Appendix C. Built-in Objects"),
    *Built-in Objects*, for the complete list).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an array and experiment with some of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The `push()` method appends a new element to the end of the array. The `pop()`
    method removes the last element. The `a.push('new')` method works like `a[a.length]
    = 'new'`, and `a.pop()` is like `a.length-`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `push()` method returns the length of the changed array, whereas `pop()`
    returns the removed element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sort()` method sorts the array and returns it. In the next example, after
    sort, both `a` and `b` point to the same array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The `join()` method returns a string containing the values of all the elements
    in the array glued together using the string parameter passed to `join()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The `slice()` method returns a piece of the array without modifying the source
    array. The first parameter to `slice()` is the start index (zero-based), and the
    second is the end index (both indices are zero-based). Start index is included,
    while the end index is not. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'After all the slicing, the source array is still the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The `splice()` method modifies the source array. It removes a slice, returns
    it, and optionally fills the gap with new elements. The first two parameters define
    the start index and length (number of elements) of the slice to be removed; the
    other parameters pass the new values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Filling the gap with new elements is optional, so you can skip it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: ES6 array methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays get a bunch of useful methods. Libraries such as **lodash** and **underscore**
    provided features missing in the language so far. With the new helper methods,
    array creation and manipulation is much more functional and easy to code.
  prefs: []
  type: TYPE_NORMAL
- en: Array.from
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Converting array-like values to arrays has always been a bit of a challenge
    in JavaScript. People have employed several hacks and written libraries to just
    let you handle arrays effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES6 introduces a very helpful method to convert array-like objects and iterable
    values into arrays. Array-like values are objects that have a length property
    and indexed elements. Every function has an implicit arguments variable that contains
    a list of all arguments passed to the function. This variable is an array-like
    object. Before ES6, the only way we could convert the `arguments` object to an
    array was to iterate through it and copy the values over to a new array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are creating a new array to copy over all elements of the `arguments`
    object. This is wasteful and needs a lot of unnecessary coding. `Array.from()`
    is a concise way to convert array-like objects into arrays. We can convert this
    example to a more succinct one using `Array.from()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'You can provide your own mapping scheme while calling `Array.from()` by providing
    a mapping function. This function is invoked on all the elements of the object
    and converts it. This is a useful construct for many common usecases, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are deconstructing the `arguments` object using `Array.from`
    and for each element in `arguments` object, we are calling a function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating arrays using Array.of
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating an array using the `Array()` constructor causes a bit of a problem.
    The constructor behaves differently based on the number and type of arguments.
    When you pass a single numeric value to the `Array()` constructor, an array of
    undefined elements is created, with the value of the length assigned to the value
    of the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if you pass only one non-numeric value, it becomes the only
    item in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not all. If you pass multiple values, they become elements of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'So, clearly, there needs to be a better way to create arrays to avoid such
    confusion. ES6 introduces the `Array.of` method that works like the `Array()`
    constructor, but guarantees one standard behavior. `Array.of` creates an array
    from its arguments, regardless of their number and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Array.prototype methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ES6 introduces several interesting methods as part of array instances. These
    methods help with array iteration and searching elements in the array, both of
    which are very frequent and useful operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the methods used for iterating over arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.entries()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.values()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prorotype.keys()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All three methods return an iterator. This iterator can be used to create arrays
    using `Array.from()` and can be used in for loops for iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, there are new methods for searching within arrays. Looking for an
    element in an array usually involved iterating through the entire list and comparing
    them with a value, as there were no built-in methods for this. Though `indexOf()`
    and `lastIndexOf()` helped find a single value, there was no way to find elements
    based on complex conditions. With ES6, the following build-in methods help with
    `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.find`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.findIndex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both these methods accept two arguments-first is the `callback` function(which
    contains the predicate condition) and the second is an optional `this` keyword.
    The `callback` accepts three arguments: the array element, index of that element,
    and the array. The `callback` returns `true` if the element matches the predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You already know that functions are a special data type. However, it turns
    out that there''s more to it than that: functions are actually objects. There
    is a built-in `constructor` function called `Function()` that allows for an alternative
    (but not necessarily recommended) way to create a function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows three ways to define a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: When using the `Function()` constructor, you pass the parameter names first
    (as strings) and then the source code for the body of the function (again as a
    string). The JavaScript engine needs to evaluate the source code you pass and
    create the new function for you. This source code evaluation suffers from the
    same drawbacks as the `eval()` function, so defining functions using the `Function()`
    constructor should be avoided when possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the `Function()` constructor to create functions that have lots
    of parameters, bear in mind that the parameters can be passed as a single comma-delimited
    list; so, for example, these are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not use the `Function()` constructor. As with `eval()` and `setTimeout()`
    (discussed later in the book), always try to stay away from passing JavaScript
    code as a string.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of function objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like any other object, functions have a `constructor` property that contains
    a reference to the `Function()` constructor function. This is true no matter which
    syntax you used to create the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions also have a `length` property, which contains the number of formal
    parameters the function expects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Using the prototype property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most widely used properties of function objects is the `prototype`
    property. You''ll see this property discussed in detail in the next chapter, but
    for now, let''s just say:'
  prefs: []
  type: TYPE_NORMAL
- en: The `prototype` property of a `function` object points to another object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its benefits shine only when you use this `function` as a constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All objects created with this `function` keep a reference to the `prototype`
    property and can use its properties as their own
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at a quick example to demonstrate the `prototype` property. Take
    a simple object that has a property name and a method `say()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create a function (even one without a body), you can verify that it
    automatically has a `prototype` property that points to a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'It gets interesting when you modify the `prototype` property. You can add properties
    to it, or you can replace the default object with any other object. Let''s assign
    `ninja` to the `prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, and here''s where the magic happens, using the `F()`function as a `constructor`
    function, you can create a new object, `baby_ninja`, which will have access to
    the properties of `F.prototype` (which points to `ninja`) as if it were its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: There will be much more on this topic later. In fact, the next chapter is all
    about the `prototype` property.
  prefs: []
  type: TYPE_NORMAL
- en: Methods of function objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Function objects, being a descendant of the top parent object, get the default
    methods such as `toString()`. When invoked on a function, the `toString()` method
    returns the source code of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to peek into the source code of the built-in functions, you''ll
    get the `[native code]` string instead of the body of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can use `toString()` to differentiate between native methods
    and developer-defined ones.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The behavior of the function's `toString()` is environment dependent, and it
    differs among browsers in terms of spacing and new lines.
  prefs: []
  type: TYPE_NORMAL
- en: Call and apply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Function objects have `call()` and `apply()` methods. You can use them to invoke
    a function and pass any arguments to it.
  prefs: []
  type: TYPE_NORMAL
- en: These methods also allow your objects to borrow methods from other objects and
    invoke them as their own. This is an easy and powerful way to reuse code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have a `some_obj` object, which contains the `say()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the `say()` method, which internally uses `this.name` to gain
    access to its own name property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a simple object, `my_obj`, which only has a name property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The `my_obj` likes the `some_obj` object''s `say()` method so much that it
    wants to invoke it as its own. This is possible using the `call()` method of the
    `say()` function object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: It worked! But what happened here? You invoked the `call()` method of the `say()`
    function object by passing two parameters-the `my_obj` object and the `Dude` string.
    The result is that when `say()` is invoked, the references to the this value that
    it contains point to `my_obj`. This way, `this.name` doesn't return `Ninja`, but
    `Scripting guru` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have more parameters to pass when invoking the `call()` method, you
    just keep adding them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: If you don't pass an object as a first parameter to `call()` or you pass `null`,
    the global object is assumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `apply()` works the same way as `call()`, but with the difference
    that all parameters you want to pass to the method of the other object are passed
    as an array. The following two lines are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing the previous example, you can use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: The arguments object revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous chapter, you have seen how, from inside a function, you have
    access to something called `arguments`, which contains the values of all the parameters
    passed to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The `arguments` looks like an array, but it is actually an array-like object.
    It resembles an array because it contains indexed elements and a `length` property.
    However, the similarity ends there, as arguments doesn't provide any of the array
    methods, such as `sort()` or `slice()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can convert `arguments` to an array and benefit from all the array
    goodies. Here''s what you can do, practicing your newly-learned `call()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can borrow `slice()` using `[].slice` or the more verbose
    `Array.prototype.slice`.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical this in arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed ES6 arrow functions and the syntax in detail in the last chapter.
    However, an important aspect of arrow functions is that they behave differently
    from normal functions. The difference is subtle but important. Arrow functions
    do not have their own value of `this`. The value of `this` in an arrow function
    is inherited from the enclosing (lexical) scope.
  prefs: []
  type: TYPE_NORMAL
- en: Functions have a special variable `this` that refers to the object via which
    the method was invoked. As the value of `this` is dynamically given based on the
    function invocation, it is sometimes called dynamic `this`. A function is executed
    in two scopes-lexical and dynamic. A lexical scope is a scope that surrounds the
    function scope, and the dynamic scope is the scope that called the function (usually
    an object)
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, traditional functions play several roles. They are non-method
    functions (aka subroutines or functions), methods (part of an object), and constructors.
    When functions do the duty of a subroutine, there is a small problem due to dynamic
    `this`. As subroutines are not called on an object, the value of `this` is undefined
    in a strict mode and set to the global scope otherwise. This makes writing `callbacks`
    difficult. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: We are passing a subroutine to the `forEach()` function on the `names` array.
    This subroutine has an undefined value of `this`, and unfortunately, it does not
    have access to `this` of the outer method `greet`. Clearly, this subroutine needs
    a lexical `this`,derive `this` from the surrounding scope of the `greet` method.
    Traditionally, to fix this limitation, we assign the lexical `this` into a variable,
    which is then accessible to the subroutine via closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix the earlier example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: This is a reasonable hack to simulate lexical `this`. However, the problem with
    such hacks is that it creates too much noise for the person writing or reviewing
    `this` code. First, you have to understand the quirk of the behavior of `this`.
    Even if you understand `this` behavior well, you will need to continuously remain
    on the lookout for such hacks in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrow functions have lexical `this` and do not require such a hack. They are
    more suited as subroutines because of `this`. We can covert the preceding example
    to use lexical `this` using the arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Inferring object types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can see that you have this array-like arguments object looking so much like
    an array object. How can you reliably tell the difference between the two? Additionally,
    `typeof` returns an object when used with arrays. Therefore, how can you tell
    the difference between an object and an array?
  prefs: []
  type: TYPE_NORMAL
- en: 'The silver bullet is the `Object` object''s `toString()` method. It gives you
    the internal class name used to create a given object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to call the original `toString()` method as defined in the prototype
    of the `Object` constructor. Otherwise, if you call the `Array` function''s `toString()`,
    it will give you a different result, as it''s been overridden for the specific
    purposes of the array objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have some more fun with `toString()`. Make a handy reference to save
    typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how we can differentiate between an array and the
    array-like object `arguments`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even inspect DOM elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Boolean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your journey through the built-in objects in JavaScript continues, and the next
    three are fairly straightforward. They are Boolean, number, and string. They merely
    wrap the primitive data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'You already know a lot about Booleans from [Chapter 2](ch02.html "Chapter 2. Primitive
    Data Types, Arrays, Loops, and Conditions"), *Primitive Data Types, Arrays, Loops,
    and Conditions*. Now, let''s meet the `Boolean()` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to note that this creates a new object, `b`, and not a primitive
    Boolean value. To get the primitive value, you can call the `valueOf()` method
    (inherited from `Object` class and customized):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Overall, objects created with the `Boolean()` constructor are not too useful,
    as they don't provide any methods or properties other than the inherited ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Boolean()` function, when called as a normal function without `new`, converts
    non-Booleans to Booleans (which is like using a double negation `!!`value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the six `false` values, everything else is `true` in JavaScript,
    including all objects. This also means that all Boolean objects created with `new
    Boolean()` are also `true`, as they are objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: This can be confusing, and since Boolean objects don't offer any special methods,
    it's best to just stick with regular primitive Boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to `Boolean()`, the `Number()` function can be used as:'
  prefs: []
  type: TYPE_NORMAL
- en: A `constructor` function (with `new`) to create objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A normal function in order to try to convert any value to a number. This is
    similar to the use of `parseInt()` or `parseFloat()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'As functions are objects, they can also have properties. The `Number()` function
    has constant built-in properties that you cannot modify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The number objects provide three methods-`toFixed()`, `toPrecision()`, and
    `toExponential()`(see [Appendix C](apc.html "Appendix C. Built-in Objects"), *Built-in
    Objects*, for more details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can use these methods without explicitly creating a `Number`
    object first. In such cases, the `Number` object is created (and destroyed) for
    you behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Like all objects, the `Number` object also provide the `toString()` method.
    When used with `Number` object, this method accepts an optional radix parameter
    (10 being the default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the `String()` constructor function to create string objects. String
    objects provide convenient methods for text manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example that shows the difference between a `String` object and
    a `primitive` string data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: A `String` object is similar to an array of characters. String objects have
    an indexed property for each character (introduced in ES5, but long supported
    in many browsers, except old IEs), and they also have a `length` property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract the `primitive` value from the `String` object, you can use the
    `valueOf()` or `toString()` method inherited from `Object`. You''ll probably never
    need to do this, as `toString()` is called behind the scenes if you use an object
    in a `primitive` string context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The `primitive` strings are not objects, so they don't have any methods or properties.
    However, JavaScript also offers you the syntax to treat `primitive` strings as
    objects (just like you already saw with primitive numbers).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `String` objects are being created (and then destroyed)
    behind the scenes every time you treat a `primitive` string as if it were an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is one final example to illustrate the difference between a `primitive`
    string and a `String` object. In this example, we are converting them to Boolean.
    The empty string is a falsy value, but any string object is truthy (because all
    objects are truthy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to `Number()` and `Boolean()`, if you use the `String()` function without
    `new`, it converts the parameter to a primitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass an object to `String()`, this object''s `toString()` method will
    be called first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: A few methods of string objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's experiment with a few of the methods you can call on string objects (see
    [Appendix C](apc.html "Appendix C. Built-in Objects"), *Built-in Objects*, for
    the complete list).
  prefs: []
  type: TYPE_NORMAL
- en: 'Start off by creating a string object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toUpperCase()` and `toLowerCase()` methods transform the capitalization
    of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'The `charAt()` method tells you the character found at the position you specify,
    which is the same as using square brackets (treating a string as an array of characters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a non-existent position to `charAt()`, you get an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'The `indexOf()` method allows you to search within a string. If there is a
    match, the method returns the position at which the first match is found. The
    position count starts at 0, so the second character in `Couch` is `o` at position
    1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'You can optionally specify where (at what position) to start the search. The
    following finds the second `o`, because `indexOf()` is instructed to start the
    search at position 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lastIndexOf()`starts the search from the end of the string (but the position
    of the match is still counted from the beginning):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'You can search , not only for characters, but also for strings, and the search
    is case sensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is no match, the function returns position `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'For a case-insensitive search, you can transform the string to lowercase first
    and then search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get `0`, this means that the matching part of the string starts at position
    `0`. This can cause confusion when you check with `if`, because `if` converts
    the position `0` to a Boolean `false` value. So, while this is syntactically correct,
    it is logically wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'The proper way to check whether a string contains another string is to compare
    the result of `indexOf()` to the number `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The `slice()`and `substring()` return a piece of the string when you specify
    the start and end positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the second parameter you pass is the end position, not the length
    of the piece. The difference between these two methods is how they treat negative
    arguments. `substring()` treats them as zeros, while `slice()` adds them to the
    length of the string. So, if you pass parameters `(1, -1)` to both methods, it''s
    the same as `substring(1,0)` and `slice(1,s.length-1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: There's also the non-standard method `substr()`, but you should try to avoid
    it in favor of `substring()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `split()` method creates an array from the string using another string
    that you pass as a separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'The `split()` method is the opposite of the `join()` method, which creates
    a string from an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'The `concat()` glues strings together, in the same way in which the `+` operator
    does for `primitive` strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that while some of the preceding methods discussed return new `primitive`
    strings, none of them modify the source string. After all the method calls listed
    previously, the initial string is still the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: You have seen how to use `indexOf()` and `lastIndexOf()` to search within strings,
    but there are more powerful methods (`search()`, `match()`, and `replace()`) that
    take regular expressions as parameters. You'll see these later in the `RegExp()`
    constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you're done with all of the data wrapper objects, so let's move
    on to the utility objects `Math`, `Date`, and `RegExp`.
  prefs: []
  type: TYPE_NORMAL
- en: Math
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Math` is a little different from the other built-in global objects you have
    seen previously. It''s not a function, and, therefore, cannot be used with `new`
    to create objects. `Math` is a built-in global object that provides a number of
    methods and properties for mathematical operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Math` object''s properties are constants, so you can''t change their values.
    Their names are all in uppercase to emphasize the difference between them and
    a normal property (similar to the constant properties of the `Number()` constructor).
    Let''s see a few of these constant properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The constant PI:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Square root of 2:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Euler''s constant:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Natural logarithm of 2:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Natural logarithm of 10:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Now, you know how to impress your friends the next time they (for whatever reason)
    start wondering, "What was the value of *e*? I can't remember." Just type `Math.E`
    in the console and you have the answer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at some of the methods the `Math` object provides (the full
    list is in [Appendix C](apc.html "Appendix C. Built-in Objects"), *Built-in Objects*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'The `random()` function returns a number between `0` and `1`, so if you want
    a number between, let''s say, `0` and `100`, you can use the following line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'For numbers between any two values, use the formula `((max-min) * Math.random())+min`.
    For example, a random number between 2 and 10 can be obtained using the formula
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'If you only need an integer, you can use one of the following rounding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`floor()` to round down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ceil()` to round up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`round()` to round to the nearest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to get either `0` or `1`, you can use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need the lowest or the highest among a set of numbers, you have the
    `min()` and `max()` methods. So, if you have a form on a page that asks for a
    valid month, you can make sure that you always work with sane data (a value between
    `1` and `12`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: The `Math` object also provides the ability to perform mathematical operations
    for which you don't have a designated operator. This means that you can raise
    to a power using `pow()`, find the square root using `sqrt()`, and perform all
    the trigonometric operations-`sin()`, `cos()`, `atan()`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to calculate `2` to the power of `8`, you can use the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the square root of `9`, you can use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Date()` is a constructor function that creates date objects. You can create
    a new object by passing:'
  prefs: []
  type: TYPE_NORMAL
- en: Nothing (defaults to today's date)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A date-like string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate values for day, month, time, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A timestamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an object instantiated with today''s date/time (using the browser''s
    timezone):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: The console displays the result of the `toString()` method called on the `Date`
    object, so you get this long string `Wed Feb 27 2013 23:49:28 GMT-0800 (PST)`
    as a representation of the date object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of using strings to initialize a `Date` object. Note
    how many different formats you can use to specify the date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Date` constructor can figure out a date from different strings, but this
    is not really a reliable way of defining a precise date, for example, when passing
    user input to the constructor. A better way is to pass numeric values to the `Date()`
    constructor representing:'
  prefs: []
  type: TYPE_NORMAL
- en: Year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Month - 0 (January) to 11 (December)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day - 1 to 31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hour - 0 to 23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minutes - 0 to 59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seconds - 0 to 59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Milliseconds - 0 to 999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing all the parameters by writing the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing date and hour by writing the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Watch out for the fact that the month starts from 0, so 1 is February:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a value greater than the one allowed, your date overflows forward.
    As there''s no February 30 in 2016, this means it has to be March 1 (2016 is a
    leap year):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, December 32 becomes January 1 of the next year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a date object can be initialized with a timestamp (the number of milliseconds
    since the UNIX epoch, where 0 milliseconds is January 1, 1970):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call `Date()` without `new`, you get a string representing the current
    date, whether or not you pass any parameters. The following example gives the
    current time (current when this example was run):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Methods to work with date objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you've created a date object, there are lots of methods you can call on
    that object. Most of the methods can be divided into `set*()` and `get*()` methods,
    for example, `getMonth()`, `setMonth()`, `getHours()`, `setHours()`, and so on.
    Let's see some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a date object by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the month to March (months start from 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the month by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: In addition to all the methods of date objects, there are also two methods (plus
    one more added in ES5) that are properties of the `Date()` function/object. These
    do not need a `date` object; they work just like the `Math` object methods. In
    class-based languages, such methods would be called static because they don't
    require an instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Date.parse()` method takes a string and returns a timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Date.UTC()` method takes all the parameters for year, month, day, and
    so on, and produces a timestamp in **Universal Time** (**UT**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `new Date()` constructor can accept timestamps, you can pass the result
    of `Date.UTC()` to it. Using the following example, you can see how `UTC()` works
    with Universal Time, while `new Date()` works with local time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'The ES5 addition to the `Date` constructor is the `now()`method, which returns
    the current timestamp. It provides a more convenient way to get the timestamp
    instead of using the `getTime()` method on a `Date` object as you would in ES3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'You can think of the internal representation of the date being an integer timestamp
    and all other methods being sugar on top of it. So, it makes sense that `valueOf()`
    is a timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, dates cast to integers with the `+` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Calculating birthdays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s look at one final example of working with `Date` objects. I was curious
    about which day my birthday falls on in 2016:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Starting the count from 0 (Sunday), 1 means Monday. Is that so?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: ok, good to know, but Monday is not necessarily the best day for a party. So,
    how about a loop that shows how many times June 20 is a Friday from year 2016
    to year 3016, or better yet, let's see the distribution of all the days of the
    week. After all, with all the progress in DNA hacking, we're all going to be alive
    and kicking in 3016.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s initialize an array with seven elements, one for each day of
    the week. These will be used as counters. Then, as a loop goes up to 3016, let''s
    increment the counters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 142 Fridays and 145 Saturdays. Woo-hoo!
  prefs: []
  type: TYPE_NORMAL
- en: RegExp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular expressions provide a powerful way to search and manipulate text. Different
    languages have different implementations (think dialects) of the regular expression
    syntax. JavaScript uses the Perl 5 syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of saying regular expression, people often shorten it to regex or regexp.
  prefs: []
  type: TYPE_NORMAL
- en: 'A regular expression consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: A pattern you use to match text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more modifiers (also called flags) that provide more instructions on
    how the pattern should be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pattern can be as simple as literal text to be matched verbatim, but that's
    rare, and in such cases you're better off using `indexOf()`. Most of the time,
    the pattern is more complex and could be difficult to understand. Mastering regular
    expressions' patterns is a large topic, which won't be discussed in full detail
    here. Instead, you'll see what JavaScript provides in terms of syntax, objects,
    and methods in order to support the use of regular expressions. You can also refer
    to [Appendix D](apd.html "Appendix D. Regular Expressions"), *Regular Expressions*,
    to help you when you're writing patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript provides the `RegExp()` constructor, which allows you to create
    regular expression objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also the more convenient **regexp literal notation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `j.*t` is the regular expression pattern. It means
    `"` matches any string that starts with `j`, ends with `t`, and has zero or more
    characters in between `"`. The asterisk (`*`) means `"` zero or more of the preceding,
    `"` and the dot (`.`) means `"` any character `"`. The pattern needs to be quoted
    when passed to a `RegExp()` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of RegExp objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regular expression objects have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`global`: If this property is `false`, which is the default, the search stops
    when the first match is found. Set this to `true` if you want all matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignoreCase`: When the match is case insensitive, this property defaults to
    `false` (meaning the default is a case-sensitive match).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiline`: Search matches that may span over more than one line default to
    `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastIndex`: The position at which to start the search; this defaults to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source`: This contains the `RegExp` pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these properties, except for `lastIndex`, can be changed once the object
    has been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three items in the preceding list represent the regex modifiers.
    If you create a regex object using the constructor, you can pass any combination
    of the following characters as a second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`g` for `global`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i` for `ignoreCase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m` for `multiline`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These letters can be in any order. If a letter is passed, the corresponding
    modifier property is set to `true`. In the following example, all modifiers are
    set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'Once set, the modifier cannot be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'To set any modifiers using the regex literal, you add them after the closing
    slash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Methods of RegExp objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regex objects provide two methods you can use to find matches-`test()` and `exec()`.
    They both accept a string parameter. The `test()` method returns a Boolean (`true`
    when there's a match, `false` otherwise), while `exec()` returns an array of matched
    strings. Obviously, `exec()` is doing more work, so use `test()` only if you really
    need to do something with the matches. People often use regular expressions to
    validate data. In this case, `test()` should be enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, there is no match because of the capital `J`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'A case-insensitive test gives a positive result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'The same test using `exec()` returns an array, and you can access the first
    element as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: String methods that accept regular expressions as arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously in this chapter, you learned about string objects and how you can
    use the `indexOf()` and `lastIndexOf()` methods to search within text. Using these
    methods, you can only specify literal string patterns to search. A more powerful
    solution would be to use regular expressions to find text. String objects offer
    you this ability.
  prefs: []
  type: TYPE_NORMAL
- en: 'String objects provide the following methods that accept regular expression
    objects as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`match()`: Returns an array of matches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search()`: Returns the position of the first match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace()`: Allows you to substitute matched text with another string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split()`: Accepts a regexp when splitting a string into array elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: search() and match()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at some examples of using the `search()`and `match()` methods.
    First, you create a string object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `match()`, you get an array containing only the first match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `g` modifier, you perform a global search, so the result array contains
    two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'A case-insensitive match is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'The `search()` method gives you the position of the matching string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: replace()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `replace()` method allows you to replace the matched text with some other
    string. The following example removes all capital letters (it replaces them with
    blank strings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the `g` modifier, you''re only going to replace the first match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'When a match is found, if you want to include the matched text in the replacement
    string, you can access it using `$&`. Here''s how to add an underscore before
    the match while keeping the match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'When the regular expression contains groups (denoted by parentheses), the matches
    of each group are available as `$1` for the first group, `$2` the second, and
    so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine you have a registration form on your web page that asks for an e-mail
    address, username, and password. The user enters their e-mail IDs, and then, your
    JavaScript kicks in and suggests the username, taking it from the e-mail address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Replace callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When specifying the replacement, you can also pass a function that returns
    a string. This gives you the ability to implement any special logic you may need
    before specifying the replacements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback function receives a number of parameters (the previous example
    ignores all but the first one):'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the `match`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last is the string being searched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The one before last is the position of the `match`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the parameters contain any strings matched by any groups in your
    regex pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s test this. First, let''s create a variable to store the entire arguments
    array passed to the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define a regular expression that has three groups and matches e-mail
    addresses in the format `something@something.something`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s define a callback function that stores the arguments in `glob`
    and then returns the replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, perform a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the callback function received as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: split()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You already know about the `split()` method, which creates an array from an
    input string and a delimiter string. Let''s take a string of comma-separated values
    and split it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the input string happens to have random inconsistent spaces before
    and after the commas, the array result has spaces too. With a regular expression,
    you can fix this using `\s*`, which means zero or more spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Passing a string when a RegExp is expected
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One last thing to note is that the four methods that you have just seen (`split()`,
    `match()`, `search()`, and `replace()`) can also take strings as opposed to regular
    expressions. In this case, the string argument is used to produce a new regex
    as if it were passed to `new RegExp()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of passing a string to `replace` is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines of code are the same as the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'When you pass a string, you cannot set modifiers the way you do with a normal
    constructor or regex literal. There''s a common source of errors when using a
    string instead of a regular expression object for string replacements, and it''s
    due to the fact that the `g` modifier is `false` by default. The outcome is that
    only the first string is replaced, which is inconsistent with most other languages
    and a little confusing. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'Most likely, you want to replace all occurrences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Error objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Errors happen, and it's good to have the mechanisms in place so that your code
    can realize that there has been an error condition and can recover from it in
    a graceful manner. JavaScript provides the `try`, `catch`, and `finally` statements
    to help you deal with errors. If an error occurs, an error object is thrown. Error
    objects are created using one of these built-in constructors-`EvalError`, `RangeError`,
    `ReferenceError`, `SyntaxError`, `TypeError`, and `URIError`. All these constructors
    inherit from `Error`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s just cause an error and see what happens. What''s a simple way to cause
    an error? Just call a function that doesn''t exist. Type this into the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Error objects](graphics/image_04_003-e1482749061350.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The display of errors can vary greatly between browsers and other host environments.
    In fact, most recent browsers tend to hide the errors from the users. However,
    you cannot assume that all of your users have disabled the display of errors,
    and it is your responsibility to ensure an error-free experience for them. The
    previous error propagated to the user, because the code didn't try to trap (catch)
    this error. The code didn't expect the error and was not prepared to handle it.
    Fortunately, it's trivial to trap the error. All you need is the `try` statement
    followed by a `catch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code hides the error from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you have:'
  prefs: []
  type: TYPE_NORMAL
- en: The `try` statement followed by a block of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `catch` statement followed by a variable name in parentheses and another
    block of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can be an optional `finally` statement (not used in this example) followed
    by a block of code, which is executed regardless of whether there was an error
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the code block that follows the `catch` statement didn't
    do anything. However, this is the place where you put the code that can help recover
    from the error, or at least give feedback to the user that your application is
    aware that there was a special condition.
  prefs: []
  type: TYPE_NORMAL
- en: The variable `e` in the parentheses after the `catch` statement contains an
    error object. Like any other object, it contains properties and methods. Unfortunately,
    different browsers implement these methods and properties differently, but there
    are two properties that are consistently implemented-`e.name` and `e.message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: This will present an `alert()` showing `e.name` and `e.message` and then another
    `alert()` saying `Finally!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Firefox and Chrome, the first alert will say **ReferenceError: iDontExist
    is not defined**. In Internet Explorer, it will be **TypeError: Object expected**.
    This tells us two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `e.name` method contains the name of the constructor that was used to create
    the error object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the error objects are not consistent across host environments (browsers),
    it would be somewhat tricky to have your code act differently depending on the
    type of error (the value of `e.name`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also create error objects yourself using `new Error()` or any of the
    other error constructors and then let the JavaScript engine know that there's
    an erroneous condition using the `throw` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine a scenario where you call the `maybeExists()` function
    and after that make calculations. You want to trap all errors in a consistent
    way, no matter whether the error is that `maybeExists()` doesn''t exist or that
    your calculations found a problem. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will alert different messages depending on whether or not `maybeExists()`
    is defined and the values it returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `maybeExists()` doesn''t exist, you get **ReferenceError: maybeExists()
    is not defined** in Firefox and **TypeError: Object expected** in IE'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `maybeExists()` returns `0`, you get **Error: Division by zero!**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `maybeExists()` returns `2`, you get an alert that says **25**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all cases, there will be a second alert that says **Finally!**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of throwing a generic error, `thrownewError(''Divisionbyzero!'')`,
    you can be more specific if you choose to, for example, throw `thrownewRangeError(''Divisionbyzero!'')`.
    Alternatively, you don''t need a constructor; you can simply throw a normal object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: This gives you cross-browser control over the error name.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lets solve the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: Does the value of `this` refer to the global object or the object `o`?
  prefs: []
  type: TYPE_NORMAL
- en: What's the result of executing this piece of code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: What's the result of executing the following piece of code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine the `String()` constructor didn''t exist. Create a constructor function,
    `MyString()`, that acts like `String()` as closely as possible. You''re not allowed
    to use any built-in string methods or properties, and remember that the `String()`
    doesn''t exist. You can use this code to test your constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use a `for` loop to loop through the input string, treating it as an
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Update your `MyString()` constructor to include a `reverse()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try to leverage the fact that arrays have a `reverse()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that `Array()`and the array literal notation don''t exist. Create a
    constructor called `MyArray()` that behaves as close to `Array()` as possible.
    Test it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: If you found this exercise amusing, don't stop with the `join()` method; go
    on with as many methods as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Imagine `Math` didn''t exist. Create a `MyMath` object that also provides the
    following additional methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MyMath.rand(min, max, inclusive)`: This generates a random number between
    `min` and `max`, inclusive if `inclusive` is `true` (default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyMath.min(array)`: This returns the smallest number in a given array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyMath.max(array)`: This returns the largest number in a given array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Primitive Data Types, Arrays, Loops, and
    Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*, you saw that
    there are five primitive data types (`number`, `string`, `Boolean`, `null`, and
    `undefined`), and we also said that everything that is not a primitive piece of
    data is an object. Now, you also know that:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects are like arrays, but you specify the keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects contain properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties can be functions (functions are data; remember `var f = function
    () {};`). Properties that are functions are also called methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays are actually objects with predefined numeric properties and an auto-incrementing
    `length` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array objects have a number of convenient methods (such as `sort()` or `slice()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions are also objects, and they have properties (such as `length` and `prototype`)
    and methods (such as `call()` and `apply()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding the five primitive data types, apart from `undefined` and `null`,
    the other three have the corresponding constructor functions-`Number()`, `String()`,
    and `Boolean()`. Using these, you can create objects, called wrapper objects,
    which contain methods for working with primitive data elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`Number()`, `String()`, and `Boolean()` can be invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `new` operator, to create new objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without the `new` operator, to convert any value to the corresponding primitive
    data type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other built-in constructor functions you're now familiar with include `Object()`,
    `Array()`, `Function()`, `Date()`, `RegExp()`, and `Error()`. You're also familiar
    with `Math`-a global object that is not a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can see how objects have a central role in JavaScript programming,
    as pretty much everything is an object or can be wrapped by an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s wrap up the literal notations you''re now familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Literal** | **Constructor** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Object | `{}` | `new Object()` | `{prop: 1}` |'
  prefs: []
  type: TYPE_TB
- en: '| Array | `[]` | `new Array()` | `[1,2,3,''test'']` |'
  prefs: []
  type: TYPE_TB
- en: '| Regular expression | `/pattern/modifiers` | `new RegExp(''pattern'', ''modifiers'')`
    | `/java.*/img` |'
  prefs: []
  type: TYPE_TB

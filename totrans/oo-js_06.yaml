- en: Chapter 6. Prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll learn about the prototype property of the function objects.
    Understanding how the prototype works is an important part of learning the JavaScript
    language. After all, JavaScript is often classified as having a prototype-based
    object model. There's nothing particularly difficult about the prototype, but
    it's a new concept, and as such, may sometimes take a bit of time to sink in.
    Like closures (see [Chapter 3](ch03.html "Chapter 3. Functions"), *Functions*),
    the prototype is one of those things in JavaScript which, once you get, seem so
    obvious and make perfect sense. As with the rest of this book, you're strongly
    encouraged to type in and play around with the examples - this makes it much easier
    to learn and remember the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Every function has a `prototype` property and it contains an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding properties to the prototype object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the properties added to the prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between own properties and properties of the prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__proto__` property, the secret link every object keeps to its prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods such as `isPrototypeOf()`, `hasOwnProperty()`, and `propertyIsEnumerable()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing built-in objects, such as arrays or strings, and why that can be a
    bad idea
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prototype property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functions in JavaScript are objects, and they contain methods and properties.
    Some of the methods that you're already familiar with are `apply()` and `call()`,
    and some of the other properties are `length` and `constructor`. Another property
    of the function objects is `prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you define a simple function, `foo()`, you can access its properties as
    you would do with any other object. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `prototype` property is a property that is available to you as soon as
    you define the function. Its initial value is an empty object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s as if you have added this property yourself, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can augment this empty object with properties and methods. They won't have
    any effect on the `foo()` function itself; they'll only be used if you call `foo()`
    as a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Adding methods and properties using the prototype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to define constructor functions that
    you can use to create (construct) new objects. The main idea is that, inside a
    function invoked with `new`, you will have access to the `this` value, which refers
    to the object to be returned by the constructor. Augmenting, which is adding methods
    and properties to `this`, is how you can add functionality to the object being
    constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the constructor function, `Gadget()`, which uses `this`
    to add two properties and one method to the objects it creates, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding methods and properties to the `prototype` property of the constructor
    function is another way to add functionality to the objects this constructor produces.
    Let''s add two more properties, `price` and `rating`, as well as a `getInfo()`
    method. As `prototype` already points to an object, you can just keep adding properties
    and methods to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, instead of adding properties to the `prototype` object one by
    one, you can overwrite the `prototype` completely, replacing it with an object
    of your choice, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using the prototype's methods and properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the methods and properties you have added to the `prototype` are available
    as soon as you create a new object using the constructor. If you create a `newtoy`
    object using the `Gadget()` constructor, you can access all the methods and properties
    that are already defined, as you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that the `prototype` is live. Objects are passed by reference
    in JavaScript, and therefore, the `prototype` is not copied with every new object
    instance. What does this mean in practice? It means that you can modify the `prototype`
    at any time, and all the objects, even those created before the modification,
    will see the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue the example by adding a new method to the `prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the `newtoy` object was created before the `get()` method was defined,
    the `newtoy` object still has access to the new method, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Own properties versus prototype properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, `getInfo()` was used internally to access the properties
    of the object. It could''ve also used `Gadget.prototype` to achieve the same output,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What's the difference? To answer this question, let's examine in detail how
    the `prototype` works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the `newtoy` object again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When you try to access a property of `newtoy`, say, `newtoy.name`, the JavaScript
    engine looks through all of the properties of the object searching for one called
    `name`, and if it finds it, it returns its value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What if you try to access the `rating` property? The JavaScript engine examines
    all of the properties of the `newtoy` object and doesn''t find the one called
    `rating`. Then, the script engine identifies the `prototype` of the constructor
    function used to create this object (the same as if you do `newtoy.constructor.prototype`).
    If the property is found in the `prototype` object, the following property is
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do the same and access the `prototype` directly. Every object has a
    `constructor` property, which is a reference to the function that created the
    object, so in this case look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take this lookup one step further. Every object has a constructor.
    The `prototype` is an object, so it must have a constructor too, which, in turn,
    has a `prototype`. You can go up the prototype chain, and you will eventually
    end up with the built-in `Object()` object, which is the highest-level parent.
    In practice, this means that if you try `newtoy.toString()` and `newtoy` doesn''t
    have its own `toString()` method, and its `prototype` doesn''t either, in the
    end, you''ll get the object''s `toString()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Overwriting a prototype's property with an own property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the preceding discussion demonstrates, if one of your objects doesn't have
    a certain property of its own, it can use one, if it exists, somewhere up the
    prototype chain. What if the object does have its own property and the prototype
    also has one with the same name? Then, the own property takes precedence over
    the prototype's.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a scenario where a property name exists as both an own property and
    a property of the `prototype` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a new object and accessing its `name` property gives you the object''s
    own `name` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can tell where the property was defined using `hasOwnProperty()`, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you delete the `toy` object''s own `name` property, the prototype''s property
    with the same name shines through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can always recreate the object''s own property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can play around with the `hasOwnProperty()` method to find out the origins
    of a particular property you're curious about. The `toString()` method was mentioned
    earlier. Where is it coming from?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Enumerating properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to list all the properties of an object, you can use a `for...in`
    loop. In [Chapter 2](ch02.html "Chapter 2. Primitive Data Types, Arrays, Loops,
    and Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*, you saw
    that you can also loop through all the elements of an array with `for...in`, but
    as mentioned there, `for` is better suited for arrays and `for...in` for objects.
    Let''s take an example of constructing a query string for a URL from an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the `url` string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://example.org/page.php?productid=666&section=products`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few details to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: Not all properties show up in a `for...in` loop. For example, the length (for
    arrays) and constructor properties don't show up. The properties that do show
    up are called enumerable. You can check which ones are enumerable with the help
    of the `propertyIsEnumerable()` method that every object provides. In ES5, you
    can specify which properties are enumerable, while in ES3 you don't have that
    control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototypes that come through the prototype chain also show up, provided they
    are enumerable. You can check whether a property is an object's own property or
    a prototype's property using the `hasOwnProperty()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `propertyIsEnumerable()` method returns `false` for all of the prototype's
    properties, even those that are enumerable and show up in the `for...in` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see these methods in action. Take this simplified version of `Gadget()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you loop using a `for...in` loop, you can see all of the object''s
    properties, including those that come from the prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result also contains the object''s methods, as methods are just properties
    that happen to be functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to distinguish between the object''s own properties and the prototype''s
    properties, use `hasOwnProperty()`. Try the following first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s loop again, but this time, showing only the object''s own properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try `propertyIsEnumerable()`. This method returns `true` for the
    object''s own properties that are not built in, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Most built-in properties and methods are not enumerable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Any properties coming down the prototype chain are not enumerable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, not that such properties are enumerable if you reach the object contained
    in the `prototype` and invoke its `propertyIsEnumerable()` method. Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using isPrototypeOf() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects also have the `isPrototypeOf()` method. This method tells you whether
    that specific object is used as a prototype of another object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a simple object named `monkey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a `Human()` constructor function and set its `prototype`
    property to point to `monkey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you create a new `Human` object called `george` and ask If `monkey`
    the prototype of `george`?, you''ll get `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that you have to know, or suspect, who the prototype is and then ask is
    it true that your prototype is `monkey`? in order to confirm your suspicion. But,
    what if you don't suspect anything, and you have no idea? Can you just ask the
    object to tell you its prototype? The answer is, you can't in all browsers, but
    you can in most of them. Most recent browsers have implemented the addition to
    ES5 called `Object.getPrototypeOf()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For some of the pre-ES5 environments that don't have `getPrototypeOf()`, you
    can use the special property, `__proto__`.
  prefs: []
  type: TYPE_NORMAL
- en: The secret __proto__ link
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you already know, the `prototype` property is consulted when you try to access
    a property that does not exist in the current object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider another object called `monkey`, and use it as a prototype when creating
    objects with the `Human()` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a `developer` object, and give it the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s access these properties (for example, `hacks` is a property of
    the `developer` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `feeds` property can also be found in the object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `breathes` property doesn''t exist as a property of the `developer` object,
    so the prototype is looked up, as if there is a secret link or passageway that
    leads to the `prototype` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The secret link is exposed in most modern JavaScript environments as the `__proto__`
    property, the word `proto` with two underscores before and after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can use this secret property for learning purposes, but it's not a good
    idea to use it in your real scripts because it does not exist in all browsers
    (notably IE), so your scripts won't be portable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware that `__proto__` is not the same as `prototype`, as `__proto__` is
    a property of the instances (objects), whereas `prototype` is a property of the
    constructor functions used to create those objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Once again, you should use `__proto__` only for learning or debugging purposes.
    Or, if you're lucky enough and your code only needs to work in ES5-compliant environments,
    you can use `Object.getPrototypeOf()`.
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting built-in objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objects created by the built-in constructor functions, such as `Array`,
    `String`, and even `Object` and `Function`, can be augmented (or enhanced) through
    the use of prototypes. This means that you can, for example, add new methods to
    the `Array` prototype, and in this way you can make them available to all arrays.
    Let's see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP, there is a function called `in_array()`, which tells you whether a
    value exists in an array. In JavaScript, there is no `inArray()` method, although,
    in ES5, there''s `indexOf()`, which you can use for the same purpose. So, let''s
    implement it and add it to `Array.prototype`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all arrays have access to the new method. Let''s test the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'That was nice and easy! Let''s do it again. Imagine your application often
    needs to spell words backward, and you feel there should be a built-in `reverse()`
    method for string objects. After all, arrays have `reverse()`. You can easily
    add a `reverse()` method to the `String` prototype by borrowing `Array.prototype.reverse()`
    (there was a similar exercise at the end of [Chapter 4](ch04.html "Chapter 4. Objects"),
    *Objects*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This code uses the `split()` method to create an array from a string, then
    calls the `reverse()` method on this array, which produces a reversed array. The
    resulting array is then turned back into a string using the `join()` method. Let''s
    test the new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Augmenting built-in objects - discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Augmenting built-in objects through the prototype is a powerful technique, and
    you can use it to shape JavaScript in any way you like. Because of its power,
    though, you should always thoroughly consider your options before using this approach.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that once you know JavaScript, you're expecting it to work the
    same way, no matter which third-party library or widget you're using. Modifying
    core objects can confuse the users and maintainers of your code and create unexpected
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript evolves and browser's vendors continuously support more features.
    What you consider a missing method today and decide to add to a core prototype
    could be a built-in method tomorrow. In this case, your method is no longer needed.
    Additionally, what if you have already written a lot of code that uses the method
    and your method is slightly different from the new built-in implementation?
  prefs: []
  type: TYPE_NORMAL
- en: The most common and acceptable use case to augment built-in prototypes is to
    add support for new features (ones that are already standardized by the ECMAScript
    committee and implemented in new browsers) to old browsers. One example will be
    adding an ES5 method to old versions of IE. These extensions are known as **shims**
    or **polyfills**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When augmenting prototypes, you will first check if the method exists before
    implementing it yourself. This way, you can use the native implementation in the
    browser if one exists. For example, let''s add the `trim()` method for strings,
    which is a method that exists in ES5 but is missing in older browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to augment a built-in object, or its prototype with a new property,
    do check for the existence of the new property first.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype gotchas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the two important behaviors to consider when dealing with
    prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: The prototype chain is live, except for when you completely replace the `prototype`
    object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `prototype.constructor` method is not reliable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a simple constructor function and two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Even after you''ve created the `benji` and `rusty` objects, you can still add
    properties to the prototype of `Dog()` and the existing objects will have access
    to the new properties. Let''s throw in the `say()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Both objects have access to the new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Up to this point, if you consult your objects, asking which constructor function
    was used to create them, they''ll report it correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s completely overwrite the `prototype` object with a brand new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out that the old objects do not get access to the new prototype''s
    properties; they still keep the secret link pointing to the old prototype object,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Any new objects that you will create from now on will use the updated prototype,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The secret `__proto__` link points to the new prototype object, as shown in
    the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `constructor` property of the new object no longer reports correctly.
    You will expect it to point to `Dog()`, but instead it points to `Object()`, as
    you can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily prevent this confusion by resetting the `constructor` property
    after you overwrite the prototype completely, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: When you overwrite the prototype, remember to reset the `constructor` property.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lets practice the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an object called `shape` that has the type `property` and a `getType()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `Triangle()` constructor function whose prototype is `shape`. Objects
    created with `Triangle()` should have three own properties-`a`, `b`, and `c`,
    representing the lengths of the sides of a triangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new method to the prototype called `getPerimeter()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test your implementation with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Loop over `t`, showing only your own properties and methods, none of the prototype's.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following code work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s summarize the most important topics you have learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: All functions have a property called `prototype`. Initially, it contains an
    empty object-an object without any own properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add properties and methods to the `prototype` object. You can even replace
    it completely with an object of your choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you create an object using a function as a constructor (with `new`), the
    object gets a secret link pointing to the prototype of the constructor and can
    access the prototype's properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object's own properties take precedence over a prototype's properties with
    the same name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `hasOwnProperty()` method to differentiate between an object's own properties
    and `prototype` properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a prototype chain. When you execute `foo.bar`, and if your `foo` object
    doesn't have a property called `bar`, the JavaScript interpreter looks for a `bar`
    property in the prototype. If none is found, it keeps searching in the prototype's
    prototype, then the prototype of the prototype's prototype, and it will keep going
    all the way up to `Object.prototype`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can augment the prototypes of built-in constructor functions, and all objects
    will see your additions. Assign a function to `Array.prototype.flip` and all arrays
    will immediately get a `flip()` method, as in `[1,2,3].flip()`. But, do check
    whether the method/property you want to add already exists, so you can future-proof
    your scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

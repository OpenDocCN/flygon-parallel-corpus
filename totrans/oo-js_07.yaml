- en: Chapter 7. Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you go back to [Chapter 1](ch01.html "Chapter 1. Object-Oriented JavaScript"),
    *Object-Oriented JavaScript*, and review the *Object-oriented programming* section,
    you'll see that you already know how to apply most of them to JavaScript. You
    know what objects, methods, and properties are. You know that there are no classes
    in ES5, although you can achieve them using constructor functions. ES6 introduces
    the notion of classes; we will take a detailed look at how ES6 classes work in
    the next chapter. Encapsulation? Yes, the objects encapsulate both the data and
    the means (methods) to do something with the data. Aggregation? Sure, an object
    can contain other objects. In fact, this is almost always the case since methods
    are functions and functions are also objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's focus on the inheritance part. This is one of the most interesting
    features, as it allows you to reuse existing code, thus promoting laziness, which
    is likely to be what brought human species to computer programming in the first
    place.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a dynamic language, and there is usually more than one way to
    achieve any given task. Inheritance is not an exception. In this chapter, you'll
    see some common patterns for implementing inheritance. Having a good understanding
    of these patterns will help you pick the right one, or the right mix, depending
    on your task, project, or style.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the default way of implementing inheritance - inheritance chaining
    through the prototype.
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, every function has a `prototype` property, which points
    to an object. When a function is invoked using the `new` operator, an object is
    created and returned. This new object has a secret link to the `prototype` object.
    The secret link (called `__proto__` in some environments) allows methods and properties
    of the `prototype` object to be used as if they belonged to the newly created
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `prototype` object is just a regular object and, therefore, it also has
    the secret link to its prototype. And so, a chain called a prototype chain is
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prototype chaining](graphics/proto.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this illustration, an object **A** contains a number of properties. One of
    the properties is the hidden `__proto__` property, which points to another object,
    **B**. **B**'s `__proto__` property points to **C**. This chain ends with the
    `Object.prototype` object, the grandparent, and every object inherits from it.
  prefs: []
  type: TYPE_NORMAL
- en: This is all good to know, but how does it help you? The practical side is that
    when object **A** lacks a property but **B** has it, **A** can still access this
    property as its own. The same applies if **B** also doesn't have the required
    property, but **C** does. This is how inheritance takes place - an object can
    access any property found somewhere down the inheritance chain.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, you'll see different examples that use the following
    hierarchy - a generic `Shape` parent is inherited by a `2D shape`, which in turn
    is inherited by any number of specific two-dimensional shapes such as a triangle,
    rectangle, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype chaining example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prototype chaining is the default way to implement inheritance. In order to
    implement the hierarchy, let''s define three constructor functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that performs the inheritance magic is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What's happening here? You take the object contained in the `prototype` property
    of `TwoDShape`, and instead of augmenting it with individual properties, you completely
    overwrite it with another object, created by invoking the `Shape()` constructor
    with `new`. The same process can be followed for `Triangle`-its prototype is replaced
    by an object created by `new TwoDShape()`. It's important to remember that JavaScript
    works with objects, not classes. You need to create an instance using the `new
    Shape()` constructor, and after that, you can inherit its properties; you don't
    inherit from `Shape()` directly. Additionally, after inheriting, you can modify
    the `Shape()` constructor, overwrite it, or even delete it, and this will have
    no effect on `TwoDShape`, because all you needed is one instance to inherit from.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know from the previous chapter, overwriting the prototype (as opposed
    to just adding properties to it), has side effects on the `constructor` property.
    Therefore, it''s a good idea to reset the `constructor` property after inheriting.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s test what has happened so far. Creating a `Triangle` object and
    calling its own `getArea()` method works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the `my` object doesn''t have its own `toString()` method, it inherited
    one and you can call it. Note how the inherited method `toString()` binds the
    `this` object to `my`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s fascinating to consider what the JavaScript engine does when you call
    `my.toString()`:'
  prefs: []
  type: TYPE_NORMAL
- en: It loops through all of the properties of `my` and doesn't find a method called
    `toString()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It looks at the object that `my.__proto__` points to `this` object is the instance
    `new TwoDShape()` created during the inheritance process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the JavaScript engine loops through the instance of `TwoDShape` and doesn't
    find a `toString()` method. It then checks `__proto__` of that object. This time,
    `__proto__` points to the instance created by `new Shape()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instance of `new Shape()` is examined, and `toString()` is finally found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method is invoked in the context of `my`, meaning that `this` points to
    `my`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you ask `my`, Who''s your constructor?, it reports it correctly because
    of the reset of the `constructor` property after the inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `instanceof` operator, you can validate that `my` is an instance
    of all three constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The same happens when you call `isPrototypeOf()`on the constructors by passing
    `my`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create objects using the other two constructors. Objects created
    with `new TwoDShape()` also get the `toString()`method inherited from `Shape()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Moving shared properties to the prototype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you create objects using a constructor function, own properties are added
    using `this`. This could be inefficient in cases where properties don''t change
    across instances. In the previous example, `Shape()` was defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that every time you create a new object using `new Shape()`, a new
    `name` property is created and stored somewhere in the memory. The other option
    is to have the `name` property added to the prototype and shared among all the
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time you create an object using `new Shape()`, this object doesn't
    get its own property `name`, but uses the one added to the prototype. This is
    more efficient, but you should only use it for properties that don't change from
    one instance to another. Methods are ideal for this type of sharing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s improve the preceding example by adding all methods and suitable properties
    to `prototype`. In the case of `Shape()` and `TwoDShape()`, everything is meant
    to be shared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you have to take care of inheritance first before augmenting
    the prototype. Otherwise, anything you add to `TwoDShape.prototype` gets wiped
    out when you inherit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Triangle` constructor is a little different, because every object it creates
    is a new triangle, which is likely to have different dimensions. So, it''s good
    to keep `side` and `height` as own properties and share the rest. The `getArea()`
    method, for example, is the same, regardless of the actual dimensions of each
    triangle. Again, you do the inheritance bit first and then augment the prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'All the preceding test code works exactly the same. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is only a slight behind-the-scenes difference when calling `my.toString()`.
    The difference is that there is one more lookup to be done before the method is
    found in `Shape.prototype`, as opposed to in the `new Shape()` instance, like
    it was in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also play with `hasOwnProperty()` to see the difference between the
    own property versus a property coming down the prototype chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The calls to `isPrototypeOf()` and the `instanceof` operator from the previous
    example work in exactly the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Inheriting the prototype only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As explained earlier, for reasons of efficiency, you should add the reusable
    properties and methods to the prototype. If you do so, then it''s a good idea
    to inherit only the prototype, because all the reusable code is there. This means
    that inheriting the `Shape.prototype` object is better than inheriting the object
    created with `new Shape()`. After all, `new Shape()` only gives you own shape
    properties that are not meant to be reused (otherwise, they would be in the prototype).
    You gain a little more efficiency by:'
  prefs: []
  type: TYPE_NORMAL
- en: Not creating a new object for the sake of inheritance alone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having fewer lookups during runtime (when it comes to searching for `toString()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, here''s the updated code; the changes are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The test code gives you the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What's the difference in the lookups when calling `my.toString()`? First, as
    usual, the JavaScript engine looks for a `toString()`method of the `my` object
    itself. The engine doesn't find such a method, so it inspects the prototype. The
    prototype turns out to be pointing to the same object that the prototype of `TwoDShape`
    points to and also the same object that `Shape.prototype` points to. Remember
    that objects are not copied by value, but only by reference. So, the lookup is
    only a two-step process as opposed to four (in the previous example) or three
    (in the first example).
  prefs: []
  type: TYPE_NORMAL
- en: Simply copying the prototype is more efficient, but it has a side effect because,
    all the prototypes of the children and parents point to the same object, when
    a child modifies the prototype, the parents get the changes and so do the siblings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It changes the `name` property, so it effectively changes `Shape.prototype.name`
    too. If you create an instance using `new Shape()`, its `name` property says `"Triangle"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This method is more efficient, but may not suit all your use cases.
  prefs: []
  type: TYPE_NORMAL
- en: A temporary constructor - new F()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution to the previously outlined problem, where all prototypes point to
    the same object and the parents get children's properties, is to use an intermediary
    to break the chain. The intermediary is in the form of a temporary constructor
    function. Creating an empty function `F()` and setting its `prototype` to the
    prototype of the parent constructor allows you to call `new F()`and create objects
    that have no properties of their own, but inherit everything from the parent's
    `prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the modified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating `my` triangle and testing the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this approach, the prototype chain stays in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the parents'' properties are not overwritten by the children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At the same time, this approach supports the idea that only properties and methods
    added to the prototype should be inherited and own properties should not. The
    rationale behind this is that own properties are likely to be too specific to
    be reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Uber - access to the parent from a child object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classical OO languages usually have a special syntax that gives you access to
    the parent class, also referred to the superclass. This could be convenient when
    a child wants to have a method that does everything the parent's method does,
    plus something in addition to it. In such cases, the child calls the parent's
    method with the same name and works with the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, there is no such special syntax, but it''s trivial to achieve
    the same functionality. Let''s rewrite the last example, and while taking care
    of inheritance, also create an `uber` property that points to the parent''s `prototype`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The new things here are:'
  prefs: []
  type: TYPE_NORMAL
- en: A new `uber` property points to the parent's `prototype`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The updated `toString()`method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Previously, `toString()` only returned `this.name`. Now, in addition to this,
    there is a check to see whether `this.constructor.uber` exists and, if it does,
    call its `toString()` first. The `this.constructor` is the function itself, and
    `this.constructor.uber` points to the parent''s `prototype`. The result is that
    when you call `toString()` for a `Triangle` instance, all `toString()` methods
    up the prototype chain are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The name of the `uber` property could've been superclass, but this would suggest
    that JavaScript has classes. Ideally, it could've been super (as in Java), but
    super is a reserved word in JavaScript. The German word uber suggested by Douglas
    Crockford means more or less the same as super, and you have to admit, it sounds
    uber cool.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating the inheritance part into a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move the code that takes care of all the inheritance details from the
    last example into a reusable `extend()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this function (or your own custom version of it) helps you keep your
    code clean with regard to the repetitive inheritance-related tasks. This way,
    you can inherit by simply using the following two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see a complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Lets test the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Copying properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s try a slightly different approach. Since inheritance is all about
    reusing code, can you simply copy the properties you like from one object to another?
    Or from a parent to a child? Keeping the same interface as the preceding `extend()`
    function, you can create a `extend2()`function, which takes two constructor functions
    and copies all the properties from the parent''s `prototype` to the child''s `prototype`.
    This will, of course, carry over methods too, as methods are just properties that
    happen to be functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a simple loop through the properties is all it takes. As with
    the previous example, you can set an `uber` property if you want to have handy
    access to parent's methods from the child. Unlike the previous example though,
    it's not necessary to reset `Child.prototype.constructor` because here, the child
    `prototype` is augmented, not overwritten completely. So, the `constructor` property
    points to the initial value.
  prefs: []
  type: TYPE_NORMAL
- en: This method is a little inefficient compared to the previous method because
    properties of the child `prototype` are being duplicated instead of simply being
    looked up via the prototype chain during execution. Bear in mind that this is
    only true for properties containing primitive types. All objects (including functions
    and arrays) are not duplicated, because these are passed by reference only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of using two constructor functions, `Shape()` and `TwoDShape()`.
    The `Shape()` function''s `prototype` object contains a primitive property, `name`,
    and a non-primitive one, the `toString()`method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you inherit with `extend()`, neither the objects created with `TwoDShape()`
    nor its prototype get an own `name` property, but they have access to the one
    they inherit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you inherit with `extend2()`, the prototype of `TwoDShape()`gets
    its own copy of the `name` property. It also gets its own copy of `toString()`,
    but it''s a reference only, so the function will not be recreated a second time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the two `toString()` methods are the same function object. This
    is good because it means that no unnecessary duplicates of the methods are created.
  prefs: []
  type: TYPE_NORMAL
- en: So, you can say that `extend2()` is less efficient than `extend()` because it
    recreates the properties of the prototype. However, this is not so bad because
    only the primitive data types are duplicated. Additionally, this is beneficial
    during the prototype chain lookups as there are fewer chain links to follow before
    finding the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the `uber` property again. This time, for a change, it''s set
    on the `Parent` object''s prototype `p`, not on the `Parent` constructor. This
    is why `toString()` uses it as `this.uber` as opposed to `this.constructor.uber`.
    This is just an illustration that you can shape your favorite inheritance pattern
    in any way you see fit. Let''s test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`TwoDShape` didn''t redefine the `name` property, hence the repetition. It
    can do that at any time, and (the prototype chain being live) all the instances
    see the update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Heads-up when copying by reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fact that objects (including functions and arrays) are copied by reference
    could sometimes lead to results you don't expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two constructor functions and add properties to the prototype
    of the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have `Wee` inherit from `Papa` (either `extend()` or `extend2()`
    will do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `extend2()`, the `Wee` function''s prototype inherited the properties
    of `Papa.prototype` as its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name` property is primitive, so a new copy of it is created. The `owns`
    property is an array object, so it''s copied by reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the `Wee` function''s copy of `name` doesn''t affect `Papa`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the `Wee` function''s `owns` property, however, affects `Papa`, because
    both properties point to the same array in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a different story when you completely overwrite the `Wee` function''s
    copy of `owns` with another object (as opposed to modifying the existing one).
    In this case, `Papa.owns` keeps pointing to the old object, while `Wee.owns` points
    to a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Think of an object as something that is created and stored in a physical location
    in memory. Variables and properties merely point to this location, so when you
    assign a brand new object to `Wee.prototype.owns`, you essentially say-Hey, forget
    about this other old object, move your pointer to this new one instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates what happens if you imagine the memory being
    a heap of objects (like a wall of bricks) and you point to (refer to) some of
    these objects:'
  prefs: []
  type: TYPE_NORMAL
- en: A new object is created, and **A** points to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new variable **B** is created and made equal to **A**, meaning it now points
    to the same place **A** is pointing to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A property color is changed using the **B** handle (pointer). The brick is now
    white. **A** check for `A.color === "white"` would be true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A new object is created, and the **B** variable/pointer is recycled to point
    to that new object. **A** and **B** are now pointing to different parts of the
    memory pile. They have nothing in common and changes to one of them don''t affect
    the other:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Heads-up when copying by reference](graphics/image_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to address the problem that objects are copied by reference, consider
    a deep copy, described later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Objects inherit from objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the examples so far in this chapter assume that you create your objects
    with constructor functions, and you want objects created with one constructor
    to inherit properties that come from another constructor. However, you can also
    create objects without the help of a constructor function, just using the object
    literal, and this is, in fact, less typing. So, how about inheriting those?
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java or PHP, you define classes and have them inherit from other classes.
    That''s why you''ll see the term classical, because the OO functionality comes
    from the use of classes. In JavaScript, there are no classes, so programmers that
    come from a classical background resort to constructor functions, because constructors
    are the closest to what they are used to. In addition, JavaScript provides the
    `new` operator, which can further suggest that JavaScript is like Java. The truth
    is that, in the end, it all comes down to objects. The first example in this chapter
    used this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Child` constructor (or class, if you will) inherits from `Parent`.
    However, this is done by creating an object using `new Parent()` and inheriting
    from it. That's why this is also referred to as a **pseudo-classical inheritance
    pattern**, because it resembles classical inheritance, although it isn't (no classes
    are involved).
  prefs: []
  type: TYPE_NORMAL
- en: So, why not get rid of the middleman (the constructor/class) and just have objects
    inherit from objects? In `extend2()`, the properties of the parent `prototype`
    object were copied as properties of the child `prototype` object. The two prototypes
    are, in essence, just objects. Forgetting about prototypes and constructor functions,
    you can simply take an object and copy all of its properties into another object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You already know that objects can start as a blank canvas without any own properties,
    using `var o = {};`, and then get properties later. However, instead of starting
    fresh, you can start by copying all of the properties of an existing object. Here''s
    a function that does exactly this: it takes an object and returns a new copy of
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply copying all the properties is a straightforward pattern, and it''s widely
    used. Let''s see this function in action. You start by having a base object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to create a new object that builds upon the old one, you can call
    the `extendCopy()` function, which returns a new object. Then, you can augment
    the new object with additional functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a triangle object that inherits the `2D shape` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the triangle, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A possible drawback of this method is the somewhat verbose way of initializing
    the new `triangle` object, where you manually set values for `side` and `height`,
    as opposed to passing them as values to a constructor. However, this is easily
    resolved by having a function, for example, called `init()` (or `__construct()`
    if you come from PHP) that acts as a constructor and accepts initialization parameters.
    Alternatively, have `extendCopy()` accept two parameters, an object to inherit
    from and another object literal of properties to add to the copy before it's returned.
    In other words, just merge two objects.
  prefs: []
  type: TYPE_NORMAL
- en: Deep copy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `extendCopy()` function discussed previously creates what is called a shallow
    copy of an object, just like `extend2()` before that. The opposite of a shallow
    copy would be, naturally, a deep copy. As discussed previously (in the *Heads-up
    when copying by reference* section of this chapter), when you copy objects, you
    only copy pointers to the location in memory where the object is stored. This
    is what happens in a shallow copy. If you modify an object in the copy, you also
    modify the original. The deep copy avoids this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deep copy is implemented in the same way as the shallow copy-you loop through
    the properties and copy them one by one. However, when you encounter a property
    that points to an object, you call the `deepcopy` function again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an object that has arrays and a subobject as properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test this by creating a deep copy and a shallow copy. Unlike the shallow
    copy, when you update the `numbers` property of a deep copy, the original is not
    affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Two side notes about the `deepCopy()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering out non-own properties with `hasOwnProperty()` is always a good idea
    to make sure you don't carry over someone's additions to the core prototypes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.isArray()` exists since ES5 because it''s surprisingly hard otherwise
    to tell real arrays from objects. The best cross-browser solution (if you need
    to define `isArray()` in ES3 browsers) looks a little hacky, but it works:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Using object() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the idea that objects inherit from objects, Douglas Crockford advocates
    the use of an `object()` function that accepts an object and returns a new one
    that has the parent as a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need access to an `uber` property, you can modify the `object()` function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `this` function is the same as using `extendCopy()`, you take an object
    such as `twoDee`, create a new object from it, and then proceed to augmenting
    the new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The new triangle still behaves the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This pattern is also referred to as **prototypal inheritance**, because you
    use a parent object as the prototype of a child object. It''s also adopted and
    built upon in ES5 and called `Object.create()`. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Using a mix of prototypal inheritance and copying properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use inheritance, you will most likely want to take an already existing
    functionality and then build upon it. This means creating a new object by inheriting
    from an existing object and then adding additional methods and properties. You
    can do this with one function call using a combination of the last two approaches
    just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can:'
  prefs: []
  type: TYPE_NORMAL
- en: Use prototypal inheritance to use an existing object as a prototype of a new
    one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Copy all the properties of another object into the newly created one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This function takes an object `o` to inherit from and another object `stuff`
    that has the additional methods and properties that are to be copied. Let's see
    this in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the base `shape` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a 2D object by inheriting shape and adding more properties. The additional
    properties are simply created with an object literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a `triangle` object that inherits from 2D and adds more
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test how it all works by creating a concrete triangle `my` with defined
    `side` and `height`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference here, when executing `toString()`, is that the `Triangle` name
    is repeated twice. That''s because the concrete instance was created by inheriting
    `triangle`, so there was one more level of inheritance. You could give the new
    instance a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This `objectPlus()` is even closer to ES5's `Object.create();` only the ES5
    one takes the additional properties (the second argument) using something called
    property descriptors (discussed in [Appendix C](apc.html "Appendix C. Built-in
    Objects"), *Built-In Objects*).
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple inheritance is where a child inherits from more than one parent. Some
    OO languages support multiple inheritance out of the box and some don't. You can
    argue both ways, that multiple inheritance is convenient or that it's unnecessary,
    complicates application design, and it's better to use an inheritance chain instead.
    Leaving the discussion of multiple inheritance's pros and cons for the long, cold
    winter nights, let's see how you can do it in practice in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation can be as simple as taking the idea of inheritance by copying
    properties and expanding it so that it takes an unlimited number of input objects
    to inherit from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `multi()` function that accepts any number of input objects.
    You can wrap the loop that copies properties in another loop that goes through
    all the objects passed as `arguments` to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test this by creating three objects-`shape`, `twoDee`, and a third,
    unnamed object. Then, creating a `triangle` object means calling `multi()` and
    passing all three objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Does this work? Let''s see. The `getArea()` method should be an own property,
    `dimensions` should come from `twoDee`, and `toString()` should come from `shape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that `multi()` loops through the input objects in the order they
    appear and if it happens that two of them have the same property, the last one
    wins.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might come across the term mixin. Think of a mixin as an object that provides
    some useful functionality but is not meant to be inherited and extended by subobjects.
    The approach to multiple inheritance outlined previously can be considered an
    implementation of the mixins idea. When you create a new object, you can pick
    and choose any other objects to mix into your new object. By passing them all
    to `multi()`, you get all their functionality without making them part of the
    inheritance tree.
  prefs: []
  type: TYPE_NORMAL
- en: Parasitic inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you like the fact that you can have all kinds of different ways to implement
    inheritance in JavaScript and you're hungry for more, here's another one. This
    pattern, courtesy of Douglas Crockford, is called parasitic inheritance. It's
    about a function that creates objects by taking all the functionality from another
    object into a new one, augmenting the new object, and returning it, pretending
    that it has done all the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an ordinary object, defined with an object literal, and unaware of
    the fact that it''s soon going to fall victim to parasitism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'A function that creates `triangle` objects could:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `twoD` object as a prototype of an object called that (similar to this
    for convenience). This can be done in any way you saw previously, for example,
    using the `object()` function or copying all the properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augment that with more properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return `that`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `triangle()` is a normal function, not a constructor, it doesn''t require
    the `new` operator. However, because it returns an object, calling it with `new`
    by mistake works too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Note that `that` is just a name, it doesn't have a special meaning, the way
    `this` does.
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing a constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One more way of implementing inheritance (the last one in the chapter, I promise)
    has to do again with constructor functions and not the objects directly. In this
    pattern, the constructor of the child calls the constructor of the parent using
    either the `call()` or `apply()` method. This can be called **stealing a constructor**
    or **inheritance by borrowing a constructor** if you want to be more subtle about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The `call()` and `apply()` methods were discussed in [Chapter 4](ch04.html "Chapter 4. Objects"),
    *Objects*, but here's a refresher; they allow you to call a function and pass
    an object that the function should bind to its `this` value. So for inheritance
    purposes, the child constructor calls the parent's constructor and binds the child's
    newly created `this` object as the parent's `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have this parent constructor `Shape()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define `Triangle()`, which uses `apply()` to call the `Shape()`
    constructor, passing `this` (an instance created with `new Triangle()`) and any
    additional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that both `Triangle()` and `Shape()`have added some extra properties to
    their prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test this by creating a new `triangle` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `triangle` object inherits the `id` property from the parent, but it
    doesn''t inherit anything added to the parent''s `prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The triangle failed to get the `Shape` function''s prototype properties because
    there was never a `new Shape()` instance created, so the prototype was never used.
    However, you saw how to do this at the beginning of this chapter. You can redefine
    `Triangle` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this inheritance pattern, the parent's own properties are recreated as the
    child's own properties. If a child inherits an array or other object, it's a completely
    new value (not a reference), and modifying it won't affect the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The drawback is that the parent''s constructor gets called twice-once with
    `apply()` to inherit own properties and once with `new` to inherit the prototype.
    In fact, the own properties of the parent are inherited twice. Let''s take this
    simplified scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will create a new instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s an own property `id,` but there''s also one that comes down the prototype
    chain, ready to shine through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Borrowing a constructor and copying its prototype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The problem of the double work performed by calling the constructor twice can
    easily be corrected. You can call `apply()` on the parent constructor to get all
    own properties and then copy the prototype''s properties using a simple iteration
    (or `extend2()` as discussed previously):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Lets test the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'No double inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `extend2()` method also gives access to `uber` if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Case study - drawing shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's finish off this chapter with a more practical example of using inheritance.
    The task is to be able to calculate the area and the perimeter of different shapes,
    as well as to draw them, while reusing as much code as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's have one `Shape` constructor that contains all the common parts. From
    there, let's have `Triangle`, `Rectangle`, and `Square` constructors, all inheriting
    from `Shape`. A square is really a rectangle with the same length sides, so let's
    reuse `Rectangle` when building `Square`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to define a shape, you'll need points with `x` and `y` coordinates.
    A generic shape can have any number of points. A triangle is defined with three
    points, a rectangle (to keep it simpler) with one point and the lengths of the
    sides. The perimeter of any shape is the sum of its side's lengths. Calculating
    the area is shape specific and will be implemented by each shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common functionality in `Shape` would be:'
  prefs: []
  type: TYPE_NORMAL
- en: A `draw()` method that can draw any shape given the points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `getParameter()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A property that contains an array of `points`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other methods and properties as needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the drawing part, let's use a `<canvas>` tag. It's not supported in early
    IEs, but hey, this is just an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have two other helper constructors-`Point` and `Line`. `Point` will help
    when defining shapes. `Line` will make calculations easier, as it can give the
    length of the line connecting any two given points.
  prefs: []
  type: TYPE_NORMAL
- en: You can play with a working example at [http://www.phpied.com/files/canvas/](http://www.phpied.com/files/canvas/).
    Just open your console and start creating new shapes as you'll see in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by adding a `canvas` tag to a blank HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, put the JavaScript code inside `<script>` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at what''s in the JavaScript part. First is the helper
    `Point` constructor. It just can''t get any simpler than the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Bear in mind that the coordinates of the points on the `canvas` start from
    `x=0`, `y=0`, which is the top left. The bottom right will be `x = 800`, `y =
    600`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](graphics/image_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next comes the `Line` constructor. It takes two points and calculates the length
    of the line between them, using the Pythagorean theorem *a² + b² = c²* (imagine
    a right-angled triangle where the hypotenuse connects the two given points):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Next comes the `Shape` constructor. The shapes will have their points (and
    the lines that connect them) as own properties. The constructor also invokes an
    initialization method, `init()`, that will be defined in the prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the big part-the methods of `Shape.prototype`. Let''s define all these
    methods using the object literal notation. Refer to the comments for guidelines
    as to what each method does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the children constructor functions. `Triangle` comes first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Triangle` constructor takes three point objects and assigns them to `this.points`
    (its own collection of points). Then, it implements the `getArea()` method, using
    Heron''s formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '`s` is the semi-perimeter (perimeter divided by two).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the `Rectangle` constructor. It receives one point (the upper-left
    point) and the lengths of the two sides. Then, it populates its `points` array
    starting from that one point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The last child constructor is `Square`. A square is a special case of a rectangle,
    so it makes sense to reuse `Rectangle`. The easiest thing to do here is to borrow
    the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all constructors are done, let''s take care of inheritance. Any pseudo-classical
    pattern (one that works with constructors as opposed to objects) will do. Let''s
    try using a modified and simplified version of the prototype-chaining pattern
    (the first method described in this chapter). This pattern calls for creating
    a new instance of the parent and setting it as the child''s prototype. In this
    case, it''s not necessary to have a new instance for each child-they can all share
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s test this by drawing shapes. First, define three points for a triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can create a triangle by passing the three points to the `Triangle`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the methods to draw the triangle on the `canvas` and get its area
    and perimeter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s play with a rectangle instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, let''s play with a square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s fun to draw these shapes. You can also be as lazy as the following example,
    which draws another square, reusing a triangle''s point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the tests will be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing](graphics/image_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lets do the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement multiple inheritance but with a prototypal inheritance pattern, not
    property copying. Here is an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The `additional` property should be an own property; all the rest should be
    mixed into the prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `canvas` example to practice. Try out different things. Here are some
    examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a few triangles, squares, and rectangles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add constructors for more shapes, such as `Trapezoid`, `Rhombus`, `Kite`, and
    `Pentagon`. If you want to learn more about the `canvas` tag, create a `Circle`
    constructor too. It will need to overwrite the `draw()` method of the parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you think of another way to approach the problem and use another type of
    inheritance?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pick one of the methods that uses `uber` as a way for a child to access its
    parent. Add functionality where the parents can keep track of who their children
    are, perhaps using a property that contains a `children` array?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned quite a few ways (patterns) of implementing inheritance,
    and the following table summarizes them. The different types can roughly be divided
    into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Patterns that work with constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns that work with objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also classify the patterns based on whether they:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do both (copy properties of the prototype):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **#** | **Name** | **Example** | **Classification** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Prototype chaining(pseudo-classical) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Works with constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the prototype chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The default mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip - move all properties/methods that are meant to be reused to the prototype,
    and add the non-reusable as own properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 2 | Inherit only the prototype |'
  prefs: []
  type: TYPE_TB
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Works with constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies the prototype (no prototype chain, as all share the same prototype object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: More efficient; no new instances are created just for the sake of inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype chain lookup during runtime; it is fast, since there's no chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Drawback: children can modify parents'' functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3 | Temporary constructor |'
  prefs: []
  type: TYPE_TB
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Works with constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the prototype chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike #1, it only inherits properties of the prototype; own properties (created
    with this inside the constructor) are not inherited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides convenient access to the parent (through `uber`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 4 | Copying the `prototype` properties |'
  prefs: []
  type: TYPE_TB
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Works with constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the prototype chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: All properties of the parent prototype become properties of the child prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need to create a new object only for inheritance purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shorter prototype chains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 5 | Copy all properties(shallow copy) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Works with objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Simple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doesn't use prototypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 6 | Deep copy | Same as the previous one, but recurse into objects |'
  prefs: []
  type: TYPE_TB
- en: Works with objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Same as #5, but clones objects and arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | Prototypal inheritance |'
  prefs: []
  type: TYPE_TB
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Works with objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the prototype chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: No pseudo-classes, objects inherit from objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverages the benefits of the prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 8 | Extend and augment |'
  prefs: []
  type: TYPE_TB
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Works with objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the prototype chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Mix of prototypal inheritance (#7) and copying properties (#5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One function call to inherit and extend at the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 9 | Multiple inheritance |'
  prefs: []
  type: TYPE_TB
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Works with objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: A mixin-style implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies all the properties of all the parent objects in the order of appearance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 10 | Parasitic inheritance |'
  prefs: []
  type: TYPE_TB
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Works with objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the prototype chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor-like function creates objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies an object, and augments and returns the copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 11 | Borrowing constructors |'
  prefs: []
  type: TYPE_TB
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Works with constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Inherits only own properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Can be combined with #1 to inherit the prototype too'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenient way to deal with the issues when a child inherits a property that
    is an object (and therefore, passed by reference)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 12 | Borrow a constructor and copy the prototype |'
  prefs: []
  type: TYPE_TB
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Works with constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the prototype chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Combination of #11 and #4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to inherit both own properties and prototype properties without calling
    the parent constructor twice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Given so many options, you must be wondering which is the right one. That depends
    on your style and preferences, your project, task, and team. Are you more comfortable
    thinking in terms of classes? Then pick one of the methods that work with constructors.
    Are you going to need just one or a few instances of your class? Then choose an
    object-based pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Are these the only ways of implementing inheritance? No. You can choose a pattern
    from the preceding table, you can mix them, or you can think of your own. The
    important thing is to understand and be comfortable with objects, prototypes,
    and constructors; the rest is just pure joy.
  prefs: []
  type: TYPE_NORMAL

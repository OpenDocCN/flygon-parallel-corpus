- en: Chapter 7. Inheritance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。继承
- en: If you go back to [Chapter 1](ch01.html "Chapter 1. Object-Oriented JavaScript"),
    *Object-Oriented JavaScript*, and review the *Object-oriented programming* section,
    you'll see that you already know how to apply most of them to JavaScript. You
    know what objects, methods, and properties are. You know that there are no classes
    in ES5, although you can achieve them using constructor functions. ES6 introduces
    the notion of classes; we will take a detailed look at how ES6 classes work in
    the next chapter. Encapsulation? Yes, the objects encapsulate both the data and
    the means (methods) to do something with the data. Aggregation? Sure, an object
    can contain other objects. In fact, this is almost always the case since methods
    are functions and functions are also objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回到[第1章](ch01.html "第1章。面向对象的JavaScript") *面向对象的JavaScript*，并回顾*面向对象编程*部分，您会发现您已经知道如何将大部分应用到JavaScript中。您知道对象、方法和属性是什么。您知道ES5中没有类，尽管您可以使用构造函数来实现它们。ES6引入了类的概念；我们将在下一章详细了解ES6类的工作原理。封装？是的，对象封装了数据和处理数据的方法（方法）。聚合？当然，一个对象可以包含其他对象。事实上，这几乎总是这种情况，因为方法是函数，函数也是对象。
- en: Now, let's focus on the inheritance part. This is one of the most interesting
    features, as it allows you to reuse existing code, thus promoting laziness, which
    is likely to be what brought human species to computer programming in the first
    place.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于继承部分。这是最有趣的特性之一，因为它允许您重用现有的代码，从而促进懒惰，这很可能是最初吸引人类物种进行计算机编程的原因。
- en: JavaScript is a dynamic language, and there is usually more than one way to
    achieve any given task. Inheritance is not an exception. In this chapter, you'll
    see some common patterns for implementing inheritance. Having a good understanding
    of these patterns will help you pick the right one, or the right mix, depending
    on your task, project, or style.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种动态语言，通常有多种方法可以实现任何给定的任务。继承也不例外。在本章中，您将看到一些常见的实现继承的模式。对这些模式有很好的理解将帮助您选择合适的模式，或者根据您的任务、项目或风格选择合适的混合模式。
- en: Prototype chaining
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型链
- en: Let's start with the default way of implementing inheritance - inheritance chaining
    through the prototype.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现继承的默认方式开始 - 通过原型进行继承链。
- en: As you already know, every function has a `prototype` property, which points
    to an object. When a function is invoked using the `new` operator, an object is
    created and returned. This new object has a secret link to the `prototype` object.
    The secret link (called `__proto__` in some environments) allows methods and properties
    of the `prototype` object to be used as if they belonged to the newly created
    object.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的，每个函数都有一个`prototype`属性，指向一个对象。当使用`new`运算符调用函数时，将创建并返回一个对象。这个新对象有一个指向`prototype`对象的秘密链接。秘密链接（在某些环境中称为`__proto__`）允许使用`prototype`对象的方法和属性，就好像它们属于新创建的对象一样。
- en: 'The `prototype` object is just a regular object and, therefore, it also has
    the secret link to its prototype. And so, a chain called a prototype chain is
    created:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`prototype`对象只是一个普通对象，因此它也有指向它的原型的秘密链接。因此，创建了一个称为原型链的链：'
- en: '![Prototype chaining](graphics/proto.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![原型链](graphics/proto.jpg)'
- en: In this illustration, an object **A** contains a number of properties. One of
    the properties is the hidden `__proto__` property, which points to another object,
    **B**. **B**'s `__proto__` property points to **C**. This chain ends with the
    `Object.prototype` object, the grandparent, and every object inherits from it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，对象**A**包含许多属性。其中一个属性是隐藏的`__proto__`属性，它指向另一个对象**B**。**B**的`__proto__`属性指向**C**。这个链以`Object.prototype`对象结束，这是祖父，每个对象都从它继承。
- en: This is all good to know, but how does it help you? The practical side is that
    when object **A** lacks a property but **B** has it, **A** can still access this
    property as its own. The same applies if **B** also doesn't have the required
    property, but **C** does. This is how inheritance takes place - an object can
    access any property found somewhere down the inheritance chain.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是很好知道的，但它如何帮助你呢？实际的一面是，当对象**A**缺少一个属性，但**B**有它时，**A**仍然可以访问这个属性作为它自己的。如果**B**也没有所需的属性，但**C**有，同样适用。这就是继承发生的方式
    - 一个对象可以访问沿着继承链找到的任何属性。
- en: Throughout this chapter, you'll see different examples that use the following
    hierarchy - a generic `Shape` parent is inherited by a `2D shape`, which in turn
    is inherited by any number of specific two-dimensional shapes such as a triangle,
    rectangle, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将看到使用以下层次结构的不同示例 - 一个通用的`Shape`父类被一个`2D shape`继承，然后被任意数量的特定的二维形状继承，比如三角形、矩形等等。
- en: Prototype chaining example
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型链示例
- en: 'Prototype chaining is the default way to implement inheritance. In order to
    implement the hierarchy, let''s define three constructor functions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 原型链是实现继承的默认方式。为了实现层次结构，让我们定义三个构造函数：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code that performs the inheritance magic is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 执行继承魔术的代码如下：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What's happening here? You take the object contained in the `prototype` property
    of `TwoDShape`, and instead of augmenting it with individual properties, you completely
    overwrite it with another object, created by invoking the `Shape()` constructor
    with `new`. The same process can be followed for `Triangle`-its prototype is replaced
    by an object created by `new TwoDShape()`. It's important to remember that JavaScript
    works with objects, not classes. You need to create an instance using the `new
    Shape()` constructor, and after that, you can inherit its properties; you don't
    inherit from `Shape()` directly. Additionally, after inheriting, you can modify
    the `Shape()` constructor, overwrite it, or even delete it, and this will have
    no effect on `TwoDShape`, because all you needed is one instance to inherit from.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？您获取了`TwoDShape`的`prototype`属性中包含的对象，并且不是增加个别属性，而是完全用另一个对象覆盖它，该对象是通过使用`new`调用`Shape()`构造函数创建的。对`Triangle`也可以遵循相同的过程-它的原型被`new
    TwoDShape()`创建的对象所取代。重要的是要记住JavaScript使用对象而不是类。您需要使用`new Shape()`构造函数创建一个实例，然后才能继承其属性；您不直接从`Shape()`继承。此外，在继承后，您可以修改`Shape()`构造函数，覆盖它，甚至删除它，这不会对`TwoDShape`产生影响，因为您只需要一个实例来继承。
- en: 'As you know from the previous chapter, overwriting the prototype (as opposed
    to just adding properties to it), has side effects on the `constructor` property.
    Therefore, it''s a good idea to reset the `constructor` property after inheriting.
    Consider the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从上一章中所知道的，重写原型（而不仅仅是向其添加属性）会对`constructor`属性产生副作用。因此，在继承后重置`constructor`属性是一个好主意。考虑以下示例：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s test what has happened so far. Creating a `Triangle` object and
    calling its own `getArea()` method works as expected:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下到目前为止发生了什么。创建一个`Triangle`对象并调用其自己的`getArea()`方法可以正常工作：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Although the `my` object doesn''t have its own `toString()` method, it inherited
    one and you can call it. Note how the inherited method `toString()` binds the
    `this` object to `my`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`my`对象没有自己的`toString()`方法，但它继承了一个，您可以调用它。请注意，继承的方法`toString()`将`this`对象绑定到`my`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s fascinating to consider what the JavaScript engine does when you call
    `my.toString()`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`my.toString()`时，考虑一下JavaScript引擎的操作：
- en: It loops through all of the properties of `my` and doesn't find a method called
    `toString()`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它循环遍历`my`的所有属性，并没有找到名为`toString()`的方法。
- en: It looks at the object that `my.__proto__` points to `this` object is the instance
    `new TwoDShape()` created during the inheritance process.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它查看`my.__proto__`指向的对象，这个对象是在继承过程中创建的`new TwoDShape()`实例。
- en: Now, the JavaScript engine loops through the instance of `TwoDShape` and doesn't
    find a `toString()` method. It then checks `__proto__` of that object. This time,
    `__proto__` points to the instance created by `new Shape()`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，JavaScript引擎循环遍历`TwoDShape`的实例，并没有找到`toString()`方法。然后它检查该对象的`__proto__`。这一次，`__proto__`指向由`new
    Shape()`创建的实例。
- en: The instance of `new Shape()` is examined, and `toString()` is finally found.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`new Shape()`的实例，最终找到了`toString()`。
- en: This method is invoked in the context of `my`, meaning that `this` points to
    `my`.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法在`my`的上下文中被调用，这意味着`this`指向`my`。
- en: 'If you ask `my`, Who''s your constructor?, it reports it correctly because
    of the reset of the `constructor` property after the inheritance:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您问`my`，你的构造函数是谁？，它会正确报告，因为在继承后重置了`constructor`属性：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using the `instanceof` operator, you can validate that `my` is an instance
    of all three constructors:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`instanceof`运算符，您可以验证`my`是所有三个构造函数的实例：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The same happens when you call `isPrototypeOf()`on the constructors by passing
    `my`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过传递`my`调用`isPrototypeOf()`时，会发生相同的情况：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also create objects using the other two constructors. Objects created
    with `new TwoDShape()` also get the `toString()`method inherited from `Shape()`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用其他两个构造函数创建对象。使用`new TwoDShape()`创建的对象也会继承自`Shape()`继承的`toString()`方法：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Moving shared properties to the prototype
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将共享属性移动到原型
- en: 'When you create objects using a constructor function, own properties are added
    using `this`. This could be inefficient in cases where properties don''t change
    across instances. In the previous example, `Shape()` was defined as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用构造函数创建对象时，使用`this`添加自己的属性。在属性跨实例不变的情况下，这可能效率低下。在前面的示例中，`Shape()`定义如下：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This means that every time you create a new object using `new Shape()`, a new
    `name` property is created and stored somewhere in the memory. The other option
    is to have the `name` property added to the prototype and shared among all the
    instances:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次使用`new Shape()`创建新对象时，都会创建一个新的`name`属性并将其存储在内存中的某个位置。另一种选择是将`name`属性添加到原型中，并在所有实例之间共享：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, every time you create an object using `new Shape()`, this object doesn't
    get its own property `name`, but uses the one added to the prototype. This is
    more efficient, but you should only use it for properties that don't change from
    one instance to another. Methods are ideal for this type of sharing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次使用`new Shape()`创建对象时，该对象都不会获得自己的`name`属性，而是使用添加到原型中的属性。这更有效，但您应该只对不会从一个实例更改为另一个实例的属性使用它。方法非常适合这种共享。
- en: 'Let''s improve the preceding example by adding all methods and suitable properties
    to `prototype`. In the case of `Shape()` and `TwoDShape()`, everything is meant
    to be shared:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有方法和适当的属性添加到`prototype`来改进前面的示例。在`Shape()`和`TwoDShape()`的情况下，一切都是共享的：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, you have to take care of inheritance first before augmenting
    the prototype. Otherwise, anything you add to `TwoDShape.prototype` gets wiped
    out when you inherit.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您必须先处理继承，然后再增加原型。否则，当您继承时，添加到`TwoDShape.prototype`的任何内容都会被清除。
- en: 'The `Triangle` constructor is a little different, because every object it creates
    is a new triangle, which is likely to have different dimensions. So, it''s good
    to keep `side` and `height` as own properties and share the rest. The `getArea()`
    method, for example, is the same, regardless of the actual dimensions of each
    triangle. Again, you do the inheritance bit first and then augment the prototype:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Triangle`构造函数有点不同，因为它创建的每个对象都是一个新的三角形，可能具有不同的尺寸。因此，最好将`side`和`height`作为自有属性，并共享其余部分。例如，`getArea()`方法是相同的，无论每个三角形的实际尺寸如何。同样，首先进行继承，然后增加原型：'
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'All the preceding test code works exactly the same. Here is an example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有先前的测试代码都完全相同。这是一个例子：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is only a slight behind-the-scenes difference when calling `my.toString()`.
    The difference is that there is one more lookup to be done before the method is
    found in `Shape.prototype`, as opposed to in the `new Shape()` instance, like
    it was in the previous example.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`my.toString()`时，只有一个微小的幕后差异。不同之处在于在找到`Shape.prototype`之前，需要进行一次额外的查找，而不是在`new
    Shape()`实例中，就像在先前的示例中一样。
- en: 'You can also play with `hasOwnProperty()` to see the difference between the
    own property versus a property coming down the prototype chain:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`hasOwnProperty()`来查看自有属性与原型链中的属性之间的差异：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The calls to `isPrototypeOf()` and the `instanceof` operator from the previous
    example work in exactly the same way:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 先前示例中对`isPrototypeOf()`和`instanceof`运算符的调用方式完全相同：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Inheriting the prototype only
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只继承原型
- en: 'As explained earlier, for reasons of efficiency, you should add the reusable
    properties and methods to the prototype. If you do so, then it''s a good idea
    to inherit only the prototype, because all the reusable code is there. This means
    that inheriting the `Shape.prototype` object is better than inheriting the object
    created with `new Shape()`. After all, `new Shape()` only gives you own shape
    properties that are not meant to be reused (otherwise, they would be in the prototype).
    You gain a little more efficiency by:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，出于效率考虑，应将可重复使用的属性和方法添加到原型中。如果这样做，那么只继承原型是一个好主意，因为所有可重复使用的代码都在那里。这意味着继承`Shape.prototype`对象比继承使用`new
    Shape()`创建的对象更好。毕竟，`new Shape()`只会给出自有形状属性，这些属性不打算被重复使用（否则，它们将在原型中）。通过这样做，您可以获得更高的效率：
- en: Not creating a new object for the sake of inheritance alone
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅仅为了继承而创建新对象
- en: Having fewer lookups during runtime (when it comes to searching for `toString()`)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时查找`toString()`时减少查找次数
- en: 'For example, here''s the updated code; the changes are highlighted:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是更新后的代码；更改部分已突出显示：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The test code gives you the same result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码给出了相同的结果：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What's the difference in the lookups when calling `my.toString()`? First, as
    usual, the JavaScript engine looks for a `toString()`method of the `my` object
    itself. The engine doesn't find such a method, so it inspects the prototype. The
    prototype turns out to be pointing to the same object that the prototype of `TwoDShape`
    points to and also the same object that `Shape.prototype` points to. Remember
    that objects are not copied by value, but only by reference. So, the lookup is
    only a two-step process as opposed to four (in the previous example) or three
    (in the first example).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`my.toString()`时查找的差异是什么？首先，像往常一样，JavaScript引擎会查找`my`对象本身的`toString()`方法。引擎找不到这样的方法，所以它会检查原型。原型指向与`TwoDShape`的原型和`Shape.prototype`指向的相同对象。请记住，对象不是按值复制的，而是按引用复制的。因此，查找只是一个两步过程，而不是四步（在上一个示例中）或三步（在第一个示例中）。
- en: Simply copying the prototype is more efficient, but it has a side effect because,
    all the prototypes of the children and parents point to the same object, when
    a child modifies the prototype, the parents get the changes and so do the siblings.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地复制原型更有效，但会产生副作用，因为所有子代和父代的原型都指向相同的对象，当子代修改原型时，父代和兄弟也会得到更改。
- en: 'Look at the following line:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面这行：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It changes the `name` property, so it effectively changes `Shape.prototype.name`
    too. If you create an instance using `new Shape()`, its `name` property says `"Triangle"`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它更改了`name`属性，因此实际上也更改了`Shape.prototype.name`。如果使用`new Shape()`创建实例，其`name`属性会显示为“Triangle”：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method is more efficient, but may not suit all your use cases.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法更有效，但可能不适用于所有用例。
- en: A temporary constructor - new F()
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时构造函数 - new F()
- en: A solution to the previously outlined problem, where all prototypes point to
    the same object and the parents get children's properties, is to use an intermediary
    to break the chain. The intermediary is in the form of a temporary constructor
    function. Creating an empty function `F()` and setting its `prototype` to the
    prototype of the parent constructor allows you to call `new F()`and create objects
    that have no properties of their own, but inherit everything from the parent's
    `prototype`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 解决先前概述的问题的一个解决方案是，所有原型都指向相同对象，父代获取子代的属性，是使用中介来打破链条。中介是一个临时构造函数的形式。创建一个空函数`F()`并将其`prototype`设置为父构造函数的原型，允许您调用`new
    F()`并创建没有自有属性但从父代`prototype`继承一切的对象。
- en: 'Let''s take a look at the modified code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下修改后的代码：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Creating `my` triangle and testing the methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`my`三角形并测试方法：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using this approach, the prototype chain stays in place:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，原型链保持不变：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Also, the parents'' properties are not overwritten by the children:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，父代的属性不会被子代覆盖：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At the same time, this approach supports the idea that only properties and methods
    added to the prototype should be inherited and own properties should not. The
    rationale behind this is that own properties are likely to be too specific to
    be reusable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，这种方法支持只继承原型应该继承的属性和方法的想法，而不应该继承自有属性。这背后的原理是，自有属性可能太具体，无法重复使用。
- en: Uber - access to the parent from a child object
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Uber - 从子对象访问父对象
- en: Classical OO languages usually have a special syntax that gives you access to
    the parent class, also referred to the superclass. This could be convenient when
    a child wants to have a method that does everything the parent's method does,
    plus something in addition to it. In such cases, the child calls the parent's
    method with the same name and works with the result.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的面向对象语言通常有一个特殊的语法，让你可以访问父类，也称为超类。当子类想要一个方法，做父类方法的所有事情，再加上一些额外的东西时，这可能很方便。在这种情况下，子类用相同的名称调用父类的方法，并处理结果。
- en: 'In JavaScript, there is no such special syntax, but it''s trivial to achieve
    the same functionality. Let''s rewrite the last example, and while taking care
    of inheritance, also create an `uber` property that points to the parent''s `prototype`
    object:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，没有这样的特殊语法，但实现相同的功能非常简单。让我们重写上一个例子，同时处理继承，并创建一个指向父类`prototype`对象的`uber`属性：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The new things here are:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新东西是：
- en: A new `uber` property points to the parent's `prototype`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的`uber`属性指向父类的`prototype`
- en: The updated `toString()`method
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新的`toString()`方法
- en: 'Previously, `toString()` only returned `this.name`. Now, in addition to this,
    there is a check to see whether `this.constructor.uber` exists and, if it does,
    call its `toString()` first. The `this.constructor` is the function itself, and
    `this.constructor.uber` points to the parent''s `prototype`. The result is that
    when you call `toString()` for a `Triangle` instance, all `toString()` methods
    up the prototype chain are called:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`toString()`只返回`this.name`。现在，除此之外，还有一个检查来看`this.constructor.uber`是否存在，如果存在，首先调用它的`toString()`。`this.constructor`是函数本身，`this.constructor.uber`指向父类的`prototype`。结果是，当你为`Triangle`实例调用`toString()`时，所有原型链上的`toString()`方法都会被调用：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The name of the `uber` property could've been superclass, but this would suggest
    that JavaScript has classes. Ideally, it could've been super (as in Java), but
    super is a reserved word in JavaScript. The German word uber suggested by Douglas
    Crockford means more or less the same as super, and you have to admit, it sounds
    uber cool.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`uber`属性的名称本来可以是superclass，但这会暗示JavaScript有类。理想情况下，它本来可以是super（就像Java中一样），但super在JavaScript中是一个保留字。Douglas
    Crockford建议的德语单词uber的意思与super差不多，你不得不承认，听起来非常酷。'
- en: Isolating the inheritance part into a function
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将继承部分隔离成一个函数
- en: 'Let''s move the code that takes care of all the inheritance details from the
    last example into a reusable `extend()` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将上一个例子中处理所有继承细节的代码移到一个可重用的`extend()`函数中：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using this function (or your own custom version of it) helps you keep your
    code clean with regard to the repetitive inheritance-related tasks. This way,
    you can inherit by simply using the following two lines of code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数（或你自己定制的版本）可以帮助你保持代码在重复的继承相关任务方面的整洁。这样，你可以通过简单地使用以下两行代码来继承：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s see a complete example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个完整的例子：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Lets test the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试以下代码：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Copying properties
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制属性
- en: 'Now, let''s try a slightly different approach. Since inheritance is all about
    reusing code, can you simply copy the properties you like from one object to another?
    Or from a parent to a child? Keeping the same interface as the preceding `extend()`
    function, you can create a `extend2()`function, which takes two constructor functions
    and copies all the properties from the parent''s `prototype` to the child''s `prototype`.
    This will, of course, carry over methods too, as methods are just properties that
    happen to be functions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一个稍微不同的方法。由于继承都是关于重用代码，你能否简单地从一个对象复制你喜欢的属性到另一个对象？或者从父类到子类？保持与前面的`extend()`函数相同的接口，你可以创建一个`extend2()`函数，它接受两个构造函数，并将父类的`prototype`的所有属性复制到子类的`prototype`。当然，这也会复制方法，因为方法只是恰好是函数的属性：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, a simple loop through the properties is all it takes. As with
    the previous example, you can set an `uber` property if you want to have handy
    access to parent's methods from the child. Unlike the previous example though,
    it's not necessary to reset `Child.prototype.constructor` because here, the child
    `prototype` is augmented, not overwritten completely. So, the `constructor` property
    points to the initial value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，通过属性的简单循环就可以完成。与前面的例子一样，如果你想要从子类方便地访问父类的方法，可以设置一个`uber`属性。不过与前面的例子不同的是，在这里，不需要重置`Child.prototype.constructor`，因为这里子类的`prototype`是增强的，而不是完全被覆盖。所以，`constructor`属性指向初始值。
- en: This method is a little inefficient compared to the previous method because
    properties of the child `prototype` are being duplicated instead of simply being
    looked up via the prototype chain during execution. Bear in mind that this is
    only true for properties containing primitive types. All objects (including functions
    and arrays) are not duplicated, because these are passed by reference only.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一种方法相比，这种方法有点低效，因为子类的`prototype`的属性被复制，而不是在执行过程中通过原型链查找。请记住，这只对包含原始类型的属性有效。所有对象（包括函数和数组）都不会被复制，因为这些只是通过引用传递的。
- en: 'Let''s see an example of using two constructor functions, `Shape()` and `TwoDShape()`.
    The `Shape()` function''s `prototype` object contains a primitive property, `name`,
    and a non-primitive one, the `toString()`method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用两个构造函数`Shape()`和`TwoDShape()`的例子。`Shape()`函数的`prototype`对象包含一个原始属性`name`和一个非原始属性`toString()`：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you inherit with `extend()`, neither the objects created with `TwoDShape()`
    nor its prototype get an own `name` property, but they have access to the one
    they inherit:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用`extend()`继承，用`TwoDShape()`创建的对象和它的原型都不会有自己的`name`属性，但它们可以访问继承的那个：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'However, if you inherit with `extend2()`, the prototype of `TwoDShape()`gets
    its own copy of the `name` property. It also gets its own copy of `toString()`,
    but it''s a reference only, so the function will not be recreated a second time:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你用`extend2()`继承，`TwoDShape()`的原型会得到自己的`name`属性的副本。它还会得到自己的`toString()`的副本，但这只是一个引用，所以函数不会被重新创建第二次：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, the two `toString()` methods are the same function object. This
    is good because it means that no unnecessary duplicates of the methods are created.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，两个`toString()`方法是相同的函数对象。这是好的，因为这意味着不会创建不必要的方法副本。
- en: So, you can say that `extend2()` is less efficient than `extend()` because it
    recreates the properties of the prototype. However, this is not so bad because
    only the primitive data types are duplicated. Additionally, this is beneficial
    during the prototype chain lookups as there are fewer chain links to follow before
    finding the property.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以说`extend2()`比`extend()`效率低，因为它重新创建了原型的属性。然而，这并不是很糟糕，因为只有原始数据类型被复制。此外，在原型链查找期间，这对于减少链条链接是有益的，因为在找到属性之前需要跟随的链条更少。
- en: 'Take a look at the `uber` property again. This time, for a change, it''s set
    on the `Parent` object''s prototype `p`, not on the `Parent` constructor. This
    is why `toString()` uses it as `this.uber` as opposed to `this.constructor.uber`.
    This is just an illustration that you can shape your favorite inheritance pattern
    in any way you see fit. Let''s test it out:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看一下`uber`属性。这次，出于变化的原因，它设置在`Parent`对象的原型`p`上，而不是`Parent`构造函数上。这就是为什么`toString()`使用它作为`this.uber`而不是`this.constructor.uber`。这只是一个说明，您可以以任何您认为合适的方式塑造您喜欢的继承模式。让我们来测试一下：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`TwoDShape` didn''t redefine the `name` property, hence the repetition. It
    can do that at any time, and (the prototype chain being live) all the instances
    see the update:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwoDShape`没有重新定义`name`属性，因此会重复。它可以随时这样做，而且（原型链是活动的）所有实例都会看到更新：'
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Heads-up when copying by reference
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用复制时要注意
- en: The fact that objects (including functions and arrays) are copied by reference
    could sometimes lead to results you don't expect.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对象（包括函数和数组）被引用复制的事实有时可能会导致您意想不到的结果。
- en: 'Let''s create two constructor functions and add properties to the prototype
    of the first one:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个构造函数，并向第一个的原型添加属性：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s have `Wee` inherit from `Papa` (either `extend()` or `extend2()`
    will do):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让`Wee`从`Papa`继承（`extend()`或`extend2()`都可以）：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Using `extend2()`, the `Wee` function''s prototype inherited the properties
    of `Papa.prototype` as its own:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`extend2()`，`Wee`函数的原型继承了`Papa.prototype`的属性作为自己的属性：
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `name` property is primitive, so a new copy of it is created. The `owns`
    property is an array object, so it''s copied by reference:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`属性是原始的，因此会创建一个新的副本。`owns`属性是一个数组对象，因此它是引用复制的：'
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Changing the `Wee` function''s copy of `name` doesn''t affect `Papa`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`Wee`函数的`name`副本不会影响`Papa`：
- en: '[PRE40]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Changing the `Wee` function''s `owns` property, however, affects `Papa`, because
    both properties point to the same array in memory:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更改`Wee`函数的`owns`属性会影响`Papa`，因为两个属性指向内存中的同一个数组：
- en: '[PRE41]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It''s a different story when you completely overwrite the `Wee` function''s
    copy of `owns` with another object (as opposed to modifying the existing one).
    In this case, `Papa.owns` keeps pointing to the old object, while `Wee.owns` points
    to a new one:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完全用另一个对象（而不是修改现有对象）覆盖`Wee`函数的`owns`副本时，情况就不同了。在这种情况下，`Papa.owns`继续指向旧对象，而`Wee.owns`指向新对象：
- en: '[PRE42]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Think of an object as something that is created and stored in a physical location
    in memory. Variables and properties merely point to this location, so when you
    assign a brand new object to `Wee.prototype.owns`, you essentially say-Hey, forget
    about this other old object, move your pointer to this new one instead.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象视为在内存中创建和存储的东西。变量和属性仅仅指向这个位置，因此当您将全新的对象分配给`Wee.prototype.owns`时，您实质上是在说-嘿，忘记这个旧对象，把你的指针移到这个新对象上。
- en: 'The following diagram illustrates what happens if you imagine the memory being
    a heap of objects (like a wall of bricks) and you point to (refer to) some of
    these objects:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了如果你想象内存是一堆对象（就像一堵砖墙），你指向（引用）其中一些对象会发生什么：
- en: A new object is created, and **A** points to it.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个新对象，并且**A**指向它。
- en: A new variable **B** is created and made equal to **A**, meaning it now points
    to the same place **A** is pointing to.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个新变量**B**，并且使其等于**A**，这意味着它现在指向**A**指向的相同位置。
- en: A property color is changed using the **B** handle (pointer). The brick is now
    white. **A** check for `A.color === "white"` would be true.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**B**句柄（指针）更改了属性颜色。砖头现在是白色的。`A.color === "white"`的检查将返回true。
- en: 'A new object is created, and the **B** variable/pointer is recycled to point
    to that new object. **A** and **B** are now pointing to different parts of the
    memory pile. They have nothing in common and changes to one of them don''t affect
    the other:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个新对象，并且**B**变量/指针被回收，指向了新对象。**A**和**B**现在指向内存堆的不同部分。它们没有共同之处，对其中一个的更改不会影响另一个：
- en: '![Heads-up when copying by reference](graphics/image_07_002.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![引用复制时要注意](graphics/image_07_002.jpg)'
- en: If you want to address the problem that objects are copied by reference, consider
    a deep copy, described later in the chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想解决对象被引用复制的问题，请考虑深复制，本章后面会有描述。
- en: Objects inherit from objects
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象从对象继承
- en: All the examples so far in this chapter assume that you create your objects
    with constructor functions, and you want objects created with one constructor
    to inherit properties that come from another constructor. However, you can also
    create objects without the help of a constructor function, just using the object
    literal, and this is, in fact, less typing. So, how about inheriting those?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中的所有示例都假设您使用构造函数创建对象，并且希望使用一个构造函数创建的对象继承来自另一个构造函数的属性。但是，您也可以创建对象而不使用构造函数的帮助，只使用对象文字，这实际上是更少的输入。那么，如何继承这些呢？
- en: 'In Java or PHP, you define classes and have them inherit from other classes.
    That''s why you''ll see the term classical, because the OO functionality comes
    from the use of classes. In JavaScript, there are no classes, so programmers that
    come from a classical background resort to constructor functions, because constructors
    are the closest to what they are used to. In addition, JavaScript provides the
    `new` operator, which can further suggest that JavaScript is like Java. The truth
    is that, in the end, it all comes down to objects. The first example in this chapter
    used this syntax:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java或PHP中，你定义类并让它们继承自其他类。这就是为什么你会看到经典这个词，因为面向对象的功能来自于类的使用。在JavaScript中，没有类，所以来自经典背景的程序员会使用构造函数，因为构造函数是他们习惯的最接近的东西。此外，JavaScript提供了`new`运算符，这可能会进一步暗示JavaScript类似于Java。事实上，最终一切都归结为对象。本章的第一个例子就是用这种语法：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the `Child` constructor (or class, if you will) inherits from `Parent`.
    However, this is done by creating an object using `new Parent()` and inheriting
    from it. That's why this is also referred to as a **pseudo-classical inheritance
    pattern**, because it resembles classical inheritance, although it isn't (no classes
    are involved).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Child`构造函数（或类，如果你愿意的话）继承自`Parent`。然而，这是通过使用`new Parent()`创建一个对象并从中继承的。这也被称为**伪经典继承模式**，因为它类似于经典继承，尽管实际上并不是（没有涉及类）。
- en: So, why not get rid of the middleman (the constructor/class) and just have objects
    inherit from objects? In `extend2()`, the properties of the parent `prototype`
    object were copied as properties of the child `prototype` object. The two prototypes
    are, in essence, just objects. Forgetting about prototypes and constructor functions,
    you can simply take an object and copy all of its properties into another object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么不摆脱中间人（构造函数/类），让对象直接继承对象呢？在`extend2()`中，父`prototype`对象的属性被复制为子`prototype`对象的属性。这两个原型本质上只是对象。忘记原型和构造函数，你可以简单地将一个对象的所有属性复制到另一个对象中。
- en: 'You already know that objects can start as a blank canvas without any own properties,
    using `var o = {};`, and then get properties later. However, instead of starting
    fresh, you can start by copying all of the properties of an existing object. Here''s
    a function that does exactly this: it takes an object and returns a new copy of
    it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道对象可以作为一个空白画布开始，没有任何自己的属性，使用`var o = {};`，然后稍后再添加属性。然而，你可以通过复制现有对象的所有属性来开始，而不是从头开始。这里有一个函数可以做到这一点：它接受一个对象并返回一个新的副本：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Simply copying all the properties is a straightforward pattern, and it''s widely
    used. Let''s see this function in action. You start by having a base object:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地复制所有属性是一种简单的模式，它被广泛使用。让我们看看这个函数的作用。你首先有一个基础对象：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In order to create a new object that builds upon the old one, you can call
    the `extendCopy()` function, which returns a new object. Then, you can augment
    the new object with additional functionality:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个建立在旧对象基础上的新对象，你可以调用`extendCopy()`函数，它会返回一个新对象。然后，你可以用额外的功能来增强新对象：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is a triangle object that inherits the `2D shape` object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个继承`2D形状`对象的三角形对象：
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Using the triangle, for example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用三角形：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A possible drawback of this method is the somewhat verbose way of initializing
    the new `triangle` object, where you manually set values for `side` and `height`,
    as opposed to passing them as values to a constructor. However, this is easily
    resolved by having a function, for example, called `init()` (or `__construct()`
    if you come from PHP) that acts as a constructor and accepts initialization parameters.
    Alternatively, have `extendCopy()` accept two parameters, an object to inherit
    from and another object literal of properties to add to the copy before it's returned.
    In other words, just merge two objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能的一个缺点是初始化新的`triangle`对象的方式有点冗长，你需要手动设置`side`和`height`的值，而不是将它们作为值传递给构造函数。然而，这很容易通过一个名为`init()`（或者如果你来自PHP，叫`__construct()`）的函数来解决，它充当构造函数并接受初始化参数。另外，让`extendCopy()`接受两个参数，一个是要继承的对象，另一个是要添加到副本中的属性的对象字面量。换句话说，就是合并两个对象。
- en: Deep copy
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深拷贝
- en: The `extendCopy()` function discussed previously creates what is called a shallow
    copy of an object, just like `extend2()` before that. The opposite of a shallow
    copy would be, naturally, a deep copy. As discussed previously (in the *Heads-up
    when copying by reference* section of this chapter), when you copy objects, you
    only copy pointers to the location in memory where the object is stored. This
    is what happens in a shallow copy. If you modify an object in the copy, you also
    modify the original. The deep copy avoids this problem.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的`extendCopy()`函数创建了一个被称为浅拷贝的对象，就像之前的`extend2()`一样。浅拷贝的相反就是深拷贝。如前所述（在本章的*通过引用复制时要注意*部分），当你复制对象时，你只复制指向存储对象的内存位置的指针。这就是浅拷贝的情况。如果你在副本中修改一个对象，你也会修改原始对象。深拷贝避免了这个问题。
- en: 'The deep copy is implemented in the same way as the shallow copy-you loop through
    the properties and copy them one by one. However, when you encounter a property
    that points to an object, you call the `deepcopy` function again:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 深拷贝的实现方式与浅拷贝相同-你遍历属性并逐个复制它们。然而，当你遇到指向对象的属性时，你会再次调用`deepcopy`函数：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s create an object that has arrays and a subobject as properties:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有数组和子对象作为属性的对象：
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s test this by creating a deep copy and a shallow copy. Unlike the shallow
    copy, when you update the `numbers` property of a deep copy, the original is not
    affected:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个深拷贝和一个浅拷贝来测试一下。与浅拷贝不同，当你更新深拷贝的`numbers`属性时，原始对象不会受到影响：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Two side notes about the `deepCopy()` function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`deepCopy()`函数的两个注意事项：
- en: Filtering out non-own properties with `hasOwnProperty()` is always a good idea
    to make sure you don't carry over someone's additions to the core prototypes.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`hasOwnProperty()`过滤非自有属性总是一个好主意，以确保你不会带上别人对核心原型的添加。
- en: '`Array.isArray()` exists since ES5 because it''s surprisingly hard otherwise
    to tell real arrays from objects. The best cross-browser solution (if you need
    to define `isArray()` in ES3 browsers) looks a little hacky, but it works:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.isArray()`自ES5以来存在，因为否则很难区分真实数组和对象。最佳的跨浏览器解决方案（如果需要在ES3浏览器中定义`isArray()`）看起来有点奇怪，但它有效：'
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using object() method
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用object()方法
- en: 'Based on the idea that objects inherit from objects, Douglas Crockford advocates
    the use of an `object()` function that accepts an object and returns a new one
    that has the parent as a prototype:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 基于对象从对象继承的思想，Douglas Crockford提倡使用一个接受对象并返回一个具有父对象作为原型的新对象的`object()`函数：
- en: '[PRE53]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you need access to an `uber` property, you can modify the `object()` function
    as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要访问`uber`属性，可以修改`object()`函数如下：
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Using `this` function is the same as using `extendCopy()`, you take an object
    such as `twoDee`, create a new object from it, and then proceed to augmenting
    the new object:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`this`函数与使用`extendCopy()`相同，您可以从诸如`twoDee`之类的对象创建一个新对象，然后继续增强新对象：
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The new triangle still behaves the same way:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 新的三角形仍然表现得一样：
- en: '[PRE56]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This pattern is also referred to as **prototypal inheritance**, because you
    use a parent object as the prototype of a child object. It''s also adopted and
    built upon in ES5 and called `Object.create()`. Here is an example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式也被称为**原型继承**，因为您使用父对象作为子对象的原型。它也被ES5采用并构建，称为`Object.create()`。这里是一个例子：
- en: '[PRE57]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Using a mix of prototypal inheritance and copying properties
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原型继承和复制属性的混合
- en: When you use inheritance, you will most likely want to take an already existing
    functionality and then build upon it. This means creating a new object by inheriting
    from an existing object and then adding additional methods and properties. You
    can do this with one function call using a combination of the last two approaches
    just discussed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用继承时，您很可能希望使用已经存在的功能，然后在此基础上构建。这意味着通过从现有对象继承创建一个新对象，然后添加其他方法和属性。您可以使用刚刚讨论的最后两种方法的组合来一次性完成这个功能。
- en: 'You can:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以：
- en: Use prototypal inheritance to use an existing object as a prototype of a new
    one
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型继承来使用现有对象作为新对象的原型
- en: 'Copy all the properties of another object into the newly created one:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将另一个对象的所有属性复制到新创建的对象中：
- en: '[PRE58]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This function takes an object `o` to inherit from and another object `stuff`
    that has the additional methods and properties that are to be copied. Let's see
    this in action.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个要继承的对象`o`和另一个具有要复制的附加方法和属性的对象`stuff`。让我们看看这个实际操作。
- en: 'Start with the base `shape` object:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从基本`shape`对象开始：
- en: '[PRE59]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a 2D object by inheriting shape and adding more properties. The additional
    properties are simply created with an object literal:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承形状并添加更多属性来创建一个2D对象。附加属性只是使用对象文字创建的：
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, let''s create a `triangle` object that inherits from 2D and adds more
    properties:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个从2D继承并添加更多属性的“triangle”对象：
- en: '[PRE61]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can test how it all works by creating a concrete triangle `my` with defined
    `side` and `height`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建具有定义的`side`和`height`的具体三角形`my`来测试所有这些工作：
- en: '[PRE62]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The difference here, when executing `toString()`, is that the `Triangle` name
    is repeated twice. That''s because the concrete instance was created by inheriting
    `triangle`, so there was one more level of inheritance. You could give the new
    instance a name:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`toString()`时，这里的区别在于`Triangle`名称重复了两次。这是因为具体实例是通过继承`triangle`创建的，所以还有一层继承。您可以给新实例一个名称：
- en: '[PRE63]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This `objectPlus()` is even closer to ES5's `Object.create();` only the ES5
    one takes the additional properties (the second argument) using something called
    property descriptors (discussed in [Appendix C](apc.html "Appendix C. Built-in
    Objects"), *Built-In Objects*).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`objectPlus()`甚至更接近ES5的`Object.create()`；只是ES5的`Object.create()`使用称为属性描述符的东西来获取附加属性（第二个参数）（在[附录C](apc.html
    "附录 C. 内置对象")中讨论，*内置对象*）。
- en: Multiple inheritance
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: Multiple inheritance is where a child inherits from more than one parent. Some
    OO languages support multiple inheritance out of the box and some don't. You can
    argue both ways, that multiple inheritance is convenient or that it's unnecessary,
    complicates application design, and it's better to use an inheritance chain instead.
    Leaving the discussion of multiple inheritance's pros and cons for the long, cold
    winter nights, let's see how you can do it in practice in JavaScript.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承是指一个子对象从多个父对象继承。一些面向对象的语言原生支持多重继承，而一些不支持。您可以从两方面进行论证，即多重继承很方便，或者它是不必要的，使应用程序设计复杂化，并且最好使用继承链。在漫长而寒冷的冬夜中留下多重继承的利弊讨论，让我们看看您如何在JavaScript中实际操作。
- en: The implementation can be as simple as taking the idea of inheritance by copying
    properties and expanding it so that it takes an unlimited number of input objects
    to inherit from.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可以简单地将继承的概念扩展为从无限数量的输入对象继承。
- en: 'Let''s create a `multi()` function that accepts any number of input objects.
    You can wrap the loop that copies properties in another loop that goes through
    all the objects passed as `arguments` to the function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个接受任意数量输入对象的`multi()`函数。您可以在另一个循环中包装复制属性的循环，该循环通过作为函数`arguments`传递的所有对象：
- en: '[PRE64]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s test this by creating three objects-`shape`, `twoDee`, and a third,
    unnamed object. Then, creating a `triangle` object means calling `multi()` and
    passing all three objects:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建三个对象-`shape`，`twoDee`和第三个未命名的对象来测试这一点。然后，创建一个`triangle`对象意味着调用`multi()`并传递所有三个对象：
- en: '[PRE65]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Does this work? Let''s see. The `getArea()` method should be an own property,
    `dimensions` should come from `twoDee`, and `toString()` should come from `shape`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这样行得通吗？让我们看看。`getArea()`方法应该是自己的属性，`dimensions`应该来自`twoDee`，`toString()`应该来自`shape`：
- en: '[PRE66]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Bear in mind that `multi()` loops through the input objects in the order they
    appear and if it happens that two of them have the same property, the last one
    wins.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`multi()`按照输入对象出现的顺序循环，如果发生两个对象具有相同的属性，最后一个将获胜。
- en: Mixins
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合
- en: You might come across the term mixin. Think of a mixin as an object that provides
    some useful functionality but is not meant to be inherited and extended by subobjects.
    The approach to multiple inheritance outlined previously can be considered an
    implementation of the mixins idea. When you create a new object, you can pick
    and choose any other objects to mix into your new object. By passing them all
    to `multi()`, you get all their functionality without making them part of the
    inheritance tree.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到混入这个术语。把混入想象成一个提供一些有用功能的对象，但不是用来被子对象继承和扩展的。前面概述的多重继承方法可以被认为是混入思想的一种实现。当你创建一个新对象时，你可以选择任何其他对象混入到你的新对象中。通过将它们全部传递给`multi()`，你可以获得它们所有的功能，而不使它们成为继承树的一部分。
- en: Parasitic inheritance
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寄生式继承
- en: If you like the fact that you can have all kinds of different ways to implement
    inheritance in JavaScript and you're hungry for more, here's another one. This
    pattern, courtesy of Douglas Crockford, is called parasitic inheritance. It's
    about a function that creates objects by taking all the functionality from another
    object into a new one, augmenting the new object, and returning it, pretending
    that it has done all the work.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢在JavaScript中有各种不同的实现继承的方式，并且渴望了解更多，这里有另一种方式。这种模式，由道格拉斯·克罗克福德提出，被称为寄生式继承。它是关于一个函数通过从另一个对象中获取所有功能来创建对象，增强新对象，并返回它，假装它已经完成了所有工作。
- en: 'Here''s an ordinary object, defined with an object literal, and unaware of
    the fact that it''s soon going to fall victim to parasitism:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个普通对象，用对象字面量定义，并不知道它很快就会成为寄生关系的受害者：
- en: '[PRE67]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A function that creates `triangle` objects could:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一个创建`triangle`对象的函数可以：
- en: Use the `twoD` object as a prototype of an object called that (similar to this
    for convenience). This can be done in any way you saw previously, for example,
    using the `object()` function or copying all the properties.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`twoD`对象作为一个名为`that`的对象的原型（为了方便类似于`this`）。这可以以你之前看到的任何方式来完成，例如使用`object()`函数或复制所有属性。
- en: Augment that with more properties.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加更多属性。
- en: 'Return `that`:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`that`：
- en: '[PRE68]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Because `triangle()` is a normal function, not a constructor, it doesn''t require
    the `new` operator. However, because it returns an object, calling it with `new`
    by mistake works too:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`triangle()`是一个普通函数，而不是构造函数，所以它不需要`new`运算符。然而，因为它返回一个对象，所以错误地使用`new`调用它也是可以的：
- en: '[PRE69]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note that `that` is just a name, it doesn't have a special meaning, the way
    `this` does.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`that`只是一个名称，它没有特殊的含义，就像`this`一样。
- en: Borrowing a constructor
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用构造函数
- en: One more way of implementing inheritance (the last one in the chapter, I promise)
    has to do again with constructor functions and not the objects directly. In this
    pattern, the constructor of the child calls the constructor of the parent using
    either the `call()` or `apply()` method. This can be called **stealing a constructor**
    or **inheritance by borrowing a constructor** if you want to be more subtle about
    it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 实现继承的另一种方式（本章最后一种，我保证）再次与构造函数有关，而不是直接与对象有关。在这种模式中，子级的构造函数使用`call()`或`apply()`方法调用父级的构造函数。这可以称为**偷取构造函数**或**通过借用构造函数继承**，如果你想更加微妙一些的话。
- en: The `call()` and `apply()` methods were discussed in [Chapter 4](ch04.html "Chapter 4. Objects"),
    *Objects*, but here's a refresher; they allow you to call a function and pass
    an object that the function should bind to its `this` value. So for inheritance
    purposes, the child constructor calls the parent's constructor and binds the child's
    newly created `this` object as the parent's `this`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`call()`和`apply()`方法在[第4章](ch04.html "第4章。对象")*对象*中已经讨论过，但这里是一个复习；它们允许你调用一个函数并传递一个对象，该函数应该将其`this`值绑定到该对象。因此，为了继承目的，子构造函数调用父构造函数，并将子级新创建的`this`对象绑定为父级的`this`。'
- en: 'Let''s have this parent constructor `Shape()`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们有这个父构造函数`Shape()`：
- en: '[PRE70]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, let''s define `Triangle()`, which uses `apply()` to call the `Shape()`
    constructor, passing `this` (an instance created with `new Triangle()`) and any
    additional arguments:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义`Triangle()`，它使用`apply()`来调用`Shape()`构造函数，传递`this`（使用`new Triangle()`创建的实例）和任何额外的参数：
- en: '[PRE71]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that both `Triangle()` and `Shape()`have added some extra properties to
    their prototypes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Triangle()`和`Shape()`都向它们的原型添加了一些额外的属性。
- en: 'Now, let''s test this by creating a new `triangle` object:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过创建一个新的`triangle`对象来测试一下：
- en: '[PRE72]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The new `triangle` object inherits the `id` property from the parent, but it
    doesn''t inherit anything added to the parent''s `prototype`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`triangle`对象从父级继承了`id`属性，但它没有继承任何添加到父级`prototype`的东西：
- en: '[PRE73]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The triangle failed to get the `Shape` function''s prototype properties because
    there was never a `new Shape()` instance created, so the prototype was never used.
    However, you saw how to do this at the beginning of this chapter. You can redefine
    `Triangle` as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形未能获取`Shape`函数的原型属性，因为从未创建过`new Shape()`实例，所以原型从未被使用。然而，你在本章的开头看到了如何做到这一点。你可以重新定义`Triangle`如下：
- en: '[PRE74]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this inheritance pattern, the parent's own properties are recreated as the
    child's own properties. If a child inherits an array or other object, it's a completely
    new value (not a reference), and modifying it won't affect the parent.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种继承模式中，父级的自有属性被重新创建为子级的自有属性。如果子级继承了数组或其他对象，则它是一个全新的值（不是引用），对其进行修改不会影响父级。
- en: 'The drawback is that the parent''s constructor gets called twice-once with
    `apply()` to inherit own properties and once with `new` to inherit the prototype.
    In fact, the own properties of the parent are inherited twice. Let''s take this
    simplified scenario:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是父级的构造函数被调用两次——一次用`apply()`继承自有属性，一次用`new`继承原型。事实上，父级的自有属性被继承了两次。让我们看一个简化的情景：
- en: '[PRE75]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here, we will create a new instance:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个新实例：
- en: '[PRE76]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'There''s an own property `id,` but there''s also one that comes down the prototype
    chain, ready to shine through:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个自有属性`id`，但也有一个通过原型链传递下来的，准备好发挥作用的属性：
- en: '[PRE77]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Borrowing a constructor and copying its prototype
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 借用构造函数并复制其原型
- en: 'The problem of the double work performed by calling the constructor twice can
    easily be corrected. You can call `apply()` on the parent constructor to get all
    own properties and then copy the prototype''s properties using a simple iteration
    (or `extend2()` as discussed previously):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用两次构造函数执行的双重工作问题可以很容易地得到纠正。您可以在父构造函数上调用`apply()`来获取所有自有属性，然后使用简单的迭代（或者如前所述的`extend2()`）复制原型的属性：
- en: '[PRE78]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Lets test the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试以下代码：
- en: '[PRE79]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'No double inheritance:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 没有双重继承：
- en: '[PRE80]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `extend2()` method also gives access to `uber` if needed:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend2()`方法也可以访问`uber`（如果需要的话）：'
- en: '[PRE81]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Case study - drawing shapes
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究-绘制形状
- en: Let's finish off this chapter with a more practical example of using inheritance.
    The task is to be able to calculate the area and the perimeter of different shapes,
    as well as to draw them, while reusing as much code as possible.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个更实际的例子来完成本章，使用继承。任务是能够计算不同形状的面积和周长，并绘制它们，同时尽可能多地重用代码。
- en: Analysis
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析
- en: Let's have one `Shape` constructor that contains all the common parts. From
    there, let's have `Triangle`, `Rectangle`, and `Square` constructors, all inheriting
    from `Shape`. A square is really a rectangle with the same length sides, so let's
    reuse `Rectangle` when building `Square`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们有一个包含所有共同部分的`Shape`构造函数。然后，让我们有`Triangle`，`Rectangle`和`Square`构造函数，它们都继承自`Shape`。正方形实际上是具有相同边长的矩形，因此在构建`Square`时让我们重用`Rectangle`。
- en: In order to define a shape, you'll need points with `x` and `y` coordinates.
    A generic shape can have any number of points. A triangle is defined with three
    points, a rectangle (to keep it simpler) with one point and the lengths of the
    sides. The perimeter of any shape is the sum of its side's lengths. Calculating
    the area is shape specific and will be implemented by each shape.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义一个形状，您需要带有`x`和`y`坐标的点。通用形状可以有任意数量的点。三角形由三个点定义，矩形（为了简单起见）由一个点和边长定义。任何形状的周长是其边长的总和。计算面积是形状特定的，将由每个形状实现。
- en: 'The common functionality in `Shape` would be:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape`中的共同功能将是：'
- en: A `draw()` method that can draw any shape given the points
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`draw()`方法，可以根据给定的点绘制任何形状
- en: A `getParameter()` method
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`getParameter()`方法
- en: A property that contains an array of `points`
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个`points`数组的属性
- en: Other methods and properties as needed
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他所需的方法和属性
- en: For the drawing part, let's use a `<canvas>` tag. It's not supported in early
    IEs, but hey, this is just an exercise.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绘图部分，让我们使用`<canvas>`标签。它在早期IE中不受支持，但嘿，这只是一个练习。
- en: Let's have two other helper constructors-`Point` and `Line`. `Point` will help
    when defining shapes. `Line` will make calculations easier, as it can give the
    length of the line connecting any two given points.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加两个辅助构造函数-`Point`和`Line`。在定义形状时，`Point`将会有所帮助。`Line`将使计算更容易，因为它可以给出连接任意两个给定点的线段长度。
- en: You can play with a working example at [http://www.phpied.com/files/canvas/](http://www.phpied.com/files/canvas/).
    Just open your console and start creating new shapes as you'll see in a moment.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://www.phpied.com/files/canvas/](http://www.phpied.com/files/canvas/)上玩一个可工作的示例。只需打开控制台，然后开始创建新形状，就像您马上会看到的那样。
- en: Implementation
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Let''s start by adding a `canvas` tag to a blank HTML page:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在空白HTML页面中添加一个`canvas`标签开始：
- en: '[PRE82]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then, put the JavaScript code inside `<script>` tags:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将JavaScript代码放在`<script>`标签内：
- en: '[PRE83]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, let''s take a look at what''s in the JavaScript part. First is the helper
    `Point` constructor. It just can''t get any simpler than the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看JavaScript部分的内容。首先是辅助`Point`构造函数。它比以下内容更简单就不能再简单了：
- en: '[PRE84]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Bear in mind that the coordinates of the points on the `canvas` start from
    `x=0`, `y=0`, which is the top left. The bottom right will be `x = 800`, `y =
    600`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`canvas`上的点的坐标从`x=0`，`y=0`开始，这是左上角。右下角将是`x=800`，`y=600`：
- en: '![Implementation](graphics/image_07_003.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![实施](graphics/image_07_003.jpg)'
- en: 'Next comes the `Line` constructor. It takes two points and calculates the length
    of the line between them, using the Pythagorean theorem *a² + b² = c²* (imagine
    a right-angled triangle where the hypotenuse connects the two given points):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Line`构造函数。它接受两个点，并使用毕达哥拉斯定理*a² + b² = c²*（想象一个直角三角形，斜边连接两个给定点）来计算它们之间的线段长度：
- en: '[PRE85]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Next comes the `Shape` constructor. The shapes will have their points (and
    the lines that connect them) as own properties. The constructor also invokes an
    initialization method, `init()`, that will be defined in the prototype:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Shape`构造函数。形状将有它们的点（以及连接它们的线）作为自有属性。构造函数还调用一个初始化方法`init()`，该方法将在原型中定义：
- en: '[PRE86]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, the big part-the methods of `Shape.prototype`. Let''s define all these
    methods using the object literal notation. Refer to the comments for guidelines
    as to what each method does:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重要的部分-`Shape.prototype`的方法。让我们使用对象文字表示法定义所有这些方法。参考注释以了解每个方法的指导方针：
- en: '[PRE87]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, the children constructor functions. `Triangle` comes first:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是子构造函数。首先是`Triangle`：
- en: '[PRE88]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `Triangle` constructor takes three point objects and assigns them to `this.points`
    (its own collection of points). Then, it implements the `getArea()` method, using
    Heron''s formula:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`Triangle`构造函数接受三个点对象，并将它们分配给`this.points`（它自己的点集合）。然后，它实现`getArea()`方法，使用海伦公式：'
- en: '[PRE89]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`s` is the semi-perimeter (perimeter divided by two).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`s`是半周长（周长除以二）。'
- en: 'Next comes the `Rectangle` constructor. It receives one point (the upper-left
    point) and the lengths of the two sides. Then, it populates its `points` array
    starting from that one point:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Rectangle`构造函数。它接收一个点（左上角的点）和两边的长度。然后，它从那一个点开始填充它的`points`数组：
- en: '[PRE90]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The last child constructor is `Square`. A square is a special case of a rectangle,
    so it makes sense to reuse `Rectangle`. The easiest thing to do here is to borrow
    the constructor:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个子构造函数是`Square`。正方形是矩形的一种特殊情况，因此重用`Rectangle`是有意义的。这里最容易做的事情是借用构造函数：
- en: '[PRE91]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now that all constructors are done, let''s take care of inheritance. Any pseudo-classical
    pattern (one that works with constructors as opposed to objects) will do. Let''s
    try using a modified and simplified version of the prototype-chaining pattern
    (the first method described in this chapter). This pattern calls for creating
    a new instance of the parent and setting it as the child''s prototype. In this
    case, it''s not necessary to have a new instance for each child-they can all share
    it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的构造函数都完成了，让我们来处理继承。任何伪经典模式（与对象不同，使用构造函数的模式）都可以。让我们尝试使用修改和简化的原型链模式（本章描述的第一种方法）。这种模式要求创建父类的新实例，并将其设置为子类的原型。在这种情况下，不需要为每个子类创建一个新实例-它们都可以共享它：
- en: '[PRE92]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Testing
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'Let''s test this by drawing shapes. First, define three points for a triangle:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过绘制形状来测试这一点。首先，为三角形定义三个点：
- en: '[PRE93]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now you can create a triangle by passing the three points to the `Triangle`
    constructor:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过将三个点传递给`Triangle`构造函数来创建一个三角形：
- en: '[PRE94]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You can call the methods to draw the triangle on the `canvas` and get its area
    and perimeter:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用绘制三角形的方法在`canvas`上，并获得它的面积和周长：
- en: '[PRE95]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now let''s play with a rectangle instance:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来玩一个矩形实例：
- en: '[PRE96]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'And finally, let''s play with a square:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们玩一个正方形：
- en: '[PRE97]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'It''s fun to draw these shapes. You can also be as lazy as the following example,
    which draws another square, reusing a triangle''s point:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 画这些形状很有趣。你也可以像下面的例子一样懒惰，重用三角形的点来画另一个正方形：
- en: '[PRE98]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The result of the tests will be something like the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的结果将类似于以下内容：
- en: '![Testing](graphics/image_07_004.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![测试](graphics/image_07_004.jpg)'
- en: Exercises
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Lets do the following exercise:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做以下练习：
- en: 'Implement multiple inheritance but with a prototypal inheritance pattern, not
    property copying. Here is an example:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用原型继承模式实现多重继承，而不是属性复制。以下是一个例子：
- en: '[PRE99]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `additional` property should be an own property; all the rest should be
    mixed into the prototype.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`additional`属性应该是自有属性；其余的属性应该混合到原型中。'
- en: 'Use the `canvas` example to practice. Try out different things. Here are some
    examples:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`canvas`示例进行练习。尝试不同的东西。以下是一些例子：
- en: Draw a few triangles, squares, and rectangles.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画几个三角形、正方形和矩形。
- en: Add constructors for more shapes, such as `Trapezoid`, `Rhombus`, `Kite`, and
    `Pentagon`. If you want to learn more about the `canvas` tag, create a `Circle`
    constructor too. It will need to overwrite the `draw()` method of the parent.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为更多的形状添加构造函数，比如`Trapezoid`、`Rhombus`、`Kite`和`Pentagon`。如果你想了解更多关于`canvas`标签的知识，也可以创建一个`Circle`构造函数。它需要覆盖父类的`draw()`方法。
- en: Can you think of another way to approach the problem and use another type of
    inheritance?
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能想到另一种方法来解决这个问题并使用另一种类型的继承吗？
- en: Pick one of the methods that uses `uber` as a way for a child to access its
    parent. Add functionality where the parents can keep track of who their children
    are, perhaps using a property that contains a `children` array?
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个使用`uber`作为子类访问其父类的方法。添加功能，使父类可以跟踪他们的子类，也许使用包含`children`数组的属性？
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned quite a few ways (patterns) of implementing inheritance,
    and the following table summarizes them. The different types can roughly be divided
    into the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了实现继承的许多方式（模式），以下表格对它们进行了总结。不同类型大致可以分为以下几类：
- en: Patterns that work with constructors
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于构造函数的模式
- en: Patterns that work with objects
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于对象的模式
- en: 'You can also classify the patterns based on whether they:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以根据它们是否：
- en: Use the prototype
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型
- en: Copy properties
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: 'Do both (copy properties of the prototype):'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都做（复制原型的属性）：
- en: '| **#** | **Name** | **Example** | **Classification** | **Notes** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **#** | **名称** | **示例** | **分类** | **备注** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | Prototype chaining(pseudo-classical) |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 原型链（伪经典） |'
- en: '[PRE100]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '|'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with constructors
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于构造函数
- en: Uses the prototype chain
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: '|'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The default mechanism
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认机制
- en: Tip - move all properties/methods that are meant to be reused to the prototype,
    and add the non-reusable as own properties
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示-将所有希望被重用的属性/方法移动到原型中，并将不可重用的内容添加为自有属性
- en: '|'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 2 | Inherit only the prototype |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 仅继承原型 |'
- en: '[PRE101]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '|'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with constructors
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于构造函数
- en: Copies the prototype (no prototype chain, as all share the same prototype object)
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制原型（没有原型链，因为所有的对象共享同一个原型对象）
- en: '|'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: More efficient; no new instances are created just for the sake of inheritance
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高效；不会仅为了继承而创建新实例
- en: Prototype chain lookup during runtime; it is fast, since there's no chain
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时原型链查找；速度快，因为没有链
- en: 'Drawback: children can modify parents'' functionality'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：子类可以修改父类的功能
- en: '|'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 3 | Temporary constructor |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 临时构造函数 |'
- en: '[PRE102]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '|'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with constructors
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于构造函数
- en: Uses the prototype chain
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: '|'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Unlike #1, it only inherits properties of the prototype; own properties (created
    with this inside the constructor) are not inherited.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与#1不同，它只继承原型的属性；自有属性（在构造函数内部使用this创建的属性）不会被继承。
- en: Provides convenient access to the parent (through `uber`)
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供方便的访问父类的方法（通过`uber`）
- en: '|'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 4 | Copying the `prototype` properties |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 复制`prototype`属性 |'
- en: '[PRE103]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '|'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with constructors
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于构造函数
- en: Copies properties
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: Uses the prototype chain
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: All properties of the parent prototype become properties of the child prototype
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父类原型的所有属性都成为子类原型的属性
- en: No need to create a new object only for inheritance purposes
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要仅为了继承目的创建一个新对象
- en: Shorter prototype chains
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更短的原型链
- en: '|'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 5 | Copy all properties(shallow copy) |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 复制所有属性（浅复制） |'
- en: '[PRE104]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '|'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with objects
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于对象
- en: Copies properties
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: '|'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Simple
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单
- en: Doesn't use prototypes
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用原型
- en: '|'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 6 | Deep copy | Same as the previous one, but recurse into objects |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 深复制 | 与前一个相同，但是递归到对象中 |'
- en: Works with objects
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于对象
- en: Copies properties
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: '|'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Same as #5, but clones objects and arrays'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与#5相同，但是克隆对象和数组
- en: '|'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 7 | Prototypal inheritance |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 原型继承 |'
- en: '[PRE105]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '|'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with objects
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于对象
- en: Uses the prototype chain
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: '|'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: No pseudo-classes, objects inherit from objects
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有伪类，对象从对象继承
- en: Leverages the benefits of the prototype
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用原型的好处
- en: '|'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 8 | Extend and augment |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 扩展和增强 |'
- en: '[PRE106]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '|'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with objects
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于对象
- en: Uses the prototype chain
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: Copies properties
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: '|'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Mix of prototypal inheritance (#7) and copying properties (#5)
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型继承（＃7）和复制属性（＃5）的混合
- en: One function call to inherit and extend at the same time
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次函数调用同时继承和扩展
- en: '|'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 9 | Multiple inheritance |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 多重继承 |'
- en: '[PRE107]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '|'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with objects
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于对象
- en: Copies properties
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: '|'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A mixin-style implementation
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种混合风格的实现
- en: Copies all the properties of all the parent objects in the order of appearance
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按出现顺序复制所有父对象的所有属性
- en: '|'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 10 | Parasitic inheritance |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 寄生继承 |'
- en: '[PRE108]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '|'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with objects
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于对象
- en: Uses the prototype chain
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: '|'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Constructor-like function creates objects
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似构造函数的函数创建对象
- en: Copies an object, and augments and returns the copy
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制一个对象，并增强并返回副本
- en: '|'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 11 | Borrowing constructors |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 借用构造函数 |'
- en: '[PRE109]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '|'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with constructors
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于构造函数
- en: '|'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Inherits only own properties
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅继承自有属性
- en: 'Can be combined with #1 to inherit the prototype too'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以与＃1结合，也可以继承原型
- en: Convenient way to deal with the issues when a child inherits a property that
    is an object (and therefore, passed by reference)
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理子类继承对象属性（因此通过引用传递）时的便捷方式
- en: '|'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 12 | Borrow a constructor and copy the prototype |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 借用构造函数并复制原型 |'
- en: '[PRE110]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '|'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with constructors
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于构造函数
- en: Uses the prototype chain
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: Copies properties
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: '|'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Combination of #11 and #4'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ＃11和＃4的组合
- en: Allows you to inherit both own properties and prototype properties without calling
    the parent constructor twice
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许您继承自有属性和原型属性，而不需要两次调用父构造函数。
- en: '|'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Given so many options, you must be wondering which is the right one. That depends
    on your style and preferences, your project, task, and team. Are you more comfortable
    thinking in terms of classes? Then pick one of the methods that work with constructors.
    Are you going to need just one or a few instances of your class? Then choose an
    object-based pattern.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多选择，你一定想知道哪一个是正确的。这取决于你的风格和偏好，你的项目、任务和团队。你更习惯以类为思维方式吗？那么选择一个与构造函数一起工作的方法。你只需要一个或几个类的实例吗？那么选择一个基于对象的模式。
- en: Are these the only ways of implementing inheritance? No. You can choose a pattern
    from the preceding table, you can mix them, or you can think of your own. The
    important thing is to understand and be comfortable with objects, prototypes,
    and constructors; the rest is just pure joy.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是实现继承的唯一方式吗？不是。你可以从上表中选择一个模式，你可以混合它们，或者你可以想出自己的。重要的是要理解并熟悉对象、原型和构造函数；其余只是纯粹的快乐。

- en: Chapter 9. Promises and Proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the important concept of **asynchronous programming**
    and how JavaScript is an ideal language to utilize it. The other topic that we
    will cover in this chapter is meta programming with proxies. These two concepts
    are introduced in ES6.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, our primary focus is to understand asynchronous programming,
    before we jump into the language - specific constructs, let's spend time in understanding
    the concept first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first model-the **synchronous model-**is where it all began. This is the
    simplest model of programming. Each task is executed one at a time, and only after
    the first task completes execution can, the next task start. When you program
    in this model, we expect that all tasks before the current task are complete and
    there is no error. Take a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Promises and Proxies](graphics/image_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **single threaded asynchronous model** is a familiar model we all know.
    However, this model can be wasteful and optimized. For any nontrivial programs
    composed of several different tasks, this model can be slow. Consider the following
    hypothetical scenario as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the synchronous model in mind, two tasks are executed one after the other.
    This means that the second statement will only be executed once the first has
    completed execution. Assuming the first statement is a costly one and takes 10
    seconds (it is normal to take even more time to read from a remote database),
    the second statement will be blocked.
  prefs: []
  type: TYPE_NORMAL
- en: This is a serious problem when you need to write high - performance and scalable
    systems. There is another problem that manifests when you are writing programs
    where you need to write interfaces for human interactions like we do on websites
    that run on a browser. While you are performing a task that may take some time,
    you cannot block the user. They may be entering something in an input field while
    the costly task is running; it would be a terrible experience if we block user
    input while we are busy doing a costly operation. In such scenarios, the costly
    tasks need to be run in the background while we can happily take input from the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, one solution is to split each task into its own thread of control.
    This is called the **multi-threaded** or **threaded model**. Consider the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Promises and Proxies](graphics/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The difference is how the tasks are split. In the threaded model, each task
    is performed in its own thread of control. Usually, threads are managed by the
    operating system and can be run in parallel on different CPU cores or on a single
    core with appropriate thread scheduling done by the CPU. With modern CPUs, the
    threaded model can be extremely optimal in performance. Several languages support
    this popular model. Although a popular model, the threaded model can be complex
    to implement in practice. The threads need to communicate and coordinate with
    each other. Inter-thread communication can get tricky very quickly. There are
    variations of the threaded model where the state is immutable. In such cases,
    the model becomes simpler as each thread is responsible for immutable state and
    there is no need to manage state between threads.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third model is what interests us the most. In this model, tasks are interleaved
    in a single thread of control. Consider the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Asynchronous programming model](graphics/image_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **asynchronous model** is simpler because you have only one thread. When
    you are executing one task, you are sure that only that task is being executed.
    This model doesn't require complex mechanism for inter-thread coordination and,
    hence, is more predictable. There is one more difference between the threaded
    and the asynchronous models; in the threaded model, you don't have a way to control
    the thread execution as the thread scheduling is mostly done by the operating
    system. However, in the asynchronous model, there is no such challenge.
  prefs: []
  type: TYPE_NORMAL
- en: In which scenarios can the asynchronous model outperform the synchronous model?
    If we are simply splitting tasks into smaller chunks, intuitively, even the smaller
    chunks will take quite an amount of time when you add them up in the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a significant factor we have not yet considered. When you execute
    a task, you will end up waiting on something-a disk read, a database query, or
    a network call; these are blocking operations. When you enter a blocked mode,
    your task simply waits in the synchronous model. Take a look at the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Asynchronous programming model](graphics/image_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the black blocks are where a task is waiting on something.
    What are the typical operations that can cause such a block? A task is performed
    in a CPU and RAM. A typical CPU and RAM can handle data transfer orders of magnitude
    faster than a typical disc read or a network call.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please refer to a comparison ([https://gist.github.com/jboner/2841832](https://gist.github.com/jboner/2841832))
    of latencies between CPU, internal memory, and discs.
  prefs: []
  type: TYPE_NORMAL
- en: When your tasks wait on an **I**/**O** (**Input**/**Output**) from such sources,
    the latency is unpredictable. For a synchronous program that does a lot of I/O,
    this is a recipe for bad performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important difference between the synchronous and asynchronous models
    is the way they handle blocking operations. In the asynchronous model, a program,
    when faced with a task that encounters a block, executes another task without
    waiting for the blocking operation to finish. In a program where there are potential
    blocks, an asynchronous program outperforms an equivalent synchronous program
    because less time is spent on waiting. A slightly inaccurate visualization of
    such a model would be as seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Asynchronous programming model](graphics/image_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With this conceptual background of the asynchronous model with us, we can look
    at language - specific constructs to support this model.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript call stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript, function calls form a stack of frames. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we call function `a()`, the first frame in the stack is created with arguments
    to the function and all local variables in the `a()`function. When function `a()`
    calls function `b()`, a second frame is created and pushed to the top of the stack.
    This goes on for all function calls. When the `c()`function returns, the top frame
    from the stack is popped out, leaving functions `b()` and `a()`; this goes on
    until the entire stack is empty. This is necessary to maintain because once the
    function finishes execution, JavaScript will need to know where to return.
  prefs: []
  type: TYPE_NORMAL
- en: Message queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript runtime contains a message queue. This queue contains the list
    of messages to be processed. These messages are queued in response to events such
    as `click` or an HTTP response received. Each message is associated with a callback
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Event loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A browser tab runs in a single thread-an event loop. This loop continuously
    picks messages from the message queue and executes the callbacks associated with
    them. The event loop simply keeps picking tasks from the message queues while
    other processes add tasks to the message queue. Other processes such as timers
    and event handlers run in parallel and keep adding tasks to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `setTimeout()`method creates a timer and waits until it fires. When the
    timer is executed, a task is added to the message queue. The `setTimeOut()` method
    takes two arguments: a callback, and the duration in milliseconds. After the duration,
    the callback is added to the message queue. Once the callback is added to the
    message queue, the event loop will eventually pick it up and execute it. There
    is, however, no guarantee when the callback will be picked up by the event loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Run to completion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the event loop picks up a message from the queue, the associated callback
    is run to completion. This means that a message is processed completely before
    the next message from the queue is processed. This property gives the asynchronous
    model a sense of predictability. As there is no intervention to preempt any of
    the messages in between execution, this model is much simpler than other models,
    where any unit of execution can be halted in between. However, once the message
    is picked up, even if the execution takes too long, any other interaction on the
    browser is blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can register event handlers for an object and receive results of a method
    asynchronously. The following example shows how we can set up event handlers for
    the `XMLHttpRequest` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we are creating the object of the `XMLHttpRequest`
    class. Once the request object is created, we will register event handlers for
    it. Event handlers, such as `onload()`, are triggered asynchronously when the
    response is received from the `open()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `send()` method doesn't actually initiate the request, it adds the request
    to the message queue for the event loop to pick it up and execute necessary callbacks
    associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Node.js application popularized this style of receiving asynchronous data.
    A callback is a function passed as the last argument to the asynchronous function
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the usage, let''s use the following example of reading a file
    in Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry about a few details here. We are using the filesystem module as
    an `fs` alias. This module has a `readFile` method to read a file asynchronously.
    We will pass the file path and filename as the first argument and a callback function
    as the last argument of the function. We are using an anonymous function as the
    callback in the example.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function has two arguments-error and data. When the `readFile()`
    method is successful, the callback function receives `data`, and if it fails,
    the `error` argument will have the error details.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use a slightly functional style to write the same callback. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This style of passing callbacks is also called **continuous-passing style**
    (**CPS**); the next step of execution or continuation is passed as a parameter.
    The following example further illustrates the CPS style of callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will provide the continuation (the next callback) to each step. This nested
    callback style also causes a problem sometimes referred to as callback hell.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks and the CPS introduce a radically different style of programming.
    Although it is easier to understand callbacks compared to other constructs, callbacks
    can create slightly difficult to understand code.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 introduces promises as an alternate to callbacks. Like callbacks, promises
    are used to retrieve the results of an asynchronous function call. Using promises
    is easier than callbacks and produces more readable code. However, to implement
    promises for your asynchronous functions requires more work.
  prefs: []
  type: TYPE_NORMAL
- en: A promise object represents a value that may be available now or in the future,
    or possibly never. As the name suggests, a promise may be fulfilled or rejected.
    A promise acts as a placeholder for the eventual result.
  prefs: []
  type: TYPE_NORMAL
- en: 'A promise has three mutually exclusive states, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A promise is **pending** before the result is ready; this is the initial state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A promise is **fulfilled** when the result is ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On an error, a promise is **rejected**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a pending promise is either fulfilled or rejected, associated callbacks/handlers
    that are queued up by the `then()` method of the promise are executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of promises is to provide a better syntax for the CPS callbacks.
    The typical CPS style asynchronous functions like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be written a bit differently with promises, as shown
    in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The asynchronous function now returns a promise, which is the placeholder for
    an eventual result. Callbacks registered with the `then()` method are notified
    when the result is ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can chain the `then()` method. When the `then()` method sees that the callback
    triggered another asynchronous action that returns a promise, it returns that
    promise. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see a real example of how we can use promises. We saw a typical example
    of asynchronous file reads in Node.js; now let''s see what that example will look
    like when used with promises. To jog our memories, we wrote something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We see callbacks as continuation here; now let''s see how the same function
    can be written using promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now the callbacks are invoked via the result and methods `then()` and `catch()`.
    The error handling is much cleaner because we are not writing the `if...else`
    and `try...catch` constructs anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Creating promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw how we can consume promises. Now, let's look at how we can produce them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a producer, you can create a `Promise` object and send a result via the
    `Promise`. The construct looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter to `Promise` is an executor function. The executor handles two
    states of the promise, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resolving**: If the result was generated successfully, the executor sends
    the results back via the `resolve()` method. This method usually fulfills the
    `Promise` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rejecting**: If an error happened, the executor notifies the consumer via
    the `reject()` method. If an exception occurs, it is notified via the `reject()`
    method as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a consumer, you are notified of either fulfillment of promise or rejection
    of promise via the `then()` and `catch()` methods. Consider the following piece
    of code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have some background on how to produce promises, let''s rewrite
    our earlier example of the asynchronous file''s `read` method to produce promises.
    We will use Node.js''s filesystem module and the `readFile()` method as we did
    last time. If you don''t understand any Node.js specific construct in the following
    snippet, please don''t worry. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we are creating a new `Promise` object and returning
    it to the consumer. As we saw earlier, the parameter to the `Promise` object is
    the executor function and the executor function takes care of two states of `Promise`-fulfilled
    and rejected. The executor function takes in two arguments, `resolve` and `reject`.
    These are the functions that notify the state of the `Promise` object to the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the executor function, we will call the actual function-the `readFile()`
    method; if this function is successful, we will return the result using the `resolve()`
    method and if there is an error, we will notify the consumer using the `reject()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an error happens in one of the `then()` reactions, they are caught in the
    subsequent `catch()` block. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `then()` reaction causes an exception or error, and the subsequent
    `catch()` block can handle this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, an exception thrown inside a `then()` or `catch()` handler is passed
    to the next error handler. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Promise.all()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One interesting use case is to create an iterable over promises. Let''s assume
    that you have a list of URLs you want to visit and parse the results. You can
    create promises for each of the fetch URL calls and use them individually, or
    you can create an iterator with all the URLs and use the promise in one go. The
    `Promise.all()` method takes the iterable of promises as an argument. When all
    of the promises are fulfilled, an array is filled with their results. Consider
    the following code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Metaprogramming and proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Metaprogramming refers to a method of programming where the program is aware
    of its structure and can manipulate itself. Many languages have support for metaprogramming
    in the form of macros. Macros are important constructs in functional languages
    such as **LISP** (**Locator/ID Separation Protocol**). In languages such as Java
    and C#, reflection is a form of metaprogramming because a program can examine
    information about itself using reflection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, you can say that methods of object allow you to examine the
    structure and hence, they offer metaprogramming. There are three types of metaprogramming
    paradigms (*The Art of the Metaobject Protocol,* Kiczales et al, [https://mitpress.mit.edu/books/art-metaobject-protocol](https://mitpress.mit.edu/books/art-metaobject-protocol)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Introspection**: This gives a read-only access to the internals of a program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-modification**: This makes structural changes possible to the program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intercession**: This changes language semantics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Object.keys()` method is an example of introspection. In the following
    example, the program is examining its own structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Self-modification is also possible in JavaScript by mutating the properties
    of an object.
  prefs: []
  type: TYPE_NORMAL
- en: However, intercession, or the ability to change language semantics, is something
    not available in JavaScript till ES6\. Proxies are introduced to open up this
    possibility.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use a proxy to determine the behavior of an object, which is called
    the target, whenever its properties are accessed. A proxy is used to define custom
    behavior for basic operations on an object, such as looking up a property, function
    invocation, and assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'A proxy needs two parameters, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Handler**: For each operation you want to customize, you need a `handler`
    method. This method intercepts the operations and is sometimes called a trap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target**: When the `handler` does not intercept the operation, the `target`
    is used as a fallback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example to understand this concept better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are trapping the operation of getting a property from the
    object. We return `42` as a default property value if the property does not exist.
    We are using the `get` handler to trap this operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use proxies to validate values before setting them on an object. For
    this, we can trap the `set` handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are trapping the `set` handler. When we set a property
    of the object, we are trapping that operation and introducing validation of values.
    If the value is valid, we will set the property.
  prefs: []
  type: TYPE_NORMAL
- en: Function traps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two operations that can be trapped if the target is a function: `apply`
    and `construct`.'
  prefs: []
  type: TYPE_NORMAL
- en: To intercept function calls, you will need to trap the `get` and `apply` operations.
    First get the function and then apply to call the function. So, you `get` the
    function and return the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following example to understand how method interception
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are trapping the `get` operation. If the type of
    the property being `get` is a function, we will use `apply` to invoke that function.
    If you see the output, we are getting two `console.logs`; the first is from the
    proxy where we trapped the `get` operation and the second is from the actual method
    call.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming is an interesting construct to use. However, any kind of introspection
    or reflection comes at the cost of performance. Care should be taken while using
    proxies as they can be slow.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at two important concepts. ES6 proxies are useful
    meta programming constructs used to define custom behavior for fundamental operations
    (for example, property lookup, assignment, enumeration, function invocation, and
    so on). We looked at how to use handlers, traps, and proxy targets to intercept
    and modify the default behavior of operations. This gives us very powerful meta
    programming capabilities earlier lacking in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The other important construct we discussed in this chapter was ES6 promises.
    Promises are important because they make asynchronous programming constructs easier
    to work with. A promise acts as a proxy for a value not necessarily known when
    the promise is created. This lets asynchronous methods return values like synchronous
    methods - instead of the final value, the asynchronous method returns a promise
    for the value at some point in the future.
  prefs: []
  type: TYPE_NORMAL
- en: These are two very powerful constructs in ES6 that greatly enhance the language's
    core capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the fascinating possibilities around browsers
    and DOM manipulation using JavaScript.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 11. Coding and Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know all about the objects in JavaScript, mastered prototypes and
    inheritance, and seen some practical examples of using browser-specific objects,
    let's move forward, or rather, move a level up. Let's take a look at some common
    JavaScript patterns.
  prefs: []
  type: TYPE_NORMAL
- en: But first, what's a pattern? In short, a pattern is a good solution to a common
    problem. Codifying the solution into a pattern makes it repeatable as well.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, when you're facing a new programming problem, you may recognize right
    away that you've previously solved another, suspiciously similar problem. In such
    cases, it's worth isolating this class of problems and searching for a common
    solution. A pattern is a proven and reusable solution (or an approach to a solution)
    to a class of problems.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases where a pattern is nothing more than an idea or a name. Sometimes,
    just using a name helps you think more clearly about a problem. Also, when working
    with other developers in a team, it's much easier to communicate when everybody
    uses the same terminology to discuss a problem or a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Other times, you may come across a unique problem that doesn't look like anything
    you've seen before and doesn't readily fit into a known pattern. Blindly applying
    a pattern just for the sake of using a pattern, is not a good idea. It's preferable
    to not use any known pattern than to try to tweak your problem so that it fits
    an existing solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter talks about two types of patterns, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Coding patterns**: These are mostly JavaScript-specific best practices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design patterns**: These are language-independent patterns, popularized by
    the famous *Gang of Four* book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with some patterns that reflect JavaScript''s unique features.
    Some patterns aim to help you organize your code, for example, namespacing; others
    are related to improving performance, such as lazy definitions and init-time branching;
    and some make up for missing features, such as private properties. The patterns
    discussed in this section include the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Separating behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Init-time branching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private variables and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privileged methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private functions as public methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immediate functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed previously, the three building blocks of a web page are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Content (HTML)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presentation (CSS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavior (JavaScript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTML is the content of the web page, the actual text. Ideally, the content should
    be marked-up using the least amount of HTML tags that sufficiently describe the
    semantic meaning of that content. For example, if you're working on a navigation
    menu, it's a good idea to use the `<ul>` and `<li>` tags as a navigation menu
    is in essence, just a list of links.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your content (HTML) should be free from any formatting elements. Visual formatting
    belongs to the presentation layer and should be achieved through the use of **CSS**
    (**Cascading Style Sheets**). This means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The style attribute of HTML tags should not be used, if possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presentational HTML tags such as `<font>` should not be used at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tags should be used for their semantic meaning, not because of how browsers
    render them by default. For instance, developers sometimes use a `<div>` tag where
    a `<p>` would be more appropriate. It's also favorable to use `<strong>` and `<em>`
    instead of `<b>` and `<i>` as the latter describe the visual presentation rather
    than the meaning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good approach to keep presentation out of the content is to reset or nullify
    all browser defaults, for example, using `reset.css` from the Yahoo! UI library.
    This way, the browser's default rendering won't distract you from consciously
    thinking about the proper semantic tags to use.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third component of a web page is the behavior. Behavior should be kept separate
    from both the content and the presentation. It is usually added by using JavaScript
    that is isolated to `<script>` tags, and preferably contained in external files.
    This means not using any inline attributes, such as `onclick`, `onmouseover`,
    and so on. Instead, you can use the `addEventListener`/`attachEvent` methods from
    the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best strategy to separate behavior from content is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize the number of `<script>` tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid inline event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use CSS expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toward the end of your content, when you are ready to close the `<body>` tag,
    insert a single `external.js` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example of separating behavior
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s say you have a search form on a page, and you want to validate the form
    with JavaScript. So, you go ahead and keep the `form` tags free from any JavaScript,
    and then immediately before closing the `</body>` tag, you insert a `<script>`
    tag that links to an external file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In `behaviors.js` you attach an event listener to the submit event. In your
    listener, you can check to see if the text input field was left blank and, if
    so, stop the form from being submitted. This way, you will save a roundtrip between
    the server and the client and make the application immediately responsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `behaviors.js` is given in the following code. It assumes that
    you''ve created your `myevent` utility from the exercise at the end of the previous
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous JavaScript loading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You noticed how the script was loaded at the end of the HTML, right before closing
    the body. The reason is that JavaScript blocks the DOM construction of the page,
    and in some browsers, even downloads of the other components that follow. By moving
    the scripts to the bottom of the page, you ensure that the script is out of the
    way, and when it arrives, it simply enhances the already usable page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to prevent external JavaScript files from blocking the page is
    to load them asynchronously. This way you can start loading them earlier. HTML5
    has the `defer` attribute for this purpose. Consider the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the `defer` attribute is not supported by older browsers, but
    luckily, there is a solution that works across browsers, old and new. The solution
    is to create a `script` node dynamically and append it to the DOM. In other words,
    you can use a bit of inline JavaScript to load the external JavaScript file. You
    can have this script loader snippet at the top of your document so that the download
    has an early start. Take a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Global variables should be avoided in order to reduce the possibility of variable
    naming collisions. You can minimize the number of globals by namespacing your
    variables and functions. The idea is simple, you will create only one global object,
    and all your other variables and functions become properties of that object.
  prefs: []
  type: TYPE_NORMAL
- en: An Object as a namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a global object called `MYAPP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of having a global `myevent` utility (from the previous chapter),
    you can have it as an `event` property of the `MYAPP` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the methods to the `event` utility is still the same. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Namespaced constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using a namespace doesn''t prevent you from creating constructor functions.
    Here is how you can have a DOM utility that has an `Element` constructor, which
    allows you to create DOM elements easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can have a `Text` constructor to create text nodes. Consider
    the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the constructors to create a link at the bottom of a page can be done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A namespace() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create a namespace utility that makes your life easier so that you
    can use more convenient syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the more verbose syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how you can create such a `namespace()` method. First, you will create
    an array by splitting the input string using the period (`.`) as a separator.
    Then, for every element in the new array, you will add a property to your global
    object, if one doesn''t already exist, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the new method is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code is the same as if you did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Init-time branching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, you noticed that sometimes, different browsers have
    different implementations for the same or similar functionalities. In such cases,
    you will need to branch your code, depending on what's supported by the browser
    currently executing your script. Depending on your program, this branching can
    happen far too often and, as a result, may slow down the script execution.
  prefs: []
  type: TYPE_NORMAL
- en: You can mitigate this problem by branching some parts of the code during initialization,
    when the script loads, rather than during runtime. Building upon the ability to
    define functions dynamically, you can branch and define the same function with
    a different body, depending on the browser. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define a namespace and placeholder method for the `event` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the methods to add or remove a listener are not implemented.
    Based on the results from feature sniffing, these methods can be defined differently,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After this script executes, you have the `addListener()` and `removeListener()`
    methods defined in a browser-dependent way. Now, every time you invoke one of
    these methods, there's no more feature-sniffing, and it results in less work and
    faster execution.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to watch out for when sniffing features is not to assume too much
    after checking for one feature. In the previous example, this rule is broken because
    the code only checks for `addEventListener` support, but then defines both `addListener()`
    and `removeListener()`. In this case, it's probably safe to assume that if a browser
    implements `addEventListener()`, it also implements `removeEventListener()`. However,
    imagine what happens if a browser implements `stopPropagation()` but not `preventDefault()`,
    and you haven't checked for these individually. You have assumed that because
    `addEventListener()` is not defined, the browser must be an old IE and write your
    code using your knowledge and assumptions of how IE works. Remember that all of
    your knowledge is based on the way a certain browser works today, but not necessarily
    the way it will work tomorrow. So, to avoid many rewrites of your code as new
    browser versions are shipped, it's best to individually check for features you
    intend to use and don't generalize on what a certain browser supports.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The lazy definition pattern is similar to the previous init-time branching pattern.
    The difference is that the branching happens only when the function is called
    for the first time. When the function is called, it redefines itself with the
    best implementation. Unlike the init-time branching, where the if happens once,
    during loading, here it may not happen at all, in cases when the function is never
    called. The lazy definition also makes the initialization process lighter as there's
    no init-time branching work to be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example that illustrates this via the definition of an `addListener()`
    function. The function is first defined with a generic body. It checks which functionality
    is supported by the browser when it''s called for the first time and then redefines
    itself using the most suitable implementation. At the end of the first call, the
    function calls itself, so that the actual event attaching is performed. The next
    time you call the same function, it will be defined with its new body and be ready
    for use, so no further branching is necessary. The following is the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Configuration object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern is convenient when you have a function or method that accepts a
    lot of optional parameters. It's up to you to decide how many constitutes a lot.
    But generally, a function with more than three parameters is not convenient to
    call, because you have to remember the order of the parameters, and it is even
    more inconvenient when some of the parameters are optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of having many parameters, you can use one parameter and make it an
    object. The properties of the object are the actual parameters. This is suitable
    to pass configuration options because these tend to be numerous and optional (with
    smart defaults). The beauty of using a single object as opposed to multiple parameters
    is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The order doesn't matter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can easily skip parameters that you don't want to set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easy to add more optional configuration attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes the code more readable because the configuration object's properties
    are present in the calling code along with their names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Imagine you have some sort of UI widget constructor you use to create fancy
    buttons. It accepts the text to put inside the button (the `value` attribute of
    the `<input>` tag) and an optional parameter of the `type` of button. For simplicity,
    let''s say the fancy button takes the same configuration as a regular button.
    Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the constructor is simple; you just give it a string. Then, you can add
    the new button to the body of the document as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all well and works fine, but then you decide you also want to be able
    to set some of the style properties of the button, such as colors and fonts. You
    can end up with a definition like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using the constructor can become a little inconvenient, especially when
    you want to set the third and fifth parameter, but not the second or the fourth.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A better approach is to use one `config` object parameter for all the settings.
    The function definition can become something like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the constructor is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Another usage example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's easy to set only some of the parameters and to switch around
    their order. In addition, the code is friendlier and easier to understand when
    you see the names of the parameters at the same place where you call the method.
  prefs: []
  type: TYPE_NORMAL
- en: A drawback of this pattern is the same as its strength. It's trivial to keep
    adding more parameters, which means trivial to abuse the technique. Once you have
    an excuse to add to this free-for-all bag of properties, you will find it tempting
    to keep adding some that are not entirely optional, or some that are dependent
    on other properties.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, all these properties should be independent and optional.
    If you have to check all possible combinations inside your function ("oh, A is
    set, but A is only used if B is also set"), this is a recipe for a large function
    body, which quickly becomes confusing and difficult, if not impossible, to test,
    because of all the combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Private properties and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript doesn''t have the notion of access modifiers, which set the privileges
    of the properties in an object. Other languages often have access modifiers, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Public`: All users of an object can access these properties or methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Private`: Only the object itself can access these properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Protected`: Only objects inheriting the object in question can access these
    properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript doesn't have a special syntax to denote private properties or methods,
    but as discussed in [Chapter 3](ch03.html "Chapter 3. Functions"), *Functions*,
    you can use local variables and methods inside a function and achieve the same
    level of protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the example of the `FancyButton` constructor, you can have
    local variable styles that contains all the defaults, and a local `setStyle()`
    function. These are invisible to the code outside of the constructor. Here''s
    how `FancyButton` can make use of the local private properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, `styles` is a private property and `setStyle()` is a
    private method. The constructor uses them internally (and they can access anything
    inside the constructor), but they are not available to code outside of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Privileged methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Privileged methods (this term was coined by Douglas Crockford) are normal public
    methods that can access private methods or properties. They can act like a bridge
    in making some of the private functionality accessible, but in a controlled manner,
    wrapped in a privileged method.
  prefs: []
  type: TYPE_NORMAL
- en: Private functions as public methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say you've defined a function that you absolutely need to keep intact,
    so you make it private. However, you also want to provide access to the same function,
    so that outside code can also benefit from it. In this case, you can assign the
    private function to a publicly available property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define `_setStyle()` and `_getStyle()` as private functions, but then
    assign them to the public `setStyle()` and `getStyle()`, consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you call `MYAPP.dom.setStyle()`, it invokes the private `_setStyle()`
    function. You can also overwrite `setStyle()` from the outside as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MYAPP.dom.setStyle` points to the new function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MYAPP.dom.yetAnother` still points to `_setStyle()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_setStyle()` is always available when any other internal code relies on it
    to be working as intended, regardless of the outside code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you expose something private, keep in mind that objects (functions and
    arrays are objects too) are passed by reference and, therefore, can be modified
    from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: Immediate functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another pattern that helps you keep the global namespace clean is to wrap your
    code in an anonymous function and execute that function immediately. This way,
    any variables inside the function are local, as long as you use the `var` statement,
    and are destroyed when the function returns, if they aren''t part of a closure.
    This pattern was discussed in more detail in [Chapter 3](ch03.html "Chapter 3. Functions"),
    *Functions*. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is especially suitable for on-off initialization task, performed
    when the script loads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The immediate self-executing function pattern can be extended to create and
    return objects. If the creation of these objects is more complicated and involves
    some initialization work, then you can do this in the first part of the self-executable
    function and return a single object that can access and benefit from any private
    properties at the top portion, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Combining several of the previous patterns gives you a new pattern, commonly
    referred to as a module pattern. The concept of modules in programming is convenient
    as it allows you to code separate pieces or libraries and combine them as needed,
    just like pieces of a puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module pattern includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces to reduce naming conflicts among modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An immediate function to provide a private scope and initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private properties and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ES5 doesn't have a built-in concept of modules. There is the module specification
    from [http://www.commonjs.org](http://www.commonjs.org), which defines a `require()`
    function and an exports object. ES6, however, supports modules. [Chapter 8](ch08.html
    "Chapter 8. Classes and Modules"), Classes and Modules has covered modules in
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning an object that has the public API of the module as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And, you can use the module in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chaining is a pattern that allows you to invoke multiple methods on one line
    as if the methods are the links in a chain. This is convenient when calling several
    related methods. You invoke the next method on the result of the previous without
    the use of an intermediate variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you''ve created a constructor that helps you work with DOM elements. The
    code to create a new `<span>` tag that is added to the `<body>` tag can look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you know, constructors return the object referred to as `this` keyword that
    they create. You can make your methods, such as `setText()` and `setStyle()`,
    also return `this` keyword, which allows you to call the next method on the instance
    returned by the previous one. This way, you can chain method calls, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You don''t even need the `obj` variable if you don''t plan on using it after
    the new element has been added to the tree, so the code looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A drawback of this pattern is that it makes it a little harder to debug when
    an error occurs somewhere in a long chain, and you don't know which link is to
    blame because they are all on the same line.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's wrap up the coding patterns section of this chapter with a few words about
    JSON. JSON is not technically a coding pattern, but you can say that using it
    is a good pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON is a popular lightweight format to exchange data. It''s often preferred
    over XML when using `XMLHttpRequest()` to retrieve data from the server. There''s
    nothing specifically interesting about **JSON** other than the fact that it''s
    extremely convenient. The JSON format consists of data defined using object and
    array literals. Here is an example of a JSON string that your server can respond
    with after an `XHR` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'An XML equivalent of this will be something like the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you can see how JSON is lighter in terms of the number of bytes. However,
    the main benefit is not the smaller byte size, but the fact that it''s trivial
    to work with JSON in JavaScript. Let''s say, you''ve made an `XHR` request and
    have received a JSON string in the `responseText` property of the `XHR` object.
    You can convert this string of data into a working JavaScript object by simply
    using `eval()`. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can access the data in `obj` as object properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that `eval()` is insecure, so it''s best if you use the JSON
    object to parse the JSON data (a fallback for older browsers is available at [http://json.org/](http://json.org/)).
    Creating an object from a JSON string is still trivial as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To do the opposite, that is, to convert an object to a JSON string, you can
    use the `stringify()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Due to its simplicity, JSON has quickly become popular as a language-independent
    format to exchange data, and you can easily produce JSON on the server side using
    your preferred language. In PHP, for example, there are the `json_encode()` and
    `json_decode()` functions that let you serialize a PHP array or object into a
    JSON string, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Higher order functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming was confined to a limited set of languages so far. With
    more languages adding features to support functional programming, interest in
    the area is gaining momentum. JavaScript is evolving to support common features
    of functional programming. You will gradually see a lot of code written in this
    style. It is important to understand the functional programming style, even if
    you don't feel inclined just yet to use it in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Higher order functions are one of the important mainstays of functional programing.
    Higher order function is a function that does at least one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes one or more functions as arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a function as a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As functions are first class objects in JavaScript, passing and returning functions
    to and from a function is a pretty routine affair. Callbacks are higher order
    functions. Let's take a look at how we can take these two principles together
    and write a higher order function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write a `filter` function; this function filters out values from an array
    based on a criteria determined by a function. This function takes two arguments-a
    function, which returns a Boolean value, `true` for keeping this element.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with this function, we are filtering all odd values from an array.
    Consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We are passing an anonymous function to the `filter` function as the first argument.
    This function returns a Boolean based on a condition that checks if the element
    is odd or even.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of one of the several higher order functions added to ECMAScript
    5\. The point we are trying to make here is that you will increasingly see similar
    patterns of usage in JavaScript. You must first understand how higher order functions
    work and later, once you are comfortable with the concept, try to incorporate
    them in your code as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'With ES6 function syntax changes, it is even more elegant to write higher order
    functions. Let''s take a small example in ES5 and see how that translates into
    its ES6 equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `add` function takes `x` and returns a function that takes `y` as an argument
    and then returns value of expression `y+x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we looked at arrow functions, we discussed that arrow functions return
    results of a single expression implicitly. So, the preceding function can be turned
    into an arrow function by making the body of the arrow function another arrow
    function. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an outer function, `x =>` [inner function with `x` as argument],
    and we have an inner function, `y => y+x`.
  prefs: []
  type: TYPE_NORMAL
- en: This introduction will help you get familiar with the increasing usage of higher
    order functions, and their increased importance in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second part of this chapter presents a JavaScript approach to a subset
    of the design patterns introduced by *Design Patterns: Elements of Reusable Object-Oriented
    Software*, an influential book most commonly referred to as the *Book of Four*,
    the *Gang of Four*, or *GoF* (after its four authors). The patterns discussed
    in the *GoF* book are divided into the three following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns that deal with how objects are created (instantiated)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural patterns that describe how different objects can be composed in order
    to provide new functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral patterns that describe ways for objects to communicate with each
    other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are 23 patterns in the *Book of Four*, and more patterns have been identified
    since the book's publication. It's way beyond the scope of this book to discuss
    all of them, so the remainder of the chapter demonstrates only four, along with
    examples of their implementation in JavaScript. Remember that the patterns are
    more about interfaces and relationships rather than implementation. Once you have
    an understanding of a design pattern, it's often not difficult to implement it,
    especially in a dynamic language such as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The patterns discussed through the rest of the chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Singleton is a creational design pattern, meaning that its focus is on creating
    objects. It helps you when you want to make sure there is only one object of a
    given kind or class. In a classical language, this would mean that an instance
    of a class is only created once, and any subsequent attempts to create new objects
    of the same class would return the original instance.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, because there are no classes, a singleton is the default and
    most natural pattern. Every object is a singleton object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic implementation of the singleton in JavaScript is the object
    literal. Take a look at the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That was easy, right?
  prefs: []
  type: TYPE_NORMAL
- en: Singleton 2 pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to use a class-like syntax and still implement the singleton pattern,
    things become a bit more interesting. Let''s say, you have a constructor called
    `Logger()`, and you want to be able to do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The idea is that, although you use `new`, only one instance needs to be created,
    and this instance is then returned in consecutive calls.
  prefs: []
  type: TYPE_NORMAL
- en: Global variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One approach is to use a global variable to store the single instance. Your
    constructor could look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this constructor gives the expected result, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The drawback is, obviously, the use of a global variable. It can be overwritten
    at any time, even accidentally, and you can lose the instance. The opposite, your
    global variable overwriting someone else's is also possible.
  prefs: []
  type: TYPE_NORMAL
- en: Property of the constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you know, functions are objects and they have properties. You can assign
    the single instance to a property of the constructor function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If you write `var a = new Logger()`, `a` points to the newly created `Logger.single_instance`
    property. A subsequent `var b = new Logger()` call results in `b` pointing to
    the same `Logger.single_instance` property, which is exactly what you want.
  prefs: []
  type: TYPE_NORMAL
- en: This approach certainly solves the global namespace issue because no global
    variables are created. The only drawback is that the property of the `Logger`
    constructor is publicly visible, so it can be overwritten at any time. In such
    cases, the single instance can be lost or modified. Of course, you can only provide
    so much protection against fellow programmers shooting themselves in the foot.
    After all, if someone can mess with the single-instance property, they can mess
    up the `Logger` constructor directly as well.
  prefs: []
  type: TYPE_NORMAL
- en: In a private property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The solution to the problem of overwriting the publicly visible property is
    not to use a public property, but a private one. You already know how to protect
    variables with a closure, so as an exercise, you can implement this approach to
    the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The factory is another creational design pattern, as it deals with creating
    objects. The factory can help you when you have similar types of objects and you
    don't know in advance which one you want to use. Based on user input or other
    criteria, your code determines the type of object it needs on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have three different constructors that implement similar functionality.
    All the objects they create take a URL but do different things with it. One creates
    a text DOM node; the second creates a link; and the third, an image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the three different constructors is exactly the same-pass the `url` variable
    and call the `insert()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine your program doesn''t know in advance which type of object is required.
    The user decides, during runtime, by clicking on a button for example. If `type`
    contains the required type of object, you''ll need to use an `if` or a `switch`
    statement, and write something like the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This works fine; however, if you have a lot of constructors, the code becomes
    too lengthy and hard to maintain. Also, if you are creating a library or a framework
    that allows extensions or plugins, you don't even know the exact names of all
    the constructor functions in advance. In such cases, it's convenient to have a
    factory function that takes care of creating an object of the dynamically determined
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a factory method to the `MYAPP.dom` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can replace the three `if` functions with the simpler code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The example `factory()` method in the previous code was simple; however, in
    a real-life scenario, you'd want to do some validation against the type value
    (for example, check if `MYAPP.dom[type]` exists) and optionally do some set up
    work common to all object types (for example, set up the URL all constructors
    use).
  prefs: []
  type: TYPE_NORMAL
- en: Decorator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The decorator design pattern is a structural pattern; it doesn''t have much
    to do with how objects are created, but rather how their functionality is extended.
    Instead of using inheritance, where you extend in a linear way (parent-child-grandchild),
    you can have one base object and a pool of different decorator objects that provide
    extra functionality. Your program can pick and choose which decorators it wants,
    and in which order. For a different program or code path, you may have a different
    set of requirements and pick different decorators out of the same pool. Take a
    look at the following code snippet to see how the usage part of the decorator
    pattern can be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You can see how you can start with a simple object that has a `doSomething()`
    method. Then, you can pick one of the decorator objects you have lying around
    and which can be identified by name. All decorators provide a `doSomething()`
    method that first calls the same method of the previous decorator and then proceeds
    with its own code. Every time you add a decorator, you overwrite the base `obj`
    with an improved version of it. In the end, when you are finished adding decorators,
    you call `doSomething()`. As a result, all of the `doSomething()` methods of all
    the decorators are executed in sequence. Let's see an example.
  prefs: []
  type: TYPE_NORMAL
- en: Decorating a christmas tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s illustrate the decorator pattern with an example of decorating a Christmas
    tree. You can start with the `decorate()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement a `getDecorator()` method that adds extra decorators.
    The decorators will be implemented as constructor functions, and they''ll all
    inherit from the base `tree` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the first decorator, `RedBalls()`, as a property of `tree`,
    in order to keep the global namespace cleaner. The red ball objects also provide
    a `decorate()` method, but they make sure they call their parent''s `decorate()`
    first. For example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, implement `BlueBalls()` and `Angel()` decorators as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add all of the decorators to the base object, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the `decorate()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This single call results in the following alerts, specifically in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the tree won't fall.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the blue balls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an angel at the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some red balls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you see, this functionality allows you to have as many decorators as you
    like, and to choose and combine them in any way you like.
  prefs: []
  type: TYPE_NORMAL
- en: Observer pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The observer pattern, also known as the **subscriber-publisher** pattern, is
    a behavioral pattern, which means that it deals with how different objects interact
    and communicate with each other. When implementing the observer pattern, you have
    the following objects:'
  prefs: []
  type: TYPE_NORMAL
- en: One or more publisher objects that announce when they do something important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more subscribers tuned in to one or more publishers. They listen to what
    the publishers announce and then act appropriately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer pattern may look familiar to you. It sounds similar to the browser
    events discussed in the previous chapter, and rightly so, because the browser
    events are one example application of this pattern. The browser is the publisher;
    it announces the fact that an event, such as a `click`, has happened. Your event
    listener functions that are subscribed to listen to this type of event will be
    notified when it happens. The browser-publisher sends an event object to all of
    the subscribers. In your custom implementations, you can send any type of data
    you find appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two subtypes of the observer pattern: push and pull. Push is where
    the publishers are responsible to notify each subscriber, and pull is where the
    subscribers monitor for changes in a publisher''s state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example implementation of the push model. Let''s keep
    the observer-related code in a separate object and then use this object as a mix-in,
    adding its functionality to any other object that decides to be a publisher. In
    this way, any object can become a publisher and any function can become a subscriber.
    The observer object will have the following properties and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: An array of `subscribers` that are just callback functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addSubscriber()`and `removeSubscriber()` methods that add to, and remove
    from, the `subscribers` collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `publish()` method that takes data and calls all subscribers, passing the
    data to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `make()` method that takes any object and turns it into a publisher by adding
    all of the methods mentioned previously to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the observer mix-in object that contains all the subscription-related
    methods and can be used to turn any object into a publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create some publishers. A publisher can be any object and its only
    duty is to call the `publish()` method whenever something important occurs. Here''s
    a `blogger` object that calls `publish()` every time a new blog posting is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Another object can be the LA Times newspaper that calls `publish()` when a
    new newspaper issue is out. Consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can turn these objects into publishers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have the following two simple objects, `jack` and `jill`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `jack` and `jill` objects can subscribe to the `blogger` object by providing
    the callback methods they want to call when something is published, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens now, when the `blogger` object writes a new post? The result is
    that `jack` and `jill` will get notified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'At any time, `jill` may decide to cancel her subscription. Then, when writing
    another blog post, the unsubscribed object is no longer notified. Consider the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `jill` object may decide to subscribe to LA Times, as an object can be
    a subscriber to many publishers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when LA Times publishes a new issue, `jill` gets notified and `jill.gossip()`
    is executed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about common JavaScript coding patterns and learned
    how to make your programs cleaner, faster, and better at working with other programs
    and libraries. Then, you saw a discussion and sample implementations of a handful
    of the design patterns from the *Book of Four*. You can see how JavaScript is
    a fully featured dynamic programming language, and that implementing classical
    patterns in a dynamic loosely typed language is pretty easy. The patterns are,
    in general, a large topic, and you can join the author of this book in a further
    discussion of the JavaScript patterns at [JSPatterns.com](http://www.jspatterns.com/),
    or take a look at the *JavaScript Patterns* book. The next chapter focuses on
    testing and debugging methodologies.
  prefs: []
  type: TYPE_NORMAL

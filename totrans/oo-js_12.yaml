- en: Chapter 12. Testing and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you write JavaScript applications, you will soon realize that having a sound
    testing strategy is indispensable. In fact, not writing enough tests is almost
    always a bad idea. It is essential to cover all nontrivial functionality of your
    code to make sure of the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Existing code behaves as per the specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any new code does not break the behavior defined by the specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both these points are very important. Many engineers consider only the first
    point as the sole reason to cover your code with enough tests. The most obvious
    advantage of test coverage is to really make sure that the code being pushed to
    production system is mostly error free. Writing test cases to smartly cover maximum
    functional areas of the code, generally gives good indication around the overall
    quality of the code. There should be no arguments or compromises around this point.
    Although, it is unfortunate that many production systems are still bereft of adequate
    code coverage. It is very important to build an engineering culture where developers
    think about writing tests as much as they think about writing code.
  prefs: []
  type: TYPE_NORMAL
- en: The second point is even more important. Legacy systems are usually very difficult
    to manage. When you are working on code, either written by someone else or written
    by a large distributed team, it is fairly easy to introduce bugs and break things.
    Even the best engineers make mistakes. When you are working on a large code base
    you are unfamiliar with, if there is no sound test coverage to help you, you will
    introduce bugs. As you won't have the confidence in the changes you are making,
    because there are no test cases to confirm your changes, your code releases will
    be shaky, slow, and obviously full of hidden bugs.
  prefs: []
  type: TYPE_NORMAL
- en: You will refrain from refactoring or optimizing your code, because you won't
    be really sure what changes to the code base would potentially break something
    (again, because there are no test case to confirm your changes); all this is a
    vicious circle. It's like a civil engineer saying-although I have constructed
    this bridge, I have no confidence on the quality of the construction. It may collapse
    immediately or never. Although this may sound like an exaggeration, I have seen
    a lot of high impact production code being pushed with no test coverage. This
    is risky and should be avoided. When you are writing enough test cases to cover
    majority of your functional code, when you make change to those pieces, you will
    immediately realize if there is a problem with this new change. If your changes
    make the test case fail, you will realize the problem. If your refactor breaks
    the test scenario, you will realize the problem; all of this happens much before
    the code is pushed to production.
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, ideas like test-driven development and self-testing code are
    gaining prominence, especially in agile methodology. These are fundamentally sound
    ideas and will help you write robust code - the code you are confident of. We
    will discuss all these ideas in this chapter. We will understand how to write
    good test cases in modern JavaScript. We will also look at several tools and methods
    to debug your code. JavaScript was traditionally a bit difficult to test and debug,
    primarily due to lack of tools, but modern tools make both of these easy and natural.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about test cases, we mostly mean unit tests. It is incorrect to
    assume that the unit we want to test is always a function. The unit, or unit of
    work, is a logical unit that constitutes single behavior. This unit should be
    able to be invoked via a public interface and should be testable independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, a unit test can perform the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: It tests a single logical function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can run without a specific order of execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes care of its own dependencies and mock data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It always returns the same result for the same input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be self-explanatory, maintainable, and readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Martin Fowler advocates the *Test Pyramid* ([http://martinfowler.com/bliki/TestPyramid.html](http://martinfowler.com/bliki/TestPyramid.html))
    strategy to make sure we have a high number of unit tests to ensure maximum code
    coverage. There are two important testing strategies that we will discuss in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Test Driven Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Test driven development** (**TDD**) has gained a lot of prominence in the
    last few years. The concept was first proposed as part of the extreme programming
    methodology. The idea is to have short repetitive development cycles where the
    focus is on writing the test cases first. The cycle looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a test case as per the specifications for the specific unit of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run existing suite of test cases to see if the new test case you wrote fails;
    it should, because there is no code for that unit yet. This step ensures that
    the current test harness works well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the code that mainly serves to confirm to the test case. This code is
    not optimized, refactored, or even entirely correct. However, this is fine at
    this moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rerun tests and see if all the test cases pass. After this step, you are confident
    that the new code is not breaking anything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor code to make sure you are optimizing the unit and handling all corner
    cases
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps are repeated for any new code you add. This is an elegant strategy
    that works really well for agile methodology. TDD will be successful only if the
    testable units of code are small and confirms only to the test case.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior Driven Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very common problem while trying to follow TDD is vocabulary and the definition
    of correctness. BDD tries to introduce a ubiquitous language while writing the
    test cases when you are following TDD. This language makes sure that both the
    business and the engineering are talking about the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Jasmine as the primary BDD framework and explore various testing
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can install Jasmine by downloading the standalone package from [https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip](https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you unzip this package, you will see the following directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior Driven Development](graphics/image_12_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `lib` directory contains the JavaScript files that you need in your project
    to start writing Jasmine test cases. If you open `SpecRunner.html`, you will find
    the following JavaScript files included in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first three are Jasmine's own framework files. The next section includes
    the source files we want to test and the actual test specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s experiment with Jasmine via a very ordinary example. Create a `bigfatjavascriptcode.js`
    file and place it in the `src/` directory. The function we will test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple function that does one single thing. It receives a string and
    returns a capitalized string. We will test various scenarios around this function.
    This is the unit of code, which we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the test specifications. Create one JavaScript file, `test.spec.js`,
    and place it in the `spec/` directory. You will need to add the following two
    lines into your `SpecRunner.html`: The file should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The order of this inclusion does not matter. When we run `SpecRunner.html`,
    you will see something like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior Driven Development](graphics/image_12_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the Jasmine report that shows details about the number of tests that
    were executed and the count of failures and successes. Now, let''s make the test
    case fail. We want to test a case where an `undefined` variable is passed to the
    function. Let''s add one more test case, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you run `SpecRunner`, you will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior Driven Development](graphics/image_12_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the failure is displayed for this test case in a detailed error
    stack. Now, we will go about fixing this. In your original JS code, handle undefined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, your test case will pass, and you will see the following
    result in the Jasmine report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior Driven Development](graphics/image_12_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is very similar to what a test-driven development would look like. You
    write test cases and then fill the necessary code to confirm to the specifications
    and rerun the test suite. Let's understand the structure of the Jasmine tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test specification looks like the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `describe("TestStringUtilities"` is what a test suite is. The name of the
    test suite should describe the unit-of-code we are testing; this can be a function
    or a group of related functionality. Inside the specs, you will call the global
    Jasmine function,`it`, to which you will pass the title of the spec and the function
    that validates the condition of the testcase This function is the actual test
    case. You can catch one or more assertions or the general expectations using the
    `expect` function. When all expectations are `true`, your spec is passed. You
    can write any valid JavaScript code inside `describe` and `it` functions. The
    values you verify as part of the expectations are matched using a matcher. In
    our example, `toEqual` is the matcher that matches two values for equality. Jasmine
    contains a rich set of matches to suit most of the common use cases. Some common
    matchers supported by Jasmine are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toBe`: This matcher checks if two objects being compared are equal. This is
    same as the `===` comparison. For example, check out the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`not`: You can negate a matcher with a not prefix. For example, `expect(1).not.toEqual(2);`
    will negate the match made by `toEqual()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toContain`: This checks if an element is part of an array. It is not an exact
    object match as `toBe`. For example, take a look at the following lines of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`toBeDefined` and `toBeUndefined`: These two matches are handy to check whether
    a variable is `undefined` or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toBeNull`: This checks if a variable''s value is `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toBeGreaterThan` and `toBeLessThan`: These matcher performs numeric comparison
    (works on strings too). For example, consider the following piece of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting feature of Jasmine is the spies. When you are writing a large
    system, it is not possible to make sure that all systems are always available
    and correct. At the same time, you don''t want your unit tests to fail due to
    a dependency that may be broken or unavailable. To simulate a situation where
    all dependencies are available for a unit of code we want to test, we will mock
    this dependency to always give the response we expect. Mocking is an important
    aspect of testing, and most testing frameworks provide support for mocking. Jasmine
    allows mocking using a feature called a **Spy**. Jasmine spies essentially stubs
    the functions we may not have ready at the time of writing the test case, but
    as part of the functionality, we will need to track that we are executing those
    dependencies and not ignoring them. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, while we are writing this test case, we either don't have the
    real implementation of the dependency, `configurator.submitPOSTRequest()`, or
    someone is fixing this particular dependency; in any case, we don't have it available.
    For our test to work, we will need to mock it. Jasmine spies allow us to replace
    a function with its mock and allows us to track its execution.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will need to ensure that we called the dependency. When the
    actual dependency is ready, we will revisit this test case to make sure it fits
    the specifications; however, at this time, all we need to ensure that the dependency
    is called. Jasmine function `tohaveBeenCalled()` lets us track the execution of
    a function that may be a mock. We can use `toHaveBeenCalledWith()`, which allows
    us to determine if the stub function was called with correct parameters. There
    are several other interesting scenarios you can create using Jasmine spies. The
    scope of this chapter won't permit us to cover them all, but I would encourage
    you to discover those areas on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha, Chai and Sinon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though Jasmine is the most prominent JavaScript testing framework, mocha and
    chai are gaining prominence in the `Node.js` environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Mocha is the testing framework used to describe and run test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chai is the assertion library supported by Mocha
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sinon comes in handy while creating mocks and stubs for your tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't discuss these frameworks in this book; however, experience on Jasmine
    will be handy if you want to experiment with these frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are not a completely new programmer, I am sure you must have spent some
    amount of time debugging your or someone else's code. Debugging is almost like
    an art form. Every language has different methods and challenges around the debugging.
    JavaScript is traditionally a difficult language to debug. I have spent days and
    nights in misery, trying to debug badly written JavaScript code using `alert()`
    functions. Fortunately, modern browsers, such as Mozilla, Firefox, and Google
    Chrome, have excellent **Developer Tools** to help debug JavaScript in the browser.
    There are IDEs like IntelliJ IDEA and WebStorm with great debugging support for
    JavaScript and Node.js. In this chapter, we will focus primarily on Google Chrome's
    built-in developer tool. Firefox also supports Firebug extension and has excellent
    built-in developer tools, but as they behave more or less the same as Google Chrome's
    **Developer Tools**, we will discuss common debugging approaches that work in
    both of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: Before we talk about the specific debugging techniques, let's understand the
    type of errors we would be interested in while we try to debug our code.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When your code has something that does not confirm to the JavaScript language
    grammar, the interpreter rejects that piece of code. These are easy to catch if
    your IDE is helping you with syntax checking. Most modern IDEs help with these
    errors. Earlier, we discussed the usefulness of tools, such as JSLint and JSHint,
    around catching syntax issues with your code. They analyze the code and flag errors
    in the syntax. The JSHint output can be very illuminating. For example, the following
    output shows up so many things we can change in the code. The following code snippet
    is from one of my existing projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using strict
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We briefly discussed the strict mode in earlier chapters. When you enable strict
    mode, JavaScript stops being accepting of syntactical errors in your code. Rather
    than silently failing, strict mode makes these failure throw errors instead. It
    also helps you convert mistakes into actual errors. There are two ways of enforcing
    strict mode. If you want the strict mode for the entire script, you can just add
    the `use strict` statement (with the quotes) as the first line of your JavaScript
    program. If you want a specific function to confirm to strict mode, you can add
    the directive as the first line of a function. For example, take a look at the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Runtime exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These errors appear when you execute the code, try to refer to an `undefined`
    variable, or try to process a `null`. When a runtime exception occurs, any code
    after that particular line, which caused the exception, does not get executed.
    It is essential to correctly handle such exceptional scenarios in the code. While
    exception handling can help prevent crashes, they also aid in debugging. You can
    wrap the code that may encounter a runtime exception into a `try{ }` block. When
    any code inside this block generates a runtime exception, a corresponding handler
    captures it. The handler is defined by a `catch(exception){}` block. Let''s clarify
    this using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `var a = doesnotexist` line tries to assign an `undefined`
    variable, `doesnotexist`, to another variable `a`. This causes a runtime exception.
    When we wrap this problematic code into `try{}catch(){}` block or when the exception
    occurs (or is thrown), the execution stops in the `try{}` block and goes directly
    to the `catch() {}` handler. The catch handler is responsible for handling the
    exceptional scenario. In this case, we are displaying the error message on the
    console for debugging purposes. You can explicitly throw an exception to trigger
    an unhandled scenario in the code. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are handling valid states of a gear shift: `R`, `N`, and
    `D`; however, when we receive an invalid state, we are explicitly throwing an
    exception clearly stating the reason. When we call the function which we think
    may throw an exception, we will wrap the code in the `try{}` block and attach
    a `catch(){}` handler with it. When the exception is caught by the `catch()` block,
    we will handle the exceptional condition appropriately.'
  prefs: []
  type: TYPE_NORMAL
- en: Console.log and asserts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Displaying the state of execution on console can be very useful while debugging.
    Although, modern developer tools allow you to put breakpoints and halt execution
    to inspect a particular value during runtime. You can quickly detect small issues
    by logging some variable state on the console.
  prefs: []
  type: TYPE_NORMAL
- en: With these concepts with us, let's see how we can use Chrome **Developer Tools**
    to debug JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Chrome Developer Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can start Chrome **Developer Tools** by clicking **menu** | **More tools**
    | **Developer Tools**. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Chrome developer tool opens up on the lower pane of your browser and has a
    bunch of very useful sections. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Elements** panel helps you inspect and monitor the DOM tree and associated
    style sheet for each of these components.
  prefs: []
  type: TYPE_NORMAL
- en: The **Network** panel is useful to understand network activity. For example,
    you can monitor the resources being downloaded over the network in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important pane for us is the **Sources** pane. This pane is where
    the JavaScript and the debugger are displayed. Let''s create a sample HTML with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this HTML file and open it in Google Chrome. Open **Developer Tools**
    in the browser, and you will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the view of the **Sources** panel. You can see the HTML and embedded
    JavaScript source in this panel. You can see the **Console** window as well, and
    you can see that the file is executed and the output is displayed on console.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right side, you will see the debugger window, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the **Sources** panel, click on the line numbers **8** and **15** to add
    a breakpoint. The breakpoints allow you to stop execution of the script at the
    specified point. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/5239_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the debug pane, you can see all existing breakpoints. Take a look at the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, when you rerun the same page, you will see that the execution stops at
    the debug point. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This window now has all the action. You can see that the execution is paused
    on line **15**. In the debug window, you can see which breakpoint is being triggered.
    You can also see the **Call Stack** and resume execution in several ways. The
    debug command window has a bunch of actions. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can resume execution, which will execute until the next breakpoint, by
    clicking on the following button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you do that, the execution continues until the next breakpoint is encountered.
    In our case, we will halt at line **8**. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can observe that the **Call Stack** window shows how we arrived at line
    **8**. The **Scope** panel shows the **Local** scope where you can see the variables
    in the scope when the breakpoint was arrived at. You can also Step-Into or Step-over
    the next function.
  prefs: []
  type: TYPE_NORMAL
- en: There are other very useful mechanisms to debug and profile your code using
    Chrome **Developer Tools**. I would suggest you to experiment with the tool and
    make it a part of your regular development flow.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both testing and debugging phases are essential to developing robust JavaScript
    code. TDD and BDD are approaches closely associated with the agile methodology
    and is widely embraced by the JavaScript developer community. In this chapter,
    we reviewed best practices around TDD and the usage of Jasmine as the testing
    framework. Additionally, we saw various methods of debugging JavaScript using
    Chrome **Developer Tools**.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the new and exciting world of ES6, DOM
    Manipulation and cross-browser strategies.
  prefs: []
  type: TYPE_NORMAL

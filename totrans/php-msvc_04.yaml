- en: Chapter 4.  Testing and Quality Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。测试和质量控制
- en: In this chapter, we will look at the different testing methodologies that you
    can use before, during, and after the development process. As you will know, testing
    your application avoids future issues and gives you a better project overview.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下在开发过程之前、期间和之后可以使用的不同测试方法。正如你所知，测试你的应用程序可以避免未来出现问题，并为你提供更好的项目概述。
- en: The importance of using tests in your application
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的应用程序中使用测试的重要性
- en: It is very important to use testing in our application because these steps can
    avoid (or at least reduce) future problems or errors that can appear as we are
    humans and can make mistakes during the development process or because the structure
    of the project is not correct or even the understanding of the developer does
    not match the requirements of the customer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用测试非常重要，因为这些步骤可以避免（或至少减少）未来可能出现的问题或错误，因为我们是人类，在开发过程中可能会犯错误，或者因为项目结构不正确，甚至开发人员的理解与客户的要求不符。
- en: The testing process will help improve the code quality and understanding of
    the functionalities, do regression testing in order to avoid the inclusion of
    old issues in continuous integration and reduce the time taken to finish the project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 测试过程将有助于提高代码质量和功能的理解，进行回归测试以避免在持续集成中包含旧问题，并减少完成项目所需的时间。
- en: 'Testing is used to reduce the fails or errors in our application. Development
    teams spend a lot of time doing bug fixing and, depending on the moment of the
    discovery of the bugs, the impact can be bigger or smaller. The following image
    shows the relative cost of bug fixing related to the stage of the development:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用于减少应用程序中的失败或错误。开发团队花费大量时间进行错误修复，根据错误的发现时间不同，影响可能会更大或更小。以下图片显示了与开发阶段相关的错误修复的相对成本：
- en: '![The importance of using tests in your application](graphics/B06142_04_01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![在应用程序中使用测试的重要性](graphics/B06142_04_01.jpg)'
- en: The reason for using testing methodologies in development is that we can find
    errors in our code in the early steps of the development so that we will spend
    less time doing bug fixing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发中使用测试方法的原因是我们可以在开发的早期阶段发现代码中的错误，这样我们将花费更少的时间进行错误修复。
- en: Testing in microservices
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务测试
- en: The challenge of testing an application based on microservices is not in the
    testing of every single microservice, but on the integration and data consistency.
    An application based on microservices will need a better understanding of the
    architecture of microservices and their workflow by the developers to be able
    to use testing on it. This is because it is necessary to check the information
    and also the functionality of every microservice at all the points of communication
    between the microservices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 基于微服务的应用程序测试的挑战不在于测试每个单独的微服务，而在于集成和数据一致性。基于微服务的应用程序将需要开发人员对微服务架构及其工作流程有更好的理解，以便能够在其上进行测试。这是因为需要检查每个微服务的信息和功能，以及微服务之间的通信点。
- en: 'The testing to use on microservices are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务上使用的测试如下：
- en: '**Unit testing**: In all the applications based on microservices or even in
    a monolithic one, it is necessary to use unit testing. Using it, we will check
    the necessary functionality of the methods or code modules.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：在所有基于微服务的应用程序中，甚至在单体应用程序中，都需要使用单元测试。通过使用它，我们将检查方法或代码模块的必要功能。'
- en: '**Integration testing**: Unit testing only checks the isolated components,
    so we also need to check the behavior between methods. We will check the behavior
    between methods of the same microservice using integration testing, so the calls
    between microservices will need to be mocked.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：单元测试仅检查孤立的组件，因此我们还需要检查方法之间的行为。我们将使用集成测试来检查同一微服务中方法之间的行为，因此微服务之间的调用将需要被模拟。'
- en: '**API tests**:The microservices architecture depends on the communication between
    them. For each microservice, it is necessary to establish an API; this is like
    a *contract* to use that microservice. With this kind of test, we will check that
    the contract is working for each microservice and all the microservices are working
    with each other.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API测试**：微服务架构依赖于它们之间的通信。对于每个微服务，需要建立一个API；这就像使用该微服务的*合同*。通过这种测试，我们将检查每个微服务的合同是否有效，并且所有微服务是否互相配合。'
- en: '**End-to-end tests**:These guarantee the application quality without any mockup method
    or call. A test will be run to assess the functionality between all the required
    microservices. There are some rules to avoid problems during these tests:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：这些测试保证了应用程序的质量，没有任何模拟方法或调用。将运行测试来评估所有必需微服务之间的功能。在这些测试期间有一些规则可以避免问题：'
- en: End-to-end tests are difficult to maintain, so only test the most important
    functionalities; the rest of them use unit testing
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试很难维护，因此只测试最重要的功能；其余功能使用单元测试
- en: The user functionalities can be tested by simulating calls to the microservices
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模拟对微服务的调用，可以测试用户功能
- en: It is necessary to keep a clean environment to test it because the tests are
    very dependent on the data, so a previous test can manipulate the data and then,
    the next test
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试环境必须保持清洁，因为测试非常依赖数据，因此先前的测试可能会操纵数据，然后下一个测试
- en: Once we know how to proceed with testing our application based on microservices,
    we will look at some strategies to do so during development.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道如何根据微服务进行应用程序测试，我们将看一些在开发过程中进行测试的策略。
- en: Test-driven development
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '**Test-driven development** (**TDD**) is part of agile philosophy, and it appears
    to solve the common developer''s problem that shows when an application is evolving
    and growing and the code is getting sick. The developers fix the problems to make
    it run but every single line that we add can be a new bug and it can even break
    other functions.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'TDD is a learning technique that helps the developer to learn about the domain
    problem of the application they will build, doing it in an iterative, incremental,
    and constructivist way:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterative** because the technique always repeats the same process to get
    a value'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incremental** because for each iteration, we have more unit tests to be used'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructivist** because it is possible to test everything we are developing
    during the process straightaway so that we can get immediate feedback'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, when we finish developing each unit test or iteration, we can forget it
    because it will be kept throughout the entire development process, helping us
    to remember the domain problem through the unit test. This is a good approach
    for forgetful developers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very important to understand that TDD includes four things: analysis,
    design, development, and testing. In other words, doing TDD is understanding the
    domain problem and correctly analyzing the problem, designing the application
    well, developing well, and testing it. It needs to be clear; TDD is not just about
    implementing unit tests, but the whole process of the software development.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: TDD perfectly matches projects based on microservices, because using microservices
    in a large project is dividing it into little microservices, our functionalities are like
    an aggrupation of little projects connected by a communication channel. The project
    size is independent of using TDD because, in this technique, you divide each functionality
    into little examples and, to do this, it does not matter whether the project is
    big or small, and even less when our project is divided by microservices. Also,
    microservices are still better than a monolithic project because the functionalities
    for the unit tests are organized in microservices and it will help the developers
    to know where they can begin to use TDD.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: How to do TDD?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Doing TDD is not difficult, we just need to follow some steps and repeat them
    by improving our code and checking that we did not break anything:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**Write the unit test**: It needs to be the simplest and clearest test possible,
    and once it is done it has to fail; this is mandatory, if it does not fail, it
    means that there is something we are not doing properly.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Run the tests**: If it has errors (it fails), this is the moment to develop
    the minimum code to pass the test; just do what is necessary, do not code additional
    things. Once you develop the minimum code to pass the test, run the test again;
    if it passes go to the next step, if not fix it and run the test again.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Improve the test**: If you think it is possible to improve the code you wrote,
    do it and run the tests again. If you think it is perfect, write a new unit test.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following image illustrates the mantra of TDD--**RED**, **GREEN**, **REFACTOR**:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do TDD?](graphics/B06142_04_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: To do TDD, it is necessary to write the tests before implementing the function;
    if the implementation is started and then the tests are written, it is not TDD,
    it is just testing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: If we create the unit tests after we start developing our application, we are
    doing the classic testing and we are not taking advantage of the TDD benefits.
    Having your unit tests in place will help you ensure that your abstract idea of
    the domain problem is correct throughout the developing process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, doing testing is always better than not doing it, but doing TDD is
    still better than doing just classic testing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Why should I use TDD?
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TDD is the answer to questions such as "where shall I begin?", "how can I do
    it?", "how can I write code that can be modified without breaking anything?", and
    "how can I know what I have to implement?".
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是对问题的答案，比如“我应该从哪里开始？”，“我该如何做？”，“我如何编写可以修改而不会破坏任何东西的代码？”，以及“我如何知道我必须实现什么？”。
- en: The goal is not to write many unit tests without sense, but to design TDD properly
    following the requirements. In TDD, we do not to think about implementing functions,
    but about good examples of the functions related to the domain problem in order
    to remove the ambiguity created by the domain problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 目标不是毫无意义地编写许多单元测试，而是根据要求正确设计TDD。在TDD中，我们不是考虑实现功能，而是考虑与域问题相关的功能的良好示例，以消除域问题造成的歧义。
- en: In other words, we should reproduce a specific function or case of use in X
    examples by doing TDD until we get the necessary examples to describe the function
    or task without ambiguity or misinterpretations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们应该通过TDD在X个示例中复制特定功能或用例，直到我们得到必要的示例来描述该功能或任务，而不会产生歧义或误解。
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: TDD can be the best way to document your application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: TDD可能是记录应用程序的最佳方法。
- en: Using other methodologies of software development, we start thinking about how
    the architecture will be, what pattern will be used, how the communication between
    microservices will be, but what happens if once we have planned all this, we realize
    that it is not necessary? How much time will pass until we realize that? How much
    effort and money will we spend?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他软件开发方法时，我们开始思考架构将是什么样子，将使用什么模式，微服务之间的通信将如何进行，但如果一旦我们计划了所有这些，我们意识到这是不必要的呢？我们要花多长时间才能意识到？我们将花费多少精力和金钱？
- en: TDD defines the architecture of our application by creating little examples
    in many iterations until we realize what is the architecture. The examples will
    slowly show us the steps to follow in order to define what the best structure,
    pattern, or tools to use are, so that we avoid spending resources during the first
    stages of our application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TDD通过在许多迭代中创建小示例来定义我们应用程序的架构，直到我们意识到什么是架构。这些示例将逐渐向我们展示应该遵循的步骤，以便定义最佳结构、模式或要使用的工具，从而避免在应用程序的最初阶段浪费资源。
- en: This does not mean that we are working without an architecture. Obviously, we
    have to know whether our application will be a website or a mobile app and use
    a proper framework (you can research which framework fits your needs in [Chapter
    2](ch02.html "Chapter 2. Development Environment"), *Development Environment*),
    and also know what the interoperability in the application will be; in our case,
    it will be an application based on microservices. So, it will give us support
    to start creating the first unit tests. TDD will be our guideline to develop an
    application and it will produce an architecture without ambiguity from the unit
    testing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们在没有架构的情况下工作。显然，我们必须知道我们的应用程序是网站还是移动应用，并使用适当的框架（您可以在[第2章](ch02.html "第2章。开发环境")中了解哪种框架适合您的需求，*开发环境*），还要知道应用程序中的互操作性将是什么；在我们的情况下，它将是基于微服务的应用程序。因此，它将支持我们开始创建第一个单元测试。TDD将成为我们开发应用程序的指南，并且将通过单元测试产生一个没有歧义的架构。
- en: 'TDD is not cure-all; in other words, it does not give the same results to a
    senior and junior developer, but it is useful for the whole team. Let''s look
    at some advantages of using TDD:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: TDD并非万能良药；换句话说，它对资深开发人员和初级开发人员的效果并不相同，但对整个团队都是有用的。让我们看看使用TDD的一些优势：
- en: '**Code reuse**: This creates every functionality with only the necessary code
    to pass the tests in the second stage (Green). It allows you to see whether there
    are more functions using the same code structure or parts of a specific function;
    so, it helps you to reuse the code you wrote earlier.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重用：这样可以仅使用必要的代码来通过第二阶段（绿色）的测试来创建每个功能。它可以让你看到是否有更多的功能使用相同的代码结构或特定功能的部分；因此，它可以帮助你重用先前编写的代码。
- en: '**Teamwork is easier**: It allows you to be confident with your team colleagues.
    Some architects or senior developers do not trust developers with poor experience,
    and they need to check their code before committing the changes, creating a bottleneck at
    that point, so TDD helps us to trust the developers with less experience.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队合作更容易：它让你对团队同事充满信心。一些架构师或资深开发人员不信任经验不足的开发人员，他们需要在提交更改之前检查他们的代码，从而在这一点上造成瓶颈，因此TDD帮助我们相信经验较少的开发人员。
- en: '**Increases the communication**: It increases the communication between team
    colleagues. The communication is more fluent, so the team share their knowledge
    about the project reflected on the unit tests.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加沟通：增加团队同事之间的沟通。沟通更加流畅，因此团队可以分享他们在单元测试中反映的对项目的知识。
- en: '**Avoid overdesign**: Do not overdesign the application in the first stages.
    As we said before, doing TDD allows you to have an overview of the application
    little by little, avoiding creating useless structures or patterns in your project
    that you will maybe trash in the future stages.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免过度设计：不要在最初阶段过度设计应用程序。正如我们之前所说，进行TDD可以让你逐渐了解应用程序的概况，避免在项目中创建无用的结构或模式，也许在将来的阶段会被废弃。
- en: '**Unit tests are the best documentation**: The best way to give a good point
    of view of a specific functionality is by reading its unit test, which helps us
    understand how it works instead of human words.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试是最好的文档：了解特定功能的最佳方法是阅读其单元测试，这有助于我们理解它的工作原理，而不是人类的语言。
- en: '**Allows to discover more use cases** in the design stage: In every test you
    have to create, you will understand how the functionality should work better and
    all the possible stages that a functionality can have.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计阶段发现更多用例：在每个测试中，您都将了解功能应该如何更好地工作，以及功能可能具有的所有可能阶段。
- en: '**Increases the feeling of a job well done**: In every commit of your code,
    you will have the feeling that it was done properly because the rest of the unit
    tests pass without errors, so you will not be worried about breaking other functionalities.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加了工作完成的感觉**：在每次提交代码时，您会感到它被正确地完成了，因为其余的单元测试都通过了，所以您不必担心破坏其他功能。'
- en: '**Increases the software quality**: During the refactoring step, we spend our
    efforts in making the code more efficient and maintainable, verifying that the
    whole project still works properly after the changes.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高软件质量**：在重构步骤中，我们努力使代码更高效和可维护，验证在更改后整个项目仍然正常工作。'
- en: TDD algorithm
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD算法
- en: 'The technical concepts and steps to follow the TDD algorithm are easy and clear,
    and the proper way to make it happen improves by practicing it. As we saw before,
    there are only three steps: red, green, and refactor.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循TDD算法的技术概念和步骤是简单明了的，通过实践来改进实现它的正确方式。正如我们之前所看到的，只有三个步骤：红、绿和重构。
- en: Red - writing the unit tests
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 红 - 编写单元测试
- en: It is possible to write a test even when the code is not written, you just need
    to think about whether it is possible to write a specification before implementing
    it. So, in the first step, you should consider that the unit test you start writing
    is not like a unit test but like an example or specification of the functionality.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 即使代码尚未编写，也可以编写测试，您只需考虑是否可以在实现之前编写规范。因此，在第一步中，您应该考虑开始编写的单元测试不像单元测试，而像功能的示例或规范。
- en: In TDD, this example or specification is not fixed; in other words, the unit
    test can be modified in the future. Before beginning to write the first unit test,
    it is necessary to think about how the **software under test** (**SUT**) will
    be, and just a little about how it will work. We need to think about how it will
    be the SUT code and how we will check that it works the way we want it to.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，这个示例或规范并不是固定的；换句话说，单元测试可以在将来进行修改。在开始编写第一个单元测试之前，需要考虑**被测试软件**（**SUT**）将是什么样子，以及它将如何工作。我们需要考虑SUT代码将是什么样子，以及我们将如何检查它是否按我们想要的方式工作。
- en: The way that TDD works drives us to firstly design what is more comfortable
    and clear if it fits the requirements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的工作方式首先让我们设计更舒适和清晰的东西，如果它符合要求的话。
- en: Green - make the code work
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绿 - 使代码工作
- en: Once the example is written, we have to code the minimum to make it pass the
    test; in other words, set the unit test to green. It does not matter if the code
    is ugly and not optimized, it will be our task in the next steps and iterations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦示例编写完成，我们必须编写最少的代码使其通过测试；换句话说，设置单元测试为绿色。代码是否丑陋且未经优化并不重要，这将是我们在接下来的步骤和迭代中的任务。
- en: In this step, the important thing is only to write the necessary code for the
    requirements, without unnecessary things. It does not mean writing without thinking
    about the functionality, but thinking about it to be efficient. It looks easy,
    but you will realize that you will write extra code the first time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，重要的是只编写满足要求的必要代码，而不是不必要的东西。这并不意味着不考虑功能性地编写，而是考虑到它的高效性。看起来很容易，但您会意识到第一次会写出额外的代码。
- en: If you concentrate on this step, you will think of new questions about the SUT
    behavior with different entries. However, you should be strong and avoid writing
    extra code about other functionalities related to the current one. As a rule of
    thumb, instead of coding the new features, take notes so you can convert them
    into functionalities in future iterations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您专注于这一步，您将考虑到关于SUT行为的不同输入的新问题。然而，您应该坚定不移地避免编写与当前功能相关的其他功能的额外代码。作为一个经验法则，不要编写新功能，而是做笔记，以便在未来的迭代中将它们转换为功能。
- en: Refactor - eliminate redundancy
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构 - 消除冗余
- en: Refactoring is not the same as rewriting code. You should be able to change
    the design without changing the behavior.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重构不同于重写代码。您应该能够在不改变行为的情况下改变设计。
- en: In this step, you should remove the duplicity in your code and check whether
    the code matches the principles of the good practices, thinking about the efficiency,
    clarity, and the future maintainability of the code. This part depends on the
    experience of each developer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，您应该消除代码中的重复，并检查代码是否符合良好实践的原则，考虑效率、清晰度和代码的未来可维护性。这部分取决于每个开发人员的经验。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The key to good refactoring is doing it in small steps.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 良好重构的关键是采取小步骤。
- en: To refactor a functionality, the best way to do it is to change a little part
    and execute all the available tests, and if they pass, continue with another little
    part until you are happy with the obtained result.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重构功能的最佳方式是改变一小部分并执行所有可用的测试，如果它们通过了，继续进行下一个小部分，直到你对得到的结果满意。
- en: Behavior-driven development
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: '**Behavior-driven development** (**BDD**) is a process that broadens the TDD
    technique and mixes it with other design ideas and business analysis provided
    to the developers in order to improve the software development.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）是一种扩展TDD技术并将其与其他设计思想和业务分析相结合的过程，以便提供给开发人员以改进软件开发。'
- en: In BDD, we test the scenarios and the class's behavior in order to meet the
    scenarios that can be composed by many classes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在BDD中，我们测试场景和类的行为，以满足可以由许多类组成的场景。
- en: It is very useful to use a DSL in order to have a common language to be used
    by the customer, project owner, business analyst, or developers. The goal is to
    have a ubiquitous language as we saw in [Chapter 3](ch03.html "Chapter 3. Application
    Design"), *Application Design*, in the domain-driven design section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DSL非常有用，以便客户、项目所有者、业务分析师或开发人员使用共同的语言。目标是拥有一个像我们在[第3章](ch03.html "第3章。应用设计")中看到的那样的普遍语言，*应用设计*，在领域驱动设计部分。
- en: What is BDD?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是BDD？
- en: As we said before, BDD is an agile technique based on TDD and ATDD, promoting
    the collaboration between the entire team of a project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，BDD是一种基于TDD和ATDD的敏捷技术，促进了项目整个团队之间的协作。
- en: The goal of BDD is that the entire team understands what the customer wants,
    and the customer knows what the rest of the team understood from their specifications.
    Most of the times, when a project starts, developers don't have the same point
    of view as the customer, and during the development process the customer realizes
    that maybe they did not explain it or maybe the developer did not understand it
    properly, so it adds more time to change the code to meet the customer's needs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: BDD的目标是让整个团队了解客户的需求，让客户知道团队其他成员从他们的规范中理解了什么。大多数情况下，当项目开始时，开发人员和客户的观点并不相同，在开发过程中客户意识到也许他们没有解释清楚，或者开发人员没有正确理解，因此需要更多时间来更改代码以满足客户的需求。
- en: So, BDD is writing test cases in human language using rules or a ubiquitous
    language so that the customer and developers can understand it. It also defines
    a DSL for the tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，BDD是使用规则或通用语言以人类语言编写测试用例，以便客户和开发人员能够理解。它还为测试定义了DSL。
- en: How does it work?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: It is necessary to define the features as user stories (we will explain what
    this is in the ATDD section of this chapter) and examine their acceptance criteria.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将功能定义为用户故事（我们将在本章的ATDD部分解释这是什么），并检查它们的验收标准。
- en: 'Once the user story is defined, we have to focus on the possible scenarios that
    describe the project behavior for a concrete user or situation using DSL. The
    steps are: given (context), when (event occurs), and then (outcome).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户故事被定义，我们必须专注于使用DSL描述项目行为的可能场景。步骤是：给定（上下文），当（事件发生），然后（结果）。
- en: To sum up, the defined scenario for a user story gives the acceptance criteria
    to check whether the feature is done.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，为用户故事定义的场景为验收标准提供了检查功能是否完成的依据。
- en: Cucumber as DSL for BDD
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cucumber作为BDD的DSL
- en: Cucumber is a DSL tool that executes examples made in plain text as automatic
    tests, taking advantage of the benefits of BDD and bringing together the business
    layer and the technology in a project in order to know what are the functionalities
    most valued by the user and develop them at the same time that we are defining
    the case tests and documenting the project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber是一个DSL工具，它执行以纯文本形式制作的示例作为自动测试，利用BDD的好处，将业务层和技术结合在一起，以了解用户最看重的功能，并在定义用例测试和记录项目的同时开发它们。
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The most important thing for Cucumber is having the same point of understanding
    between developers and customers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber最重要的是让开发人员和客户有相同的理解。
- en: '**Gherkin** is the language that Cucumber uses, and it allows you to translate
    the specifications of the project into a near human language so that the customer
    or other people without technical skills can understand it. This tool and language
    can be used for BDD and ATDD. Let''s look at a piece of sample code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gherkin**是Cucumber使用的语言，它允许您将项目的规范翻译成接近人类语言，以便客户或其他没有技术技能的人能够理解。这个工具和语言可以用于BDD和ATDD。让我们看一个样本代码：'
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This allows us to define the software behavior without saying how it is implemented.
    Also, it allows us to document the functionalities at the same time we write the
    case automatic tests. The advantages of using Cucumber are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以让我们定义软件行为，而不用说出它是如何实现的。同时，它也让我们能够在编写自动测试用例的同时记录功能。使用Cucumber的优势如下：
- en: Easy to read
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于阅读
- en: Easy to understand
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于理解
- en: Easy to parse
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于解析
- en: Easy to discuss
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于讨论
- en: 'DSL has three steps in the code that the tool understands and processes; they
    are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: DSL在代码中有三个工具可以理解和处理的步骤；它们如下：
- en: '**Given**: This is the necessary step to set the system in the proper status
    to check the tests.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**给定**：这是将系统设置为适当状态以检查测试的必要步骤。'
- en: '**When**: This is the necessary step to be carried out by the user to action
    the functionality.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当**：这是用户必须执行的必要步骤来激活功能。'
- en: '**Then**: This refers to the things that change in the system. Here, we are
    able to see if it does what we want.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**然后**：这指的是系统中发生变化的事物。在这里，我们能够看到它是否符合我们的期望。'
- en: 'Also, there are two more available optional steps: **And** and **But**, and
    they can be used in **Given** or **Then** when you need more than a sentence to
    match the requirements.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个可选的步骤：**And**和**But**，它们可以在**Given**或**Then**中使用，当您需要超过一句话来满足要求时。
- en: In this chapter, we will see how to use a tool, called Selenium, to do BDD.
    It is another DSL tool but is oriented to web development instead of plain text.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何使用一个名为Selenium的工具来进行BDD。这是另一个DSL工具，但是它是面向Web开发而不是纯文本的。
- en: Acceptance test-driven development
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验收测试驱动开发
- en: Maybe the most important methodology in a project is the **Acceptance Test-Driven
    Development** (**ATDD**) or **Story Test-Driven Development** (**STDD**); it is
    TDD but on a different level.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 也许项目中最重要的方法是**验收测试驱动开发**（**ATDD**）或**故事测试驱动开发**（**STDD**）；它是TDD，但在不同的层面上。
- en: The acceptance (or customer) tests are the written criteria that the project
    meets the business requirements that the customer demands. They are examples (like
    the examples in TDD) written by the project owner. It is the beginning of the
    development for each iteration, the bridge between scrum and agile development.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 验收（或客户）测试是项目满足客户需求的业务要求的书面标准。它们是由项目所有者编写的示例（就像TDD中的示例）。它是每次迭代开发的开始，是Scrum和敏捷开发之间的桥梁。
- en: In ATDD, we start the implementation of our project in a different way to the
    traditional methodologies. The business requirements written in human language
    are replaced by executables agreed by some team members and the customer. It is
    not about replacing the whole documentation, but only part of the requirements.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在ATDD中，我们以一种与传统方法不同的方式开始项目的实施。用人类语言编写的业务需求被一些团队成员和客户商定的可执行文件所取代。这并不是要替换整个文档，而只是部分需求。
- en: 'The advantages of using ATDD are as mentioned:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ATDD的优势如下：
- en: It provides real examples and a common language for the team to understand the
    domain
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了真实的例子和一个团队可以理解领域的共同语言
- en: It allows us to identify the domain rules properly
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使我们能够正确识别领域规则
- en: It is possible to know if a user story is finished in each iteration
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在每次迭代中知道用户故事是否完成
- en: The workflow works from the first steps
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作流程从最初的步骤开始
- en: The development does not start until the tests are defined and accepted by the
    team
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发直到团队定义并接受了测试才开始
- en: User stories
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户故事
- en: The user stories of ATDD are like use cases in terms of name or description,
    but work in a different way. A user story does not define the requirement, avoiding
    the problem of ambiguity of the human language. The goal is to communicate the
    idea without problems for the rest of the team.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ATDD的用户故事在名称或描述方面类似于用例，但工作方式不同。用户故事不定义需求，避免了人类语言的歧义问题。目标是让团队的其他成员能够无问题地理解这个想法。
- en: 'Each user story is a list of clear and concise examples about what the customer
    wants from the application. The name of the story is a sentence of human language
    defining what the function must do. Consider the following examples:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户故事都是关于客户对应用程序的期望的清晰简洁的例子列表。故事的名称是一个人类语言的句子，定义了功能必须做什么。考虑以下例子：
- en: Search available secrets around our position
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索我们位置周围的可用秘密
- en: Check the secrets we already have stored
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们已经存储的秘密
- en: Check who is the winner in a battle
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查战斗中谁是赢家
- en: They have the goals of listening to the customers and helping them define what
    they expect from the application. The user stories should be clear without ambiguity
    and should be written in human language, not in technical language; the customer
    should understand what they say.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的目标是倾听客户并帮助他们定义他们对应用程序的期望。用户故事应该清晰明了，没有歧义，并且应该用人类语言而不是技术语言编写；客户应该能够理解他们所说的话。
- en: 'Once we have defined a user story, some questions appear and they should be
    answered by associating acceptance tests for each story. For example, for the
    *Check who is the winner in a battle* story, some possible questions are as listed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了一个用户故事，就会出现一些问题，这些问题应该通过为每个故事关联验收测试来回答。例如，对于*检查战斗中谁是赢家*的故事，一些可能的问题如下所列：
- en: What happens if they draw?
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们平局了会发生什么？
- en: What does the winner win?
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赢家会得到什么？
- en: What does the loser lose?
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输家会失去什么？
- en: How long does a battle take?
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一场战斗需要多长时间？
- en: 'And the possible acceptance tests are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的验收测试如下：
- en: If they draw, no one will win or lose anything; they will keep their secrets
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们平局了，没有人会赢或输任何东西；他们会保留他们的秘密
- en: The winner will earn 10 points and get a secret from the loser's pocket
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赢家将获得10分，并从输家的口袋里得到一个秘密
- en: The loser will give a secret to the winner
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输家将给赢家一个秘密
- en: A battle takes three throws of a dice
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一场战斗需要掷三次骰子
- en: Maybe the questions and answers from a user story will generate new user stories
    to be added to the backlog.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 也许一个用户故事的问题和答案会产生新的用户故事，添加到待办列表中。
- en: ATDD algorithm
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ATDD算法
- en: 'The algorithm of ATDD is like the TDD, but reaches more people than the developers.
    In other words, doing ATDD, the tests of each story are written in a meeting that
    includes the project owners, developers, and QA technicians because the team must
    understand what is necessary to do and why it is necessary so that they can see
    if it is what the code should do. The following image shows the ATDD cycle:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ATDD的算法类似于TDD，但覆盖的人员比开发人员更多。换句话说，进行ATDD时，每个故事的测试是在一个会议上编写的，该会议包括项目所有者、开发人员和QA技术人员，因为团队必须理解需要做什么以及为什么需要这样做，以便他们可以看到代码应该做什么。以下图片显示了ATDD的循环：
- en: '![ATDD algorithm](graphics/B06142_04_03.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![ATDD算法](graphics/B06142_04_03.jpg)'
- en: Discuss
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论
- en: The starting point of the ATDD algorithm is the discussion. In this step, the
    business has a meeting with the customer to clarify how the application should
    work and the analyst should create the user stories from that conversation. Also,
    they should be able to explain the conditions of satisfaction of every user story
    in order to be translated into examples as we explained earlier, in the user stories
    section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ATDD算法的起点是讨论。在这一步中，业务与客户进行会议，澄清应用程序应该如何工作，分析师应该从对话中创建用户故事。此外，他们应该能够解释每个用户故事的满意条件，以便被翻译成例子，就像我们在用户故事部分解释的那样。
- en: By the end of the meeting, the examples should be clear and concise so that
    we can get a list of examples of user stories to cover all the needs that the
    customer reviewed and understood for himself. Also, the team will have a project
    overview in order to understand the business value of the user story, and in case
    the user story was too big, it can be divided into little user stories, getting
    the first one for the first iteration of this process.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 会议结束时，例子应该清晰简洁，这样我们就可以得到一个用户故事的例子列表，以满足客户审查和理解的所有需求。此外，团队将对项目有一个概览，以便理解用户故事的业务价值，如果用户故事太大，可以将其分成小的用户故事，获得第一个迭代的第一个用户故事。
- en: Distill
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提炼
- en: The high level acceptance tests are written by the customer and the development
    team. In this step, the writing of the test cases that we got from the examples
    in the discussion step begins and the team can take part in the discussion and
    help clarify the information or specify its real needs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 高级验收测试由客户和开发团队编写。在这一步中，从讨论步骤中得到的测试用例的编写开始，并且团队可以参与讨论并帮助澄清信息或指定其真实需求。
- en: The tests should cover all the examples that were discovered in the discussion
    step, and extra tests could be added during this process; little by little we
    are understanding the functionality better.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该覆盖在讨论步骤中发现的所有示例，并在这个过程中可以添加额外的测试；一点一点地我们正在更好地理解功能。
- en: At the end of this step, we will obtain the necessary tests written in human
    language so that the team (including the customer) can understand what they will
    do in the next step. These tests can be used like documentation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步结束时，我们将获得以人类语言编写的必要测试，以便团队（包括客户）能够理解他们在下一步将要做什么。这些测试可以用作文档。
- en: Develop
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发
- en: In the develop step, the acceptance test cases start to be developed by the
    development team and the project owner. The methodology to follow in this step
    is the same as TDD--the developers should create a test and watch it fail (red),
    and then develop the minimum amount of lines to pass (green). Once the acceptance
    tests are green, this should be verified and tested to be ready to be delivered.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发步骤中，验收测试用例开始由开发团队和项目所有者开发。在这一步骤中要遵循的方法与TDD相同--开发人员应该创建一个测试并观察它失败（红色），然后开发最少的代码行以通过测试（绿色）。一旦验收测试通过，就应该进行验证和测试，准备好交付。
- en: During this process, the developers may find new scenarios that need to be added
    into the tests or even, if it needs a large amount of work, it could be pushed
    to the user story.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，开发人员可能会发现需要添加到测试中的新场景，甚至，如果需要大量工作，它可能会被推到用户故事中。
- en: At the end of this step, we will have a software that passes the acceptance
    tests and maybe more comprehensive tests.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步结束时，我们将拥有一个通过验收测试的软件，甚至可能还有更全面的测试。
- en: Demo
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 演示
- en: The created functionality is shown by running the acceptance test cases and
    manually exploring the features of the new functionality. After it is demonstrated,
    the team discusses whether the user story was done properly and whether it meets
    the product owner's needs and decide if they can continue with the next story.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行验收测试用例并手动探索新功能的特性来展示创建的功能。演示完毕后，团队讨论用户故事是否做得恰当，是否满足产品所有者的需求，并决定是否可以继续下一个故事。
- en: Tools
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: Now that you know more about TDD and BDD, it is time to explain a few tools
    that you can use in your development workflow. There are a lot of tools available,
    but we will only explain the most used ones.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经更多地了解了TDD和BDD，是时候解释一些可以在开发工作流程中使用的工具了。有很多可用的工具，但我们只会解释最常用的工具。
- en: Composer
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Composer
- en: Composer is a PHP tool used to manage software dependencies. You only need to
    declare the libraries required by your project and Composer will manage them,
    installing and updating them when necessary. This tool has only a few requirements--if
    you have PHP 5.3.2+, you are ready to go. In the case of a missing requirement,
    Composer will warn you.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Composer是一个用于管理软件依赖关系的PHP工具。您只需要声明项目所需的库，Composer将管理它们，在必要时安装和更新它们。这个工具只有一些要求--如果您有PHP
    5.3.2+，您就可以开始了。如果缺少某个要求，Composer会提醒您。
- en: 'You can install this dependency manager on your development machine, but since
    we are using Docker, we will install it directly on our **PHP-FPM** (**FastCGI
    Process Manager**) containers. The installation of Composer in Docker is very
    easy; you only need to add the following rule to the Dockerfile:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在开发机器上安装这个依赖管理器，但由于我们使用的是Docker，我们将直接在我们的**PHP-FPM**（**FastCGI进程管理器**）容器中安装它。在Docker中安装Composer非常容易；您只需要向Dockerfile添加以下规则：
- en: '[PRE1]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: PHPUnit
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHPUnit
- en: Another tool we need for our project is PHPUnit, a unit test framework. In our
    case, we will use version 4.0\. The same as before, we will add this tool to our
    PHP-FPM containers to keep our development machine clean. If you are wondering
    why we are not installing anything on our development machine except for Docker,
    the response is clear--having everything in the containers will help you avoid
    any conflict with other projects and give you the flexibility of changing versions
    without being too worried.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目中需要的另一个工具是PHPUnit，一个单元测试框架。在我们的情况下，我们将使用4.0版本。与之前一样，我们将把这个工具添加到我们的PHP-FPM容器中，以保持我们的开发机器干净。如果您想知道为什么除了Docker之外我们不在开发机器上安装任何东西，答案很明确--将所有东西放在容器中将帮助您避免与其他项目的冲突，并且可以灵活地更改版本而不必过于担心。
- en: 'As a quick way, you can add the following `RUN` command to your `PHP-FPM` `Dockerfile`
    and you will have the latest PHPUnit version installed and ready to use:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速的方法，您可以在您的`PHP-FPM` `Dockerfile`中添加以下`RUN`命令，这样您就可以安装并准备使用最新的PHPUnit版本了：
- en: '[PRE2]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command will install the latest Composer version in your container,
    but the recommended way of installing it is through Composer. Open your `composer.json`
    file and add the following line:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在您的容器中安装最新的Composer版本，但推荐的安装方式是通过Composer。打开您的`composer.json`文件并添加以下行：
- en: '[PRE3]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As soon as you update the `composer.json` file, you only need to do a Composer
    update in your container command line and Composer will install PHPUnit for you.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您更新了`composer.json`文件，您只需要在容器命令行中执行Composer更新，Composer就会为您安装PHPUnit。
- en: Now that we have all our requirements as well, it is time to install our PHP
    framework and start doing some TDD stuff. Later, we will continue updating our
    Docker environment with new tools.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的要求都准备好了，现在是时候安装我们的PHP框架并开始做一些TDD的工作了。稍后，我们将继续更新我们的Docker环境，加入新的工具。
- en: In the previous chapters, we talked about some PHP frameworks and chose Lumen as
    our example. Feel free to adapt all the examples to your favorite framework. Our
    source code will be living inside our containers but, at this point of the development,
    we do not want immutable containers. We want every change we make to our code
    to be available instantaneously in our containers so that we will use a container
    as a storage volume.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们谈到了一些PHP框架，并选择了Lumen作为我们的示例。请随意将所有示例调整为您喜欢的框架。我们的源代码将存储在容器中，但在开发的这一阶段，我们不希望容器是不可变的。我们希望我们对代码所做的每一次更改都能立即在我们的容器中使用，因此我们将使用容器作为存储卷。
- en: 'To create a container with our source and use it as a storage volume, we only
    need to edit our `docker-compose.yml` file and create a source container for each
    of our microservices, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含我们的源代码并将其用作存储卷的容器，我们只需要编辑我们的`docker-compose.yml`文件，并为我们的每个微服务创建一个源容器，如下所示：
- en: '[PRE4]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding piece of code creates a container image named `source_battle`,
    and it stores our battle source (located at `../source/battle` from the `docker-compose.yml` file
    current path). Once we have our source container available, we can edit each of
    our services and assign a volume. For instance, we can add the following line to
    our `microservice_battle_fpm` and `microservice_battle_nginx` container descriptions:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段创建了一个名为`source_battle`的容器映像，并存储了我们的battle源代码（位于`docker-compose.yml`文件当前路径的`../source/battle`）。一旦我们有了我们的源代码容器，我们可以编辑每个服务并分配一个卷。例如，我们可以将以下行添加到我们的`microservice_battle_fpm`和`microservice_battle_nginx`容器描述中：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our battle source will be available in our source container at the `/var/www/html`
    path and the remaining step to install Lumen is to do a simple Composer execution.
    First, you need to ensure that your infrastructure is up with a simple command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的battle源代码将在我们的源容器的`/var/www/html`路径中可用，安装Lumen的剩下步骤是执行一个简单的Composer命令。首先，您需要确保您的基础设施已经准备好了：
- en: '[PRE6]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding command spins up our containers and outputs the log to the standard
    IO. Now that we are sure that everything is up and running, we need to enter in
    our PHP-FPM containers and install Lumen.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令启动我们的容器并将日志输出到标准IO。现在我们确信一切都已经准备就绪，我们需要进入我们的PHP-FPM容器并安装Lumen。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you need to know the names assigned to each of your containers, you can
    execute `docker ps` on your terminal and copy the container name.As an example,
    we will enter the following command into the battle PHP-FPM container:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要知道每个容器分配的名称，可以在终端上执行`docker ps`并复制容器名称。例如，我们将输入以下命令进入battle PHP-FPM容器：
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding command opens an interactive shell in your container so that
    you can do anything you want. Let''s install Lumen with a single command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在您的容器中打开一个交互式shell，以便您可以做任何您想做的事情。让我们用一个命令安装Lumen：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Repeat the preceding commands for each of your microservices.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个微服务重复上述命令。
- en: Now you have everything ready to start doing unit tests and code your application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好开始进行单元测试并编写应用程序代码了。
- en: Unit testing
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'A unit test is a small piece of code that uses other code in a known context
    so that we can check whether the code we are testing is valid. Lumen comes with
    PHPUnit out of the box; therefore, we only need to add all our tests to the tests
    folder. The framework installation comes with a very small sample file by default--`ExampleTest.php`--where
    you can give the unit testing a try. In order to start with unit testing and until
    you become more comfortable creating unit tests, choose one of your microservices
    sources and create the `app/Dummy.php` file with the following content:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一小段代码，它在已知的上下文中使用其他代码，以便我们可以检查我们正在测试的代码是否有效。Lumen默认带有PHPUnit；因此，我们只需要将所有测试添加到tests文件夹中。框架安装默认带有一个非常小的示例文件--`ExampleTest.php`--您可以在其中尝试单元测试。为了开始单元测试，直到您更加熟悉创建单元测试，选择一个您的微服务源代码，并创建`app/Dummy.php`文件，内容如下：
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The easiest way of starting with unit testing is every time you create a new
    class in your code, you can create a new one for your tests. Working this way,
    you will remember that your new class needs to be covered with unit tests. For
    instance, imagine that you need a `Battle` class; therefore, when you create the
    class, you can also create a new one with a `Test` prefix in your `tests` folder.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 开始单元测试的最简单方法是每次在代码中创建一个新类时，您都可以为测试创建一个新类。以这种方式工作，您将记住您的新类需要用单元测试进行覆盖。例如，想象一下您需要一个`Battle`类；因此，当您创建该类时，您还可以在`tests`文件夹中创建一个以`Test`为前缀的新类。
- en: 'In an ideal world, all your code is covered by unit tests but we know that
    this is an odd case. Most of the times, you will have 70% or 80% of code coverage
    if you are lucky. We encourage you to keep your code fully covered but if it is
    not possible, cover at least the core functionalities. There are two ways of creating
    unit tests:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的情况下，所有代码都应该由单元测试覆盖，但我们知道这是一个奇怪的情况。大多数情况下，如果幸运的话，您的代码覆盖率将达到70%或80%。我们鼓励您保持代码完全覆盖，但如果不可能，至少覆盖核心功能。有两种创建单元测试的方法：
- en: '**Tests first, code later:** In our opinion, this workflow is better when you
    have enough time to develop your project. First, you create the tests so that
    you are sure that you really know each new functionality. After you have the tests
    in place, you will write the minimum code necessary to pass the tests. Coding
    this way, you will be thinking about what makes your code valid and what can make
    your code fail.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先测试，后编码：**在我们看来，当您有足够的时间开发项目时，这种工作流程更好。首先，创建测试，以确保您真正了解每个新功能。在测试就位后，您将编写必要的最小代码以通过测试。以这种方式编码，您将思考什么使您的代码有效，以及什么可能使您的代码失败。'
- en: '**Code first, tests later:** This a very extended workflow when you don''t
    have too much time for unit testing. You create your code as always and, as soon
    as you have finished, you create the unit tests. This approach creates a less
    robust code because you are adapting your unit test to the already created code
    instead of doing it the other way around.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先写代码，后写测试：** 当您没有太多时间进行单元测试时，这是一个非常常见的工作流程。您像往常一样创建您的代码，一旦完成，就创建单元测试。这种方法会创建一个不太健壮的代码，因为您是将单元测试适应已创建的代码，而不是相反。'
- en: Remember that it is important to always have time to test your code; it is a
    long-term investment. Spending time at the beginning will make your code more
    robust and will eliminate future bugs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，测试代码的时间非常重要；这是一项长期投资。在开始时花费时间将使您的代码更加健壮，并消除未来的错误。
- en: Running the tests
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'You are probably wondering how you can run and check your tests. Don''t worry,
    it is very simple. You only need to enter one of your PHP-FPM containers. For
    example, to enter in the Battle PHP-FPM container, open your terminal and execute
    the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道如何运行和检查您的测试。别担心，这很简单。您只需要进入您的PHP-FPM容器之一。例如，要进入Battle PHP-FPM容器，请打开终端并执行以下命令：
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After executing the above command you will be inside the container. Now it
    is time to be sure that your current path is the `/var/www/html` folder. After
    you accomplish the previous step, you can execute phpunit inside that folder.
    All this actions can be done with the following commands:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令后，您将进入容器。现在是时候确保您的当前路径是`/var/www/html`文件夹。完成上一步后，您可以在该文件夹中执行phpunit。所有这些操作都可以使用以下命令完成：
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `phpunit` command will read the `phpunit.xml` file. This XML describes where
    our tests are stored and executes all of them. The execution of this command will
    give us a pretty screen with the results of our passed or failed tests.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`phpunit`命令将读取`phpunit.xml`文件。这个XML描述了我们的测试存储在哪里，并执行所有测试。执行此命令将为我们提供一个漂亮的屏幕，显示我们的测试通过或失败的结果。'
- en: Assertions
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: An assertion is a statement in a known context that we are expecting to be true
    at some point in our code and that is the core of unit testing. Assertions are
    used inside test cases and a test case can include multiple assertions inside
    the same tests. In PHPUnit, it is very simple to create a test as you only need
    to add the `test` prefix to your method name. Easy, isn't it? To clarify all these
    concepts, let's look at some assertions you can use in your unit tests with some
    examples. Feel free to create more complex tests until you are comfortable with
    PHPUnit.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是在已知上下文中的语句，我们期望在代码中的某个时刻为真，并且这是单元测试的核心。断言用于测试用例内，一个测试用例可以包含多个断言。在PHPUnit中，创建测试非常简单，您只需要在方法名称前添加`test`前缀。简单吧？为了澄清所有这些概念，让我们看一些您可以在单元测试中使用的断言及其示例。随时创建更复杂的测试，直到您熟悉PHPUnit为止。
- en: assertArrayHasKey
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertArrayHasKey
- en: 'The `assertArrayHasKey(mixed $key, array $array[, string $message = ''''])`
    assertion checks whether `$array` has an element with `$key`. Imagine that you
    have a method that generates and returns some kind of configuration data and there
    is a specific element identified by `storage` that you need to be sure is always
    present. Add the following method to our `Dummy` class to simulate the configuration
    generation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertArrayHasKey(mixed $key, array $array[, string $message = ''''])`断言检查`$array`是否具有`$key`元素。想象一下，您有一个生成并返回某种配置数据的方法，并且有一个特定由`storage`标识的元素，您需要确保它始终存在。将以下方法添加到我们的`Dummy`类中以模拟配置生成：'
- en: '[PRE12]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can test the response of this `getConfigArray` in any way we want:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以以任何方式测试此`getConfigArray`的响应：
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding test will check if the array returned by `getConfigArray` has
    an element identified by `foo`, which fails in our example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的测试将检查`getConfigArray`返回的数组是否具有由`foo`标识的元素，在我们的示例中失败了：
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, this test will ensure that `getConfigArray` returns an element
    identified by `storage`. If, for some reason, you change the implementation of
    the `getConfigArray` method in future, this test will help you ensure that you
    keep receiving at least an array element identified by `storage`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，此测试将确保`getConfigArray`返回由`storage`标识的元素。如果由于某种原因您将来更改`getConfigArray`方法的实现，此测试将帮助您确保您至少继续接收由`storage`标识的数组元素。
- en: You can use `assertArrayNotHasKey()` as the inverse of `assertArrayHasKey;`
    it uses the same arguments.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`assertArrayNotHasKey()`作为`assertArrayHasKey`的反向操作；它使用相同的参数。
- en: assertClassHasAttribute
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertClassHasAttribute
- en: 'The `assertClassHasAttribute(string $attributeName, string $className[, string
    $message = ''''])` assertion checks whether our `$className` has defined the `$attributeName`.
    Modify our `Dummy` class and add a new attribute, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertClassHasAttribute(string $attributeName, string $className[, string
    $message = ''''])`断言检查我们的`$className`是否已定义`$attributeName`。修改我们的`Dummy`类并添加一个新属性，如下所示：'
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can test the existence of this public attribute with the following tests:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下测试来测试此公共属性的存在：
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code will pass the check of the `foo` attribute but will fail
    in checking the `bar` attribute.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将通过`foo`属性的检查，但在检查`bar`属性时将失败。
- en: You can use `assertClassNotHasAttribute()` as the inverse of `assertClassHasAttribute;`
    it uses the same arguments.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`assertClassNotHasAttribute()`作为`assertClassHasAttribute`的反向操作；它使用相同的参数。
- en: assertArraySubset
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertArraySubset
- en: 'The `assertArraySubset(array $subset, array $array[, bool $strict = '''', string
    $message = ''''])` assertion checks whether a given `$subset` is available in
    our `$array`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertArraySubset(array $subset, array $array[, bool $strict = '''', string
    $message = ''''])`断言检查给定的`$subset`是否在我们的`$array`中可用：'
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding example test will fail because the `['storage' => 'failed-test']`
    subset does not exist in the response of our `getConfigArray` method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例测试将失败，因为`['storage' => 'failed-test']`子集不存在于我们的`getConfigArray`方法的响应中。
- en: assertClassHasStaticAttribute
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertClassHasStaticAttribute
- en: 'The `assertClassHasStaticAttribute(string $attributeName, string $className[,
    string $message = ''''])` assertion checks the existence of a static attribute
    in a given `$className`. We can add a static attribute, like the following one,
    to our `Dummy` class:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertClassHasStaticAttribute(string $attributeName, string $className[, string
    $message = ''''])`断言检查给定`$className`中静态属性的存在。我们可以向我们的`Dummy`类添加一个静态属性，如下所示：'
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Having this static attribute in place, we are free to test the existence of
    `$availableLocales`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个静态属性，我们可以自由地测试`$availableLocales`的存在：
- en: '[PRE19]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In case of needing to assert the inverse, you can use `assertClassNotHasStaticAttribute();`
    it uses the same arguments.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要断言相反的情况，可以使用`assertClassNotHasStaticAttribute();`它使用相同的参数。
- en: assertContains()
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertContains()
- en: 'Sometimes you need to check if a haystack contains specific elements. You can
    do this using the `assertContains()` functions:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要检查一个集合是否包含特定元素。您可以使用`assertContains()`函数来实现：
- en: '`assertContains(mixed $needle, Iterator|array $haystack[, string $message =
    ''''])`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertContains(mixed $needle, Iterator|array $haystack[, string $message =
    ''''])`'
- en: '`assertNotContains(mixed $needle, Iterator|array $haystack[, string $message
    = ''''])`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotContains(mixed $needle, Iterator|array $haystack[, string $message
    = ''''])`'
- en: '`assertContainsOnly(string $type, Iterator|array $haystack[, boolean $isNativeType
    = null, string $message = ''''])`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertContainsOnly(string $type, Iterator|array $haystack[, boolean $isNativeType
    = null, string $message = ''''])`'
- en: '`assertNotContainsOnly(string $type, Iterator|array $haystack[, boolean $isNativeType
    = null, string $message = ''''])`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotContainsOnly(string $type, Iterator|array $haystack[, boolean $isNativeType
    = null, string $message = ''''])`'
- en: '`assertContainsOnlyInstancesOf(string $classname, Traversable|array $haystack[,
    string $message = ''''])`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertContainsOnlyInstancesOf(string $classname, Traversable|array $haystack[,
    string $message = ''''])`'
- en: assertDirectory() and assertFile()
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertDirectory()和assertFile()
- en: 'PHPUnit not only allows you to test the logic of your application, but you
    can even test the existence and permissions of folders and files. All this can
    be achieved with the following assertions:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit不仅允许您测试应用程序的逻辑，还可以测试文件夹和文件的存在和权限。所有这些都可以通过以下断言实现：
- en: '`assertDirectoryExists(string $directory[, string $message = ''''])`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertDirectoryExists(string $directory[, string $message = ''''])`'
- en: '`assertDirectoryNotExists(string $directory[, string $message = ''''])`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertDirectoryNotExists(string $directory[, string $message = ''''])`'
- en: '`assertDirectoryIsReadable(string $directory[, string $message = ''''])`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertDirectoryIsReadable(string $directory[, string $message = ''''])`'
- en: '`assertDirectoryNotIsReadable(string $directory[, string $message = ''''])`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertDirectoryNotIsReadable(string $directory[, string $message = ''''])`'
- en: '`assertDirectoryIsWritable(string $directory[, string $message = ''''])`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertDirectoryIsWritable(string $directory[, string $message = ''''])`'
- en: '`assertDirectoryNotIsWritable(string $directory[, string $message = ''''])`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertDirectoryNotIsWritable(string $directory[, string $message = ''''])`'
- en: '`assertFileEquals(string $expected, string $actual[, string $message = ''''])`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFileEquals(string $expected, string $actual[, string $message = ''''])`'
- en: '`assertFileNotEquals(string $expected, string $actual[, string $message = ''''])`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFileNotEquals(string $expected, string $actual[, string $message = ''''])`'
- en: '`assertFileExists(string $filename[, string $message = ''''])`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFileExists(string $filename[, string $message = ''''])`'
- en: '`assertFileNotExists(string $filename[, string $message = ''''])`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFileNotExists(string $filename[, string $message = ''''])`'
- en: '`assertFileIsReadable(string $filename[, string $message = ''''])`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFileIsReadable(string $filename[, string $message = ''''])`'
- en: '`assertFileNotIsReadable(string $filename[, string $message = ''''])`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFileNotIsReadable(string $filename[, string $message = ''''])`'
- en: '`assertFileIsWritable(string $filename[, string $message = ''''])`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFileIsWritable(string $filename[, string $message = ''''])`'
- en: '`assertFileNotIsWritable(string $filename[, string $message = ''''])`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFileNotIsWritable(string $filename[, string $message = ''''])`'
- en: '`assertStringMatchesFormatFile(string $formatFile, string $string[, string
    $message = ''''])`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertStringMatchesFormatFile(string $formatFile, string $string[, string
    $message = ''''])`'
- en: '`assertStringNotMatchesFormatFile(string $formatFile, string $string[, string
    $message = ''''])`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertStringNotMatchesFormatFile(string $formatFile, string $string[, string
    $message = ''''])`'
- en: Does your application rely on a writable file in order to work? Don't worry,
    PHPUnit has your back. You can add an `assertFileIsWritable()` to your tests so
    that the next time somebody removes the file you have specified in the assertion,
    the test will fail.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序是否依赖于可写文件才能工作？别担心，PHPUnit会帮你解决。您可以在测试中添加`assertFileIsWritable()`，这样下次有人删除您在断言中指定的文件时，测试将失败。
- en: assertString()
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertString()
- en: 'In some cases, you need to check the content of some strings. For instance,
    if your code generates serial codes, you can check whether the codes you generate
    match your specifications. You can use the following assertions with strings:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您需要检查一些字符串的内容。例如，如果您的代码生成序列码，您可以检查生成的代码是否符合您的规格。您可以使用以下断言来处理字符串：
- en: '`assertStringStartsWith(string $prefix, string $string[, string $message =
    ''''])`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertStringStartsWith(string $prefix, string $string[, string $message =
    ''''])`'
- en: '`assertStringStartsNotWith(string $prefix, string $string[, string $message
    = ''''])`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertStringStartsNotWith(string $prefix, string $string[, string $message
    = ''''])`'
- en: '`assertStringMatchesFormat(string $format, string $string[, string $message
    = ''''])`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertStringMatchesFormat(string $format, string $string[, string $message
    = ''''])`'
- en: '`assertStringNotMatchesFormat(string $format, string $string[, string $message
    = ''''])`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertStringNotMatchesFormat(string $format, string $string[, string $message
    = ''''])`'
- en: '`assertStringEndsWith(string $suffix, string $string[, string $message = ''''])`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertStringEndsWith(string $suffix, string $string[, string $message = ''''])`'
- en: '`assertStringEndsNotWith(string $suffix, string $string[, string $message =
    ''''])`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertStringEndsNotWith(string $suffix, string $string[, string $message =
    ''''])`'
- en: assertRegExp()
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertRegExp()
- en: 'The `assertRegExp(string $pattern, string $string[, string $message = ''''])`
    assertion will be very useful for you as you have all the regex power in one assertion.
    Let''s add a static function to our Dummy class:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertRegExp(string $pattern, string $string[, string $message = ''''])`断言对您非常有用，因为您可以在一个断言中使用所有的正则表达式功能。让我们向我们的Dummy类添加一个静态函数：'
- en: '[PRE20]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This new function returns a static string code. Feel free to complicate the
    generation. To test this generated string code, you can now do something like
    this in your test class:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新函数返回一个静态字符串代码。随意增加生成的复杂性。要测试这个生成的字符串代码，您现在可以在测试类中做如下操作：
- en: '[PRE21]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we are using a simple regular expression to check the output
    generated by `getRandomCode`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们正在使用简单的正则表达式来检查`getRandomCode`生成的输出。
- en: assertJson()
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertJson()
- en: 'Working with microservices, you will probably be working very closely with
    JSON requests and responses. Therefore, it is very important that you have the
    ability to test our JSONs. You can have a JSON as a file or as a string:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用微服务时，您可能会与JSON请求和响应密切合作。因此，非常重要的是您有能力测试我们的JSON。您可以将JSON作为文件或字符串：
- en: '`assertJsonFileEqualsJsonFile()`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertJsonFileEqualsJsonFile()`'
- en: '`assertJsonStringEqualsJsonFile()`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertJsonStringEqualsJsonFile()`'
- en: '`assertJsonStringEqualsJsonString()`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertJsonStringEqualsJsonString()`'
- en: Boolean assertions
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔断言
- en: 'Boolean results or types can be checked with the following methods:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方法检查布尔结果或类型：
- en: '`assertTrue(bool $condition[, string $message = ''''])`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTrue(bool $condition[, string $message = ''''])`'
- en: '`assertFalse(bool $condition[, string $message = ''''])`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFalse(bool $condition[, string $message = ''''])`'
- en: Type assertions
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型断言
- en: 'Sometimes you need to ensure that an element is an instance of a specific class
    or has a specific internal type. You can use the following assertions in your
    tests:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要确保元素是特定类的实例或具有特定的内部类型。您可以在测试中使用以下断言：
- en: '`assertInstanceOf($expected, $actual[, $message = ''''])`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertInstanceOf($expected, $actual[, $message = ''''])`'
- en: '`assertInternalType($expected, $actual[, $message = ''''])`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertInternalType($expected, $actual[, $message = ''''])`'
- en: Other assertions
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他断言
- en: 'PHPUnit has a high number of assertions and your tests can''t be completed
    without some of the following assertions applied to results or object states of
    your features:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit具有大量的断言，如果没有以下一些断言应用于您的功能的结果或对象状态，您的测试将无法完成：
- en: '`assertCount($expectedCount, $haystack[, string $message = ''''])`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertCount($expectedCount, $haystack[, string $message = ''''])`'
- en: '`assertEmpty(mixed $actual[, string $message = ''''])`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEmpty(mixed $actual[, string $message = ''''])`'
- en: '`assertEquals(mixed $expected, mixed $actual[, string $message = ''''])`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEquals(mixed $expected, mixed $actual[, string $message = ''''])`'
- en: '`assertGreaterThan(mixed $expected, mixed $actual[, string $message = ''''])`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertGreaterThan(mixed $expected, mixed $actual[, string $message = ''''])`'
- en: '`assertGreaterThanOrEqual(mixed $expected, mixed $actual[, string $message
    = ''''])`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertGreaterThanOrEqual(mixed $expected, mixed $actual[, string $message
    = ''''])`'
- en: '`assertInfinite(mixed $variable[, string $message = ''''])`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertInfinite(mixed $variable[, string $message = ''''])`'
- en: '`assertLessThan(mixed $expected, mixed $actual[, string $message = ''''])`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertLessThan(mixed $expected, mixed $actual[, string $message = ''''])`'
- en: '`assertLessThanOrEqual(mixed $expected, mixed $actual[, string $message = ''''])`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertLessThanOrEqual(mixed $expected, mixed $actual[, string $message = ''''])`'
- en: '`assertNan(mixed $variable[, string $message = ''''])`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNan(mixed $variable[, string $message = ''''])`'
- en: '`assertNull(mixed $variable[, string $message = ''''])`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNull(mixed $variable[, string $message = ''''])`'
- en: '`assertObjectHasAttribute(string $attributeName, object $object[, string $message
    = ''''])`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertObjectHasAttribute(string $attributeName, object $object[, string $message
    = ''''])`'
- en: '`assertSame(mixed $expected, mixed $actual[, string $message = ''''])`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertSame(mixed $expected, mixed $actual[, string $message = ''''])`'
- en: You can find more information about the assertions you can use on the PHPUnit
    website, that is, [https://phpunit.de/](https://phpunit.de/).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在PHPUnit网站上找到有关您可以在其中使用的断言的更多信息，即[https://phpunit.de/](https://phpunit.de/)。
- en: Unit testing from scratch
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从头开始的单元测试
- en: At this point, you probably feel more comfortable with unit testing and you
    want to start coding your app as soon as possible, so let's get started with testing!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能对单元测试感到更加舒适，并且希望尽快开始编写您的应用程序，因此让我们开始测试吧！
- en: Our microservices application uses geolocalization to find secrets and other
    players. This means that your location microservice will need a way to calculate
    the distance between two geospatial points. We will also need, given an origin
    point, to get a list of the closest stored points (they can be the closest users
    or secrets). As this is a core feature, you need to ensure that what we described
    is fully tested.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的微服务应用程序使用地理定位来查找秘密和其他玩家。这意味着您的位置微服务将需要一种方法来计算两个地理空间点之间的距离。我们还需要根据起始点获取最接近的存储点的列表（它们可以是最接近的用户或秘密）。由于这是一个核心功能，您需要确保我们描述的内容经过充分测试。
- en: 'In our app, the localization has its own service. Therefore, open the source
    code of the location microservice with your IDE and create the `app/Http/Controllers/LocationController.php`
    file with the following content:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，定位有自己的服务。因此，使用您的IDE打开位置微服务的源代码，并创建`app/Http/Controllers/LocationController.php`文件，内容如下：
- en: '[PRE22]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code has created our location controller in Lumen and, as we mentioned
    before, as soon as we have this class created, we need to create a similar class
    for our unit tests. In order to do this, you only need to create the `tests/app/Http/Controllers/LocationControllerTest.php`
    file. As you can see, we are even replicating the folder structure; this is the
    best approach to easily know which class we are testing for.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码已在Lumen中创建了我们的位置控制器，并且正如我们之前提到的，一旦我们创建了这个类，我们需要为我们的单元测试创建一个类似的类。为了做到这一点，您只需要创建`tests/app/Http/Controllers/LocationControllerTest.php`文件。正如您所看到的，我们甚至在复制文件夹结构；这是最好的方法，可以轻松知道我们正在为哪个类进行测试。
- en: 'We want to start creating tests for the distance calculation and for the function that
    allows us to get the closest secrets given a specific geolocation point. One approach
    is to create two different tests. Therefore, fill your `LocationControllerTest.php`
    with the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望开始为距离计算和允许我们根据特定地理位置点获取最接近的秘密的功能创建测试。一种方法是创建两个不同的测试。因此，请使用以下代码填充您的`LocationControllerTest.php`：
- en: '[PRE23]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We didn't add anything special to our test class, we only declared two tests.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有向我们的测试类添加任何特殊内容，我们只声明了两个测试。
- en: 'Let''s start with `testDistance()`. In this test, we want to ensure that given
    two geospatial points, the calculated distance between them is accurate enough
    for our purposes. In unit testing, you need to start describing the known scenario--as
    points, we have chosen London (latitude: `51.50`, longitude: `-0.13`) and Amsterdam
    (latitude: `52.37`, longitude: `4.90`). The known distance between these two cities
    is around 358.06 km, and this is the result we aim to get from our distance calculator.
    Let''s fill our test with the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`testDistance()`开始。在这个测试中，我们希望确保给定两个地理空间点之间的计算距离对我们的目的来说足够准确。在单元测试中，你需要开始描述已知的场景——作为点，我们选择了伦敦（纬度：`51.50`，经度：`-0.13`）和阿姆斯特丹（纬度：`52.37`，经度：`4.90`）。这两个城市之间的已知距离大约为358.06公里，这是我们希望从我们的距离计算器中得到的结果。让我们用以下代码填充我们的测试：
- en: '[PRE24]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding piece of code, we defined the known scenario, the location
    of our two points and the distance known between them. Once we had our known scenario
    ready, we created an instance of our `LocationController` and we used the defined
    `getDistance` function to obtain a result we want to test. As soon as we got the
    result, we tested that our `LocationController` had a `conversionRate` static
    attribute that we can use to transform the distance to different units. Our last
    and most important assertion checks the match between the calculated distance
    and the known distance between these two points. We have our basic test ready,
    and it is time to start coding our `getDistance` function.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们定义了已知的场景，我们两点的位置和它们之间的已知距离。一旦我们准备好了已知的场景，我们创建了一个`LocationController`的实例，并使用定义的`getDistance`函数来获得我们想要测试的结果。一旦我们得到了结果，我们测试我们的`LocationController`是否有一个`conversionRate`静态属性，我们可以用它来将距离转换为不同的单位。我们最后并且最重要的断言检查了计算出的距离与这两点之间的已知距离之间的匹配。我们已经准备好了基本的测试，现在是时候开始编写我们的`getDistance`函数了。
- en: The distance calculation between two geospatial points can be calculated in
    very different ways. You can use a strategy pattern here, but to keep the example
    simple we will code the different calculation algorithms in different functions
    inside our controller.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 两个地理空间点之间的距离计算可以用非常不同的方式计算。你可以在这里使用策略模式，但为了保持示例简单，我们将在控制器内的不同函数中编写不同的计算算法。
- en: 'Open your `LocationController` and add some auxiliary code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`LocationController`并添加一些辅助代码：
- en: '[PRE25]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we have defined our conversion rates, a constant we can
    use to round our results, and a simple conversion function. We will use this `convertDistance`
    function later.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们定义了我们的转换率、一个我们可以用来四舍五入结果的常量，以及一个简单的转换函数。我们将稍后使用这个`convertDistance`函数。
- en: 'Our first approach for distance calculation is to use the Euclidean function
    to get our result. A simple implementation is described in the following code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算距离的第一个方法是使用欧几里得函数来得到我们的结果。一个简单的实现如下所示：
- en: '[PRE26]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have our algorithm ready, we can add it to our `getDistance` function,
    as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的算法准备好了，我们可以将其添加到我们的`getDistance`函数中，如下所示：
- en: '[PRE27]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At this point, you have everything in place and you can start the tests. Enter
    the location container and run PHPUnit in `/var/www/html`. This is our first approach;
    the PHPUnit result will be a fail, and the output of this application will tell
    you where the problem is. In our case, the main reason for the fail is that the
    algorithm we used is not accurate enough for our application. We can't deploy
    this version of our application because it has failed tests and we have to change
    our test or the code that implements our tests.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你已经准备好了一切，可以开始测试了。进入位置容器，在`/var/www/html`中运行PHPUnit。这是我们的第一次尝试；PHPUnit的结果将是失败，应用程序的输出将告诉你问题所在。在我们的情况下，失败的主要原因是我们使用的算法对我们的应用程序来说不够准确。我们不能部署这个版本的应用程序，因为它未通过测试，我们必须更改我们的测试或实现测试的代码。
- en: As we mentioned before, there are multiple ways of calculating the distance
    between two points and each one can be more or less accurate. The first implementation
    we tried failed because it is used for plains and our world is a sphere.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，有多种计算两点之间距离的方法，每种方法都可能更或者更少准确。我们尝试的第一个实现失败了，因为它用于平面，而我们的世界是一个球体。
- en: 'Open your `LocationController` again and create a new distance implementation
    using a haversine calculation:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开你的`LocationController`，并使用haversine计算创建一个新的距离实现：
- en: '[PRE28]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, this distance calculation function is a little more complex
    and considers the spherical form of our world. Change the `getDistance` function
    to use our new algorithm:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个距离计算函数稍微复杂一些，考虑了我们世界的球形形式。更改`getDistance`函数以使用我们的新算法：
- en: '[PRE29]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now run PHPUnit again and everything should be okay; the test will pass and
    our code is ready for production.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行PHPUnit，一切应该没问题；测试将通过，我们的代码已经准备好投入生产。
- en: 'With unit testing and TDD, the process is always the same:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单元测试和TDD，流程总是一样的：
- en: Create the tests.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建测试。
- en: Make your code to pass the tests.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让你的代码通过测试。
- en: Run the tests and if they fail, start again from step 2.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试，如果测试失败，从第2步重新开始。
- en: 'Another feature we want to have in our location microservice is to get the
    closest secrets we have near our current position. Open the `LocationControllerTest`
    file and add the following code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在我们的位置微服务中拥有的另一个功能是获取我们当前位置附近最近的秘密。打开`LocationControllerTest`文件并添加以下代码：
- en: '[PRE30]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding piece of code, we defined our current location (New York) and
    asked our implementation to give us a list of the closest secrets. Our location
    implementation will have a cache list of secrets, and we know where they are located
    (this will help us to know the correct order).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们定义了我们的当前位置（纽约），并要求我们的实现给我们一个最近秘密的列表。我们的位置实现将有一个秘密的缓存列表，我们知道它们的位置（这将帮助我们知道正确的顺序）。
- en: 'Open the `LocationController.php` and first add a cache list of secrets. In the
    real world, we don''t have hardcoded values, but it''s good enough for testing
    purposes:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`LocationController.php`，首先添加一个秘密的缓存列表。在现实世界中，我们没有硬编码的值，但对于测试目的来说，这已经足够了：
- en: '[PRE31]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once we have our list of secrets ready, we can add our `getClosestSecrets`
    function as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好秘密列表，我们可以添加我们的`getClosestSecrets`函数如下：
- en: '[PRE32]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code, we used our cache list of secrets to calculate the distance between
    the origin point and each of our secret points. As soon as we had the distance,
    we sorted the result and returned the closest three.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用我们的缓存秘密列表来计算原点与我们每个秘密点之间的距离。一旦我们有了距离，我们就对结果进行排序并返回最接近的三个。
- en: Running PHPUnit in our location container will show us that all the tests are
    being passed, giving us the confidence to deploy our code to production.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的位置容器中运行PHPUnit将显示所有测试都已通过，这让我们有信心将代码部署到生产环境。
- en: Future commits can make changes to the distance calculation or to the closest
    function, and they can break our tests. Luckily for you, there is a unit testing
    covering them and PHPUnit will throw an alert, so you can start rethinking your
    code implementation.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的提交可能会对距离计算或最接近功能进行更改，并且可能会破坏我们的测试。幸运的是，有一个单元测试覆盖它们，PHPUnit会发出警报，因此您可以开始重新思考代码实现。
- en: Let your imagination fly and test everything--from the simple and small case
    to any odd and obscure case you can imagine. The idea is that your application will
    break and break very badly, in the middle of the night or during your holidays.
    There is nothing you can do about this except adding as many tests as you can
    so that you can ensure that the release you have in production is stable enough
    to reduce the risks of breaking.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让您的想象力飞翔，并测试一切--从简单和小的情况到您能想象到的任何奇怪和模糊的情况。想法是您的应用程序将会崩溃，并且会非常严重，在半夜或者在您度假期间。除了尽可能添加尽可能多的测试以确保您在生产中的发布足够稳定以减少破坏风险之外，您无能为力。
- en: Behat
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Behat
- en: Behat is an open source behavior-driven development framework. All the Behat
    tests are written in plain English and wrapped into readable scenarios. This framework
    uses the Gherkin syntax and was inspired by Cucumber, a Ruby tool. The main advantage
    of Behat is that most of the test scenarios can be understood by anyone.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Behat是一个开源的行为驱动开发框架。所有Behat测试都是用简单的英语编写，并包装成可读的场景。该框架使用Gherkin语法，受到了Ruby工具Cucumber的启发。Behat的主要优势在于，大多数测试场景都可以被任何人理解。
- en: Installation
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: 'Behat can be easily installed using Composer. You only need to edit the `composer.json`
    of each microservice and drop a new line with `"behat/behat" : "3.*"`. Your `require-dev`
    definition will be as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '使用Composer可以轻松安装Behat。您只需要编辑每个微服务的`composer.json`，并添加一行新的`"behat/behat" : "3.*"`。您的`require-dev`定义将如下所示：'
- en: '[PRE33]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once you have updated the `dev` requirements, you need to enter each of your
    PHP-FPM containers and run Composer:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您更新了`dev`要求，您需要进入每个PHP-FPM容器并运行Composer：
- en: '[PRE34]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Test execution
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试执行
- en: 'Running Behat is as easy as running PHPUnit. You only need to enter your PHP-FPM
    container, go to the `/var/www/html` folder, and run the following command:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Behat就像运行PHPUnit一样简单。您只需要进入PHP-FPM容器，转到`/var/www/html`文件夹，并运行以下命令：
- en: '[PRE35]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Behat example from scratch
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从头开始的Behat示例
- en: 'One of the key features of our microservices application is the ability to
    find secrets. Users should be able to save the secrets and, for this, they need
    a wallet. So, let''s write our user-story in our user microservice:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们微服务应用程序的关键功能之一是查找秘密。用户应该能够保存这些秘密，为此，他们需要一个钱包。因此，让我们在用户微服务中编写我们的用户故事：
- en: '[PRE36]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see, the test can be understood by anyone in the project--from the
    developers to the stakeholders. Each test scenario always has the same format:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，该测试可以被项目中的任何人理解，从开发人员到利益相关者。每个测试场景总是具有相同的格式：
- en: '[PRE37]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can add some modifiers to the preceding basic template (and or but) to empower
    the scenario description. At this point, with your scenario ready, you can save
    it as a `features/wallet.feature` file.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向上述基本模板添加一些修饰词（and或but）以增强场景描述。在这一点上，您的场景准备就绪后，可以将其保存为`features/wallet.feature`文件。
- en: 'The first time you start writing a Behat test on your project, you need to
    initialize the suite with the following command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次在项目中开始编写Behat测试时，您需要使用以下命令初始化套件：
- en: '[PRE38]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding command will create the files needed by Behat to run the scenario
    tests. The main file we will use is `features/bootstrap/FeatureContext.php`; this
    file will be our test environment.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将创建Behat运行场景测试所需的文件。我们将使用的主要文件是`features/bootstrap/FeatureContext.php`；这个文件将成为我们的测试环境。
- en: 'Once we have our `FeatureContext` file in place, it is time to start creating
    our scenario steps. For example, place the following method in your `FeatureContext`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的`FeatureContext`文件就位，就该开始创建我们的场景步骤了。例如，将以下方法放入您的`FeatureContext`中：
- en: '[PRE39]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Behat uses doc-blocks for step definitions, step transformations, and hooks.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Behat使用文档块来定义步骤、步骤转换和钩子。
- en: 'In the preceding piece of code, we are telling Behat that the `thereIsA()`
    function matches each `Given there is a(n)` step. In our example, that definition
    will match the steps in the following cases:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们告诉Behat，`thereIsA()`函数匹配每个`Given there is a(n)`步骤。在我们的示例中，该定义将匹配以下情况中的步骤：
- en: Given that there is an amber
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设有一块琥珀
- en: There is a diamond
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一颗钻石
- en: 'We need to map each of our scenario steps so that our `FeatureContext` will
    end up as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要映射每个场景步骤，以便我们的`FeatureContext`最终如下：
- en: '[PRE40]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our tests use external classes that we need to define. These classes implement
    our logic and, for example, purposefully create the `features/bootstrap/SecretsCache.php`
    with the following content:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试使用需要定义的外部类。这些类实现了我们的逻辑，并且例如故意创建了`features/bootstrap/SecretsCache.php`，其中包含以下内容：
- en: '[PRE41]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You also need to create `features/bootstrap/Wallet.php` with the following
    sample code:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要创建`features/bootstrap/Wallet.php`，其中包含以下示例代码：
- en: '[PRE42]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding two classes are the implementation of our tests and, as you can
    see, they have the logic of storing secrets in a wallet. Now, if you run `vendor/bin/behat`
    on your console, the tool will check all our test scenarios and give us confidence
    that our code will behave the way we want it to.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个类是我们测试的实现，正如你所看到的，它们具有在钱包中存储秘密的逻辑。现在，如果你在控制台上运行 `vendor/bin/behat`，这个工具将检查所有我们的测试场景，并让我们确信我们的代码将按我们想要的方式运行。
- en: This was a simple example of testing an application with Behat. In our GitHub
    repository, you can find more specific examples. Also, feel free to explore the
    Behat ecosystem; you can find multiple tools and extensions that can help you
    test your application.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Behat测试应用程序的一个简单示例。在我们的GitHub存储库中，你可以找到更具体的示例。另外，随时探索Behat生态系统；你可以找到多个工具和扩展，可以帮助你测试你的应用程序。
- en: Selenium
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium
- en: Selenium is a suite of tools to automate web browsers across many platforms
    and can be used as a browser extension, or it can be installed on a server to
    run our browser tests. The main advantage of Selenium is that you can easily record
    a full user journey and create a test from the record. This test can be later
    added to your pipeline to be executed on each commit to discover regressions.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium是一套用于自动化多平台上的Web浏览器的工具，并且可以作为浏览器扩展使用，或者可以安装在服务器上来运行我们的浏览器测试。Selenium的主要优势在于你可以轻松地记录完整的用户旅程并从记录中创建测试。这个测试可以稍后添加到你的流水线中，以便在每次提交时执行，以发现回归。
- en: Selenium WebDriver
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Selenium WebDriver
- en: The WebDriver is the API that you can use to run your browser testing from other
    tools. It is a powerful testing environment normally placed in a dedicated server
    where it sits waiting to run browser tests.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriver是你可以用来从其他工具运行浏览器测试的API。它是一个强大的测试环境，通常放置在专用服务器上，等待运行浏览器测试。
- en: Selenium IDE
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Selenium IDE
- en: The Selenium IDE is a Firefox extension that allows you to record, edit, and
    debug browser tests. This plugin is not only a recording tool, but a full IDE
    with autocomplete functionalities. You can even record and create tests with the
    IDE and later run them with the WebDriver.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium IDE是一个Firefox扩展，允许你记录、编辑和调试浏览器测试。这个插件不仅是一个录制工具，还是一个带有自动完成功能的完整IDE。你甚至可以使用IDE记录和创建测试，然后用WebDriver稍后运行它们。
- en: Most of the time, Selenium is used as a complimentary testing tool executed
    from another testing framework. For instance, you can improve your Behat tests
    with Selenium thanks to the Mink project ([http://mink.behat.org/en/latest/](http://mink.behat.org/en/latest/)).
    This project is a wrapper for different browser drivers, so you can use them in
    your BDD workflow.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，Selenium被用作补充测试工具，从另一个测试框架执行。例如，你可以通过Mink项目（[http://mink.behat.org/en/latest/](http://mink.behat.org/en/latest/)）来改进你的Behat测试。这个项目是不同浏览器驱动程序的包装器，所以你可以在BDD工作流中使用它们。
- en: We will talk about the deployment of our application in [Chapter 7](ch07.html
    "Chapter 7. Security"), *Security*. We will learn how to automate all these tests
    and integrate them in our CI/CD workflow.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](ch07.html "Chapter 7. Security") *Security*中讨论我们应用程序的部署。我们将学习如何自动化所有这些测试，并将它们集成到我们的CI/CD工作流中。
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you studied the importance of using tests on your application,
    tools such as Behat and Selenium, and also about implementing driven development.
    In the next chapter, you will study error handling, dependency management, and
    the microservices framework.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了在应用程序中使用测试的重要性，诸如Behat和Selenium之类的工具，以及关于实现驱动开发。在下一章中，你将学习错误处理、依赖管理和微服务框架。

- en: Chapter 6. Monitoring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 监控
- en: In the last chapter, we spent some time developing our example application.
    Now it is time to start with more advanced topics. In this chapter, we will show
    you how to monitor your microservices application. Keeping a track of everything
    that is happening in your application will help you know the overall performance
    at any time, and you can even find issues and bottlenecks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们花了一些时间开发我们的示例应用程序。现在是时候开始更高级的主题了。在本章中，我们将向您展示如何监视您的微服务应用程序。跟踪应用程序中发生的一切将帮助您随时了解整体性能，甚至可以找到问题和瓶颈。
- en: Debugging and profiling
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和性能分析
- en: Debugging and profiling is very necessary in the development of a complex and
    large application, so let’s explain what they are and how we can take advantage
    of these kinds of tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发复杂和大型应用程序时，调试和性能分析是非常必要的，因此让我们解释一下它们是什么，以及我们如何利用这些工具。
- en: What is debugging?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是调试？
- en: Debugging is the process of identifying and fixing errors in programming. It
    is mainly a manual task in which developers need to use their imagination, intuition,
    and have a lot of patience.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是识别和修复编程错误的过程。这主要是一个手动任务，开发人员需要运用他们的想象力、直觉，并且需要有很多耐心。
- en: Most of the time, it is necessary to include new instructions in the code to
    read the value of variables at a concrete point of execution or code to stop the
    execution in order to know whether it is passing through a function.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，需要在代码中包含新的指令，以在执行的具体点或代码中读取变量的值，或者停止执行以了解它是否通过函数。
- en: However, this process can be managed by the debugger. This is a tool or application
    that allows us to control the execution of our application in order to follow
    each executed instruction and find the bugs or errors, avoiding having to add
    code instructions in our code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个过程可以由调试器来管理。这是一个工具或应用程序，允许我们控制应用程序的执行，以便跟踪每个执行的指令并找到错误，避免必须在我们的代码中添加代码指令。
- en: The debugger uses an instruction called breakpoint. A **breakpoint** is, as
    its name suggests, a point at which the application stops in order to be driven
    by the developer to decide what to do. At that point, the debugger gives different
    information about the current status of the application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器使用一个称为断点的指令。**断点**就像它的名字所暗示的那样，是应用程序停止的一个点，以便由开发人员决定要做什么。在那一点上，调试器会提供有关应用程序当前状态的不同信息。
- en: We will see more about the debugger and breakpoint later on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将更多地了解调试器和断点。
- en: What is profiling?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是性能分析？
- en: Like debugging, profiling is a process to identify if our application is working
    properly in terms of performance. Profiling investigates the application’s behavior
    in order to know the dedicated time to execute different parts of code to find
    bottlenecks or optimize them in terms of speed or consumed resources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 像调试一样，性能分析是一个过程，用于确定我们的应用在性能方面是否正常工作。性能分析调查应用程序的行为，以了解执行不同代码部分所需的专用时间，以找到瓶颈或在速度或消耗资源方面进行优化。
- en: Profiling is usually used during the development process as part of debugging,
    and it is necessary to measure it in proper environments by specialists to get
    real data from it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析通常在开发过程中作为调试的一部分使用，并且需要由专家在适当的环境中进行测量，以获得真实的数据。
- en: 'There are four different kinds of profilers: based on events, statistics, tools
    to support code, and simulation.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种不同类型的性能分析器：基于事件的、统计的、支持代码的工具和模拟的。
- en: Debugging and profiling in PHP with Xdebug
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Xdebug在PHP中进行调试和性能分析
- en: Now we will install and set up Xdebug in our project. This must be installed
    on our IDE, so depending on which one you use, this process will be different,
    but the steps to follow are quite similar. In our case, we will install it on PHPStorm.
    Even if you use a different IDE, after installing Xdebug, the workflow for debugging
    your code in any IDE will largely be the same.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在我们的项目中安装和设置Xdebug。这必须安装在我们的IDE上，因此取决于您使用的是哪个，此过程将有所不同，但要遵循的步骤相当相似。在我们的情况下，我们将在PHPStorm上安装它。即使您使用不同的IDE，在安装Xdebug之后，在任何IDE中调试代码的工作流程基本上是相同的。
- en: Debugging installation
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试安装
- en: 'To install Xdebug on our Docker, we should modify the proper `Dockerfile` file.
    We will install it on the user microservices, so open the `docker/microservices/user/php-fpm/Dockerfile`
    file and add the following highlighted lines:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Docker上安装Xdebug，我们应该修改适当的`Dockerfile`文件。我们将在用户微服务上安装它，所以打开`docker/microservices/user/php-fpm/Dockerfile`文件，并添加以下突出显示的行：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first highlighted block is necessary to `install xdebug`. The `&& pecl install
    xdebug` line is used to install Xdebug using PECL, and the rest of the lines set
    the parameters on the `xdebug.ini` file. The second one is to copy the `php.ini` file
    from our local machine to Docker.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个突出显示的块是`安装xdebug`所必需的。`&& pecl install xdebug`行用于使用PECL安装Xdebug，其余行设置了`xdebug.ini`文件上的参数。第二个是将`php.ini`文件从我们的本地机器复制到Docker。
- en: 'It is also necessary to set some values on the `php.ini` file, so open it,
    it is located on `docker/microservices/user/php-fpm/config/php.ini`, and add the
    following lines:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要在`php.ini`文件上设置一些值，因此打开它，它位于`docker/microservices/user/php-fpm/config/php.ini`，并添加以下行：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should enter your local IP address instead of `YOUR_LOCAL_IP_ADDRESS` in
    order to be visible in Docker, so Xdebug will be able to read our code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该输入您的本地IP地址，而不是`YOUR_LOCAL_IP_ADDRESS`，以便在Docker中可见，因此Xdebug将能够读取我们的代码。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Your local IP address is your IP inside your network, not the public one.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您的本地IP地址是您网络内部的IP，而不是公共IP。
- en: 'Now, you can make the build in order to install everything necessary to debug
    by executing the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过执行以下命令进行构建，以安装调试所需的一切：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This can take a few minutes. Xdebug will be installed once this is finished.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要几分钟。一旦完成，Xdebug将被安装。
- en: Debugging setup
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试设置
- en: Now it is time to set up Xdebug on our favorite IDE. As we said before, we will use
    PHPStorm, but feel free to use any other IDE.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在我们喜爱的IDE上设置Xdebug了。正如我们之前所说，我们将使用PHPStorm，但是请随意使用任何其他IDE。
- en: We have to create a server on the IDE, in PHPStorm this is done by navigating to **Preferences** |
    **Languages & Frameworks** | **PHP**. So, add a new one and set the `name` to
    `users`, for example, `host` to `localhost`, `port` to `8084`, and `debugger` to `xdebug`.
    It is also necessary to enable **Use path mappings** in order to map our routes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在 IDE 上创建一个服务器，在 PHPStorm 中，可以通过导航到**首选项** | **语言和框架** | **PHP**来完成。因此，添加一个新的，并将`name`设置为`users`，例如，`host`设置为`localhost`，`port`设置为`8084`，`debugger`设置为`xdebug`。还需要启用**使用路径映射**以便映射我们的路由。
- en: Now, we need to navigate to **Tools** | **DBGp proxy- configuration** and ensure
    that the IDE key field is set to `PHPSTORM`, `Host` to `users` (this name must
    be the same one you entered on the servers section), and `Port` to `9000`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要导航到**工具** | **DBGp代理配置**，确保 IDE 密钥字段设置为`PHPSTORM`，`Host`设置为`users`（这个名称必须与你在服务器部分输入的名称相同），`Port`设置为`9000`。
- en: 'Stop and start Docker by executing the following commands:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令停止和启动 Docker：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Set PHPStorm to be able to listen to the debugger:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 PHPStorm 能够像调试器一样监听：
- en: '![Debugging setup](graphics/B06142_06_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![调试设置](graphics/B06142_06_01.jpg)'
- en: Xdebug button to listen to connections in PHPStorm
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: PHPStorm 中监听连接的 Xdebug 按钮
- en: Debugging the output
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试输出
- en: 'Now you are ready to view the debugger results. You just have to set the breakpoints
    in your code and the execution will stop at that point, giving you all the data
    values. To do this, go to your code, for example, on the `UserController.php`
    file, and click on the left side of a line. It will create a red point; this is
    a breakpoint:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好查看调试器的结果。你只需要在你的代码中设置断点，执行将在那一点停止，给你所有的数据值。要做到这一点，转到你的代码，例如，在`UserController.php`文件中，并点击一行的左侧。它会创建一个红点；这是一个断点：
- en: '![Debugging the output](graphics/B06142_06_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![调试输出](graphics/B06142_06_02.jpg)'
- en: Breakpoint in PHPStorm
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHPStorm 中设置断点
- en: 'Now, you have the breakpoint set and the debugger running, so it is time to
    make a call with Postman to try the debugger. Give the breakpoint a try by executing
    a POST call to `http://localhost:8084/api/v1/user` with the `api_key = RSAy430_a3eGR and XDEBUG_SESSION_START
    = PHPSTORM` parameters. The execution will stop at the breakpoint and, from there,
    you have the execution control:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经设置了断点并且调试器正在运行，所以现在是时候用 Postman 发起一个调用来尝试调试器了。通过执行一个 POST 调用到`http://localhost:8084/api/v1/user`，参数为`api_key
    = RSAy430_a3eGR 和 XDEBUG_SESSION_START = PHPSTORM`。执行将在断点处停止，从那里开始你就有了执行控制：
- en: '![Debugging the output](graphics/B06142_06_03-1.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![调试输出](graphics/B06142_06_03-1.jpg)'
- en: Debugger console in PHPStorm
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: PHPStorm 中的调试器控制台
- en: Note that you have all the current values for the parameters on the variables
    side. In this case, you can see the `test` parameter set to `"this is a test"`;
    we assigned this value two lines before the breakpoint.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你在变量侧的所有参数的当前值。在这种情况下，你可以看到`test`参数设置为`"this is a test"`；我们在断点之前的两行分配了这个值。
- en: 'As we said, now we have control of the execution; the three basic functions
    are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，现在我们控制了执行；三个基本功能如下：
- en: '**Step over:** This continues the execution with the following line.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步过：** 这将继续执行下一行。'
- en: '**Step into:** This continues the execution inside a function.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步入：** 这将在函数内部继续执行。'
- en: '**Step out:** This continues the execution outside a function.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步出：** 这将在函数外部继续执行。'
- en: All these basic functions are executed step by step, so it will stop in the
    next line, it does not need any other breakpoints.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些基本功能都是逐步执行的，所以它将在下一行停止，不需要任何其他断点。
- en: As you can see, this is very useful to find errors in your code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这对于找到代码中的错误非常有用。
- en: Profiling installation
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能分析安装
- en: 'Once we have Xdebug installed, we just need to add the following lines on the
    `docker/microservices/user/php-fpm/Dockerfile` file to enable the profiling:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了 Xdebug，我们只需要在`docker/microservices/user/php-fpm/Dockerfile`文件中添加以下行以启用性能分析：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With `profiler_enable`, we enable the profiler and the output directory is set
    by `profiler_output_dir`. This directory should exist on our user microservice
    in order to get the profiler output files. So, if it is not yet created, do it
    now on `/source/user/tmp`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`profiler_enable`，我们启用了性能分析器，并且输出目录由`profiler_output_dir`设置。这个目录应该存在于我们的用户微服务中，以便获取性能分析器输出文件。因此，如果还没有创建，请在`/source/user/tmp`上创建。
- en: 'Now, you can make the build in order to install everything necessary to debug
    by executing the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过执行以下命令进行构建，以安装调试所需的一切：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This can take a few minutes. Xdebug will be installed once this is finished.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要几分钟。一旦完成，Xdebug 就会被安装。
- en: Profiling setup
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能分析设置
- en: 'It does not need to be set up, so just stop and start Docker by executing the
    following commands:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 它不需要设置，所以只需通过执行以下命令停止和启动 Docker：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Set PHPStorm to be able to listen to the debugger as we did with the debugger.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 PHPStorm 能够像调试器一样监听。
- en: Analyzing the output file
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析输出文件
- en: To generate the profiling file, we need to execute a call as we did before with
    Postman, so feel free to execute the method you want. It will generate a file
    located on the folder we made before with name `cachegrind.out.XX`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成性能分析文件，我们需要执行一个调用，就像之前在 Postman 中做的那样，所以随时执行你想要的方法。它将在我们之前创建的文件夹中生成一个名为`cachegrind.out.XX`的文件。
- en: If you open this file, you will note that it is difficult to understand, but
    there are some tools to read this type of content. PHPStorm has a tool located
    on **Tools** |  ****Analyze** Xdebug Profiler Snapshot**. Once you open it, you
    can select the file to analyze and then the tool will show you a detailed analysis
    of all the files and functions executed in the call. Displaying the time spent,
    times called, and other interesting things are very useful to optimize your code
    and find bottlenecks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开这个文件，你会注意到它很难理解，但有一些工具可以读取这种类型的内容。PHPStorm 有一个工具位于**工具** | **分析** Xdebug
    Profiler Snapshot**。一旦打开它，你可以选择要分析的文件，然后工具将向你展示所有文件和函数在调用中执行的详细分析。显示花费的时间，调用的次数，以及其他有趣的东西非常有用，可以优化你的代码并找到瓶颈。
- en: Error handling
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: Error handling is the way we manage the errors and exceptions in our application.
    This is very important in order to have all the possible errors that can happen
    in our development detected and organized.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是我们管理应用程序中的错误和异常的方式。这对于检测和组织开发中可能发生的所有可能的错误非常重要。
- en: What is error handling?
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是错误处理？
- en: The term *error handling* is used in development to refer to the process of
    responding to the occurrence of an exception during the execution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*错误处理*在开发中用于指代在执行过程中响应异常发生的过程。
- en: Usually, the appearance of exceptions breaks the normal workflow of an application
    execution and executes a registered exception handler, giving us more information
    about what is happening and, sometimes, how we can avoid the exception.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，异常的出现会打断应用程序执行的正常工作流程，并执行注册的异常处理程序，为我们提供更多关于发生了什么以及有时如何避免异常的信息。
- en: The way that PHP handles the errors is very basic. A default error message is
    composed of the filename, line, and a little description about the error that
    the browser receives. In this chapter, we will see three different ways to handle
    errors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PHP处理错误的方式非常基础。默认的错误消息由文件名、行号和关于浏览器接收到的错误的简短描述组成。在本章中，我们将看到三种不同的处理错误的方式。
- en: Why is error handling important?
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么错误处理很重要？
- en: The majority of applications are very complex and large, and they are also developed
    by different people or even different teams if we are working on an application
    based on microservices as we are doing here. Can you imagine all the potential
    bugs that would appear in a project if we mix all these things? It is impossible
    to be aware of all the possible issues that an application can have or the users
    will find in it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序非常复杂和庞大，它们也是由不同的人甚至不同的团队开发的，如果我们正在开发基于微服务的应用程序，那么这些团队可能会更多。想象一下，如果我们混合所有这些东西，项目中可能出现的潜在错误有多少？要意识到应用程序可能存在的所有可能问题或用户可能在其中发现的问题是不可能的。
- en: 'So, error handling helps in the following two ways:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，错误处理以以下两种方式帮助：
- en: '**Users or consumers**: In microservices, error handling is very useful because
    it allows the consumers to know the possible problems that an API has and maybe
    they can figure out if it is a problem related to the introduced parameters in
    the API call, or the file size of an image. Also, in microservices, it is very
    useful to use different status codes for the errors in order to let the consumer
    know what is happening. You can find these codes in the [Chapter 11](ch11.html
    "Chapter 11. Best Practices and Conventions"), *Best Practices and Conventions*.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户或消费者**：在微服务中，错误处理非常有用，因为它允许消费者知道API可能存在的问题，也许他们可以弄清楚这是否与API调用中引入的参数有关，或者与图像文件大小有关。此外，在微服务中，使用不同的错误状态代码对于让消费者知道发生了什么是非常有用的。您可以在[第11章](ch11.html
    "第11章。最佳实践和约定")*最佳实践和约定*中找到这些代码。'
- en: 'On a commercial website, the error handling avoids showing strange messages
    like `PHP Fatal error: Cannot access empty property` to the users or customers.
    Instead of this, it can say something simple, such as `There is an error. Please
    contact us`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业网站上，错误处理可以避免向用户或客户显示诸如`PHP致命错误：无法访问空属性`之类的奇怪消息。而是可以简单地说`出现错误，请与我们联系`。
- en: '**Developers or yourself**: It allows the rest of the team and even yourself
    to be aware of any errors in your application, helping you to debug possible issues.
    There are many tools to get these kinds of bugs and send them to you by e-mail,
    written in a log file, or put on an event log, detailing the error tracking, function
    parameters, database calls, and more interesting things.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发人员或您自己**：它可以让团队的其他成员甚至您自己意识到应用程序中的任何错误，帮助您调试可能出现的问题。有许多工具可以获取这些类型的错误并通过电子邮件将它们发送给您，写入日志文件，或者放在事件日志中，详细说明错误跟踪、函数参数、数据库调用等更有趣的事情。'
- en: Challenges when managing error handling with microservices
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在微服务中管理错误处理时的挑战
- en: As mentioned earlier, we will explain three different ways to handle errors.
    When we are working with microservices, we have to monitor all the possible errors
    in order to let the microservices know what the problem is.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将解释三种不同的处理错误的方式。当我们使用微服务时，我们必须监视所有可能的错误，以便让微服务知道问题所在。
- en: Basic die() function
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本的die()函数
- en: 'In PHP, the basic way to handle errors is using the die() command. Let’s look
    at an example. Imagine that we want to open a file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，处理错误的基本方法是使用die()命令。让我们来看一个例子。假设我们想要打开一个文件：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the execution arrives at that point and tries to open the file called
    `test.txt`, if the file does not exist PHP will throw an error like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行到达那一点并尝试打开名为`test.txt`的文件时，如果文件不存在，PHP会抛出这样的错误：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To avoid the error message, we can use the `die()` function with the reason
    written in it so that the execution does not continue:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免错误消息，我们可以使用`die()`函数，并在其中写上原因，以便执行不会继续：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is just an example of the basic error handling on PHP. Obviously, there
    are better ways to manage this, but this is the minimum required to manage errors.
    In other words, avoiding the automatic error message from the PHP application
    is more efficient than stopping the execution manually and giving a human-language
    reason to the user.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是PHP中基本错误处理的一个例子。显然，有更好的方法来处理这个问题，但这是管理错误所需的最低限度。换句话说，避免PHP应用程序的自动错误消息比手动停止执行并向用户提供人类语言的原因更有效。
- en: Let’s look at an alternate way to manage this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个替代的管理方式。
- en: Custom error handling
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义错误处理
- en: Creating a system to manage the errors in your application is a better practice
    than using the `die()` function. Lumen provides us with this system and it is
    already configured when it is installed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个系统来管理应用程序中的错误比使用`die()`函数更好。Lumen为我们提供了这个系统，并且在安装时已经配置好了。
- en: We can configure it by setting other parameters. The first thing is the error
    detail. It is possible to get more information about the errors by setting it
    to `true`. To do this, it is necessary to add the `APP_DEBUG` value on your `.env`
    file and set it to `true`. This is the recommended way to work on the development
    environment so that the developers can know more about the issues of the application,
    but once the application is on the production server, this value should be set
    to `false` in order to avoid giving more information to the users.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置其他参数来配置它。首先是错误详情。通过将其设置为`true`，可以获取有关错误的更多信息。为此，需要在你的`.env`文件中添加`APP_DEBUG`值并将其设置为`true`。这是在开发环境中工作的推荐方式，这样开发人员可以更多地了解应用程序的问题，但一旦应用程序部署到生产服务器上，这个值应该设置为`false`，以避免向用户提供更多信息。
- en: 'This system manages all the exceptions through the `AppExceptionsHandler` class.
    This class contains two methods: `report` and `render`. Let’s explain them.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统通过`AppExceptionsHandler`类来管理所有的异常。这个类包含两个方法：`report`和`render`。让我们来解释一下它们。
- en: Report method
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 报告方法
- en: The `Report` method is used to log the exceptions that happen in your microservice
    or it is even possible to send them to an external tool, such as Sentry. We will go
    through this in the chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Report`方法用于记录在你的微服务中发生的异常，甚至可以将它们发送到Sentry等外部工具。我们将在本章中详细介绍这一点。'
- en: 'As mentioned, this method only logs the problem on the base class, but you
    can manage the different exceptions however you want. Check how you can do this
    in the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，这个方法只是在基类上记录问题，但你可以按照自己的需求管理不同的异常。看看下面的例子，你可以如何做到这一点：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The way to manage the different errors is `instanceof`. As you can see, in the
    preceding example, you can have different responses for each exception type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 管理不同错误的方法是`instanceof`。正如你所看到的，在前面的例子中，你可以针对每种异常类型有不同的响应。
- en: It is also possible to ignore some exception types by adding a variable to the
    `$dontReport` class. It is an array of different exceptions that you do not want
    to report. If we do not use this variable on the `Handle` class, only the `404`
    errors will be ignored by default.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过向`$dontReport`类添加一个变量来忽略一些异常类型。这是一个你不想报告的不同异常的数组。如果我们在`Handle`类上不使用这个变量，那么默认情况下只有`404`错误会被忽略。
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Render method
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染方法
- en: If the `report` method is used to help developers or yourself, the render method
    is to help users or consumers. This method gives an exception in an HTTP response
    that will be sent back to the user if it is a website and to a consumer if it
    is an API.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`report`方法用于帮助开发者或你自己，那么渲染方法是用来帮助用户或消费者的。这个方法会将异常以HTTP响应的形式返回给用户（如果是网站）或者返回给消费者（如果是API）。
- en: 'By default, the exception is sent to the base class to generate a response,
    but it can be modified. Take a look at this code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，异常被发送到基类以生成响应，但可以进行修改。看看这段代码：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, the `render` method receives two parameters: the request and
    the exception. With these parameters, you can make a proper response for your
    users or consumers, giving the information you want to give for each exception.
    For example, by giving an error code to the consumers of your API, they can check
    it on the API documentation. Take a look at the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`render`方法接收两个参数：请求和异常。通过这些参数，你可以为你的用户或消费者做出适当的响应，提供你想要为每个异常提供的信息。例如，通过在API文档中给消费者一个错误代码，他们可以在API文档中查看。看下面的例子：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The consumer will receive an error message with the `code 44`; this should be
    on our API documentation, and the proper status code. Obviously, this can be different
    in order to match your consumer's needs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者将收到一个带有`代码44`的错误消息；这应该在我们的API文档中，以及适当的状态码。显然，这可能会因消费者的需求而有所不同。
- en: Error handling with Sentry
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Sentry进行错误处理
- en: It is even better having a system to monitor the errors. There are a lot of
    error-tracking systems on the market but one that stands out is Sentry, a real-time
    cross-platform error tracking system that provides us with clues to understand
    what is happening in our microservices. An interesting feature is its support
    of notifications by e-mail or other medium.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个监控错误的系统甚至更好。市场上有很多错误跟踪系统，但其中一个脱颖而出的是Sentry，它是一个实时的跨平台错误跟踪系统，为我们提供了理解微服务中发生的情况的线索。一个有趣的特性是它支持通过电子邮件或其他媒介进行通知。
- en: Using a well-known system benefits your application, you are using a trusted
    and well-known tool, which in our case has an easy integration with our framework,
    Lumen.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个知名的系统有利于你的应用，你正在使用一个值得信赖和知名的工具，而在我们的情况下，它与我们的框架Lumen有着简单的集成。
- en: 'The first thing we need to do is install Sentry in our Docker environment;
    so, as always, stop all your containers with `docker-compose stop`. Once all the
    containers are stopped, open the `docker-compose.yml` file and add the following
    containers:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在我们的Docker环境中安装Sentry；所以，像往常一样，停止所有的容器，使用`docker-compose stop`。一旦所有的容器都停止了，打开`docker-compose.yml`文件并添加以下容器：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we firstly created a specific `redis` and `postgresql`
    container that will be used by Sentry. Once we had the required data storage containers,
    we added and linked the different containers that are the core of Sentry.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们首先创建了一个特定的`redis`和`postgresql`容器，这将被Sentry使用。一旦我们有了所需的数据存储容器，我们就添加并链接了Sentry核心的不同容器。
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding command will spin up the minimum containers we need for the Sentry
    setup. Once we have them up for the first time, we need to configure and fill
    the database and users. We can do it by running just one command on the container
    we have available for Sentry:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将启动我们设置Sentry所需的最小容器。一旦我们第一次启动它们，我们需要配置和填充数据库和用户。我们可以通过在我们为Sentry可用的容器上运行一个命令来完成：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding command will do all the setup needed for Sentry to run and will
    ask you to create an account to have access to the UI as admin; do this to save
    it and use it later. As soon as it finishes and returns you to the command path,
    you can spin up the remaining containers of our project:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As soon as everything is up, you can open `http://localhost:9876` in your browser
    and you will see a screen similar to the following one:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Error handling with Sentry](graphics/B06142_06_03-1.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: Sentry login page
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Log in with the user you created in the previous step and create a new project
    to start tracking our errors/logs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of using a single Sentry project to store all your debug information,
    it is better if you split them into logical groups, for example, one for the user
    microservice API, and so on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created your project, you will need the DSN assigned to this
    project; open your project settings and select the **Client Keys** option. In
    this section, you can find the **DSN** keys assigned to the project; you will
    be using these keys in your code so that the library knows where it needs to send
    all the debug information:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Error handling with Sentry](graphics/B06142_06_05.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: Sentry DSN keys
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! At this point, you have Sentry ready to be used in your project.
    Now it is time to install the `sentry/sentry-laravel` package using composer.
    To install this library, you can edit your `composer.json` file or enter your
    user microservice container with the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you are inside the container, give the following command to use composer
    to update your `composer.json` and install it for you:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once it is installed, we need to configure it on our microservice, so open
    the `bootstrap/app.php` file and add the following lines:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we have to configure the report method as we saw earlier, so go to the
    `app/Exceptions/Handler.php` file and add the following lines in the report function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These lines will report the exception to Sentry, so let’s create the `config/sentry.php`
    file with the following configuration:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Application logs
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A log is a record of debug information that can be important in the future to
    see the performance of your application or to see how your application is doing
    or even to get some stats. Practically, all known applications produce some kind
    of log information. For example, by default, all the requests to NGINX are recorded
    in the `/var/log/nginx/error.log` and `/var/log/nginx/access.log`. The first one, `error.log`,
    stores any errors generated by your application, for example, PHP exceptions.
    The second one, `access.log`, is created by each request that hits your NGINX
    server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: As an experienced developer, you already know that keeping some logs in your
    application is very important and you are not alone in this task, you can find
    a lot of libraries that can make your life easier. You may be wondering where
    the important places are and where you can place log calls and the information
    you need to save. There is no rule of thumb you can always follow, you only need
    to think about the future, and about what information you will need in the worst
    case scenario (a broken app).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Let’s focus on our example application; in the user service, we will be dealing
    with user registrations. An interesting point where you can place a log call is
    just before you save a new user registration. By doing this, you can keep track
    of your logs and know which information we are trying to save and when. Now, imagine
    that there is a bug in the registration process and it breaks with special characters
    but you were not aware of this, the only thing you know is that there are some
    users reporting issues with the registration. What will you do now? Check the
    logs! You can easily check which information the users are trying to store and
    detect that users with special characters are not being registered.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you are not using a log system, you can use `error_log()` to
    store messages in the default log file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您没有使用日志系统，可以使用`error_log()`将消息存储在默认日志文件中：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `0` parameter indicates that we want to store our message in the default
    log file. This function allows us to send the message by e-mail, changing the
    `0` parameter with `1` and adding an extra parameter with the e-mail address.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`0`表示我们要将消息存储在默认日志文件中。此函数允许我们通过电子邮件发送消息，将`0`参数更改为`1`并添加一个额外的参数，其中包含电子邮件地址。
- en: 'All the log systems allow you to define different levels; the most common ones
    are (note that they can be named differently in different log systems, but the
    concept is the same):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的日志系统都允许您定义不同的级别；最常见的是（请注意，它们在不同的日志系统中可能有不同的名称，但概念是相同的）：
- en: '**INFO**: This refers to non-critical information. You usually store debug
    information with this level, for example, you can store a new record each time
    a specific page is rendered.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息**：这指的是非关键信息。通常，您可以使用此级别存储调试信息，例如，您可以在特定页面呈现时存储一个新记录。'
- en: '**WARNING**: These are errors that are not very important or where the system
    can recover itself. For example, the lack of some information that can generate
    an inconsistent state of your application.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告**：这些是不太重要或系统可以自行恢复的错误。例如，缺少某些信息可能会导致应用程序处于不一致的状态。'
- en: '**ERROR**: This is critical information and, of course, all of these are errors
    that take place in your application. This is the first level you will check every
    time you find an error.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：这是关键信息，当然，所有这些都是发生在您的应用程序中的错误。这是您在发现错误时将首先检查的级别。'
- en: Challenges in microservices
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务中的挑战
- en: When you are working with a monolithic application, your logs will be stored
    in the same location by default or at least in only a few servers. If you have
    any problems and you need to check your logs, you can get all the information
    in a few minutes. The challenge is when you are dealing with a microservice architecture
    where each microservice generates log information. It is even worse if you have
    multiple instances of a microservice, each instance creating its own log data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用单体应用程序时，您的日志将默认存储在相同位置，或者至少在只有几台服务器上。如果出现任何问题，您需要检查日志，您可以在几分钟内获取所有信息。挑战在于当您处理微服务架构时，每个微服务都会生成日志信息。如果您有多个微服务实例，每个实例都会创建自己的日志数据，情况会变得更糟。
- en: What will you do in this case? The answer is to store all the log records in
    the same place using log systems like Sentry. Having a log service allows you
    to scale your infrastructure without worrying about your logs. They will all be
    stored in the same place, allowing you to easily find information about different
    microservices/instances.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您会怎么做？答案是使用像Sentry这样的日志系统将所有日志记录存储在同一位置。拥有日志服务可以让您扩展基础架构而不必担心日志。它们将全部存储在同一位置，让您轻松地找到有关不同微服务/实例的信息。
- en: Logs in Lumen
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lumen中的日志
- en: Lumen comes out of the box with **Monolog** (PSR-3 interface) integrated; this
    log library allows you to use different log handlers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen默认集成了**Monolog**（PSR-3接口）；这个日志库允许您使用不同的日志处理程序。
- en: In the Lumen framework, you can set up the amount of error detail of your application
    in the `.env` file. The `APP_DEBUG` setting defines how much debug information
    will be generated. The main recommendation is to set this flag to `true` in development
    environments but always to `false` in production.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lumen框架中，您可以在`.env`文件中设置应用程序的错误详细信息。`APP_DEBUG`设置定义了将生成多少调试信息。主要建议是在开发环境中将此标志设置为`true`，但在生产环境中始终设置为`false`。
- en: To use logging facilities in your code, you only need to ensure that you have
    uncommented the `$app->withFacades();` line of your `bootstrap/app.php` file.
    Once you have the facades enabled, you can start using the Log class in any place
    of your code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中使用日志记录功能，您只需要确保已取消注释`bootstrap/app.php`文件中的`$app->withFacades();`行。一旦启用了门面，您就可以在代码的任何地方开始使用Log类。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By default, without any extra configuration, Lumen will store the logs in the
    `storage/logs` folder.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，没有任何额外配置，Lumen将日志存储在`storage/logs`文件夹中。
- en: 'Our logger provides the eight logging levels defined in RFC 5424:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的记录器提供了RFC 5424中定义的八个日志级别：
- en: '`Log::emergency($error);`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log::emergency($error);`'
- en: '`Log::alert($error);`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log::alert($error);`'
- en: '`Log::critical($error);`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log::critical($error);`'
- en: '`Log::error($error);`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log::error($error);`'
- en: '`Log::warning($error);`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log::warning($error);`'
- en: '`Log::notice($error);`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log::notice($error);`'
- en: '`Log::info($error);`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log::info($error);`'
- en: '`Log::debug($error);`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log::debug($error);`'
- en: 'An interesting feature is the option where you have to add an array of contextual
    data. Imagine that you want to log a record of a failed user login. You can do
    something similar to the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的功能是您必须添加一个上下文数据数组的选项。想象一下，您想记录一个失败的用户登录记录。您可以执行类似以下代码的操作：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding piece of code, we are adding extra information to our log message--the
    ID of the user who had problems trying to log into our application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们正在向我们的日志消息添加额外信息--尝试登录到我们的应用程序时出现问题的用户的ID。
- en: 'The setup of Monolog with a custom handler like Sentry (we explained how to
    install it in your project earlier) is very easy, you only need to add the following
    piece to the `bootstrap/app.php` file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Sentry这样的自定义处理程序设置Monolog（我们之前解释了如何在项目中安装它）非常容易，您只需要将以下代码添加到`bootstrap/app.php`文件中：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code changes how Monolog will work; in our case, instead of storing
    all our debug information in the `storage/logs` folder, it will use our Sentry
    installation and the `WARNING` level.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码更改了Monolog的工作方式；在我们的情况下，它将不再将所有调试信息存储在`storage/logs`文件夹中，而是使用我们的Sentry安装和`WARNING`级别。
- en: 'We showed you two different ways of storing your logs in Lumen: in local files
    like a monolithic application or with an external service. Both of them are fine
    but our recommendation for microservices development is to use an external tool
    like Sentry.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向您展示了在Lumen中存储日志的两种不同方式：像单体应用程序一样在本地文件中存储，或者使用外部服务。这两种方式都可以，但我们建议微服务开发使用像Sentry这样的外部工具。
- en: Application monitoring
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序监控
- en: In software development, application monitoring can be defined as the process
    which ensures that our application performs in an expected manner. This process
    allows us to measure and evaluate the performance of our application and can be
    helpful to find bottlenecks or hidden issues.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，应用程序监控可以被定义为确保我们的应用程序以预期的方式执行的过程。这个过程允许我们测量和评估我们的应用程序的性能，并有助于发现瓶颈或隐藏的问题。
- en: Application monitoring is usually made through a specialized software that gathers
    metrics from the application or the infrastructure that runs your software. These
    metrics can include CPU load, transaction times, or average response times among
    others. Anything you can measure can be stored in your telemetry system so you
    can analyze it later.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序监控通常是通过专门的软件进行的，该软件从运行您的软件的应用程序或基础架构中收集指标。这些指标可以包括CPU负载、事务时间或平均响应时间等。您可以测量的任何内容都可以存储在遥测系统中，以便以后进行分析。
- en: Monitoring a monolithic application is easy; you have everything in one place,
    all logs are stored in the same place, all metrics can be gathered from the same
    host, you can know if your PHP thread is killing your server. The main difficulty
    you may find is finding the part of your application that is underperforming,
    for example, which part of your PHP code is wasting your resources.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 监控单体应用程序很容易；您可以在一个地方找到所有内容，所有日志都存储在同一个地方，所有指标都可以从同一主机收集，您可以知道您的PHP线程是否在消耗服务器资源。您可能遇到的主要困难是找到应用程序中性能不佳的部分，例如，您的PHP代码中的哪一部分在浪费资源。
- en: When you work with microservices, you have your code split into logical parts,
    allowing you to know which part of the application is underperforming, but at
    a big cost. You have all your metrics segregated between different containers
    or servers, making it difficult to have a big picture of the overall performance.
    By having a telemetry system in place, you can send all your metrics to the same
    location, making it easier to check and debug your application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用微服务时，您的代码被分割成逻辑部分，使您能够知道应用程序的哪一部分性能不佳，但代价很大。您的所有指标被分隔在不同的容器或服务器之间，这使得很难获得整体性能的全貌。通过建立遥测系统，您可以将所有指标发送到同一位置，从而更容易地检查和调试您的应用程序。
- en: Monitoring by levels
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按层次监控
- en: As a developer, you need to know how your application is performing at all the
    levels, from the top level that is your application to the bottom that is the
    hardware or hypervisor level. In an ideal world, we will have control over all
    the levels, but the most probable scenario is that you will only be able to monitor
    up to the infrastructure level.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您需要了解您的应用程序在各个层面的表现，从顶层即您的应用程序到底层即硬件或虚拟化层。在理想的情况下，我们将能够控制所有层面，但最有可能的情况是您只能监控到基础架构层。
- en: 'The following image shows you the different layers and the relation with the
    server stack:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了不同层次和与服务器堆栈的关系：
- en: '![Monitoring by levels](graphics/B06142_06_06.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![按层次监控](graphics/B06142_06_06.jpg)'
- en: Monitoring layers
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 监控层
- en: Application level
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序级别
- en: Application level lives inside your application; all the metrics are generated
    by your code, in our case by PHP. Unfortunately, you can’t find free or open source
    tools for **Application Performance Monitoring** (**APM**) exclusively for PHP.
    In any case, you can find interesting third-party services with free plans to
    give it a try.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序级别存在于您的应用程序内；所有指标都是由您的代码生成的，例如我们的PHP。不幸的是，您无法找到专门用于PHP的**应用程序性能监控**（**APM**）的免费或开源工具。无论如何，您可以找到有趣的第三方服务，并尝试其免费计划。
- en: Two of the most well-known APM services for PHP are New Relic and Datadog. In
    both the cases, the installation follows the same path--you install an agent (or
    library) on your container/host and this small piece of software will start sending
    the metrics to its service, giving you a dashboard where you can manipulate your
    data. The main disadvantage of using third-party services is that you don’t have
    any control over this agent or metric system, but this disadvantage can be transformed
    into a plus point--you will have a reliable system that you don’t need to manage,
    you only need to worry about your application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的两个最知名的APM服务是New Relic和Datadog。在这两种情况下，安装都遵循相同的路径--您在容器/主机上安装一个代理（或库），这个小软件将开始将指标发送到其服务，为您提供一个仪表板，您可以在其中操作您的数据。使用第三方服务的主要缺点是您无法控制该代理或指标系统，但这个缺点可以转化为一个优点--您将拥有一个可靠的系统，无需管理，您只需要关注您的应用程序。
- en: Datadog
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Datadog
- en: 'The installation of the Datadog client could not be easier. Open the `composer.json`
    of one of your microservices and drop the following line inside the `required` definitions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Datadog客户端的安装非常简单。打开其中一个微服务的`composer.json`文件，并在`required`定义中添加以下行：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As soon as you save your changes and make a composer update, you will be able
    to use the `Datadogstatsd` class in your code and start sending metrics.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改并进行composer更新后，您就可以在代码中使用`Datadogstatsd`类并开始发送指标了。
- en: 'Imagine that you want to monitor the time your secret microservice spends getting
    all the servers you have in your database. Open the `app/Http/Controllers/SecretController.php`
    file of your secret microservice and modify your class, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您想监控您的秘密微服务在获取数据库中所有服务器所花费的时间。打开您的秘密微服务的`app/Http/Controllers/SecretController.php`文件，并修改您的类，如下所示：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding piece of code defines your app and API keys of your Datadog account
    and we used them to set up our `Datadogstatsd` interface. The example logs the
    time spent retrieving all our secret records. The `Datadogstatsd::timing()` method
    will send the metric to our external telemetry service. Doing the monitoring inside
    your application allows you to decide the places of your code you want to generate
    metrics in. There is no rule of thumb when you are monitoring this level, but
    you need to remember that it is important to know where your application spends
    most of its time, so add metrics in each place of your code that you think could
    be a bottleneck (like getting data from another service or from a database).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段定义了你的应用程序和Datadog账户的API密钥，我们使用它们来设置我们的`Datadogstatsd`接口。这个例子记录了检索所有秘密记录所花费的时间。`Datadogstatsd::timing()`方法将指标发送到我们的外部遥测服务。在你的应用程序内部进行监控可以让你决定在你的代码中生成指标的位置。在监控这个级别时没有硬性规定，但你需要记住重要的是要知道你的应用程序在哪里花费了大部分时间，所以在你认为可能成为瓶颈的代码的每个地方添加指标（比如从另一个服务获取数据或从数据库获取数据）。
- en: 'With this library, you can even increment and decrement custom metric points
    with the following method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个库，你甚至可以使用以下方法增加和减少自定义指标点：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The three of them increase a point: the first increments `another.data.point`
    in one unit, the second one increments our point by `0.5`, and the third one increments
    the point and also adds a custom tag to the metric record.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 他们三个增加了一个点：第一个将`another.data.point`增加了一个单位，第二个将我们的点增加了`0.5`，第三个增加了点，并且还向度量记录添加了自定义标签。
- en: You can also decrement points with `Datadogstatsd::decrement()`, which has the
    same syntax as `::increment()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`Datadogstatsd::decrement()`来减少点，它与`::increment()`具有相同的语法。
- en: Infrastructure level
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础设施级别
- en: This level controls everything between the OS and your application. Adding a
    monitoring system to this layer allows you to know if your container is using
    too much memory, or if the load of a specific container is too high. You can even
    track some basic metrics of your application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个层控制着操作系统和你的应用程序之间的一切。在这一层添加一个监控系统可以让你知道你的容器是否使用了太多内存，或者特定容器的负载是否过高。你甚至可以跟踪你的应用程序的一些基本指标。
- en: There are multiple options to monitor this layer in the high street, but we
    will give you a sneak peek at two interesting projects. Both of them are open
    source and even though they use different approaches, you can combine them.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在高街上，有多种监控这个层的选项，但我们将给你一些有趣的项目。它们都是开源的，尽管它们使用不同的方法，但你可以将它们结合起来。
- en: Prometheus
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Prometheus
- en: '**Prometheus** is an open source monitoring and alerting toolkit that was created
    at SoundCloud and is under the umbrella of the **Cloud Native Computing Foundation**.
    Being the new kid on the block doesn''t mean that it doesn''t have powerful features.
    Among others, we can highlight the following main features:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**Prometheus**是一个开源的监控和警报工具包，是在SoundCloud创建的，并且属于**Cloud Native Computing Foundation**的一部分。作为新生力量并不意味着它没有强大的功能。除其他外，我们可以强调以下主要功能：'
- en: Time series collection through pull over HTTP
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP拉取进行时间序列收集
- en: Target discovery via service discovery (kubernetes, consul, and so on) or static
    config
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过服务发现（kubernetes、consul等）或静态配置进行目标发现
- en: Web UI with simple graphing support
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有简单图形支持的Web界面
- en: Powerful query language that allows you to extract all the information you need
    from your data
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的查询语言，允许你从数据中提取所有你需要的信息
- en: 'Installing Prometheus is very easy with Docker, we only need to add a new container
    for our telemetry system and link it with our autodiscovery service (Consul).
    Add the following lines to the `docker-compose.yml` file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker安装Prometheus非常简单，我们只需要为我们的遥测系统添加一个新的容器，并将其与我们的自动发现服务（Consul）进行链接。将以下行添加到`docker-compose.yml`文件中：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, we only tell Docker where the `Dockerfile` is located,
    link the container without autodiscovery container, and expose and map some ports.
    Now, it''s time to create the `telemetry/Dockerfile` file with the following content:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们只告诉Docker`Dockerfile`的位置，链接了没有自动发现容器的容器，并暴露和映射了一些端口。现在，是时候创建`telemetry/Dockerfile`文件，内容如下：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, it does not take a lot to create our telemetry container; we
    are using the official image and adding our Prometheus configuration. Create the
    `etc/prometheus.yml` configuration with the following content:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，创建我们的遥测容器并不需要太多的工作；我们使用官方镜像并添加我们的Prometheus配置。创建`etc/prometheus.yml`配置，内容如下：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Again, the setup is very easy as we are defining some global scrapping intervals
    and one job called `containerpilot-telemetry` that will use our autodiscovery
    container and monitor all the services stored in consul announced under the `containerpilot`
    name.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，设置非常简单，因为我们正在定义一些全局的抓取间隔和一个名为`containerpilot-telemetry`的作业，它将使用我们的自动发现容器，并监视存储在consul中以`containerpilot`名称宣布的所有服务。
- en: 'Prometheus has a simple and powerful web UI. Open your `localhost:9090` and
    you have access to all the metrics gathered by this tool. Creating a graph is
    very easy, choose a metric and Prometheus will do all the work for you:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus有一个简单而强大的Web界面。打开`localhost:9090`，你就可以访问到这个工具收集的所有指标。创建一个图表非常简单，选择一个指标，Prometheus会为你完成所有工作：
- en: '![Prometheus](graphics/B06142_06_07-1.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Prometheus](graphics/B06142_06_07-1.jpg)'
- en: Prometheus graph UI
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus图形界面
- en: 'At this point, you will probably be wondering how you can declare metrics.
    In the earlier chapters, we introduced `containerpilot`, a tool we will use as
    a PID in our containers to manage our autodiscovery. The `containerpilot` has
    the ability to declare metrics to be available for the supported telemetry systems,
    in our case Prometheus. If you open, for example, the `docker/microservices/battle/nginx/config/containerpilot.json`
    file, you can find something similar to the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding piece of code, we are declaring two metrics: `"nginx_connections_unhandled_total"` and
    `"nginx_connections_load"`. `ContainerPilot` will run the command defined in the
    `"check"` parameter inside the container and the result will be scrapped by Prometheus.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: You can monitor anything in your infrastructure with Prometheus, even Prometheus
    itself. Feel free to change our basic installation and setup and adapt it to use
    the autopilot pattern. If the Prometheus’ web UI is not enough for your graphics
    and you need more power and control, you can easily link our telemetry system
    with Grafana, one of the most powerful tools out there to create dashboards with
    all kinds of metrics.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Weave Scope
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Weave Scope** is a tool used for monitoring your containers, it works well
    with Docker and Kubernetes and has some interesting features that will make your
    life easier. Scope gives you a deep top-down view of your app and your entire
    infrastructure. With this tool, you can diagnose any problems in your distributed
    containerized application, and everything in real time.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Forget about complex configurations, Scope automatically detects and starts
    monitoring every host, Docker container, and any process running in your infrastructure.
    As soon as it gets all this information, it creates a nice map showing the inter-communications
    between all your containers in real time. You can use this tool to find memory
    issues, bottlenecks, or any other problems. You can even check different metrics
    of a process, container, service, or host. A hidden feature you can find in Scope
    is the ability to manage containers, view logs, or attach a terminal, all from
    the browser UI.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options to deploy Weave Scope: in a standalone mode where all
    the components run locally or as a paid cloud service where you don''t need to
    worry about anything. The standalone mode runs as a privileged container inside
    each one of your infrastructure servers and has the ability to correlate all the
    information from your cluster or servers and display it in the UI.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation is very easy--you only need to run the following commands
    on each one of your infrastructure servers:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As soon as you have Scope launched, open the IP address of your server (localhost
    if you are working locally like us) `http://localhost:4040`, and you will see
    something similar to the following screenshot:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Weave Scope](graphics/B06142_06_08-1.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: Weave Scope containers graph visualization
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The preceding image is a snapshot of the application we are building; here,
    you can see all our containers and the connections between them in a specific
    moment in time. Give it a try and while you make some calls to our different API
    endpoints, you will be able to see the connections between containers changing.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Can you find any problems in our microservices infrastructure? If so, you are
    correct. As you can see, we didn't connect some of our containers to the autodiscovery
    service. Scope helped us find a possible future problem, now feel free to fix
    it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can use Scope to monitor your app from a browser. You only
    need to be careful with who has access to the privileged Scope container; if you
    have plans to use Scope in production, ensure that you limit the access to this
    tool.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Hardware/hypervisor monitoring
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This layer matches our hardware or hypervisor level and is the lowest place
    where you can place your metrics. The maintenance and monitoring of this layer
    is usually done by sysadmins and they can use very well-known tools, such as **Zabbix**
    or **Nagios**. As a developer, you will probably not be worried about this layer.
    If you deploy the application in a cloud environment, you will not have any kind
    of access to the metrics generated by this layer.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained how you can debug and do a profiling of a microservice
    application, an important process in any software development. On a day-to-day
    basis, you will not spend all your time debugging or profiling your application;
    in some scenarios, you will spend a lot of time trying to fix bugs. For this reason,
    it is important to have a place where you can store all your errors and debug
    information, this information will give you a deeper understanding of what is
    happening with your app. Finally, as a full-stack developer, we showed you how
    to monitor the top two layers of your application stack.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 8. Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 部署
- en: Throughout the previous chapters, you have learned how to develop an application
    based on microservices. Now, it is time to learn about the deployment of your
    application, learning the best strategies to automate and roll back your application
    and also, doing back ups and restores if needed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，您已经学会了如何基于微服务开发应用程序。现在，是时候学习如何部署您的应用程序，学习最佳的自动化策略和回滚应用程序的方法，以及在需要时进行备份和恢复。
- en: Dependency management
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖管理
- en: As we mentioned in [Chapter 5](ch01.html "Chapter 1. What are Microservices?"),
    *Microservice Development*, **Composer** is the most-used dependency management
    tool; it can help us move a project from the development environment to production
    in the deployment process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第5章](ch01.html "第1章 什么是微服务？")中提到的，*微服务开发*，**Composer**是最常用的依赖管理工具；它可以帮助我们在部署过程中将项目从开发环境移动到生产环境。
- en: There are some different opinions about what the best workflow for the deployment
    process is, so let's look at the advantages and disadvantages of every case.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 关于部署过程的最佳工作流有不同的观点，因此让我们看一下每种情况的优缺点。
- en: Composer require-dev
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Composer require-dev
- en: To be used on the development environment, Composer provides a section on their
    `composer.json`, called `require-dev`, and when we need to install some libraries
    on our application that do not need to be on production, we have to use it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Composer在他们的`composer.json`中提供了一个名为`require-dev`的部分，用于在开发环境中使用，并且当我们需要在应用程序中安装一些不需要在生产环境中的库时，我们必须使用它。
- en: As we already know, the command to install a new library using Composer is `composer
    require library-name`, but if we want to install a new library, such as testing
    libraries, debugging libraries, or any others that do not make sense on production,
    we can use `composer require-dev library-name` instead. It will add the library
    to the `require-dev` section and when we deploy the project to production, we
    should use the `--no-dev` parameter when executing `composer install --no-dev`
    or `composer update --no-dev` in order to avoid installing development libraries.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，使用Composer安装新库的命令是`composer require library-name`，但如果我们想安装新的库，比如测试库、调试库或者其他在生产环境下没有意义的库，我们可以使用`composer
    require-dev library-name`。它会将库添加到`require-dev`部分，当我们将项目部署到生产环境时，我们应该在执行`composer
    install --no-dev`或`composer update --no-dev`时使用`--no-dev`参数，以避免安装开发库。
- en: The .gitignore file
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .gitignore文件
- en: With the `.gitignore` file, it is possible to ignore files or folders that you
    do not want to track. Even though Git is a versioning tool, many developers use
    this in the deployment process. The `.gitignore` file contains a list of files
    and folders that will not be tracked on your repository when they change. This
    is usually used to upload folders that contain images or any other file uploaded
    by users and also, it is used for the vendor folder, the folder that contains
    all the libraries used on the project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`.gitignore`文件，可以忽略您不想跟踪的文件或文件夹。尽管Git是一个版本控制工具，但许多开发人员在部署过程中使用它。`.gitignore`文件包含一系列在更改时不会在存储库中跟踪的文件和文件夹。这通常用于上传包含用户上传的图像或其他文件的文件夹，也用于vendor文件夹，该文件夹包含项目中使用的所有库。
- en: Vendor folder
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vendor文件夹
- en: The `vendor` folder contains all the libraries used in our application. As previously
    mentioned, there are two different ways of thinking about how to use the `vendor`
    folder.  There are advantages and disadvantages of including Composer in production
    in order to get the `vendor` folder from the repository once the application is
    deployed or when it is downloading the libraries used on development into production.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`vendor`文件夹包含我们应用程序中使用的所有库。如前所述，关于如何使用`vendor`文件夹有两种不同的思考方式。在生产中包含Composer以便在应用程序部署后从存储库获取`vendor`文件夹，或者在生产中将开发中使用的库下载到生产中。'
- en: Deployment workflows
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署工作流
- en: The deployment workflow can be different in every application depending on the
    project needs. For example, if you want to keep the whole project, including the
    `vendor` folder, in the repository or if you prefer to get the libraries from
    Composer once the project is deployed. We will look at a couple of the most common
    workflows in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 部署工作流可能因项目需求而异。例如，如果您想在存储库中保留整个项目，包括`vendor`文件夹，或者如果您希望在项目部署后从Composer获取库。在本章中，我们将看一下一些最常见的工作流。
- en: Vendor folder on repository
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储库中的Vendor文件夹
- en: The first deployment workflow has the entire application on the repository.
    This is when we use Composer for the first time in our development environment
    and we push the `vendor` folder to our repository, so all the libraries will be
    kept on the repository.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个部署工作流在存储库中有整个应用程序。这是当我们在开发环境中第一次使用Composer并将`vendor`文件夹推送到我们的存储库时，所有的库都将保存在存储库中。
- en: Therefore, on production we will get the entire project from the repository
    without needing to do a Composer update because our libraries were put in production
    with the deployment. So, you do not need Composer in production.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在生产中，我们将从存储库中获取整个项目，而无需进行Composer更新，因为我们的库已经在部署中投入生产。因此，在生产中不需要Composer。
- en: 'Advantages of including the **`vendor`** folder in the repository are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中包含**`vendor`**文件夹的优点如下：
- en: You know that the same code (including libraries) was working on development.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您知道相同的代码（包括库）在开发中是可以工作的。
- en: Minor risk of breaking updated libraries in production.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产中更新库的风险较小。
- en: You do not depend on external services in the deployment process. Sometimes,
    the libraries are not available at a specific moment.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在部署过程中，您不依赖外部服务。有时，库在特定时刻不可用。
- en: 'Disadvantages of including the **`vendor`** folder on the repository are as
    follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中包含**`vendor`**文件夹的缺点如下：
- en: Your repository has to store libraries already stored on Composer. The space
    needed can be a problem if you need many or large libraries.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are storing code that is not yours.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composer in production
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second deployment workflow has two different ways of proceeding, but both
    of them do not need to store the `vendor` folder in the repository; they will
    get the libraries from Composer once the code is deployed to production.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Once the code is deployed to production, the `composer update` command will
    be executed either **manually** or **automatically** in the deployment process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of running Composer in production are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: You are saving space in your repository
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can execute–optimize-autoload in production in order to map the libraries
    added
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages of running Composer in production are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The deployment process will depend on external services.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Major risk in some situations when updating packages. For example, if a library
    is suddenly modified or corrupted, your application will break.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend dependencies
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is necessary to know that it is possible to have management dependencies
    on the frontend side too, so it is possible to choose if it is better to put it
    on the repository or not. Grunt and Gulp are two of the most used tools in order
    to automatize tasks in your application. Also, if your application based on microservices
    has a frontend part you should use the following tools in order to manage styles and assets.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Grunt
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Grunt** is a tool to automatize tasks on your application. Grunt can help
    you to concat or minify JS and CSS files, optimize images, or even help you with
    unit testing.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Every task is implemented by a Grunt plugin developed on Javascript. Also, they
    use Node.js, so it makes Grunt a multiplatform tool. You can check all the available
    plugins at  [http://gruntjs.com/plugins](http://gruntjs.com/plugins).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not necessary to learn Node.js, just install Node.js and you will have
    Node Packaged Modules available to install Grunt (and many other packages). Once
    Node.js is installed, run the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, you can create a `package.json` that will be read by the NPM command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, `npm install` will install the dependencies contained in the `package.json`
    file. Grunt will be stored in the `node_modules` folder. Once Grunt is installed,
    it is necessary to create a `Gruntfile.js` to define the automated tasks, as shown
    in the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are three sections to define the automated tasks:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**InitConfig**: This refers to tasks that will be executed by Grunt'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LoadNpmTask**: This is used to load the required plugin to make the tasks'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RegisterTask**: This registers the tasks that will run'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we decide what plugin to install and define all the necessary tasks, run
    grunt on your terminal to execute them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Gulp
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like Grunt, **Gulp** is also a tool to automatize tasks and it is also developed
    on NodeJS, so it is necessary to install Node.js in order to have NPM available
    to install it. Once we have installed Node.js, we can install Gulp globally by
    running the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another way of installing gulp, and is the recommended option, is locally and
    you can do it with the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All the tasks should be included in a `gulpfile.js` located on the root project
    to be automated:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code is very simple. As you can see, the code is `gulp.task`,
    the task name, and then the `function` defined for that task name.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the functions defined, you can run `gulp`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: SASS
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSS is complex, large, and hard to maintain. Can you imagine maintaining a file
    with thousands and thousands of lines? This is where Sass can be used. This is
    a preprocessor that adds features, such as variables, nesting, mixins, inheritance,
    and others to CSS that makes CSS a real development language.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntactically Awesome Stylesheets** (**SASS**) is a metalanguage of CSS.
    It is a script language that is translated to CSS. SassScript is the Sass language
    and it has two different syntaxes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**Syntactically Awesome Stylesheets** (**SASS**)是CSS的元语言。它是一种被翻译成CSS的脚本语言。SassScript是Sass语言，它有两种不同的语法：'
- en: '**Indented syntax:** This uses the indent to separate block codes and the new
    line character to separate rules'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩进语法:** 这使用缩进来分隔块代码，换行符来分隔规则'
- en: '**SCSS**: This one is an extension of the CSS syntax, it uses braces for code
    blocks and semicolons to separate lines within a block'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCSS**: 这是CSS语法的扩展，它使用大括号来分隔代码块，分号来分隔块内的行'
- en: The indented syntax has `.sass` extensions, and SCSS has `.scss` extensions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进的语法有`.sass`扩展名，SCSS有`.scss`扩展名。
- en: Sass is very simple to run. Once it is installed, just run `sass input.scss
    output.css` on your terminal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Sass非常简单易用。一旦安装，只需在终端上运行`sass input.scss output.css`。
- en: Bower
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bower
- en: '**Bower** is a dependency management like Composer, but it works for the frontend
    side. It is also based on Node.js, so once Node.js is installed, you can install
    Bower using NPM. Using Bower, it is possible to have all the frontend libraries
    updated, without needing to update them manually. The command to install Bower
    once Node.js is installed is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bower**是一个类似Composer的依赖管理工具，但它适用于前端。它也基于Node.js，因此一旦安装了Node.js，您就可以使用NPM安装Bower。使用Bower，可以更新所有前端库，而无需手动更新它们。一旦安装了Node.js，安装Bower的命令如下：'
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, you can execute `bower init` in order to create the `bower.json` file
    on your project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以执行`bower init`来创建项目上的`bower.json`文件。
- en: 'The `bower.json` file will remind you of `composer.json`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`bower.json`文件会让您想起`composer.json`：'
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, you can you can see the dependencies added to the project.
    They can be modified in order to have these dependencies installed on your application
    like Composer works. Also, the commands to work with Bower are very similar to
    Composer:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，您可以看到添加到项目中的依赖项。它们可以被修改，以便像Composer一样在您的应用程序上安装这些依赖项。此外，与Composer一起使用Bower的命令非常相似：
- en: '**bower install:** This is to install all the dependencies on `bower.json`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bower install:** 这是为了安装`bower.json`中的所有依赖项'
- en: '**bower update:** This is to update the dependencies contained on `bower.json`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bower update:** 这是为了更新`bower.json`中包含的依赖项'
- en: '**bower install package-name:** This installs a package on Bower'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bower install package-name:** 这会在Bower上安装一个包'
- en: Deploy automation
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署自动化
- en: At some point, your application will be deployed to production. If your application
    is small and you only use a few containers/servers, everything will be fine, you
    can easily manage all your resources (containers, VMs, servers, and so on) by
    hand in each deployment. However, what happens if you have hundreds of resources
    you need to update on each deployment? In this case, you need some kind of deployment
    mechanism; even if you have a small project and only one container/server, we
    recommend automating your deployment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，您的应用将被部署到生产环境。如果您的应用很小，只使用了少量容器/服务器，那么一切都会很好，您可以轻松地手动管理所有资源（容器、虚拟机、服务器等）在每次部署时。但是，如果您有数百个资源需要在每次部署时更新，那该怎么办呢？在这种情况下，您需要某种部署机制；即使您有一个小项目和一个容器/服务器，我们也建议自动化您的部署。
- en: 'The main benefits of using an automatic deployment process are as listed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动部署流程的主要好处如下列出：
- en: '**Easy to maintain:** Most of the time, the steps needed by the deployment
    can be stored in files so that you can edit them.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于维护:** 大多数时候，部署所需的步骤可以存储在文件中，这样您就可以编辑它们。'
- en: '**Repeatable:** You can execute the deployment again and again and it will
    follow the same steps each time.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重复:** 您可以一遍又一遍地执行部署，每次都会按照相同的步骤进行。'
- en: '**Less error-prone:** We are humans and, as humans, we make mistakes multitasking.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更少出错:** 我们是人类，作为人类，我们在多任务处理时会犯错。'
- en: '**Easy to track:** There are multiple tools you can use to keep a log of everything
    that happens in every commit. These tools can also be used to create groups of
    users who can make deploys. The most common tools you can use are **Jenkins**,
    **Ansible Tower**, and **Atlassian Bamboo**.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于跟踪:** 有多种工具可用于记录每次提交发生的一切。这些工具也可以用于创建可以进行部署的用户组。您可以使用的最常见的工具是**Jenkins**、**Ansible
    Tower**和**Atlassian Bamboo**。'
- en: '**Easy to release more often:** Having a deployment pipeline in place will
    help you develop and deploy faster because you will not spend time dealing with
    the push of your code to production.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易更频繁地发布:** 拥有一个部署流水线将帮助您更快地开发和部署，因为您将不会花时间处理将代码推送到生产环境。'
- en: Let's look at some ways to automate your deployments, starting with the simplest
    options and increasing the complexity and features more and more. We will analyze
    the pros and cons of each one so that, at the end of the chapter, you will be
    available to choose the perfect deployment system for your project.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些自动化部署的方法，从最简单的选项开始，逐渐增加复杂性和功能。我们将分析每种方法的优缺点，这样，在本章结束时，您将能够选择适合您项目的完美部署系统。
- en: Simple PHP script
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的PHP脚本
- en: 'This is the most simple way you can automate your deployments--you can add
    a script to your code (in a public location), as shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您可以自动化部署的最简单方式--您可以向您的代码中添加一个脚本（在公共位置），如下所示：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding script, we only do a pull from master if the script is reached
    with the correct key. As you can see, it is very easy and it can be fired by anyone
    who knows the secret key, for example, by a browser. If your code repository allows
    the set up of webhooks, you can use them to fire your script each time a push
    or commit is done in your project.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述脚本中，只有在使用正确的密钥到达脚本时，我们才会从主分支中拉取。正如您所看到的，这非常简单，任何知道秘钥的人都可以触发它，例如，通过浏览器。如果您的代码仓库允许设置webhook，您可以使用它们在每次推送或提交时触发您的脚本。
- en: 'Here are the pros of this deployment method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这种部署方法的优点：
- en: It's easy to create if the work required is small, for example, a` git pull`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所需工作很小，例如`git pull`，那么创建起来很容易
- en: It's easy to keep track of changes to the script
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易跟踪脚本的更改
- en: It's easy to be fired by you or any external tools
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它很容易被您或任何外部工具触发
- en: 'Here are the disadvantages of this deployment method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这种部署方法的缺点：
- en: The web server user needs to be able to use the repo
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器用户需要能够使用存储库
- en: It increases in complexity when you need to deal with, for example, branches
    or tags
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要处理分支或标签时，它会变得更加复杂
- en: It is not easy to use when you need to deploy to multiple instances, you will need
    external tools like rsync
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要部署到多个实例时，它不容易使用，您将需要像rsync这样的外部工具
- en: Not very secure. If your key gets found out by a third party, they can deploy
    on your server whatever they want
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不太安全。如果您的密钥被第三方发现，他们可以在您的服务器上部署任何他们想要的东西
- en: In an ideal world, all your commits to production will be perfect and pristine,
    but you know the truth--at some point in the future, you will need to roll back
    all your changes. If you have this deployment method in place and you want to
    create a rollback strategy, you have to increase the complexity of your PHP script
    so that it can manage tags. Another not-recommended option is, instead of adding
    a rollback to your scripts, you can do, for example, a `git undo` and push all
    the changes again.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，您对生产的所有提交都将是完美和纯净的，但您知道事实--在将来的某个时候，您将需要回滚所有更改。如果您已经使用了这种部署方法，并且想要创建一个回滚策略，您必须增加您的PHP脚本的复杂性，以便它可以管理标签。另一个不推荐的选择是，而不是向您的脚本添加回滚，您可以执行，例如，`git
    undo`并再次推送所有更改。
- en: Ansible and Ansistrano
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible和Ansistrano
- en: '**Ansible** is an IT automation engine that can be used to automate cloud provisioning,
    manage configurations, deploy applications, or orchestrate services among other
    uses. This engine does not use an agent, so there is no need for additional security
    infrastructure, it was designed to be used through SSH. The main language used
    to describe your automation jobs (also called **playbooks**)is YAML and its syntax
    is similar to English. Due to the fact that all your playbooks are simple text
    files, you can store them easily in your repository. An interesting feature that
    you can find in Ansible is its Galaxy, a hub of add-ons you can use in your playbooks.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible**是一个IT自动化引擎，可用于自动化云配置，管理配置，部署应用程序或编排服务等其他用途。该引擎不使用代理，因此无需额外的安全基础设施，它被设计为通过SSH使用。用于描述自动化作业（也称为**playbooks**）的主要语言是YAML，其语法类似于英语。由于所有playbooks都是简单的文本文件，因此可以轻松地将它们存储在存储库中。在Ansible中可以找到的一个有趣的功能是其Galaxy，这是一个可以在playbooks中使用的附加组件中心。'
- en: Ansible requirements
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ansible要求
- en: Ansible uses the SSH protocol to manage all the hosts, and you only need to
    install this tool on one machine--the machine you will use to manage your fleet
    of hosts. The main requisite for the control machine is Python 2.6 or 2.7 (from
    Ansible 2.2 it has support for Python 3), and you can use any OS except Microsoft
    Windows.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible使用SSH协议管理所有主机，您只需要在一台机器上安装此工具--您将用来管理主机群的机器。控制机器的主要要求是Python 2.6或2.7（从Ansible
    2.2开始支持Python 3），您可以使用除Microsoft Windows之外的任何操作系统。
- en: The only requirement on the managed hosts is Python 2.4+, which comes installed
    by default by most of the UNIX-like operating systems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 托管主机的唯一要求是Python 2.4+，这在大多数类UNIX操作系统中默认安装。
- en: Ansible installation
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ansible安装
- en: Assuming that you have the correct Python version on your control machine, installing
    Ansible is very easy with the help of the package managers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的控制机器上有正确的Python版本，使用包管理器很容易安装Ansible。
- en: 'On RHEL, CentOS and similar linux distributions execute the following command
    to install Ansible:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在RHEL、CentOS和类似的Linux发行版上执行以下命令来安装Ansible：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The Ubuntu command is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu命令如下：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The FreeBSD command is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD命令如下：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Mac OS command is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Mac OS命令如下：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What is Ansistrano?
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是Ansistrano？
- en: '**Ansistrano** is an open source project composed with `ansistrano.deploy`
    and `ansistrano.rollback`, two Ansible Galaxy roles used to easily manage your
    deployments. It''s considered to be the Ansible port for Capistrano.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansistrano**是一个由`ansistrano.deploy`和`ansistrano.rollback`组成的开源项目，这两个Ansible
    Galaxy角色用于轻松管理您的部署。它被认为是Capistrano的Ansible端口。'
- en: 'Once we have Ansible available on our machine, it is very easy to install the
    Ansistrano roles with the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在我们的机器上有了Ansible，使用以下命令很容易安装Ansistrano角色：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After the execution of this command, you will be able to use Ansistrano in your
    playbooks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，您将能够在您的playbooks中使用Ansistrano。
- en: How does Ansistrano work?
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ansistrano是如何工作的？
- en: 'Ansistrano deploys your application following the Capistrano flow:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Ansistrano遵循Capistrano流程部署您的应用程序：
- en: '**Setup phase**: In this phase, Ansistrano creates the folder structure that will
    hold the application releases.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置阶段**：在此阶段，Ansistrano创建将容纳应用程序发布的文件夹结构。'
- en: '**Code update phase**: In this phase, Ansistrano puts your release in your
    hosts; it can use rsync, Git, or SVN among other methods.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码更新阶段**：在此阶段，Ansistrano将您的发布放在您的主机上；它可以使用rsync、Git或SVN等其他方法。'
- en: '**Symlink phase** (see below): After the new release is deployed, it changes
    the current softlink that points the available release to the new release location.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**符号链接阶段**（见下文）：在部署新发布后，它会更改当前软链接，将可用发布指向新发布位置。'
- en: '**Cleanup phase**: In this phase Ansistrano removes old releases stored in
    your hosts. You can configure the number of releases in your playbooks through
    the `ansistrano_keep_releases` parameter. In following examples you will se how
    this parameter works'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**清理阶段**：在此阶段，Ansistrano会删除存储在您的主机上的旧发布。您可以通过`ansistrano_keep_releases`参数在您的playbooks中配置发布的数量。在以下示例中，您将看到此参数的工作方式'
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: With Ansistrano, you can hook custom tasks to be executed before and after each
    task.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansistrano，您可以挂钩自定义任务以在每个任务之前和之后执行。
- en: 'Let''s look at a simple example to explain how it works. Imagine that your
    application is deployed to `/var/www/my-application`; the contents of this folder
    will be similar to the following example after your first deployment:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的示例来解释它是如何工作的。假设你的应用程序部署到`/var/www/my-application`；在第一次部署后，这个文件夹的内容将类似于以下示例：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see from the preceding example, the current symlink points to the
    first release we have in our host. Your application will always be available in
    the same path, `/var/www/my-application/current`, so you can use this path in
    any place you need, for example, NGINX or PHP-FPM.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，当前的符号链接指向我们在主机上拥有的第一个版本。你的应用程序将始终可在相同路径`/var/www/my-application/current`中使用，因此你可以在任何需要的地方使用这个路径，例如NGINX或PHP-FPM。
- en: 'As your deployments continue, Ansistrano will deal with the deploys for you.
    The next example will show you what your application folder will look like after
    a second deployment:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的部署继续进行，Ansistrano将为你处理部署。下一个示例将展示在第二次部署后你的应用程序文件夹将会是什么样子：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see from the preceding example, now we have two releases in our
    hosts and symlink was updated to point to the new version of your code. What happens
    if you do a rollback with Ansistrano? Easy, this tool will remove the latest release
    you have in your hosts and update the symlink. In our example, your application
    folder content will be similar to this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，现在我们的主机上有两个版本，并且符号链接已更新，指向你的代码的新版本。如果你使用Ansistrano进行回滚会发生什么？很简单，这个工具将删除你的主机上的最新版本，并更新符号链接。在我们的示例中，你的应用程序文件夹内容将类似于这样：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To avoid problems, if you try to roll back and Ansistrano can't find a previous
    version to move to, it will do nothing, keeping your hosts without changes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免问题，如果你尝试回滚并且Ansistrano找不到要移动到的先前版本，它将不执行任何操作，保持你的主机没有变化。
- en: Deploying with Ansistrano
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Ansistrano进行部署
- en: Now, let's create a small automation system with Ansible and Ansistrano. We
    are assuming that you have a known and persistent infrastructure available where
    you will push your app or microservice. Create a folder in your development environment
    to keep all your deployment scripts.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Ansible和Ansistrano创建一个小型的自动化系统。我们假设你有一个已知且持久的基础架构可用，你将在其中推送你的应用程序或微服务。在你的开发环境中创建一个文件夹，用于存放所有的部署脚本。
- en: In our case, we previously created three VMs in our local environment with SSH
    enabled. Note that we are not covering the provisioning of those VMs but if you
    want, you can even use Ansible to do it for you.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们之前在本地环境中创建了三个启用了SSH的虚拟机。请注意，我们没有涵盖这些虚拟机的配置，但如果你愿意，你甚至可以使用Ansible来为你完成这些配置。
- en: 'The first thing you need to create is a `hosts` file. In this file, you can
    store and group all your servers/hosts so that you can later use them in the deployment:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建的第一件事是一个`hosts`文件。在这个文件中，你可以存储和分组所有的服务器/主机，以便以后在部署中使用它们：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding configuration, we created two groups of hosts-–`production`
    and `staging`. On each one of them, we have a few hosts available; in our case,
    we set up the IP address of our local VM for testing purposes, but you can use
    URIs if you want. One of the advantages of grouping your hosts is the ability
    you have to even create bigger groups; for example, you can create a group formed
    by other groups. For example, we have a `servers` group that wraps all the production
    and staging hosts. If you are wondering what happens if you have a dynamic environment,
    no problem; Ansible has your back and comes with multiple connectors that you
    can use to get your dynamic infrastructure, for example, from AWS or Digital Ocean,
    among others.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的配置中，我们创建了两组主机-`production`和`staging`。在每一个组中，我们有一些可用的主机；在我们的情况下，我们设置了我们本地虚拟机的IP地址以进行测试，但如果你愿意，你也可以使用URI。将主机分组的一个优势是你甚至可以创建更大的组；例如，你可以创建一个由其他组组成的组。例如，我们有一个`servers`组，包含了所有的生产和测试主机。如果你想知道如果你有一个动态环境会发生什么，没问题；Ansible可以帮你，并提供了多个连接器，你可以使用它们来获取你的动态基础架构，例如来自AWS或Digital
    Ocean等。
- en: 'Once you have your `hosts` file ready, it is time to create our `deploy.yml`
    file where we will store all the tasks we want to execute in our deployment. Create
    a `deploy.yml` file with the following content:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的`hosts`文件准备好了，现在是时候创建我们的`deploy.yml`文件了，我们将在其中存储所有我们想要在部署中执行的任务。创建一个包含以下内容的`deploy.yml`文件：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Thanks to Ansistrano, our deployment tasks are very easy to define, as you can
    see from the preceding example. What we did is create a new task that will be
    executed in all the hosts wrapped under the tag servers, and define a few variables
    available for the Ansistrano role. Here, we defined where we will deploy our application
    on each host, the method we will use for the deploy (Git), how many releases we
    will keep in the hosts (5), and the branch we want to deploy.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Ansistrano，我们的部署任务非常容易定义，如前面的示例所示。我们所做的是创建一个新任务，它将在标记为servers的所有主机上执行，并为Ansistrano角色定义一些可用的变量。在这里，我们定义了我们将在每个主机上部署我们的应用程序的位置，我们将使用的部署方法（Git），我们将在主机上保留多少个版本（5），以及我们想要部署的分支。
- en: 'An interesting feature of Ansible is that you can pass variables from the command
    line to your generic deployment process. This is what we do in the following line:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的一个有趣的特性是你可以从命令行传递变量到你的通用部署过程中。这就是我们在下面这行中所做的：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we are using a `GIT_BRANCH` variable to define which branch we want to
    deploy; if Ansible can't find this defined variable, it will use master.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`GIT_BRANCH`变量来定义我们想要部署的分支；如果Ansible找不到这个定义的变量，它将使用master分支。
- en: 'Are you ready to test what we have done? Open a terminal and go to the location
    where you have stored the deployment tasks. Imagine that you want to deploy the
    latest versions of your code to your production hosts; you can do it with the
    following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好测试我们所做的了吗？打开一个终端，转到存储部署任务的位置。假设你想要将最新版本的代码部署到生产主机上，你可以使用以下命令来完成：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding command, we are telling Ansible to use our `deploy.yml` playbook
    and we also defined our `GIT_BRANCH` to be master so that this branch will be
    deployed. As we have all our hosts in the hosts file and we only want to make
    the deployment to the `production` hosts, we limited the execution to the desired
    hosts with `--limit` `production`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，我们告诉Ansible使用我们的`deploy.yml` playbook，并且我们还定义了我们的`GIT_BRANCH`为master，以便部署该分支。由于我们在hosts文件中有所有的主机，并且我们只想将部署限制在`production`主机上，我们使用`--limit`
    `production`将执行限制到所需的主机。
- en: 'Now, imagine that you have a new version ready, all your code was committed
    and tagged under the `v1.0.4` tag, and you want to push this release to your staging
    environment. You can do it with a very simple command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，您已经准备好一个新版本，您的所有代码都已提交并标记为`v1.0.4`标签，您想将此版本推送到您的演示环境。您可以使用一个非常简单的命令来完成：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, deploying your application is very easy with Ansible/Ansistrano
    and it is even easier to roll back to a previously deployed release. To manage
    the rollbacks, you only need to create a new playbook. Create a `rollback.yml`
    file with the following content:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用Ansible/Ansistrano部署您的应用非常容易，甚至可以更轻松地回滚到先前部署的版本。要管理回滚，您只需要创建一个新的playbook。创建一个名为`rollback.yml`的文件，内容如下：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding piece of code, we are using the Ansistrano rollback role to
    move to the previous deployed release. If you only have one release in your hosts,
    Ansible will not undo the changes because it is not possible. Do you remember
    the variable we set up in the `deploy.yml` file, called `ansistrano_keep_releases`?
    This variable is very important to know how many rollbacks you can do in your
    hosts, so adjust it to your needs. To roll back your production servers to the
    previous release, you can use the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们使用了Ansistrano回滚角色来回滚到先前部署的版本。如果您的主机中只有一个版本，Ansible将不会撤消更改，因为这是不可能的。您还记得我们在`deploy.yml`文件中设置的名为`ansistrano_keep_releases`的变量吗？这个变量非常重要，可以知道您的主机上可以执行多少次回滚，因此根据您的需求进行调整。要将生产服务器回滚到先前的版本，您可以使用以下命令：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, Ansible is a very powerful tool that you can use for your deployments,
    but it is not used only for deployments; you can even use it for orchestration,
    for example. With a vibrant community and with RedHat supporting the project,
    Ansible is a necessary tool.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Ansible是一个非常强大的工具，您可以用它进行部署，但它不仅仅用于部署；您甚至可以用它进行编排，例如。有了充满活力的社区和RedHat支持该项目，Ansible是一个必不可少的工具。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Ansible has an enterprise version of a web tool that you can use to manage all
    your Ansible playbooks. Even though it needs a paid subscription, if you manage
    less than ten nodes, you can use it for free.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible有一个企业版的Web工具，您可以用它来管理所有的Ansible playbooks。尽管它需要付费订阅，但如果您管理的节点少于十个，您可以免费使用它。
- en: Other deployment tools
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他部署工具
- en: 'As you can imagine, there are multiple and different tools that you can use
    to do your deployments and we cannot cover all of them in this book. We wanted
    to show you a simple one (PHP scripts) and a more complex and powerful one (Ansible),
    but we don''t want you to finish this chapter without knowing the other tools
    that you can use:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以想象的，有多种不同的工具可以用来进行部署，我们无法在本书中涵盖所有这些工具。我们想向您展示一个简单的（PHP脚本）和一个更复杂和强大的（Ansible），但我们不希望您在不了解其他可以使用的工具的情况下完成本章：
- en: '**Chef**: This is an interesting open source tool you can use to manage your
    infrastructure as code.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef：这是一个有趣的开源工具，您可以用它来管理基础架构作为代码。
- en: '**Puppet**: This is an open source configuration management tool with a paid
    enterprise version.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet：这是一个开源的配置管理工具，有一个付费的企业版本。
- en: '**Bamboo**: This is a continuous integration server from Atlassian and, of
    course, you need to pay to use this tool. This is the most complete tool you can
    use combine with the Atlassian catalog of products.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bamboo：这是Atlassian的一个持续集成服务器，当然，您需要付费才能使用这个工具。这是您可以与Atlassian产品目录结合使用的最完整的工具。
- en: '**Codeship**: This is a cloud continuous deployment solution that aims to be
    a tool focused on being an end-to-end solution for running tests and deploying
    apps'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Codeship：这是一个云持续部署解决方案，旨在成为一个专注于运行测试和部署应用的端到端解决方案的工具
- en: '**Travis CI**: This is a similar tool to Jenkins used for continuous integration;
    you can also use it to make your deployments.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Travis CI：这是一个类似于Jenkins用于持续集成的工具；您也可以使用它进行部署。
- en: '**Packer, Nomad, and Terraform**: These are different tools from HashiCorp
    that you can use to write your infrastructure as code.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Packer、Nomad和Terraform：这些是HashiCorp的不同工具，您可以用它们来编写您的基础架构作为代码。
- en: '**Capistrano**: This is a well-known remote server automation and deployment
    tool, which is easy to understand and easy to use.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Capistrano：这是一个众所周知的远程服务器自动化和部署工具，易于理解和使用。
- en: Advanced deployment techniques
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级部署技术
- en: In the previous section, we showed you some ways you can deploy your application.
    Now, it's time to increase the level of complexity with some advanced techniques
    used on big deployments.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们向您展示了一些部署应用程序的方法。现在，是时候使用一些在大型部署中使用的高级技术来增加复杂性了。
- en: Continuous integration with Jenkins
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Jenkins进行持续集成
- en: 'Jenkins is the most known continuous integration application; being an open
    source project allows you to create your own pipeline with high flexibility. It
    was built in Java, so this is the main requirement you have if you want to install
    this tool. With Jenkins, everything is easier, even the installation. For example,
    you can spin up a Docker container with the last version with only a few commands:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是最知名的持续集成应用程序；作为一个开源项目，它允许您以高度灵活的方式创建自己的流水线。它是用Java构建的，因此这是您安装此工具时的主要要求。使用Jenkins，一切都更容易，甚至安装。例如，您可以只用几个命令启动一个带有最新版本的Docker容器：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding command will download and create a new container with the latest
    Jenkins version, ready to use.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将下载并创建一个带有最新Jenkins版本的新容器，准备好使用。
- en: 'The main idea behind Jenkins is the concept of a job. A job is a sequence of
    commands or steps you can execute automatically or by hand. With jobs and the
    use of plugins (available to download from the web UI), you can create your custom
    workflow. For example, you can create a workflow similar to the next one that is
    fired by your repository as soon as a commit/push happens:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins背后的主要思想是工作的概念。工作是一系列可以自动或手动执行的命令或步骤。通过工作和插件的使用（可以从Web UI下载），你可以创建自定义的工作流程。例如，你可以创建一个类似下一个的工作流程，它会在提交/推送发生时由你的存储库触发：
- en: A unit test plugin starts testing your application.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个单元测试插件开始测试你的应用程序。
- en: As soon as it passes, a code sniffer plugin checks your code.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦通过，一个代码嗅探器插件检查你的代码。
- en: If the previous steps are okay, Jenkins connects through SSH to a remote host.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前面的步骤都没问题，Jenkins通过SSH连接到远程主机。
- en: Jenkins pulls all the changes in the remote host.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins拉取远程主机中的所有更改。
- en: The preceding example is an easy one; you can improve and complicate the example
    more, firing an Ansible playbook instead of using SSH.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子很简单；你可以改进和复杂化这个例子，使用Ansible playbook而不是SSH。
- en: This application is so versatile that you can use it in any you want. For example,
    you can use it to check the replication status of your Master-Slave database.
    In our opinion, this application is worth a try and you can find examples of any
    kinds of tasks adapted to this software.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序非常灵活，你可以用它来检查主从数据库的复制状态。在我们看来，这个应用程序值得一试，你可以找到适应这个软件的各种任务的例子。
- en: Blue/Green deployment
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: 'This deployment technique relies on having a duplicate of your infrastructure
    so that you can have a new version of your application installed in parallel with
    the current version. In front of your application, you have a router or **Load
    Balancer** (LB) that is used to redirect the traffic to the desired version. As
    soon as you have your new version ready, you only need to change your router/LB
    to redirect all the traffic to the new version. Having two sets of releases gives
    you the flexibility and advantage of easy rollbacks and also gives you time to
    ensure that the new version works fine. Refer to the following diagram:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种部署技术依赖于拥有基础设施的副本，这样你就可以在当前版本的应用程序旁边安装新版本。在应用程序前面，你有一个路由器或**负载均衡器**（LB），用于将流量重定向到所需的版本。一旦你的新版本准备好，你只需要更改你的路由器/LB，将所有流量重定向到新版本。拥有两套发布版本可以让你灵活地进行回滚，并且可以确保新版本运行良好。参考以下图表：
- en: '![Blue/Green deployment](graphics/B06142_08_01.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![蓝绿部署](graphics/B06142_08_01.jpg)'
- en: Blue/Green deployment on microservices
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的蓝绿部署
- en: As you can see from the preceding image, the Blue/Green deployment can be done
    at any level of your application. In our example image, you can spot a microservice
    that is getting ready to deploy a new version but has not been released yet, and you
    can see that some microservices released the latest version of their code, keeping
    the previous one for rollback.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从上面的图像中看到的，蓝绿部署可以在应用程序的任何级别进行。在我们的示例图像中，你可以看到一个微服务正在准备部署一个新版本，但尚未发布，你还可以看到一些微服务发布了他们的最新代码版本，保留了以前的版本以便回滚。
- en: This technique is widely used by big tech companies without any kinds of problems;
    the main disadvantage is the increased amount of resources you need to run your
    application--more resources means more money to be spent on your infrastructure.
    If you want to give it a try, the most-used load balancers on this kind of deployments
    are **ELB**, **Fabio**, and **Traefik**, among others.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被大型科技公司广泛使用，没有任何问题；主要的缺点是你需要运行应用程序的资源增加了--更多的资源意味着在基础设施上花更多的钱。如果你想试一试，这种部署中最常用的负载均衡器是**ELB**、**Fabio**和**Traefik**等。
- en: Canary releases
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金丝雀发布
- en: '**Canary releases** is a similar deployment technique to the Blue/Green one
    with a subtle difference--only a small amount of hosts are upgraded at the same
    time. Once you have a portion of your hosts with the release you want, using a
    cookie, a lb, or a proxy, a fraction of the traffic is redirected to the new version.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**金丝雀发布**是一种类似于蓝绿部署的部署技术，只是一次只升级少量主机。一旦你有了你想要的部分主机的发布版本，使用cookie、lb或代理，一部分流量被重定向到新版本。'
- en: 'This technique allows you to test your changes with a small portion of your
    traffic; if the application behaves as expected, we continue migrating more hosts
    to the new version until all the traffic is redirected to the new version of your
    application. Take a look at the following diagram:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术允许你用一小部分流量测试你的更改；如果应用程序表现如预期，我们继续将更多主机迁移到新版本，直到所有流量都被重定向到你的应用程序的新版本。看一下下面的图表：
- en: '![Canary releases](graphics/B06142_08_02.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![金丝雀发布](graphics/B06142_08_02.jpg)'
- en: Canary releases with microservices
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的金丝雀发布
- en: As you can see from the preceding image, there are four instances of some microservices;
    three of them keep the old version of the application and only one has the latest
    version. The LB is used to split the traffic between the different versions, sending
    the majority of the traffic to the **v1.0.0** and only a small portion of the
    traffic to the **v2.0.0**. If everything is fine, the next step will be increasing
    the number of **v2.0.0** instances, reducing the number of **v1.0.0** instances,
    and redirecting more traffic to the new versions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从上面的图像中看到的，有四个微服务实例；其中三个保留了旧版本的应用程序，只有一个有最新版本。LB用于在不同版本之间分配流量，将大部分流量发送到**v1.0.0**，只有一小部分流量发送到**v2.0.0**。如果一切正常，下一步将是增加**v2.0.0**实例的数量，减少**v1.0.0**实例的数量，并将更多的流量重定向到新版本。
- en: This deployment technique adds a little bit of complexity to your current infrastructure,
    but allows you to start testing your changes with small portions of users/traffic.
    Another benefit is the reuse of your existing infrastructure; you don't need to
    have duplicated set of hosts to make your deployments.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种部署技术会给您当前的基础设施增加一些复杂性，但允许您开始使用小部分用户/流量测试您的更改。另一个好处是重复使用您现有的基础设施；您不需要复制一套主机来进行部署。
- en: Immutable infrastructure
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变基础设施
- en: These days, a trend in the tech industry is to use immutable infrastructure.
    When we say immutable infrastructure, we mean that what you have in your development
    environment is later deployed to production without any changes. You can achieve
    this thanks to the containerization technology and some tools, such as Packer.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，技术行业的一个趋势是使用不可变基础设施。当我们说不可变基础设施时，我们的意思是您在开发环境中拥有的内容稍后会在没有任何更改的情况下部署到生产环境中。您可以通过容器化技术和一些工具（如Packer）实现这一点。
- en: With Packer, you can create an image of your application and later distribute
    this image through your infrastructure. The main benefit of this technique is
    that you ensure that your production environment will behave like your development.
    Another important aspect is security; imagine that there is a security breach
    in your NGINX container, a new release with the base image update will solve the
    issue and it will be propagated with your application without the need of external
    intervention.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Packer，您可以创建应用程序的映像，然后通过您的基础设施分发这个映像。这种技术的主要好处是您确保您的生产环境的行为与您的开发环境相同。另一个重要的方面是安全性；想象一下您的NGINX容器中发生了安全漏洞，通过基础映像更新的新版本将解决问题，并且将在不需要外部干预的情况下与您的应用程序一起传播。
- en: Backup strategies
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份策略
- en: In any project, the backup is one of the most important ways to avoid losing
    data. In this chapter, we will learn the backup strategies to be used in your
    application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何项目中，备份是避免数据丢失的最重要方式之一。在本章中，我们将学习在应用程序中使用的备份策略。
- en: What is backup?
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是备份？
- en: '**Backup** is the process of saving code or data in a different place to where
    the code or data is usually stored. This process can be done using different strategies,
    but all of them have the same goal--not to lose data in order for it to be accessed
    in the future.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**备份**是将代码或数据保存在与通常存储代码或数据的地方不同的地方的过程。这个过程可以使用不同的策略来完成，但它们都有相同的目标--不丢失数据，以便将来可以访问。'
- en: Why is it important?
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么重要？
- en: A backup can be done for two reasons. The first one is the loss of data due
    to a hack attack, corrupted data, or any mistakes executing queries on the production
    server. This backup will help restore the lost or corrupted data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 备份可以出于两个原因而进行。第一个原因是由于黑客攻击、数据损坏或在生产服务器上执行查询时出现任何错误而导致数据丢失。此备份将帮助恢复丢失或损坏的数据。
- en: The second reason is policy. The law says that it is required to store user
    data for years. Sometimes, this functionality is done by a system, but a backup
    is another way to store this data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是政策。法律规定必须保存用户数据多年。有时，这个功能是由系统完成的，但备份是存储这些数据的另一种方式。
- en: To sum up, backups allow us to be calm. We ensure that we are doing things properly
    and in case any disasters happen, we have a solution to fix them fast and without
    (significant) data loss.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，备份让我们保持冷静。我们确保我们正在正确地做事情，并且在任何灾难发生时，我们有解决方案可以快速修复它们，而且没有（重大的）数据丢失。
- en: What and where we need to back up
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们需要备份什么和在哪里备份
- en: If we are using some repositories, such as Git, in our application, this can
    be our backup place for the files. The assets or any other files uploaded by users
    should be backed up too.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在应用程序中使用一些仓库，比如Git，这可以是我们的文件备份位置。用户上传的资产或其他文件也应该备份。
- en: A good practice to see if we are backing up all the necessary files is reviewing
    the `.gitignore` file and ensuring that we have backed up all the files and folders
    included in that folder.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`.gitignore`文件并确保我们已备份该文件夹中包括的所有文件和文件夹是备份所有必要文件的一个良好做法。
- en: Also, the most important and precious thing to back up is the database. This
    should be backed up more frequently.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，最重要和宝贵的备份是数据库。这应该更频繁地备份。
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not store a backup in the same place where the application is working. Try
    to have different locations for the backup copies.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将备份存储在应用程序正在运行的相同位置。尝试为备份副本选择不同的位置。
- en: Backup types
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份类型
- en: 'The backups can be full, incremental, or differential. We will look at the
    difference between them and how they work. Applications usually combine different
    backup types: a full backup with incremental or differential backups.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 备份可以是完整的、增量的或差异的。我们将看看它们之间的区别以及它们的工作原理。应用程序通常将不同类型的备份结合在一起：完整备份与增量或差异备份。
- en: Full backup
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整备份
- en: The full backup is the basic one; it consists of generating a full copy of the
    current application. This option is used by large applications periodically, and
    small applications can use it daily.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 完整备份是基本备份；它包括生成当前应用程序的完整副本。大型应用程序定期使用此选项，而小型应用程序可以每天使用它。
- en: 'The advantages are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 优点如下：
- en: The full application is backed up in a single file
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的应用程序备份在一个文件中
- en: It always generates a full copy
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它总是生成完整副本
- en: 'The disadvantages are as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点如下：
- en: The time to generate it can be very long
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成它可能需要很长时间
- en: The backup will need a lot of disk space
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份将需要大量的磁盘空间
- en: Please note that it's generally good practice to include date/time in the backup
    file name so you can know when was created only looking to the file name.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通常最好在备份文件名中包含日期/时间，这样您只需查看文件名就可以知道何时创建的。
- en: Incremental and differential backups
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增量和差异备份
- en: The incremental backup copies the data that has changed since the last backup.
    The `datetime` should be included in this kind of backup in order to be checked by
    the backup tools the next time a new backup is generated.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 增量备份复制自上次备份以来发生变化的数据。这种备份应该包括`datetime`，以便在下次生成新备份时由备份工具检查。
- en: 'The advantages are as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: It is faster than a full backup
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes up less disk space
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The entire application is not stored in a single generated backup
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is another type, called **differential**. This is like the incremental
    backup (copying all the data that has changed since the last backup); it is executed
    the first time and then it will continue copying all the modified data from the
    last full backup.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: So, it will generate more data than the incremental one but less than the full
    one after the first time. This type is an intermediate one between full and incremental.
    It needs more space and time than incremental and less than full.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Backup tools
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to find many backup tools. The most common tool in large projects
    is Bacula. There are other similar ones for small projects like a custom script
    that will be run frequently.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Bacula
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bacula** is a backup management tool. This application manages and automates
    the backup tasks and it is perfect for large applications. This tool is a little
    complex to set up, but once you have it ready, it does not need any other changes
    and it will work without any problems.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Three different parts exist on Bacula, and every single part needs to be installed
    in a different package:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '**Director**: This manages all the backup processes'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: This is where the backup is stored'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File**: This is the client machine where we have our application running'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our application based on microservices, we will have many files (one for
    each microservice) and optionally, many storage locations (in order to have different
    locations for the backups) and directors.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: This tool works with daemons. Each part has its own daemon and each daemon works
    following its own config files. The config files are set up in the installation
    process, and it is only necessary to change some little things, such as the remote
    IP address, certificates, or the plan to automate backups.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The security of Bacula is really amazing--every part (director, storage, and
    file) has its own key and depending on the connection, it is encrypted using it.
    Also, Bacula allows TLS connections for more security.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Bacula allows you to do full, incremental, or differential backups, and they
    can be automated on the director's part.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Percona xtrabackup
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**XtraBackup** is an open source tool to do hot database backups on your application
    without blocking the database. This is possibly the most important feature of
    this application.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: This tool allows MySQL databases, such as MariaDB and Percona, to perform streaming
    and compression and do incremental backups.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages are as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Fast backups and restores
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uninterrupted transaction processing during the backups
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saves disk space and network bandwidth
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic backup verification
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom scripts
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fastest way to create backups is to use a custom script in production. This
    is a script that when it runs, it creates a backup by doing a `mysqldump` (if
    we are using a MySQL database), compressing the desired files, and putting them
    in the desired location (ideally, remotely on a different machine).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: These scripts should be executed by a cronjob that can be set up to run them
    every day or week.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Validating backups
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As part of the backup strategies, it is a good practice to have techniques to
    validate the data stored on the backups. If you have backups with errors, it is
    like not having any backups at all.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In order to check that our backups are valid, are not corrupted, and they work
    as expected, it is necessary to frequently do a mock restore to avoid failure
    if we need to restore them in the future.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Be ready for the apocalypse
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No one wants to have to restore a backup, but it is necessary to be ready in
    case any of your microservices are broken or corrupted and we have to react fast.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The first step is knowing where the most recent backup of your application is
    in order to restore it as soon as possible.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: If the problem is related to the database, we have to put the application under
    maintenance, restore the database backup, check that it works properly, and then,
    make the application live again.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题与数据库有关，我们必须使应用程序停机，恢复数据库备份，检查其是否正常工作，然后再次使应用程序上线。
- en: If the problem is related to something like assets or files, it is possible
    to restore without putting the application under maintenance.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题与资产或文件之类的东西有关，可以在不使应用程序停机的情况下进行恢复。
- en: Keep calm and get your backup.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 保持冷静并备份你的数据。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now you know how to deploy your application to production and automate the deployment process.
    Also, you learned what you have to deploy and that you can get it from any dependency
    management, how to do a rollback if necessary, and the different strategies to
    back up your application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何将你的应用程序部署到生产环境并自动化部署过程。此外，你还学会了需要部署什么以及可以从任何依赖管理中获取它，如何在必要时进行回滚，以及备份应用程序的不同策略。

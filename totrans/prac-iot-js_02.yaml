- en: IoTFW.js - I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter and [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - II*, we are going to develop a reference architecture for building
    various IoT solutions. The reference architecture or the IoT framework will be
    serving as a base for our future IoT solutions that we are going to be working
    on in this book. We will be calling this reference architecture or framework as
    IoTFW.js. We will be working on the following topics to bring IoTFW.js to life:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing an IoTFW.js architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a Node.js based server-side layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing an Angular 4 based web app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing an Ionic 3 based mobile app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing an Angular 4 and Electron.js desktop app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and installing the required dependencies on a Raspberry Pi 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating all the pieces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to cover some of the previous topics in this chapter and some in
    [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee), *IoTFW.js
    - II*.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a reference architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in [Chapter 1](part0024.html#MSDG0-ce91715363d04669bca1c1545beb57ee),
    *The World of IoT*, all the examples we are going to work on have a common setup.
    That would be the hardware, firmware (software running on the hardware), broker,
    API engine and the user apps.
  prefs: []
  type: TYPE_NORMAL
- en: We will be expanding on the relevant pieces of framework as we come across it.
  prefs: []
  type: TYPE_NORMAL
- en: As and when we need to, we will be expanding on the hardware, or mobile app,
    or the API engine.
  prefs: []
  type: TYPE_NORMAL
- en: With this reference architecture, we are going to establish a pipeline between
    the devices present in the real world to the cloud in the virtual world. In other
    words, IoT is a last mile solution between devices and the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple reference architecture with Raspberry Pi, Wi-Fi gateway, the cloud
    engine, and the user interface apps stitched together would look as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At a very high level, we have smart devices on the left-hand side and the user
    devices on the right-hand side. All of the communication between them happens
    through the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Following is a description of each key entity in the previous architecture.
    We are going to start from the left-hand side and move towards the right.
  prefs: []
  type: TYPE_NORMAL
- en: Smart device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart devices are hardware entities that consist of a sensor, or actuator, or
    both, any micro controller or micro processor, in our case, a Raspberry pi 3.
  prefs: []
  type: TYPE_NORMAL
- en: A sensor is an electronic component that can sense or measure a physical property
    and relay it back to a microcontroller or a microprocessor. The data relayed back
    can be periodic or event-driven; event-driven as in when there is change in data
    only. A temperature sensor such as an LM35 or DHT11 is an example of a sensor.
  prefs: []
  type: TYPE_NORMAL
- en: An actuator is also an electro-mechanical component that can trigger actions
    in the real world. Generally, the actuators do not act by themselves. A microcontroller,
    a microprocessor, or an electronic logic sends signals to the actuator. An example
    of an actuator is a mechanical relay.
  prefs: []
  type: TYPE_NORMAL
- en: The micro-processor we were referring would be a Raspberry Pi 3 for this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi 3 is a single-board computer, designed and developed by the
    Raspberry Pi foundation. The Raspberry Pi 3 is the third-generation Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we are going to use a Raspberry Pi 3 model B for all the examples.
    Some of the specifications of the Raspberry Pi 3 model B are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Specification** |'
  prefs: []
  type: TYPE_TB
- en: '| Generation | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Release date | February 2016 |'
  prefs: []
  type: TYPE_TB
- en: '| Architecture | ARMv8-A (64/32-bit) |'
  prefs: []
  type: TYPE_TB
- en: '| System on a Chip (SoC) | Broadcom BCM2837 |'
  prefs: []
  type: TYPE_TB
- en: '| CPU | 1.2 GHz 64-bit quad-core ARM Cortex-A53 |'
  prefs: []
  type: TYPE_TB
- en: '| Memory (SDRAM) | 1 GB (shared with GPU) |'
  prefs: []
  type: TYPE_TB
- en: '| USB 2.0 ports | 4 (via the on-board 5-port USB hub) |'
  prefs: []
  type: TYPE_TB
- en: '| On-board network | 10/100 Mbit/s Ethernet, 802.11n wireless, Bluetooth 4.1
    |'
  prefs: []
  type: TYPE_TB
- en: '| Low-level peripherals | 17× GPIO plus the same specific functions, and HAT
    ID bus |'
  prefs: []
  type: TYPE_TB
- en: '| Power ratings | 300 mA (1.5 W) average when idle, 1.34 A (6.7 W) maximum
    under stress (monitor, keyboard, mouse, and Wi-Fi connected) |'
  prefs: []
  type: TYPE_TB
- en: '| Power source | 5 V via MicroUSB or GPIO header |'
  prefs: []
  type: TYPE_TB
- en: 'For more information on the specifications, please refer to the specifications
    of Raspberry Pi: [https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications](https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications).'
  prefs: []
  type: TYPE_NORMAL
- en: Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next piece in our architecture is the Wi-Fi router. A common household Wi-Fi
    router will act as a gateway for us. As we have seen in [Chapter 1](part0024.html#MSDG0-ce91715363d04669bca1c1545beb57ee),
    *The World of IoT*, in the *Clustered devices versus standalone devices* section,
    we are following the approach of standalone devices, where each device is self-sufficient
    and has a radio of its own to communicate with the outside world. All the projects
    we are going to build consist of a Raspberry Pi 3, which has a microprocessor
    as well as the radio to interface with the sensors, and actuators with the internet.
  prefs: []
  type: TYPE_NORMAL
- en: MQTTS broker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next important piece in our reference framework is the secure communication
    channel between the device and the cloud. We are going to use MQTT as our communication
    channel. MQTT is described in the following quote from [http://mqtt.org/faq](http://mqtt.org/faq):'
  prefs: []
  type: TYPE_NORMAL
- en: MQTT stands for MQ Telemetry Transport. It is a publish/subscribe, extremely
    simple and lightweight messaging protocol, designed for constrained devices and
    low-bandwidth, high-latency or unreliable networks. The design principles are
    to minimise network bandwidth and device resource requirements whilst also attempting
    to ensure reliability and some degree of assurance of delivery.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the MQTT over SSL or MQTTS. In our architecture, we are
    going to use Mosca ([http://www.mosca.io/](http://www.mosca.io/)) as our MQTTS
    broker. Mosca is a Node.js MQTT broker. We will talk more about Mosca when we
    start working with it.
  prefs: []
  type: TYPE_NORMAL
- en: API engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An API engine is a web server application, written on Node.js, Express with
    persistence layer as MongoDB. This engine is responsible for communicating with
    Mosca as a MQTT client, persisting data into MongoDB as well as to expose APIs
    using Express. These APIs are then consumed by the apps to display the data.
  prefs: []
  type: TYPE_NORMAL
- en: We will also be implementing a socket-based API for user interfaces to get notified
    in real time from the devices between the apps and the server.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to use MongoDB as our data persistence layer. MongoDB is a NoSQL
    document database that allows us to save documents with different schemas in one
    collection. This kind of database is well suited for dealing with sensor data
    from various devices, as the data structure or the parameters vary from solution
    to solution. To know more about MongoDB, refer to [https://www.mongodb.com/](https://www.mongodb.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web app is a simple web/mobile web interface, which will implement the APIs
    exposed by the API engine. These APIs will include authentication, access a particular
    smart device, get the latest data from the smart device, and send data back to
    the smart device over APIs. We are going to use Angular 4 ([https://angular.io/](https://angular.io/))
    and Twitter Bootstrap 3 ([http://getbootstrap.com/](http://getbootstrap.com/))
    technologies to build the web app.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to follow a mobile hybrid approach for building our mobile app.
    The mobile app implements the APIs exposed by the API engine. These APIs will
    include authentication, access a particular smart device, get the latest data
    from the smart device and send data back to the smart device over APIs. We are
    going to use Ionic 3 ([http://ionicframework.com/](http://ionicframework.com/)),
    which is powered by Angular 4, to build the mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Desktop app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to follow a desktop hybrid approach for building our desktop app.
    The desktop app will implement the APIs exposed by the API engine. These APIs
    will include authentication, access a particular smart device, get the latest
    data from the smart device, and send data back to the smart device over APIs.
    We are going to use Electron ([https://electron.atom.io/](https://electron.atom.io/))
    as the shell for building the desktop app. We will be using Angular 4 and Twitter
    Bootstrap 3 ([http://getbootstrap.com/](http://getbootstrap.com/)) technologies
    to build the desktop app. We try and reuse as much code as possible between the
    web and desktop apps.
  prefs: []
  type: TYPE_NORMAL
- en: Data flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an understanding of the various pieces of the architecture,
    we will now look at the data flow between the components. We are going to talk
    about the data flow from the smart device to the apps and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Smart device to the apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple flow of data from a sensor to a user device will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the previous figure, the data originates at the sensor;
    this data is read by the Raspberry Pi 3 and published to the MQTTS broker (Mosca)
    via the Wi-Fi router. Once the broker receives the data, it will send the same
    to the API engine, which will persist the data to the DB. Once the data has been
    successfully saved, the API engine will send the new data to our app, to show
    the data in real time.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to notice here is that the API engine will act as an MQTT
    client and subscribe to topics on which the device publishes the data. We will
    look at these topics when we go over the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the data in this flow would be a typical sensor transmitting data.
  prefs: []
  type: TYPE_NORMAL
- en: App to the smart device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram shows how the data flows from an app to the smart device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the previous diagram, if the app wishes to send an instruction
    to the smart device, it sends that message to the API engine. The API engine then
    persists that data into the database and publishes the same to the MQTTS broker,
    to be passed on to the device. The device then reacts to that data on the actuator.
  prefs: []
  type: TYPE_NORMAL
- en: Do note that in both the flows, the MQTTS broker manages the devices and the
    API engine manages the apps.
  prefs: []
  type: TYPE_NORMAL
- en: Building the reference architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to start putting together all the pieces and stitch
    together the required setup. We are going to start with Node.js installation,
    then the database, and after that, move on to other pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js on the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we continue with our development, we need Node.js on our server. The
    server here could be your own desktop, laptop, an AWS machine, or a digitalocean
    instance, which may or may not have a public IP ([https://www.iplocation.net/public-vs-private-ip-address](https://www.iplocation.net/public-vs-private-ip-address)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Node.js, navigate to [https://nodejs.org/en/](https://nodejs.org/en/)
    and download the appropriate version for your machine. Once installation is completed,
    you can test the installation by running the from a command prompt/terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You may have a later version than the one shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the required software, we will continue.
  prefs: []
  type: TYPE_NORMAL
- en: Installing nodemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have Node.js installed, we will install nodemon. This will take
    care of auto restarting our node application. Run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can follow one of the following two ways listed to set up the database.
  prefs: []
  type: TYPE_NORMAL
- en: Local installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can set up MongoDB on our server as a stand-alone installation. This way,
    the DB is running on the server and the data is persisted there.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your OS, you can follow the instructions provided at [https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)
    to set up the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed the DB, to test whether everything is working fine,
    you can open a new terminal and start the Mongo daemon by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I am running the database on the default port `27017`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will interact with the database using the mongo shell. Open a new command
    prompt/terminal and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take us to the `mongo` shell, using which we can interface with the
    MongoDB. The following are a few handy commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Description** | **Command** |'
  prefs: []
  type: TYPE_TB
- en: '| Show all databases | `show dbs` |'
  prefs: []
  type: TYPE_TB
- en: '| Use a specific database | `use local` |'
  prefs: []
  type: TYPE_TB
- en: '| Create a database | `use testdb` |'
  prefs: []
  type: TYPE_TB
- en: '| Check database in use | `db` |'
  prefs: []
  type: TYPE_TB
- en: '| Create a collection | `db.createCollection("user");` |'
  prefs: []
  type: TYPE_TB
- en: '| Show all collections in a DB | `show collections` |'
  prefs: []
  type: TYPE_TB
- en: '| (Create) insert a document in a collection | `db.user.insert({"name":"arvind"});`
    |'
  prefs: []
  type: TYPE_TB
- en: '| (Read) query a collection | `db.user.find({});` |'
  prefs: []
  type: TYPE_TB
- en: '| (Update) modify a document in collection | `db.user.update({"name": "arvind"},
    {"name" : "arvind2"}, {"upsert":true});` |'
  prefs: []
  type: TYPE_TB
- en: '| (Delete) Remove a document | `db.user.remove({"name": "arvind2"});` |'
  prefs: []
  type: TYPE_TB
- en: Using the previous commands, you can get acquainted with the Mongo shell. In
    our API engine, we are going to use Mongoose ODM ([http://mongoosejs.com/](http://mongoosejs.com/))
    to manage from the Node.js/Express--API engine.
  prefs: []
  type: TYPE_NORMAL
- en: Using mLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don’t want to go through the hassle of setting up the DB locally, you
    can use a MongoDB as a service such as mLab ([https://mlab.com/](https://mlab.com/))
    for this. In this book, I am going to follow this approach. Instead of having
    a local database, I will be using an instance of mLab.
  prefs: []
  type: TYPE_NORMAL
- en: To setup an mLab MongoDB instance, first navigate to [https://mlab.com/login/](https://mlab.com/login/)
    and login. If you do not have an account, you can create one by navigating to
    [https://mlab.com/signup/](https://mlab.com/signup/).
  prefs: []
  type: TYPE_NORMAL
- en: mLab has a free tier, which we are going to leverage to build our reference
    architecture. The free tire is perfect for development and prototyping projects
    like ours. Once we are done with the actual development and we are ready for a
    production grade application, we can look at some more reliable plans. You can
    get an idea of pricing at [https://mlab.com/plans/pricing/](https://mlab.com/plans/pricing/).`
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are logged in, click on the Create New button to create a new DB.
    Now, select amazon web services under Cloud Provider and then select the Plan
    Type as FREE, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And finally, name the database as `iotfwjs` and click on CREATE. And in a few
    seconds, a new MongoDB instance should be created for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the database has been created, open the `iotfwjs` DB. We should see a
    couple of warnings: one stating that this sandbox database should not be used
    for production, which we are aware of, and the second one that there is no database
    user present.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s go ahead and create one. Click on the Users tab and click on the
    Add database user button and fill in the form with the username as `admin` and
    password as `admin123` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can choose your own username and password and update it accordingly in the
    remaining part of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to test the connection to our database, use the section at the top of the
    page to connect using the `mongo` shell. In my case, it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open a new command prompt and run the following (after updating the mLab URL
    and credentials accordingly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be able to log in to the shell and we can run queries from here as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This completes our setup of MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: MQTTS broker - Mosca
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to put together the MQTTS broker. We are going
    to use Mosca ([http://www.mosca.io/](http://www.mosca.io/)) as a standalone service
    ([https://github.com/mcollina/mosca/wiki/Mosca-as-a-standalone-service](https://github.com/mcollina/mosca/wiki/Mosca-as-a-standalone-service)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder named `chapter2`. Inside the `chapter2` folder, create
    a new folder named `broker` and open a new command prompt/terminal inside the
    folder. Then run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will install Mosca and Pino globally. Pino ([https://github.com/pinojs/pino](https://github.com/pinojs/pino))
    is a Node.js logger, which logs all the messages to the console thrown by Mosca.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the default version of Mosca implements MQTT. But we want to secure our
    communication between the smart device and cloud to avoid man-in-the-middle attacks.
  prefs: []
  type: TYPE_NORMAL
- en: So, for us to set up MQTTS, we would need an SSL key and SSL certificate. To
    create the SSL key and certificate locally, we will use `openssl`.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether `openssl` is present on your machine, run `openssl version
    -a` and you should see the information about your local installation of `openssl`.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have `openssl`, you can download the same from [https://www.openssl.org/source/](https://www.openssl.org/source/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, inside the `broker` folder, create another folder named `certs` and `cd`
    into that folder. Run the following to generate the required key and certificate
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will prompt a few questions and you can fill in the same along the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This will create two new files inside the `certs` folder named `key.pem` and
    `certificate.pem`. We will be using these in our Mosca setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, at the root of the `broker` folder, create a new file named `index.js`
    and update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is the configuration with which we are going to launch Mosca.
    The config here loads the SSL certificates and keys and sets Mongo as our persistence
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save `index.js` and head back to the terminal/prompt and `cd` into the location
    where we have the `index.js` file. Next, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the previous, we are connected to the `iotfwjs` database
    and the broker is going to listen to port `8883` for connections.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up our setup of the MQTTS broker using Mosca.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we will implement the API engine and at that point, we are
    going to test the integration of the MQTTS broker with the API engine.
  prefs: []
  type: TYPE_NORMAL
- en: API engine - Node.js and Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to build the API engine. This engine interfaces
    with our apps and cascades the information from and to the smart device, connecting
    as an MQTT client with the broker.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we are going to clone a repository that we have created using
    a Yeoman ([http://yeoman.io/](http://yeoman.io/)) generator named `generator-node-express-mongo`
    ([https://www.npmjs.com/package/generator-node-express-mongo](https://www.npmjs.com/package/generator-node-express-mongo)).
    We have taken the code scaffolded by `generator-node-express-mongo` and modified
    it a bit for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Somewhere on your machine, download the complete code base of this book using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Or, you can download the zip file from [https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript](https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript)
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Once the repository has been downloaded, `cd` into the `base` folder and make
    a copy of `api-engine-base` folder into `chapter2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will download the `api-engine` boilerplate code. Once the `repo` is cloned,
    `cd` into the folder and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will install the needed dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the `cloned` folder, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This folder has all the bare bones needed for us to get started with our API
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the previous structure, we have a `package.json` at the
    root of the folder. This file consists of all the dependencies needed. We have
    also defined our startup script here.
  prefs: []
  type: TYPE_NORMAL
- en: All our application files are present inside the `server` folder. Everything
    starts at `api-engine/server/app.js`. We initialize `mongoose`, `express`, `socketio`,
    `config`, `routes`, and `mqtt`. And finally, we start our server and listen to
    port `9000` on `localhost` with the help of `server.listen()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`api-engine/server/config/express.js` has the required setup to initialize
    the Express middleware. `api-engine/server/config/socketio.js` consists of the
    logic needed to manage web sockets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using `api-engine/server/config/environment` to configure the environment
    variables. For most of the book, we are going to work with the development environment.
    If we open `api-engine/server/config/environment/development.js`, we should see
    the configuration for `mongo` and `mqtt`. Update them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Update the mongo URL as per your setup (mLab or local). Since we are going to
    connect to the Mosca broker running on our local machine, we are using `127.0.0.1`
    as the host.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we are going to look at out-of-the-box auth. We will be using **JSON Web
    Tokens** (**JWTs**) to authenticate the clients that are going to communicate
    with our API engine. We will be using Passport ([http://passportjs.org/](http://passportjs.org/))
    for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Open `api-engine/server/auth/index.js` and we should see the Passport setup
    using `require('./local/passport').setup(User, config);` and we are creating a
    new route for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The routes are configured in `api-engine/server/routes.js`. If we open `api-engine/server/routes.js`,
    we should see `app.use('/auth', require('./auth'));`. This will create a new endpoint
    named `/auth` and inside `the api-engine/server/auth/index.js`, we have added
    `router.use('/local', require('./local'));` now, if we wanted to access the `POST`
    method inside `api-engine/server/auth/local/index.js`, we would make a HTTP `POST`
    request to `/auth/local`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `api-engine`, we are using the passport local authentication strategy
    ([https://github.com/jaredhanson/passport-local](https://github.com/jaredhanson/passport-local))
    to authenticate the user using MongoDB for persistence.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new user, we are going to use the user API. If we open `api-engine/server/routes.js`,
    we should see a route defined to access the users collection `app.use('/api/v1/users',
    require('./api/user'));`. We have prefixed with `/api/v1/users` so we can version
    our API layer later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open `api-engine/server/api/user/index.js`, we should the see the following
    six routes defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`router.get(''/'', auth.hasRole(''admin''), controller.index);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.delete(''/:id'', auth.hasRole(''admin''), controller.destroy);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.get(''/me'', auth.isAuthenticated(), controller.me);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.put(''/:id/password'', auth.isAuthenticated(), controller.changePassword);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.get(''/:id'', auth.isAuthenticated(), controller.show);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.post(''/'', controller.create);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first route is for fetching all the users in the database and, using the
    `auth.hasRole` middleware defined in `api-engine/server/auth/auth.service.js`,
    we will be checking whether the user is authenticated and has the admin role.
  prefs: []
  type: TYPE_NORMAL
- en: The next route is to delete a user with an ID; after that, we have a route to
    get a user's information based on the token. We have a `PUT` route to update the
    user's information; one `GET` route to get a user's information based on the user
    ID; and finally, a `POST` route to create a user. Do note that the `POST` route
    doesn't have any authentication or authorization middleware, as the user accessing
    this endpoint will be using our app for the first time (or is trying to register
    with us).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `POST` route, we will be creating a new user; this is how we register
    a user: `api-engine/server/api/user/user.model.js` consists of the Mongoose schema
    for the user and `api-engine/server/api/user/user.controller.js` consists of the
    logic for the routes we have defined.'
  prefs: []
  type: TYPE_NORMAL
- en: MQTT client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we are going to look at the MQTT client integration with our `api-engine`.
    If we open `api-engine/server/mqtt/index.js`, we should see the default setup
    of the MQTTS client.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using the following configuration to connect to the Mosca broker over
    MQTTS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And we are subscribing to two events: one when the connection is established
    and the other when we receive a message. On the `connect` event, we subscribe
    to a topic named `greet` and we are publishing a simple message to that topic
    in the next line. And on the `message` event, we are listening for any messages
    from the broker and we are printing the topic and the message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we are aware of most of the pieces of code needed to work with `api-engine`.
    To start the `api-engine`, `cd` into the `chapter2/api-engine` folder and run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will start a new Express server application on port `9000`.
  prefs: []
  type: TYPE_NORMAL
- en: API engine testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To quickly check out the API that we have created, we will be using a Chrome
    extension named Postman. You can set up the Chrome extension from here: [https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en).'
  prefs: []
  type: TYPE_NORMAL
- en: Once Postman is set up, we will be testing two API calls to validate the register
    and login methods.
  prefs: []
  type: TYPE_NORMAL
- en: Open Postman and enter the requested URL as `http://localhost:9000/api/v1/users`.
    Next, select the method type as `POST`. Once that is done, we will set the headers.
    Add a new header with key as `content-type` and value as `application/json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will construct the request body/payload. Click on the Body tab, next
    to Headers, and select Raw request. And update it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can update the data as applicable. And then click on Send. This makes a
    request to the API engine, which will in turn save the data to the database and
    respond with the new user object, along with the auth token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we hit the Send button again with the same data, we should see a validation
    error something the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to validate the newly registered user, we will fire a request to `http://localhost:9000/auth/local`
    with only the email and password. And we should see something the same as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This validates the API we have created.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we complete the walk-through of the API engine. In the next section,
    we are going to integrate the `api-engine` with the broker and test the connectivity
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between broker and API engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are done with the two pieces of software on the cloud, we will be
    interfacing them. In `api-engine/server/config/environment/development.js`, we
    have defined the broker IP and port that the `api-engine` needs to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, if we deploy these two pieces on different machines, this is the place
    where we update the IP and port so the `api-engine` refers to the broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to test the communication, `cd` into `chapter2/broker` folder and run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, open a new command prompt/terminal, `cd` into `chapter2/api-engine` folder,
    and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The API engine connected to the mLab MongoDB instance, post that it started
    a new Express server and finally, it connected to the Mosca broker and the posted
    a message to the greet topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we look at the Mosca terminal, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The broker logged the activity that has happened so far. A client connected
    with username `API_Server_Dev` and subscribed to a topic named greet with **Quality
    of Service** (**QoS**) as `0`.
  prefs: []
  type: TYPE_NORMAL
- en: With this, our integration between the broker and API engine is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to move towards the Raspberry Pi 3 and start working on an
    MQTTS client.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are new to MQTT protocol, you can refer to *MQTT Essentials: Part 1
    - Introducing MQTT* ([http://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt](http://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt))
    and the subsequent parts. To know more about QoS, refer to *MQTT Essentials Part
    6: Quality of Service 0, 1 & 2* ([https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels)).'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to build the required software to make the Raspberry
    Pi a client to our Mosca broker via the Wi-Fi router.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen in the data flow diagram how the Raspberry Pi stands between
    the sensor and the Mosca broker. Now we are going to set up the required code
    and software.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at installing the required software on the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: A Raspberry Pi, installed with Raspbian OS ([https://www.raspberrypi.org/downloads/raspbian/](https://www.raspberrypi.org/downloads/raspbian/)),
    is a prerequisite. The Wi-Fi should have already been set up and connected before
    we continue.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to setting up a Raspberry Pi 3, refer to the *Beginner's Guide
    to Installing Node.js on a Raspberry Pi* ([http://thisdavej.com/beginners-guide-to-installing-node-js-on-a-raspberry-pi/](http://thisdavej.com/beginners-guide-to-installing-node-js-on-a-raspberry-pi/)).
    We will, however, cover the Node.js part, you can refer until you bring up the
    Pi and configure the Wi-Fi.
  prefs: []
  type: TYPE_NORMAL
- en: Once the OS is installed, boot up the Raspberry Pi and log in to it. At this
    point in time, it will be connected to the internet over your own access point
    and you should be able to browse the internet without issues.
  prefs: []
  type: TYPE_NORMAL
- en: I am accessing my Raspberry Pi 3 from my Apple MacBook Pro using VNC Viewer.
    This way, I am not always connected to the Raspberry Pi 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start off by downloading Node.js. Open a new terminal and run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will upgrade all the packages which need upgrades. Next, we will install
    the latest version of Node.js. At the time of writing, Node 7.x is the latest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take a moment to install and once your installation is done, you
    should be able to run the following commands to see the version of Node.js and
    `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are done with setting up the required software for running our
    MQTTS client on the Raspberry Pi 3.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi MQTTS client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are going to work with the MQTTS client of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: On the desktop of the Raspberry Pi 3, create a folder named `pi-client`. Open
    a terminal and `cd` into the `pi-client` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we are going to do is create a `package.json` file. From inside
    the `pi-client` folder, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then answer the question as applicable. Once you are done with that, next we
    will install MQTT.js ([https://www.npmjs.com/package/mqtt](https://www.npmjs.com/package/mqtt))
    on the Raspberry Pi 3\. Run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this installation is also done, the final `package.json` will look the
    same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Do note that we have added a start script to launch our `index.js` file. We
    will be creating the `index.js` file in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, at the root of the `pi-client` folder, create a file named `config.js`.
    Update `config.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Do notice the host property. This is set to the IP address of my MacBook and
    my MacBook is where I am going to run the Mosca broker API engine. Make sure all
    three (Mosca broker, API engine, and Raspberry Pi 3) of them are on the same Wi-Fi
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will write the required MQTT client code. Create a file named `index.js`
    at the root of the `pi-client` folder and update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is the same test code we have written on the API engine to test the connectivity.
    Save all the files and move towards your Mosca broker.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between the broker and the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to communicate between the broker and the Raspberry
    Pi over MQTTS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `broker` folder and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, head over to the Raspberry Pi, `cd` into the `pi-client` folder, and
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And we should see the following message on the Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](../images/00024.jpeg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'And when we look at the console of Mosca, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This wraps up our connectivity test between the Raspberry Pi 3 and the Mosca
    broker.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are not able to see the previous messages, check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the Raspberry Pi and the machine running the broker are on the
    same Wi-Fi network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-check the IP address of the machine running the broker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between the Raspberry Pi, the broker and the API engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are going to integrate the Raspberry Pi, the broker, and the API engine
    and pass the data from the Pi to the API engine.
  prefs: []
  type: TYPE_NORMAL
- en: The way we are going to achieve this is that we are going create a topic named
    `api-engine` and another topic named `rpi`.
  prefs: []
  type: TYPE_NORMAL
- en: To send data from the Raspberry Pi to the API engine, we will be using the `api-engine`
    topic and when we need to send data from the API engine to the Raspberry Pi, we
    will use the `rpi` topic.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to get the MAC address of the Raspberry Pi and
    send that to the API engine. The API engine will acknowledge the same by sending
    the same MAC address back to the Raspberry Pi. The communication between the API
    engine and Raspberry Pi will happen over the two topics mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'So first, we will update the `api-engine/server/mqtt/index.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, once the MQTT connection is established, we are subscribing to the `api-engine`
    topic. When we receive any data from the `api-engine` topic, we will send back
    the same to the `rpi` topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'From inside the `broker` folder, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, from inside the `api-engine` folder, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Next, head back to the Raspberry Pi. We are going to install the `getmac` module
    ([https://www.npmjs.com/package/getmac](https://www.npmjs.com/package/getmac))
    that will help us to get the MAC address of a device.
  prefs: []
  type: TYPE_NORMAL
- en: 'From inside the `pi-client` folder, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, update `/home/pi/Desktop/pi-client/index.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we have waited for the connection to establish between
    the Raspberry Pi and the broker. Once that is done, we have subscribed to the
    `rpi` topic. Next, we fetched the MAC address of the Raspberry Pi using `GetMac.getMac()`
    and published the same to the `api-engine` topic.
  prefs: []
  type: TYPE_NORMAL
- en: In the `message` event callback, we are listening for the `rpi` topic. If we
    receive any data from the server, it will be printed here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the file and from inside the `pi-client` folder, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we look at the broker terminal/prompt, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Both the devices are connected and subscribed to the topic of interest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, if we look at the `api-engine` terminal/prompt, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And finally, the Raspberry Pi terminal should look the same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this, we conclude the integration of the Raspberry Pi with the broker and
    API engine.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will implement a web application that can send and receive
    data from the Raspberry Pi through the broker and API engine.
  prefs: []
  type: TYPE_NORMAL
- en: Web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to build a web app that interfaces with our API
    engine. The web app is the primary interface with which we will be interacting
    with our smart devices.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to build the web app using Angular (4) and Twitter Bootstrap (3).
    There is no rule that the interface should be built with Angular and Bootstrap;
    it can be built using jQuery or React.js as well. All we will be doing is interfacing
    with the APIs of the API engine using JavaScript from the browser. The only reason
    we are using Angular is to keep the framework consistent across all our apps.
    Since we will be using the Ionic framework, which also follows the Angular approach,
    things will be easy for us to manage as well as reuse.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with the web application, we are going to install Angular CLI
    ([https://github.com/angular/angular-cli](https://github.com/angular/angular-cli)).
  prefs: []
  type: TYPE_NORMAL
- en: On the machine that was running our broker and API engine, we will be setting
    up the web app as well.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From inside the `chapter2` folder, open a new command prompt/terminal and run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will install the Angular CLI generator. If you run `ng -v` after the installation
    is done, you should see a version number greater than or equal to 1.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: If you are facing any issues while setting up and running the IoTFW.js, feel
    free to drop your comment here:[https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript/issues/1](https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript/issues/1)
  prefs: []
  type: TYPE_NORMAL
- en: For the web app, we have already created a base project using Angular CLI and
    have added the essential pieces to integrate with the API engine. We will clone
    the project as is and then start working on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we need the web app base. If you have not already cloned the
    book''s code repository, you can do so using the following command-line (anywhere
    on your machine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Or you can download the zip file from [https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript](https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript)
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Once the repository has been downloaded, `cd` into the `base` folder and make
    a copy of `web-app-base` folder into `chapter2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the base has been copied, `cd` into the `web-app` folder, and run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will install the needed dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we open the `cloned` folder, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, for the walk-through of the project structure and code setup.
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, we have an `src` folder, where we will have all the source
    code and unit test code, and an `e2e` folder, which consists of the end-to-end
    test.
  prefs: []
  type: TYPE_NORMAL
- en: We will be spending most of the time inside the `src/app` folder. Before we
    go into this folder, open `web-app/src/main.ts` and this is where everything begins.
    Next, we have added the Twitter Bootstrap Cosmos theme ([https://bootswatch.com/cosmo/](https://bootswatch.com/cosmo/))
    here and defined a few layout styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `app/src` folder: here, we have defined the root component, the root
    module, and the required components and services.'
  prefs: []
  type: TYPE_NORMAL
- en: App module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open `web-app/src/app/app.module.ts`. This file consists of the `@NgModule`
    declaration, which defines all the components and services that we are going to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AppComponent`: Application root component that holds the router outlet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavBarComponent`: This is the navigation bar component that appears on the
    all the pages. This component automatically detects the authentication state and
    shows the menu bar accordingly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoginComponent`: This deals with the login feature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegisterComponent`: To work with registration with the API engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HomeComponent`: This component displays all the devices attached to the current
    logged-in user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeviceComponent`: This component displays information about one device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddDeviceComponent`: This component lets us add a new component to our device
    list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeviceTemplateComponent`: A common template that is used to represent a device
    in our application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from the previous, we have also added the required modules to the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RouterModule`: To manage the routing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalStorageModule`: To manage the user data within the browser, we are going
    to use `LocalStorgae`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleNotificationsModule` : To show the notifications using Angular 2 notifications
    ([https://github.com/flauc/angular2-notifications](https://github.com/flauc/angular2-notifications))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And for the services, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthService`: To manage the authentication APIs exposed by the API engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DevicesService`: To manage the device API exposed by the API engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataService`: To manage the Data API exposed by the API engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SocketService`: To manage web sockets that send data from the API engine in
    real time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthGuard`: An Angular Guard that protects routes which need authentication.
    Read *Protecting Routes using Guards in Angular* ([https://blog.thoughtram.io/angular/2016/07/18/guards-in-angular-2.html](https://blog.thoughtram.io/angular/2016/07/18/guards-in-angular-2.html))
    for more information on Guards'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoaderService`: That shows and hides a loader bar when an activity is going
    on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Http`: The HTTP service that we use to make HTTP requests. Here, we have not
    used the HTTP service as is, but extended the class and added our logic in between
    to manage the HTTP request experience better using the loader service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do note that at this point, the API engine does not have APIs for devices and
    data, and sockets are not set up for the data. We will be implementing in the
    API engine, once we are done with the web app completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this web application, we are going to have the following routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`login`: To let the user log in to the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`register`: To register with our application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`home`: A page that displays all the devices in a user account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add-device`: A page to add a new device to the user''s device list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view-device/:id`: A page to view one device, identified by the id parameter
    in the URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**`: The default route is set to login'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''''`: If no route matches, we redirect the user to the login page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web app services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand at a high level all that is present in this web app,
    we will walk through the services and components.
  prefs: []
  type: TYPE_NORMAL
- en: Open `web-app/src/app/services/http-interceptor.service.ts;` in this class,
    we have extended the `Http` class and implemented the class methods. We have added
    two methods of our own named `requestInterceptor()` and `responseInterceptor()`,
    which intercept the request and response respectively.
  prefs: []
  type: TYPE_NORMAL
- en: When the request is about to be sent, we call the `requestInterceptor()` to
    show a loader, indicating the HTTP activity, and we use the `responseInterceptor()`
    to hide the loader once the response arrives. This way, the user is clearly aware
    if there is any background activity going on.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `LoaderService` class; open `web-app/src/app/services/loader.service.ts`
    and, as we can see from here, we have added a class property named status of the
    type `BehaviorSubject<boolean>` (to know more about `Behaviour` subject, refer
    to [https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md)).
    And we have a method, which will be called by the HTTP service or any other component
    if they would like to show or hide the loader bar and then set the value as true
    or false.
  prefs: []
  type: TYPE_NORMAL
- en: The required HTML for the loader service is present in `web-app/src/app/app.component.html`
    and the required styles are present in `web-app/src/app/app.component.css`.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use web sockets for streaming data in real time between the
    web app and the API engine. Open `web-app/src/app/services/socket.service.ts`
    and we should see the constructor and the `getData()` method. We are using `socket.io-client`
    ([https://github.com/socketio/socket.io-client](https://github.com/socketio/socket.io-client))
    to manage web sockets in our web app.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we have created a new socket connection to our API engine
    and passed the auth token as a query parameter. We are going to validate the incoming
    connections via web sockets as well. And only if the token is valid will we allow
    the connection, else we close the web socket.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `getData()`, we subscribe to the `data:save` topic for a device. This
    is how we get notified from the API engine when there is new data available from
    a device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will look at the three API services with which we authenticate the user,
    get the user''s devices and get data for a device:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthService`: Open `web-app/src/app/services/auth.service.ts`. Here, we have
    defined the `register()`, `login()`, and `logout()`, which takes care of managing
    the authentication state and we have `isAuthenticated()`, which returns the current
    state of authentication, as in whether the user is logged in or logged out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DevicesService`: Open `web-app/src/app/services/devices.service.ts`. Here,
    we have implemented three methods: one to create, one to read, and one to delete.
    With this, we manage our devices for a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataService`: Open `web-app/src/app/services/data.service.ts`, which manages
    the data for a device. We have only two methods here: one to create a new data
    record and one to fetch the last 30 records of a device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do notice that we are using `web-app/src/app/app.global.ts` to save all our
    constant global variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with the required services, we will walk through the components.
  prefs: []
  type: TYPE_NORMAL
- en: Web app components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with the app component. The app component is the root component,
    which holds the router outlet, loader service HTML, and notification service HTML.
    You can find the same here: `web-app/src/app/app.component.html`. In `web-app/src/app/app.component.ts`,
    we have defined `showLoader` that decides whether the loader should be shown or
    not. We have also defined notification options, which stores the notification
    service configurations.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the constructor, we are listening for route change events on the router,
    so we can show a loading bar on page change. We are also listening to the loader
    service status variable. If this changes, we show or hide the loader.
  prefs: []
  type: TYPE_NORMAL
- en: The first page that the user lands on is the login page. The login page/component,
    `web-app/src/app/login/login.component.ts`, has only one method, the takes the
    user's email and password from `web-app/src/app/login/login.component.html` and
    authenticates the user.
  prefs: []
  type: TYPE_NORMAL
- en: Using the register button on the home page, the user registers themself. Inside
    the `RegisterComponent` class, `web-app/src/app/register/register.component.ts`,
    we have defined `register()`, which takes the user's information and, using the
    `AuthService`, registers a user.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user has been successfully authenticated, we redirect the user to the
    `LoginComponent`. In the `HomeComponent`, `web-app/src/app/home/home.component.ts`,
    we fetch all the devices associated with the user and display them on load. This
    page also has a button for adding a new device using the `AddDeviceComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: To view one device, we use the `DeviceComponent` to view one device.
  prefs: []
  type: TYPE_NORMAL
- en: As of now, we do not have any APIs available to work with devices and data.
    We will revisit this page once we finish the API engine update in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the app, open a terminal/prompt inside the `web-app` folder and run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the API engine and Mosca are running before you run the previous command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the webpack compilation is successful, navigate to `http://localhost:4200/login`
    and we should see the login page, this is the first page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the account we have created while testing the API engine, using
    Postman, or we can create a new account by clicking on Register with Web App as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the registration is successful, we should be redirected to the home page
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we open the developer tools, we should see the previous message. The API
    engine does not have APIs for devices implemented, hence the previous `404s`.
    We will fix that in [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - II*.
  prefs: []
  type: TYPE_NORMAL
- en: We will also walk through the remaining part of the web app in [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - II*, once we are done with the API engine update.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have gone through the process of setting up a frame to work
    with internet of Things solutions. We have built most of the framework using only
    JavaScript as our programming language.
  prefs: []
  type: TYPE_NORMAL
- en: We started by understanding the architecture and data flow from a Raspberry
    Pi to an end user device such as a web app, desktop app, or mobile app. Then we
    started working on the broker using Mosca, after setting up the MongoDB. Next,
    we designed and developed the API engine and completed the basic Raspberry Pi
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: We have worked on the web app and set up the necessary templates to work with
    the remaining part of the application. In [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - II*, we will complete the entire framework and also integrate a DHT11
    (temperature and humidity) sensor and an LED to validate the two-way data flow
    end to end.
  prefs: []
  type: TYPE_NORMAL

- en: '*Chapter 7*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Test simple scripts using Node.js REPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construct objects and arrays and modify their content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use object methods and operators to get information about the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create simple JavaScript classes and classes that inherit from other classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use advanced built-in methods from Math, RegEx, Date, and String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulate data in JavaScript using Array, Map, and Set methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement Symbols, Iterators, Generators, and Proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will work with arrays, classes, and objects in JavaScript,
    and then we will use inheritance and built-in methods in common JavaScript classes
    to simplify our code and make it highly reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing JavaScript code for medium to large projects (10+ files), it is
    helpful to understand all of the possible features that this language provides.
    It is always easier and quicker to use what is already there than reinvent the
    wheel. These built-in methods will not only help you with performing basic functions,
    but they will also help with code readability and maintainability. These built-in
    methods range from basic calculations to the complex array and string manipulation
    that developers face every day. By using these built-in methods, we can reduce
    our code size and help with the performance of our application.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is usually used as a functional language, but you can use it for
    **Object-Oriented Programming** (**OOP**). In recent years, many new features,
    such as classes, have been added to the language in response to the growing need
    for JavaScript to accomplish more complex and data-driven tasks. While it is still
    possible to create JavaScript using function prototypes, many developers have
    moved on from doing so since it offers a much closer syntax, similar to popular
    OOP languages such as C++, Java, and C#.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the vast number of built-in methods that JavaScript
    provides us with. We will use Node.js **REPL** (**Read-Eval-Print Loop**) to test
    our code as this doesn't require us to create any files on the disk or invoke
    any special commands.
  prefs: []
  type: TYPE_NORMAL
- en: Language Features Supported in ES5, ES6, ES7, ES8, and ES9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into the depths of these amazing language features, let''s take
    a look at the different versions of JavaScript. Currently, most websites that
    you regularly come across that still support legacy browsers use ES5\. As of 2019,
    many mainstream browsers have already added support for ES6\. Later versions will
    only have minimal browser support. Since we will be running and testing our code
    in a Node.js runtime, we don''t have to worry about version compatibility as long
    as we are using the latest LTS (long term support) version of Node.js. Regarding
    the materials that will be used in this chapter, here is a breakdown of the minimum
    ES version your runtime needs to support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Minimum required ES version'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: Minimum required ES version'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this chapter, we won't be switching runtimes, but in the future, it is best
    to check the language support on the runtime you are going to be developing for
    before getting started.
  prefs: []
  type: TYPE_NORMAL
- en: Working in the Node.js REPL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We won't be doing anything too complex in this chapter, so we are going to write
    our code in the `Node.js` REPL. This allows us to test some ideas before we start
    coding without the need to create any files. Before we start, make sure you have
    Node.js installed on your computer and you have opened a Terminal application.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the Node.js REPL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every Node.js installation includes a node executable that allows you to run
    local JavaScript files or start the REPL. To run the Node.js executable as a REPL,
    all you need to do is type the `node` command in your favorite Terminal without
    any parameters. To test our Node.js installation, you can run the `node -v` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Testing the Node.js installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.2: Testing the Node.js installation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you see an output like this, it means you have `Node.js` installed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This command outputs the currently running version of the `Node.js` runtime,
    so it is also a very good way to check the current version. For this book, we
    will be using the current LTS, that is, v10.16.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have verified our Node.js installation, to run the node command in
    REPL mode, all you need to do is type `node` in your Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Running the node command in REPL mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3: Running the node command in REPL mode'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you can see a cursor waiting for your input, congratulations – you have successfully
    entered the REPL mode of Node.js! From now on, you can start typing code into
    the prompt and pressing Enter to evaluate it.
  prefs: []
  type: TYPE_NORMAL
- en: Array Manipulation in JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating arrays and modifying its content in JavaScript is very easy. Unlike
    other languages, creating arrays in JavaScript doesn't require you to specify
    the data type or size because these can be changed on request later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a JavaScript array, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in JavaScript, there is no need to define the size or the type of
    items in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an array with elements predefined, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To access and modify items in an array, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to other programming languages when accessing the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 37: Creating and Modifying an Array'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will be creating a simple array and exploring its value
    using the REPL. The syntax for creating an array is very similar to many other
    scripting languages. We will create an array of `singers` in two ways: one is
    using the `Array` constructor and the other is to use an array literal way. Once
    we have created the array, we will then manipulate the contents of the array.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the array literal method to create an empty array and test it is successfully
    created afterward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use the `Array` constructor to do the same. While they yield the
    same result, the constructor allows more flexibility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we are not using `typeof` to check the type of the array because, in
    JavaScript, array is a type of object. If we were to use `typeof` on the array
    we just created, we would get an unexpected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create arrays with a predefined size and items. Note that JavaScript arrays
    will automatically resize as you add items to the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have an array initialized that has an initial size of `6`.
    We also used the `fill` method to predefine all the items in our array. This is
    very useful when we want to use the array to keep track of flags in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign a value to index `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign any arbitrary index for a JavaScript array. The indexes without assignment
    will simply be `undefined`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the item at the end of the array using the array''s length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we have learned how we can define arrays in JavaScript. These arrays behave
    similar to other languages and they are also auto-expanded so that you don't have
    to worry about manually resizing the array. In the next exercise, we will go over
    how to add items to the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 38: Adding and Removing Items'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s very easy to add and remove items from JavaScript arrays, which we have
    to do in many applications where we have to accumulate a number of items. In this
    exercise, we are going to modify the existing `singers` array we created previously.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with an empty array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new item to the end of an array using `push`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `push` method will always add the item to the end of the array, even if
    you have items in the array that are `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, if you have an array that of a predefined
    size, using `push` will expand the array and add it to the end of the array instead
    of just adding it to the beginning
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove an item from the end of an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an item to the beginning of an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove items from the beginning of an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These are very useful in a larger scale application, such as if you are building
    a simple web application that processes images. When a request comes in, you can
    push the image data, the job ID, and even the client connection to an array, which
    means that the JavaScript array can be of any type. You can have another worker
    calling `pop` on the array to retrieve the jobs and then process them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 39: Getting Information About the Items in Your Array'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will go over various basic ways to get information about
    the items in your array. These functions are very helpful when we are working
    on applications that need to manipulate the data. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an empty array and push items to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the index of an item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the number of items in the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove an item from a certain index in the array. We will do this by storing
    the position of the item we want to remove into a variable position. After we
    know where we want to remove the item, we can call `array.splice` to remove it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`array.splice` can also be used to insert/replace items into the array at a
    specific index. We will go over the specifics of that function later. When we
    are using it, we are supplying it with two parameters. The first one tells splice
    where to start, and the next one tells it how many items to delete from the start
    position. Since we only want to remove the item at that index, we are supplying
    it with 1.'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we explored ways to get more information about the array.
    Trying to locate the index of a specific item is very useful in building applications.
    Using these built-in methods is very useful because you don't need to iterate
    through the array to find the item yourself. In the next activity, we will be
    building a simple user tracker using the ID of the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8: Creating a User Tracker'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose you are building a website and you want to track how many people are
    currently viewing it. In order to do this, you decide to keep a list of users
    in your backend. When a user opens your website, you will update the list to include
    that user, and when that user closes your website, you will remove that user from
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: For this activity, we will have a list called `users`, which stores a list of
    strings, and a couple of helper functions to help store and remove the users from
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we need to define a function that takes our list of users
    and modifies it to our liking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `Activity08.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `logUser` function, which will add the user to the `userList` argument
    supplied and make sure no duplicates are added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `userLeft` function. It will remove the user from the `userList` argument
    supplied in the argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `numUsers` function, which returns the number of users currently inside
    the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a function called `runSite`. This will be used to test our implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 607.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we explored one of the ways in which we can use arrays to
    accomplish certain tasks in JavaScript. We can use it to keep track of a list
    of items and use the built-in methods to add and remove items. The reason we are
    seeing **user3**, **user5**, and **user6** is because these users were never removed.
  prefs: []
  type: TYPE_NORMAL
- en: Object Manipulation in JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating basic objects in JavaScript is very easy and objects are used in every
    JavaScript application out there. A JavaScript object also includes a collection
    of built-in methods for you to use. These methods are very helpful when we are
    writing our code because it makes developing in JavaScript very easy and fun.
    In this section, we will examine how to create objects in our code and how we
    can use them to maximize their potential.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an object in JavaScript, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: By using the `{}` notation, we are defining an empty object and assigning it
    to our variable name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use objects to store many numbers of key-value pairs in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to access the value, this is also quite easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, creating an object doesn''t mean having to follow a specific
    schema. You can put any number of properties within the object. Just make sure
    that none of the object keys are duplicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the syntax for a new object is very similar to the JSON notation.
    There are times where we need to know exactly what kind of information is in our
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create an object user with some properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to get all the property names, you need to use the `keys` method,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also test whether a property exists. Let''s check this for a property
    that has not been defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s check this for the properties that we defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple way of testing whether the property exists in an object.
    In a lot of applications, this is used frequently to check the existence of the
    field and, if it doesn't exist, a default value will be set. Just keep in mind
    that, in JavaScript, an empty string, an empty array, the number zero, and other
    falsy values will be evaluated to `false` by the `if` statement. In the following
    exercise, we will try to create an object with a lot of information and output
    very useful information from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 40: Creating and Modifying Objects in JavaScript'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will store objects inside an array and modify the array
    by making changes to the object. We will then check how we can access an object
    using its properties. We will keep using the `singers` array we defined earlier,
    but this time instead of only storing a list of strings, we will use objects.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `singers` array to an empty array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Push an object to the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `name` property of the first object inside the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It's very simple to modify values in an object; for example, you can assign
    any value to the property, but it doesn't stop there. You can also add properties
    that weren't originally part of the object to expand its information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a property called `birthday` to the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To add properties to an existing object, simply assign a value to a property
    name. This will create that property if it doesn't exist. You can assign any value
    to the property, functions, arrays, or other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read the property in the object by executing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, accessing the property value of an object is very simple in
    JavaScript. If you already know the name of the value, you can just use dot notation.
    In some cases where the property name is dynamic or from a variable, you can use
    bracket notation to access the property value of that property name.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we went over ways to create an object in JavaScript and how
    to modify and add properties to it. JavaScript objects, just like arrays, are
    very easy to modify and they do not need you to specify a schema. In the next
    activity, we will build a very interesting utility that can help you understand
    how objects work across networks and how to efficiently use them.
  prefs: []
  type: TYPE_NORMAL
- en: JSON.stringify
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`JSON.stringify` is a very useful utility that converts a JavaScript object
    into a formatted string. Later, the string can be transmitted over the network.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say we have a `user` object that we want to convert it
    into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to convert our object into a string, we need to call `JSON.stringify`
    with this object, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get a result like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Result using JSON.stringify'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: Result using JSON.stringify'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, calling `JSON.stringify` has converted our object into a string
    representation of the object.
  prefs: []
  type: TYPE_NORMAL
- en: But because of the way it is implemented, `JSON.stringify` is very inefficient.
    Although the performance difference is not apparent in most applications, in high-performance
    applications, a little bit of performance does matter. One way to make a faster
    `JSON.stringify` utility is to know which property you need in the final output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 41: Creating an Efficient JSON.Stringify'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our objective is to write a simple function that takes an object and a list
    of properties to be included in the final output. The function will then call
    `JSON.stringify` to create the string version of the object. Let''s define a function
    called `betterStringify` in the `Exercise41.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `betterStringify` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create a temporary output. We will store the property we want
    to be included in `propertyMap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate through our `propertyMap` argument to cherry-pick the property we want
    to include:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Because our `propertyMap` argument is an array, we want to use `forEach` to
    iterate through it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the value from our item to the temporary output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are checking whether the key in our `propertyMap` argument is set.
    If it is set, we will store the value in our `output` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a function on a test object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After finishing the function, running the file will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Output of running better_stringify.js'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: Output of running Exercise41.js'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, it''s time to answer the tough question: just how fast can you make your
    code if you did something like this?'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run a benchmark on this over `JSON.stringify`, you will see a 30% performance
    gain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 Performance difference between JSON.stringify and ouR method'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 Performance difference between JSON.stringify and ouR method
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: That's 30% more time you can spend calculating more important stuff. Note that
    this is a very bare-bones example of what you can do if you cherry-pick your properties
    rather than dumping everything using `JSON.stringify`.
  prefs: []
  type: TYPE_NORMAL
- en: Array and Object Destructuring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous exercises and activities, we went over basic ways to modify
    values in objects and arrays and ways to get more information from them. There
    is also a way to retrieve values from the array or object using **destructuring
    assignment**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider you have been given a list of parameters you need to assign to variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to assign them is to access each item in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also simplify this into one line by using destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 42: Using Destructuring Assignment for an Array'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will declare an array called `userInfo`. It will include
    basic user information. We will also declare a couple of variables so that we
    can store the item inside the array by using the destructuring assignment. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `userInfo` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Create the variables for storing `name`, `age`, and `job:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the destructuring assignment syntax to assign values to our variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Check our values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also ignore values inside the array using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The destructuring assignment is very useful when you are dealing with data that
    is not exactly formatted the way you like. It can also be used to pick items you
    want inside the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 43: Using Destructuring Assignment for an Object'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous exercise, we declared an array with the user''s information,
    and we used destructuring assignment to retrieve some values from it. A similar
    thing can be done to objects as well. In this exercise, we will try destructuring
    assignment on objects. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an object called `userInfo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the variables we will use to store the information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the destructuring assignment syntax to assign values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that when using deconstructing assignment on an object, it acts like a
    filter where the variable name must match, and you can selectively choose which
    property in the array you want to select. There is also a different way of using
    this on objects that don't require you to predeclare the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use deconstructing assignment with the arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the destructuring operator to create a variable from the object values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Output of the job variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.7: Output of the job variable'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we went over how we can use the destructuring operator to
    extract specific information from our objects and arrays. This is very useful
    when we are dealing with a lot of information and we only want to transfer a subset
    of that information.
  prefs: []
  type: TYPE_NORMAL
- en: Spread Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous exercise, we went over some ways in which we can get specific
    information from objects or arrays. There is another operator that can help us
    expand arrays or objects. The spread operator was added to the ES6 specification,
    but in ES9, it also added support for object spread. The spread operator's function
    is to spread each item into individual items. In the case of arrays, when we use
    the spread operator, we can treat it as a list of separate values. For objects,
    they will be spread into key-value pairs. In the next exercise, we will explore
    different ways we can use the spread operator in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the spread operator, we use three dots (`…`) before any iterrable object,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 44: Using Spread Operators'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we are going to see how the spread operator can help us. We
    will use the original `userInfo` array from the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `userInfo` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function that prints out the user''s information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Spread the array into a list of arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the original way to call this function without the spread operator
    is to use the array access operator and repeat this for each argument. Since the
    ordering of the array matches the respective arguments, we can just use the spread
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the spread operator when you want to merge arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the spread operator as a way to copy an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Using the spread operator on objects is much more powerful and practical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new object called `userRequest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Clone the object using the `object` spread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an object that includes every property of this object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the spread operator is very useful when you want to copy all
    the properties over to a new object. You can see this being used in many applications
    where you want to wrap a user request with some generic properties for further
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: Rest Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we looked at spread operators. The same operator can
    also be used in a different way. In function declarations, they are called **rest
    operators**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rest operators are mainly used to represent an indefinite number of arguments.
    Then, the arguments will be placed in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we used the same three dots before the name. This tells our
    code that we are expecting an indefinite number of arguments for this function.
    When we do call the function with a list of arguments, they will be put inside
    a JavaScript array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: Output of sum when called with a list of numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.8: Output of sum when called with a list of numbers'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'That doesn''t mean you don''t have any control over the number of arguments.
    You can write your function declaration like this to let JavaScript map several
    parameters to your liking and the rest into an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This maps the first parameter to the variable initial, and the rest to an array
    called `numbers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: Output of sum when called with 0 and 1-9.'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.9: Output of sum when called with 0 and 1-9.'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: OOP in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because of the popularity of JavaScript in web development, it is used mainly
    in a functional way. This led many developers to the assumption that there is
    no way to do OOP in JavaScript. Even before the release of the ES6 standard, there
    was a way to define a class: by using functions. You might have seen this way
    of defining a class before in legacy frontend code. For example, if you want to
    create a class called `Food`, you would have to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: After the release of ES6, an increasing number of developers adopted the modern
    way of writing JavaScript classes using the `class` keyword. In this chapter,
    we will be going over ways to declare classes using the ES6 standard.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Class in JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the latest syntax to define a class in JavaScript, let's
    go over how it used to be done before ES6.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax that was used to define a class before ES6 was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, we are defining the `constructor` class. The name of the function
    will be the name of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax to define a class with ES6 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This is what we usually do with class definitions in other languages. Here,
    we can define a constructor and a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 45: Declaring an Object Constructor Using Functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a very simple class called `Food`. Later,
    we will also add some methods to the class. We will be using the function constructor
    method here. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `Food` constructor function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the method to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new object using the `Food` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the method we have declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10: Output of the burger.description() method'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.10: Output of the burger.description() method'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Many of you might be familiar with this type of declaration of a class. But
    this also creates issues. First, using functions as constructors gives a developer
    no clear idea of when to treat a function as a function and when to use it as
    a constructor. Later, when JavaScript released ES6, it introduced a new way of
    declaring classes. In the next exercise, we will use the new method to declare
    the `Food` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 46: Creating a Class in JavaScript'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a class definition in JavaScript to store
    food data. It will include a name, a cost, and a calorie count. Later, we will
    also create methods that return the description of the food and another static
    method to output the calories for a certain food. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a `Food` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `typeof` on the class name to see what type it is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11: Running the typeof command on the class'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.11: Running the typeof command on the class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, the type of the new class we just declared is `function` – isn't
    that interesting? This is because, inside JavaScript, the class we declared is
    just another way of writing the `constructor` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our `constructor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Just like any other language, the class definition will include a constructor,
    which is called using the `new` keyword to create an instance of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the `description` method inside the class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to invoke the `Food` class constructor like a function, it will
    throw the following error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12: TypeError for invoking the constructor as a function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.12: TypeError for invoking the constructor as a function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the runtime throws an error when you are trying to call the constructor
    like a function. This is very helpful as it prevents the developer from mistakenly
    calling the constructor as a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new food object using the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the method we have declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `static` method, which returns the number of calories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `static` method with the object we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13: Output generated after calling the static method of the Food
    class'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.13: Output generated after calling the static method of the Food class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Like any other programming language, you can call the `static` method without
    instantiating the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve looked at the new way to declare classes in JavaScript, let''s
    talk about some of the differences of class declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor method is required. If you do not declare one, JavaScript will
    add an empty constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class declaration is not hoisted, which means that you cannot use it before
    it is declared. So, it's best to have your class definitions or imports at the
    top of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Simple User Information Cache Using Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will design a simple user info cache. A cache is a temporary
    location where you can store the most frequently accessed items when fetching
    them from the original place takes time. Suppose you are designing for a backend
    application that handles user profiles. Whenever the request comes in, the server
    needs to call the database to retrieve the user profile and send it back to the
    handler. As you may know, calling the database is a very costly operation. As
    a backend developer, you may be asked to improve the read performance of the service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will create a simple cache for storing the user profile
    so that you can skip the request to the database most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 47: Creating a Cache Class to Add/Update/Remove Records from the Data
    Store'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will create a cache class that includes a local memory
    data store. It also includes a method that adds/updates/removes a record from
    the data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `MySimpleCache` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we will also initialize our internal state for the cache.
    This will be a simple object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define `addItem`, which will set the cache item for the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Define `updateItem`, which will use the `addItem` we already defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Define `removeItem`. This will remove the object we stored in our cache and
    invoke the `updateItem` method we created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Test our cache using `assert()` with `testMycache` by updating and deleting
    a few users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`assert()` is a built-in Node.js function that takes an expression. It will
    pass if the expression evaluates to `true` and throw an exception if it is evaluated
    to `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the file, you should see no errors and the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14: Output of simple_cache.js'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.14: Output of simple_cache.js'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Class Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have only created simple class definitions in JavaScript. In OOP,
    we can also have a class inherit from another class. Class inheritance is simply
    making one class''s implementation be derived from another class. The child class
    that''s created will have all the attributes and methods of the parent class.
    This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15: Class inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.15: Class inheritance'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Class inheritance provides some benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates clean, testable, and reusable code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reduces the amount of similar code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reduces maintenance time when writing a new feature that will apply to all
    subclasses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In JavaScript, it is very easy to create a subclass that inherits from another
    class. In order to do so, the `extends` keyword is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 48: Implementing a Subclass'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will define a superclass called `Vehicle` and create our
    subclasses from it. The superclass will have methods called `start`, `buy`, and
    `name`, `speed`, and `cost` as its attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor of the superclass will take a name, color, and speed attributes,
    and then store them inside the object.
  prefs: []
  type: TYPE_NORMAL
- en: The `start` method will simply print out a string, telling you which vehicle
    you are using and how you are traveling. The `buy` function will print out which
    vehicle you are about to purchase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `Vehicle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `vehicle` instance and test out its methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16: Output of the Vehicle class'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.16: Output of the Vehicle class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create the `Car`, `Plane`, and `Rocket` subclasses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Car`, `Plane`, and `Rocket`, override the `start` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance for `Plane`, `Rocket`, and `Car`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `start` method on all three objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17: Output from the objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.17: Output from the objects'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you call these start methods now, you can clearly see that the output is
    different. When declaring subclasses, most of the time, we need to override some
    methods from the parent class. This is very useful when we are reducing the duplicated
    code while preserving the customization this creates.
  prefs: []
  type: TYPE_NORMAL
- en: The customization doesn't stop here – you are also able to create a new subclass
    with a different constructor. You are also able to call the parent method from
    the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the subclasses we created previously, we will be modifying the `Car` subclass
    so that it includes extra parameters in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Check to see whether the extra property is set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18: Checking the extra property of the Car class'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.18: Checking the extra property of the Car class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, declaring a subclass is very easy – you can have a lot of code
    shared when coding this way. Also, you do not lose the ability of being able to
    do customization. After the ES6 standard, you can easily define classes just like
    the other OOP languages out there. It can make your code cleaner, more testable,
    and more easily maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Private and Public Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In OOP, sometimes, it's useful to separate publicly accessible properties and
    functions and privately accessible properties and functions. It's a protection
    layer to prevent developers who are using the class from invoking or accessing
    some internal states of the class. In JavaScript, that behavior is not possible
    because ES6 doesn't allow private properties to be declared; all the properties
    you declare in the class will be publicly accessible. To achieve this type of
    behavior, some developers have opted to use the underscore prefix, for example,
    `privateMethod()`, to inform other developers not to use it. However, there are
    hacks around declaring private methods. In the next exercise, we will explore
    private methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 49: Private Methods in the Vehicle Class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will try to declare a private function for the `Car` class
    we created previously so that we can make sure our private method isn''t exposed
    when we export the class as a module later. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function named `printStat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `public` method to use the function we just declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We called `printStat` from our `start` method directly, but there is no real
    way to access the method directly without using one of the methods in our class.
    By having the method declared outside, we made the method `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another `car` instance and call the `start` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, you will realize that this causes an anomaly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19: Output of printStat'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.19: Output of printStat'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Modify the `start` method so that the function knows about the object instance
    we are calling it from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we used `.bind()`. By using bind, we are binding the current instance
    to the `this` variable inside this function. This enabled our code to work as
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20: Output of printStat after using .bind()'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.20: Output of printStat after using .bind()'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, currently, there is no way to easily declare a `private` method
    or properties in JavaScript. This example is just a hack around the issue; it
    still doesn't provide equal separation like other OOP languages do, such as Java
    or Python. There are also options online where you can declare private methods
    using symbols, but they can also be accessed if you know where to look.
  prefs: []
  type: TYPE_NORMAL
- en: Array and Object Built-in Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, we talked about basic arrays and objects. They deal with how we
    store data. Now, we will dive deep into how we take the data we have just stored
    in them and make advanced calculations and manipulations on them.
  prefs: []
  type: TYPE_NORMAL
- en: '**array.map(function)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Array map will iterate over each item in the array and return a new array as
    a result. The function that''s passed to the method will take the current item
    as a parameter and the returned value of the function will be included in the
    final array''s result; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to create a new array and only include the name property from the
    object in the list, we can use `array.map` to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21: Output using array.map(function)'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.21: Output using array.map(function)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**array.forEach(function)**'
  prefs: []
  type: TYPE_NORMAL
- en: '`.forEach` is a way of iterating over an array of items. Unlike `.map`, it
    does not return new values. The function we passed in simply gets called repeatedly
    with the values in the array; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This will print out every singer's name in the array.
  prefs: []
  type: TYPE_NORMAL
- en: '**array.find(function)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.find` method works just like the `.map` and `.forEach` methods; it takes
    a function as a parameter. This function will be used to determine whether the
    current object matches the requirement of the search. If a match is found, it
    will be used as the returned result for the method. This method is only useful
    if you have only one match in the array and will not return at all if multiple
    matches were found. For example, if we want to find the object with the name equal
    to a string, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '**array.filter(function)**'
  prefs: []
  type: TYPE_NORMAL
- en: '`.filter` works just like `.find`, but it allows multiple items to be returned.
    If we want to match multiple items in a list, we need to use `.filter`. If we
    want to find a list of singers with an age less than 30, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map` method from the array creates a new array while iterating through
    every item in the array. The `map` method takes a function such as the `forEach`
    method. When it executes, it will call the function with the first parameter with
    the current item and the second with the current index. The `map` method also
    expects the function that''s supplied to it to be returned. The returned value
    will be put inside a new array and returned by the method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.map` method will iterate through the array and our `map` function will
    return `"I know,"` plus the current language. So, the result of `myMappedArray`
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22: Example output using an array map method'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.22: Example output using an array map method'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We will go over `array.map` in more detail in *Chapter 10*, *Functional Programming
    in JavaScript*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method that we will use in the following exercise is the `forEach`
    method. The `forEach` method is much cleaner, as there is no need to manage the
    current index and write the actual call to the function. The `forEach` method
    is a built-in array method and it takes a function as a parameter. The following
    is an example of the `forEach` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: In the following exercise, we will use iteration methods on arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 50: Using Iteration Methods on Arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many ways to iterate through an array. One is to use the `for` loop
    with an index, while another is to use one of its built-in methods. In this exercise,
    we will initialize an array of strings and then explore some of the iteration
    methods that are available in JavaScript. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a list of foods as an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Join every item in the array using `join`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23: Joined items in the array'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.23: Joined items in the array'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Array joining is another way to iterate through every item in the array, combining
    them into one single string using the separator supplied in between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function called `eat_food`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `for` loop to iterate through the array and call the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24: Output of eat_food being called inside a loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.24: Output of eat_food being called inside a loop'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Use the `forEach` method to achieve the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25: The same output is generated by using the forEach method'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.25: The same output is generated by using the forEach method'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because `eat_food` is a function and its first parameter references the current
    item, we can just pass the function name over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new array of calorie numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: This array includes all the calories for each item in our `food` array. Next,
    we will use a different iterative function to create a new list of objects, including
    this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create new array of objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Print out `foodInfo` to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26: Array containing food and calorie information'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.26: Array containing food and calorie information'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After running `array.map`, the new array will be created, which includes information
    about our food name and its calorie count.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we went over two iteration methods, that is, `forEach` and
    `map`. Each has its own capabilities and usages. In most applications, maps are
    generally used to calculate array results by running the same code on each array
    item. This is very useful if you want to manipulate every item in the array without
    modifying the array directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 51: Lookups and Filtering the Array'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously, we talked about ways to iterate through arrays. These ways can
    also be used for lookups. As we all know, a lookup is very costly when you are
    iterating the array from start to finish. Luckily, a JavaScript array has some
    built-in methods for that, so we don''t have to write our search function ourselves.
    In this exercise, we will use `includes` and `filter` to search the items in our
    array. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a list of names called `profiles`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to find out whether the list of profiles includes a person named `Jim Halpert`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27: Output of the hasJim method'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.27: Output of the hasJim method'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Modify the `profiles` array to include extra information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Now, the array is no longer a simple list of strings – it's a list of objects,
    and things will work a little bit differently when we are dealing with objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to use `includes` to find the `Jim Halpert` profile again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28: Output of the hasJim method'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.28: Output of the hasJim method'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Find the profile with the name `Jim Halpert`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Find all the users with an age older than `18`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding code, it should output all the users with an age
    over 18\. The difference between `filter` and `find` is that `filter` returns
    an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29: Output after using the filter method'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.29: Output after using the filter method'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we looked at two ways we can locate a specific item in our
    array. By using these methods, we can avoid rewriting the search algorithm. The
    difference between `find` and `filter` is that `filter` returns an array of all
    the objects matching the requirement. In an actual production environment, when
    we want to test whether the array has an object that matches our requirement,
    we usually use the `find` method because it stops scanning when it finds one match,
    whereas `filter` compares with all the objects in the array and will return all
    the matching occurrences. This is more costly if you are just testing for the
    existence of something. We also used the double negative operator to cast our
    result to a Boolean. This notation is very useful if you are using this value
    later in a conditional.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sorting is one of the biggest challenges that developers face. When we want
    to sort a number of items in our array, we usually need to define a specific sorting
    algorithm. These algorithms usually require us to write a lot of logic on sorting
    and they are not easily reused. In JavaScript, we can use the built-in array methods
    to sort our custom list of items and write minimal custom code.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting in JavaScript arrays requires us to call the `.sort()` function on the
    array. The `sort()` function takes one parameter, called the sorting comparator.
    Based on the comparator, the `sort()` function will make a decision on how to
    arrange each element.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a brief description of some of the other functions we will
    use in the upcoming exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `compareNumber` function only calculates the difference between `a` and
    `b`. In the `sort` method, we can declare our own custom compare function to be
    passed down to do the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The `compareAge` function is very similar to the `compareNumber` function.
    The only difference here is that we are comparing JavaScript objects instead of
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 52: Sorting Arrays in JavaScript'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will go over ways to sort our arrays. Sorting is always
    complicated in computer science. In JavaScript, the array object has a sorting
    method built into it where you can do basic sorting on the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the `profiles` array of objects from the previous exercise.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an array of `numbers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `array.sort()` to sort this array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding code, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30: Output of array.sort()'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.30: Output of array.sort()'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is not exactly what we want; it appears that the `sort` function just randomly
    arranges the values. The reason behind this is that, in JavaScript, `array.sort()`
    doesn't really support sorting by values. By default, it treats everything as
    a string. When we called it using the number array, it converted everything into
    strings and then started sorting. That's why you are seeing numbers with 1 appearing
    before 2 and 3\. To implement the sorting of numbers, we need to do something
    extra.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `compareNumber` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The function expects to take two values that are going to be compared, and
    returns a value that must match the following: if `a` is smaller than `b`, return
    a number less than 0; if `a` is equal to `b`, return 0; and if `a` is larger than
    `b`, return a number greater than 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `sort` function and provide the `compareNumber` function as our parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding code, you will see that the function has sorted
    our array into the order we wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31: Output of array.sort(compareNumber)'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.31: Output of array.sort(compareNumber)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, the array is sorted correctly from smallest to largest. However, most of
    the time when we have to do sorting, we need to sort complex objects into order.
    For the next step, we will use the `profiles` array we created in the previous
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `profiles` array if it isn''t defined in your workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `profiles.sort()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.32: Output of the profiles.sort() function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.32: Output of the profiles.sort() function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because our `sort` function has no idea how to compare these objects, the array
    is left the way it is. In order to make it correctly sort objects, we need a compare
    function just like last time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define `compareAge`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The two arguments that are supplied to `compareAge`, `a` and `b`, are objects
    in our array. So, in order to have them sorted correctly, we need to access the
    `age` property of these objects and compare them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `sort` function with the `compare` function we just have defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.33: Result of profile.sort(compareAge)'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.33: Result of profile.sort(compareAge)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we went over the ways to sort our arrays. One thing to keep
    in mind is that, in JavaScript, if you are not sorting string values, you are
    required to supply the sorting function with a compare function so that it knows
    how to sort. The space and time complexity for this method varies from platform
    to platform, but if you are using Node.js, the V8 engine of JavaScript is highly
    optimized for these types of operations, so you don't have to worry about performance.
    In the next exercise, we will go over a very interesting, yet useful, array operation
    in JavaScript, the array reducer. By using the array reducer, we can easily combine
    items in the array and reduce them into one single value.
  prefs: []
  type: TYPE_NORMAL
- en: Array Reduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When building backend applications, there are many times where you are given
    a list of formatted results and you must calculate a single value from them. While
    this can be done using the traditional loop method, it is much cleaner and much
    easier to maintain when you are using the JavaScript reducing function. Reducing
    means taking each element in the array and producing a single value in return.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to reduce an array, we can call the built-in `array.reduce()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: When we call `array.reduce()`, we need to pass in a function and the initial
    value. The function will feed a previous value and a current value as arguments
    and will use the return as the final value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 53: Using JavaScript Reduce Method to Make Calculations for a Shopping
    Cart'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will try to use JavaScript `reduce` method to make calculations
    for a shopping cart. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the shopping cart variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Push items into the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculate the total cost of the shopping cart using the loop method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.34: Result of the loop method of calculating total'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.34: Result of the loop method of calculating total'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We write our reducer called `priceReducer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `cart.reduce` with our reducer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.35: Result of cart.reduce'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.35: Result of cart.reduce'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we went over the ways in which we can reduce the array into
    a single value in JavaScript. While it is perfectly correct to use a loop to iterate
    through the array and return the accumulator, it makes the code much cleaner when
    you are using the reduce function. We not only reduced the number of mutable variables
    in the scope, but we also made the code much cleaner and maintainable. The next
    person maintaining the code will know that the returned value of that function
    will be a single value, whereas the `forEach` method may make it unclear what
    the result of that returned is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9: Creating a Student Manager Using JavaScript Arrays and Classes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose you are working for a local school district, and up until now they''ve
    been using a paper register to keep track of student information. Now, they''ve
    had some funding and want you to develop a piece of computer software to track
    student information. They have the following requirements for the software:'
  prefs: []
  type: TYPE_NORMAL
- en: It needs to be able to record information about students, including their name,
    age, grade level, and book information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each student will be assigned a unique ID that will be used to retrieve and
    modify student record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Book information will include the name and the current grade (number grade)
    of the book for that student.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There needs to be a way to calculate the average grade for the student.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There needs to be a way to search for all students with the same age or grade
    level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There needs to be a way to search for a student using their name. When multiples
    are found, return all of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The complete code for this activity can also be found on our GitHub repository,
    here: [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson07/Activity09/Activity09.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson07/Activity09/Activity09.js).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `School` class and initialize a list of students in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Student` class and store a list of courses, the student's `age`, `name`,
    and `grade level` in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Course` class that will include information about `course`, `name`
    and `grades`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `addStudent` function in the `School` class to push students into
    a list in the `school` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `findByGrade` function in the `School` class, which returns all the
    students with a given `grade level`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `findByAge` function in the `School` class, which returns a list
    of students with the same `age`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `findByName` function in the `School` class, which searches for all
    the students in the school by name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Student` class, create a `calculateAverageGrade` method for calculating
    the average grade of the student.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Student` class, create a `assignGrade` method, which will assign a number
    grade for a course the student is taking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 608.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we went over methods that allow us to iterate, look
    up, and reduce our arrays. These are very useful methods when dealing with arrays.
    While most of the methods only accomplish basic tasks and they can be easily implemented
    using loops, using them helps with making our code more usable and testable. Some
    of the built-in methods are also well optimized by the runtime engine.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go over some built-in functions for Map and Set.
    They are very useful if we need to track values in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Maps and Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps and Sets are very underrated types in JavaScript, but they can be very
    powerful in some applications. Maps work just like a basic hashmap in JavaScript,
    and are useful when you need to keep track of a list of key-value pairs. Sets
    are used when you need to keep a list of unique values. Most developers often
    use objects for everything while forgetting that, in some cases, using Maps and
    Sets is way more efficient. In the following section, we will go over Maps and
    Sets and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many cases where we must keep track of a list of unique key-value
    pairs in our application. When programming with other languages, we often need
    to implement a class called **Hashmap**. In JavaScript, there are two types that
    can accomplish this: one is Map and the other is Object. Because they seem to
    do the same thing, many JavaScript developers tend to use Object for everything
    while ignoring that using Map is sometimes way more effective for their use case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 54: Using Maps versus Objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will go over ways we can use Maps and how they are different
    compared to Objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Map called `map`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a list of objects we want to use as keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `map.set` to set a value for all the keys we defined earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.36: Output after assigning values to map.set'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.36: Output after assigning values to map.set'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Get the values of the keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.37: Output of console.log for value retrieval'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.37: Output of console.log for value retrieval'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Retrieve the value for `key2` without using the reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.38: Output of console.log when using get without reference'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.38: Output of console.log when using get without reference'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While we typed everything correctly, our Map doesn't seem to be able to find
    the value for that key. This is because, when doing these retrievals, it is using
    the reference to the object instead of the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterate through the Map using `forEach`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The Map can be iterated through like an array. When using the `forEach` method,
    the function that is passed in will be called with two parameters: the first parameter
    is the value while the second parameter is the key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the list of keys and values as arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.39: List of keys and values as arrays'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.39: List of keys and values as arrays'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These methods are useful when you only need a part of the information it stores.
    If you have a Map tracking the users while using their IDs as keys, calling the
    `values` method will simply return a list of users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether the Map includes a key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.40: Output indicating that Map does not include a key'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.40: Output indicating that Map does not include a key'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here, we can see the first major difference between Maps and Objects, even though
    both are able to keep track of a list of unique key-value pairs. In Maps, you
    can have keys that are references of an object or function. This is not possible
    with Objects in JavaScript. Another thing we can see is that it also preserves
    the order of the keys according to the order that they are added to the Map. While
    you might get ordered keys in Objects, JavaScript does not guarantee the order
    for keys in terms of the order they are added into the Object.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this exercise, we went over the usage of Maps and its differences compared
    to Object. When you are dealing with key-value data and you need to do ordering,
    Map should be always preferred over Objects because not only does it keep the
    order of your keys, it also allows object references to be used as keys. That''s
    the main difference between the two types. In the next exercise, we will go over
    another type that is often overlooked by developers: Set.'
  prefs: []
  type: TYPE_NORMAL
- en: In mathematics, a set is defined as a collection of distinct objects. In JavaScript,
    it is rarely used, but we are going to go over one usage of Set regardless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 55: Using Sets to Track Unique Values'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will go over the JavaScript Set. We will be building an
    algorithm to remove all the duplicate values inside an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare an array string called `planets`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Set using the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the unique values in the `planets` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.41: Unique array values'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.41: Unique array values'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Add more values to the Set using the `add` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `add` method to add a new value to our Set, but because Set
    always maintains the uniqueness of its members, if you add anything that already
    exists, it will be ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.42: Failure to add duplicate values'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.42: Failure to add duplicate values'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Get the size of the Set using the `.size` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Clear all the values inside the Set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.43: All values cleared from the set'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.43: All values cleared from the set'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we went over some ways in which we can use Set as a tool to
    help us remove duplicate values in our arrays. Sets are very useful when you want
    to keep a list of unique values with the smallest effort possible while you don't
    have any need to access them through an index. Otherwise, arrays are still the
    best choice if you are dealing with a lot of items that may include duplicates.
    In the next section, we will talk about the Math, Date, and String methods.
  prefs: []
  type: TYPE_NORMAL
- en: Math, Date, and String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building complex applications using JavaScript, there will be times when
    you need to deal with string manipulation, math calculations, and dates. Luckily,
    JavaScript has several built-in methods for this type of data. In the following
    exercises, we will go over the ways we can utilize these in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `new Date` object, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: This will point to the current date.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new string, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the `Math` module, we can use the `Math` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 56: Using String Methods'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will go over some of the ways we can work with strings
    more easily in our applications. String manipulation and building have always
    been complex tasks in other languages. In JavaScript, by using String methods,
    we can create, match, and manipulate strings with ease. In this exercise, we will
    create various strings and use String methods to manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a variable called `planet`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `sentence` using template strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: A template strings is a very useful feature that was introduced in ES6\. We
    can create strings by combining templates and variables without the need to create
    a string build or using string concatenation. String templates are wrapped using
    [PRE156]
  prefs: []
  type: TYPE_NORMAL
- en: console.log(sentence.split(' '));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: sentence = sentence.replace('Earth', 'Venus');
  prefs: []
  type: TYPE_NORMAL
- en: console.log(sentence);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: console.log(sentence.includes('Mars'));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: sentence.toUpperCase();
  prefs: []
  type: TYPE_NORMAL
- en: sentence.toLowerCase();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: sentence.charAt(0); // returns W
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: sentence.length;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: function generateRandomString(length) {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: function generateRandomNumber(min, max) {
  prefs: []
  type: TYPE_NORMAL
- en: return Math.floor(Math.random() * (max - min + 1)) + min;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: function generateRandomString(length) {
  prefs: []
  type: TYPE_NORMAL
- en: const characters = [];
  prefs: []
  type: TYPE_NORMAL
- en: const characterSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  prefs: []
  type: TYPE_NORMAL
- en: for (let i = 0; i < length; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: characters.push(characterSet.charAt(generateRandomNumber(0, characterSet.length)));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return characters.join(');
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: console.log(generateRandomString(16));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: function circleArea(radius) {
  prefs: []
  type: TYPE_NORMAL
- en: return Math.pow(radius, 2) * Math.PI;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: const now = new Date();
  prefs: []
  type: TYPE_NORMAL
- en: console.log(now);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: const past = new Date('August 31, 2007 00:00:00');
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: console.log(past.getFullYear());
  prefs: []
  type: TYPE_NORMAL
- en: console.log(past.getMonth());
  prefs: []
  type: TYPE_NORMAL
- en: console.log(past.getDate());
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: console.log(past.toString());
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: console.log(Math.floor(Date.now() / 1000));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: let symbol1 = Symbol();
  prefs: []
  type: TYPE_NORMAL
- en: let symbol2 = Symbol('symbol');
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: console.log(symbol1 === symbol2);
  prefs: []
  type: TYPE_NORMAL
- en: console.log(symbol1 === Symbol('symbol'));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: const testObj = {};
  prefs: []
  type: TYPE_NORMAL
- en: testObj.name = 'test object';
  prefs: []
  type: TYPE_NORMAL
- en: testObj.included = 'this will be included';
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: const symbolKey = Symbol();
  prefs: []
  type: TYPE_NORMAL
- en: testObj[symbolKey] = 'this will be hidden';
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: console.log(Object.keys(testObj));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: console.log(testObj[Symbol()]); // Will return undefined
  prefs: []
  type: TYPE_NORMAL
- en: console.log(testObj[symbolKey]); // Will return our hidden property
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: const anotherSymbolKey = Symbol.for('key');
  prefs: []
  type: TYPE_NORMAL
- en: const copyOfAnotherSymbol = Symbol.for('key');
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: testObj[anotherSymbolKey] = 'another key';
  prefs: []
  type: TYPE_NORMAL
- en: console.log(testObj[copyOfAnotherSymbol]);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: function range(max) {
  prefs: []
  type: TYPE_NORMAL
- en: return {
  prefs: []
  type: TYPE_NORMAL
- en: '*[Symbol.iterator]() {'
  prefs: []
  type: TYPE_NORMAL
- en: yield 1;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: for (let value of range(10)) {
  prefs: []
  type: TYPE_NORMAL
- en: console.log(value);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: function range(max) {
  prefs: []
  type: TYPE_NORMAL
- en: return {
  prefs: []
  type: TYPE_NORMAL
- en: '*[Symbol.iterator]() {'
  prefs: []
  type: TYPE_NORMAL
- en: for (let i = 0; i < max; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: yield i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: function* gen() {
  prefs: []
  type: TYPE_NORMAL
- en: yield 1;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: const generator = gen();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: console.log(generator.next());
  prefs: []
  type: TYPE_NORMAL
- en: console.log(generator.next());
  prefs: []
  type: TYPE_NORMAL
- en: console.log(generator.next());
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: const handlers = {
  prefs: []
  type: TYPE_NORMAL
- en: 'set: (object, prop, value) => {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log('setting ' + prop);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: const proxiesValue = new Proxy({}, handlers);
  prefs: []
  type: TYPE_NORMAL
- en: proxiesValue.prop1 = 'hi';
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: const simpleObject = {};
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: const handlers = {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: const proxiesValue = new Proxy(simpleObject, handlers);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: const handlers = {
  prefs: []
  type: TYPE_NORMAL
- en: 'get: (object, prop) => {'
  prefs: []
  type: TYPE_NORMAL
- en: return 'values are private';
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: proxiedValue.key1 = 'value1';
  prefs: []
  type: TYPE_NORMAL
- en: console.log(proxiedValue.key1);
  prefs: []
  type: TYPE_NORMAL
- en: console.log(proxiedValue.keyDoesntExist);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'set: (object, prop, value) => {'
  prefs: []
  type: TYPE_NORMAL
- en: if (prop === 'id') {
  prefs: []
  type: TYPE_NORMAL
- en: if (!Number.isInteger(value)) {
  prefs: []
  type: TYPE_NORMAL
- en: throw new TypeError('The id needs to be an integer');
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: proxiedValue.id = 'not an id'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: function appendPrefix(prefix, input) {
  prefs: []
  type: TYPE_NORMAL
- en: const result = [];
  prefs: []
  type: TYPE_NORMAL
- en: for (var i = 0; i < input.length; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: result.push(prefix + input[i]);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: appendPrefix('Hi! ', ['Miku', 'Rin', 'Len']);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: function appendPrefix(prefix, input) {
  prefs: []
  type: TYPE_NORMAL
- en: return input.map((inputItem) => {
  prefs: []
  type: TYPE_NORMAL
- en: return prefix + inputItem;
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: appendPrefix('Hi! ', ['Miku', 'Rin', 'Len']);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will still get the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.61: Getting the same output after refactoring the code'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_07_60.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.61: Getting the same output after refactoring the code'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Activity 10: Refactoring Functions to Use Modern JavaScript Features'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have recently joined a company. The first task that's been assigned to you
    is to refactor a number of legacy modules. You opened the file and saw that the
    existing code has already been written using legacy JavaScript methods. You'll
    need to refactor all the functions in that file and make sure it can still pass
    the required test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `Activity10.js` using node.js to check that the tests have passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor the `itemExist` function using the `includes` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `array push` to add a new item to the bottom of the `pushunique` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `array.fill` in `createFilledArray` to fill our array with an initial value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `array.shift` in the `removeFirst` function to remove the first item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `array.pop` in the `removeLast` function to remove the last item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the spread operator in `cloneArray` to make a clone of our array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor the `Food` class using the `ES6` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After refactoring, run the code to observe that the same output is generated
    as it was by the legacy code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 611.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we learned how to use modern JavaScript functions by using
    refactoring functions. We have successfully learned how to rewrite code while
    maintaining its compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we started by looking at the ways we can construct and manipulate
    arrays and objects in JavaScript. Then, we looked at ways we can concatenate arrays
    and objects using spread operators. Using spread operators saves us from having
    to write functions without a loop. Later, we looked at ways we can do OOP in JavaScript.
    By using these classes and class inheritance, we can build complex applications
    without having to write a lot of duplicate code. We also looked at built-in methods
    for Array, Map, Set, Regex, Date, and Math. These are very helpful when we need
    to deal with a large number of different types of data. Lastly, Symbols, Iterators,
    Generators, and Proxies opened up a huge range of possibilities when it comes
    to making our program dynamic and clean. This concludes our chapter on advanced
    JavaScript. In the next chapter, we will talk about asynchronous programming in
    JavaScript.
  prefs: []
  type: TYPE_NORMAL

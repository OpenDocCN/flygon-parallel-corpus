- en: Algorithmic Trading Strategies - Coding Step by Step
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 算法交易策略-逐步编码
- en: It is a complex task to build your own algorithmic trading strategies. A trading
    platform with numerous components is required to test and run your strategy. Some
    of these components are the compute engine, real-time data feeds, broker connectivity,
    blotter, fund manager, clocks, a virtual order-management system, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自己的算法交易策略是一项复杂的任务。需要一个具有多个组件的交易平台来测试和运行您的策略。其中一些组件是计算引擎，实时数据源，经纪人连接性，记账簿，基金经理，时钟，虚拟订单管理系统等等。
- en: In this chapter, you will be using the services provided by AlgoBulls, an algorithmic
    trading platform ([https://algobulls.com](https://algobulls.com)). This platform
    provides a Python package called `pyalgotrading` ([https://github.com/algobulls/pyalgotrading](https://github.com/algobulls/pyalgotrading)).
    You will code your strategy as a Python class by subclassing the `StrategyBase`
    abstract class provided in the package. The abstract class acts as a template
    for developing and validating new strategies quickly with minimal effort. You
    can use the AlgoBulls platform to perform backtesting, paper trading, and real
    trading on your strategy. The `pyalgotrading` package helps us focus on developing
    the strategy and takes care of talking to the AlgoBulls platform for execution
    purposes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用AlgoBulls提供的服务，AlgoBulls是一个算法交易平台（[https://algobulls.com](https://algobulls.com)）。该平台提供了一个名为`pyalgotrading`的Python包（[https://github.com/algobulls/pyalgotrading](https://github.com/algobulls/pyalgotrading)）。您将通过继承包中提供的`StrategyBase`抽象类来编写您的策略。该抽象类充当了快速开发和验证新策略的模板，减少了开发工作量。您可以使用AlgoBulls平台对您的策略进行回测，模拟交易和实盘交易。`pyalgotrading`包帮助我们专注于开发策略，并负责与AlgoBulls平台进行交互以执行策略。
- en: 'This chapter introduces two strategies:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两种策略：
- en: '**EMA-Regular-Order strategy**: This strategy is based on the technical indicator
    exponential moving average. It uses regular orders.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EMA-Regular-Order策略**：该策略基于指数移动平均线技术指标。它使用常规订单。'
- en: '**MACD-Bracket-Order strategy**: This strategy is based on the technical indicator
    moving average convergence divergence. It uses bracket orders.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MACD-Bracket-Order策略**：该策略基于移动平均线收敛与背离技术指标。它使用挂单。'
- en: Initially, you may find strategy coding a daunting task. Therefore, the coding
    part is divided into five recipes. Each recipe demonstrates one or more methods
    enforced by the `StrategyBase` class. The sixth recipe demonstrates how to upload
    the strategy to the AlgoBulls platform.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，您可能会发现策略编码是一项艰巨的任务。因此，编码部分分为五个步骤。每个步骤演示了`StrategyBase`类强制执行的一个或多个方法。第六个步骤演示了如何将策略上传到AlgoBulls平台。
- en: 'The skeleton for a strategy looks as shown:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 策略的框架如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The AlgoBulls core engine is the trading engine powering the AlgoBulls platform.
    It is responsible for reading your strategies and executing them for backtesting,
    paper trading, and real trading. The AlgoBulls core engine uses the following
    flowchart for executing your strategy successfully:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: AlgoBulls核心引擎是AlgoBulls平台的交易引擎。它负责读取您的策略并执行它们进行回测，模拟交易和实盘交易。AlgoBulls核心引擎使用以下流程图成功执行您的策略：
- en: '![](img/cb26ef36-c0ba-4d61-b223-d6224f210f67.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb26ef36-c0ba-4d61-b223-d6224f210f67.png)'
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下步骤：
- en: EMA-Regular-Order strategy – coding the __init__, initialize, name, and versions_supported methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略-编写__init__，initialize，name和versions_supported方法
- en: EMA-Regular-Order strategy – coding the strategy_select_instruments_for_entry
    method
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略-编写strategy_select_instruments_for_entry方法
- en: EMA-Regular-Order strategy – coding the strategy_enter_position method
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略-编写strategy_enter_position方法
- en: EMA-Regular-Order strategy – coding the strategy_select_instruments_for_exit
    method
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略-编写strategy_select_instruments_for_exit方法
- en: EMA-Regular-Order strategy – coding the strategy_exit_position method
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略-编写strategy_exit_position方法
- en: EMA-Regular-Order strategy – uploading the strategy onto the AlgoBulls trading
    platform
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略-将策略上传到AlgoBulls交易平台
- en: MACD-Bracket-Order strategy – coding the __init__, initialize, name, and versions_supported methods
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略-编写__init__，initialize，name和versions_supported方法
- en: MACD-Bracket-Order strategy – coding the strategy_select_instruments_for_entry
    method
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略-编写strategy_select_instruments_for_entry方法
- en: MACD-Bracket-Order strategy – coding the strategy_enter_position method
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略-编写strategy_enter_position方法
- en: MACD-Bracket-Order strategy – coding the strategy_select_instruments_for_exit
    method
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略-编写strategy_select_instruments_for_exit方法
- en: MACD-Bracket-Order strategy – coding the strategy_exit_position method
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略-编写strategy_exit_position方法
- en: MACD-Bracket-Order strategy – uploading the strategy onto AlgoBulls trading
    platform
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略-将策略上传到AlgoBulls交易平台
- en: Technical requirements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following to execute the recipes in this chapter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下内容来执行本章的步骤：
- en: Python 3.7+
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.7+
- en: 'Python packages:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python包：
- en: '`pyalgotrading` (`$ pip install pyalgotrading`)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyalgotrading`（`$ pip install pyalgotrading`）'
- en: '`pyalgostrategypool` (`$ pip install pyalgostrategypool`)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyalgostrategypool`（`$ pip install pyalgostrategypool`）'
- en: '`TA-Lib` (`$ pip install TA-Lib`)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TA-Lib`（`$ pip install TA-Lib`）'
- en: 'If you face errors while installing `TA-Lib`, it will mostly be due to missing
    dependencies. You can follow these instructions to fix the issue:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在安装`TA-Lib`时遇到错误，这很可能是由于缺少依赖项。您可以按照以下说明来解决问题：
- en: '**For Mac OS X, use the following**:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于Mac OS X，请使用以下**：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**For Windows, use the following instructions**:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于Windows，请使用以下说明**：'
- en: You can install the latest `TA-Lib` binary from [https://www.lfd.uci.edu/~gohlke/pythonlibs/#ta-lib](https://www.lfd.uci.edu/~gohlke/pythonlibs/#ta-lib)
    based on your Windows build (32 bit/64 bit) and Python version. So, for example,
    this link on the site, [TA_Lib‑0.4.18‑cp38‑cp38‑win_amd64.whl](https://download.lfd.uci.edu/pythonlibs/w3jqiv8s/TA_Lib-0.4.18-cp39-cp39-win_amd64.whl),
    is for `TA-Lib` version 0.4.18 (`TA_Lib-0.4.18`) and Python version 3.8 (`cp38`),
    and is Windows 64-bit-compatible (`win_amd64`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据您的Windows版本（32位/64位）和Python版本从[https://www.lfd.uci.edu/~gohlke/pythonlibs/#ta-lib](https://www.lfd.uci.edu/~gohlke/pythonlibs/#ta-lib)安装最新的`TA-Lib`二进制文件。例如，该网站上的此链接[TA_Lib‑0.4.18‑cp38‑cp38‑win_amd64.whl](https://download.lfd.uci.edu/pythonlibs/w3jqiv8s/TA_Lib-0.4.18-cp39-cp39-win_amd64.whl)是`TA-Lib`版本0.4.18（`TA_Lib-0.4.18`）和Python版本3.8（`cp38`），并且是Windows
    64位兼容的（`win_amd64`）。
- en: '**For Linux, take the following steps**:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于Linux，请执行以下步骤**：'
- en: 'Download this `gzip` file—[http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz](http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz)—and
    run the following commands from your Linux Terminal:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的Linux终端运行以下命令：
- en: 'Extract the downloaded `gzip` file containing the source code for `TA-Lib`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取包含`TA-Lib`源代码的下载的`gzip`文件：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Change your current working directory to the extracted folder:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前工作目录更改为提取的文件夹：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the `configure` command to configure `TA-Lib` for your machine:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`configure`命令为您的机器配置`TA-Lib`：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the `make` command to build `TA-Lib` from the downloaded source code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`make`命令从下载的源代码构建`TA-Lib`：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the `install` command to install built executables and libraries to specific
    directories on your machine:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`install`命令将构建的可执行文件和库安装到您机器上的特定目录：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If this doesn't help and you still get errors, please refer to the official
    `TA-Lib` GitHub page at [https://github.com/mrjbq7/ta-lib#dependencies](https://github.com/mrjbq7/ta-lib#dependencies).
    The latest Jupyter notebook for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter08](https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter08).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这没有帮助，您仍然遇到错误，请参考官方的`TA-Lib` GitHub页面[https://github.com/mrjbq7/ta-lib#dependencies](https://github.com/mrjbq7/ta-lib#dependencies)。本章的最新Jupyter笔记本可以在GitHub上找到[https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter08](https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter08)。
- en: 'The following code will help you import the necessary modules that are used
    by all the recipes in this chapter. Please make sure you have followed this step
    before trying out any of the recipes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将帮助您导入本章中所有配方中使用的必要模块。请确保在尝试任何配方之前已经完成了这一步：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the first five recipes, you will create a complete algorithmic trading strategy
    based on the EMA technical indicator. This strategy is called the **EMA-Regular-Order**
    strategy and is described as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前五个配方中，您将基于EMA技术指标创建一个完整的算法交易策略。这个策略称为**EMA-Regular-Order**策略，描述如下：
- en: '**Technical indicators**:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术指标**：'
- en: '`EMA(timeperiod=4)` or `EMA4`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMA(timeperiod=4)`或`EMA4`'
- en: '`EMA(timeperiod=9)` or `EMA9`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMA(timeperiod=9)`或`EMA9`'
- en: While the typical values of the time periods are `4` and `9`, both of the time
    periods are taken as parameters, so they can be changed at runtime without having
    to recreate the strategy again. This is discussed more in the first recipe of
    this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管时间周期的典型值为`4`和`9`，但这两个时间周期都被视为参数，因此可以在运行时更改，而无需重新创建策略。这在本章的第一个配方中有更详细的讨论。
- en: '**Order attributes**:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单属性**：'
- en: 'Order transaction type: `BUY` and `SELL`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单交易类型：`买入`和`卖出`
- en: 'Order type: `Regular`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单类型：`常规`
- en: 'Order code: `INTRADAY`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单代码：`日内交易`
- en: 'Order variety: `Market`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单种类：`市价`
- en: '**Strategy algorithm**:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略算法**：'
- en: 'Whenever `EMA4` crosses `EMA9` upward, note the following:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当`EMA4`向上穿越`EMA9`时，请注意以下事项：
- en: The previous `SHORT` position, if present, should be exited.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在之前的`空头`头寸，则应退出。
- en: A `BUY` signal is generated by the strategy and a new `LONG` position should
    be entered.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略生成`买入`信号，应输入新的`多头`头寸。
- en: 'Whenever `EMA4` crosses `EMA9` downward, note the following:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当`EMA4`向下穿越`EMA9`时，请注意以下事项：
- en: The previous `LONG` position, if present, should be exited.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在之前的`多头`头寸，则应退出。
- en: A `SELL` signal is generated by the strategy and a new `SHORT` position should
    be entered.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略生成`卖出`信号，应输入新的`空头`头寸。
- en: You will code the entire logic as a single Python class called `StrategyEMARegularOrder`.
    This class will be a subclass of `StrategyBase` from the `pyalgotrading` package.
    After uploading `StrategyEMARegularOrder` on the AlgoBulls platform, you can backtest
    (refer to the first six recipes of [Chapter 9](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml),
    *Backtesting Strategies*), paper trade (refer to the first five recipes of [Chapter
    10](0f869a6e-bb6b-4f5f-828e-33ca477c509d.xhtml), *Paper Trading*), and real trade
    (refer to the first five recipes of [Chapter 11](725b5f38-fffb-46ae-8b5b-8a4667419e3a.xhtml),
    *Real Trading*) on this strategy.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您将把整个逻辑编码为一个名为`StrategyEMARegularOrder`的Python类。这个类将是`pyalgotrading`包中`StrategyBase`的子类。在AlgoBulls平台上上传`StrategyEMARegularOrder`后，您可以在这个策略上进行回测（参考[第9章](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml)的前六个配方，*回测策略*），模拟交易（参考[第10章](0f869a6e-bb6b-4f5f-828e-33ca477c509d.xhtml)的前五个配方，*模拟交易*），和真实交易（参考[第11章](725b5f38-fffb-46ae-8b5b-8a4667419e3a.xhtml)的前五个配方，*真实交易*）。
- en: 'In the seventh to eleventh recipes, you will create a complete algorithmic
    trading strategy based on the MACD technical indicator. This strategy is called
    as the **MACD-Bracket-Order** strategy and is described as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第七到第十一个配方中，您将基于MACD技术指标创建一个完整的算法交易策略。这个策略称为**MACD-Bracket-Order**策略，描述如下：
- en: '**Technical indicators**:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术指标**：'
- en: 'MACD: This technical indicator has three components: the MACD line, MACD signal,
    and MACD histogram. We are concerned only with the MACD line and MACD signal components
    for this strategy.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MACD：这个技术指标有三个组成部分：MACD线、MACD信号和MACD柱状图。对于这个策略，我们只关注MACD线和MACD信号的部分。
- en: '**Order attributes**:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单属性**：'
- en: 'Order transaction type: `BUY` and `SELL`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单交易类型：`买入`和`卖出`
- en: 'Order type: `Bracket`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单类型：`Bracket`
- en: 'Order code: `INTRADAY`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单代码：`日内交易`
- en: 'Order variety: `Limit`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单类型：`限价`
- en: '**Strategy algorithm**:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略算法**：'
- en: 'Whenever the MACD line crosses the MACD signal upward, note the following:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当MACD线向上穿越MACD信号时，注意以下内容：
- en: The previous `SHORT` position, if present, should be exited.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在先前的`空`头寸，则应退出。
- en: A `BUY` signal is generated by the strategy and a new `LONG` position should
    be entered.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略生成`买入`信号，应该进入一个新的`多`头寸。
- en: 'Whenever the MACD line crosses the MACD signal downward, note the following:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当MACD线向下穿越MACD信号时，注意以下内容：
- en: The previous `LONG` position, if present, should be exited.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在先前的`多`头寸，则应退出。
- en: A `SELL` signal is generated by the strategy and a new `SHORT` position should
    be entered.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略生成`卖出`信号，应该进入一个新的`空`头寸。
- en: You will code the entire logic as a single Python class, called `StrategyMACDBracketOrder`.
    This class will be a subclass of `StrategyBase` from the `pyalgotrading` package.
    After uploading `StrategyMACDBracketOrder` onto the AlgoBulls platform, you can
    backtest (refer to the seventh to twelfth recipes of [Chapter 9](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml),
    *Algorithmic Trading – Backtesting*), paper trade (refer to the seventh to twelfth
    recipes of [Chapter 10](0f869a6e-bb6b-4f5f-828e-33ca477c509d.xhtml), *Algorithmic
    Trading – **Paper Trading*), and real trade (refer to the seventh to eleventh
    recipes of [Chapter 11](725b5f38-fffb-46ae-8b5b-8a4667419e3a.xhtml), *Algorithmic
    Trading – **Real Trading*) on this strategy.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您将把整个逻辑编码为一个名为`StrategyMACDBracketOrder`的单个Python类。这个类将是`pyalgotrading`包中`StrategyBase`的子类。将`StrategyMACDBracketOrder`上传到AlgoBulls平台后，您可以在该策略上进行回测（参考[第9章](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml)的第七到第十二个配方，*算法交易-回测*），模拟交易（参考[第10章](0f869a6e-bb6b-4f5f-828e-33ca477c509d.xhtml)的第七到第十二个配方，*算法交易-模拟交易*），和真实交易（参考[第11章](725b5f38-fffb-46ae-8b5b-8a4667419e3a.xhtml)的第七到第十一个配方，*算法交易-真实交易*）。
- en: 'For more information on these topics, please refer to the following corresponding
    chapters:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些主题的更多信息，请参阅以下相应的章节：
- en: '**Technical indicators**: [Chapter 5](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml),
    *Computing and Plotting Technical Indicators*'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术指标**：[第5章](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml)，*计算和绘制技术指标*'
- en: '**Order attributes**: [Chapter 6](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml),
    *Placing Regular Orders on the Exchange* and [Chapter 7](d5760c5d-fa09-4008-ab45-5d7d69c4bde9.xhtml),
    *Placing Bracket and Cover Orders on the Exchange*.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单属性**：[第6章](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml)，*在交易所上放置常规订单*和[第7章](d5760c5d-fa09-4008-ab45-5d7d69c4bde9.xhtml)，*在交易所上放置Bracket和Cover订单*。'
- en: You need to set up your account on the AlgoBulls platform ([https://algobulls.com](https://algobulls.com))
    to get your API token. Setting up an account is free. Using its services might
    incur charges depending on your usage. You can start with free packages on the
    site. Refer to *Appendix II* for more details.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在AlgoBulls平台（[https://algobulls.com](https://algobulls.com)）上设置您的账户以获取API令牌。设置账户是免费的。使用其服务可能会产生费用，具体取决于您的使用情况。您可以从网站上免费开始。有关更多详细信息，请参阅*附录II*。
- en: EMA-Regular-Order strategy – coding the __init__, initialize, name, and versions_supported
    methods
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略-编码__init__、initialize、name和versions_supported方法
- en: 'This recipe demonstrates the initial coding of the `StrategyEMARegularOrder`
    class. The complete class will be coded by the end of the *EMA-Regular-Order strategy
    – coding the strategy_exit_position method* recipe of this chapter. In this recipe,
    you will code the following methods:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方演示了`StrategyEMARegularOrder`类的初始编码。完整的类将在本章的*EMA-Regular-Order策略-编码strategy_exit_position方法*配方结束时编码。在这个配方中，您将编写以下方法：
- en: '`__init__()`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`'
- en: '`initialize()`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()`'
- en: '`name()`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name()`'
- en: '`versions_supported()`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`versions_supported()`'
- en: To learn more about the EMA technical indicator, please refer to the *Trend
    indicator – exponential moving average* recipe of [Chapter 5](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml), *Computing
    and Plotting Technical Indicators*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关EMA技术指标的更多信息，请参考[第5章](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml)的*Trend
    indicator- exponential moving average*配方。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `__init__()` and `initialize()` methods
    during strategy execution.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`__init__()`和`initialize()`方法。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure you have the `StrategyBase` and `pyalgotrading` constants in your
    Python namespace. Refer to the *Technical requirements* section of this chapter
    to set it up.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的Python命名空间中有`StrategyBase`和`pyalgotrading`常量。请参考本章的*技术要求*部分进行设置。
- en: How to do it…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a new class named `StrategyEMARegularOrder`, which will be a subclass
    from `StrategyBase` and then define the required four methods:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`StrategyEMARegularOrder`的新类，它将是`StrategyBase`的子类，然后定义所需的四种方法：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we create the `StrategyEMARegularOrder` class, subclassed from
    `StrategyBase`. We define four methods for this class and describe them as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们创建了`StrategyEMARegularOrder`类，它是从`StrategyBase`派生的子类。我们为这个类定义了四种方法，并将它们描述如下：
- en: 'The `__init__()` method: This is the first thing to do when you create a new
    strategy. First, you create this method and call the parent class `__init__()`
    method using `super()`. This helps the AlgoBulls core engine create the necessary
    data structures needed for further development of the strategy. Next, you create
    two new attributes from `self.strategy_parameters`—`self.timeperiod1` and `self.timeperiod2`.
    `self.strategy_parameters` is a dictionary object available for every strategy
    subclassed from `StrategyBase`. (The second recipe of [Chapter 8](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml),
    *Backtesting Strategies*, discusses how these values are passed at runtime to
    `self.strategy_parameters`.) You will use these parameters as time periods of
    both the EMAs in the next recipe.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`方法：当您创建一个新策略时，这是要做的第一件事。首先，您创建这个方法，并使用`super()`调用父类的`__init__()`方法。这有助于AlgoBulls核心引擎创建进一步开发策略所需的必要数据结构。接下来，您从`self.strategy_parameters`中创建了两个新属性——`self.timeperiod1`和`self.timeperiod2`。`self.strategy_parameters`是从`StrategyBase`继承的每个策略子类都可用的字典对象。（[第8章](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml)的第二个示例讨论了这些值如何在运行时传递给`self.strategy_parameters`。）您将在下一个示例中将这些参数用作两个EMA的时间周期。'
- en: Lastly, you create a new attribute, `self.main_order`, which is an empty dictionary.
    We will use this to save the handles to all the open orders placed during the
    execution of this strategy.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您创建了一个新属性`self.main_order`，它是一个空字典。我们将用它来保存在执行这个策略期间放置的所有未完成订单的句柄。
- en: 'The `initialize()` method: This method is called at the beginning of every
    market day to initialize any internal variables to their default state. For real
    trading and paper trading, this method is called once. For multi-day backtesting,
    this method is called multiple times, once at the beginning of every new trading
    day. In this method, you initialize `self.main_order` to an empty dictionary.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()`方法：这个方法在每个交易日的开始被调用，用于将任何内部变量初始化为它们的默认状态。对于实际交易和模拟交易，这个方法只会被调用一次。对于多天的回测，这个方法会在每个新的交易日的开始被调用多次。在这个方法中，您将`self.main_order`初始化为空字典。'
- en: 'The `name()` method: This is a static method, which returns the name of this
    strategy. This is used while availing backtesting, paper trading, and real trading
    services on this strategy. In this method, you simply return a string, `Exponential
    Moving Average Regular Order`. You can return any string of your choice.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name()`方法：这是一个静态方法，返回这个策略的名称。在使用这个策略进行回测、模拟交易和实际交易服务时会用到。在这个方法中，您只需返回一个字符串，`Exponential
    Moving Average Regular Order`。您可以返回任何您喜欢的字符串。'
- en: 'The `versions_supported()` method: This static method is used for returning
    the AlgoBulls core engine version for which this strategy has been created. Often,
    as new upgrades come to the AlgoBulls core engine, some backward-incompatible
    changes may get introduced. This method helps to ensure this strategy is run on
    the correct version of the AlgoBulls core engine at all times. In this method,
    you return the highest available version from the constants module, which at the
    time of writing this chapter is VERSION_3_2_0.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`versions_supported()`方法：这是一个静态方法，用于返回此策略所创建的AlgoBulls核心引擎版本。通常，随着AlgoBulls核心引擎的新升级，可能会引入一些不兼容的变化。这个方法有助于确保这个策略始终在正确的AlgoBulls核心引擎版本上运行。在这个方法中，您返回常量模块中最高可用的版本，即在撰写本章时为VERSION_3_2_0。'
- en: These four methods are mandatory; they are enforced by the `StrategyBase` base
    class and cannot be skipped.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个方法是必需的；它们是由`StrategyBase`基类强制执行的，不能被跳过。
- en: EMA-Regular-Order strategy – coding the strategy_select_instruments_for_entry
    method
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略——编写strategy_select_instruments_for_entry方法
- en: In this recipe, you continue coding the `StrategyEMARegularOrder` class. Here,
    you code the `strategy_select_instruments_for_entry()` method, a mandatory method
    enforced by the `StrategyBase` base class. This method is called by the AlgoBulls
    core engine on every new candle for backtesting, paper trading, and real trading
    services.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将继续编写`StrategyEMARegularOrder`类。在这里，您将编写`strategy_select_instruments_for_entry()`方法，这是`StrategyBase`基类强制执行的一个必需方法。AlgoBulls核心引擎会在每个新的蜡烛图上调用这个方法，用于回测、模拟交易和实际交易服务。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_select_instruments_for_entry()`
    method during strategy execution.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_select_instruments_for_entry()`方法。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have followed the preceding recipe to create the `StrategyEMARegularOrder`
    class before starting this recipe.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本示例之前，请确保您已经按照前面的示例创建了`StrategyEMARegularOrder`类。
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Continue coding the `StrategyEMARegularOrder` class. We need to define two
    new methods—a method for getting the crossover value between the MACD line and
    MACD history signals and a method for selecting instruments from `instruments_bucket`
    for entering a new position based on the computed crossover value:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyEMARegularOrder`类。我们需要定义两个新方法——一个用于获取MACD线和MACD历史信号之间的交叉值，另一个用于根据计算出的交叉值从`instruments_bucket`中选择进入新仓位的工具：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we continue coding the `StrategyEMARegularOrder` class. We
    define two new methods for this class, described as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将继续编写`StrategyEMARegularOrder`类。我们为这个类定义了两个新方法，如下所述：
- en: 'The `get_crossover_value()` method: This method takes `instrument` as an argument
    (along with `self`). This is the financial instrument for which the crossover
    value has to be computed. You fetch the latest historical data using the `self.get_historical_data()`
    method and assign it to a new attribute, `hist_data`. We pass `instrument` as
    the argument to this method. The `hist_data` attribute is a `pandas.DataFrame`
    object with `timestamp`, `open`, `high`, `low`, `close`, and `volume` columns.
    The default duration of the fetched historical data is the last 15 days.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_crossover_value()`方法：这个方法以`instrument`作为参数（以及`self`）。这是需要计算交叉值的金融工具。你使用`self.get_historical_data()`方法获取最新的历史数据，并将其赋值给一个新属性`hist_data`。我们将`instrument`作为参数传递给这个方法。`hist_data`属性是一个带有`timestamp`、`open`、`high`、`low`、`close`和`volume`列的`pandas.DataFrame`对象。获取的历史数据的默认持续时间是最近的15天。'
- en: You compute EMA on the close of `hist_data` using the `talib.EMA` function,
    for a time period of `self.timeperiod1`, and assign it to `ema_x`. This data is
    a `pandas.Series` object. (Refer to the second recipe of [Chapter 5](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml), *Computing
    and Plotting of Technical Indicators*, for more details on the computation of
    EMA.) Similarly, you compute EMA on the close of `hist_data` for a time period
    of `self.timeperiod2` and assign it to `ema_y`. This return data is again a `pandas.Series`
    object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`talib.EMA`函数在`hist_data`的收盘价上计算EMA，时间段为`self.timeperiod1`，并将其赋值给`ema_x`。这些数据是`pandas.Series`对象。（有关计算EMA的更多细节，请参阅[第5章](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml)的第二个配方，*计算和绘制技术指标*。）同样，你使用`self.timeperiod2`的时间段在`hist_data`的收盘价上计算EMA，并将其赋值给`ema_y`。这些返回数据同样是`pandas.Series`对象。
- en: 'You compute the crossover value between `ema_x` and `ema_y` using `self.utils.crossover(ema_x,
    ema_y)` and assign it to a new attribute, `crossover_value`. The `crossover()`
    function call works as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`self.utils.crossover(ema_x, ema_y)`计算`ema_x`和`ema_y`之间的交叉值，并将其赋值给一个新属性`crossover_value`。`crossover()`函数调用如下：
- en: It takes two iterables as input. We pass `ema_x` and `ema_y` here.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受两个可迭代对象作为输入。我们在这里传递`ema_x`和`ema_y`。
- en: If `ema_x` crosses `ema_y` upward, the crossover function returns `1`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ema_x`向上穿过`ema_y`，交叉函数返回`1`。
- en: If `ema_x` crosses `ema_y` downward, the crossover function returns `-1`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ema_x`向下穿过`ema_y`，交叉函数返回`-1`。
- en: If there is no crossover between `ema_x` and `ema_y`, then the crossover function
    returns `0`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ema_x`和`ema_y`之间没有交叉，那么交叉函数返回`0`。
- en: Finally, you return `crossover_value`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你返回`crossover_value`。
- en: 'The `strategy_select_instruments_for_entry()` method: This method takes two
    arguments, other than `self`—`candle`, an object of the `CandleTime` type that
    contains the timestamp of the current candle, and `instruments_bucket`, an object
    of the `SetInstruments` type that contains all the financial instruments available
    for creating a new position. We pass this data at the time of strategy execution.
    You create two empty lists, `selected_instruments_bucket` and `sideband_info_bucket`.
    Then you run a `for` loop over `instruments_bucket`, and for each instrument,
    you call `self.get_crossover_value()` and save its value to a new attribute, `crossover_value`.
    Based on the value of `crossover_value`, you make a decision, as follows:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strategy_select_instruments_for_entry()`方法：这个方法除了`self`之外，还接受两个参数——`candle`，一个包含当前蜡烛时间戳的`CandleTime`类型的对象，和`instruments_bucket`，一个包含所有可用于创建新头寸的金融工具的`SetInstruments`类型的对象。我们在策略执行时传递这些数据。你创建两个空列表，`selected_instruments_bucket`和`sideband_info_bucket`。然后你对`instruments_bucket`运行一个`for`循环，对于每个金融工具，你调用`self.get_crossover_value()`，并将其值保存到一个新属性`crossover_value`。根据`crossover_value`的值，你做出决定，如下：'
- en: 'If `crossover_value` is `1`, it means the strategy is giving a `BUY` signal.
    You do the following:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`是`1`，这意味着策略发出了`BUY`信号。你要做以下操作：
- en: Append `instrument` to `selected_instruments_bucket`.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`instrument`附加到`selected_instruments_bucket`。
- en: 'Append an `{''action'': ''BUY''}` dictionary to the `sideband_info_bucket`
    attribute.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '向`sideband_info_bucket`属性附加一个`{''action'': ''BUY''}`字典。'
- en: 'If `crossover_value` is `-1`, it means the strategy is giving a `SELL` signal.
    You do the following:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`是`-1`，这意味着策略发出了`SELL`信号。你要做以下操作：
- en: Append `instrument` to `selected_instruments_bucket`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`instrument`附加到`selected_instruments_bucket`。
- en: 'Append an `{''action'': ''SELL''}` dictionary to the `sideband_info_bucket`
    attribute.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '向`sideband_info_bucket`属性附加一个`{''action'': ''SELL''}`字典。'
- en: If `crossover_value` is neither `1` nor `-1`, it means the strategy is not giving
    any signals. You do nothing here.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`既不是`1`也不是`-1`，这意味着策略没有发出任何信号。在这里你什么都不做。
- en: Finally, you return both the attributes: `selected_instruments_bucket` and `sideband_info_bucket`.
    These attributes may have been populated or may remain as empty lists.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你返回这两个属性：`selected_instruments_bucket`和`sideband_info_bucket`。这些属性可能已经被填充，也可能仍然是空列表。
- en: Recall that the `strategy_select_instruments_for_entry()` method is called for
    every candle, so the preceding steps are repeated for every new candle. In the
    appropriate candle, you would get a `BUY` or a `SELL` signal, and in the others,
    you won't get any signal. Based on the signal, you can place the appropriate order,
    which is discussed in the next recipe.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`strategy_select_instruments_for_entry()`方法是针对每个蜡烛调用的，因此前面的步骤会针对每个新的蜡烛重复。在适当的蜡烛中，你会得到一个`BUY`或`SELL`信号，而在其他蜡烛中，你不会得到任何信号。根据信号，你可以下达适当的订单，这将在下一个配方中讨论。
- en: The `strategy_select_instruments_for_entry()` method is enforced by the `StrategyBase`
    base class and has to be defined for every strategy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`strategy_select_instruments_for_entry()`方法是由`StrategyBase`基类强制的，对于每个策略都必须定义。'
- en: The `get_crossover_value()` method is a helper method, meaning it is not enforced
    by the `StrategyBase` base class. You may choose not to define this or to define
    multiple of these helper functions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_crossover_value()`方法是一个辅助方法，这意味着它不是`StrategyBase`基类强制的。你可以选择不定义这个方法，或者定义多个这样的辅助函数。'
- en: EMA-Regular-Order strategy – coding the strategy_enter_position method
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略-编写strategy_enter_position方法
- en: In this recipe, you continue with the coding of the `StrategyEMARegularOrder`
    class. Here, you code the `strategy_enter_position()` method, a mandatory method
    enforced by the `StrategyBase` base class. This method is called by the AlgoBulls
    core engine every time the `strategy_select_instruments_for_entry` method returns
    non-empty data. This method may not be called for every new candle for backtesting,
    paper trading, and real trading services.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您继续编写`StrategyEMARegularOrder`类。在这里，您编写`strategy_enter_position()`方法，这是`StrategyBase`基类强制执行的一个必需方法。每当`strategy_select_instruments_for_entry`方法返回非空数据时，AlgoBulls核心引擎都会调用此方法。对于回测、模拟交易和实际交易服务，这个方法可能不会在每个新蜡烛时被调用。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_enter_position()` method during
    strategy execution.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_enter_position()`方法。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have followed the preceding recipe before starting this recipe.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本配方之前，请确保您已经按照前面的配方进行了操作。
- en: How to do it…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Continue coding the `StrategyEMARegularOrder` class. We need to define a method
    to punch new orders for a given instrument and enter a new position:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyEMARegularOrder`类。我们需要定义一个方法来为给定的工具打新订单并进入新的头寸：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we continue coding the `StrategyEMARegularOrder` class. We
    define a new method for this class, `strategy_enter_position()`, described as
    follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们继续编写`StrategyEMARegularOrder`类。我们为这个类定义了一个新方法`strategy_enter_position()`，描述如下：
- en: 'This method takes three arguments, other than `self`:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了`self`之外，此方法还需要三个参数：
- en: '`candle`: An object of the `CandleTime` type that contains the timestamp of
    the current candle.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle`：`CandleTime`类型的对象，包含当前蜡烛的时间戳。'
- en: '`instrument`: An object of the `Instrument` type that represents a financial
    instrument.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument`：代表金融工具的`Instrument`类型的对象。'
- en: '`sideband_info`: A dictionary object that holds information on trades to be
    placed for the `instrument` attribute. This object looks like `{''action'': [action_value]}`,
    where `[action_value]` can be either `''BUY''` or `''SELL''`.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sideband_info`：一个字典对象，包含有关要为`instrument`属性放置交易的信息。此对象看起来像`{''action'': [action_value]}`，其中`[action_value]`可以是`''BUY''`或`''SELL''`。'
- en: You calculate the quantity for order to be placed by multiplying `self.number_of_lots`
    with `instrument.lot_size` and assign it to a new attribute `qty`. The `self.number_of_lots`
    attribute holds information on the number of lots to trade, which you can pass
    while executing this strategy. The `instrument.lot_size` attribute holds `lot_size`
    for `instrument`, which is a positive integer. For example, if number of lots
    is passed as 2 and lot size for instrument is 10, then the quantity for the order
    would be 2 * 10 = 20.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过将`self.number_of_lots`与`instrument.lot_size`相乘来计算要放置的订单数量，并将其分配给一个新属性`qty`。`self.number_of_lots`属性保存有关要交易的手数的信息，您可以在执行此策略时传递。`instrument.lot_size`属性保存了`instrument`的`lot_size`，它是一个正整数。例如，如果手数为2，而工具的手数为10，那么订单的数量将是2
    * 10 = 20。
- en: 'If `sideband_info` is `{''action'': ''BUY''}`, you place a `Regular` order
    of the `BUY` transaction type by creating an instance of the `self.broker.BuyOrderRegular`
    class (the first recipe of [Chapter 6](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml), *Placing
    Regular Orders on the Exchange*) and assigning its value to `self.main_order[instrument]`.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`sideband_info`是`{''action'': ''BUY''}`，则通过创建`self.broker.BuyOrderRegular`类的实例（[第6章](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml)的第一个配方，*在交易所上放置常规订单*）并将其值分配给`self.main_order[instrument]`，来放置`BUY`交易类型的`Regular`订单。'
- en: 'If `sideband_info` is `{''action'': ''SELL''}`, you place a `Regular` order
    of the `SELL` transaction type by creating an instance of the `self.broker.SellOrderRegular`
    class (the first recipe of [Chapter 6](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml),
    *Placing Regular Orders on the Exchange*) and assigning its value to `self.main_order[instrument]`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`sideband_info`是`{''action'': ''SELL''}`，则通过创建`self.broker.SellOrderRegular`类的实例（[第6章](077b54a1-c9c4-424c-912a-11f28db3797f.xhtml)的第一个配方，*在交易所上放置常规订单*）并将其值分配给`self.main_order[instrument]`，来放置`SELL`交易类型的`Regular`订单。'
- en: In both cases, the `self.main_order dictionary` object holds the `instrument`
    and `order` instances as a key-value pair. This will be useful later (in the *EMA-Regular-Order
    strategy – coding the strategy_exit_position method* recipe) for exiting positions
    created by this method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`self.main_order`字典对象将`instrument`和`order`实例作为键值对保存。这将在稍后（在*EMA-Regular-Order策略
    - 编写strategy_exit_position方法*配方中）对由此方法创建的头寸进行退出时非常有用。
- en: The `self.broker` attribute is replaced by the appropriate broker instance at
    runtime by the AlgoBulls core engine. So, the same code can work across all the
    brokers supported by the AlgoBulls platform.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.broker`属性在运行时由AlgoBulls核心引擎替换为适当的经纪人实例。因此，相同的代码可以在AlgoBulls平台支持的所有经纪人上运行。'
- en: EMA-Regular-Order strategy – coding the strategy_select_instruments_for_exit
    method
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略 - 编写strategy_select_instruments_for_exit方法
- en: In this recipe, you continue with the coding of the `StrategyEMARegularOrder`
    class. Here, you code the `strategy_select_instruments_for_exit()` method, a mandatory
    method enforced by the `StrategyBase` base class. This method is called by the
    AlgoBulls core engine for every new candle for backtesting, paper trading, and
    real trading services if there are any open positions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您继续编写`StrategyEMARegularOrder`类。在这里，您编写`strategy_select_instruments_for_exit()`方法，这是`StrategyBase`基类强制执行的一个必需方法。如果有任何未平仓头寸，AlgoBulls核心引擎会在每个新蜡烛时调用此方法，用于回测、模拟交易和实际交易服务。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_select_instruments_for_exit()`
    method during strategy execution.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_select_instruments_for_exit()`方法。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have followed the preceding recipe before starting this recipe.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本配方之前，请确保您已经按照前面的配方进行了操作。
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Continue coding the `StrategyEMARegularOrder` class. We need to define a new
    method for selecting instruments from `instruments_bucket` for exiting an existing
    position based on the computation of the crossover value:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyEMARegularOrder`类。我们需要为从`instruments_bucket`中选择工具退出现有头寸的计算定义一个新方法：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we continue coding the `StrategyEMARegularOrder` class. We
    define a new method for this class, `strategy_select_instruments_for_exit()`,
    described as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们继续编写`StrategyEMARegularOrder`类。我们为这个类定义一个新方法`strategy_select_instruments_for_exit()`，描述如下：
- en: 'This method takes two arguments, other than `self`:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个方法除了`self`之外还有两个参数：
- en: '`candle`: An object of the `CandleTime` type that contains the timestamp of
    the current candle.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle`：`CandleTime`类型的对象，包含当前蜡烛的时间戳。'
- en: '`instruments_bucket`: An object of the `SetInstruments` type. This object holds
    financial instruments that have been entered into a position earlier by the `strategy_enter_position()`
    method.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instruments_bucket`：`SetInstruments`类型的对象。这个对象保存了通过`strategy_enter_position()`方法之前进入头寸的金融工具。'
- en: You create two empty lists, `selected_instruments_bucket` and `sideband_info_bucket`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您创建两个空列表，`selected_instruments_bucket`和`sideband_info_bucket`。
- en: You run a `for` loop over `instruments_bucket`. For each instrument, you check
    whether there is a position entered for the given instrument using the `'if self.main_order.get(instrument)
    is not None:'` line. You proceed only if a position exists already.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您在`instruments_bucket`上运行一个`for`循环。对于每个工具，您检查是否已经输入了给定工具的头寸，使用`'if self.main_order.get(instrument)
    is not None:'`行。只有在已经存在头寸的情况下才继续。
- en: 'You call `self.get_crossover_value()` and save its value to a new attribute,
    `crossover_value`. Based on the value of `crossover_value`, you make a decision,
    as follows:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您调用`self.get_crossover_value()`并将其值保存到一个新属性`crossover_value`中。根据`crossover_value`的值，您可以做出决定，如下所示：
- en: 'If `crossover_value` is either `1` or `-1`, it means there has been a crossover.
    You do the following:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`是`1`或`-1`，这意味着已经发生了交叉。您可以执行以下操作：
- en: Append the `instrument` attribute to `selected_instruments_bucket`.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`instrument`属性附加到`selected_instruments_bucket`。
- en: 'Append an `{''action'': ''EXIT''}` dictionary to the `sideband_info_bucket`
    attribute.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将一个`{''action'': ''EXIT''}`字典附加到`sideband_info_bucket`属性。'
- en: If `crossover_value` is neither `1` nor `-1`, it means the strategy is not giving
    any signal. You do nothing here.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`既不是`1`也不是`-1`，这意味着策略没有发出任何信号。在这里你什么也不做。
- en: Finally, you return both the attributes: `selected_instruments_bucket` and `sideband_info_bucket`.
    These attributes may have gotten populated or may remain as empty lists.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，您返回`selected_instruments_bucket`和`sideband_info_bucket`两个属性。这些属性可能已经被填充，也可能仍然是空列表。
- en: Recall that the `strategy_select_instruments_for_exit()` method is called for
    every candle, so the preceding steps are repeated for every new candle. In the
    appropriate candle, if there is a position, you may get an `EXIT` signal, and
    in the others, you won't get any signal. Based on the signal, you can exit the
    position by placing an appropriate order, which is discussed in the next recipe.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请回想一下，`strategy_select_instruments_for_exit()`方法是为每个蜡烛调用的，因此前面的步骤对于每个新的蜡烛都会重复。在适当的蜡烛中，如果有一个头寸，您可能会得到一个`EXIT`信号，在其他情况下，您不会得到任何信号。根据信号，您可以通过下一个配方中讨论的适当订单退出头寸。
- en: EMA-Regular-Order strategy – coding the strategy_exit_position method
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略-编写`strategy_exit_position`方法
- en: In this recipe, you will continue with the coding of the `StrategyEMARegularOrder`
    class. Here, you will code the `strategy_exit_position()` method, the last mandatory
    method enforced by the `StrategyBase` base class. This method is called by the
    AlgoBulls core engine every time the `strategy_select_instruments_for_exit` method
    returns non-empty data. By the end of this recipe, you will have completed coding
    the `StrategyEMARegularOrder` class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将继续编写`StrategyEMARegularOrder`类。在这里，您将编写`strategy_exit_position()`方法，这是`StrategyBase`基类强制执行的最后一个必需方法。这个方法是由AlgoBulls核心引擎在`strategy_select_instruments_for_exit`方法返回非空数据时调用的。在本配方结束时，您将完成`StrategyEMARegularOrder`类的编写。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how AlgoBulls core engine calls the `strategy_select_instruments_for_exit()` method
    during strategy execution.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_select_instruments_for_exit()`方法。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have followed the previous recipe before starting this recipe.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本配方之前，请确保您已经按照上一个配方进行了操作。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Continue coding the `StrategyEMARegularOrder` class. Define a method to the
    exit position for a given instrument based on `sideband_info`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyEMARegularOrder`类。根据`sideband_info`定义一个退出给定工具头寸的方法：
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we continue coding the `StrategyEMARegularOrder` class. We
    define a new method for this class, `strategy_exit_position()`, described as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们继续编写`StrategyEMARegularOrder`类。我们为这个类定义一个新方法`strategy_exit_position()`，描述如下：
- en: 'This method takes three arguments, other than `self`:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个方法除了`self`之外还有三个参数：
- en: '`candle`: An object of `CandleTime` type that contains the timestamp of the
    current candle.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle`：包含当前蜡烛的时间戳的`CandleTime`类型的对象。'
- en: '`instrument`: An object of `Instrument` type that represents a financial instrument.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument`：代表金融工具的`Instrument`类型的对象。'
- en: '`sideband_info`: A dictionary object that holds information on trades to be
    placed for the `instrument` attribute. This object looks like `{''action'': ''EXIT''}`.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sideband_info`：一个字典对象，保存了有关要为`instrument`属性放置的交易的信息。这个对象看起来像`{''action'':
    ''EXIT''}`。'
- en: 'If `sideband_info` is `{''action'': ''EXIT''}`, do the following:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`sideband_info`是`{''action'': ''EXIT''}`，请执行以下操作：'
- en: You fetch the order using `self.main_order[instrument]` (recall that `self.main_order`
    is a dictionary that holds instruments and corresponding order instances as key-value
    pairs.)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用`self.main_order[instrument]`获取订单（请回想一下，`self.main_order`是一个包含工具和相应订单实例的字典，作为键值对。）
- en: You exit the position for this order by calling its `exit_position()` method.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用其`exit_position()`方法退出此订单的持仓。
- en: You reset the value corresponding to the key `instrument` in `self.main_order`
    as `None`. This indicates that there is no longer a position open corresponding
    to `instrument`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将`self.main_order`中与`instrument`对应的键的值重置为`None`。这表示与`instrument`对应的持仓已不再存在。
- en: You return `True`, signaling to the AlgoBulls core engine that a position has
    been exited for `instrument` in this call.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您返回`True`，向AlgoBulls核心引擎发出信号，表明在此调用中已经退出了`instrument`的持仓。
- en: 'If `sideband_info` is not `{''action'': ''EXIT''}`, you return `False`, signaling
    to the AlgoBulls core engine that no position was not exited for `instrument`
    in this call.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`sideband_info`不是`{''action'': ''EXIT''}`，则返回`False`，向AlgoBulls核心引擎发出信号，表明在此调用中没有退出`instrument`的持仓。'
- en: The `self.broker` attribute is replaced by the appropriate broker instance at
    runtime by the AlgoBulls core engine. So, the same code can work across all the
    brokers supported by the AlgoBulls platform.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.broker`属性在运行时由AlgoBulls核心引擎替换为适当的经纪人实例。因此，相同的代码可以在AlgoBulls平台支持的所有经纪人中运行。'
- en: You have now completed the coding for the `StrategyEMARegularOrder` class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经完成了`StrategyEMARegularOrder`类的编码。
- en: EMA-Regular-Order strategy – uploading the strategy on the AlgoBulls trading
    platform
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMA-Regular-Order策略-在AlgoBulls交易平台上上传策略
- en: In this recipe, you will upload the strategy class, `StrategyEMARegularOrder`,
    which you created in the preceding recipes, on the AlgoBulls trading platform.
    Once it is uploaded, you can perform backtesting, paper trading, and real trading
    on the same code base.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将在AlgoBulls交易平台上上传在前面的配方中创建的`StrategyEMARegularOrder`策略类。一旦上传，您就可以在同一代码库上执行回测、模拟交易和实际交易。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have set up your account on the AlgoBulls platform ([https://algobulls.com](https://algobulls.com))
    to get your API token. Setting up an account is free. Using its services might
    incur charges depending on your usage. You can start with free packages on the
    site. Refer to *Appendix II* for more details.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已在AlgoBulls平台（[https://algobulls.com](https://algobulls.com)）上设置了您的账户以获取API令牌。设置账户是免费的。使用其服务可能会产生费用，具体取决于您的使用情况。您可以从网站上免费开始。有关更多详细信息，请参阅*附录II*。
- en: How to do it…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We execute the following steps for this recipe:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个配方执行以下步骤：
- en: 'Import the necessary modules:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的模块：
- en: '[PRE13]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a new AlgoBulls connection object:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的AlgoBulls连接对象：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Fetch the authorization URL:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取授权URL：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We get the following output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Log in to the preceding link with your AlgoBulls credentials, fetch your token,
    and set it here (refer to *Appendix II* for more details):'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的AlgoBulls凭据登录到上述链接，获取您的令牌，并在此处设置它（有关更多详细信息，请参阅*附录II*）：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before uploading your strategy, you can inspect your strategy code to ensure
    you are uploading the right strategy:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上传策略之前，您可以检查您的策略代码，以确保您上传了正确的策略：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We get the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The complete output is not shown here. Please visit the following link to read
    the complete output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有显示完整的输出。请访问以下链接以阅读完整的输出：
- en: '[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py)。'
- en: 'Upload `StrategyEMARegularOrder` onto the AlgoBulls platform. This creates
    a new strategy for your AlgoBulls account:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`StrategyEMARegularOrder`上传到AlgoBulls平台。这为您的AlgoBulls账户创建了一个新策略：
- en: '[PRE20]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We get the following output (your output may differ):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出（您的输出可能不同）：
- en: '[PRE21]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We import the necessary modules in *step 1*. In *step 2*, an instance of the
    `AlgoBullsConnection` class is created, named `algobulls_connection`. In *step
    3*, you get the authorization URL using the `get_authorization_url()` method of
    the `algobulls_connection` object. You should visit this URL from your web browser
    to sign in to the AlgoBulls platform and fetch your developer access token. (You
    can find more details with screenshots in *Appendix II* on fetching the developer
    access token from the AlgoBulls platform.) You copy the access token and set it
    in *step 4* using the `set_access_token()` method of `algobulls_connection`. If
    the token is accepted, a successful connection is set up with the AlgoBulls platform.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在*步骤1*中导入必要的模块。在*步骤2*中，创建了`AlgoBullsConnection`类的一个实例，命名为`algobulls_connection`。在*步骤3*中，使用`algobulls_connection`对象的`get_authorization_url()`方法获取授权URL。您应该从您的网络浏览器访问此URL，以登录到AlgoBulls平台并获取您的开发者访问令牌。（您可以在*附录II*中找到更多详细信息和截图，关于如何从AlgoBulls平台获取开发者访问令牌。）您复制访问令牌，并在*步骤4*中使用`algobulls_connection`的`set_access_token()`方法设置它。如果令牌被接受，就会与AlgoBulls平台建立成功的连接。 '
- en: The `StrategyEMARegularOrder` strategy class that we coded in *steps 1* to *5* is
    also available in the `pyalgostrategypool` package. We import this class in *step
    1*. Alternatively, you can also save your strategy class in a separate Python
    module and import it in *step 1* instead of importing it from `pyalgostrategypool`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*步骤1*到*5*中编写的`StrategyEMARegularOrder`策略类也可以在`pyalgostrategypool`包中找到。我们在*步骤1*中导入这个类。或者，您也可以将您的策略类保存在一个单独的Python模块中，并在*步骤1*中导入它，而不是从`pyalgostrategypool`中导入它。
- en: You upload the `StrategyEMARegularOrder` strategy class using the `upload_strategy()`
    method of `algobulls_connection` by passing it as a parameter. If the upload is
    successful, you will get a success message with `strategy_code`, which is a unique
    string. `strategy_code` can be used later to do everything related to the strategy—for
    example, editing the strategy, performing backtesting ([Chapter 9](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml),
    *Algorithmic Trading – Backtesting*), performing paper trading ([Chapter 10](0f869a6e-bb6b-4f5f-828e-33ca477c509d.xhtml),* Algorithmic
    Trading – **Paper Trading*), and performing real trading ([Chapter 11](725b5f38-fffb-46ae-8b5b-8a4667419e3a.xhtml),* Algorithmic
    Trading – **Real Trading*).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`algobulls_connection`的`upload_strategy()`方法上传`StrategyEMARegularOrder`策略类，将其作为参数传递。如果上传成功，您将收到一个带有`strategy_code`的成功消息，这是一个唯一的字符串。`strategy_code`可以稍后用于执行与策略相关的所有操作，例如编辑策略，执行回测（[第9章](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml)，*Algorithmic
    Trading – Backtesting*），执行模拟交易（[第10章](0f869a6e-bb6b-4f5f-828e-33ca477c509d.xhtml)，*Algorithmic
    Trading – Paper Trading*），以及执行实际交易（[第11章](725b5f38-fffb-46ae-8b5b-8a4667419e3a.xhtml)，*Algorithmic
    Trading – Real Trading*）。 '
- en: There's more…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If there are changes done to a strategy after uploading, you can update the
    strategy on the AlgoBulls platform using the `upload_strategy()` method of `algobulls_connection`
    with the updated class and `overwrite=True` as arguments. If the changes are uploaded
    successfully, you will get a success message.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在上传后对策略进行了更改，可以使用`algobulls_connection`的`upload_strategy()`方法将策略更新到AlgoBulls平台，使用更新后的类和`overwrite=True`作为参数。如果更改成功上传，您将收到成功消息。
- en: 'Modify an already-uploaded strategy:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 修改已上传的策略：
- en: '[PRE22]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We get the following output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Multiple strategies with the same name (returned by the `name()` method) are
    not allowed by the AlgoBulls platform. The `overwrite=True` parameter updates
    an existing strategy with the same name if present. If `overwrite=True` is not
    passed to the `create_strategy()` method, the default value is `False`, which
    means it tries to create a new strategy on the AlgoBulls platform.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: AlgoBulls平台不允许具有相同名称（由`name()`方法返回）的多个策略。如果存在`overwrite=True`参数，则更新具有相同名称的现有策略。如果未将`overwrite=True`传递给`create_strategy()`方法，则默认值为`False`，这意味着它会尝试在AlgoBulls平台上创建一个新策略。
- en: MACD-Bracket-Order strategy – coding the __init__, initialize, name, and versions_supported
    methods
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略 - 编写__init__、initialize、name和versions_supported方法
- en: 'This recipe demonstrates the initial coding of the `StrategyMACDBracketOrder`
    class. The complete class will be coded by the end of the eleventh recipe of this
    chapter. In this recipe, you will code the following methods:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱演示了`StrategyMACDBracketOrder`类的初始编码。完整的类将在本章的第十一个食谱结束时编码。在这个食谱中，您将编写以下方法：
- en: '`__init__()`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`'
- en: '`initialize()`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()`'
- en: '`name()`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name()`'
- en: '`versions_supported()`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`versions_supported()`'
- en: To learn more about the MACD technical indicator, please refer to the *Trend
    indicator – moving average convergence divergence* recipe of [Chapter 5](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml),
    *Computing and Plotting Technical Indicators*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关MACD技术指标的更多信息，请参考[第5章](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml)的*Trend
    indicator – moving average convergence divergence*食谱，*计算和绘制技术指标*。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `__init__()` and `initialize()` methods
    during strategy execution.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`__init__()`和`initialize()`方法。
- en: Getting ready
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have the `StrategyBase` and `pyalgotrading` constants in your
    Python namespace. Refer to the *Technical requirements* section of this chapter
    to set it up.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在Python命名空间中有`StrategyBase`和`pyalgotrading`常量。请参考本章的*技术要求*部分进行设置。
- en: How to do it…
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a new class named `StrategyMACDBracketOrder`. Subclass it from `StrategyBase`.
    Define the required four methods:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`StrategyMACDBracketOrder`的新类。从`StrategyBase`继承它。定义所需的四种方法：
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we will create the `StrategyEMARegularOrder` class, subclassed
    from `StrategyBase`. We will define four methods for this class, described as
    follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建`StrategyEMARegularOrder`类，它是从`StrategyBase`继承而来的子类。我们将为这个类定义四种方法，如下所述：
- en: 'The `__init__()` method: This is the first thing you do when you create a new
    strategy. First, you create this method and call the parent class `__init__()`
    method using `super()`. This helps the AlgoBulls core engine create the necessary
    data structures needed for the further development of the strategy. Next, you
    create six attributes from `self.strategy_parameters`:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`方法：这是创建新策略时的第一步。首先，创建这个方法，并使用`super()`调用父类的`__init__()`方法。这有助于AlgoBulls核心引擎创建进一步开发策略所需的必要数据结构。接下来，从`self.strategy_parameters`创建六个属性：'
- en: '`self.fastMA_period`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.fastMA_period`'
- en: '`self.slowMA_period`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.slowMA_period`'
- en: '`self.signal_period`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.signal_period`'
- en: '`self.stoploss`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.stoploss`'
- en: '`self.target`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.target`'
- en: '`self.trailing_stoploss`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.trailing_stoploss`'
- en: '`self.strategy_parameters` is a dictionary object available for every strategy
    subclassed from `StrategyBase`. (The seventh recipe of [Chapter 9](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml),* Algorithmic
    Trading – **Backtesting*, discusses how these values are passed at runtime to
    `self.strategy_parameters`.) These parameters will be used in the next recipe
    of this chapter as parameters to the MACD technical indicator. Lastly, you create
    a new attribute, `self.main_order`, an empty dictionary. We will use this for
    saving the handles to all the open orders placed during the execution of this
    strategy.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.strategy_parameters`是一个字典对象，对于从`StrategyBase`继承的每个策略都可用。（[第9章](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml)的第七个食谱讨论了这些值如何在运行时传递给`self.strategy_parameters`。）这些参数将在本章的下一个食谱中作为MACD技术指标的参数使用。最后，创建一个新属性`self.main_order`，一个空字典。我们将用它来保存在执行此策略期间放置的所有未完成订单的句柄。'
- en: 'The `initialize()` method: This method is called at the beginning of every
    market day to initialize any internal variables to their default state. For real
    trading and paper trading, this method is called once. For multi-day backtesting,
    this method is called multiple times, once at the beginning of every new trading
    day. In this method, you initialize `self.main_order` to an empty dictionary.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()`方法：这个方法在每个交易日的开始被调用，用于将任何内部变量初始化为它们的默认状态。对于实际交易和模拟交易，这个方法只被调用一次。对于多天的回测，这个方法会被多次调用，每个新的交易日开始时调用一次。在这个方法中，你将`self.main_order`初始化为空字典。'
- en: 'The `name()` method: This is a static method that returns the name of this
    strategy. This is used while utilizing backtesting, paper trading, and real trading
    services on this strategy. In this method, you simply return a string, `MACD Bracket
    Order`. You can return any string of your choice in this method.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name()`方法：这是一个静态方法，返回该策略的名称。在利用该策略进行回测、模拟交易和实际交易服务时会用到。在这个方法中，你只需返回一个字符串，`MACD
    Bracket Order`。你可以在这个方法中返回任何你选择的字符串。'
- en: 'The `versions_supported()` method: This static method is used for returning
    the AlgoBulls core engine version for which this strategy has been created. Often,
    as new upgrades come to the AlgoBulls core engine, some backward-incompatible
    changes may get introduced. This method helps to ensure this strategy is run on
    the correct version of the AlgoBulls core engine at all times. In this method,
    you return the highest available version from the constants module, which at the
    time of writing this chapter is VERSION_3_2_0.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`versions_supported()`方法：这个静态方法用于返回为该策略创建的AlgoBulls核心引擎版本。通常，随着AlgoBulls核心引擎的新升级，可能会引入一些不兼容的变化。这个方法有助于确保该策略始终在正确的AlgoBulls核心引擎版本上运行。在这个方法中，你返回常量模块中最高可用的版本，即在撰写本章时为VERSION_3_2_0。'
- en: These four methods are mandatory; they are enforced by the `StrategyBase` base
    class and cannot be skipped.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种方法是强制性的；它们由`StrategyBase`基类强制执行，不能被跳过。
- en: MACD-Bracket-Order strategy – coding the strategy_select_instruments_for_entry
    method
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略 - 编写strategy_select_instruments_for_entry方法
- en: In this recipe, you will continue coding the `StrategyMACDBracketOrder` class.
    Here, you will code the `strategy_select_instruments_for_entry()` method, a mandatory
    method enforced by the `StrategyBase` base class. This method is called by the
    AlgoBulls core engine on every new candle for backtesting, paper trading, and
    real trading services.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将继续编写`StrategyMACDBracketOrder`类。在这里，您将编写`strategy_select_instruments_for_entry()`方法，这是`StrategyBase`基类强制执行的强制性方法。该方法由AlgoBulls核心引擎在每个新蜡烛时进行回测、模拟交易和实际交易服务时调用。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_select_instruments_for_entry()`
    method during strategy execution.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_select_instruments_for_entry()`方法。
- en: Getting ready
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have followed the previous recipe to create the `StrategyMACDBracketOrder`
    class before starting this recipe.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本教程之前，请确保您已经按照之前的步骤创建了`StrategyMACDBracketOrder`类。
- en: How to do it…
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'Continue coding the `StrategyMACDBracketOrder` class. Define two new methods—a method
    for getting the crossover value between the MACD line and MACD history signals
    and a method for selecting instruments from `instruments_bucket` for entering
    a new position based on the computed crossover value:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyMACDBracketOrder`类。定义两个新方法 - 一个用于获取MACD线和MACD历史信号之间的交叉值，另一个用于根据计算的交叉值从`instruments_bucket`中选择进入新仓位的金融工具的方法：
- en: '[PRE25]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we continue coding the `StrategyMACDBracketOrder` class. We
    define two new methods for this class, described as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们继续编写`StrategyMACDBracketOrder`类。我们为这个类定义了两个新方法，如下所述：
- en: 'The `get_crossover_value()` method: This is a helper method. It takes `instrument`
    as an argument (along with `self`). This is the financial instrument for which
    the crossover value has to be computed. You fetch the latest historical data using
    the `self.get_historical_data()` method and assign it to a new attribute, `hist_data`.
    We pass `instrument` as the argument to this method. The `hist_data` attribute
    is a `pandas.DataFrame` object with `timestamp`, `open`, `high`, `low`, `close`,
    and `volume` columns.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_crossover_value()`方法：这是一个辅助方法。它以`instrument`作为参数（以及`self`）。这是需要计算交叉值的金融工具。你使用`self.get_historical_data()`方法获取最新的历史数据，并将其赋值给一个新的属性`hist_data`。我们将`instrument`作为参数传递给这个方法。`hist_data`属性是一个`pandas.DataFrame`对象，具有`timestamp`、`open`、`high`、`low`、`close`和`volume`列。'
- en: 'The default duration of the fetched historical data is the last 15 days. You
    compute MACD on the close of `hist_data` using the `talib.MACD` function. It takes
    the following additional arguments:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 获取的历史数据的默认持续时间是最近的15天。你使用`talib.MACD`函数在`hist_data`的收盘价上计算MACD。它接受以下额外的参数：
- en: '`fastperiod`: We pass `self.fastMA_period` here.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fastperiod`：我们在这里传递`self.fastMA_period`。'
- en: '`slowperiod`: We pass `self.slowMA_period` here.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slowperiod`：我们在这里传递`self.slowMA_period`。'
- en: '`signalperiod:` We pass `self.signal_period` here.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signalperiod:` 我们在这里传递`self.signal_period`。'
- en: 'This computed MACD data is a tuple of the `pandas.Series` object, which you
    assign to `macdline`, `macdsignal`, and `_` (the last object in the tuple is assigned
    to `_` because it is not required). (Refer to the third recipe in [Chapter 5](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml),
    *Computing and Plotting Technical Indicators*, for more details on computation
    of MACD.) You compute the crossover value between `macdline` and `macdsignal`
    using `self.utils.crossover(macdline, macdsignal)` and assign it to a new attribute,
    `crossover_value`. The `crossover()` function call works as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 计算得到的MACD数据是一个`pandas.Series`对象的元组，您将其分配给`macdline`、`macdsignal`和`_`（元组中的最后一个对象分配给`_`，因为它不是必需的）。
    （有关计算MACD的更多细节，请参考[第5章](16529fe4-d3ea-4017-a6f9-bad85a41d8a0.xhtml)中的第三个示例，*计算和绘制技术指标*。）您使用`self.utils.crossover(macdline,
    macdsignal)`计算`macdline`和`macdsignal`之间的交叉值，并将其分配给一个新属性`crossover_value`。`crossover()`函数调用如下：
- en: It takes two iterables as input. We pass `macdline` and `macdsignal` here.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受两个可迭代对象作为输入。我们在这里传递`macdline`和`macdsignal`。
- en: If `macdline` crosses `macdsignal` upward, the crossover function returns `1`.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`macdline`向上穿越`macdsignal`，则交叉函数返回`1`。
- en: If `macdline` crosses the `macdsignal` downward, the crossover function returns
    `-1`.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`macdline`向下穿越`macdsignal`，则交叉函数返回`-1`。
- en: If there is no crossover between `macdline` and `macdsignal`, then the crossover
    function returns `0`.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`macdline`和`macdsignal`之间没有交叉，则交叉函数返回`0`。
- en: Finally, you return `crossover_value`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，返回`crossover_value`。
- en: '`strategy_select_instruments_for_entry()` method: This method takes two arguments,
    other than `self`:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strategy_select_instruments_for_entry()`方法：此方法除了`self`之外，还接受两个参数：'
- en: '`candle`:  An object of the `CandleTime` type that contains the timestamp of
    the current candle.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle`：`CandleTime`类型的对象，包含当前蜡烛的时间戳。'
- en: '`instruments_bucket`: An object of the `SetInstruments` type that contains
    all the financial instruments available for creating a new position. We pass this
    data at the time of strategy execution (the second recipe of [Chapter 8](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml),
    *Backtesting Strategies*).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instruments_bucket`：`SetInstruments`类型的对象，包含用于创建新头寸的所有金融工具。我们在策略执行时传递这些数据（[第8章](b415aed0-c473-48ba-8e52-5914c7f0de87.xhtml)中的第二个示例，*回测策略*）。'
- en: 'You create two empty lists, `selected_instruments_bucket` and `sideband_info_bucket`.
    You run a `for` loop over `instruments_bucket`. For each instrument, you call
    `self.get_crossover_value()` and save its value to a new attribute, `crossover_value`.
    Based on the value of `crossover_value`, you make a decision, as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建两个空列表`selected_instruments_bucket`和`sideband_info_bucket`。您对`instruments_bucket`运行一个`for`循环。对于每个工具，您调用`self.get_crossover_value()`并将其值保存到一个新属性`crossover_value`。根据`crossover_value`的值，您做出决定，如下所示：
- en: 'If `crossover_value` is `1`, it means the strategy is giving a `BUY` signal.
    You do the following:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`为`1`，这意味着策略正在发出`BUY`信号。您需要执行以下操作：
- en: Append `instrument` to `selected_instruments_bucket`.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`instrument`附加到`selected_instruments_bucket`。
- en: 'Append an `{''action'': ''BUY''}` dictionary to the `sideband_info_bucket`
    attribute.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`{''action'': ''BUY''}`字典附加到`sideband_info_bucket`属性。'
- en: 'If `crossover_value` is `-1`, it means the strategy is giving a `SELL` signal.
    You do the following:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`为`-1`，这意味着策略正在发出`SELL`信号。您需要执行以下操作：
- en: Append `instrument` to `selected_instruments_bucket`.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`instrument`附加到`selected_instruments_bucket`。
- en: 'Append an `{''action'': ''SELL''}` dictionary to the `sideband_info_bucket`
    attribute.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`{''action'': ''SELL''}`字典附加到`sideband_info_bucket`属性。'
- en: If `crossover_value` is neither `1` nor `-1`, it means the strategy is not giving
    a signal. You do nothing here.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`既不是`1`也不是`-1`，这意味着策略没有发出信号。在这里您不需要做任何操作。
- en: Finally, you return both the attributes: `selected_instruments_bucket` and `sideband_info_bucket`.
    These attributes may have been populated or may remain as empty lists.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，您返回这两个属性：`selected_instruments_bucket`和`sideband_info_bucket`。这些属性可能已经被填充，也可能保持为空列表。
- en: Recall that the `strategy_select_instruments_for_entry()` method is called for
    every candle, so the preceding steps are repeated for every new candle. In the
    appropriate candle, you will get a `BUY` or `SELL` signal, and in the others,
    you won't get any signal. Based on the signal, you can place the appropriate order,
    which is discussed in the next recipe.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`strategy_select_instruments_for_entry()`方法会为每个蜡烛调用，因此前面的步骤会针对每个新蜡烛重复进行。在适当的蜡烛中，您将获得一个`BUY`或`SELL`信号，在其他蜡烛中，您将不会收到任何信号。根据信号，您可以下达适当的订单，这将在下一个示例中讨论。
- en: The `strategy_select_instruments_for_entry()` method is enforced by the `StrategyBase`
    base class and has to be defined for every strategy. The `get_crossover_value()`
    method is a helper method, meaning it is not enforced by the `StrategyBase` base
    class. You may choose not to define this or to define multiple of these helper
    functions.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`strategy_select_instruments_for_entry()`方法是由`StrategyBase`基类强制执行的，对于每个策略都必须定义。`get_crossover_value()`方法是一个辅助方法，这意味着它不是`StrategyBase`基类强制执行的。您可以选择不定义此方法，或者定义多个这样的辅助函数。'
- en: MACD-Bracket-Order strategy – coding the strategy_enter_position method
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略 - 编写strategy_enter_position方法
- en: In this recipe, you will continue with the coding of the `StrategyMACDBracketOrder`
    class. Here, you will code the `strategy_enter_position()` method, a mandatory
    method enforced by the `StrategyBase` base class. This method is called by the
    AlgoBulls core engine every time the `strategy_select_instruments_for_entry()`
    method returns non-empty data. This method may not be called for every new candle
    for backtesting, paper trading, and real trading services.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将继续编写`StrategyMACDBracketOrder`类的代码。在这里，您将编写`strategy_enter_position()`方法，这是`StrategyBase`基类强制执行的一个必需方法。每当`strategy_select_instruments_for_entry()`方法返回非空数据时，AlgoBulls核心引擎都会调用此方法。对于回测、模拟交易和实际交易服务，此方法可能不会在每个新蜡烛时被调用。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_enter_position()` method during
    strategy execution.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_enter_position()`方法。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: Make sure you have followed the previous recipe before starting this recipe.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本教程之前，请确保您已经按照上一个教程进行了操作。
- en: How to do it…
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: 'Continue coding the `StrategyMACDBracketOrder` class. Define a method to punch
    new orders for a given instrument and enter a new position:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyMACDBracketOrder`类。定义一个方法来为给定的工具打新订单并进入新的持仓：
- en: '[PRE26]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we continue coding the `StrategyMACDBracketOrder` class. We
    define a new method for this class, `strategy_enter_position()`, described as
    follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们继续编写`StrategyMACDBracketOrder`类。我们为这个类定义了一个新的方法，`strategy_enter_position()`，描述如下：
- en: 'This method takes three arguments, other than `self`:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法除了`self`之外，还需要三个参数：
- en: '`candle`:  An object of the `CandleTime` type that contains the timestamp of
    the current candle.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle`：一个`CandleTime`类型的对象，包含当前蜡烛的时间戳。'
- en: '`instrument`: An object of the `Instrument` type that represents a financial
    instrument.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument`：代表金融工具的`Instrument`类型的对象。'
- en: '`sideband_info`: A dictionary object that holds information on trades to be
    placed for the `instrument` attribute. This object looks like `{''action'': [action_value]}`,
    where `[action_value]` can be either `''BUY''` or `''SELL''`.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sideband_info`：一个字典对象，包含有关要为`instrument`属性下订单的信息。这个对象看起来像`{''action'': [action_value]}`，其中`[action_value]`可以是`''BUY''`或`''SELL''`。'
- en: You calculate the quantity for order to be placed by multiplying `self.number_of_lots`
    with `instrument.lot_size` and assign it to a new attribute qty. The `self.number_of_lots`
    attribute holds information on the number of lots to trade, which you can pass
    while executing this strategy. The `instrument.lot_size` attribute holds `lot_size`
    for `instrument`, which is a positive integer. For example, if number of lots
    is passed as 2 and lot size for instrument is 10, then the quantity for the order
    would be 2 * 10 = 20.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将`self.number_of_lots`与`instrument.lot_size`相乘来计算要下订单的数量，并将其分配给一个新的属性qty。`self.number_of_lots`属性保存了要交易的手数信息，您可以在执行此策略时传递。`instrument.lot_size`属性保存了`instrument`的`lot_size`，它是一个正整数。例如，如果手数为2，而instrument的手数为10，那么订单的数量将是2
    * 10 = 20。
- en: 'If `sideband_info` is `{''action'': ''BUY''}`, you place a `Bracket` order
    of the `BUY` transaction type by creating an instance of the `self.broker.BuyOrderBracket` class
    (refer to the first recipe of [Chapter 7](d5760c5d-fa09-4008-ab45-5d7d69c4bde9.xhtml),
    *Placing Bracket and Cover Orders on the Exchange*) and assigning its value to
    `self.main_order[instrument]`.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`sideband_info`是`{''action'': ''BUY''}`，则通过创建`self.broker.BuyOrderBracket`类的实例（参考[第7章](d5760c5d-fa09-4008-ab45-5d7d69c4bde9.xhtml)的第一个教程，*在交易所上放置Bracket和Cover订单*）并将其值分配给`self.main_order[instrument]`来放置`BUY`交易类型的`Bracket`订单。'
- en: 'Similarly, if `sideband_info` is `{''action'': ''SELL''}`, you place a `Bracket` order
    of the `BUY` transaction type by creating an instance of the `self.broker.SellOrderBracket`
    class (refer to the first recipe of [Chapter 7](d5760c5d-fa09-4008-ab45-5d7d69c4bde9.xhtml), *Placing
    Bracket and Cover Orders on the Exchange*) and assigning its value to `self.main_order[instrument]`.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '同样，如果`sideband_info`是`{''action'': ''SELL''}`，则通过创建`self.broker.SellOrderBracket`类的实例（参考[第7章](d5760c5d-fa09-4008-ab45-5d7d69c4bde9.xhtml)的第一个教程，*在交易所上放置Bracket和Cover订单*）并将其值分配给`self.main_order[instrument]`来放置`BUY`交易类型的`Bracket`订单。'
- en: In both cases, the `self.main_order` dictionary object holds the `instrument`
    and `order` instances as a key-value pair. This will be useful later (in the *MACD-Bracket-Order
    strategy – coding the strategy_exit_position method* recipe) for exiting positions
    created by this method.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`self.main_order`字典对象将`instrument`和`order`实例作为键值对保存。这将在稍后（在*MACD-Bracket-Order
    strategy – coding the strategy_exit_position method*教程中）对由该方法创建的持仓进行退出时非常有用。
- en: The `self.broker` attribute is replaced by the appropriate broker instance at
    runtime by the AlgoBulls core engine. So, the same code can work across all the
    brokers supported by the AlgoBulls platform.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.broker`属性在AlgoBulls核心引擎运行时被适当的经纪人实例替换。因此，相同的代码可以在AlgoBulls平台支持的所有经纪人上运行。'
- en: MACD-Bracket-Order strategy – coding the strategy_select_instruments_for_exit
    method
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order strategy – 编写strategy_select_instruments_for_exit方法
- en: In this recipe, you will continue with the coding of the `StrategyMACDBracketOrder`
    class. Here, you will code the `strategy_select_instruments_for_exit()` method,
    a mandatory method enforced by the `StrategyBase` base class. This method is called
    by the AlgoBulls core engine for every new candle for backtesting, paper trading,
    and real trading services.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将继续编写`StrategyMACDBracketOrder`类。在这里，您将编写`strategy_select_instruments_for_exit()`方法，这是`StrategyBase`基类强制执行的一个必需方法。AlgoBulls核心引擎会在每个新蜡烛的回测、模拟交易和实际交易服务中调用此方法。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_select_instruments_for_exit()`
    method during strategy execution.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_select_instruments_for_exit()`方法。
- en: Getting ready
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have followed the previous recipe before starting this recipe.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本教程之前，请确保您已经按照上一个教程进行了操作。
- en: How to do it…
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: 'Continue coding the `StrategyMACDBracketOrder` class. Define a new method for
    selecting instruments from `instruments_bucket` for exiting an existing position
    based on the computation of the crossover value:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyMACDBracketOrder`类。定义一个从`instruments_bucket`中选择用于基于交叉值计算退出现有持仓的工具的新方法：
- en: '[PRE27]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we continue coding the `StrategyMACDBracketOrder` class. We
    define a new method for this class, `strategy_select_instruments_for_exit()`,
    described as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们继续编写`StrategyMACDBracketOrder`类。我们为这个类定义了一个新的方法，`strategy_select_instruments_for_exit()`，描述如下：
- en: 'This method takes two arguments, other than `self`:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法除了`self`之外，还需要两个参数：
- en: '`candle`:  An object of `CandleTime` type that contains the timestamp of the
    current candle.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`candle`：一个`CandleTime`类型的对象，包含当前蜡烛的时间戳。'
- en: '`instruments_bucket`: An object of `SetInstruments` type. This object holds
    financial instruments that have been entered into a position earlier by the `strategy_enter_position()`
    method.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instruments_bucket`：`SetInstruments`类型的对象。此对象保存了通过`strategy_enter_position()`方法之前输入头寸的金融工具。'
- en: You create two empty lists, `selected_instruments_bucket` and `sideband_info_bucket`.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个空列表，`selected_instruments_bucket`和`sideband_info_bucket`。
- en: You run a `for` loop over `instruments_bucket`. For each instrument, you check
    whether there is a position entered for the given instrument using the `'if self.main_order.get(instrument)
    is not None:'` line. You proceed only if a position exists already.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您在`instruments_bucket`上运行一个`for`循环。对于每个工具，您检查是否已经输入了给定工具的头寸，使用`'if self.main_order.get(instrument)
    is not None:'`行。只有在已经存在头寸的情况下才继续。
- en: 'You call `self.get_crossover_value()` and save its value to a new attribute,
    `crossover_value`. Based on the value of `crossover_value`, you make a decision,
    as follows:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`self.get_crossover_value()`并将其值保存到一个新属性`crossover_value`中。根据`crossover_value`的值，做出决定，如下所示：
- en: 'If `crossover_value` is either `1` or `-1`, it means there has been a crossover.
    You do the following:'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`是`1`或`-1`，这意味着已经发生了交叉。您需要执行以下操作：
- en: Append the `instrument` attribute to `selected_instruments_bucket`.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`instrument`属性附加到`selected_instruments_bucket`。
- en: 'Append a `{''action'': ''EXIT''}` dictionary to the `sideband_info_bucket`
    attribute.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`{''action'': ''EXIT''}`字典附加到`sideband_info_bucket`属性。'
- en: If `crossover_value` is neither `1` nor `-1`, it means the strategy is not giving
    a signal. You do nothing here.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`crossover_value`既不是`1`也不是`-1`，这意味着策略没有发出信号。在这里不做任何操作。
- en: Finally, you return both the attributes, `selected_instruments_bucket` and `sideband_info_bucket`.
    These attributes may have been populated or may remain as empty lists.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，您返回`selected_instruments_bucket`和`sideband_info_bucket`两个属性。这些属性可能已经被填充，也可能保持为空列表。
- en: Recall that the `strategy_select_instruments_for_exit()` method is called for
    every candle, so the preceding steps are repeated for every new candle. In the
    appropriate candle, if there is a position, you may get an `EXIT` signal, and
    in the others, you won't get any signal. Based on the signal, you can exit the
    position by placing an appropriate order, which is discussed in the next recipe.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`strategy_select_instruments_for_exit()`方法会为每个蜡烛调用，因此前面的步骤会针对每个新蜡烛重复进行。在适当的蜡烛中，如果有头寸，您可能会收到`EXIT`信号，而在其他蜡烛中，您将不会收到任何信号。根据信号，您可以通过下一篇文章中讨论的适当订单退出头寸。
- en: MACD-Bracket-Order strategy – coding the strategy_exit_position method
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略 - 编写`strategy_exit_position`方法
- en: In this recipe, you will continue with the coding of the `StrategyMACDBracketOrder`
    class. Here, you will code the `strategy_exit_position()` method, the last mandatory
    method enforced by the `StrategyBase` base class. This method is called by the
    AlgoBulls core engine every time the `strategy_select_instruments_for_exit` method
    returns non-empty data. By the end of this recipe, you will have completed coding
    the `StrategyMACDBracketOrder` class.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将继续编写`StrategyMACDBracketOrder`类。在这里，您将编写`strategy_exit_position()`方法，这是`StrategyBase`基类强制执行的最后一个强制性方法。此方法由AlgoBulls核心引擎在`strategy_select_instruments_for_exit`方法返回非空数据时调用。在本配方结束时，您将完成编写`StrategyMACDBracketOrder`类。
- en: Please refer to the flowchart in the introduction of this chapter to understand
    how the AlgoBulls core engine calls the `strategy_select_instruments_for_exit()`
    method during strategy execution.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章介绍中的流程图，了解AlgoBulls核心引擎在策略执行期间如何调用`strategy_select_instruments_for_exit()`方法。
- en: Getting ready
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have followed the previous recipe before starting this recipe.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本配方之前，请确保您已经按照上一个配方进行了操作。
- en: How to do it…
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: 'Continue coding the `StrategyMACDBracketOrder` class. Define a method to the
    exit position for a given instrument based on `sideband_info`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`StrategyMACDBracketOrder`类。根据`sideband_info`定义一个退出给定工具头寸的方法：
- en: '[PRE28]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works…
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we continue coding the `StrategyMACDBracketOrder` class. We
    define a new method for this class, `strategy_exit_position()`, described as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们继续编写`StrategyMACDBracketOrder`类。我们为这个类定义一个新方法，`strategy_exit_position()`，描述如下：
- en: 'This method takes three arguments, other than `self`:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了`self`之外，此方法还需要三个参数：
- en: '`candle`:  An object of the `CandleTime` type that contains the timestamp of
    the current candle.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜡烛：`CandleTime`类型的对象，包含当前蜡烛的时间戳。
- en: '`instrument`: An object of the `Instrument` type that represents a financial
    instrument.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument`：代表金融工具的`Instrument`类型的对象。'
- en: '`sideband_info`: A dictionary object that holds information on trades to be
    placed for the `instrument` attribute. This object looks like `{''action'': `EXIT`}`.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sideband_info`：一个字典对象，包含有关要为`instrument`属性放置的交易的信息。此对象看起来像`{''action'': `EXIT`}`。'
- en: 'If `sideband_info` is `{''action'': ''EXIT''}`, do the following:'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`sideband_info`是`{''action'': ''EXIT''}`，执行以下操作：'
- en: You fetch the order using `self.main_order[instrument]`. (Recall that `self.main_order`
    is a dictionary that holds instruments and corresponding order instances as key-value
    pairs.)
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`self.main_order[instrument]`获取订单。（回想一下，`self.main_order`是一个字典，将工具和相应的订单实例作为键值对保存。）
- en: You exit the position for this order by calling its `exit_position()` method.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用其`exit_position()`方法退出该订单的头寸。
- en: 'Since it''s a `Bracket` order strategy, there is the possibility for the `target`
    or `stoploss` order to hit and the position to exit without our strategy knowing
    it. You can still use the `exit_position()` method to handle these scenarios.
    The `exit_position()` method works for both of the following exit scenarios:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个`Bracket`订单策略，存在`target`或`stoploss`订单可能触发并导致头寸退出而我们的策略不知情的可能性。您仍然可以使用`exit_position()`方法来处理这些情况。`exit_position()`方法适用于以下两种退出情况：
- en: The position is open and you want to exit it yourself.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头寸是开放的，您想自己退出。
- en: The position is already exited by the broker due to the completion of either
    the `stoploss` order or the `target` order and there is nothing to be done.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头寸已由经纪人退出，因为`止损`订单或`目标`订单已完成，没有需要做的事情。
- en: You reset the value corresponding to the key `instrument` in `self.main_order`
    as `None`. This indicates there is no longer a position open corresponding to
    `instrument`.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将与`self.main_order`中的`instrument`对应的值重置为`None`。这表示与`instrument`对应的头寸已不再开放。
- en: You return `True`, signaling to the AlgoBulls core engine that a position has
    been exited for `instrument` in this call.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您返回`True`，向AlgoBulls核心引擎发出信号，表示在此调用中已退出`instrument`的头寸。
- en: 'If `sideband_info` is not `{''action'': ''EXIT''}`, you return `False`, signaling
    to the AlgoBulls core engine that no position was exited for `instrument` in this
    call.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`sideband_info`不是`{''action'': ''EXIT''}`，则返回`False`，向AlgoBulls核心引擎发出信号，表示在此调用中没有退出`instrument`的头寸。'
- en: The `self.broker` attribute is replaced by the appropriate broker instance at
    runtime by the AlgoBulls core engine. So, the same code can work across all the
    brokers supported by the AlgoBulls platform.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.broker`属性在运行时由AlgoBulls核心引擎替换为适当的经纪人实例。因此，相同的代码可以在AlgoBulls平台支持的所有经纪人中运行。'
- en: You have now completed the coding for the `StrategyMACDBracketOrder` class.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经完成了`StrategyMACDBracketOrder`类的编码。
- en: MACD-Bracket-Order strategy — uploading the strategy on the AlgoBulls trading
    platform
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MACD-Bracket-Order策略 - 将策略上传到AlgoBulls交易平台
- en: In this recipe, you will upload the strategy class, `StrategyMACDBracketOrder`,
    which you created in the preceding five recipes, on the AlgoBulls trading platform.
    Once it is uploaded, you can perform backtesting, paper trading, and real trading
    on the same code base.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将在AlgoBulls交易平台上上传`StrategyMACDBracketOrder`类，这是您在前面五个配方中创建的。一旦上传，您可以在相同的代码库上执行回测、模拟交易和实际交易。
- en: Getting ready
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have set up your account on the AlgoBulls platform ([https://algobulls.com](https://algobulls.com))
    to get your API token. Setting up an account is free. Using its services might
    incur charges depending on your usage. You can start with the free packages on
    the site. Refer to *Appendix II* for more details.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已在AlgoBulls平台（[https://algobulls.com](https://algobulls.com)）上设置了您的账户以获取API令牌。设置账户是免费的。使用其服务可能会产生费用，具体取决于您的使用情况。您可以从网站上的免费套餐开始。有关更多详细信息，请参阅*附录II*。
- en: How to do it…
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We execute the following steps for this recipe:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行以下步骤来完成这个配方：
- en: 'Import the necessary modules:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的模块：
- en: '[PRE29]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a new AlgoBulls connection object:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的AlgoBulls连接对象：
- en: '[PRE30]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Fetch the authorization URL:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取授权URL：
- en: '[PRE31]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We get the following output:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE32]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Log in to the preceding link with your AlgoBulls credentials, fetch your token,
    and set it here (refer to *Appendix II* for more details):'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的AlgoBulls凭据登录到上述链接，获取您的令牌，并在此处设置（有关更多详细信息，请参阅*附录II*）：
- en: '[PRE33]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Before uploading your strategy, you can inspect your strategy code to ensure
    you are uploading the right strategy:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上传您的策略之前，您可以检查您的策略代码，以确保您上传了正确的策略。
- en: '[PRE34]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We get the following output:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE35]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The complete output is not shown here. Please visit the following link to read
    the complete output:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的输出在这里没有显示。请访问以下链接以阅读完整的输出：
- en: '[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py).'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py)。'
- en: 'Upload `StrategyMACDBracketOrder` onto the AlgoBulls platform. This creates
    a new strategy for your AlgoBulls account:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`StrategyMACDBracketOrder`上传到AlgoBulls平台。这将为您的AlgoBulls账户创建一个新策略：
- en: '[PRE36]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We get the following output (your output may differ):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出（您的输出可能不同）：
- en: '[PRE37]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works…
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We import the necessary modules in *step 1*. In *step 2*, an instance of the
    `AlgoBullsConnection` class is created, named `algobulls_connection`. In *step
    3*, you get the authorization URL using the `get_authorization_url()` method of
    the `algobulls_connection` object. You should visit this URL from your web browser
    to sign in to the AlgoBulls platform and fetch your developer access token. (You
    can find more details with screenshots in *Appendix II* on fetching the developer
    access token from the AlgoBulls platform.) You copy the access token and set it
    in *step 4* using the `set_access_token()` method of `algobulls_connection`. If
    the token is accepted, a successful connection is set up with the AlgoBulls platform.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*步骤1*中导入必要的模块。在*步骤2*中，创建了`AlgoBullsConnection`类的一个实例，名为`algobulls_connection`。在*步骤3*中，使用`algobulls_connection`对象的`get_authorization_url()`方法获取授权URL。您应该从您的网络浏览器访问此URL，以登录到AlgoBulls平台并获取您的开发者访问令牌。（您可以在*附录II*中找到更多详细信息和屏幕截图，了解如何从AlgoBulls平台获取开发者访问令牌。）您复制访问令牌，并在*步骤4*中使用`algobulls_connection`的`set_access_token()`方法设置它。如果令牌被接受，将与AlgoBulls平台建立成功的连接。
- en: The `StrategyMACDBracketOrder` strategy class, which we coded in *step 5*, is
    also available in the `pyalgostrategypool` package. We import this class in *step
    1*. Alternatively, you can also save your strategy class in a separate Python
    module and import it in *step 1* instead of importing it from `pyalgostrategypool`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*步骤5*中编写的`StrategyMACDBracketOrder`策略类也在`pyalgostrategypool`包中可用。我们在*步骤1*中导入了这个类。或者，您也可以将您的策略类保存在一个单独的Python模块中，并在*步骤1*中导入它，而不是从`pyalgostrategypool`中导入它。
- en: You upload the `StrategyMACDBracketOrder` strategy class using the `upload_strategy()`
    method of `algobulls_connection` by passing it as a parameter. If the upload is
    successful, you will get a success message with `strategy_code`, which is a unique
    string. `strategy_code` can be used in later chapters to do everything related
    to the strategy—for example, editing the strategy, performing backtesting, performing
    paper trading, and performing real trading.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`algobulls_connection`的`upload_strategy()`方法通过将其作为参数传递来上传`StrategyMACDBracketOrder`策略类。如果上传成功，您将收到带有`strategy_code`的成功消息，这是一个唯一的字符串。`strategy_code`可以在以后的章节中用于执行与策略相关的所有操作，例如编辑策略、执行回测、执行模拟交易和执行真实交易。
- en: There's more…
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: If there are changes made to a strategy after uploading, you can update the
    strategy on the AlgoBulls platform using the `upload_strategy()` method of `algobulls_connection`
    with the updated class and `overwrite=True` as arguments. If the changes are uploaded
    successfully, you will get a success message.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在上传后对策略进行了更改，您可以使用`algobulls_connection`的`upload_strategy()`方法和更新后的类以及`overwrite=True`作为参数在AlgoBulls平台上更新策略。如果更改成功上传，您将收到成功消息。
- en: 'You can modify an already-uploaded strategy as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式修改已上传的策略：
- en: '[PRE38]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We get the following output:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE39]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Multiple strategies with the same name (returned by the `name()` method) are
    not allowed by the AlgoBulls platform. The `overwrite=True` parameter updates
    an existing strategy with the same name if present. If `overwrite=True` is not
    passed to the `create_strategy()` method, the default value is `False`, which
    means it tries to create a new strategy on the AlgoBulls platform.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: AlgoBulls平台不允许具有相同名称（由`name()`方法返回）的多个策略。`overwrite=True`参数将更新具有相同名称的现有策略（如果存在）。如果未将`overwrite=True`传递给`create_strategy()`方法，则默认值为`False`，这意味着它会尝试在AlgoBulls平台上创建新策略。

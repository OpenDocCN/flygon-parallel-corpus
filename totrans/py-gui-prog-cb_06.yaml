- en: Chapter 6. Threads and Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create threads, queues, and TCP/IP sockets using Python
    3.
  prefs: []
  type: TYPE_NORMAL
- en: How to create multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stopping a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing queues among different modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dialog widgets to copy files to your network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TCP/IP to communicate via networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using URLOpen to read data from websites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will extend the functionality of our Python GUI using threads,
    queues, and network connections.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A tkinter GUI is single-threaded. Every function that involves sleep or wait
    time has to be called in a separate thread, otherwise the tkinter GUI freezes.
  prefs: []
  type: TYPE_NORMAL
- en: When we run our Python GUI in Windows Task Manager, we can see that a new `python.exe`
    process has been launched.
  prefs: []
  type: TYPE_NORMAL
- en: When we give our Python GUI a `.pyw` extension, then the process created will
    be `python.pyw`, as can be seen in Task Manager.
  prefs: []
  type: TYPE_NORMAL
- en: When a process is created, the process automatically creates a main thread to
    run our application. This is called a single-threaded application.
  prefs: []
  type: TYPE_NORMAL
- en: For our Python GUI, a single-threaded application will lead to our GUI becoming
    frozen as soon as we call a longer-running task such as clicking a button that
    has a sleep of a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep our GUI responsive we have to use multi-threading, and this
    is what we will study in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create multiple processes by creating multiple instances of our
    Python GUI, as can be seen in Task Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Processes are isolated by design from each other and do not share common data.
    In order to communicate between separate processes we would have to use **Inter-Process-Communication**
    (**IPC**), which is an advanced technique.
  prefs: []
  type: TYPE_NORMAL
- en: Threads, on the other hand, do share common data, code, and files, which makes
    communication between threads within the same process much easier than when using
    IPC.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A great explanation of threads can be found at: [https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to keep our Python GUI responsive and not
    to freeze.
  prefs: []
  type: TYPE_NORMAL
- en: How to create multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create multiple threads using Python. This is necessary in order to
    keep our GUI responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A thread is like weaving a fabric made out of yarn and is nothing to be afraid
    of.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple threads run within the same computer process memory space. There is
    no need for Inter-Process-Communication (aka IPC), which would complicate our
    code. In this recipe, we will avoid IPC by using threads.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First we will increase the size of our `ScrolledText` widget, making it larger.
    Let's increase `scrolW` to 40 and `scrolH` to 10.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When we now run the resulting GUI, the `Spinbox` widget is center-aligned in
    relation to the `Entry` widget above it, which does not look good. We'll change
    this by left-aligning the widget.
  prefs: []
  type: TYPE_NORMAL
- en: Add `sticky='W'` to the `grid` control to left-align the `Spinbox` widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The GUI could still look better, so next, we will increase the size of the `Entry`
    widget to get a more balanced GUI layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Increase the width to 24, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let us also slightly increase the width of the `Combobox` to 14.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Running the modified and improved code results in a larger GUI, which we will
    use for this and the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to create and use threads in Python, we have to import the `Thread`
    class from the threading module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's add a method to be created in a thread to our `OOP` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can now call our threaded method in the code, saving the instance in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a method that is threaded, but when we run the code, nothing gets
    printed to the console!
  prefs: []
  type: TYPE_NORMAL
- en: We have to start the `Thread` first before it can run and the next recipe will
    show us how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: However, setting a breakpoint after the GUI main event loop proves that we did
    indeed create a `Thread` object, as can been seen in the Eclipse IDE Debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we prepared our GUI to use threads by first increasing the GUI
    size, so we could better see the results printed to the `ScrolledText` widget.
  prefs: []
  type: TYPE_NORMAL
- en: We then imported the `Thread` class from the Python `threading` module.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we created a method that we call in a thread from within our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show us how to start a thread. It will also demonstrate why
    threads are necessary to keep our GUI responsive during long-running tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's first see what happens when we call a function or method of our GUI that
    has some sleep associated with it without using threads.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using a sleep here to simulate a real-world application that might have
    to wait for a web server or database to respond or a large file transfer or complex
    computation to complete its task.
  prefs: []
  type: TYPE_NORMAL
- en: The sleep is a very realistic place-holder and shows the principle involved.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a loop into our button callback method with some sleep time results in
    our GUI becoming unresponsive and, when we try to close the GUI, things get even
    worse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Getting ready](graphics/B04829_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we wait long enough, the method will eventually complete but during this
    time none of our GUI widgets respond to click events. We solve this problem by
    using threads.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous recipe, we created a method to be run in a thread, but so far,
    the thread has not run!
  prefs: []
  type: TYPE_NORMAL
- en: Unlike regular Python functions and methods, we have to `start` a method that
    is going to be run in its own thread!
  prefs: []
  type: TYPE_NORMAL
- en: This is what we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's move the creation of the thread into its own method and then call
    this method from the button callback method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Clicking the button now results in the `createThread` method being called which,
    in turn, calls the `methodInAThread` method.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a thread and target it at a method. Next, we start the thread
    that will run the targeted method in a new thread.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GUI itself runs in its own thread, which is the main thread of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can print out the instance of the thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking the button now creates the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we click the button several times, we can see that each thread gets assigned
    a unique name and ID.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's now move our code with the `sleep` in a loop into the `methodInAThread`
    method to verify that threads really do solve our problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When clicking the button, while the numbers are being printed into the `ScrolledText`
    widget with a five second delay, we can click around anywhere in our GUI, switch
    tabs, and so on. Our GUI has become responsive again because we are using threads!
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we called methods of our GUI class in their own threads and
    learned that we have to start the threads. Otherwise, the thread gets created
    but just sits there waiting for us to run its target method.
  prefs: []
  type: TYPE_NORMAL
- en: We noticed that each thread gets assigned a unique name and ID.
  prefs: []
  type: TYPE_NORMAL
- en: We simulated long-running tasks by inserting a `sleep` statement into our code,
    which showed us that threads can indeed solve our problem.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have to start a thread to actually make it do something by calling the `start()`
    method, so, intuitively, we would expect there to be a matching `stop()` method,
    but there is no such thing. In this recipe, we will learn how to run a thread
    as a background task, which is called a daemon. When closing the main thread,
    which is our GUI, all daemons will automatically be stopped as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we call methods in a thread, we can also pass arguments and keyword arguments
    to the method. We start this recipe by doing exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By adding `args=[8]` to the thread constructor and modifying the targeted method
    to expect arguments, we can pass arguments to threaded methods. The parameter
    to `args` has to be a sequence, so we will wrap our number in a Python list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the following code, `runT` is a local variable which we only access within
    the scope of the method inside of which we created `runT`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By turning the local variable into a member, we can then check if the thread
    is still running by calling `isAlive` on it from another method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have elevated our local `runT` variable to a member
    of our class. What this does is enable us to assess the `self.runT` variable from
    any method in our class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is achieved like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When we click the button and then exit the GUI, we can see that the print statement
    in the `createThread` method was printed, but we do not see the second print statement
    from `methodInAThread`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we get a RuntimeError.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Threads are expected to finish their assigned task so when we close the GUI
    while the thread has not completed, Python tells us that the thread we started
    is not in the main event loop.
  prefs: []
  type: TYPE_NORMAL
- en: We can solve this by turning the thread into a daemon, which will then execute
    as a background task.
  prefs: []
  type: TYPE_NORMAL
- en: What this gives us is that, as soon as we close our GUI, which is our main thread
    starting other threads, the daemon threads will cleanly exit.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this by calling the `setDaemon(True)` method on the thread before
    we start the thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When we now click the button and exit our GUI while the thread has not yet completed
    its assigned task, we no longer get any errors.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While there is a start method to make threads run, surprisingly there is not
    really an equivalent stop method.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are running a method in a thread, which prints numbers to
    our `ScrolledText` widget.
  prefs: []
  type: TYPE_NORMAL
- en: When we exit our GUI, we are no longer interested in the thread that used to
    print to our widget, so, by turning the thread into a background daemon, we can
    exit our GUI cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: How to use queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Python queue is a data structure that implements the first-in-first-out paradigm,
    basically working like a pipe. You shovel something into the pipe on one side
    and it falls out on the other side of the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between this queue shoveling, and shoveling mud into physical
    pipes is that, in Python queues, things do not get mixed up. You put one unit
    in, and that unit comes back out on the other side. Next, you place another unit
    in (say, for example, an instance of a class), and this entire unit will come
    back out on the other end as one integral piece.
  prefs: []
  type: TYPE_NORMAL
- en: It comes back out at the other end in the exact order we inserted code into
    the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A queue is not a stack where we push and pop data. A stack is a last-in-first-out
    (LIFO) data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Queues are containers that hold data being fed into the queue from potentially
    different data sources. We can have different clients providing data to the queue
    whenever those clients have data available. Whichever client is ready to send
    data to our queue sends it, and we can then display this data in a widget or send
    it forward to other modules.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple threads to complete assigned tasks in a queue is very useful
    when receiving the final results of the processing and displaying them. The data
    is inserted at one end of the queue and then comes out of the other end in an
    ordered fashion, First-In-First-Out (FIFO).
  prefs: []
  type: TYPE_NORMAL
- en: Our GUI might have five different button widgets that each kick off different
    tasks that we want to display in our GUI in a widget (for example, a ScrolledText
    widget).
  prefs: []
  type: TYPE_NORMAL
- en: These five different tasks take a different amount of time to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a task has completed, we immediately need to know this and display
    this information in our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: By creating a shared Python queue and having the five tasks write their results
    to this queue, we can display the result of whatever task has been completed immediately
    using a FIFO approach.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our GUI is ever increasing in its functionality and usefulness, it starts
    to talk to networks, processes, and websites, and will eventually have to wait
    for data to be made available for the GUI to represent.
  prefs: []
  type: TYPE_NORMAL
- en: Creating queues in Python solves the problem of waiting for data to be displayed
    inside our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create queues in Python, we have to import the `Queue` class from
    the `queue` module. Add the following statement towards the top of our GUI module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That gets us started.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a queue instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding code we create a local `Queue` instance that is only accessible
    within this method. If we wish to access this queue from other places, we have
    to turn it into a member of our class by using the `self` keyword which binds
    the local variable to the entire class, making it available from any other method
    within our class. In Python, we often create class instance variables in the `__init__(self)`
    method but Python is very pragmatic and enables us to create those member variables
    anywhere in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have an instance of a queue. We can prove that this works by printing
    it out.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to put data into the queue, we use the `put` command. In order to get
    data out of the queue, we use the `get` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Running the modified code results in the message first being placed in the `Queue`,
    and then being taken out of the `Queue`, and then printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can place many messages into the queue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have placed 10 messages into the `Queue`, but we are only getting the first
    one out. The other messages are still inside of the `Queue`, waiting to be taken
    out in a FIFO fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to get all messages that have been placed into a `Queue` out, we can
    create an endless loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](graphics/B04829_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While this code works, unfortunately it freezes our GUI. In order to fix this,
    we have to call the method in its own thread, as we did in previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our method in a thread and tie it to the button event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When we now click the action `Button`, we no longer get an extraneous pop-up
    window and the code works.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a `Queue`, placed messages into one side of the `Queue` in a
    first-in-first-out (aka FIFO) fashion. We got the messages out of the `Queue`
    and then printed them to the console (stdout).
  prefs: []
  type: TYPE_NORMAL
- en: We realized that we have to call the method in its own `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing queues among different modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will pass `Queues` around different modules. As our GUI code
    increases in complexity, we want to separate the GUI components from the business
    logic, separating them out into different modules.
  prefs: []
  type: TYPE_NORMAL
- en: Modularization gives us code reuse and also makes the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Once the data to be displayed in our GUI comes from different data sources,
    we will face latency issues, which is what `Queues` solve. By passing instances
    of `Queues` among different Python modules, we are separating the different concerns
    of the modules' functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GUI code ideally would only be concerned with creating and displaying widgets.
  prefs: []
  type: TYPE_NORMAL
- en: The business logic modules' job is to only do the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: We have to combine the two elements, ideally using as few relations among the
    different modules, reducing code interdependence.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The coding principle of avoiding unnecessary dependencies is usually called
    "loose coupling".
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand the significance of loose coupling, we can draw some
    boxes on a whiteboard or a piece of paper. One box represents our GUI class and
    code, while the other boxes represent business logic, databases, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we draw lines between the boxes, graphing out the interdependencies between
    those boxes which are our Python modules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fewer lines we have between our Python boxes, the more loosely-coupled our
    design is.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipe, we have started to use `Queues`. In this recipe we will
    pass instances of a `Queue` from our main GUI thread to other Python modules,
    which will enable us to write to the `ScrolledText` widget from another module
    while keeping our GUI responsive.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we create a new Python module in our project. Let's call it `Queues.py`.
    We'll place a function into it (no OOP necessary yet) and pass it an instance
    of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: We also pass a self-reference of the class that creates the GUI form and widgets,
    which enables us to use all of the GUI methods from another Python module.
  prefs: []
  type: TYPE_NORMAL
- en: We do this in the button callback.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the magic of OOP. In the middle of a class, we pass ourselves into a
    function we are calling from within the class, using the `self` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The code now looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The imported module contains the function we are calling,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have commented out the call to `createThread` in the button callback because
    we are now calling it from our new module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By passing in a self-reference from the class instance to the function the class
    is calling in another module, we now have access to all of our GUI elements from
    other Python modules.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code creates the following result.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will create the `Queue` as a member of our class, placing a reference
    to it in the `__init__` method of the class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now we can put messages into the queue from our new module by simply using the
    passed-in class reference to our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `createThread` method in our GUI code now only reads from the queue, which
    got filled in by the business logic residing in our new module, which has separated
    the logic from our GUI module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Running our modified code creates the same results. We have not broken anything
    (yet)!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to separate the GUI widgets from the functionality that expresses the
    business logic, we created a class, made a queue a member of this class and, by
    passing an instance of the class into a function residing in a different Python
    module, we now have access to all of the GUI widgets as well as the `Queue`.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is an example of when it makes sense to program in OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Using dialog widgets to copy files to your network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows us how to copy files from your local hard drive to a network
    location.
  prefs: []
  type: TYPE_NORMAL
- en: We will do this by using one of Python's tkinter built-in dialogs, which enables
    us to browse our hard drive. We can then select a file to be copied.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe also shows us how to make `Entry` widgets read-only and to default
    our `Entry` to a specified location, which speeds up the browsing of our hard
    drive.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will extend **Tab 2** of the GUI we have been building in previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add the following code to our GUI in the `def createWidgets(self)` method towards
    the bottom where we created Tab Control 2.
  prefs: []
  type: TYPE_NORMAL
- en: The parent of the new widget frame is `tab2`, which we have created at the very
    beginning of the `createWidgets()` method. As long as you place the code shown
    as follows physically below the creation of `tab2`, it will work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will add two buttons and two entries to **Tab 2** of our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: We are not yet implementing the functionality of our button callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code creates the following GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking the **Browse to File…** button currently prints to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can use tkinter's built-in file dialogs so let's add the following `import`
    statements to the top of our Python GUI module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can now use the dialogs in our code. Instead of hard-coding a path, we can
    use Python's os module to find the full path to where our GUI module resides.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Clicking the browse button now opens up the `askopenfilename` dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can now open a file in this directory or browse to a different directory.
    After selecting a file and clicking the **Open** button in the dialog, we will
    save the full path to the file in the `fName` local variable.
  prefs: []
  type: TYPE_NORMAL
- en: It would be nice if, when we opened our Python `askopenfilename` dialog widget,
    we would automatically default to a directory so that we would not have to browse
    all the way to where we were looking for a particular file to be opened.
  prefs: []
  type: TYPE_NORMAL
- en: It is best to demonstrate how to do this by going back to our GUI **Tab 1**,
    which is what we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: We can default values into Entry widgets. Back on our **Tab 1**, this is very
    easy. All we have to do is add the following two lines of code to the creation
    of the `Entry` widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When we now run the GUI, the `nameEntered` Entry has a default value.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can get the full path to the module we are using with the following Python
    syntax and then we can create a new subfolder just below it. We can do this as
    a module level global, or we can create the subfolder within a method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We are setting defaults for both entry widgets and, after setting them, we make
    the local file entry widget read-only.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This order is important. We have to first populate the entry before we make
    it read-only.
  prefs: []
  type: TYPE_NORMAL
- en: We are also selecting **Tab 2** before calling the main event loop and no longer
    set the focus into the `Entry` of **Tab 1**. Calling `select` on our tkinter `notebook`
    is zero-based so by passing in the value of 1 we select **Tab 2**…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](graphics/B04829_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we are not all on the same network, this recipe will use the local hard drive
    as an example for a network.
  prefs: []
  type: TYPE_NORMAL
- en: A UNC path is a Universal Naming Convention and what this means is that we can
    access a server on our network by using double backslashes to access a network
    server instead of the typical `C:\` when we access our local hard drive on a Windows
    PC.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just have to use the UNC and replace `C:\` with `\\<server name> \<folder>\`.
  prefs: []
  type: TYPE_NORMAL
- en: This example can be used to back up our code to a backup directory, which we
    can create if it does not exist by using `os.makedirs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After selecting a file to copy to somewhere else, we import the Python `shutil`
    module. We need the full path to the source of the file to be copied, a network
    or local directory path, and then we append the file name to the path where we
    are going to copy it, using `shutil.copy`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shutil is short-hand notation for shell utility.
  prefs: []
  type: TYPE_NORMAL
- en: We also give feedback to the user via a message box to indicate whether the
    copying succeeded or failed. In order to do this, import `messagebox` and rename
    it `mBox`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we will mix two different approaches of where to place
    our import statements. In Python, we have some flexibility that other languages
    do not provide.
  prefs: []
  type: TYPE_NORMAL
- en: We typically place all of the import statements towards the very top of each
    of our Python modules so that it is clear which modules we are importing.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, a modern coding approach is to place the creation of variables
    close to the function or method where they are first being used.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we import the message box at the top of our Python module,
    but then we also import the shutil Python module in a function.
  prefs: []
  type: TYPE_NORMAL
- en: Why would we wish to do this?
  prefs: []
  type: TYPE_NORMAL
- en: Does this even work?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is, yes, it does work, and we are placing this import statement into
    a function because this is the only place in our code where we actually do need
    this module.
  prefs: []
  type: TYPE_NORMAL
- en: If we never call this method, then we will never import the module this method
    requires.
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, you can view this technique as the lazy initialization design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't need it, we don't import it until we really do require it in our
    Python code.
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is that our entire code might require, let's say, twenty different
    modules. At runtime, which modules are really needed depends upon the user interaction.
    If we never call the `copyFile()` function then there is no need to import `shutil`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we click the button that invokes the `copyFile()` function in this function,
    we import the required module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When we now run our GUI and browse to a file and click copy, the file is copied
    to the location we specified in our `Entry` widget.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the file does not exist or we forgot to browse to a file and are trying to
    copy the entire parent folder, the code will let us know this as well because
    we are using Python's built-in exception handling capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are copying files from our local hard drive to a network by using the Python
    shell utility. As most of us are not connected to the same local area network,
    we simulate the copying by backing up our code to a different local folder.
  prefs: []
  type: TYPE_NORMAL
- en: We are using one of tkinter's dialog controls and, by defaulting directory paths,
    we can increase our efficiency in copying files.
  prefs: []
  type: TYPE_NORMAL
- en: Using TCP/IP to communicate via networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to use sockets to communicate via TCP/IP. In order
    to achieve this, we need both an IP address and a port number.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep things simple and independent of the ever-changing internet
    IP addresses, we will create our own local TCP/IP server and, as a client, learn
    how to connect to it and read data from a TCP/IP connection.
  prefs: []
  type: TYPE_NORMAL
- en: We will integrate this networking capability into our GUI by using the queues
    we created in previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a new Python module, which will be the TCP server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to implement a TCP server in Python is to inherit from the `socketserver`
    module. We subclass `BaseRequestHandler` and then override the inherited `handle`
    method. In very few lines of Python code, we can implement a TCP server module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We are passing in our `RequestHandler` class into a `TCPServer` initializer.
    The empty single quotes are a short cut for passing in localhost, which is our
    own PC. This is the IP address of 127.0.0.1\. The second item in the tuple is
    the port number. We can choose any port number that is not in use on our local
    PC.
  prefs: []
  type: TYPE_NORMAL
- en: We just have to make sure that we are using the same port on the client side
    of the TCP connection, otherwise we would not be able to connect to the server.
    Of course, we have to start the server first before clients can connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: We will modify our `Queues.py` module to become the TCP client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is all the code we need to talk to the TCP server. In this example, we
    are simply sending some bytes to the server and the server sends them back, prepending
    some strings before returning the response.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This shows the principle of how TCP communications via networks work.
  prefs: []
  type: TYPE_NORMAL
- en: Once we know how to connect to a remote server via TCP/IP, we will use whatever
    commands are designed by the protocol of the program we are interested in communicating
    with. The first step is to connect before we can send commands to specific applications
    residing on a server.
  prefs: []
  type: TYPE_NORMAL
- en: In the `writeToScrol` function, we will use the same loop as before but now
    we will send the messages to the TCP server. The server modifies the received
    message and then sends it back to us. Next, we place it into the GUI member queue
    which, as in previous recipes, runs in its own `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python 3, we have to send strings over sockets in binary format. Adding the
    integer index now becomes a little bit convoluted as we have to cast it to a string,
    encode it, and then cast the encoded string into bytes!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note the `b` before the string and then, well, all the rest of the required
    casting…
  prefs: []
  type: TYPE_NORMAL
- en: We are starting the TCP server in its own thread in the initializer of the OOP
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Clicking the **Click Me!** button on **Tab 1** now creates the following output
    in our `ScrolledText` widget, as well as on the console, and the response, due
    to using `Threads`, is very fast.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a TCP server to simulate connecting to a server in our local area
    network or on the Internet. We turned our queues module into a TCP client. We
    are running both the queue and the server in their own background thread, which
    keeps our GUI very responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Using URLOpen to read data from websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how we can easily read entire webpages by using Python's built-in
    modules. We will display the webpage data first in its raw format and then decode
    it, and then we will display it in our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will read the data from a webpage and then display it in the `ScrolledText`
    widget of our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we create a new Python module and name it `URL.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We then import the required functionality to read webpages using Python.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this in very few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: We are wrapping our code in a `try…except` block similar to Java and C#. This
    is a modern approach to coding which Python supports.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we have code that might not complete we can experiment with this code
    and, if it works, all is fine.
  prefs: []
  type: TYPE_NORMAL
- en: If the block of code in the `try…except` block does not work, the Python interpreter
    will throw one of several possible exceptions, which we then can catch. Once we
    have caught the exception we can decide what to do next.
  prefs: []
  type: TYPE_NORMAL
- en: There is a hierarchy of exceptions in Python and we can also create our own
    classes that inherit from and extend the Python exception classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the code shown as follows, we are mainly concerned that the URL we are trying
    to open might not be available and so we wrap our code within a `try…except` code
    block.
  prefs: []
  type: TYPE_NORMAL
- en: If the code succeeds in opening the requested URL, all is fine.
  prefs: []
  type: TYPE_NORMAL
- en: If it fails, maybe because our internet connection is down, we fall into the
    exception part of the code and print out that an exception has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about Python exception handling at [https://docs.python.org/3.4/library/exceptions.html](https://docs.python.org/3.4/library/exceptions.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: By calling `urlopen` on the official Python website, we get the entire data
    as one long string.
  prefs: []
  type: TYPE_NORMAL
- en: The first print statement prints this long string out to the console.
  prefs: []
  type: TYPE_NORMAL
- en: We then call `decode` on the result and this time we get a little over 1,000
    lines of web data, including some whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: We are also printing out the type of calling `urlopen`, which is an `http.client.HTTPResponse`
    object. Actually, we are printing it out first.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here is the official Python webpage we just read. If you are a web developer,
    you probably have some good ideas what to do with the parsed data.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We next display this data in our GUI inside the `ScrolledText` widget. In order
    to do so, we have to connect our new module to read the data from the webpage
    to our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we need a reference to our GUI, and one way to do this
    is by tying our new module to the **Tab 1** button callback.
  prefs: []
  type: TYPE_NORMAL
- en: We can return the decoded HTML data from the Python webpage to the `Button`
    widget, which we can then place in the `ScrolledText` control.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's turn our code into a function and return the data to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can now write the data in our `button` callback method to the `ScrolledText`
    control by first importing the new module and then inserting the data into the
    widget. We also give it some sleep after the call to `writeToScrol`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The HTML data is now displayed in our GUI widget.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create a new module to separate the code that gets the data from a webpage
    from our GUI code. This is always a good thing to do. We read in the webpage data
    and then return it to the calling code after decoding it. We then use the button
    callback function to place the returned data in the `ScrolledText` control.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced us to some advanced Python programming concepts, which
    we combined to produce a functional GUI program.
  prefs: []
  type: TYPE_NORMAL

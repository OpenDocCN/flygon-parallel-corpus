- en: Chapter 11. Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore best practices related to our Python GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding spaghetti code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __init__ to connect modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing fall-down and OOP coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a code naming convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When not to use OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use design patterns successfully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore different best practices that can help us to
    build our GUI in an efficient way and keep it both maintainable and extendible.
  prefs: []
  type: TYPE_NORMAL
- en: These best practices will also help us to debug our GUI to get it just the way
    we want it to be.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding spaghetti code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will explore a typical way to create spaghetti code and then
    we will see a much better way of how to avoid such code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spaghetti code is code in which a lot of functionality is intertangled.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a new, simple GUI written in Python using the tkinter built-in
    Python library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having searched online and read the documentation, we might start by writing
    the following code to create our GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code results in the following GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is not quite the GUI we intended. We wanted it to look something more
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While the spaghetti code created a GUI, the code is very hard to debug because
    there is so much confusion in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code that produces the desired GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we compared spaghetti code to good code. Good code has many
    advantages over the spaghetti code.
  prefs: []
  type: TYPE_NORMAL
- en: It has clearly commented sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spaghetti code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Good code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It has a natural flow that follows how the widgets get laid out in the GUI main
    form.
  prefs: []
  type: TYPE_NORMAL
- en: In the spaghetti code, the bottom LabelFrame gets created before the top LabelFrame
    and it is intermixed with an import statement and some widget creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spaghetti code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Good code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It does not contain unnecessary variable assignments and neither does it have
    a `print` function that does not do the debugging one might expect it to do when
    reading the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spaghetti code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Good code:'
  prefs: []
  type: TYPE_NORMAL
- en: Has none of the above.
  prefs: []
  type: TYPE_NORMAL
- en: The `import` statements only import the required modules. They are not cluttered
    throughout the code. There are no duplicate `import` statements. There is no `import
    *` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spaghetti code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Good code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The chosen variable names are quite meaningful. There are no unnecessary `if`
    statements that use the number `1` instead of `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spaghetti code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Good code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We did not lose the intended window title and our check button ended up in the
    correct position. We also made the `LabelFrame` surrounding the check button visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spaghetti code:'
  prefs: []
  type: TYPE_NORMAL
- en: We lost both the window title and did not display the top `LabelFrame`. The
    check button ended up in the wrong place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using __init__ to connect modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a new Python project using the PyDev plugin for the Eclipse IDE,
    it automatically creates a `__init__.py` module. We can also create it ourselves
    manually when not using Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `__init__.py` module is usually empty and then has a size of 0 kilobytes.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this usually empty module to connect different Python modules by
    entering code into it. This recipe will show how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a new GUI similar to the one we created in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our project becomes larger and larger, we naturally break it out into several
    Python modules. Using a modern IDE such as Eclipse, it is surprisingly complicated
    to find modules that are located in different subfolders either above or below
    the code that needs to import it.
  prefs: []
  type: TYPE_NORMAL
- en: One practical way to get around this limitation is to use the `__init__.py`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Eclipse, we can set the Eclipse internal project environment to certain folders
    and our Python code will find it. But outside of Eclipse, for example when running
    from a command window, there is sometimes a mismatch in the Python module import
    mechanism and the code will not run.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a screenshot of the empty `__init__.py` module, which appears not with
    the name `__init__` but with the name of the PyDev package it belongs to when
    opened in the Eclipse code editor. The "1" on the left side of the code editor
    is the line number and not any code written in this module. There is absolutely
    no code in this empty `__init__.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This file is empty, but it does exist.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we run the following code and click the `clickMe Button`, we get the result
    shown following the code. This is a regular Python module that does not yet use
    the `__init__.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The __`init__.py` module is not the same as the `__init__(self)` method of a
    Python class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](graphics/B04829_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code, we created the following function, which imports Python''s
    message box and then uses it to display the message box window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When we move the `clickMe()` message box code into a nested directory folder
    and try to `import` it into our GUI module, we run into some problems.
  prefs: []
  type: TYPE_NORMAL
- en: We have created three sub-folders below where our Python module lives. We then
    placed the `clickMe()` message box code into a new Python module, which we named
    `MessageBox.py`. This module lives in `Folder3`, three levels below where our
    Python module lives.
  prefs: []
  type: TYPE_NORMAL
- en: We need to import this `MessageBox.py` module in order to use the `clickMe()`
    function that this module contains.
  prefs: []
  type: TYPE_NORMAL
- en: At first, it appears to work because it seems we can import the new nested module
    as we are not getting any errors or warnings from the Eclipse IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using Python''s relative import syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have deleted the local `clickMe()` function and now our callback should
    use the imported `clickMe()` function, but it is not working as expected. Instead
    of the expected popup window, we get an import system error when we run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can add the subfolder where our new function lives as an external library
    in Eclipse by going to the PyDev Project properties and adding ourselves as an
    external library. This does not seem very intuitive, but it does work.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we now comment out the folder structure and, instead, directly import the
    function from the module which is nested to three levels, the code works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This function displays a different text in a message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A better way to achieve the same result is to use Python's built-in `__init__.py`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: After deleting the previously Eclipse-specific external library dependency,
    we can now use this module directly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code we place into this module runs before all of our other code if we import
    the `__init__.py` module into our program, as of Python 3.4.3.
  prefs: []
  type: TYPE_NORMAL
- en: Ignore the PyDev Unresolved Import (red circle with a cross) error. This `import`
    is necessary; it makes our code run and the entire Python importing mechanism
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After importing the `__init__.py` module into our program, we can use it. The
    first test to check if it works is to code a print statement into this module.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By adding the following code, we can find out programmatically where we are
    located:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can initialize our Python search path from within this `__init__.py`
    module by adding the following code to the same `__init__.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When we now run our GUI code, we get the same expected windows, but we have
    removed our dependency on the Eclipse `PYTHONPATH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can successfully run the same code outside of the Eclipse PyDev plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our code has become more Pythonic.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we discovered a limitation of using the PyDev plugin, which
    comes free with the wonderful and free Eclipse IDE.
  prefs: []
  type: TYPE_NORMAL
- en: We first found a workaround in the Eclipse IDE, and next, we became independent
    from this IDE by becoming Pythonic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using pure Python is usually the best way to go.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing fall-down and OOP coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is an object-oriented programming language yet it does not always make
    sense to use OOP. For simple scripting tasks, the legacy waterfall coding style
    is still appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a new GUI that mixes both the fall-down coding
    style with the more modern OOP coding style.
  prefs: []
  type: TYPE_NORMAL
- en: We will create an OOP-style class that will display a tooltip when we hover
    the mouse over a widget in a Python GUI that we will create using a waterfall
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fall-down and waterfall coding styles are the same. It means that we have to
    physically place code above code before we can call it from the code below. In
    this paradigm, the code literally falls down from the top of our program to the
    bottom of our program when we execute the code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create a GUI using tkinter, which is similar to the
    GUI we created in the first chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, we can bind functions to classes by turning them into methods using
    the `self` keyword. This is a truly wonderful capability of Python and it allows
    us to create large systems that are understandable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, when we only write short scripts, OOP does not make sense because
    we find ourselves prepending a lot of variables with the `self` keyword and the
    code gets unnecessarily large when it does not need to be.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first create a Python GUI using tkinter and code it in the waterfall style.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates the GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the code, we get the GUI and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can improve our Python GUI by adding tooltips. The best way to do this is
    to isolate the code that creates the tooltip functionality from our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: We do this by creating a separate class that has the tooltip functionality,
    and then we create an instance of this class in the same Python module that creates
    our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python, there is no need to place our `ToolTip` class into a separate
    module. We can place it just above the procedural code and then call it from below
    this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Running the code creates tooltips for our widgets when we hover the mouse over
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a Python GUI in a procedural way, and later, we added
    a class to the top of the module.
  prefs: []
  type: TYPE_NORMAL
- en: We can very easily mix and match both procedural and OOP programming in the
    same Python module.
  prefs: []
  type: TYPE_NORMAL
- en: Using a code naming convention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipes in this book have not used a structured code naming convention.
    This recipe will show you the value of adhering to a code naming scheme because
    it helps us to find the code we want to extend, as well as reminds us of the design
    of our program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will look at the Python module names from the first chapter
    of this book and compare them to better naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first chapter of this book, we created our first Python GUI. We improved
    our GUI by incrementing the different code module names via sequential numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While this is a typical way to code, it does not provide much meaning. When
    we write our Python code during development, it is very easy to increment numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Later, coming back to this code, we don't have much of an idea which Python
    module provides which functionality, and sometimes, our last incremented modules
    are not as good as earlier versions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A clear naming convention does help.
  prefs: []
  type: TYPE_NORMAL
- en: We can compare the module names from [Chapter 1](ch01.html "Chapter 1. Creating
    the GUI Form and Adding Widgets"), *Creating the GUI Form and Adding Widgets*,
    to the names from [Chapter 8](ch08.html "Chapter 8. Internationalization and Testing"),
    *Internationalization and Testing*, which are much more meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While not perfect, the names chosen for the different Python modules, indicate
    what each module's responsibility is. When we want to add more unit tests, it
    is clear in which module they reside.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is another example of how to use a code naming convention to
    create a GUI in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replace the word `PRODUCT` with the product you are currently working on.
  prefs: []
  type: TYPE_NORMAL
- en: The entire application is a GUI. All parts are connected. The `DEBUG.py` module
    is only used for debugging our code. The main function to invoke the GUI has its
    name reversed when compared to all of the other modules. It starts with `Gui`
    and ends in a `.pyw` extension.
  prefs: []
  type: TYPE_NORMAL
- en: It is the only Python module that has this extension name.
  prefs: []
  type: TYPE_NORMAL
- en: From this naming convention, if you are familiar enough with Python, it will
    be obvious that, in order to run this GUI, you double-click the `Gui_PRODUCT.pyw`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: All other Python modules contain functionality to supply to the GUI as well
    as execute the underlying business logic to fulfil the purpose this GUI addresses.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Naming conventions for Python code modules are a great help in keeping us efficient
    and remembering our original design. When we need to debug and fix a defect or
    add new functionality, they are the first resource to look at.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Incrementing module names by numbers is not very meaningful and eventually wastes
    development time.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, naming Python variables is more of a free form. Python infers
    types, so we do not have to specify that a variable will be of type `<list>` (it
    might not be or actually, later in the code, it might become a different type).
  prefs: []
  type: TYPE_NORMAL
- en: A good idea for naming variables is to make them descriptive and it is also
    a good idea not to abbreviate too much.
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to point out that a certain variable is designed to be of type `<list>`,
    then it is much more intuitive to use the full word `list` instead of `lst`.
  prefs: []
  type: TYPE_NORMAL
- en: It is similar for `number` instead of `num`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it is a good idea to have very descriptive names for variables, sometimes
    that can get too long. In Apple''s Objective-C language, some variable and function
    names are extreme: `thisIsAMethodThatDoesThisAndThatAndAlsoThatIfYouPassInNIntegers:1:2:3`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use common sense when naming variables, methods, and functions.
  prefs: []
  type: TYPE_NORMAL
- en: When not to use OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python comes built-in with object-oriented programming capabilities, but at
    the same time, we can write scripts that do not need to use OOP.
  prefs: []
  type: TYPE_NORMAL
- en: For some tasks, OOP does not make sense.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show when not to use OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create a Python GUI similar to previous recipes. We
    will compare the OOP code to the non-OOP alternative way of programming.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first create a new GUI using **OOP** methodology. The following code
    will create the GUI displayed below the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](graphics/B04829_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can achieve the same GUI without using an OOP approach by restructuring our
    code slightly. First, we remove the `OOP` class and its `__init__` method.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we move all methods to the left and remove the `self` class reference
    which turns them into unbound functions.
  prefs: []
  type: TYPE_NORMAL
- en: We also remove any other `self` references our previous code had. Then, we move
    the `createWidgets` function call below the point of the function's declaration.
    We place it just above the `mainloop` call.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we achieve the same GUI but without using OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The refactored code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python enables us to use OOP when it makes sense. Other languages such as Java
    and C# force us to always use the OOP approach to coding. In this recipe, we explored
    a situation when it did not make sense to use OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The OOP approach will be more extendible if the codebase grows but, if it's
    certain that it is the only code that's needed then there's no need to go through
    OOP.
  prefs: []
  type: TYPE_NORMAL
- en: How to use design patterns successfully
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create widgets for our Python GUI by using the factory
    design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In previous recipes, we created our widgets either manually one at a time or
    dynamically in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Using the factory design pattern, we will use the factory to create our widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a Python GUI which has three buttons each having different styles.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Towards the top of our Python GUI module, just below the import statements,
    we create several classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We create a base class which our different button style classes inherit from
    and in which each of them overrides the `relief` and `foreground` configuration
    properties. All subclasses inherit the `getButtonConfig` method from this base
    class. This method returns a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: We also create a button factory class and a list that holds the names of our
    button subclasses. We name the list `buttonTypes` as our factory will create different
    types of buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Further down in the module we create the button widgets, using the same `buttonTypes`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: First, we create an instance of the button factory and then we use our factory
    to create our buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The items in the `buttonTypes` list are the names of our subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: We invoke the `createButton` method and then immediately call the `getButtonConfig`
    method of the base class and retrieve the configuration properties using dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the entire code, we get the following Python tkinter GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that our Python GUI factory did indeed create different buttons,
    each having a different style. They differ in the color of their text and in their
    relief property.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used the factory design pattern to create several widgets
    that have different styles. We can easily use this design pattern to create entire
    GUIs.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are a very exciting tool in our software development toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will extend our Python GUI and learn ways to handle the ever-increasing
    complexity of our software development efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Our co-workers and clients love the GUIs we create in Python and ask for more
    and more features to add to our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: This increases complexity and can easily ruin our original nice design.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a new Python GUI similar to those in previous recipes and will
    add many features to it in the form of widgets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with a Python GUI that has two tabs and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first new feature request we receive is to add functionality to **Tab 1**,
    which clears the `scrolledtext` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Easy enough. We just add another button to **Tab 1**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We also have to create the callback method to add the desired functionality,
    which we define towards the top of our class and outside the method that creates
    our widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now our GUI has a new button and, when we click it, we clear the text of the
    `ScrolledText` widget.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to add this functionality, we had to add code in two places in the
    same Python module.
  prefs: []
  type: TYPE_NORMAL
- en: We inserted the new button in the `createWidgets` method (not shown) and then
    we created a new callback method, which our new button calls when it is clicked.
    We placed this code just below the callback of our first button.
  prefs: []
  type: TYPE_NORMAL
- en: Our next feature request is to add more functionality. The business logic is
    encapsulated in another Python module. We invoke this new functionality by adding
    three more buttons to **Tab 1**. We use a loop to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our GUI now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, our customers ask for more features and we use the same approach. Our
    GUI now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B04829_11_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is not too bad. When we get new feature requests for another 50 new features,
    we start to wonder if our approach is still the best approach to use…
  prefs: []
  type: TYPE_NORMAL
- en: One way to handle the ever-increasing complexity our GUI has to handle is by
    adding tabs. By adding more tabs and placing related features into their own tab,
    we get control of the complexity and make our GUI more intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that creates our new **Tab 3** and, below it, is our new Python
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](graphics/B04829_11_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we added several new widgets to our GUI in order to add more
    functionality to our Python GUI. We saw how more and more new feature requests
    easily got our nice GUI design into a state where it became less clear how to
    use the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suddenly, widgets took over the world…
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to handle complexity by modularizing our GUI by breaking large features
    into smaller pieces and arranging them in functionally-related areas using tabs.
  prefs: []
  type: TYPE_NORMAL
- en: While complexity has many aspects, modularizing and refactoring code is usually
    a very good approach to handling software code complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In programming, at certain times, we run into a wall and get stuck. We keep
    banging our head against this wall but nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we feel like we want to give up.
  prefs: []
  type: TYPE_NORMAL
- en: However, miracles do happen…
  prefs: []
  type: TYPE_NORMAL
- en: If we keep on banging against this wall, at a certain moment in time, the wall
    will collapse and the road will be open.
  prefs: []
  type: TYPE_NORMAL
- en: At that point in time, we can make a positive dent in the software universe.
  prefs: []
  type: TYPE_NORMAL

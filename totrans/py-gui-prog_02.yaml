- en: Designing GUI Applications with Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software applications are developed in three repeating phases: understanding
    a problem, designing a solution, and implementing the solution. These phases repeat
    throughout the life of an application, refining and honing it until it is either
    optimal or obsolete.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing and analyzing a scenario in the workplace that will need a software
    solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting the requirements of the solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a design for a piece of software that implements the solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A problem at ABQ AgriLabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Congratulations! Your Python skills have landed you a great data analyst job
    at ABQ AgriLabs. So far, your job is fairly simple: collating and doing simple
    data analysis on the CSV files sent to you daily from the lab''s data entry staff.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a problem, though. You've noted with frustration that the quality of
    the CSV files from the lab is sadly inconsistent. Data is missing, typos abound,
    and often the files have to be re-entered in a time-consuming process. The lab
    director has noticed this as well and, knowing that you are a skilled Python programmer,
    she thinks you might be able to help.
  prefs: []
  type: TYPE_NORMAL
- en: You've been enlisted to program a solution that will allow the data entry staff
    to enter lab data into a CSV file with fewer mistakes. Your application needs
    to be simple and allow as little room for error as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Assessing the problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spreadsheets are often the first stop for computer users who need to keep track
    of data. Their table-like layouts and computational features seem to make them
    ideal for the task. However, as a set of data grows and is added to by multiple
    users, the shortcomings of spreadsheets become apparent: they don''t enforce data
    integrity, their table-like layout can be visually confusing when dealing with
    long rows of sparse or ambiguous data, and users can easily delete or overwrite
    data if they aren''t being careful.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve this situation, you propose to implement a simple GUI data entry
    form that appends data to a CSV file in the format we need. Forms can help to
    improve data integrity in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing only the correct type of data to be entered (for example, only allowing
    numerals in a number field)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting choices to only valid options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-filling information like current dates, times, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that entered data is within expected ranges or matches expected patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that all data has been filled in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By implementing such a form, we can greatly reduce the number of errors being
    entered by the data entry staff.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering information about the problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build the data entry form application, you need to gather details about
    what it needs to accomplish. Fortunately, you already know the output part of
    the equation: you need a CSV file containing data about the plants growing in
    the plots of each laboratory and the environmental conditions at each plot. You
    work with these files every day, so you''re pretty familiar with the field layout.'
  prefs: []
  type: TYPE_NORMAL
- en: However, you don't know everything about the data or the process of entering
    it; you'll need to talk to the other staff involved to find out more information.
  prefs: []
  type: TYPE_NORMAL
- en: First, you'll need to find out more detail about the data being recorded. This
    isn't always as easy as it sounds. The software needs absolute, black-and-white
    rules when dealing with data; people, on the other hand, tend to think in generalities
    about their data, and they often don't consider the exact details of limits or
    edge cases without some prompting.
  prefs: []
  type: TYPE_NORMAL
- en: As a programmer, it's your job to come up with questions that will bring out
    the information you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'You decide you should start with the lab technicians and learn more about the
    data they''re collecting. You come up with the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What values are acceptable for each field? Are any fields constrained to a set
    of values?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What units are represented by each of the numeric fields?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are numeric fields truly number-only fields? Would they ever need letters or
    symbols?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What range of numbers is acceptable for each numeric field?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you record data and how long does it take?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data isn't the only consideration. If we're making a program to help reduce
    user error, we also have to understand those users and how they work. In the case
    of this application, our users will be the data entry staff. We need to ask them
    questions about their needs and workflow to understand how to create an application
    that works well for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We come up with the following list of questions:'
  prefs: []
  type: TYPE_NORMAL
- en: In what format do you get the data you're entering?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When is the data received and how soon is it entered? What's the latest it might
    be entered?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there fields that could be automatically populated? Should users be able
    to override the auto values?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's the overall technical ability of the users?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do you like about the current solution? What do you dislike?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do users have visual or manual impairments that should be accommodated?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we need to understand the technology involved with operating our application—the
    computers, networks, servers, and platforms being used to accomplish the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'You decide to add the following questions, which you''ll assess yourself when
    you meet with the data entry staff:'
  prefs: []
  type: TYPE_NORMAL
- en: What kind of computer does data entry use?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What platform does it run?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How fast or powerful is it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is Python available on these systems?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which Python libraries are available?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you found out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You start by writing down the following basics about ABQ that you know:'
  prefs: []
  type: TYPE_NORMAL
- en: Your ABQ facility has five greenhouses, each operating with a different climate,
    marked A, B, C, D, and E
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each greenhouse has 20 plots (labeled 1 through 20)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are currently four seed samples, each coded with a six-character label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each plot has 20 seeds of a given sample planted in it, as well as its own environmental
    sensor unit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about the data being collected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your talk with the lab technicians revealed a lot about the data. Four times
    a day, at 8:00, 12:00, 16:00, and 20:00, each technician checks the plots in one
    or two labs. They use a paper form to record values at each plot, recording all
    values to two decimal places. This usually takes 30 to 40 minutes per lab, and
    the whole process typically takes 90 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Each plot has an environmental sensor that detects the light, temperature, and
    humidity at the plot. Unfortunately, these devices are prone to failure, indicated
    by an `Equipment` `Fault` light on the unit. Technicians record if this light
    is lit, since it invalidates the environmental data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the technicians tell you about the units and acceptable ranges for
    the fields, which you record in the following chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Data type** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `Date` | `Date` | The data collection date. Almost always the current date
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Time` | `Time` | The start of the period during which measurements were
    taken. One of 8:00, 12:00, 16:00, or 20:00 |'
  prefs: []
  type: TYPE_TB
- en: '| `Lab` | `Character` | The lab ID, which will be A to E |'
  prefs: []
  type: TYPE_TB
- en: '| `Technician` | `Text` | The name of the technician recording data |'
  prefs: []
  type: TYPE_TB
- en: '| `Plot` | `Int` | The plot ID, which will be 1 through 20 |'
  prefs: []
  type: TYPE_TB
- en: '| `Seed Sample` | `Text` | ID string for seed sample. Always a six-character
    code containing digits 0 to 9 and capital letters A to Z |'
  prefs: []
  type: TYPE_TB
- en: '| `Fault` | `Boolean` | True if environmental equipment registered a failure,
    otherwise false |'
  prefs: []
  type: TYPE_TB
- en: '| `Humidity` | `Decimal` | Absolute humidity in g/m³, roughly between 0.5 and
    52.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `Light` | `Decimal` | Amount of sunlight at the plot center in kilolux, between
    0 and 100 |'
  prefs: []
  type: TYPE_TB
- en: '| `Temperature` | `Decimal` | Degrees C, should not go below 4 or above 40
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Blossoms` | `Int` | The number of blossoms in the plot must be 0 or more,
    but unlikely to ever approach 1,000 |'
  prefs: []
  type: TYPE_TB
- en: '| `Fruit` | `Int` | The number of fruits in the plot must be 0 or more, but
    unlikely to ever approach 1,000 |'
  prefs: []
  type: TYPE_TB
- en: '| `Plants` | `Int` | The number of growing plants, between 0 and 20. |'
  prefs: []
  type: TYPE_TB
- en: '| `Max height` | `Decimal` | The height of the tallest plant in cm. At least
    0, unlikely to approach 1,000. |'
  prefs: []
  type: TYPE_TB
- en: '| `Median height` | `Decimal` | The median height of plants in the plot, in
    cm. At least 0, unlikely to approach 1,000 |'
  prefs: []
  type: TYPE_TB
- en: '| `Min height` | `Decimal` | The height of the smallest plant in cm. At least
    0, unlikely to approach 1,000 |'
  prefs: []
  type: TYPE_TB
- en: '| `Notes` | `Long Text` | Additional observations about the plant, data, instruments,
    and so on |'
  prefs: []
  type: TYPE_TB
- en: Information about the users of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your session with the data entry staff yielded good information about their
    workflow, requirements, and technology.
  prefs: []
  type: TYPE_NORMAL
- en: The lab technicians drop off their paper forms as they're completed. The data
    is typically entered right away and usually on the same day as it's handed in.
  prefs: []
  type: TYPE_NORMAL
- en: The technicians are currently using LibreOffice on a Debian Linux workstation
    to enter the data. Using copy and paste, they can bulk-fill fields with repeated
    data like date, time, and technician. The autocompletion feature of LibreOffice
    is often helpful in text fields, but sometimes causes accidental data errors in
    the number fields.
  prefs: []
  type: TYPE_NORMAL
- en: The workstation being used is several years old, but performs adequately. You
    get a chance to look at it and find that Python and Tkinter are already installed.
  prefs: []
  type: TYPE_NORMAL
- en: There are four data entry clerks in total, but only one working at any one time;
    while interviewing the clerks, you learn that one has red-green color blindness,
    and another has trouble using a mouse due to RSI issues. All are reasonably computer
    literate.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting specification requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've assembled your data about the application, it's time to write
    up a **specification**. Software specifications can range from very formal, contractual
    documents that include time estimates and deadlines, to a simple set of descriptions
    of what the programmer intends to build. The purpose of the specification is to
    give everyone involved in the project a point of reference for what the developer
    will create. It spells out the problem to be solved, the functionality required,
    and the scope of what the program should and shouldn't do.
  prefs: []
  type: TYPE_NORMAL
- en: Your scenario is rather informal and your application is simple, so you do not
    need a detailed formal specification in this case. However, a basic write-up of
    what you know will make sure that you, your boss, and the users are all on the
    same page.
  prefs: []
  type: TYPE_NORMAL
- en: Contents of a simple specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start our specification with the following outline of the items we need
    to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**: This is one or two sentences that describe the primary purpose,
    function, and goals of the application.  Think of it as the program''s mission
    statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functionality required**: This section is a list of specific things the program
    needs to be able to do to be minimally functional. It can include both hard requirements,
    such as detailed output and input formats, and soft requirements—goals that are
    not quantifiably attainable, but that the program should strive toward (for example,
    "reduce user errors as much as possible").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functionality not required**: This section is a list of things the program
    does not need to do; it exists to clarify the scope of the software and make sure
    nobody expects unreasonable things from the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitations**: This is a list of constraints under which the program must
    operate, both technological and human.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data dictionary**: This is a detailed list of the data fields the application
    will deal with and their parameters. These can get quite lengthy but are a critical
    reference as the application expands and the data gets utilized in other contexts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the ABQ data entry program specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You could write a specification in your favorite word processor, but ideally
    the specification is a part of your code; it will need to be kept with the code
    and synchronized with any changes to the application. For that reason, we're going
    to write it in our text editor using the **reStructuredText** markup language.
  prefs: []
  type: TYPE_NORMAL
- en: For Python documentation, reStructuredText, or reST, is the  official markup
    language. The Python community encourages the use of reST to document Python projects,
    and many packaging and publication tools used in the Python community expect the
    reST format. We'll cover reST in more depth in Chapter 5, *Planning for the Expansion
    of Our Application*, but you can find the official documentation at [http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin writing our specification, one section at a time as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin the specification with the name of the application and a short description.
    This should contain a summary of the program''s purpose, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's list the requirements. Remember that hard requirements are objectively
    attainable goals—input and output requirements, calculations that must be done,
    features that must be present, whereas our soft requirements are subjective or
    best-effort goals. Look through your findings from the last section, and consider
    which needs are which.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should come up with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll reign in the scope of the program with the `Functionality Not
    Required` section. Remember that this is only an entry form for now; editing or
    deletion will be handled in the spreadsheet application. We''ll clarify this as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `Limitations` section, remember that we have some users with physical
    constraints, as well has hardware and operating system constraints. Add it as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the data dictionary, this is essentially the table we''ve made previously,
    but we''ll break out range, data types, and units for quick reference, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That's our specification for now! The specification is very likely to grow,
    change, or evolve in complexity as we discover new needs.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our specification in hand and our requirements clear, it's time to start
    designing our solution. We'll start with the form GUI component itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create a basic design for our form in the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine the appropriate `input` widget for each data field
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Group together related items to create a sense of organization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Layout our widgets in their groups on a form sheet
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exploring Tkinter input widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like all toolkits, Tkinter offers a variety of `input` widgets for different
    kinds of data. However, `ttk` offers additional widget types and enhances some
    (but not all!) of Tkinter''s native widgets. The following table offers advice
    on which widgets are most appropriate for different kinds of data entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Widget** | **Description** | **Used for** |'
  prefs: []
  type: TYPE_TB
- en: '| `ttk.Entry` | Basic text entry | Single-line strings |'
  prefs: []
  type: TYPE_TB
- en: '| `ttk.Spinbox` | Text entry with increment/decrement arrows | Numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `Tkinter.Listbox` | Box with a list of choices | Choice between several values
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Tkinter.OptionMenu` | Drop-down list with choices | Choice between several
    values |'
  prefs: []
  type: TYPE_TB
- en: '| `ttk.Combobox` | Drop-down list with optional text entry | Choice between
    several values plus text entry |'
  prefs: []
  type: TYPE_TB
- en: '| `ttk.Checkbutton` | Checkbox with label | Boolean values |'
  prefs: []
  type: TYPE_TB
- en: '| `ttk.Radiobutton` | Like checkbox, but only one of a set can be selected
    | Choice between small set of values |'
  prefs: []
  type: TYPE_TB
- en: '| `Tkiner.Text` | Multiline text entry box | Long, multiline strings |'
  prefs: []
  type: TYPE_TB
- en: '| `Tkinter.Scale` | Mouse-operated slider | Bounded number data |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s consider which of these widgets are appropriate for the data that needs
    to be entered:'
  prefs: []
  type: TYPE_NORMAL
- en: There are several `Decimal` fields, many with clear boundary ranges with `Min
    height`, `Max height`, `Median height`, `Humidity`, `Temperature`, and `Light`.
    You could use a `Scale` widget for these, but it's not really appropriate for
    precise data entry, since it requires careful positioning to get an exact value.
    It's also mouse-operated and that violates your specification requirements. Instead,
    use the `Spinbox` widget for these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also some `Int` fields, such as `Plants`, `Blossoms`, and `Fruit`.
    Again, the `Spinbox` widget is the right choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a couple of fields with a limited set of possible values—`Time` and
    `Lab`. The `Radiobutton` or `Listbox` widgets could work for these, but both take
    up a lot of space and are less keyboard-friendly as they require selection with
    arrow keys. There is also `OptionMenu`, but it is also mouse or arrow keys only.
    For these, use the `Combobox` widget instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plot is a tricky case. At face value, it looks like an `Int` field, but think
    about it. The plots could just as well be identified by letters, or symbols, or
    names. Numbers just happen to be an easy set of values with which to assign arbitrary
    identifiers. The `Plot ID`, like the `Lab ID`, is a constrained set of values;
    so, it would make more sense to use a `Combobox` widget here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Notes` field is multiline text, so the `Text` widget is appropriate here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one `Boolean` field, `Fault`. It could be handled with `Radiobutton`
    or `Combobox`, but `Checkbutton` is the optimal choice—it's compact and reasonably
    keyboard-friendly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining lines are simple, one-line character fields. We'll use `Entry`
    for those fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might be wondering about the `Date` field. Tkinter has no special widget
    for dates; so, we'll use a generic `Entry` widget here for the time being.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our final analysis will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Widget type** |'
  prefs: []
  type: TYPE_TB
- en: '| `Blossoms` | `ttk.Spinbox` |'
  prefs: []
  type: TYPE_TB
- en: '| `Date` | `ttk.Entry` |'
  prefs: []
  type: TYPE_TB
- en: '| `Fault` | `ttk.Checkbutton` |'
  prefs: []
  type: TYPE_TB
- en: '| `Fruit` | `ttk.Spinbox` |'
  prefs: []
  type: TYPE_TB
- en: '| `Humidity` | `ttk.Spinbox` |'
  prefs: []
  type: TYPE_TB
- en: '| `Lab` | `ttk.Combobox` |'
  prefs: []
  type: TYPE_TB
- en: '| `Light` | `ttk.Spinbox` |'
  prefs: []
  type: TYPE_TB
- en: '| `Max height` | `ttk.Spinbox` |'
  prefs: []
  type: TYPE_TB
- en: '| `Median height` | `ttk.Spinbox` |'
  prefs: []
  type: TYPE_TB
- en: '| `Min height` | `ttk.Spinbox` |'
  prefs: []
  type: TYPE_TB
- en: '| `Notes` | `Tkinter.Text` |'
  prefs: []
  type: TYPE_TB
- en: '| `Plants` | `ttk.Spinbox` |'
  prefs: []
  type: TYPE_TB
- en: '| `Plot` | `ttk.Combobox` |'
  prefs: []
  type: TYPE_TB
- en: '| `Seed Sample` | `ttk.Entry` |'
  prefs: []
  type: TYPE_TB
- en: '| `Technician` | `ttk.Entry` |'
  prefs: []
  type: TYPE_TB
- en: '| `Temperature` | `ttk.Spinbox` |'
  prefs: []
  type: TYPE_TB
- en: '| `Time` | `ttk.Combobox` |'
  prefs: []
  type: TYPE_TB
- en: Grouping our fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Humans tend to get confused when staring at a huge wall of inputs in no particular
    order. You can do your users a big favor by breaking up the input form into sets
    of related fields. Of course, that assumes that your data has related sets of
    fields, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'After looking over your fields, you identify the following related groups:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Date`, `Lab`, `Plot`, `Seed Sample`, `Technician`, and `Time` fields are
    identifying data or metadata about the record itself. You could group these together
    under a heading like `Record information`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Blossoms`, `Fruit`, three `Height` fields, and `Plants` fields are all
    measurements that have to do with the plants in the `Plot` field. You could group
    these together as `Plant data`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Humidity`, `Light`, `Temperature`, and `Equipment` `Fault` fields, are
    all information from the environmental sensor. You could group these as `Environmental
    data`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Notes` field could be related to anything, so it's in a category of its
    own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To group the preceding fields in Tkinter, we could just insert labels between
    each set of fields, but it''s worth exploring the various options we have for
    grouping widgets together:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Widget** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ttk.LabelFrame` | Frame with label text and an optional border |'
  prefs: []
  type: TYPE_TB
- en: '| `ttk.NoteBook` | Tabbed widget that allows multiple pages |'
  prefs: []
  type: TYPE_TB
- en: '| `Tkinter.PanedWindow` | Allows for multiple re-sizable frames in horizontal
    or vertical arrangement |'
  prefs: []
  type: TYPE_TB
- en: We don't want our form on multiple pages, nor will users need to resize the
    sections, but the `LabelFrame` widget sounds perfect for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we know that we have 17 inputs, which are grouped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Six fields under `Record information`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four fields under `Environmental data`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Six fields under `Plant data`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One large `Notes` field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to group the preceding inputs using `LabelFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that two of the first three sections have widgets in multiples of three.
    That suggests that we could arrange them in a grid with three items across. How
    should we order the fields within each group?
  prefs: []
  type: TYPE_NORMAL
- en: Ordering of fields seems like a trivial item, but for the user it can make a
    significant difference in usability. Users who have to jump around a form haphazardly
    to match their workflow are more likely to make mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you learned, the data is entered from paper forms filled out by the lab
    technicians. You obtained a copy of the form, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5c9481da-4be5-4b0d-ae11-c269df173e16.png)'
  prefs: []
  type: TYPE_IMG
- en: It looks like items are mostly grouped the way our records are grouped, so we'll
    use the ordering on this form to order our fields. That way, data entry clerks
    can zip right through the form without having to bounce around the screen.
  prefs: []
  type: TYPE_NORMAL
- en: When designing a new application to replace some part of an existing workflow,
    it's important to learn and respect that workflow. While we'll have to adjust
    that workflow to actually improve it, we don't want to make another part of someone's
    job harder just to make the part we're working on simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last consideration in our design is where to place field labels in relation
    to the fields. There is a good deal of debate in the UI design community over
    the best placement of labels, but the consensus is that one of the following two
    options is best:'
  prefs: []
  type: TYPE_NORMAL
- en: Labels above fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels to the left of fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might try sketching out both to see which you prefer, but for this application
    labels above fields will probably work better for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Since both fields and labels are rectangular in shape, our form will be more
    compact by stacking them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's a lot easier to make the layout work, since we don't have to find a label
    width that works for all the labels without distancing them too far from the fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The one exception is the check button field; check buttons are typically labeled
    to the right of the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a moment to make a mockup of your form, using paper and pencil, or a drawing
    program. Your form should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b492e61c-f61f-4088-882b-c2e5aec87a18.png)'
  prefs: []
  type: TYPE_IMG
- en: Laying out the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With your form designed, it''s time to consider the rest of the application''s
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: You'll need a save button to trigger storage of the entered data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, we might need to provide status information to the user; applications
    typically have a status bar that displays these kinds of messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it might be good to have a header indicating what the form is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding the following things to our sketch, we have something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/35e3cd90-956d-490f-9e44-a3ca0524ceb4.png)'
  prefs: []
  type: TYPE_IMG
- en: Looks good! This is definitely a form we can implement in Tkinter. Your final
    step is to show these designs to your users and the director for any feedback
    or approval.
  prefs: []
  type: TYPE_NORMAL
- en: Keep stakeholders involved as much as possible in your application design process.
    This reduces the possibility that you'll have to go back and redesign your application
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you worked through the first two phases of application development:
    understanding the problem and designing a solution. You learned how to develop
    an application specification by interviewing users and examining the data and
    requirements, creating an optimal form layout for your users, and learned which
    widgets are available in Tkinter for dealing with different kinds of input data.
    Most importantly, you learned that developing an application doesn''t begin with
    code, but with research and planning.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll create a basic implementation of your designs with
    Tkinter and Python. We will get familiar with the Tkinter widgets required to
    create our form, build the form, and place the form within the application. We'll
    also learn how to make our form trigger callback actions and discover how to structure
    our code to ensure efficiency and consistency.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 5. When to Use Object-oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we've covered many of the defining features of object-oriented
    programming. We now know the principles and paradigms of object-oriented design,
    and we've covered the syntax of object-oriented programming in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, we don''t know exactly how and when to utilize these principles and syntax
    in practice. In this chapter, we''ll discuss some useful applications of the knowledge
    we''ve gained, picking up some new topics along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: How to recognize objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data and behaviors, once again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping data in behavior using properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting data using behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Don't Repeat Yourself principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing repeated code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treat objects as objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This may seem obvious; you should generally give separate objects in your problem
    domain a special class in your code. We've seen examples of this in the case studies
    in previous chapters; first, we identify objects in the problem and then model
    their data and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying objects is a very important task in object-oriented analysis and
    programming. But it isn't always as easy as counting the nouns in a short paragraph,
    as we've been doing. Remember, objects are things that have both data and behavior.
    If we are working only with data, we are often better off storing it in a list,
    set, dictionary, or some other Python data structure (which we'll be covering
    thoroughly in [Chapter 6](ch06.html "Chapter 6. Python Data Structures"), *Python
    Data Structures*). On the other hand, if we are working only with behavior, but
    no stored data, a simple function is more suitable.
  prefs: []
  type: TYPE_NORMAL
- en: An object, however, has both data and behavior. Proficient Python programmers
    use built-in data structures unless (or until) there is an obvious need to define
    a class. There is no reason to add an extra level of abstraction if it doesn't
    help organize our code. On the other hand, the "obvious" need is not always self-evident.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can often start our Python programs by storing data in a few variables.
    As the program expands, we will later find that we are passing the same set of
    related variables to a set of functions. This is the time to think about grouping
    both variables and functions into a class. If we are designing a program to model
    polygons in two-dimensional space, we might start with each polygon being represented
    as a list of points. The points would be modeled as two-tuples (*x*, *y*) describing
    where that point is located. This is all data, stored in a set of nested data
    structures (specifically, a list of tuples):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we want to calculate the distance around the perimeter of the polygon,
    we simply need to sum the distances between the two points. To do this, we also
    need a function to calculate the distance between two points. Here are two such
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as object-oriented programmers, we clearly recognize that a `polygon`
    class could encapsulate the list of points (data) and the `perimeter` function
    (behavior). Further, a `point` class, such as we defined in [Chapter 2](ch02.html
    "Chapter 2. Objects in Python"), *Objects in Python*, might encapsulate the `x`
    and `y` coordinates and the `distance` method. The question is: is it valuable
    to do this?'
  prefs: []
  type: TYPE_NORMAL
- en: For the previous code, maybe yes, maybe no. With our recent experience in object-oriented
    principles, we can write an object-oriented version in record time. Let's compare
    them
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the highlighted sections, there is twice as much code here
    as there was in our earlier version, although we could argue that the `add_point`
    method is not strictly necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to understand the differences a little better, let''s compare the two
    APIs in use. Here''s how to calculate the perimeter of a square using the object-oriented
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s fairly succinct and easy to read, you might think, but let''s compare
    it to the function-based code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmm, maybe the object-oriented API isn''t so compact! That said, I''d argue
    that it was easier to *read* than the functional example: How do we know what
    the list of tuples is supposed to represent in the second version? How do we remember
    what kind of object (a list of two-tuples? That''s not intuitive!) we''re supposed
    to pass into the `perimeter` function? We would need a lot of documentation to
    explain how these functions should be used.'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the object-oriented code is relatively self-documenting, we just
    have to look at the list of methods and their parameters to know what the object
    does and how to use it. By the time we wrote all the documentation for the functional
    version, it would probably be longer than the object-oriented code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, code length is not a good indicator of code complexity. Some programmers
    get hung up on complicated "one liners" that do an incredible amount of work in
    one line of code. This can be a fun exercise, but the result is often unreadable,
    even to the original author the following day. Minimizing the amount of code can
    often make a program easier to read, but do not blindly assume this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, this trade-off isn''t necessary. We can make the object-oriented `Polygon`
    API as easy to use as the functional implementation. All we have to do is alter
    our `Polygon` class so that it can be constructed with multiple points. Let''s
    give it an initializer that accepts a list of `Point` objects. In fact, let''s
    allow it to accept tuples too, and we can construct the `Point` objects ourselves,
    if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This initializer goes through the list and ensures that any tuples are converted
    to points. If the object is not a tuple, we leave it as is, assuming that it is
    either a `Point` object already, or an unknown duck-typed object that can act
    like a `Point` object.
  prefs: []
  type: TYPE_NORMAL
- en: Still, there's no clear winner between the object-oriented and more data-oriented
    versions of this code. They both do the same thing. If we have new functions that
    accept a polygon argument, such as `area(polygon)` or `point_in_polygon(polygon,
    x, y)`, the benefits of the object-oriented code become increasingly obvious.
    Likewise, if we add other attributes to the polygon, such as `color` or `texture`,
    it makes more and more sense to encapsulate that data into a single class.
  prefs: []
  type: TYPE_NORMAL
- en: The distinction is a design decision, but in general, the more complicated a
    set of data is, the more likely it is to have multiple functions specific to that
    data, and the more useful it is to use a class with attributes and methods instead.
  prefs: []
  type: TYPE_NORMAL
- en: When making this decision, it also pays to consider how the class will be used.
    If we're only trying to calculate the perimeter of one polygon in the context
    of a much greater problem, using a function will probably be quickest to code
    and easier to use "one time only". On the other hand, if our program needs to
    manipulate numerous polygons in a wide variety of ways (calculate perimeter, area,
    intersection with other polygons, move or scale them, and so on), we have most
    certainly identified an object; one that needs to be extremely versatile.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, pay attention to the interaction between objects. Look for inheritance
    relationships; inheritance is impossible to model elegantly without classes, so
    make sure to use them. Look for the other types of relationships we discussed
    in [Chapter 1](ch01.html "Chapter 1. Object-oriented Design"), *Object-oriented
    Design*, association and composition. Composition can, technically, be modeled
    using only data structures; for example, we can have a list of dictionaries holding
    tuple values, but it is often less complicated to create a few classes of objects,
    especially if there is behavior associated with the data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't rush to use an object just because you can use an object, but *never*
    neglect to create a class when you need to use a class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding behavior to class data with properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we've been focusing on the separation of behavior and
    data. This is very important in object-oriented programming, but we're about to
    see that, in Python, the distinction can be uncannily blurry. Python is very good
    at blurring distinctions; it doesn't exactly help us to "think outside the box".
    Rather, it teaches us to stop thinking about the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the details, let''s discuss some bad object-oriented theory.
    Many object-oriented languages (Java is the most notorious) teach us to never
    access attributes directly. They insist that we write attribute access like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables are prefixed with an underscore to suggest that they are private
    (other languages would actually force them to be private). Then the get and set
    methods provide access to each variable. This class would be used in practice
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not nearly as readable as the direct access version that Python favors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So why would anyone insist upon the method-based syntax? Their reasoning is
    that someday we may want to add extra code when a value is set or retrieved. For
    example, we could decide to cache a value and return the cached value, or we might
    want to validate that the value is a suitable input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, we could decide to change the `set_name()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in Java and similar languages, if we had written our original code to
    do direct attribute access, and then later changed it to a method like the preceding
    one, we''d have a problem: anyone who had written code that accessed the attribute
    directly would now have to access the method. If they don''t change the access
    style from attribute access to a function call, their code will be broken. The
    mantra in these languages is that we should never make public members private.
    This doesn''t make much sense in Python since there isn''t any real concept of
    private members!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python gives us the `property` keyword to make methods look like attributes.
    We can therefore write our code to use direct member access, and if we unexpectedly
    need to alter the implementation to do some calculation when getting or setting
    that attribute''s value, we can do so without changing the interface. Let''s see
    how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we had started with the earlier non-method-based class, which set the `name`
    attribute directly, we could later change the code to look like the preceding
    one. We first change the `name` attribute into a (semi-) private `_name` attribute.
    Then we add two more (semi-) private methods to get and set that variable, doing
    our validation when we set it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the `property` declaration at the bottom. This is the magic.
    It creates a new attribute on the `Color` class called `name`, which now replaces
    the previous `name` attribute. It sets this attribute to be a property, which
    calls the two methods we just created whenever the property is accessed or changed.
    This new version of the `Color` class can be used exactly the same way as the
    previous version, yet it now does validation when we set the `name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, if we'd previously written code to access the `name` attribute, and then
    changed it to use our `property` object, the previous code would still work, unless
    it was sending an empty `property` value, which is the behavior we wanted to forbid
    in the first place. Success!
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that even with the `name` property, the previous code is not 100
    percent safe. People can still access the `_name` attribute directly and set it
    to an empty string if they want to. But if they access a variable we've explicitly
    marked with an underscore to suggest it is private, they're the ones that have
    to deal with the consequences, not us.
  prefs: []
  type: TYPE_NORMAL
- en: Properties in detail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think of the `property` function as returning an object that proxies any requests
    to set or access the attribute value through the methods we have specified. The
    `property` keyword is like a constructor for such an object, and that object is
    set as the public facing member for the given attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `property` constructor can actually accept two additional arguments, a
    deletion function and a docstring for the property. The `delete` function is rarely
    supplied in practice, but it can be useful for logging that a value has been deleted,
    or possibly to veto deleting if we have reason to do so. The docstring is just
    a string describing what the property does, no different from the docstrings we
    discussed in [Chapter 2](ch02.html "Chapter 2. Objects in Python"), *Objects in
    Python*. If we do not supply this parameter, the docstring will instead be copied
    from the docstring for the first argument: the getter method. Here is a silly
    example that simply states whenever any of the methods are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we actually use this class, it does indeed print out the correct strings
    when we ask it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, if we look at the help file for the `Silly` class (by issuing `help(silly)`
    at the interpreter prompt), it shows us the custom docstring for our `silly` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, everything is working as we planned. In practice, properties are
    normally only defined with the first two parameters: the getter and setter functions.
    If we want to supply a docstring for a property, we can define it on the getter
    function; the property proxy will copy it into its own docstring. The deletion
    function is often left empty because object attributes are rarely deleted. If
    a coder does try to delete a property that doesn''t have a deletion function specified,
    it will raise an exception. Therefore, if there is a legitimate reason to delete
    our property, we should supply that function.'
  prefs: []
  type: TYPE_NORMAL
- en: Decorators – another way to create properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you've never used Python decorators before, you might want to skip this section
    and come back to it after we've discussed the decorator pattern in [Chapter 10](ch10.html
    "Chapter 10. Python Design Patterns I"), *Python Design Patterns I*. However,
    you don't need to understand what's going on to use the decorator syntax to make
    property methods more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The property function can be used with the decorator syntax to turn a get function
    into a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This applies the `property` function as a decorator, and is equivalent to the
    previous `foo = property(foo)` syntax. The main difference, from a readability
    perspective, is that we get to mark the `foo` function as a property at the top
    of the method, instead of after it is defined, where it can be easily overlooked.
    It also means we don't have to create private methods with underscore prefixes
    just to define a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going one step further, we can specify a setter function for the new property
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This syntax looks pretty odd, although the intent is obvious. First, we decorate
    the `foo` method as a getter. Then, we decorate a second method with exactly the
    same name by applying the `setter` attribute of the originally decorated `foo`
    method! The `property` function returns an object; this object always comes with
    its own `setter` attribute, which can then be applied as a decorator to other
    functions. Using the same name for the get and set methods is not required, but
    it does help group the multiple methods that access one property together.
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify a deletion function with `@foo.deleter`. We cannot specify
    a docstring using `property` decorators, so we need to rely on the property copying
    the docstring from the initial getter method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our previous `Silly` class rewritten to use `property` as a decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This class operates *exactly* the same as our earlier version, including the
    help text. You can use whichever syntax you feel is more readable and elegant.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding when to use properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the property built-in clouding the division between behavior and data,
    it can be confusing to know which one to choose. The example use case we saw earlier
    is one of the most common uses of properties; we have some data on a class that
    we later want to add behavior to. There are also other factors to take into account
    when deciding to use a property.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, in Python, data, properties, and methods are all attributes on
    a class. The fact that a method is callable does not distinguish it from other
    types of attributes; indeed, we'll see in [Chapter 7](ch07.html "Chapter 7. Python
    Object-oriented Shortcuts"), *Python Object-oriented Shortcuts*, that it is possible
    to create normal objects that can be called like functions. We'll also discover
    that functions and methods are themselves normal objects.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that methods are just callable attributes, and properties are just
    customizable attributes can help us make this decision. Methods should typically
    represent actions; things that can be done to, or performed by, the object. When
    you call a method, even with only one argument, it should *do* something. Method
    names are generally verbs.
  prefs: []
  type: TYPE_NORMAL
- en: Once confirming that an attribute is not an action, we need to decide between
    standard data attributes and properties. In general, always use a standard attribute
    until you need to control access to that property in some way. In either case,
    your attribute is usually a noun. The only difference between an attribute and
    a property is that we can invoke custom actions automatically when a property
    is retrieved, set, or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a more realistic example. A common need for custom behavior is
    caching a value that is difficult to calculate or expensive to look up (requiring,
    for example, a network request or database query). The goal is to store the value
    locally to avoid repeated calls to the expensive calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this with a custom getter on the property. The first time the value
    is retrieved, we perform the lookup or calculation. Then we could locally cache
    the value as a private attribute on our object (or in dedicated caching software),
    and the next time the value is requested, we return the stored data. Here''s how
    we might cache a web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this code to see that the page is only retrieved once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I was on an awful satellite connection when I originally tested this code and
    it took 20 seconds the first time I loaded the content. The second time, I got
    the result in 2 seconds (which is really just the amount of time it took to type
    the lines into the interpreter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom getters are also useful for attributes that need to be calculated on
    the fly, based on other object attributes. For example, we might want to calculate
    the average for a list of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This very simple class inherits from `list`, so we get list-like behavior for
    free. We just add a property to the class, and presto, our list can have an average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we could have made this a method instead, but then we should call
    it `calculate_average()`, since methods represent actions. But a property called
    `average` is more suitable, both easier to type, and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Custom setters are useful for validation, as we've already seen, but they can
    also be used to proxy a value to another location. For example, we could add a
    content setter to the `WebPage` class that automatically logs into our web server
    and uploads a new page whenever the value is set.
  prefs: []
  type: TYPE_NORMAL
- en: Manager objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve been focused on objects and their attributes and methods. Now, we''ll
    take a look at designing higher-level objects: the kinds of objects that manage
    other objects. The objects that tie everything together.'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between these objects and most of the examples we've seen so
    far is that our examples tend to represent concrete ideas. Management objects
    are more like office managers; they don't do the actual "visible" work out on
    the floor, but without them, there would be no communication between departments
    and nobody would know what they are supposed to do (although, this can be true
    anyway if the organization is badly managed!). Analogously, the attributes on
    a management class tend to refer to other objects that do the "visible" work;
    the behaviors on such a class delegate to those other classes at the right time,
    and pass messages between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we''ll write a program that does a find and replace action for
    text files stored in a compressed ZIP file. We''ll need objects to represent the
    ZIP file and each individual text file (luckily, we don''t have to write these
    classes, they''re available in the Python standard library). The manager object
    will be responsible for ensuring three steps occur in order:'
  prefs: []
  type: TYPE_NORMAL
- en: Unzipping the compressed file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performing the find and replace action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Zipping up the new files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The class is initialized with the `.zip` filename and search and replace strings.
    We create a temporary directory to store the unzipped files in, so that the folder
    stays clean. The Python 3.4 `pathlib` library helps out with file and directory
    manipulation. We''ll learn more about that in [Chapter 8](ch08.html "Chapter 8. Strings
    and Serialization"), *Strings and Serialization*, but the interface should be
    pretty clear in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create an overall "manager" method for each of the three steps. This
    method delegates responsibility to other methods. Obviously, we could do all three
    steps in one method, or indeed, in one script without ever creating an object.
    There are several advantages to separating the three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readability**: The code for each step is in a self-contained unit that is
    easy to read and understand. The method names describe what the method does, and
    less additional documentation is required to understand what is going on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensibility**: If a subclass wanted to use compressed TAR files instead
    of ZIP files, it could override the `zip` and `unzip` methods without having to
    duplicate the `find_replace` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partitioning**: An external class could create an instance of this class
    and call the `find_replace` method directly on some folder without having to `zip`
    the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The delegation method is the first in the following code; the rest of the methods
    are included for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For brevity, the code for zipping and unzipping files is sparsely documented.
    Our current focus is on object-oriented design; if you are interested in the inner
    details of the `zipfile` module, refer to the documentation in the standard library,
    either online or by typing `import zipfile ; help(zipfile)` into your interactive
    interpreter. Note that this example only searches the top-level files in a ZIP
    file; if there are any folders in the unzipped content, they will not be scanned,
    nor will any files inside those folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two lines in the example allow us to run the program from the command
    line by passing the `zip` filename, search string, and replace string as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this object does not have to be created from the command line; it
    could be imported from another module (to perform batch ZIP file processing) or
    accessed as part of a GUI interface or even a higher-level management object that
    knows where to get ZIP files (for example, to retrieve them from an FTP server
    or back them up to an external disk).
  prefs: []
  type: TYPE_NORMAL
- en: As programs become more and more complex, the objects being modeled become less
    and less like physical objects. Properties are other abstract objects and methods
    are actions that change the state of those abstract objects. But at the heart
    of every object, no matter how complex, is a set of concrete properties and well-defined
    behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Removing duplicate code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often the code in management style classes such as `ZipReplace` is quite generic
    and can be applied in a variety of ways. It is possible to use either composition
    or inheritance to help keep this code in one place, thus eliminating duplicate
    code. Before we look at any examples of this, let's discuss a tiny bit of theory.
    Specifically, why is duplicate code a bad thing?
  prefs: []
  type: TYPE_NORMAL
- en: There are several reasons, but they all boil down to readability and maintainability.
    When we're writing a new piece of code that is similar to an earlier piece, the
    easiest thing to do is copy the old code and change whatever needs to be changed
    (variable names, logic, comments) to make it work in the new location. Alternatively,
    if we're writing new code that seems similar, but not identical to code elsewhere
    in the project, it is often easier to write fresh code with similar behavior,
    rather than figure out how to extract the overlapping functionality.
  prefs: []
  type: TYPE_NORMAL
- en: But as soon as someone has to read and understand the code and they come across
    duplicate blocks, they are faced with a dilemma. Code that might have made sense
    suddenly has to be understood. How is one section different from the other? How
    are they the same? Under what conditions is one section called? When do we call
    the other? You might argue that you're the only one reading your code, but if
    you don't touch that code for eight months it will be as incomprehensible to you
    as it is to a fresh coder. When we're trying to read two similar pieces of code,
    we have to understand why they're different, as well as how they're different.
    This wastes the reader's time; code should always be written to be readable first.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I once had to try to understand someone's code that had three identical copies
    of the same 300 lines of very poorly written code. I had been working with the
    code for a month before I finally comprehended that the three "identical" versions
    were actually performing slightly different tax calculations. Some of the subtle
    differences were intentional, but there were also obvious areas where someone
    had updated a calculation in one function without updating the other two. The
    number of subtle, incomprehensible bugs in the code could not be counted. I eventually
    replaced all 900 lines with an easy-to-read function of 20 lines or so.
  prefs: []
  type: TYPE_NORMAL
- en: Reading such duplicate code can be tiresome, but code maintenance is even more
    tormenting. As the preceding story suggests, keeping two similar pieces of code
    up to date can be a nightmare. We have to remember to update both sections whenever
    we update one of them, and we have to remember how the multiple sections differ
    so we can modify our changes when we are editing each of them. If we forget to
    update both sections, we will end up with extremely annoying bugs that usually
    manifest themselves as, "but I fixed that already, why is it still happening?"
  prefs: []
  type: TYPE_NORMAL
- en: The result is that people who are reading or maintaining our code have to spend
    astronomical amounts of time understanding and testing it compared to if we had
    written the code in a nonrepetitive manner in the first place. It's even more
    frustrating when we are the ones doing the maintenance; we find ourselves saying,
    "why didn't I do this right the first time?" The time we save by copy-pasting
    existing code is lost the very first time we have to maintain it. Code is both
    read and modified many more times and much more often than it is written. Comprehensible
    code should always be paramount.
  prefs: []
  type: TYPE_NORMAL
- en: This is why programmers, especially Python programmers (who tend to value elegant
    code more than average), follow what is known as the **Don't Repeat Yourself**
    (**DRY**) principle. DRY code is maintainable code. My advice to beginning programmers
    is to never use the copy and paste feature of their editor. To intermediate programmers,
    I suggest they think thrice before they hit *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: But what should we do instead of code duplication? The simplest solution is
    often to move the code into a function that accepts parameters to account for
    whatever parts are different. This isn't a terribly object-oriented solution,
    but it is frequently optimal.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have two pieces of code that unzip a ZIP file into two different
    directories, we can easily write a function that accepts a parameter for the directory
    to which it should be unzipped instead. This may make the function itself slightly
    more difficult to read, but a good function name and docstring can easily make
    up for that, and any code that invokes the function will be easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s certainly enough theory! The moral of the story is: always make the
    effort to refactor your code to be easier to read instead of writing bad code
    that is only easier to write.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's explore two ways we can reuse existing code. After writing our code to
    replace strings in a ZIP file full of text files, we are later contracted to scale
    all the images in a ZIP file to 640 x 480\. Looks like we could use a very similar
    paradigm to what we used in `ZipReplace`. The first impulse might be to save a
    copy of that file and change the `find_replace` method to `scale_image` or something
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: But, that's uncool. What if someday we want to change the `unzip` and `zip`
    methods to also open TAR files? Or maybe we want to use a guaranteed unique directory
    name for temporary files. In either case, we'd have to change it in two different
    places!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by demonstrating an inheritance-based solution to this problem.
    First we''ll modify our original `ZipReplace` class into a superclass for processing
    generic ZIP files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We changed the `filename` property to `zipname` to avoid confusion with the
    `filename` local variables inside the various methods. This helps make the code
    more readable even though it isn't actually a change in design.
  prefs: []
  type: TYPE_NORMAL
- en: We also dropped the two parameters to `__init__` (`search_string` and `replace_string`)
    that were specific to `ZipReplace`. Then we renamed the `zip_find_replace` method
    to `process_zip` and made it call an (as yet undefined) `process_files` method
    instead of `find_replace`; these name changes help demonstrate the more generalized
    nature of our new class. Notice that we have removed the `find_replace` method
    altogether; that code is specific to `ZipReplace` and has no business here.
  prefs: []
  type: TYPE_NORMAL
- en: This new `ZipProcessor` class doesn't actually define a `process_files` method;
    so if we ran it directly, it would raise an exception. Because it isn't meant
    to run directly, we removed the main call at the bottom of the original script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before we move on to our image processing app, let''s fix up our original
    `zipsearch` class to make use of this parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code is a bit shorter than the original version, since it inherits its
    ZIP processing abilities from the parent class. We first import the base class
    we just wrote and make `ZipReplace` extend that class. Then we use `super()` to
    initialize the parent class. The `find_replace` method is still here, but we renamed
    it to `process_files` so the parent class can call it from its management interface.
    Because this name isn't as descriptive as the old one, we added a docstring to
    describe what it is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that was quite a bit of work, considering that all we have now is a program
    that is functionally not different from the one we started with! But having done
    that work, it is now much easier for us to write other classes that operate on
    files in a ZIP archive, such as the (hypothetically requested) photo scaler. Further,
    if we ever want to improve or bug fix the zip functionality, we can do it for
    all classes by changing only the one `ZipProcessor` base class. Maintenance will
    be much more effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'See how simple it is now to create a photo scaling class that takes advantage
    of the `ZipProcessor` functionality. (Note: this class requires the third-party
    `pillow` library to get the `PIL` module. You can install it with `pip install
    pillow`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Look how simple this class is! All that work we did earlier paid off. All we
    do is open each file (assuming that it is an image; it will unceremoniously crash
    if a file cannot be opened), scale it, and save it back. The `ZipProcessor` class
    takes care of the zipping and unzipping without any extra work on our part.
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this case study, we'll try to delve further into the question, "when should
    I choose an object versus a built-in type?" We'll be modeling a `Document` class
    that might be used in a text editor or word processor. What objects, functions,
    or properties should it have?
  prefs: []
  type: TYPE_NORMAL
- en: We might start with a `str` for the `Document` contents, but in Python, strings
    aren't mutable (able to be changed). Once a `str` is defined, it is forever. We
    can't insert a character into it or remove one without creating a brand new string
    object. That would be leaving a lot of `str` objects taking up memory until Python's
    garbage collector sees fit to clean up behind us.
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of a string, we'll use a list of characters, which we can modify
    at will. In addition, a `Document` class would need to know the current cursor
    position within the list, and should probably also store a filename for the document.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Real text editors use a binary-tree based data structure called a `rope` to
    model their document contents. This book's title isn't "advanced data structures",
    so if you're interested in learning more about this fascinating topic, you may
    want to search the web for the rope data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what methods should it have? There are a lot of things we might want to
    do to a text document, including inserting, deleting, and selecting characters,
    cut, copy, paste, the selection, and saving or closing the document. It looks
    like there are copious amounts of both data and behavior, so it makes sense to
    put all this stuff into its own `Document` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pertinent question is: should this class be composed of a bunch of basic
    Python objects such as `str` filenames, `int` cursor positions, and a `list` of
    characters? Or should some or all of those things be specially defined objects
    in their own right? What about individual lines and characters, do they need to
    have classes of their own?'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll answer these questions as we go, but let''s start with the simplest
    possible `Document` class first and see what it can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple class allows us full control over editing a basic document. Have
    a look at it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Looks like it's working. We could connect a keyboard's letter and arrow keys
    to these methods and the document would track everything just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to connect more than just arrow keys. What if we want to
    connect the *Home* and *End* keys as well? We could add more methods to the `Document`
    class that search forward or backwards for newline characters (in Python, a newline
    character, or `\n` represents the end of one line and the beginning of a new one)
    in the string and jump to them, but if we did that for every possible movement
    action (move by words, move by sentences, *Page Up*, *Page Down*, end of line,
    beginning of whitespace, and more), the class would be huge. Maybe it would be
    better to put those methods on a separate object. So, let us turn the cursor attribute
    into an object that is aware of its position and can manipulate that position.
    We can move the forward and back methods to that class, and add a couple more
    for the *Home* and *End* keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This class takes the document as an initialization parameter so the methods
    have access to the content of the document's character list. It then provides
    simple methods for moving backwards and forwards, as before, and for moving to
    the `home` and `end` positions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code is not very safe. You can very easily move past the ending position,
    and if you try to go home on an empty file, it will crash. These examples are
    kept short to make them readable, but that doesn't mean they are defensive! You
    can improve the error checking of this code as an exercise; it might be a great
    opportunity to expand your exception handling skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Document` class itself is hardly changed, except for removing the two
    methods that were moved to the `Cursor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply updated anything that accessed the old cursor integer to use the
    new object instead. We can test that the `home` method is really moving to the
    newline character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, since we''ve been using that string `join` function a lot (to concatenate
    the characters so we can see the actual document contents), we can add a property
    to the `Document` class to give us the complete string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes our testing a little simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This framework is simple (though it might be a bit time consuming!) to extend
    to create and edit a complete plaintext document. Now, let's extend it to work
    for rich text; text that can have **bold**, underlined, or *italic* characters.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways we could process this; the first is to insert "fake" characters
    into our character list that act like instructions, such as "bold characters until
    you find a stop bold character". The second is to add information to each character
    indicating what formatting it should have. While the former method is probably
    more common, we'll implement the latter solution. To do that, we're obviously
    going to need a class for characters. This class will have an attribute representing
    the character, as well as three Boolean attributes representing whether it is
    bold, italic, or underlined.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm, wait! Is this `Character` class going to have any methods? If not, maybe
    we should use one of the many Python data structures instead; a tuple or named
    tuple would probably be sufficient. Are there any actions that we would want to
    do to, or invoke on a character?
  prefs: []
  type: TYPE_NORMAL
- en: Well, clearly, we might want to do things with characters, such as delete or
    copy them, but those are things that need to be handled at the `Document` level,
    since they are really modifying the list of characters. Are there things that
    need to be done to individual characters?
  prefs: []
  type: TYPE_NORMAL
- en: Actually, now that we're thinking about what a `Character` class actually is...
    what is it? Would it be safe to say that a `Character` class is a string? Maybe
    we should use an inheritance relationship here? Then we can take advantage of
    the numerous methods that `str` instances come with.
  prefs: []
  type: TYPE_NORMAL
- en: What sorts of methods are we talking about? There's `startswith`, `strip`, `find`,
    `lower`, and many more. Most of these methods expect to be working on strings
    that contain more than one character. In contrast, if `Character` were to subclass
    `str`, we'd probably be wise to override `__init__` to raise an exception if a
    multi-character string were supplied. Since all those methods we'd get for free
    wouldn't really apply to our `Character` class, it seems we needn't use inheritance,
    after all.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us back to our original question; should `Character` even be a
    class? There is a very important special method on the `object` class that we
    can take advantage of to represent our characters. This method, called `__str__`
    (two underscores, like `__init_`_), is used in string manipulation functions like
    `print` and the `str` constructor to convert any class to a string. The default
    implementation does some boring stuff like printing the name of the module and
    class and its address in memory. But if we override it, we can make it print whatever
    we like. For our implementation, we could make it prefix characters with special
    characters to represent whether they are bold, italic, or underlined. So, we will
    create a class to represent a character, and here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This class allows us to create characters and prefix them with a special character
    when the `str()` function is applied to them. Nothing too exciting there. We only
    have to make a few minor modifications to the `Document` and `Cursor` classes
    to work with this class. In the `Document` class, we add these two lines at the
    beginning of the `insert` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is a rather strange bit of code. Its basic purpose is to check whether
    the character being passed in is a `Character` or a `str`. If it is a string,
    it is wrapped in a `Character` class so all objects in the list are `Character`
    objects. However, it is entirely possible that someone using our code would want
    to use a class that is neither `Character` nor string, using duck typing. If the
    object has a character attribute, we assume it is a "`Character`-like" object.
    But if it does not, we assume it is a "`str`-like" object and wrap it in `Character`.
    This helps the program take advantage of duck typing as well as polymorphism;
    as long as an object has a character attribute, it can be used in the `Document`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This generic check could be very useful, for example, if we wanted to make
    a programmer''s editor with syntax highlighting: we''d need extra data on the
    character, such as what type of syntax token the character belongs to. Note that
    if we are doing a lot of this kind of comparison, it''s probably better to implement
    `Character` as an abstract base class with an appropriate `__subclasshook__`,
    as discussed in [Chapter 3](ch03.html "Chapter 3. When Objects Are Alike"), *When
    Objects Are Alike*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we need to modify the string property on `Document` to accept
    the new `Character` values. All we need to do is call `str()` on each character
    before we join it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This code uses a generator expression, which we'll discuss in [Chapter 9](ch09.html
    "Chapter 9. The Iterator Pattern"), *The Iterator Pattern*. It's a shortcut to
    perform a specific action on all the objects in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also need to check `Character.character`, instead of just the string
    character we were storing before, in the `home` and `end` functions when we''re
    looking to see whether it matches a newline character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes the formatting of characters. We can test it to see that it
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As expected, whenever we print the string, each bold character is preceded by
    a `*` character, each italic character by a `/` character, and each underlined
    character by a `_` character. All our functions seem to work, and we can modify
    characters in the list after the fact. We have a working rich text document object
    that could be plugged into a proper user interface and hooked up with a keyboard
    for input and a screen for output. Naturally, we'd want to display real bold,
    italic, and underlined characters on the screen, instead of using our `__str__`
    method, but it was sufficient for the basic testing we demanded of it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at various ways that objects, data, and methods can interact with
    each other in an object-oriented Python program. As usual, your first thoughts
    should be how you can apply these principles to your own work. Do you have any
    messy scripts lying around that could be rewritten using an object-oriented manager?
    Look through some of your old code and look for methods that are not actions.
    If the name isn't a verb, try rewriting it as a property.
  prefs: []
  type: TYPE_NORMAL
- en: Think about code you've written in any language. Does it break the DRY principle?
    Is there any duplicate code? Did you copy and paste code? Did you write two versions
    of similar pieces of code because you didn't feel like understanding the original
    code? Go back over some of your recent code now and see whether you can refactor
    the duplicate code using inheritance or composition. Try to pick a project you're
    still interested in maintaining; not code so old that you never want to touch
    it again. It helps keep your interest up when you do the improvements!
  prefs: []
  type: TYPE_NORMAL
- en: Now, look back over some of the examples we saw in this chapter. Start with
    the cached web page example that uses a property to cache the retrieved data.
    An obvious problem with this example is that the cache is never refreshed. Add
    a timeout to the property's getter, and only return the cached page if the page
    has been requested before the timeout has expired. You can use the `time` module
    (`time.time() - an_old_time` returns the number of seconds that have elapsed since
    `an_old_time`) to determine whether the cache has expired.
  prefs: []
  type: TYPE_NORMAL
- en: Now look at the inheritance-based `ZipProcessor`. It might be reasonable to
    use composition instead of inheritance here. Instead of extending the class in
    the `ZipReplace` and `ScaleZip` classes, you could pass instances of those classes
    into the `ZipProcessor` constructor and call them to do the processing part. Implement
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Which version do you find easier to use? Which is more elegant? What is easier
    to read? These are subjective questions; the answer varies for each of us. Knowing
    the answer, however, is important; if you find you prefer inheritance over composition,
    you have to pay attention that you don't overuse inheritance in your daily coding.
    If you prefer composition, make sure you don't miss opportunities to create an
    elegant inheritance-based solution.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add some error handlers to the various classes we created in the case
    study. They should ensure single characters are entered, that you don't try to
    move the cursor past the end or beginning of the file, that you don't delete a
    character that doesn't exist, and that you don't save a file without a filename.
    Try to think of as many edge cases as you can, and account for them (thinking
    about edge cases is about 90 percent of a professional programmer's job!) Consider
    different ways to handle them; should you raise an exception when the user tries
    to move past the end of the file, or just stay on the last character?
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention, in your daily coding, to the copy and paste commands. Every time
    you use them in your editor, consider whether it would be a good idea to improve
    your program's organization so that you only have one version of the code you
    are about to copy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on identifying objects, especially objects that
    are not immediately apparent; objects that manage and control. Objects should
    have both data and behavior, but properties can be used to blur the distinction
    between the two. The DRY principle is an important indicator of code quality and
    inheritance and composition can be applied to reduce code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover several of the built-in Python data structures
    and objects, focusing on their object-oriented properties and how they can be
    extended or adapted.
  prefs: []
  type: TYPE_NORMAL

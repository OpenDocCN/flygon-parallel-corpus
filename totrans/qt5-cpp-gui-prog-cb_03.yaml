- en: Chapter 3. QPainter and 2D Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing basic shapes on screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting shapes to an SVG file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinate transformation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying images on screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying image effects to graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic paint program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D Canvas in QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to render 2D graphics on screen with Qt.
    Internally, Qt uses a low-level class called `QPainter` to render its widgets
    on the main window. Qt allows us to access and use the `QPainter` class for drawing
    vector graphics, text, 2D images, and even 3D graphics. You can make use of the
    `QPainter` class to create your own custom widgets or to create programs that
    rely heavily on computer graphics rendering such as video games, photo editors,
    3D modeling tools, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing basic shapes on screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to draw simple vector shapes (line, rectangle,
    circle, and so on) and display text on the main window using the `QPainter` class.
    We will also learn how to change the drawing style of the vector shapes using
    the `QPen` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create a new **Qt Widgets Application** project:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `mainwindow.ui` and remove the menu bar, main tool bar, and status bar
    so that we get a clean, empty main window. Right-click on the bar widgets and
    select **Remove Menu Bar** from the pop-up menu:![How to do it…](img/B02820_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, open up `mainwindow.h` and add the following code to include the `QPainter`
    header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, declare the `paintEvent()` event handler below the class destructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open up `mainwindow.cpp` and define the `paintEvent()` event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will add text to the screen using the `QPainter` class inside
    the `paintEvent()` event handler. We set the text font settings before drawing
    it on the screen at the position `(20, 30)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will draw a straight line that starts from `(50, 60)` and ends at
    `(100, 100)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also easily draw a rectangle shape by calling the `drawRect()` function
    using a `QPainter` class. This time however, we also apply a background pattern
    to the shape before drawing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare a `QPen` class, set its color to `red`, and set its drawing style
    to `Qt::DashDotLine`. Then, apply the `QPen` class to `QPainter` and draw an ellipse
    shape at `(80, 200)` with a horizontal radius of `50` and a vertical radius of
    `20`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use `QPainterPath` class to define a shape before passing it over
    to the `QPainter` class for rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also draw any other shapes by using `QPainterPath`, such as an ellipse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`QPainter` can also be used to draw an image file onto the screen. In the following
    example, we load an image file called `tux.png` and draw it on the screen at position
    `(100, 150)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The final result should look something like this:![How to do it…](img/B02820_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to draw something on screen using `QPainter`, basically all you
    need to do is tell it what type of graphics it should be drawing (text, vector
    shape, image, polygon, and so on) with its position and size.
  prefs: []
  type: TYPE_NORMAL
- en: QPen determines what the outline of the graphic should look like, such as its
    color, line width, line style (solid, dashed, dotted, and so on), cap style, join
    style, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `QBrush` sets the style of the background of the graphics,
    such as the background color, pattern (solid color, gradient, dense brush, crossing
    diagonal lines, and so on) and pixmap.
  prefs: []
  type: TYPE_NORMAL
- en: The options for the graphics should be set before calling the draw function
    (`drawLine()`, `drawRect()`, `drawEllipse()`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'If your graphics do not appear on screen and you see warnings such as `QPainter::setPen:
    Painter not active` and `QPainter::setBrush: Painter not active` appearing on
    the application output window in Qt Creator, it means that the `QPainter` class
    is not currently active and your program will not trigger its paint event. To
    solve this problem, set the main window as the parent of the `QPainter` class.
    Usually, if you''re writing code in the `mainwindow.cpp` file, all you need to
    do is to put `this` in the bracket when initializing `QPainter`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`QImage` can load images from both the computer directories and from the program
    resources.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think of `QPainter` as a robot with a pen and an empty canvas. You just have
    to tell the robot what type of shape it should be drawing and its location on
    the canvas, then the robot will do its job based on your description. To make
    your life easier, the `QPainter` class also provides numerous functions such as
    `drawArc()`, `drawEllipse()`, `drawLine()`, `drawRect()`, `drawPie()`, and so
    on that allow you to easily render a predefined shape.
  prefs: []
  type: TYPE_NORMAL
- en: In Qt, all the widget classes (including the main window) have an event handler
    called `QWidget::paintEvent()`. This event handler will be triggered whenever
    the operating system thinks that the main window should re-draw its widgets. Many
    things can lead to that decision, such as the main window being scaled, a widget
    changing its state (that is, a button being pressed), or functions such as `repaint()`
    or `update()` being invoked manually in the code. Different operating system may
    behave differently when it comes to deciding whether or not to trigger the update
    event on the same set of conditions. If you're making a program that requires
    continuous and consistent graphical updates, call `repaint()` or `update()` manually
    with a timer.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting shapes to SVG files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scalable Vector Graphics** (**SVG**) is an XML-based language for describing
    two-dimensional vector graphics. Qt provides classes for saving vector shapes
    into an SVG file. This feature can be used to create a simple vector graphics
    editor similar to Adobe Illustrator and Inkscape.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we will continue using the same project file from the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s learn how to create a simple program that displays SVG graphics on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's create a menu bar by right-clicking the main window widget
    on the hierarchy window and selecting **Create Menu Bar** option from the pop-up
    menu. After that, add a **File** option to the menu bar and a **Save as SVG**
    action underneath it:![How to do it…](img/B02820_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, you will see an item called `actionSave_as_SVG` in the **Action
    Editor** window at the bottom of the Qt Creator window. Right-click on the item
    and choose **Go to slot…** from the pop-up menu. A window will now appear, which
    carries a list of slots available for the particular action. Choose the default
    signal called `triggered()` and click the **OK** button:![How to do it…](img/B02820_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have clicked the **OK** button, Qt Creator will switch over to the
    script editor. You will realize that a slot called `on_actionSave_as_SVG_triggered()`
    has been automatically added to your main window class. At the bottom of your
    `mainwindow.h`, you will see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will be called when you clicked on the **Save as SVG**
    option from the menu bar. We will write our code within this function to save
    all the vector graphics into an SVG file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we need to first of all include a class header called `QSvgGenerator`
    at the top of our source file. This header is very important as it''s required
    for generating SVG files. Then, we also need to include another class header called
    `QFileDialog`, which will be used to open the save dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add the SVG module to our project file, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new function called `paintAll()` within `mainwindow.h`, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, in `mainwindow.cpp`, move all the code from `paintEvent()` to the
    `paintAll()` function. Then, replace all the individual `QPainter` objects with
    a single, unified `QPainter` for drawing all the graphics. Also, call the `begin()`
    function before drawing anything and call the `end()` function after finishing
    drawing. The code should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have moved all the code from `paintEvent()` to `paintAll()`, we shall
    now call the `paintAll()` function inside `paintEvent()`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will write the code for exporting the graphics to an SVG file. The
    code will be written inside the slot function called `on_actionSave_as_SVG_triggered()`,
    which was generated by Qt. We start by calling the save file dialog and obtain
    the directory path with the desired file name from the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, create a `QSvgGenerator` object and save the graphics to an SVG
    file by passing the `QSvgGenerator` object to the `paintAll()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run the program now and you should be able to export the graphics
    by going to **File** | **Save as SVG**:![How to do it…](img/B02820_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, `QPainter` will use the paint engine from its parent object to draw
    the graphics assigned to it. If you don't assign any parent to `QPainter`, you
    can manually assign a paint engine to it, which is what we have done in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why we placed the code into `paintAll()` is because we want to reuse
    the same code for two different purposes: for displaying the graphics on the window
    and exporting the graphics to an SVG file. Notice the default value of the `generator`
    variable in the `paintAll()` function is set to `0`, which means no `QSvgGenerator`
    object is required to run the function unless specified. Later on, in the `paintAll()`
    function, we check whether the `generator` object exists. If it does exist, use
    it as the paint engine for the painter, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, pass the main window to the `begin()` function (since we're writing
    the code in `mainwindow.cpp`, we can directly use `this` to refer to main window's
    pointer) so that it will use the paint engine of the main window itself, which
    means the graphics will be drawn onto the surface of the main window.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, it's required to use a single `QPainter` object to save the
    graphics into the SVG file. If you use multiple `QPainter` objects, the resulting
    SVG file will contain multiple XML header definitions and thus the file will be
    deemed to be invalid by any graphics editor software out there.
  prefs: []
  type: TYPE_NORMAL
- en: '`QFileDialog::getSaveFileName()` will open up the native save file dialog for
    the user to choose the save directory and set a desired file name. Once the user
    is done with that, the full path will be returned as a string and we will be able
    to pass that information to the `QSvgGenerator` object to export the graphics.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the previous screenshot, the penguin in the SVG file has been
    cropped. This is because the canvas size of the SVG was set to follow the size
    of the main window. To help the poor penguin getting its body back, scale the
    window bigger before exporting the SVG file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scalable Vector Graphics** (**SVG**) defines the graphics in XML format.
    Since it is vector graphics, SVG graphics do not lose any quality if they are
    zoomed or resized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SVG allows three types of graphic object: vector graphics, raster graphics,
    and text. Graphical objects, including PNG and JPEG raster images, can be grouped,
    styled, transformed, and composited into previously rendered objects.'
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the full specification of SVG graphics at [https://www.w3.org/TR/SVG](https://www.w3.org/TR/SVG).
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to use coordinate transformation and a timer
    to create a real-time clock display.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create our first graphical clock display, let''s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new **Qt Widgets Application** project. Then, open up `mainwindow.ui`
    and remove the menu bar, tool bar, and status bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, open up `mainwindow.h` and include the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, declare the `paintEvent()` function, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In `mainwindow.cpp`, create three arrays to store the shapes of the hour hand,
    minute hand, and second hand, where each of the arrays contains three sets of
    coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add the following code below the arrays to create the painter and
    move it to the center of the main window. Also, we adjust the size of the painter
    so that it fits nicely in the main window, even when the window is being resized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are done with that, we will start drawing the dials by using a `for`
    loop. Each dial is rotated by an increment of 6 degrees, so 60 dials would complete
    a full circle. Also, the dial at every 5 minutes will look slightly longer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we proceed with drawing the hands of the clock. Each hand''s rotation
    is calculated according to the current time and its respective unit over 360 degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Last but not least, create a timer to refresh the graphics every second so that
    the program will work like a real clock!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run the program now and you should see something like this:![How
    to do it…](img/B02820_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each of the arrays contain three `QPoint` data, which form the shape of an elongated
    triangle. The arrays are then passed to the painter and rendered as a convex polygon
    using the `drawConvexPolygon()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Before drawing each of the clock hands, we use `painter.save()` to save the
    state of the `QPainter` object and then proceed with drawing the hand using coordinate
    transformation. Once we're done with the drawing, we restore the painter to its
    previous state by calling `painter.restore()`. This function will undo all the
    transformations before `painter.restore()` so that the next clock hand will not
    inherit the transformations of the previous one. Without using `painter.save()`
    and `painter.restore()`, we will have to manually change back the position, rotation,
    and scale before drawing the next hand.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of not using `painter.save()` and `painter.restore()` is when
    drawing the dials. Since each dial's rotation is an increment of 6 degrees from
    the previous one, we don't need to save the painter's state at all. We just have
    to call `painter.rotate(6.0)` in a loop and each dial will inherit the previous
    dial's rotation. We also use a modulus operator (`%`) to check whether the unit
    represented by the dial can be divided by 5\. If it can, then we draw it slightly
    longer.
  prefs: []
  type: TYPE_NORMAL
- en: Without using a timer to constantly call the `update()` slot, the clock will
    not function properly. This is because `paintEvent()` will not be called by Qt
    when there is no change to the state of the parent widget, which in this case
    is the main window. Therefore, we need to manually tell Qt that we need to refresh
    the graphics by calling `update()`every second.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `painter.setRenderHint(QPainter::Antialiasing)` function to enable
    anti-aliasing when rendering the clock. Without anti-aliasing, the graphics will
    look very jagged and pixelated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B02820_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `QPainter` class uses the coordinate system to determine the position and
    size of the graphics before rendering them on screen. This information can be
    altered to make the graphics appear at a different position, rotation, and size.
    This process of altering the coordinate information of a graphic is what we called
    coordinate transformation. There are several types of transformation, among them
    are translation, rotation, scaling and shearing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/B02820_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Qt uses a coordinate system that has its origin at the top-left corner, meaning
    the x values increase to the right and the y values increase downwards. This coordinate
    system might be different from the coordinate system used by the physical device,
    such as a computer screen. Qt handles this automatically by using the `QPaintDevice`
    class, which maps Qt's logical coordinates to the physical coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '`QPainter` provides four transform operations to perform different types of
    transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QPainter::translate()`: Offset the graphic''s position by a given set of units'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QPainter::rotate()`: Rotate the graphics around the origin in a clockwise
    direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QPainter::scale()`: Offset the graphic''s size by a given factor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QPainter::shear()`: Twist the graphic''s coordinate system around the origin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying images on screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt not only allows us to draw shapes and images on screen, but it also allows
    us to overlay multiple images on top of each other and combine the pixel information
    from all the layers using different types of algorithms to create very interesting
    results. In this example, we will learn how to overlay images on top of each other
    and apply different composition effects to them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a simple demo that shows the effect of different image compositions
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, set up a new **Qt Widgets Application** project and remove the menu bar,
    tool bar, and status bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add the QPainter class header to `mainwindow.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, declare the `paintEvent()` virtual function like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In `mainwindow.cpp`, we will first load several image files using the `QImage`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a `QPainter` object and use it to draw two pairs of images, where
    one image is on top of another:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run the program now and you should see something like this:![How
    to do it…](img/B02820_03_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will set the composition mode before drawing each image on screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run the program again and you will now see something like this:![How
    to do it…](img/B02820_03_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When drawing images with Qt, the sequence of calling the `drawImage()` function
    will determine which image is being rendered first and which one is rendered later.
    This will affect the depth order of the images and yield different outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we called `drawImage()` four times to draw four different
    images on screen. The first `drawImage()` renders `checker.png` and the second
    `drawImage()` renders `tux.png` (the penguin). The image that gets rendered later
    will always appear in front of the others, which is why the penguin is showing
    in front of the checker box. The same goes for the butterfly and the checker on
    the right. The reason why you can still see the checker even though the butterfly
    is rendered in front of it is because the butterfly image is not fully opaque.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s invert the render sequence and see what happens. We will try to
    render the penguin first, followed by the checker box. The same goes for the other
    pair of images on the right: the butterfly gets rendered first, followed by the
    checker box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B02820_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To apply a composition effect to the image, we'll have to set the painter's
    composition mode before drawing the image, by calling the `painter.setCompositionMode()`
    function. You can pick a desired composition mode from the auto-complete menu
    by typing `QPainter::CompositionMode`.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we applied `QPainter::CompositionMode_Difference` to
    the checker box on the left, which inverted its color. Next, we applied `QPainter::CompositionMode_Overlay`
    to the penguin which makes it blend with the checker and we're able to see both
    images overlaying each other.
  prefs: []
  type: TYPE_NORMAL
- en: On the right-hand side, we applied `QPainter::CompositionMode_Xor` to the checker,
    where if differences exist between the source and destination, colors are shown;
    otherwise, it will be rendered black. Since it's comparing differences with the
    white background, the non-transparent part of the checker becomes completely black.
    We also applied `QPainter::CompositionMode_SoftLight` to the butterfly image.
    This blends the pixels with the background with reduced contrast.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to disable the composition mode you have just set for the previous
    rendering before proceeding to the next, simply set it back to the default mode,
    which is `QPainter::CompositionMode_SourceOver`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For example, we can overlay multiple images on top of each other and use Qt's
    image composition feature to merge them together and calculate the resulting pixels
    on screen, based on the composition mode we used. This is often used in image
    editing software such as Photoshop and GIMP to composite image layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more than 30 types of composition mode available in Qt. Some of the
    most commonly used modes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clear**: The pixels in the destination are set to fully transparent, independent
    of the source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source**: The output is the source pixel. This mode is the inverse of `CompositionMode_Destination`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination**: The output is the destination pixel. This means that the blending
    has no effect. This mode is the inverse of `CompositionMode_Source`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source Over**: Often referred to as alpha blending. The alpha of the source
    is used to blend the pixel on top of the destination. This is the default mode
    used by `QPainter`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination Over**: The alpha of the destination is used to blend it on top
    of the source pixels. This mode is the inverse of `CompositionMode_SourceOver`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source In**: The output is the source, where the alpha is reduced by that
    of the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination In**: The output is the destination, where the alpha is reduced
    by that of the source. This mode is the inverse of `CompositionMode_SourceIn`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source Out**: The output is the source, where the alpha is reduced by the
    inverse of the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination Out**: The output is the destination, where the alpha is reduced
    by the inverse of the source. This mode is the inverse of `CompositionMode_SourceOut`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source Atop**: The source pixel is blended on top of the destination, with
    the alpha of the source pixel reduced by the alpha of the destination pixel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination Atop**: The destination pixel is blended on top of the source,
    with the alpha of the source pixel reduced by the alpha of the destination pixel.
    This mode is the inverse of `CompositionMode_SourceAtop`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Xor**: This is short for **Exclusive OR**, which is an advanced blending
    mode that is primarily used for image analysis. The source, whose alpha is reduced
    by the inverse of the destination alpha, is merged with the destination, whose
    alpha is reduced by the inverse of the source alpha.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows the outcome of overlaying two images with different
    composition modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/B02820_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Applying image effects to graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt provides an easy way to add image effects to any graphics drawn using the
    `QPainter` class. In this example, we will learn how to apply different images
    effects, such as drop shadow, blur, colorize, and opacity effects, to a graphic
    before displaying it on screen.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s learn how to apply image effects to text and graphics by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Qt Widgets Application** and remove the menu bar, tool bar, and
    status bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new resource file by going to **File** | **New File or Project** and
    adding all the images required by the project:![How to do it…](img/B02820_03_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, open up `mainwindow.ui` and add four labels to the window. Two of the
    labels will be text and the two others we will load with the images we have just
    added to the resource file:![How to do it…](img/B02820_03_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may already notice the font sizes are way bigger than the default size.
    That can be achieved by adding a style sheet to the label widget, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, open up `mainwindow.cpp` and include the following headers at the
    top of the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, within the constructor of the `MainWindow` class, add the following code
    to create a drop shadow effect, and apply it to one of the labels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a colorized effect and apply it to one of the images,
    in this case the butterfly. We also set the effect color to red:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''re done with that, create a blur effect and set its radius to `12`.
    Then, apply the graphics effect to the other label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, create an alpha effect and apply it to the penguin image. We set the
    opacity value to `0.2`, which means 20% opacity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run the program now and you should be able to see something like
    this:![How to do it…](img/B02820_03_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each of the graphic effects is a class of its own that inherits the `QGraphicsEffect`
    parent class. You can create your own custom effect by creating a new class that
    inherits `QGraphicsEffect` and re-implementing some of the functions in it.
  prefs: []
  type: TYPE_NORMAL
- en: Each effect has its own set of variables that are specifically created for it.
    For example, you can set the color of the colorized effect, but there is no such
    variable in the blur effect. This is because each effect is vastly different from
    the others, which is also why it needs to be a class of its own rather than using
    the same class for all the different effects.
  prefs: []
  type: TYPE_NORMAL
- en: It's only possible to add a single graphics effect to a widget at a time. If
    you add more than one effect, only the last one will be applied to the widget
    as it replaces the previous one. Other than that, be aware that if you create
    a graphics effect, say the drop shadow effect, you can't assign it to two different
    widgets as it will only get assigned to the last widget you applied it to. If
    you need to apply the same type of effect to several different widgets, create
    a few graphics effects of the same type and apply each of them to their respective
    widgets.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently Qt supports blur, drop shadow, colorize, and opacity effects. These
    effects can be used by calling the following classes: `QGraphicsBlurEffect`, `QGraphicsDropShadowEffect`,
    `QGraphicsColorizeEffect`, and `QGraphicsOpacityEffect`. All these classes are
    inherited from the `QGraphicsEffect` class. You can also create your own custom
    image effect by creating a subclass of `QGrapicsEffect` (or any other existing
    effects) and re-implementing the `draw()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: The graphics effect changes only the bounding rectangle of the source. If you
    want to increase the margin of the bounding rectangle, re-implement the virtual
    `boundingRectFor()` function, and call `updateBoundingRect()` to notify the framework
    whenever this rectangle changes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic paint program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have learned so much about the `QPainter` class and how to use it to
    display graphics on screen, I guess it's time for us to do something fun so that
    we can put our knowledge into practice.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to make a basic paint program that allows
    us to draw lines on a canvas with different brush sizes and colors. We will also
    learn how to use the `QImage` class and the mouse events in order to construct
    the paint program.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us start our fun project through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we start by creating a new **Qt Widgets Application** project and removing
    the tool bar and status bar. We will keep the menu bar this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, set up the menu bar like so:![How to do it…](img/B02820_03_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will leave the menu bar as it is for the moment and let''s proceed to `mainwindow.h`.
    First, include the following header files as it''s required for the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare the variables that we''ll be using for this project, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, declare the event callback functions, which are inherited from the `QWidget`
    class. These functions will be triggered by Qt when the respective event happens.
    We will override these functions and tell Qt what to do when these events get
    called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, go to `mainwindow.cpp` and add the following code to the class
    constructor for setting up some of the variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will construct the `mousePressEvent()` event and tell Qt what to do
    when the left mouse button is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will construct the `mouseMoveEvent()` event and tell Qt what to do
    when the mouse is moving. In this case, we want to draw the lines on the canvas
    if the left mouse button is being held:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will also construct the `mouseReleaseEvent()` event, which will
    be triggered when the mouse button is released:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''re done with that, we will proceed to the `paintEvent()` event, which
    is surprisingly simple compared to the other examples we have seen in previous
    sections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Remember we have a menu bar sitting around doing nothing? Let's right-click
    on each of the actions below the GUI editor and select **Go to slot…** in the
    pop-up menu. We want to tell Qt what to do when each of these options on the menu
    bar is selected:![How to do it…](img/B02820_03_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, select the default slot called `triggered()` and press the **OK** button.
    Qt will automatically generate a new slot function in both your `mainwindow.h`
    and `mainwindow.cpp`. Once you are done with all the actions, you should see something
    like this in your `mainwindow.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will tell Qt what to do when each of these slots is triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If we compile and run the program now, we will get a simple but usable paint
    program:![How to do it…](img/B02820_03_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we created a `QImage` widget when the program started. This
    widget acts as the canvas and it will follow the size of the window whenever the
    window gets resized.
  prefs: []
  type: TYPE_NORMAL
- en: In order to draw something on the canvas, we will need to use the mouse events
    provided by Qt. These events will tell us the position of the cursor and we will
    be able to use this information to change the pixels on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: We use a Boolean variable called `drawing` to let the program know whether it
    should start drawing when a mouse button is pressed. In this case, when the left
    mouse button is pressed, the variable `drawing` will be set to `true`. We also
    save the current cursor position to the `lastPoint` variable when the left mouse
    button is pressed, so that Qt will know where it should start drawing.
  prefs: []
  type: TYPE_NORMAL
- en: When the mouse moves, the `mouseMoveEvent()` event will be triggered by Qt.
    This is where we need to check whether the `drawing` variable is set to `true`.
    If it is, then `QPainter` can start drawing the lines onto the `QImage` widget
    based on the brush settings that we provide.
  prefs: []
  type: TYPE_NORMAL
- en: The brush settings consist of the brush color as well as the brush size. These
    settings are being saved as variables and can be altered by selecting a different
    setting from the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: Please remember to call the `update()` function when the user is drawing on
    the canvas. Otherwise, the canvas will remain empty even though we have changed
    the pixel information of the canvas. We also have to call the `update()` function
    when we select **File** | **Clear** from the menu bar to reset our canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use `QImage::save()` to save the image file, which is very
    easy and straightforward. We use the file dialog to let the user decide where
    to save the image and its desired file name. Then, we pass the information to
    `QImage` and it will do the rest by itself. If we don't specify the file format
    to the `QImage::save()` function, `QImage` will try to figure it out by looking
    at the extension of the desired file name.
  prefs: []
  type: TYPE_NORMAL
- en: 2D canvas in QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all the previous examples of this chapter, we have discussed the methods
    and techniques used to render 2D graphics with Qt's C++ API. However, we have
    yet to learn how to achieve similar results using the powerful QML script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we''ll be do something quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the first step we should do is to create a new project by going to
    **File** | **New File or Project** and selecting **Qt Quick Application** as the
    project template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you are done creating the new project, open up `qml.qrc` from the `Resource`
    folder in the project pane by right-clicking on it and selecting **Open in Editor**.
    Then, remove `MainForm.ui.qml` from your project's resources, as we don't need
    it for this project:![How to do it…](img/B02820_03_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open up `main.qml`, which is listed under `qml.rc` in the project pane.
    After that, remove the entire section that references `MainForm`. Now what is
    left is only the `Window` object in `main.qml`. After that, set an ID for the
    window and adjust its width and height to higher values, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a `Canvas` object under `myWindow` and call it `myCanvas`. After
    that, we make its width and height the same as `myWindow`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define what will happen when the `onPaint` event is triggered; in
    this case, we will draw a cross on the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we add the following code to draw a tick besides the cross:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, draw a triangle shape by adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, draw a half circle and a full circle with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we draw a 2D image from a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the preceding code alone will not successfully render an image on
    screen because you must also load the image file beforehand. Add the following
    code within the `Canvas` object to ask QML to load the image file when the program
    is started, then call the `requestPaint()` signal when the image is loaded so
    that the `onPaint()` event slot will be triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the program now and you should get the following result:![How
    to do it…](img/B02820_03_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

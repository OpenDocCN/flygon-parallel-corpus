["```py\ndef a():\n    print('a() was called.')\n    b()\n    print('a() is returning.')\n\ndef b():\n    print('b() was called.')\n    c()\n    print('b() is returning.')\n\ndef c():\n    print('c() was called.')\n    print('c() is returning.')\n\na()\n```", "```py\n<script type=\"text/javascript\">\nfunction a() {\n    document.write(\"a() was called.<br />\");\n    b();\n    document.write(\"a() is returning.<br />\");\n}\n\nfunction b() {\n    document.write(\"b() was called.<br />\");\n    c();\n    document.write(\"b() is returning.<br />\");\n}\n\nfunction c() {\n    document.write(\"c() was called.<br />\");\n    document.write(\"c() is returning.<br />\");\n}\n\na();\n</script>\n```", "```py\na() was called.\nb() was called.\nc() was called.\nc() is returning.\nb() is returning.\na() is returning.\n```", "```py\ncardStack = \u2776 []\n\u2777 cardStack.append('5 of diamonds')\nprint(','.join(cardStack))\ncardStack.append('3 of clubs')\nprint(','.join(cardStack))\ncardStack.append('ace of hearts')\nprint(','.join(cardStack))\n\u2778 cardStack.pop()\nprint(','.join(cardStack))\n```", "```py\n<script type=\"text/javascript\">\nlet cardStack = \u2776 [];\n\u2777 cardStack.push(\"5 of diamonds\");\ndocument.write(cardStack + \"<br />\");\ncardStack.push(\"3 of clubs\");\ndocument.write(cardStack + \"<br />\");\ncardStack.push(\"ace of hearts\");\ndocument.write(cardStack + \"<br />\");\n\u2778 cardStack.pop()\ndocument.write(cardStack + \"<br />\");\n</script>\n```", "```py\n5 of diamonds\n5 of diamonds,3 of clubs\n5 of diamonds,3 of clubs,ace of hearts\n5 of diamonds,3 of clubs\n```", "```py\ndef a():\n  \u2776 spam = 'Ant'\n  \u2777 print('spam is ' + spam)\n  \u2778 b()\n    print('spam is ' + spam)\n\ndef b():\n  \u2779 spam = 'Bobcat'\n    print('spam is ' + spam)\n  \u277a c()\n    print('spam is ' + spam)\n\ndef c():\n  \u277b spam = 'Coyote'\n    print('spam is ' + spam)\n\n\u277c a()\n```", "```py\n<script type=\"text/javascript\">\nfunction a() {\n  \u2776 let spam = \"Ant\";\n  \u2777 document.write(\"spam is \" + spam + \"<br />\");\n  \u2778 b();\n    document.write(\"spam is \" + spam + \"<br />\");\n}\n\nfunction b() {\n  \u2779 let spam = \"Bobcat\";\n    document.write(\"spam is \" + spam + \"<br />\");\n  \u277a c();\n document.write(\"spam is \" + spam + \"<br />\");\n}\n\nfunction c() {\n  \u277b let spam = \"Coyote\";\n    document.write(\"spam is \" + spam + \"<br />\");\n}\n\n\u277c a();\n</script>\n```", "```py\nspam is Ant\nspam is Bobcat\nspam is Coyote\nspam is Bobcat\nspam is Ant\n```", "```py\ndef shortest():\n    shortest()\n\nshortest()\n```", "```py\n<script type=\"text/javascript\">\nfunction shortest() {\n    shortest();\n}\n\nshortest();\n</script>\n```", "```py\nTraceback (most recent call last):\n  File \"shortest.py\", line 4, in <module>\n    shortest()\n  File \"shortest.py\", line 2, in shortest\n    shortest()\n  File \"shortest.py\", line 2, in shortest\n    shortest()\n  File \"shortest.py\", line 2, in shortest\n    shortest()\n  [Previous line repeated 996 more times]\nRecursionError: maximum recursion depth exceeded\n```", "```py\nUncaught RangeError: Maximum call stack size exceeded\n    at shortest (shortest.html:2)\n    at shortest (shortest.html:3)\n    at shortest (shortest.html:3)\n    at shortest (shortest.html:3)\n    at shortest (shortest.html:3)\n    at shortest (shortest.html:3)\n    at shortest (shortest.html:3)\n    at shortest (shortest.html:3)\n    at shortest (shortest.html:3)\n    at shortest (shortest.html:3)\n```", "```py\ndef shortestWithBaseCase(makeRecursiveCall):\n    print('shortestWithBaseCase(%s) called.' % makeRecursiveCall)\n    if not makeRecursiveCall:\n        # BASE CASE\n        print('Returning from base case.')\n      \u2776 return\n    else:\n        # RECURSIVE CASE\n      \u2777 shortestWithBaseCase(False)\n        print('Returning from recursive case.')\n        return\n\nprint('Calling shortestWithBaseCase(False):')\n\u2778 shortestWithBaseCase(False)\nprint()\nprint('Calling shortestWithBaseCase(True):')\n\u2779 shortestWithBaseCase(True)\n```", "```py\n<script type=\"text/javascript\">\nfunction shortestWithBaseCase(makeRecursiveCall) {\n    document.write(\"shortestWithBaseCase(\" + makeRecursiveCall + \n     \") called.<br />\");\n    if  (makeRecursiveCall === false) {\n        // BASE CASE\n        document.write(\"Returning from base case.<br />\");\n      \u2776 return;\n } else {\n        // RECURSIVE CASE\n      \u2777 shortestWithBaseCase(false);\n        document.write(\"Returning from recursive case.<br />\");\n        return;\n    }\n}\n\ndocument.write(\"Calling shortestWithBaseCase(false):<br />\");\n\u2778 shortestWithBaseCase(false);\ndocument.write(\"<br />\");\ndocument.write(\"Calling shortestWithBaseCase(true):<br />\");\n\u2779 shortestWithBaseCase(true);\n</script>\n```", "```py\nCalling shortestWithBaseCase(False):\nshortestWithBaseCase(False) called.\nReturning from base case.\n\nCalling shortestWithBaseCase(True):\nshortestWithBaseCase(True) called.\nshortestWithBaseCase(False) called.\nReturning from base case.\nReturning from recursive case.\n```", "```py\ndef countDownAndUp(number):\n  \u2776 print(number)\n    if number == 0:\n        # BASE CASE\n      \u2777 print('Reached the base case.')\n        return\n    else:\n        # RECURSIVE CASE\n      \u2778 countDownAndUp(number - 1)\n      \u2779 print(number, 'returning')\n        return\n\n\u277a countDownAndUp(3)\n```", "```py\n<script type=\"text/javascript\">\nfunction countDownAndUp(number) {\n  \u2776 document.write(number + \"<br />\");\n    if (number === 0) {\n        // BASE CASE\n      \u2777 document.write(\"Reached the base case.<br />\");\n        return;\n    } else {\n        // RECURSIVE CASE\n      \u2778 countDownAndUp(number - 1);\n      \u2779 document.write(number + \" returning<br />\");\n        return;\n    }\n}\n\n\u277a countDownAndUp(3);\n</script>\n```", "```py\n3\n2\n1\n0\nReached the base case.\n1 returning\n2 returning\n3 returning\n```", "```py\ndef factorial(number):\n    product = 1\n    for i in range(1, number + 1):\n        product = product * i\n    return product\nprint(factorial(5))\n```", "```py\n<script type=\"text/javascript\">\nfunction factorial(number) {\n    let product = 1;\n    for (let i = 1; i <= number; i++) {\n        product = product * i;\n    }\n    return product;\n}\ndocument.write(factorial(5));\n</script>\n```", "```py\n120\n```", "```py\ndef factorial(number):\n    if number == 1:\n        # BASE CASE\n        return 1\n    else:\n        # RECURSIVE CASE\n      \u2776 return number * factorial(number - 1)\nprint(factorial(5))\n```", "```py\n<script type=\"text/javascript\">\nfunction factorial(number) {\n    if (number == 1) {\n        // BASE CASE\n        return 1;\n } else {\n        // RECURSIVE CASE\n      \u2776 return number * factorial(number - 1);\n    }\n}\ndocument.write(factorial(5));\n</script>\n```", "```py\n120\n```", "```py\ndef fibonacci(nthNumber):\n  \u2776 a, b = 1, 1\n    print('a = %s, b = %s' % (a, b))\n    for i in range(1, nthNumber):\n      \u2777 a, b = b, a + b # Get the next Fibonacci number.\n        print('a = %s, b = %s' % (a, b))\n    return a\n\nprint(fibonacci(10))\n```", "```py\n<script type=\"text/javascript\">\nfunction fibonacci(nthNumber) {\n  \u2776 let a = 1, b = 1;\n    let nextNum;\n    document.write('a = ' + a + ', b = ' + b + '<br />');\n    for (let i = 1; i < nthNumber; i++) {\n      \u2777 nextNum = a + b; // Get the next Fibonacci number.\n        a = b;\n        b = nextNum;\n document.write('a = ' + a + ', b = ' + b + '<br />');\n    }\n    return a;\n};\n\ndocument.write(fibonacci(10));\n</script>\n```", "```py\na = 1, b = 1\na = 1, b = 2\na = 2, b = 3\n`--snip--`\na = 34, b = 55\n55\n```", "```py\ndef fibonacci(nthNumber):\n    print('fibonacci(%s) called.' % (nthNumber))\n    if nthNumber == 1 or nthNumber == 2: \u2776\n        # BASE CASE\n        print('Call to fibonacci(%s) returning 1.' % (nthNumber))\n        return 1\n    else:\n        # RECURSIVE CASE\n        print('Calling fibonacci(%s) and fibonacci(%s).' % (nthNumber - 1, nthNumber - 2))\n        result = fibonacci(nthNumber - 1) + fibonacci(nthNumber - 2)\n        print('Call to fibonacci(%s) returning %s.' % (nthNumber, result))\n        return result\n\nprint(fibonacci(10))\n```", "```py\n<script type=\"text/javascript\">\nfunction fibonacci(nthNumber) {\n    document.write('fibonacci(' + nthNumber + ') called.<br />');\n    if (nthNumber === 1 || nthNumber === 2) { \u2776\n        // BASE CASE\n        document.write('Call to fibonacci(' + nthNumber + ') returning 1.<br />');\n        return 1;\n    }\n    else {\n        // RECURSIVE CASE\n        document.write('Calling fibonacci(' + (nthNumber - 1) + ') and fibonacci(' + (nthNumber - 2) + ').<br />');\n        let result = fibonacci(nthNumber - 1) + fibonacci(nthNumber - 2);\n        document.write('Call to fibonacci(' + nthNumber + ') returning ' + result + '.<br />');\n        return result;\n    }\n}\n\ndocument.write(fibonacci(10) + '<br />');\n</script>\n```", "```py\nfibonacci(10) called.\nCalling fibonacci(9) and fibonacci(8).\nfibonacci(9) called.\nCalling fibonacci(8) and fibonacci(7).\nfibonacci(8) called.\nCalling fibonacci(7) and fibonacci(6).\nfibonacci(7) called.\n`--snip--`\nCall to fibonacci(6) returning 8.\nCall to fibonacci(8) returning 21.\nCall to fibonacci(10) returning 55.\n55\n```", "```py\ncallStack = [] # The explicit call stack, which holds \"frame objects\". \u2776\ncallStack.append({'returnAddr': 'start', 'number': 5}) # \"Call\" the \"factorial() function\". \u2777\nreturnValue = None\n\nwhile len(callStack) > 0:\n    # The body of the \"factorial() function\":\n\n    number = callStack[-1]['number'] # Set number parameter.\n    returnAddr = callStack[-1]['returnAddr']\n\n    if returnAddr == 'start':\n        if number == 1:\n            # BASE CASE\n            returnValue = 1\n            callStack.pop() # \"Return\" from \"function call\". \u2778\n            continue\n        else:\n            # RECURSIVE CASE\n            callStack[-1]['returnAddr'] = 'after recursive call'\n            # \"Call\" the \"factorial() function\":\n            callStack.append({'returnAddr': 'start', 'number': number - 1}) \u2779\n            continue\n    elif returnAddr == 'after recursive call':\n        returnValue = number * returnValue\n        callStack.pop() # \"Return from function call\". \u277a\n        continue\n\nprint(returnValue)\n```", "```py\n<script type=\"text/javascript\">\nlet callStack = []; // The explicit call stack, which holds \"frame objects\". \u2776\ncallStack.push({\"returnAddr\": \"start\", \"number\": 5}); // \"Call\" the \"factorial() function\". \u2777\nlet returnValue;\n\nwhile (callStack.length > 0) {\n// The body of the \"factorial() function\":\n    let number = callStack[callStack.length - 1][\"number\"]; // Set number parameter.\n    let returnAddr = callStack[callStack.length - 1][\"returnAddr\"];\n\n    if (returnAddr == \"start\") {\n        if (number === 1) {\n            // BASE CASE\n            returnValue = 1;\n            callStack.pop(); // \"Return\" from \"function call\". \u2778\n            continue;\n        } else {\n            // RECURSIVE CASE\n callStack[callStack.length - 1][\"returnAddr\"] = \"after recursive call\";\n            // \"Call\" the \"factorial() function\":\n            callStack.push({\"returnAddr\": \"start\", \"number\": number - 1}); \u2779\n            continue;\n        }\n    } else if (returnAddr == \"after recursive call\") {\n        returnValue = number * returnValue;\n        callStack.pop(); // \"Return from function call\". \u277a\n        continue;\n    }\n}\n\ndocument.write(returnValue + \"<br />\");\n</script> \n```", "```py\nprint('Code in a loop:')\ni = 0\nwhile i < 5:\n    print(i, 'Hello, world!')\n    i = i + 1\n\nprint('Code in a function:')\ndef hello(i=0):\n    print(i, 'Hello, world!')\n    i = i + 1\n    if i < 5:\n        hello(i) # RECURSIVE CASE\n else:\n        return # BASE CASE\nhello()\n```", "```py\n<script type=\"text/javascript\">\ndocument.write(\"Code in a loop:<br />\");\nlet i = 0;\nwhile (i < 5) {\n    document.write(i + \" Hello, world!<br />\");\n    i = i + 1;\n}\n\ndocument.write(\"Code in a function:<br />\");\nfunction hello(i) {\n    if (i === undefined) {\n        i = 0; // i defaults to 0 if unspecified.\n    }\n\n    document.write(i + \" Hello, world!<br />\");\n    i = i + 1;\n    if (i < 5) {\n        hello(i); // RECURSIVE CASE\n    }\n    else {\n        return; // BASE CASE\n    }\n}\nhello();\n</script>\n```", "```py\nCode in a loop:\n0 Hello, world!\n1 Hello, world!\n2 Hello, world!\n3 Hello, world!\n4 Hello, world!\nCode in a function:\n0 Hello, world!\n1 Hello, world!\n2 Hello, world!\n3 Hello, world!\n4 Hello, world!\n```", "```py\ndef findSubstringIterative(needle, haystack):\n    i = 0\n    while i < len(haystack):\n        if haystack[i:i + len(needle)] == needle:\n            return i # Needle found.\n        i = i + 1\n    return -1 # Needle not found.\n\ndef findSubstringRecursive(needle, haystack, i=0):\n    if i >= len(haystack):\n        return -1 # BASE CASE (Needle not found.)\n\n    if haystack[i:i + len(needle)] == needle:\n        return i # BASE CASE (Needle found.)\n    else:\n        # RECURSIVE CASE\n        return findSubstringRecursive(needle, haystack, i + 1)\n\nprint(findSubstringIterative('cat', 'My cat Zophie'))\nprint(findSubstringRecursive('cat', 'My cat Zophie'))\n```", "```py\n<script type=\"text/javascript\">\nfunction findSubstringIterative(needle, haystack) {\n    let i = 0;\n    while (i < haystack.length) {\n        if (haystack.substring(i, i + needle.length) == needle) {\n            return i; // Needle found.\n        }\n        i = i + 1\n    }\n    return -1; // Needle not found.\n}\n\nfunction findSubstringRecursive(needle, haystack, i) {\n    if (i === undefined) {\n        i = 0;\n    }\n\n    if (i >= haystack.length) {\n        return -1; // # BASE CASE (Needle not found.)\n    }\n\n    if (haystack.substring(i, i + needle.length) == needle) {\n        return i; // # BASE CASE (Needle found.)\n    } else {\n        // RECURSIVE CASE\n        return findSubstringRecursive(needle, haystack, i + 1);\n    }\n}\n\ndocument.write(findSubstringIterative(\"cat\", \"My cat Zophie\") + \"<br />\");\ndocument.write(findSubstringRecursive(\"cat\", \"My cat Zophie\") + \"<br />\");\n</script>\n```", "```py\n3\n3\n```", "```py\ndef exponentByIteration(a, n):\n    result = 1\n    for i in range(n):\n        result *= a\n    return result\n\nprint(exponentByIteration(3, 6))\nprint(exponentByIteration(10, 3))\nprint(exponentByIteration(17, 10))\n```", "```py\n<script type=\"text/javascript\">\nfunction exponentByIteration(a, n) {\n    let result = 1;\n    for (let i = 0; i < n; i++) {\n result *= a;\n    }\n    return result;\n}\n\ndocument.write(exponentByIteration(3, 6) + \"<br />\");\ndocument.write(exponentByIteration(10, 3) + \"<br />\");\ndocument.write(exponentByIteration(17, 10) + \"<br />\");\n</script>\n```", "```py\n729\n1000\n2015993900449\n```", "```py\ndef exponentByRecursion(a, n):\n    if n == 1:\n        # BASE CASE\n        return a\n    elif n % 2 == 0:\n        # RECURSIVE CASE (When n is even.)\n        result = exponentByRecursion(a, n // 2)\n        return result * result\n    elif n % 2 == 1:\n        # RECURSIVE CASE (When n is odd.)\n        result = exponentByRecursion(a, n // 2)\n        return result * result * a\n\nprint(exponentByRecursion(3, 6))\nprint(exponentByRecursion(10, 3))\nprint(exponentByRecursion(17, 10))\n```", "```py\n<script type=\"text/javascript\">\nfunction exponentByRecursion(a, n) {\n    if (n === 1) {\n        // BASE CASE\n        return a;\n    } else if (n % 2 === 0) {\n        // RECURSIVE CASE (When n is even.)\n        result = exponentByRecursion(a, n / 2);\n        return result * result;\n    } else if (n % 2 === 1) {\n        // RECURSIVE CASE (When n is odd.)\n        result = exponentByRecursion(a, Math.floor(n / 2));\n        return result * result * a;\n    }\n}\n\ndocument.write(exponentByRecursion(3, 6));\ndocument.write(exponentByRecursion(10, 3));\ndocument.write(exponentByRecursion(17, 10));\n</script>\n```", "```py\n729\n1000\n2015993900449\n```", "```py\ndef exponentWithPowerRule(a, n):\n    # Step 1: Determine the operations to be performed.\n    opStack = []\n    while n > 1:\n        if n % 2 == 0:\n            # n is even.\n            opStack.append('square')\n            n = n // 2\n        elif n % 2 == 1:\n            # n is odd.\n            n -= 1\n            opStack.append('multiply')\n\n    # Step 2: Perform the operations in reverse order.\n    result = a # Start result at `a`.\n    while opStack:\n        op = opStack.pop()\n\n        if op == 'multiply':\n            result *= a\n        elif op == 'square':\n            result *= result\n\n    return result\n\nprint(exponentWithPowerRule(3, 6))\nprint(exponentWithPowerRule(10, 3))\nprint(exponentWithPowerRule(17, 10))\n```", "```py\n<script type=\"text/javascript\">\nfunction exponentWithPowerRule(a, n) {\n    // Step 1: Determine the operations to be performed.\n    let opStack = [];\n    while (n > 1) {\n if (n % 2 === 0) {\n            // n is even.\n            opStack.push(\"square\");\n            n = Math.floor(n / 2);\n        } else if (n % 2 === 1) {\n            // n is odd.\n            n -= 1;\n            opStack.push(\"multiply\");\n        }\n    }\n\n    // Step 2: Perform the operations in reverse order.\n    let result = a; // Start result at `a`.\n    while (opStack.length > 0) {\n        let op = opStack.pop();\n\n        if (op === \"multiply\") {\n            result = result * a;\n        } else if (op === \"square\") {\n            result = result * result;\n        }\n    }\n\n    return result;\n}\n\ndocument.write(exponentWithPowerRule(3, 6) + \"<br />\");\ndocument.write(exponentWithPowerRule(10, 3) + \"<br />\");\ndocument.write(exponentWithPowerRule(17, 10) + \"<br />\");\n</script>\n```", "```py\n729\n1000\n2015993900449\n```", "```py\ndef sum(numbers):\n    if len(numbers) == 0: # BASE CASE\n      \u2776 return 0\n    else: # RECURSIVE CASE\n      \u2777 head = numbers[0]\n      \u2778 tail = numbers[1:]\n      \u2779 return head + sum(tail)\n\nnums = [1, 2, 3, 4, 5]\nprint('The sum of', nums, 'is', sum(nums))\nnums = [5, 2, 4, 8]\nprint('The sum of', nums, 'is', sum(nums))\nnums = [1, 10, 100, 1000]\nprint('The sum of', nums, 'is', sum(nums))\n```", "```py\n<script type=\"text/javascript\">\nfunction sum(numbers) {\n    if (numbers.length === 0) { // BASE CASE\n      \u2776 return 0;\n    } else { // RECURSIVE CASE\n      \u2777 let head = numbers[0];\n      \u2778 let tail = numbers.slice(1, numbers.length);\n      \u2779 return head + sum(tail);\n    }\n}\n\nlet nums = [1, 2, 3, 4, 5];\ndocument.write('The sum of ' + nums + ' is ' + sum(nums) + \"<br />\");\nnums = [5, 2, 4, 8];\ndocument.write('The sum of ' + nums + ' is ' + sum(nums) + \"<br />\");\nnums = [1, 10, 100, 1000];\ndocument.write('The sum of ' + nums + ' is ' + sum(nums) + \"<br />\");\n</script>\n```", "```py\nThe sum of [1, 2, 3, 4, 5] is 15\nThe sum of [5, 2, 4, 8] is 19\nThe sum of [1, 10, 100, 1000] is 1111\n```", "```py\ndef rev(theString):\n    return rev(theString) # This won't magically work.\n```", "```py\ndef rev(theString):\n  \u2776 if len(theString) == 0 or len(theString) == 1:\n        # BASE CASE\n        return theString\n    else:\n        # RECURSIVE CASE\n      \u2777 head = theString[0]\n      \u2778 tail = theString[1:]\n      \u2779 return rev(tail) + head\n\nprint(rev('abcdef'))\nprint(rev('Hello, world!'))\nprint(rev(''))\nprint(rev('X'))\n```", "```py\n<script type=\"text/javascript\">\nfunction rev(theString) {\n  \u2776 if (theString.length === 0 || theString.length === 1) {\n        // BASE CASE\n        return theString;\n    } else {\n        // RECURSIVE CASE\n      \u2777 var head = theString[0];\n      \u2778 var tail = theString.substring(1, theString.length);\n \u2779 return rev(tail) + head;\n    }\n}\n\ndocument.write(rev(\"abcdef\") + \"<br />\");\ndocument.write(rev(\"Hello, world!\") + \"<br />\");\ndocument.write(rev(\"\") + \"<br />\");\ndocument.write(rev(\"X\") + \"<br />\");\n</script>\n```", "```py\nfedcba\n!dlrow ,olleH\n\nX\n```", "```py\ndef isPalindrome(theString):\n    if len(theString) == 0 or len(theString) == 1:\n        # BASE CASE\n        return True\n    else:\n        # RECURSIVE CASE\n      \u2776 head = theString[0]\n      \u2777 middle = theString[1:-1]\n      \u2778 last = theString[-1]\n      \u2779 return head == last and isPalindrome(middle)\n\ntext = 'racecar'\nprint(text + ' is a palindrome: ' + str(isPalindrome(text)))\ntext = 'amanaplanacanalpanama'\nprint(text + ' is a palindrome: ' + str(isPalindrome(text)))\ntext = 'tacocat'\nprint(text + ' is a palindrome: ' + str(isPalindrome(text)))\ntext = 'zophie'\nprint(text + ' is a palindrome: ' + str(isPalindrome(text)))\n```", "```py\n<script type=\"text/javascript\">\nfunction isPalindrome(theString) {\n    if (theString.length === 0 || theString.length === 1) {\n        // BASE CASE\n        return true;\n    } else {\n        // RECURSIVE CASE\n      \u2776 var head = theString[0];\n      \u2777 var middle = theString.substring(1, theString.length -1);\n      \u2778 var last = theString[theString.length - 1];\n      \u2779 return head === last && isPalindrome(middle);\n    }\n}\n\ntext = \"racecar\";\ndocument.write(text + \" is a palindrome: \" + isPalindrome(text) + \"<br />\");\ntext = \"amanaplanacanalpanama\";\ndocument.write(text + \" is a palindrome: \" + isPalindrome(text) + \"<br />\");\ntext = \"tacocat\";\ndocument.write(text + \" is a palindrome: \" + isPalindrome(text) + \"<br />\");\ntext = \"zophie\";\ndocument.write(text + \" is a palindrome: \" + isPalindrome(text) + \"<br />\");\n</script>\n```", "```py\nracecar is a palindrome: True\namanaplanacanalpanama is a palindrome: True\ntacocat is a palindrome: True\nzophie is a palindrome: False\n```", "```py\nimport sys\n\n# Set up towers A, B, and C. The end of the list is the top of the tower.\n  TOTAL_DISKS = 6 \u2776\n\n# Populate Tower A:\n  TOWERS = {'A': list(reversed(range(1, TOTAL_DISKS + 1))), \u2777\n          'B': [],\n          'C': []}\n\ndef printDisk(diskNum):\n    # Print a single disk of width diskNum.\n    emptySpace = ' ' * (TOTAL_DISKS - diskNum)\n    if diskNum == 0:\n        # Just draw the pole.\n        sys.stdout.write(emptySpace + '||' + emptySpace)\n    else:\n        # Draw the disk.\n        diskSpace = '@' * diskNum\n        diskNumLabel = str(diskNum).rjust(2, '_')\n        sys.stdout.write(emptySpace + diskSpace + diskNumLabel + diskSpace + emptySpace)\n\ndef printTowers():\n    # Print all three towers.\n for level in range(TOTAL_DISKS, -1, -1):\n        for tower in (TOWERS['A'], TOWERS['B'], TOWERS['C']):\n            if level >= len(tower):\n                printDisk(0)\n            else:\n                printDisk(tower[level])\n        sys.stdout.write('\\n')\n    # Print the tower labels A, B, and C.\n    emptySpace = ' ' * (TOTAL_DISKS)\n    print('%s A%s%s B%s%s C\\n' % (emptySpace, emptySpace, emptySpace, emptySpace, emptySpace))\n\ndef moveOneDisk(startTower, endTower):\n    # Move the top disk from startTower to endTower.\n    disk = TOWERS[startTower].pop()\n    TOWERS[endTower].append(disk)\n\ndef solve(numberOfDisks, startTower, endTower, tempTower):\n    # Move the top numberOfDisks disks from startTower to endTower.\n    if numberOfDisks == 1:\n        # BASE CASE\n        moveOneDisk(startTower, endTower) \u2778\n        printTowers()\n        return\n    else:\n        # RECURSIVE CASE\n        solve(numberOfDisks - 1, startTower, tempTower, endTower) \u2779\n        moveOneDisk(startTower, endTower) \u277a\n        printTowers()\n        solve(numberOfDisks - 1, tempTower, endTower, startTower) \u277b\n        return\n\n# Solve:\nprintTowers()\nsolve(TOTAL_DISKS, 'A', 'B', 'C')\n\n# Uncomment to enable interactive mode:\n#while True:\n#    printTowers()\n#    print('Enter letter of start tower and the end tower. (A, B, C) Or Q to quit.')\n#    move = input().upper()\n#    if move == 'Q':\n#        sys.exit()\n#    elif move[0] in 'ABC' and move[1] in 'ABC' and move[0] != move[1]:\n#        moveOneDisk(move[0], move[1])\n```", "```py\n<script type=\"text/javascript\">\n// Set up towers A, B, and C. The end of the array is the top of the tower.\n  var TOTAL_DISKS = 6; \u2776\n  var TOWERS = {\"A\": [], \u2777\n              \"B\": [],\n              \"C\": []};\n\n// Populate Tower A:\nfor (var i = TOTAL_DISKS; i > 0; i--) {\n    TOWERS[\"A\"].push(i);\n}\n\nfunction printDisk(diskNum) {\n    // Print a single disk of width diskNum.\n    var emptySpace = \" \".repeat(TOTAL_DISKS - diskNum);\n    if (diskNum === 0) {\n        // Just draw the pole.\n        document.write(emptySpace + \"||\" + emptySpace);\n    } else {\n        // Draw the disk.\n        var diskSpace = \"@\".repeat(diskNum);\n        var diskNumLabel = String(\"___\" + diskNum).slice(-2);\n        document.write(emptySpace + diskSpace + diskNumLabel + diskSpace + emptySpace);\n    }\n}\n\nfunction printTowers() {\n    // Print all three towers.\n    var towerLetters = \"ABC\";\n    for (var level = TOTAL_DISKS; level >= 0; level--) {\n        for (var towerLetterIndex = 0; towerLetterIndex < 3; towerLetterIndex++) {\n            var tower = TOWERS[towerLetters[towerLetterIndex]];\n            if (level >= tower.length) {\n                printDisk(0);\n            } else {\n                printDisk(tower[level]);\n            }\n        }\n        document.write(\"<br />\");\n    }\n    // Print the tower labels A, B, and C.\n    var emptySpace = \" \".repeat(TOTAL_DISKS);\n    document.write(emptySpace + \" A\" + emptySpace + emptySpace +\n\" B\" + emptySpace + emptySpace + \" C<br /><br />\");\n}\n\nfunction moveOneDisk(startTower, endTower) {\n    // Move the top disk from startTower to endTower.\n    var disk = TOWERS[startTower].pop();\n    TOWERS[endTower].push(disk);\n}\n\nfunction solve(numberOfDisks, startTower, endTower, tempTower) {\n    // Move the top numberOfDisks disks from startTower to endTower.\n    if (numberOfDisks == 1) {\n        // BASE CASE\n        moveOneDisk(startTower, endTower); \u2778\n        printTowers();\n        return;\n    } else {\n        // RECURSIVE CASE\n        solve(numberOfDisks - 1, startTower, tempTower, endTower); \u2779\n moveOneDisk(startTower, endTower); \u277a\n        printTowers();\n        solve(numberOfDisks - 1, tempTower, endTower, startTower); \u277b\n        return;\n    }\n}\n\n// Solve:\ndocument.write(\"<pre>\");\nprintTowers();\nsolve(TOTAL_DISKS, \"A\", \"B\", \"C\");\ndocument.write(\"</pre>\");\n</script>\n```", "```py\n      ||            ||            ||      \n     @_1@           ||            ||      \n    @@_2@@          ||            ||      \n   @@@_3@@@         ||            ||      \n  @@@@_4@@@@        ||            ||      \n @@@@@_5@@@@@       ||            ||      \n@@@@@@_6@@@@@@      ||            ||      \n       A             B             C\n\n      ||            ||            ||      \n      ||            ||            ||      \n    @@_2@@          ||            ||      \n   @@@_3@@@         ||            ||      \n  @@@@_4@@@@        ||            ||      \n @@@@@_5@@@@@       ||            ||      \n@@@@@@_6@@@@@@      ||           @_1@     \n       A             B             C\n--snip--\n      ||            ||            ||      \n      ||            ||            ||      \n      ||            ||            ||      \n      ||            ||            ||      \n      ||          @@_2@@          ||      \n     @_1@        @@@_3@@@         ||      \n@@@@@@_6@@@@@@  @@@@_4@@@@   @@@@@_5@@@@@ \n--snip--\n       A             B             C\n      ||            ||            ||      \n      ||           @_1@           ||      \n      ||          @@_2@@          ||      \n      ||         @@@_3@@@         ||      \n      ||        @@@@_4@@@@        ||      \n      ||       @@@@@_5@@@@@       ||      \n      ||      @@@@@@_6@@@@@@      ||      \n       A             B             C\n```", "```py\nimport sys\n\n# Create the image (make sure it's rectangular!)\n\u2776 im = [list('..########################...........'),\n      list('..#......................#...#####...'),\n      list('..#..........########....#####...#...'),\n      list('..#..........#......#............#...'),\n      list('..#..........########.........####...'),\n      list('..######......................#......'),\n      list('.......#..#####.....###########......'),\n      list('.......####...#######................')]\n\nHEIGHT = len(im)\nWIDTH = len(im[0])\n\ndef floodFill(image, x, y, newChar, oldChar=None):\n    if oldChar == None:\n        # oldChar defaults to the character at x, y.\n      \u2777 oldChar = image[y][x]\n    if oldChar == newChar or image[y][x] != oldChar:\n        # BASE CASE\n        return\n\n    image[y][x] = newChar # Change the character.\n\n    # Uncomment to view each step:\n    #printImage(image)\n\n    # Change the neighboring characters.\n    if y + 1 < HEIGHT and image[y + 1][x] == oldChar:\n        # RECURSIVE CASE\n      \u2778 floodFill(image, x, y + 1, newChar, oldChar)\n    if y - 1 >= 0 and image[y - 1][x] == oldChar:\n        # RECURSIVE CASE\n      \u2779 floodFill(image, x, y - 1, newChar, oldChar)\n    if x + 1 < WIDTH and image[y][x + 1] == oldChar:\n        # RECURSIVE CASE\n      \u277a floodFill(image, x + 1, y, newChar, oldChar)\n    if x - 1 >= 0 and image[y][x - 1] == oldChar:\n        # RECURSIVE CASE\n      \u277b floodFill(image, x - 1, y, newChar, oldChar)\n  \u277c return # BASE CASE\n\ndef printImage(image):\n    for y in range(HEIGHT):\n        # Print each row.\n        for x in range(WIDTH):\n            # Print each column.\n            sys.stdout.write(image[y][x])\n        sys.stdout.write('\\n')\n    sys.stdout.write('\\n')\n\nprintImage(im)\nfloodFill(im, 3, 3, 'o')\nprintImage(im)\n```", "```py\n<script type=\"text/javascript\">\n// Create the image (make sure it's rectangular!)\n\u2776 var im = [\"..########################...........\".split(\"\"),\n          \"..#......................#...#####...\".split(\"\"),\n          \"..#..........########....#####...#...\".split(\"\"),\n          \"..#..........#......#............#...\".split(\"\"),\n          \"..#..........########.........####...\".split(\"\"),\n          \"..######......................#......\".split(\"\"),\n          \".......#..#####.....###########......\".split(\"\"),\n          \".......####...#######................\".split(\"\")];\n\nvar HEIGHT = im.length;\nvar WIDTH = im[0].length;\n\nfunction floodFill(image, x, y, newChar, oldChar) {\n    if (oldChar === undefined) {\n        // oldChar defaults to the character at x, y.\n      \u2777 oldChar = image[y][x];\n    }\n    if ((oldChar == newChar) || (image[y][x] != oldChar)) {\n        // BASE CASE\n        return;\n    }\n\n    image[y][x] = newChar; // Change the character.\n\n    // Uncomment to view each step:\n    //printImage(image);\n\n    // Change the neighboring characters.\n    if ((y + 1 < HEIGHT) && (image[y + 1][x] == oldChar)) {\n        // RECURSIVE CASE\n      \u2778 floodFill(image, x, y + 1, newChar, oldChar);\n    }\n    if ((y - 1 >= 0) && (image[y - 1][x] == oldChar)) {\n        // RECURSIVE CASE\n      \u2779 floodFill(image, x, y - 1, newChar, oldChar);\n    }\n    if ((x + 1 < WIDTH) && (image[y][x + 1] == oldChar)) {\n        // RECURSIVE CASE\n      \u277a floodFill(image, x + 1, y, newChar, oldChar);\n    }\n    if ((x - 1 >= 0) && (image[y][x - 1] == oldChar)) {\n        // RECURSIVE CASE\n      \u277b floodFill(image, x - 1, y, newChar, oldChar);\n    }\n  \u277c return; // BASE CASE\n}\n\nfunction printImage(image) {\n    document.write(\"<pre>\");\n    for (var y = 0; y < HEIGHT; y++) {\n        // Print each row.\n        for (var x = 0; x < WIDTH; x++) {\n            // Print each column.\n            document.write(image[y][x]);\n        }\n        document.write(\"\\n\");\n    }\n    document.write(\"\\n</ pre>\");\n}\n\nprintImage(im);\nfloodFill(im, 3, 3, \"o\");\nprintImage(im);\n</script>\n```", "```py\n..########################...........\n..#......................#...#####...\n..#..........########....#####...#...\n..#..........#......#............#...\n..#..........########.........####...\n..######......................#......\n.......#..#####.....###########......\n.......####...#######................\n\n..########################...........\n..#oooooooooooooooooooooo#...#####...\n..#oooooooooo########oooo#####ooo#...\n..#oooooooooo#......#oooooooooooo#...\n..#oooooooooo########ooooooooo####...\n..######oooooooooooooooooooooo#......\n.......#oo#####ooooo###########......\n.......####...#######................\n```", "```py\ndef ackermann(m, n, indentation=None):\n    if indentation is None:\n        indentation = 0\n    print('%sackermann(%s, %s)' % (' ' * indentation, m, n))\n\n    if m == 0:\n        # BASE CASE\n        return n + 1\n    elif m > 0 and n == 0:\n        # RECURSIVE CASE\n return ackermann(m - 1, 1, indentation + 1)\n    elif m > 0 and n > 0:\n        # RECURSIVE CASE\n        return ackermann(m - 1, ackermann(m, n - 1, indentation + 1), indentation + 1)\n\nprint('Starting with m = 1, n = 1:')\nprint(ackermann(1, 1))\nprint('Starting with m = 2, n = 3:')\nprint(ackermann(2, 3))\n```", "```py\n<script type=\"text/javascript\">\nfunction ackermann(m, n, indentation) {\n    if (indentation === undefined) {\n        indentation = 0;\n    }\n    document.write(\" \".repeat(indentation) + \"ackermann(\" + m + \", \" + n + \")\\n\");\n\n    if (m === 0) {\n        // BASE CASE\n        return n + 1;\n    } else if ((m > 0) && (n === 0)) {\n        // RECURSIVE CASE\n        return ackermann(m - 1, 1, indentation + 1);\n    } else if ((m > 0) && (n > 0)) {\n        // RECURSIVE CASE\n        return ackermann(m - 1, ackermann(m, n - 1, indentation + 1), indentation + 1);\n    }\n}\n\ndocument.write(\"<pre>\");\ndocument.write(\"Starting with m = 1, n = 1:<br />\");\ndocument.write(ackermann(1, 1) + \"<br />\");\ndocument.write(\"Starting with m = 2, n = 3:<br />\");\ndocument.write(ackermann(2, 3) + \"<br />\");\ndocument.write(\"</pre>\");\n</script>\n```", "```py\nStarting with m = 1, n = 1:\nackermann(1, 1)\n ackermann(1, 0)\n  ackermann(0, 1)\n ackermann(0, 2)\n3\nStarting with m = 2, n = 3:\nackermann(2, 3)\n ackermann(2, 2)\n  ackermann(2, 1)\n   ackermann(2, 0)\n--snip--\n    ackermann(0, 6)\n   ackermann(0, 7)\n  ackermann(0, 8)\n9\n```", "```py\n    ...##########....................................\n    ...#........#....####..................##########\n    ...#........#....#..#...############...#........#\n    ...##########....#..#...#..........#...##.......#\n    .......#....#....####...#..........#....##......#\n    .......#....#....#......############.....##.....#\n    .......######....#........................##....#\n    .................####........####..........######\n    ```", "```py\nroot  = {'data': 'A', 'children': []}\nnode2 = {'data': 'B', 'children': []}\nnode3 = {'data': 'C', 'children': []}\nnode4 = {'data': 'D', 'children': []}\nnode5 = {'data': 'E', 'children': []}\nnode6 = {'data': 'F', 'children': []}\nnode7 = {'data': 'G', 'children': []}\nnode8 = {'data': 'H', 'children': []}\nroot['children'] = [node2, node3]\nnode2['children'] = [node4]\nnode3['children'] = [node5, node6]\nnode5['children'] = [node7, node8]\n```", "```py\nroot = {'data': 'A', 'children': [{'data': 'B', 'children': \n[{'data': 'D', 'children': []}]}, {'data': 'C', 'children': \n[{'data': 'E', 'children': [{'data': 'G', 'children': []}, \n{'data': 'H', 'children': []}]}, {'data': 'F', 'children': []}]}]}\n```", "```py\n>>> **root['children'][1]['data']**\n'C'\n>>> **root['children'][1]['children'][0]['data']**\n'E'\n```", "```py\nroot = {'data': 'A', 'children': [{'data': 'B', 'children': \n[{'data': 'D', 'children': []}]}, {'data': 'C', 'children': \n[{'data': 'E', 'children': [{'data': 'G', 'children': []}, \n{'data': 'H', 'children': []}]}, {'data': 'F', 'children': []}]}]}\n\ndef preorderTraverse(node):\n    print(node['data'], end=' ') # Access this node's data.\n  \u2776 if len(node['children']) > 0:\n        # RECURSIVE CASE\n        for child in node['children']:\n            preorderTraverse(child) # Traverse child nodes.\n    # BASE CASE\n  \u2777 return\n\npreorderTraverse(root)\n```", "```py\n<script type=\"text/javascript\">\nroot = {\"data\": \"A\", \"children\": [{\"data\": \"B\", \"children\": \n[{\"data\": \"D\", \"children\": []}]}, {\"data\": \"C\", \"children\": \n[{\"data\": \"E\", \"children\": [{\"data\": \"G\", \"children\": []}, \n{\"data\": \"H\", \"children\": []}]}, {\"data\": \"F\", \"children\": []}]}]};\n\nfunction preorderTraverse(node) {\n    document.write(node[\"data\"] + \" \"); // Access this node's data.\n  \u2776 if (node[\"children\"].length > 0) {\n        // RECURSIVE CASE\n        for (let i = 0; i < node[\"children\"].length; i++) {\n\n preorderTraverse(node[\"children\"][i]); // Traverse child nodes.\n        }\n    }\n    // BASE CASE\n  \u2777 return;\n}\n\npreorderTraverse(root);\n</script>\n```", "```py\nA B D C E G H F\n```", "```py\nroot = {'data': 'A', 'children': [{'data': 'B', 'children': \n[{'data': 'D', 'children': []}]}, {'data': 'C', 'children': \n[{'data': 'E', 'children': [{'data': 'G', 'children': []}, \n{'data': 'H', 'children': []}]}, {'data': 'F', 'children': []}]}]}\n\ndef postorderTraverse(node):\n    for child in node['children']:\n        # RECURSIVE CASE\n        postorderTraverse(child) # Traverse child nodes.\n    print(node['data'], end=' ') # Access this node's data.\n    # BASE CASE\n    return\n\npostorderTraverse(root)\n```", "```py\n<script type=\"text/javascript\">\nroot = {\"data\": \"A\", \"children\": [{\"data\": \"B\", \"children\": \n[{\"data\": \"D\", \"children\": []}]}, {\"data\": \"C\", \"children\": \n[{\"data\": \"E\", \"children\": [{\"data\": \"G\", \"children\": []}, \n{\"data\": \"H\", \"children\": []}]}, {\"data\": \"F\", \"children\": []}]}]};\n\nfunction postorderTraverse(node) {\n    for (let i = 0; i < node[\"children\"].length; i++) {\n        // RECURSIVE CASE\n        postorderTraverse(node[\"children\"][i]); // Traverse child nodes.\n    }\n    document.write(node[\"data\"] + \" \"); // Access this node's data.\n    // BASE CASE\n    return;\n}\n\npostorderTraverse(root);\n</script>\n```", "```py\nD B G H E F C A\n```", "```py\nroot = {'data': 'A', 'children': [{'data': 'B', 'children': \n[{'data': 'D', 'children': []}]}, {'data': 'C', 'children': \n[{'data': 'E', 'children': [{'data': 'G', 'children': []}, \n{'data': 'H', 'children': []}]}, {'data': 'F', 'children': []}]}]}\n\ndef inorderTraverse(node):\n    if len(node['children']) >= 1:\n        # RECURSIVE CASE\n inorderTraverse(node['children'][0]) # Traverse the left child.\n    print(node['data'], end=' ') # Access this node's data.\n    if len(node['children']) >= 2:\n        # RECURSIVE CASE\n        inorderTraverse(node['children'][1]) # Traverse the right child.\n    # BASE CASE\n    return\n\ninorderTraverse(root)\n```", "```py\n<script type=\"text/javascript\">\nroot = {\"data\": \"A\", \"children\": [{\"data\": \"B\", \"children\": \n[{\"data\": \"D\", \"children\": []}]}, {\"data\": \"C\", \"children\": \n[{\"data\": \"E\", \"children\": [{\"data\": \"G\", \"children\": []}, \n{\"data\": \"H\", \"children\": []}]}, {\"data\": \"F\", \"children\": []}]}]};\n\nfunction inorderTraverse(node) {\n    if (node[\"children\"].length >= 1) {\n        // RECURSIVE CASE\n        inorderTraverse(node[\"children\"][0]); // Traverse the left child.\n    }\n    document.write(node[\"data\"] + \" \"); // Access this node's data.\n    if (node[\"children\"].length >= 2) {\n        // RECURSIVE CASE\n        inorderTraverse(node[\"children\"][1]); // Traverse the right child.\n    }\n    // BASE CASE\n    return;\n}\n\ninorderTraverse(root);\n</script>\n```", "```py\nD B A G E H C F\n```", "```py\nroot = {'name': 'Alice', 'children': [{'name': 'Bob', 'children': \n[{'name': 'Darya', 'children': []}]}, {'name': 'Caroline', \n'children': [{'name': 'Eve', 'children': [{'name': 'Gonzalo', \n'children': []}, {'name': 'Hadassah', 'children': []}]}, {'name': 'Fred', 'children': []}]}]}\n\ndef find8LetterName(node):\n    print(' Visiting node ' + node['name'] + '...')\n\n    # Preorder depth-first search:\n    print('Checking if ' + node['name'] + ' is 8 letters...')\n  \u2776 if len(node['name']) == 8: return node['name'] # BASE CASE\n\n    if len(node['children']) > 0:\n        # RECURSIVE CASE\n        for child in node['children']:\n            returnValue = find8LetterName(child)\n            if returnValue != None:\n                return returnValue\n\n # Postorder depth-first search:\n    #print('Checking if ' + node['name'] + ' is 8 letters...')\n  \u2777 #if len(node['name']) == 8: return node['name'] # BASE CASE\n\n    # Value was not found or there are no children.\n    return None # BASE CASE\n\nprint('Found an 8-letter name: ' + str(find8LetterName(root)))\n```", "```py\n<script type=\"text/javascript\">\nroot = {'name': 'Alice', 'children': [{'name': 'Bob', 'children': \n[{'name': 'Darya', 'children': []}]}, {'name': 'Caroline', \n'children': [{'name': 'Eve', 'children': [{'name': 'Gonzalo', \n'children': []}, {'name': 'Hadassah', 'children': []}]}, {'name': 'Fred', 'children': []}]}]};\n\nfunction find8LetterName(node, value) {\n    document.write(\"Visiting node \" + node.name + \"...<br />\");\n\n    // Preorder depth-first search:\n    document.write(\"Checking if \" + node.name + \" is 8 letters...<br />\");\n  \u2776 if (node.name.length === 8) return node.name; // BASE CASE\n\n    if (node.children.length > 0) {\n        // RECURSIVE CASE\n        for (let child of node.children) {\n            let returnValue = find8LetterName(child);\n            if (returnValue != null) {\n                return returnValue;\n            }\n        }\n    }\n\n    // Postorder depth-first search:\n    document.write(\"Checking if \" + node.name + \" is 8 letters...<br />\");\n  \u2777 //if (node.name.length === 8) return node.name; // BASE CASE\n\n    // Value was not found or there are no children.\n    return null; // BASE CASE\n}\n\ndocument.write(\"Found an 8-letter name: \" + find8LetterName(root));\n</script>\n```", "```py\nVisiting node Alice...\nChecking if Alice is 8 letters...\nVisiting node Bob...\nChecking if Bob is 8 letters...\nVisiting node Darya...\nChecking if Darya is 8 letters...\nVisiting node Caroline...\nChecking if Caroline is 8 letters...\nFound an 8-letter name: Caroline\n```", "```py\nVisiting node Alice...\nVisiting node Bob...\nVisiting node Darya...\nChecking if Darya is 8 letters...\nChecking if Bob is 8 letters...\nVisiting node Caroline...\nVisiting node Eve...\nVisiting node Gonzalo...\nChecking if Gonzalo is 8 letters...\nVisiting node Hadassah...\nChecking if Hadassah is 8 letters...\nFound an 8-letter name: Hadassah\n```", "```py\nroot = {'data': 'A', 'children': [{'data': 'B', 'children': \n[{'data': 'D', 'children': []}]}, {'data': 'C', 'children': \n[{'data': 'E', 'children': [{'data': 'G', 'children': []}, \n{'data': 'H', 'children': []}]}, {'data': 'F', 'children': []}]}]}\n\ndef getDepth(node):\n    if len(node['children']) == 0:\n        # BASE CASE\n        return 0\n    else:\n        # RECURSIVE CASE\n        maxChildDepth = 0\n        for child in node['children']:\n            # Find the depth of each child node:\n            childDepth = getDepth(child)\n            if childDepth > maxChildDepth:\n                # This child is deepest child node found so far:\n                maxChildDepth = childDepth\n        return maxChildDepth + 1\n\nprint('Depth of tree is ' + str(getDepth(root)))\n```", "```py\n<script type=\"text/javascript\">\nroot = {\"data\": \"A\", \"children\": [{\"data\": \"B\", \"children\": \n[{\"data\": \"D\", \"children\": []}]}, {\"data\": \"C\", \"children\": \n[{\"data\": \"E\", \"children\": [{\"data\": \"G\", \"children\": []}, \n{\"data\": \"H\", \"children\": []}]}, {\"data\": \"F\", \"children\": []}]}]};\n\nfunction getDepth(node) {\n    if (node.children.length === 0) {\n        // BASE CASE\n        return 0;\n    } else {\n        // RECURSIVE CASE\n        let maxChildDepth = 0;\n        for (let child of node.children) {\n            // Find the depth of each child node:\n let childDepth = getDepth(child);\n            if (childDepth > maxChildDepth) {\n                // This child is deepest child node found so far:\n                maxChildDepth = childDepth;\n            }\n        }\n        return maxChildDepth + 1;\n    }\n}\n\ndocument.write(\"Depth of tree is \" + getDepth(root) + \"<br />\");\n</script>\n```", "```py\nDepth of tree is 3\n```", "```py\n# Create the maze data structure:\n# You can copy-paste this from inventwithpython.com/examplemaze.txt\nMAZE = \"\"\"\n#######################################################################\n#S#                 #       # #   #     #         #     #   #         #\n# ##### ######### # ### ### # # # # ### # # ##### # ### # # ##### # ###\n# #   #     #     #     #   # # #   # #   # #       # # # #     # #   #\n# # # ##### # ########### ### # ##### ##### ######### # # ##### ### # #\n#   #     # # #     #   #   #   #         #       #   #   #   #   # # #\n######### # # # ##### # ### # ########### ####### # # ##### ##### ### #\n#       # # # #     # #     # #   #   #   #     # # #   #         #   #\n# # ##### # # ### # # ####### # # # # # # # ##### ### ### ######### # #\n# # #   # # #   # # #     #     #   #   #   #   #   #     #         # #\n### # # # # ### # # ##### ####### ########### # ### # ##### ##### ### #\n#   # #   # #   # #     #   #     #       #   #     # #     #     #   #\n# ### ####### ##### ### ### ####### ##### # ######### ### ### ##### ###\n#   #         #     #     #       #   # #   # #     #   # #   # #   # #\n### ########### # ####### ####### ### # ##### # # ##### # # ### # ### #\n#   #   #       # #     #   #   #     #       # # #     # # #   # #   #\n# ### # # ####### # ### ##### # ####### ### ### # # ####### # # # ### #\n#     #         #     #       #           #     #           # #      E#\n#######################################################################\n\"\"\".split('\\n')\n\n# Constants used in this program:\nEMPTY = ' '\nSTART = 'S'\nEXIT = 'E'\nPATH = '.'\n\n# Get the height and width of the maze:\nHEIGHT = len(MAZE)\nWIDTH = 0\nfor row in MAZE: # Set WIDTH to the widest row's width.\n    if len(row) > WIDTH:\n        WIDTH = len(row)\n# Make each row in the maze a list as wide as the WIDTH:\nfor i in range(len(MAZE)):\n    MAZE[i] = list(MAZE[i])\n    if len(MAZE[i]) != WIDTH:\n        MAZE[i] = [EMPTY] * WIDTH # Make this a blank row.\n\ndef printMaze(maze):\n    for y in range(HEIGHT):\n        # Print each row.\n        for x in range(WIDTH):\n            # Print each column in this row.\n            print(maze[y][x], end='')\n        print() # Print a newline at the end of the row.\n    print()\n\ndef findStart(maze):\n    for x in range(WIDTH):\n        for y in range(HEIGHT):\n            if maze[y][x] == START:\n                return (x, y) # Return the starting coordinates.\n\ndef solveMaze(maze, x=None, y=None, visited=None):\n    if x == None or y == None:\n        x, y = findStart(maze)\n        maze[y][x] = EMPTY # Get rid of the 'S' from the maze.\n    if visited == None:\n      \u2776 visited = [] # Create a new list of visited points. \n\n    if maze[y][x] == EXIT:\n         return True # Found the exit, return True.\n\n    maze[y][x] = PATH # Mark the path in the maze.\n  \u2777 visited.append(str(x) + ',' + str(y)) \n  \u2778 #printMaze(maze) # Uncomment to view each forward step.\n\n    # Explore the north neighboring point:\n    if y + 1 < HEIGHT and maze[y + 1][x] in (EMPTY, EXIT) and \\\n    str(x) + ',' + str(y + 1) not in visited:\n        # RECURSIVE CASE\n        if solveMaze(maze, x, y + 1, visited):\n            return True # BASE CASE\n    # Explore the south neighboring point:\n    if y - 1 >= 0 and maze[y - 1][x] in (EMPTY, EXIT) and \\\n    str(x) + ',' + str(y - 1) not in visited:\n        # RECURSIVE CASE\n        if solveMaze(maze, x, y - 1, visited):\n            return True # BASE CASE\n # Explore the east neighboring point:\n    if x + 1 < WIDTH and maze[y][x + 1] in (EMPTY, EXIT) and \\\n    str(x + 1) + ',' + str(y) not in visited:\n        # RECURSIVE CASE\n        if solveMaze(maze, x + 1, y, visited):\n            return True # BASE CASE\n    # Explore the west neighboring point:\n    if x - 1 >= 0 and maze[y][x - 1] in (EMPTY, EXIT) and \\\n    str(x - 1) + ',' + str(y) not in visited:\n        # RECURSIVE CASE\n        if solveMaze(maze, x - 1, y, visited):\n            return True # BASE CASE\n\n    maze[y][x] = EMPTY # Reset the empty space.\n  \u2779 #printMaze(maze) # Uncomment to view each backtrack step.\n\n    return False # BASE CASE\n\nprintMaze(MAZE)\nsolveMaze(MAZE)\nprintMaze(MAZE)\n```", "```py\n<script type=\"text/javascript\">\n// Create the maze data structure:\n// You can copy-paste this from inventwithpython.com/examplemaze.txt\nlet MAZE = `\n#######################################################################\n#S#                 #       # #   #     #         #     #   #         #\n# ##### ######### # ### ### # # # # ### # # ##### # ### # # ##### # ###\n# #   #     #     #     #   # # #   # #   # #       # # # #     # #   #\n# # # ##### # ########### ### # ##### ##### ######### # # ##### ### # #\n#   #     # # #     #   #   #   #         #       #   #   #   #   # # #\n######### # # # ##### # ### # ########### ####### # # ##### ##### ### #\n#       # # # #     # #     # #   #   #   #     # # #   #         #   #\n# # ##### # # ### # # ####### # # # # # # # ##### ### ### ######### # #\n# # #   # # #   # # #     #     #   #   #   #   #   #     #         # #\n### # # # # ### # # ##### ####### ########### # ### # ##### ##### ### #\n#   # #   # #   # #     #   #     #       #   #     # #     #     #   #\n# ### ####### ##### ### ### ####### ##### # ######### ### ### ##### ###\n#   #         #     #     #       #   # #   # #     #   # #   # #   # #\n### ########### # ####### ####### ### # ##### # # ##### # # ### # ### #\n#   #   #       # #     #   #   #     #       # # #     # # #   # #   #\n# ### # # ####### # ### ##### # ####### ### ### # # ####### # # # ### #\n#     #         #     #       #           #     #           # #      E#\n#######################################################################\n`.split(\"\\n\");\n\n// Constants used in this program:\nconst EMPTY = \" \";\nconst START = \"S\";\nconst EXIT = \"E\";\nconst PATH = \".\";\n\n// Get the height and width of the maze:\nconst HEIGHT = MAZE.length;\nlet maxWidthSoFar = MAZE[0].length;\nfor (let row of MAZE) { // Set WIDTH to the widest row's width.\n    if (row.length > maxWidthSoFar) {\n        maxWidthSoFar = row.length;\n    }\n}\nconst WIDTH = maxWidthSoFar;\n// Make each row in the maze a list as wide as the WIDTH:\nfor (let i = 0; i < MAZE.length; i++) {\n    MAZE[i] = MAZE[i].split(\"\");\n    if (MAZE[i].length !== WIDTH) {\n        MAZE[i] = EMPTY.repeat(WIDTH).split(\"\"); // Make this a blank row.\n    }\n}\n\nfunction printMaze(maze) {\n    document.write(\"<pre>\");\n    for (let y = 0; y < HEIGHT; y++) {\n        // Print each row.\n        for (let x = 0; x < WIDTH; x++) {\n            // Print each column in this row.\n            document.write(maze[y][x]);\n        }\n        document.write(\"\\n\"); // Print a newline at the end of the row.\n    }\n    document.write(\"\\n</ pre>\");\n}\n\nfunction findStart(maze) {\n    for (let x = 0; x < WIDTH; x++) {\n        for (let y = 0; y < HEIGHT; y++) {\n            if (maze[y][x] === START) {\n                return [x, y]; // Return the starting coordinates.\n            }\n        }\n    }\n}\n\nfunction solveMaze(maze, x, y, visited) {\n    if (x === undefined || y === undefined) {\n        [x, y] = findStart(maze);\n        maze[y][x] = EMPTY; // Get rid of the 'S' from the maze.\n    }\n    if (visited === undefined) {\n      \u2776 visited = []; // Create a new list of visited points.\n    }\n\n    if (maze[y][x] == EXIT) {\n         return true; // Found the exit, return true.\n    }\n\n    maze[y][x] = PATH; // Mark the path in the maze.\n  \u2777 visited.push(String(x) + \",\" + String(y)); \n \u2778 //printMaze(maze) // Uncomment to view each forward step.\n\n    // Explore the north neighboring point:\n    if ((y + 1 < HEIGHT) && ((maze[y + 1][x] == EMPTY) || \n    (maze[y + 1][x] == EXIT)) && \n    (visited.indexOf(String(x) + \",\" + String(y + 1)) === -1)) {\n        // RECURSIVE CASE\n        if (solveMaze(maze, x, y + 1, visited)) {\n            return true; // BASE CASE\n        }\n    }\n    // Explore the south neighboring point:\n    if ((y - 1 >= 0) && ((maze[y - 1][x] == EMPTY) || \n    (maze[y - 1][x] == EXIT)) && \n    (visited.indexOf(String(x) + \",\" + String(y - 1)) === -1)) {\n        // RECURSIVE CASE\n        if (solveMaze(maze, x, y - 1, visited)) {\n            return true; // BASE CASE\n        }\n    }\n    // Explore the east neighboring point:\n    if ((x + 1 < WIDTH) && ((maze[y][x + 1] == EMPTY) || \n    (maze[y][x + 1] == EXIT)) && \n    (visited.indexOf(String(x + 1) + \",\" + String(y)) === -1)) {\n        // RECURSIVE CASE\n        if (solveMaze(maze, x + 1, y, visited)) {\n            return true; // BASE CASE\n        }\n    }\n    // Explore the west neighboring point:\n    if ((x - 1 >= 0) && ((maze[y][x - 1] == EMPTY) || \n    (maze[y][x - 1] == EXIT)) && \n    (visited.indexOf(String(x - 1) + \",\" + String(y)) === -1)) {\n        // RECURSIVE CASE\n        if (solveMaze(maze, x - 1, y, visited)) {\n            return true; // BASE CASE\n        }\n    }\n\n    maze[y][x] = EMPTY; // Reset the empty space.\n  \u2779 //printMaze(maze); // Uncomment to view each backtrack step.\n    return false; // BASE CASE\n}\n\nprintMaze(MAZE);\nsolveMaze(MAZE);\nprintMaze(MAZE);\n</script>\n```", "```py\ndef binarySearch(needle, haystack, left=None, right=None):\n    # By default, `left` and `right` are all of `haystack`:\n    if left is None:\n        left = 0 # `left` defaults to the 0 index.\n    if right is None:\n        right = len(haystack) - 1 # `right` defaults to the last index.\n\n    print('Searching:', haystack[left:right + 1])\n\n    if left > right: # BASE CASE\n         return None # The `needle` is not in `haystack`.\n\n    mid = (left + right) // 2\n    if needle == haystack[mid]: # BASE CASE\n         return mid # The `needle` has been found in `haystack`\n    elif needle < haystack[mid]: # RECURSIVE CASE\n         return binarySearch(needle, haystack, left, mid - 1)\n    elif needle > haystack[mid]: # RECURSIVE CASE\n         return binarySearch(needle, haystack, mid + 1, right)\n\nprint(binarySearch(13, [1, 4, 8, 11, 13, 16, 19, 19]))\n```", "```py\n<script type=\"text/javascript\">\nfunction binarySearch(needle, haystack, left, right) {\n    // By default, `left` and `right` are all of `haystack`:\n    if (left === undefined) {\n        left = 0; // `left` defaults to the 0 index.\n    }\n    if (right === undefined) {\n        right = haystack.length - 1; // `right` defaults to the last index.\n    }\n\n document.write(\"Searching: [\" + \n    haystack.slice(left, right + 1).join(\", \") + \"]<br />\");\n\n    if (left > right) { // BASE CASE\n         return null; // The `needle` is not in `haystack`.\n    }\n\n    let mid = Math.floor((left + right) / 2);\n    if (needle == haystack[mid]) { // BASE CASE\n         return mid; // The `needle` has been found in `haystack`.\n    } else if (needle < haystack[mid]) { // RECURSIVE CASE\n         return binarySearch(needle, haystack, left, mid - 1);\n    } else if (needle > haystack[mid]) { // RECURSIVE CASE\n         return binarySearch(needle, haystack, mid + 1, right);\n    }\n}\n\ndocument.write(binarySearch(13, [1, 4, 8, 11, 13, 16, 19, 19]));\n</script>\n```", "```py\nSearching: [1, 4, 8, 11, 13, 16, 19, 19]\nSearching: [13, 16, 19, 19]\nSearching: [13]\n4\n```", "```py\ndef quicksort(items, left=None, right=None):\n    # By default, `left` and `right` span the entire range of `items`:\n    if left is None:\n        left = 0 # `left` defaults to the 0 index.\n    if right is None:\n        right = len(items) - 1 # `right` defaults to the last index.\n\n print('\\nquicksort() called on this range:', items[left:right + 1])\n    print('................The full list is:', items)\n\n    if right <= left: \u2776\n        # With only zero or one item, `items` is already sorted.\n        return  # BASE CASE\n\n    # START OF THE PARTITIONING\n    i = left # i starts at the left end of the range. \u2777\n    pivotValue = items[right] # Select the last value for the pivot.\n\n    print('....................The pivot is:', pivotValue)\n\n    # Iterate up to, but not including, the pivot:\n    for j in range(left, right):\n        # If a value is less than the pivot, swap it so that it's on the\n        # left side of `items`:\n        if items[j] <= pivotValue:\n            # Swap these two values:\n            items[i], items[j] = items[j], items[i] \u2778\n            i += 1\n\n    # Put the pivot on the left side of `items`:\n    items[i], items[right] = items[right], items[i]\n    # END OF THE PARTITIONING\n\n    print('....After swapping, the range is:', items[left:right + 1])\n    print('Recursively calling quicksort on:', items[left:i], 'and', items[i + 1:right + 1])\n\n    # Call quicksort() on the two partitions:\n    quicksort(items, left, i - 1)   # RECURSIVE CASE\n    quicksort(items, i + 1, right)  # RECURSIVE CASE\n\nmyList = [0, 7, 6, 3, 1, 2, 5, 4]\nquicksort(myList)\nprint(myList)\n```", "```py\n<script type=\"text/javascript\">\nfunction quicksort(items, left, right) {\n    // By default, `left` and `right` span the entire range of `items`:\n    if (left === undefined) {\n        left = 0; // `left` defaults to the 0 index.\n    }\n    if (right === undefined) {\n        right = items.length - 1; // `right` defaults to the last index.\n    }\n\n    document.write(\"<br /><pre>quicksort() called on this range: [\" + \n    items.slice(left, right + 1).join(\", \") + \"]</pre>\");\n    document.write(\"<pre>................The full list is: [\" + items.join(\", \") + \"]</pre>\");\n\n    if (right <= left) { \u2776\n        // With only zero or one item, `items` is already sorted.\n return; // BASE CASE\n    }\n\n    // START OF THE PARTITIONING\n    let i = left; \u2777 // i starts at the left end of the range.\n    let pivotValue = items[right]; // Select the last value for the pivot.\n\n    document.write(\"<pre>....................The pivot is: \" + pivotValue.toString() + \n\"</pre>\");\n\n    // Iterate up to, but not including, the pivot:\n    for (let j = left; j < right; j++) {\n        // If a value is less than the pivot, swap it so that it's on the\n        // left side of `items`:\n        if (items[j] <= pivotValue) {\n            // Swap these two values:\n            [items[i], items[j]] = [items[j], items[i]]; \u2778\n            i++;\n        }\n    }\n\n    // Put the pivot on the left side of `items`:\n    [items[i], items[right]] = [items[right], items[i]];\n    // END OF THE PARTITIONING\n\n    document.write(\"<pre>....After swapping, the range is: [\" + items.slice(left, right + 1).join(\", \") + \"]</pre>\");\n    document.write(\"<pre>Recursively calling quicksort on: [\" + items.slice(left, i).join(\", \") + \"] and [\" + items.slice(i + 1, right + 1).join(\", \") + \"]</pre>\");\n\n    // Call quicksort() on the two partitions:\n    quicksort(items, left, i - 1); // RECURSIVE CASE\n    quicksort(items, i + 1, right); // RECURSIVE CASE\n}\n\nlet myList = [0, 7, 6, 3, 1, 2, 5, 4];\nquicksort(myList);\ndocument.write(\"<pre>[\" + myList.join(\", \") + \"]</pre>\");\n</script>\n```", "```py\nitems:   [0, 7, 6, 3, 1, 2, 5, 4]\nindices:  0  1  2  3  4  5  6  7\n          ^\ni = 0     i\nj = 0     j\n```", "```py\nitems:   [0, 7, 6, 3, 1, 2, 5, 4]\nindices:  0  1  2  3  4  5  6  7\n             ^\ni = 1        i\nj = 1        j\n```", "```py\nitems:   [0, 7, 6, 3, 1, 2, 5, 4]\nindices:  0  1  2  3  4  5  6  7\n             ^\ni = 1        i  ^\nj = 2           j\n```", "```py\nitems:   [0, 7, 6, 3, 1, 2, 5, 4]\nindices:  0  1  2  3  4  5  6  7\n             ^\ni = 1        i     ^\nj = 3              j\n```", "```py\nitems:   [0, 3, 6, 7, 1, 2, 5, 4]\nindices:  0  1  2  3  4  5  6  7\n                ^\ni = 2           i     ^\nj = 4                 j\n```", "```py\nitems:   [0, 3, 1, 7, 6, 2, 5, 4]\nindices:  0  1  2  3  4  5  6  7\n                   ^\ni = 3              i     ^\nj = 5                    j\n```", "```py\nitems:   [0, 3, 1, 2, 6, 7, 5, 4]\nindices:  0  1  2  3  4  5  6  7\n                      ^\ni = 4                 i     ^\nj = 6                       j\n```", "```py\nitems:   [0, 3, 1, 2, 6, 7, 5, 4]\nindices:  0  1  2  3  4  5  6  7\n                      ^\ni = 4                 i        ^\nj = 7                          j\n```", "```py\nitems:   [0, 3, 1, 2, 4, 7, 5, 6]\nindices:  0  1  2  3  4  5  6  7\n                      ^\ni = 4                 i        ^\nj = 7                          j\n```", "```py\nquicksort() called on this range: [0, 7, 6, 3, 1, 2, 5, 4]\n................The full list is: [0, 7, 6, 3, 1, 2, 5, 4]\n....................The pivot is: 4\n....After swapping, the range is: [0, 3, 1, 2, 4, 7, 5, 6]\nRecursively calling quicksort on: [0, 3, 1, 2] and [7, 5, 6]\n\nquicksort() called on this range: [0, 3, 1, 2]\n................The full list is: [0, 3, 1, 2, 4, 7, 5, 6]\n....................The pivot is: 2\n....After swapping, the range is: [0, 1, 2, 3]\nRecursively calling quicksort on: [0, 1] and [3]\n\nquicksort() called on this range: [0, 1]\n................The full list is: [0, 1, 2, 3, 4, 7, 5, 6]\n....................The pivot is: 1\n....After swapping, the range is: [0, 1]\nRecursively calling quicksort on: [0] and []\n\nquicksort() called on this range: [0]\n................The full list is: [0, 1, 2, 3, 4, 7, 5, 6]\n\nquicksort() called on this range: []\n................The full list is: [0, 1, 2, 3, 4, 7, 5, 6]\n\nquicksort() called on this range: [3]\n................The full list is: [0, 1, 2, 3, 4, 7, 5, 6]\n\nquicksort() called on this range: [7, 5, 6]\n................The full list is: [0, 1, 2, 3, 4, 7, 5, 6]\n....................The pivot is: 6\n....After swapping, the range is: [5, 6, 7]\nRecursively calling quicksort on: [5] and [7]\n\nquicksort() called on this range: [5]\n................The full list is: [0, 1, 2, 3, 4, 5, 6, 7]\n\nquicksort() called on this range: [7]\n................The full list is: [0, 1, 2, 3, 4, 5, 6, 7]\n\nSorted: [0, 1, 2, 3, 4, 5, 6, 7]\n```", "```py\nimport math\n\ndef mergeSort(items):\n    print('.....mergeSort() called on:', items)\n\n    # BASE CASE - Zero or one item is naturally sorted:\n    if len(items) == 0 or len(items) == 1:\n        return items \u2776\n\n    # RECURSIVE CASE - Pass the left and right halves to mergeSort():\n    # Round down if items doesn't divide in half evenly:\n    iMiddle = math.floor(len(items) / 2) \u2777\n\n    print('................Split into:', items[:iMiddle], 'and', items[iMiddle:])\n\n    left = mergeSort(items[:iMiddle]) \u2778\n    right = mergeSort(items[iMiddle:])\n\n    # BASE CASE - Returned merged, sorted data:\n    # At this point, left should be sorted and right should be\n    # sorted. We can merge them into a single sorted list.\n    sortedResult = []\n    iLeft = 0\n    iRight = 0\n    while (len(sortedResult) < len(items)):\n        # Append the smaller value to sortedResult.\n        if left[iLeft] < right[iRight]: \u2779\n            sortedResult.append(left[iLeft])\n            iLeft += 1\n        else:\n            sortedResult.append(right[iRight])\n            iRight += 1\n\n        # If one of the pointers has reached the end of its list,\n        # put the rest of the other list into sortedResult.\n        if iLeft == len(left):\n            sortedResult.extend(right[iRight:])\n            break\n        elif iRight == len(right):\n            sortedResult.extend(left[iLeft:])\n            break\n\n    print('The two halves merged into:', sortedResult)\n\n    return sortedResult # Returns a sorted version of items.\n\nmyList = [2, 9, 8, 5, 3, 4, 7, 6]\nmyList = mergeSort(myList)\nprint(myList)\n```", "```py\n<script type=\"text/javascript\">\nfunction mergeSort(items) {\n    document.write(\"<pre>\" + \".....mergeSort() called on: [\" + \n    items.join(\", \") + \"]</pre>\");\n\n    // BASE CASE - Zero or one item is naturally sorted:\n    if (items.length === 0 || items.length === 1) { // BASE CASE\n        return items; \u2776\n    }\n\n    // RECURSIVE CASE - Pass the left and right halves to mergeSort():\n    // Round down if items doesn't divide in half evenly:\n    let iMiddle = Math.floor(items.length / 2); \u2777\n\n    document.write(\"<pre>................Split into: [\" + items.slice(0, iMiddle).join(\", \") + \n    \"] and [\" + items.slice(iMiddle).join(\", \") + \"]</pre>\");\n\n    let left = mergeSort(items.slice(0, iMiddle)); \u2778\n    let right = mergeSort(items.slice(iMiddle));\n\n    // BASE CASE - Returned merged, sorted data:\n    // At this point, left should be sorted and right should be\n    // sorted. We can merge them into a single sorted list.\n    let sortedResult = [];\n    let iLeft = 0;\n    let iRight = 0;\n    while (sortedResult.length < items.length) {\n        // Append the smaller value to sortedResult.\n        if (left[iLeft] < right[iRight]) { \u2779\n            sortedResult.push(left[iLeft]);\n            iLeft++;\n        } else {\n            sortedResult.push(right[iRight]);\n            iRight++;\n        }\n\n        // If one of the pointers has reached the end of its list,\n        // put the rest of the other list into sortedResult.\n        if (iLeft == left.length) {\n            Array.prototype.push.apply(sortedResult, right.slice(iRight));\n            break;\n        } else if (iRight == right.length) {\n            Array.prototype.push.apply(sortedResult, left.slice(iLeft));\n            break;\n        }\n    }\n\n    document.write(\"<pre>The two halves merged into: [\" + sortedResult.join(\", \") + \n    \"]</pre>\");\n\n    return sortedResult; // Returns a sorted version of items.\n}\n\nlet myList = [2, 9, 8, 5, 3, 4, 7, 6];\nmyList = mergeSort(myList);\ndocument.write(\"<pre>[\" + myList.join(\", \") + \"]</pre>\");\n</script>\n```", "```py\nsortedResult = []\n      left: [2, 9]    right: [5, 8]\n   indices:  0  1             0  1\n iLeft = 0   ^\niRight = 0                    ^\n```", "```py\nsortedResult = [2]\n      left: [2, 9]    right: [5, 8]\n   indices:  0  1             0  1\n iLeft = 1      ^\niRight = 0                    ^\n```", "```py\nsortedResult = [2, 5]\n      left: [2, 9]    right: [5, 8]\n indices:  0  1             0  1\n iLeft = 1      ^\niRight = 1                       ^\n```", "```py\nsortedResult = [2, 5, 8]\n      left: [2, 9]    right: [5, 8]\n   indices:  0  1             0  1\n iLeft = 1      ^\niRight = 2                         ^\n```", "```py\n.....mergeSort() called on: [2, 9, 8, 5, 3, 4, 7, 6]\n................Split into: [2, 9, 8, 5] and [3, 4, 7, 6]\n.....mergeSort() called on: [2, 9, 8, 5]\n................Split into: [2, 9] and [8, 5]\n.....mergeSort() called on: [2, 9]\n................Split into: [2] and [9]\n.....mergeSort() called on: [2]\n.....mergeSort() called on: [9]\nThe two halves merged into: [2, 9]\n.....mergeSort() called on: [8, 5]\n................Split into: [8] and [5]\n.....mergeSort() called on: [8]\n.....mergeSort() called on: [5]\nThe two halves merged into: [5, 8]\nThe two halves merged into: [2, 5, 8, 9]\n.....mergeSort() called on: [3, 4, 7, 6]\n................Split into: [3, 4] and [7, 6]\n.....mergeSort() called on: [3, 4]\n................Split into: [3] and [4]\n.....mergeSort() called on: [3]\n.....mergeSort() called on: [4]\nThe two halves merged into: [3, 4]\n.....mergeSort() called on: [7, 6]\n................Split into: [7] and [6]\n.....mergeSort() called on: [7]\n.....mergeSort() called on: [6]\nThe two halves merged into: [6, 7]\nThe two halves merged into: [3, 4, 6, 7]\nThe two halves merged into: [2, 3, 4, 5, 6, 7, 8, 9]\n[2, 3, 4, 5, 6, 7, 8, 9]\n```", "```py\ndef sumDivConq(numbers):\n    if len(numbers) == 0: # BASE CASE\n      \u2776 return 0\n    elif len(numbers) == 1: # BASE CASE\n      \u2777 return numbers[0]\n    else: # RECURSIVE CASE\n      \u2778 mid = len(numbers) // 2\n        leftHalfSum = sumDivConq(numbers[0:mid])\n rightHalfSum = sumDivConq(numbers[mid:len(numbers) + 1])\n      \u2779 return leftHalfSum + rightHalfSum\n\nnums = [1, 2, 3, 4, 5]\nprint('The sum of', nums, 'is', sumDivConq(nums))\nnums = [5, 2, 4, 8]\nprint('The sum of', nums, 'is', sumDivConq(nums))\nnums = [1, 10, 100, 1000]\nprint('The sum of', nums, 'is', sumDivConq(nums))\n```", "```py\n<script type=\"text/javascript\">\nfunction sumDivConq(numbers) {\n    if (numbers.length === 0) { // BASE CASE\n      \u2776 return 0;\n    } else if (numbers.length === 1) { // BASE CASE\n      \u2777 return numbers[0];\n    } else { // RECURSIVE CASE\n      \u2778 let mid = Math.floor(numbers.length / 2);\n        let leftHalfSum = sumDivConq(numbers.slice(0, mid));\n        let rightHalfSum = sumDivConq(numbers.slice(mid, numbers.length + 1));\n      \u2779 return leftHalfSum + rightHalfSum;\n    }\n}\n\nlet nums = [1, 2, 3, 4, 5];\ndocument.write('The sum of ' + nums + ' is ' + sumDivConq(nums) + \"<br />\");\nnums = [5, 2, 4, 8];\ndocument.write('The sum of ' + nums + ' is ' + sumDivConq(nums) + \"<br />\");\nnums = [1, 10, 100, 1000];\ndocument.write('The sum of ' + nums + ' is ' + sumDivConq(nums) + \"<br />\");\n</script>\n```", "```py\nThe sum of [1, 2, 3, 4, 5] is 15\nThe sum of [5, 2, 4, 8] is 19\nThe sum of [1, 10, 100, 1000] is 1111\n```", "```py\n>>> **x = 5678**\n>>> **y = 1234**\n>>> **product = 0**\n>>> **for i in range(x):**\n...     **product += y**\n...\n>>> **product**\n7006652\n```", "```py\nimport math\n\n# Create a lookup table of all single-digit multiplication products:\nMULT_TABLE = {} \u2776\nfor i in range(10):\n    for j in range(10):\n MULT_TABLE[(i, j)] = i * j\n\ndef padZeros(numberString, numZeros, insertSide):\n    \"\"\"Return a string padded with zeros on the left or right side.\"\"\"\n    if insertSide == 'left':\n        return '0' * numZeros + numberString\n    elif insertSide == 'right':\n        return numberString + '0' * numZeros\n\ndef karatsuba(x, y):\n    \"\"\"Multiply two integers with the Karatsuba algorithm. Note that\n    the * operator isn't used anywhere in this function.\"\"\"\n    assert isinstance(x, int), 'x must be an integer'\n    assert isinstance(y, int), 'y must be an integer'\n    x = str(x)\n    y = str(y)\n\n    # At single digits, look up the products in the multiplication table:\n    if len(x) == 1 and len(y) == 1: # BASE CASE\n        print('Lookup', x, '*', y, '=', MULT_TABLE[(int(x), int(y))])\n        return MULT_TABLE[(int(x), int(y))]\n\n    # RECURSIVE CASE\n    print('Multiplying', x, '*', y)\n\n    # Pad with prepended zeros so that x and y are the same length:\n    if len(x) < len(y): \u2777\n        # If x is shorter than y, pad x with zeros:\n        x = padZeros(x, len(y) - len(x), 'left')\n    elif len(y) < len(x):\n        # If y is shorter than x, pad y with zeros:\n        y = padZeros(y, len(x) - len(y), 'left')\n    # At this point, x and y have the same length.\n\n    halfOfDigits = math.floor(len(x) / 2) \u2778\n\n    # Split x into halves a & b, split y into halves c & d:\n    a = int(x[:halfOfDigits])\n    b = int(x[halfOfDigits:])\n    c = int(y[:halfOfDigits])\n    d = int(y[halfOfDigits:])\n\n    # Make the recursive calls with these halves:\n    step1Result = karatsuba(a, c) \u2779 # Step 1: Multiply a & c.\n    step2Result = karatsuba(b, d) # Step 2: Multiply b & d.\n    step3Result = karatsuba(a + b, c + d) # Step 3: Multiply a + b & c + d.\n\n    # Step 4: Calculate Step 3 - Step 2 - Step 1:\n    step4Result = step3Result - step2Result - step1Result \u277a\n\n    # Step 5: Pad these numbers, then add them for the return value:\n    step1Padding = (len(x) - halfOfDigits) + (len(x) - halfOfDigits)\n    step1PaddedNum = int(padZeros(str(step1Result), step1Padding, 'right'))\n\n    step4Padding = (len(x) - halfOfDigits)\n step4PaddedNum = int(padZeros(str(step4Result), step4Padding, 'right'))\n\n    print('Solved', x, 'x', y, '=', step1PaddedNum + step2Result + step4PaddedNum)\n\n    return step1PaddedNum + step2Result + step4PaddedNum \u277b\n\n# Example: 1357 x 2468 = 3349076\nprint('1357 * 2468 =', karatsuba(1357, 2468))\n```", "```py\n<script type=\"text/javascript\">\n\n// Create a lookup table of all single-digit multiplication products:\nlet MULT_TABLE = {}; \u2776\nfor (let i = 0; i < 10; i++) {\n    for (let j = 0; j < 10; j++) {\n        MULT_TABLE[[i, j]] = i * j;\n    }\n}\n\nfunction padZeros(numberString, numZeros, insertSide) {\n    // Return a string padded with zeros on the left or right side.\n    if (insertSide === \"left\") {\n        return \"0\".repeat(numZeros) + numberString;\n    } else if (insertSide === \"right\") {\n        return numberString + \"0\".repeat(numZeros);\n    }\n}\n\nfunction karatsuba(x, y) {\n    // Multiply two integers with the Karatsuba algorithm. Note that\n    // the * operator isn't used anywhere in this function.\n    console.assert(Number.isInteger(x), \"x must be an integer\");\n    console.assert(Number.isInteger(y), \"y must be an integer\");\n    x = x.toString();\n    y = y.toString();\n\n    // At single digits, look up the products in the multiplication table:  \n    if ((x.length === 1) && (y.length === 1)) { // BASE CASE\n        document.write(\"Lookup \" + x.toString() + \" * \" + y.toString() + \" = \" + \n        MULT_TABLE[[parseInt(x), parseInt(y)]] + \"<br />\");\n        return MULT_TABLE[[parseInt(x), parseInt(y)]];\n    }\n\n    // RECURSIVE CASE\n    document.write(\"Multiplying \" + x.toString() + \" * \" + y.toString() + \n    \"<br />\");\n\n    // Pad with prepended zeros so that x and y are the same length:\n    if (x.length < y.length) { \u2777\n        // If x is shorter than y, pad x with zeros:\n        x = padZeros(x, y.length - x.length, \"left\");\n    } else if (y.length < x.length) {\n        // If y is shorter than x, pad y with zeros:\n y = padZeros(y, x.length - y.length, \"left\");\n    }\n    // At this point, x and y have the same length.\n\n    let halfOfDigits = Math.floor(x.length / 2); \u2778\n\n    // Split x into halves a & b, split y into halves c & d:\n    let a = parseInt(x.substring(0, halfOfDigits));\n    let b = parseInt(x.substring(halfOfDigits));\n    let c = parseInt(y.substring(0, halfOfDigits));\n    let d = parseInt(y.substring(halfOfDigits));\n\n    // Make the recursive calls with these halves:\n    let step1Result = karatsuba(a, c); \u2779 // Step 1: Multiply a & c.\n    let step2Result = karatsuba(b, d); // Step 2: Multiply b & d.\n    let step3Result = karatsuba(a + b, c + d); // Step 3: Multiply a + b & c + d.\n\n    // Step 4: Calculate Step 3 - Step 2 - Step 1:\n    let step4Result = step3Result - step2Result - step1Result; \u277a\n\n    // Step 5: Pad these numbers, then add them for the return value:\n    let step1Padding = (x.length - halfOfDigits) + (x.length - halfOfDigits);\n    let step1PaddedNum = parseInt(padZeros(step1Result.toString(), step1Padding, \"right\"));\n\n    let step4Padding = (x.length - halfOfDigits);\n    let step4PaddedNum = parseInt(padZeros((step4Result).toString(), step4Padding, \"right\"));\n\n    document.write(\"Solved \" + x + \" x \" + y + \" = \" + \n    (step1PaddedNum + step2Result + step4PaddedNum).toString() + \"<br />\");\n\n    return step1PaddedNum + step2Result + step4PaddedNum; \u277b\n}\n\n// Example: 1357 x 2468 = 3349076\ndocument.write(\"1357 * 2468 = \" + karatsuba(1357, 2468).toString() + \"<br />\");\n</script>\n```", "```py\nMultiplying 1357 * 2468\nMultiplying 13 * 24\nLookup 1 * 2 = 2\nLookup 3 * 4 = 12\nLookup 4 * 6 = 24\nSolved 13 * 24 = 312\nMultiplying 57 * 68\nLookup 5 * 6 = 30\nLookup 7 * 8 = 56\nMultiplying 12 * 14\nLookup 1 * 1 = 1\nLookup 2 * 4 = 8\nLookup 3 * 5 = 15\nSolved 12 * 14 = 168\nSolved 57 * 68 = 3876\nMultiplying 70 * 92\nLookup 7 * 9 = 63\nLookup 0 * 2 = 0\nMultiplying 7 * 11\nLookup 0 * 1 = 0\nLookup 7 * 1 = 7\nLookup 7 * 2 = 14\nSolved 07 * 11 = 77\nSolved 70 * 92 = 6440\nSolved 1357 * 2468 = 3349076\n1357 * 2468 = 3349076\n```", "```py\ndef getPerms(chars, indent=0):\n    print('.' * indent + 'Start of getPerms(\"' + chars + '\")')\n    if len(chars) == 1: \u2776\n        # BASE CASE\n        print('.' * indent + 'When chars = \"' + chars + '\" base case returns', chars)\n        return [chars]\n\n    # RECURSIVE CASE\n    permutations = []\n    head = chars[0] \u2777\n    tail = chars[1:]\n tailPermutations = getPerms(tail, indent + 1)\n    for tailPerm in tailPermutations: \u2778\n        print('.' * indent + 'When chars =', chars, 'putting head', head, 'in all places in', tailPerm)\n        for i in range(len(tailPerm) + 1): \u2779\n            newPerm = tailPerm[0:i] + head + tailPerm[i:]\n            print('.' * indent + 'New permutation:', newPerm)\n            permutations.append(newPerm)\n    print('.' * indent + 'When chars =', chars, 'results are', permutations)\n    return permutations\n\nprint('Permutations of \"ABCD\":')\nprint('Results:', ','.join(getPerms('ABCD')))\n```", "```py\n<script type=\"text/javascript\">\nfunction getPerms(chars, indent) {\n    if (indent === undefined) {\n        indent = 0;\n    }\n    document.write('.'.repeat(indent) + 'Start of getPerms(\"' + chars + '\")<br />');\n    if (chars.length === 1) { \u2776\n        // BASE CASE\n        document.write('.'.repeat(indent) + \"When chars = \\\"\" + chars + \n        \"\\\" base case returns \" + chars + \"<br />\");\n        return [chars];\n    }\n    // RECURSIVE CASE\n    let permutations = [];\n    let head = chars[0]; \u2777\n    let tail = chars.substring(1);\n    let tailPermutations = getPerms(tail, indent + 1);\n    for (tailPerm of tailPermutations) { \u2778\n        document.write('.'.repeat(indent) + \"When chars = \" + chars + \n        \" putting head \" + head + \" in all places in \" + tailPerm + \"<br />\");\n        for (let i = 0; i < tailPerm.length + 1; i++) { \u2779\n            let newPerm = tailPerm.slice(0, i) + head + tailPerm.slice(i);\n            document.write('.'.repeat(indent) + \"New permutation: \" + newPerm + \"<br />\");\n            permutations.push(newPerm);\n        }\n    }\n    document.write('.'.repeat(indent) + \"When chars = \" + chars + \n    \" results are \" + permutations + \"<br />\");\n    return permutations;\n}\n\ndocument.write(\"<pre>Permutations of \\\"ABCD\\\":<br />\");\ndocument.write(\"Results: \" + getPerms(\"ABCD\") + \"</pre>\");\n</script>\n```", "```py\nPermutations of \"ABCD\":\nStart of getPerms(\"ABCD\")\n.Start of getPerms(\"BCD\")\n..Start of getPerms(\"CD\")\n...Start of getPerms(\"D\")\n...When chars = \"D\" base case returns D\n..When chars = CD putting head C in all places in D\n..New permutation: CD\n..New permutation: DC\n..When chars = CD results are ['CD', 'DC']\n.When chars = BCD putting head B in all places in CD\n.New permutation: BCD\n.New permutation: CBD\n.New permutation: CDB\n.When chars = BCD putting head B in all places in DC\n.New permutation: BDC\n.New permutation: DBC\n.New permutation: DCB\n.When chars = BCD results are ['BCD', 'CBD', 'CDB', 'BDC', 'DBC', 'DCB']\n`--snip--`\nWhen chars = ABCD putting head A in all places in DCB\nNew permutation: ADCB\nNew permutation: DACB\nNew permutation: DCAB\nNew permutation: DCBA\nWhen chars = ABCD results are ['ABCD', 'BACD', 'BCAD', 'BCDA', 'ACBD', 'CABD', 'CBAD', 'CBDA', 'ACDB','CADB', 'CDAB', 'CDBA', 'ABDC', 'BADC', 'BDAC', 'BDCA', 'ADBC', 'DABC', 'DBAC', 'DBCA', 'ADCB', 'DACB', 'DCAB', 'DCBA']\nResults: ABCD,BACD,BCAD,BCDA,ACBD,CABD,CBAD,CBDA,ACDB,CADB,CDAB,CDBA,ABDC,\nBADC,BDAC,BDCA,ADBC,DABC,DBAC,DBCA,ADCB,DACB,DCAB,DCBA\n```", "```py\nfor a in ['A', 'B', 'C', 'D', 'E']:\n    for b in ['A', 'B', 'C', 'D', 'E']:\n        for c in ['A', 'B', 'C', 'D', 'E']:\n            for d in ['A', 'B', 'C', 'D', 'E']:\n                print(a, b, c, d)\n```", "```py\n<script>\nfor (a of ['A', 'B', 'C', 'D', 'E']) {\n    for (b of ['A', 'B', 'C', 'D', 'E']) {\n        for (c of ['A', 'B', 'C', 'D', 'E']) {\n            for (d of ['A', 'B', 'C', 'D', 'E']) {\n                document.write(a + b + c + d + \"<br />\")\n            }\n        }\n    }\n}\n</script>\n```", "```py\nA A A A\nA A A B\nA A A C\nA A A D\nA A A E\nA A B A\nA A B B\n`--snip--`\nE E E C\nE E E D\nE E E E\n```", "```py\ndef getPermsWithRep(chars, permLength=None, prefix=''):\n    indent = '.' * len(prefix)\n    print(indent + 'Start, args=(\"' + chars + '\", ' + str(permLength) + ', \"' + prefix + '\")')\n    if permLength is None:\n        permLength = len(chars)\n\n    # BASE CASE\n    if (permLength == 0): \u2776\n        print(indent + 'Base case reached, returning', [prefix])\n        return [prefix]\n\n    # RECURSIVE CASE\n    # Create a new prefix by adding each character to the current prefix.\n    results = []\n    print(indent + 'Adding each char to prefix \"' + prefix + '\".')\n    for char in chars:\n        newPrefix = prefix + char \u2777\n\n        # Decrease permLength by one because we added one character to the prefix.\n        results.extend(getPermsWithRep (chars, permLength - 1, newPrefix)) \u2778\n    print(indent + 'Returning', results)\n    return results\n\nprint('All permutations with repetition of JPB123:')\nprint(getPermsWithRep('JPB123', 4))\n```", "```py\n<script type=\"text/javascript\">\nfunction getPermsWithRep(chars, permLength, prefix) {\n    if (permLength === undefined) {\n        permLength = chars.length;\n    }\n    if (prefix === undefined) {\n        prefix = \"\";\n    }\n    let indent = \".\".repeat(prefix.length);\n    document.write(indent + \"Start, args=(\\\"\" + chars + \"\\\", \" + permLength + \n    \", \\\"\" + prefix + \"\\\")<br />\");\n\n    // BASE CASE\n    if (permLength === 0) { \u2776\n        document.write(indent + \"Base case reached, returning \" + [prefix] + \"<br />\");\n        return [prefix];\n    }\n\n    // RECURSIVE CASE\n    // Create a new prefix by adding each character to the current prefix.\n    let results = [];\n    document.write(indent + \"Adding each char to prefix \\\"\" + prefix + \"\\\".<br />\");\n    for (char of chars) {\n        let newPrefix = prefix + char; \u2777\n\n        // Decrease permLength by one because we added one character to the prefix.\n        results = results.concat(getPermsWithRep(chars, permLength - 1, newPrefix)); \u2778\n    }\n    document.write(indent + \"Returning \" + results + \"<br />\");\n    return results;\n}\n\ndocument.write(\"<pre>All permutations with repetition of JPB123:<br />\");\ndocument.write(getPermsWithRep('JPB123', 4) + \"</pre>\");\n</script>\n```", "```py\nAll permutations with repetition of JPB123:\nStart, args=(\"JPB123\", 4, \"\")\nAdding each char to prefix \"\".\n.Start, args=(\"JPB123\", 3, \"J\")\n.Adding each char to prefix \"J\".\n..Start, args=(\"JPB123\", 2, \"JJ\")\n..Adding each char to prefix \"JJ\".\n...Start, args=(\"JPB123\", 1, \"JJJ\")\n...Adding each char to prefix \"JJJ\".\n....Start, args=(\"JPB123\", 0, \"JJJJ\")\n....Base case reached, returning ['JJJJ']\n....Start, args=(\"JPB123\", 0, \"JJJP\")\n....Base case reached, returning ['JJJP']\n`--snip--`\nReturning ['JJJJ', 'JJJP', 'JJJB', 'JJJ1', 'JJJ2', 'JJJ3', \n'JJPJ', 'JJPP', 'JJPB', 'JJP1', 'JJP2', 'JJP3', 'JJBJ', 'JJBP', \n'JJBB', 'JJB1', 'JJB2', 'JJB3', 'JJ1J', 'JJ1P', 'JJ1B', 'JJ11', \n'JJ12', 'JJ13', 'JJ2J', 'JJ2P', 'JJ2B', 'JJ21', 'JJ22', 'JJ23', \n'JJ3J', 'JJ3P', 'JJ3B', 'JJ31', 'JJ32', 'JJ33', 'JPJJ', \n`--snip--`\n```", "```py\ndef getCombos(chars, k, indent=0):\n    debugMsg = '.' * indent + \"In getCombos('\" + chars + \"', \" + str(k) + \")\"\n    print(debugMsg + ', start.')\n    if k == 0:\n        # BASE CASE\n        print(debugMsg + \" base case returns ['']\")\n        # If k asks for 0-combinations, return '' as the selection of\n        # zero letters from chars.\n        return ['']\n    elif chars == '':\n        # BASE CASE\n        print(debugMsg + ' base case returns []')\n        return [] # A blank chars has no combinations, no matter what k is.\n\n    # RECURSIVE CASE\n    combinations = []\n  \u2776 # First part, get the combos that include the head:\n    head = chars[:1]\n    tail = chars[1:]\n    print(debugMsg + \" part 1, get combos with head '\" + head + \"'\")\n  \u2777 tailCombos = getCombos(tail, k - 1, indent + 1)\n    print('.' * indent + \"Adding head '\" + head + \"' to tail combos:\")\n    for tailCombo in tailCombos:\n        print('.' * indent + 'New combination', head + tailCombo)\n        combinations.append(head + tailCombo)\n\n  \u2778 # Second part, get the combos that don't include the head:\n    print(debugMsg + \" part 2, get combos without head '\" + head + \"')\")\n  \u2779 combinations.extend(getCombos(tail, k, indent + 1))\n\n    print(debugMsg + ' results are', combinations)\n    return combinations\n\nprint('2-combinations of \"ABC\":')\nprint('Results:', getCombos('ABC', 2))\n```", "```py\n<script type=\"text/javascript\">\nfunction getCombos(chars, k, indent) {\n    if (indent === undefined) {\n        indent = 0;\n    }\n    let debugMsg = \".\".repeat(indent) + \"In getCombos('\" + chars + \"', \" + k + \")\";\n    document.write(debugMsg + \", start.<br />\");\n    if (k == 0) {\n        // BASE CASE\n        document.write(debugMsg + \" base case returns ['']<br />\");\n        // If k asks for 0-combinations, return '' as the selection of zero letters from chars.\n        return [\"\"];\n    } else if (chars == \"\") {\n        // BASE CASE\n        document.write(debugMsg + \" base case returns []<br />\");\n return []; // A blank chars has no combinations, no matter what k is.\n    }\n\n    // RECURSIVE CASE\n    let combinations = [];\n    // First part, get the combos that include the head: \u2776\n    let head = chars.slice(0, 1);\n    let tail = chars.slice(1, chars.length);\n    document.write(debugMsg + \" part 1, get combos with head '\" + head + \"'<br />\");\n    let tailCombos = getCombos(tail, k - 1, indent + 1); \u2777\n    document.write(\".\".repeat(indent) + \"Adding head '\" + head + \"' to tail combos:<br />\");\n    for (tailCombo of tailCombos) {\n        document.write(\".\".repeat(indent) + \"New combination \" + head + tailCombo + \"<br />\");\n        combinations.push(head + tailCombo);\n    }\n    // Second part, get the combos that don't include the head: \u2778\n    document.write(debugMsg + \" part 2, get combos without head '\" + head + \"')<br />\");\n    combinations = combinations.concat(getCombos(tail, k, indent + 1)); \u2779\n\n    document.write(debugMsg + \" results are \" + combinations + \"<br />\");\n    return combinations;\n}\n\ndocument.write('<pre>2-combinations of \"ABC\":<br />');\ndocument.write(\"Results: \" + getCombos(\"ABC\", 2) + \"<br /></pre>\");\n</script>\n```", "```py\n2-combinations of \"ABC\":\nIn getCombos('ABC', 2), start.\nIn getCombos('ABC', 2) part 1, get combos with head 'A'\n.In getCombos('BC', 1), start.\n.In getCombos('BC', 1) part 1, get combos with head 'B'\n..In getCombos('C', 0), start.\n..In getCombos('C', 0) base case returns ['']\n.Adding head 'B' to tail combos:\n.New combination B\n.In getCombos('BC', 1) part 2, get combos without head 'B')\n..In getCombos('C', 1), start.\n..In getCombos('C', 1) part 1, get combos with head 'C'\n...In getCombos('', 0), start.\n...In getCombos('', 0) base case returns ['']\n..Adding head 'C' to tail combos:\n..New combination C\n..In getCombos('C', 1) part 2, get combos without head 'C')\n...In getCombos('', 1), start.\n...In getCombos('', 1) base case returns []\n..In getCombos('C', 1) results are ['C']\n.In getCombos('BC', 1) results are ['B', 'C']\nAdding head 'A' to tail combos:\nNew combination AB\nNew combination AC\nIn getCombos('ABC', 2) part 2, get combos without head 'A')\n.In getCombos('BC', 2), start.\n.In getCombos('BC', 2) part 1, get combos with head 'B'\n..In getCombos('C', 1), start.\n..In getCombos('C', 1) part 1, get combos with head 'C'\n...In getCombos('', 0), start.\n...In getCombos('', 0) base case returns ['']\n..Adding head 'C' to tail combos:\n..New combination C\n..In getCombos('C', 1) part 2, get combos without head 'C')\n...In getCombos('', 1), start.\n...In getCombos('', 1) base case returns []\n..In getCombos('C', 1) results are ['C']\n.Adding head 'B' to tail combos:\n.New combination BC\n.In getCombos('BC', 2) part 2, get combos without head 'B')\n..In getCombos('C', 2), start.\n..In getCombos('C', 2) part 1, get combos with head 'C'\n...In getCombos('', 1), start.\n...In getCombos('', 1) base case returns []\n..Adding head 'C' to tail combos:\n..In getCombos('C', 2) part 2, get combos without head 'C')\n...In getCombos('', 2), start.\n...In getCombos('', 2) base case returns []\n..In getCombos('C', 2) results are []\n.In getCombos('BC', 2) results are ['BC']\nIn getCombos('ABC', 2) results are ['AB', 'AC', 'BC']\nResults: ['AB', 'AC', 'BC']\n```", "```py\ndef getBalancedParens(pairs, openRem=None, closeRem=None, current='', indent=0):\n    if openRem is None: \u2776\n        openRem = pairs\n    if closeRem is None:\n        closeRem = pairs\n\n    print('.' * indent, end='')\n    print('Start of pairs=' + str(pairs) + ', openRem=' + \n    str(openRem) + ', closeRem=' + str(closeRem) + ', current=\"' + current + '\"')\n    if openRem == 0 and closeRem == 0: \u2777\n        # BASE CASE\n        print('.' * indent, end='')\n        print('1st base case. Returning ' + str([current]))\n        return [current] \u2778\n\n    # RECURSIVE CASE\n    results = []\n    if openRem > 0: \u2779\n        print('.' * indent, end='')\n        print('Adding open parenthesis.')\n        results.extend(getBalancedParens(pairs, openRem - 1, closeRem, \n        current + '(', indent + 1))\n    if closeRem > openRem: \u277a\n        print('.' * indent, end='')\n        print('Adding close parenthesis.')\n        results.extend(getBalancedParens(pairs, openRem, closeRem - 1, \n        current + ')', indent + 1))\n\n    # BASE CASE\n    print('.' * indent, end='')\n    print('2nd base case. Returning ' + str(results))\n    return results \u277b\n\nprint('All combinations of 2 balanced parentheses:')\nprint('Results:', getBalancedParens(2))\n```", "```py\n<script type=\"text/javascript\">\nfunction getBalancedParens(pairs, openRem, closeRem, current, indent) {\n    if (openRem === undefined) { \u2776\n        openRem = pairs;\n    }\n    if (closeRem === undefined) {\n        closeRem = pairs;\n    }\n    if (current === undefined) {\n        current = \"\";\n    }\n if (indent === undefined) {\n        indent = 0;\n    }\n\n    document.write(\".\".repeat(indent) + \"Start of pairs=\" + \n    pairs + \", openRem=\" + openRem + \", closeRem=\" + \n    closeRem + \", current=\\\"\" + current + \"\\\"<br />\");\n    if (openRem === 0 && closeRem === 0) { \u2777\n        // BASE CASE\n        document.write(\".\".repeat(indent) + \n        \"1st base case. Returning \" + [current] + \"<br />\");\n        return [current]; \u2778\n    }\n\n    // RECURSIVE CASE\n    let results = [];\n    if (openRem > 0) { \u2779\n        document.write(\".\".repeat(indent) + \"Adding open parenthesis.<br />\");\n        Array.prototype.push.apply(results, getBalancedParens(\n        pairs, openRem - 1, closeRem, current + '(', indent + 1));\n    }\n    if (closeRem > openRem) { \u277a\n        document.write(\".\".repeat(indent) + \"Adding close parenthesis.<br />\");\n        results = results.concat(getBalancedParens(\n        pairs, openRem, closeRem - 1, current + ')', indent + 1));\n    }\n\n    // BASE CASE\n    document.write(\".\".repeat(indent) + \"2nd base case. Returning \" + results + \"<br />\");\n    return results; \u277b\n}\n\ndocument.write(<pre>\"All combinations of 2 balanced parentheses:<br />\");\ndocument.write(\"Results: \", getBalancedParens(2), \"</pre>\");\n</script>\n```", "```py\nAll combinations of 2 balanced parentheses:\nStart of pairs=2, openRem=2, closeRem=2, current=\"\"\nAdding open parenthesis.\n.Start of pairs=2, openRem=1, closeRem=2, current=\"(\"\n.Adding open parenthesis.\n..Start of pairs=2, openRem=0, closeRem=2, current=\"((\"\n..Adding close parenthesis.\n...Start of pairs=2, openRem=0, closeRem=1, current=\"(()\"\n...Adding close parenthesis.\n....Start of pairs=2, openRem=0, closeRem=0, current=\"(())\"\n....1st base case. Returning ['(())']\n...2nd base case. Returning ['(())']\n..2nd base case. Returning ['(())']\n.Adding close parenthesis.\n..Start of pairs=2, openRem=1, closeRem=1, current=\"()\"\n..Adding open parenthesis.\n...Start of pairs=2, openRem=0, closeRem=1, current=\"()(\"\n...Adding close parenthesis.\n....Start of pairs=2, openRem=0, closeRem=0, current=\"()()\"\n....1st base case. Returning ['()()']\n...2nd base case. Returning ['()()']\n..2nd base case. Returning ['()()']\n.2nd base case. Returning ['(())', '()()']\n2nd base case. Returning ['(())', '()()']\nResults: ['(())', '()()']\n```", "```py\ndef getPowerSet(chars, indent=0):\n    debugMsg = '.' * indent + 'In getPowerSet(\"' + chars + '\")'\n    print(debugMsg + ', start.')\n\n  \u2776 if chars == '':\n        # BASE CASE\n        print(debugMsg + \" base case returns ['']\")\n        return ['']\n\n    # RECURSIVE CASE\n    powerSet = []\n    head = chars[0]\n    tail = chars[1:]\n\n    # First part, get the sets that don't include the head:\n    print(debugMsg, \"part 1, get sets without head '\" + head + \"'\")\n  \u2777 tailPowerSet = getPowerSet(tail, indent + 1)\n\n    # Second part, get the sets that include the head:\n    print(debugMsg, \"part 2, get sets with head '\" + head + \"'\")\n    for tailSet in tailPowerSet:\n        print(debugMsg, 'New set', head + tailSet)\n      \u2778 powerSet.append(head + tailSet)\n\n    powerSet = powerSet + tailPowerSet\n    print(debugMsg, 'returning', powerSet)\n  \u2779 return powerSet\n\nprint('The power set of ABC:')\nprint(getPowerSet('ABC'))\n```", "```py\n<script type=\"text/javascript\">\nfunction getPowerSet(chars, indent) {\n    if (indent === undefined) {\n        indent = 0;\n    }\n    let debugMsg = \".\".repeat(indent) + 'In getPowerSet(\"' + chars + '\")';\n    document.write(debugMsg + \", start.<br />\");\n\n    if (chars == \"\") { \u2776\n        // BASE CASE\n        document.write(debugMsg + \" base case returns ['']<br />\");\n        return [''];\n    }\n\n    // RECURSIVE CASE\n    let powerSet = [];\n    let head = chars[0];\n    let tail = chars.slice(1, chars.length);\n\n // First part, get the sets that don't include the head:\n    document.write(debugMsg + \n    \" part 1, get sets without head '\" + head + \"'<br />\");\n    let tailPowerSet = getPowerSet(tail, indent + 1); \u2777\n\n    // Second part, get the sets that include the head:\n    document.write(debugMsg + \n    \" part 2, get sets with head '\" + head + \"'<br />\");\n    for (tailSet of tailPowerSet) {\n        document.write(debugMsg + \" New set \" + head + tailSet + \"<br />\");\n        powerSet.push(head + tailSet); \u2778\n    }\n\n    powerSet = powerSet.concat(tailPowerSet);\n    document.write(debugMsg + \" returning \" + powerSet + \"<br />\");\n    return powerSet; \u2779\n}\n\ndocument.write(\"<pre>The power set of ABC:<br />\")\ndocument.write(getPowerSet(\"ABC\") + \"<br /></pre>\");\n</script>\n```", "```py\nThe power set of ABC:\nIn getPowerSet(\"ABC\"), start.\nIn getPowerSet(\"ABC\") part 1, get sets without head 'A'\n.In getPowerSet(\"BC\"), start.\n.In getPowerSet(\"BC\") part 1, get sets without head 'B'\n..In getPowerSet(\"C\"), start.\n..In getPowerSet(\"C\") part 1, get sets without head 'C'\n...In getPowerSet(\"\"), start.\n...In getPowerSet(\"\") base case returns ['']\n..In getPowerSet(\"C\") part 2, get sets with head 'C'\n..In getPowerSet(\"C\") New set C\n..In getPowerSet(\"C\") returning ['C', '']\n.In getPowerSet(\"BC\") part 2, get sets with head 'B'\n.In getPowerSet(\"BC\") New set BC\n.In getPowerSet(\"BC\") New set B\n.In getPowerSet(\"BC\") returning ['BC', 'B', 'C', '']\nIn getPowerSet(\"ABC\") part 2, get sets with head 'A'\nIn getPowerSet(\"ABC\") New set ABC\nIn getPowerSet(\"ABC\") New set AB\nIn getPowerSet(\"ABC\") New set AC\nIn getPowerSet(\"ABC\") New set A\nIn getPowerSet(\"ABC\") returning ['ABC', 'AB', 'AC', 'A', 'BC', 'B', 'C', '']\n['ABC', 'AB', 'AC', 'A', 'BC', 'B', 'C', '']\n```", "```py\n>>> **def subtract(number1, number2):**\n...     **return number1 - number2**\n...\n>>> **subtract(123, 987)**\n-864\n```", "```py\n>>> **TOTAL = 0**\n>>> **def addToTotal(amount):**\n...     **global TOTAL**\n...     **TOTAL += amount**\n...     **return TOTAL**\n...\n>>> **addToTotal(10)**\n10\n>>> **addToTotal(10)**\n20\n>>> **TOTAL**\n20\n```", "```py\n**fibonacciCache = {}** \u2776 **# Create the global cache.**\n\ndef fibonacci(nthNumber, indent=0):\n    **global fibonacciCache**\n    indentation = '.' * indent\n    print(indentation + 'fibonacci(%s) called.' % (nthNumber))\n\n **if nthNumber in fibonacciCache:**\n        **# If the value was already cached, return it.**\n **print(indentation + 'Returning memoized result: %s' % (fibonacciCache[nthNumber]))**\n        **return fibonacciCache[nthNumber]** \u2777\n\n    if nthNumber == 1 or nthNumber == 2:\n        # BASE CASE\n        print(indentation + 'Base case fibonacci(%s) returning 1.' % (nthNumber))\n        **fibonacciCache[nthNumber] = 1** \u2778 **# Update the cache.**\n        return 1\n    else:\n        # RECURSIVE CASE\n        print(indentation + 'Calling fibonacci(%s) (nthNumber - 1).' % (nthNumber - 1))\n        result = fibonacci(nthNumber - 1, indent + 1)\n\n        print(indentation + 'Calling fibonacci(%s) (nthNumber - 2).' % (nthNumber - 2))\n        result = result + fibonacci(nthNumber - 2, indent + 1)\n\n        print('Call to fibonacci(%s) returning %s.' % (nthNumber, result))\n        **fibonacciCache[nthNumber] = result** \u2779 **# Update the cache.**\n        return result\n\nprint(fibonacci(10))\n**print(fibonacci(10))** \u277a\n```", "```py\n<script type=\"text/javascript\">\n\n\u2776 **let fibonacciCache = {}; // Create the global cache.**\n\nfunction fibonacci(nthNumber, indent) {\n    if (indent === undefined) {\n        indent = 0;\n    }\n    let indentation = '.'.repeat(indent);\n    document.write(indentation + \"fibonacci(\" + nthNumber + \") called.\n<br />\");\n\n    **if (nthNumber in fibonacciCache) {**\n        **// If the value was already cached, return it.**\n **document.write(indentation +** \n **\"Returning memoized result: \" + fibonacciCache[nthNumber] + \"<br />\");**\n      \u2777 **return fibonacciCache[nthNumber];**\n    **}**\n\n    if (nthNumber === 1 || nthNumber === 2) {\n        // BASE CASE\n        document.write(indentation + \n        \"Base case fibonacci(\" + nthNumber + \") returning 1.<br />\");\n      \u2778 **fibonacciCache[nthNumber] = 1; // Update the cache.**\n        return 1;\n } else {\n        // RECURSIVE CASE\n        document.write(indentation + \n        \"Calling fibonacci(\" + (nthNumber - 1) + \") (nthNumber - 1).<br />\");\n        let result = fibonacci(nthNumber - 1, indent + 1);\n\n        document.write(indentation + \n        \"Calling fibonacci(\" + (nthNumber - 2) + \") (nthNumber - 2).<br />\");\n        result = result + fibonacci(nthNumber - 2, indent + 1);\n\n        document.write(indentation + \"Returning \" + result + \".<br />\");\n      \u2779 **fibonacciCache[nthNumber] = result; // Update the cache.**\n        return result;\n    }\n}\n\ndocument.write(\"<pre>\");\ndocument.write(fibonacci(10) + \"<br />\");\n\u277a **document.write(fibonacci(10) + \"<br />\");**\ndocument.write(\"</pre>\");\n</script>\n```", "```py\nfibonacci(10) called.\nCalling fibonacci(9) (nthNumber - 1).\n.fibonacci(9) called.\n.Calling fibonacci(8) (nthNumber - 1).\n..fibonacci(8) called.\n..Calling fibonacci(7) (nthNumber - 1).\n`--snip--`\n.......Calling fibonacci(2) (nthNumber - 1).\n........fibonacci(2) called.\n........Base case fibonacci(2) returning 1.\n.......Calling fibonacci(1) (nthNumber - 2).\n........fibonacci(1) called.\n........Base case fibonacci(1) returning 1.\nCall to fibonacci(3) returning 2.\n......Calling fibonacci(2) (nthNumber - 2).\n.......fibonacci(2) called.\n.......Returning memoized result: 1\n`--snip--`\nCalling fibonacci(8) (nthNumber - 2).\n.fibonacci(8) called.\n.Returning memoized result: 21\nCall to fibonacci(10) returning 55.\n55\nfibonacci(10) called.\nReturning memoized result: 55\n55\n```", "```py\n**import functools**\n\n**@functools.lru_cache()**\ndef fibonacci(nthNumber):\n    print('fibonacci(%s) called.' % (nthNumber))\n if nthNumber == 1 or nthNumber == 2:\n        # BASE CASE\n        print('Call to fibonacci(%s) returning 1.' % (nthNumber))\n        return 1\n    else:\n        # RECURSIVE CASE\n        print('Calling fibonacci(%s) (nthNumber - 1).' % (nthNumber - 1))\n        result = fibonacci(nthNumber - 1)\n\n        print('Calling fibonacci(%s) (nthNumber - 2).' % (nthNumber - 2))\n        result = result + fibonacci(nthNumber - 2)\n\n        print('Call to fibonacci(%s) returning %s.' % (nthNumber, result))\n        return result\n\nprint(fibonacci(99))\n```", "```py\nimport functools, time, datetime\n\n@functools.lru_cache()\ndef getCurrentTime():\n    # This nondeterministic function returns different values each time\n    # it's called.\n    return datetime.datetime.now()\n\n@functools.lru_cache()\ndef printMessage():\n    # This function displays a message on the screen as a side effect.\n print('Hello, world!')\n\nprint('Getting the current time twice:')\nprint(getCurrentTime())\nprint('Waiting two seconds...')\ntime.sleep(2)\nprint(getCurrentTime())\n\nprint()\n\nprint('Displaying a message twice:')\nprintMessage()\nprintMessage()\n```", "```py\nGetting the current time twice:\n2022-07-30 16:25:52.136999\nWaiting two seconds...\n2022-07-30 16:25:52.136999\n\nDisplaying a message twice:\nHello, world!\n```", "```py\ndef factorial(number, accum=1):\n    if number == 1:\n        # BASE CASE\n        return accum\n    else:\n        # RECURSIVE CASE\n        return factorial(number - 1, accum * number)\n\nprint(factorial(5))\n```", "```py\n<script type=\"text/javascript\">\nfunction factorial(number, accum=1) {\n    if (number === 1) {\n        // BASE CASE\n        return accum;\n    } else {\n        // RECURSIVE CASE\n        return factorial(number - 1, accum * number);\n    }\n}\n\ndocument.write(factorial(5));\n</script>\n```", "```py\n\u2776 def rev(theString, accum=''):\n    if len(theString) == 0:\n        # BASE CASE\n      \u2777 return accum\n    else:\n        # RECURSIVE CASE\n        head = theString[0]\n        tail = theString[1:]\n      \u2778 return rev(tail, head + accum)\n\ntext = 'abcdef'\nprint('The reverse of ' + text + ' is ' + rev(text))\n```", "```py\n<script type=\"text/javascript\">\n\u2776 function rev(theString, accum='') {\n    if (theString.length === 0) {\n        // BASE CASE\n      \u2777 return accum;\n    } else {\n        // RECURSIVE CASE\n        let head = theString[0];\n        let tail = theString.substring(1, theString.length);\n      \u2778 return rev(tail, head + accum);\n    }\n}\n\nlet text = \"abcdef\";\ndocument.write(\"The reverse of \" + text + \" is \" + rev(text) + \"<br />\");\n</script>\n```", "```py\n`--snip--`\n    elif n % 2 == 0:\n        # RECURSIVE CASE (when n is even)\n        result = exponentByRecursion(a, n / 2)\n        return result * result\n`--snip--`\n```", "```py\n`--snip--` \n  } else if (n % 2 === 0) {\n        // RECURSIVE CASE (when n is even)\n        result = exponentByRecursion(a, n / 2);\n        return result * result; \n`--snip--`\n```", "```py\n`--snip--`\nreturn exponentByRecursion(a, n / 2) * exponentByRecursion(a, n / 2)\n`--snip--`\n```", "```py\ndef isOdd(number):\n    if number == 0:\n        # BASE CASE\n        return False\n    else:\n        # RECURSIVE CASE\n        return not isOdd(number - 1)\nprint(isOdd(42))\nprint(isOdd(99))\n`--snip--`\n```", "```py\n<script type=\"text/javascript\">\n\nfunction isOdd(number) {\n    if (number === 0) {\n        // BASE CASE\n        return false;\n } else {\n        // RECURSIVE CASE\n        return !isOdd(number - 1);\n    }\n}\ndocument.write(isOdd(42) + \"<br />\");\ndocument.write(isOdd(99) + \"<br />\");\n`--snip--`\n```", "```py\n`--snip--`\ndef isOddTailCall(number, inversionAccum=False):\n    if number == 0:\n        # BASE CASE\n        return inversionAccum\n    else:\n        # RECURSIVE CASE\n        return isOddTailCall(number - 1, not inversionAccum)\n\nprint(isOddTailCall(42))\nprint(isOddTailCall(99))\n```", "```py\n`--snip--`\nfunction isOddTailCall(number, inversionAccum) {\n    if (inversionAccum === undefined) {\n        inversionAccum = false;\n    }\n\n    if (number === 0) {\n        // BASE CASE\n        return inversionAccum;\n    } else {\n // RECURSIVE CASE\n        return isOddTailCall(number - 1, !inversionAccum);\n    }\n}\n\ndocument.write(isOdd(42) + \"<br />\");\ndocument.write(isOdd(99) + \"<br />\");\n</script>\n```", "```py\nimport turtle\nturtle.tracer(1, 0) # Makes the turtle draw faster.\nfor i in range(360):\n    turtle.forward(i)\n    turtle.left(59)\nturtle.exitonclick() # Pause until user clicks in the window.\n```", "```py\n**for (let i = 0; i < 360; i++) { t.fd(i); t.lt(59) }**\n```", "```py\nimport turtle\nturtle.tracer(100, 0) # Increase the first argument to speed up the drawing.\nturtle.setworldcoordinates(0, 0, 700, 700)\nturtle.hideturtle()\n\nMIN_SIZE = 4 # Try changing this to decrease/increase the amount of recursion.\n\ndef midpoint(startx, starty, endx, endy):\n    # Return the x, y coordinate in the middle of the four given parameters.\n    xDiff = abs(startx - endx)\n    yDiff = abs(starty - endy)\n    return (min(startx, endx) + (xDiff / 2.0), min(starty, endy) + (yDiff / 2.0))\n\ndef isTooSmall(ax, ay, bx, by, cx, cy):\n    # Determine if the triangle is too small to draw.\n    width = max(ax, bx, cx) - min(ax, bx, cx)\n    height = max(ay, by, cy) - min(ay, by, cy)\n    return width < MIN_SIZE or height < MIN_SIZE\n\ndef drawTriangle(ax, ay, bx, by, cx, cy):\n    if isTooSmall(ax, ay, bx, by, cx, cy):\n        # BASE CASE\n        return\n    else:\n        # RECURSIVE CASE\n        # Draw the triangle.\n        turtle.penup()\n        turtle.goto(ax, ay)\n        turtle.pendown()\n        turtle.goto(bx, by)\n        turtle.goto(cx, cy)\n        turtle.goto(ax, ay)\n        turtle.penup()\n\n        # Calculate midpoints between points A, B, and C.\n        mid_ab = midpoint(ax, ay, bx, by)\n        mid_bc = midpoint(bx, by, cx, cy)\n        mid_ca = midpoint(cx, cy, ax, ay)\n\n        # Draw the three inner triangles.\n        drawTriangle(ax, ay, mid_ab[0], mid_ab[1], mid_ca[0], mid_ca[1])\n        drawTriangle(mid_ab[0], mid_ab[1], bx, by, mid_bc[0], mid_bc[1])\n        drawTriangle(mid_ca[0], mid_ca[1], mid_bc[0], mid_bc[1], cx, cy)\n        return\n\n# Draw an equilateral Sierpinski triangle.\ndrawTriangle(50, 50, 350, 650, 650, 50)\n\n# Draw a skewed Sierpinski triangle.\n#drawTriangle(30, 250, 680, 600, 500, 80)\n\nturtle.exitonclick()\n```", "```py\nimport turtle\nturtle.tracer(10, 0) # Increase the first argument to speed up the drawing.\nturtle.setworldcoordinates(0, 0, 700, 700)\nturtle.hideturtle()\n\nMIN_SIZE = 6 # Try changing this to decrease/increase the amount of recursion.\nDRAW_SOLID = True\n\ndef isTooSmall(width, height):\n    # Determine if the rectangle is too small to draw.\n    return width < MIN_SIZE or height < MIN_SIZE\n\ndef drawCarpet(x, y, width, height):\n    # The x and y are the lower-left corner of the carpet.\n\n    # Move the pen into position.\n    turtle.penup()\n    turtle.goto(x, y)\n\n    # Draw the outer rectangle.\n    turtle.pendown()\n    if DRAW_SOLID:\n        turtle.fillcolor('black')\n        turtle.begin_fill()\n    turtle.goto(x, y + height)\n    turtle.goto(x + width, y + height)\n    turtle.goto(x + width, y)\n    turtle.goto(x, y)\n    if DRAW_SOLID:\n        turtle.end_fill()\n    turtle.penup()\n\n    # Draw the inner rectangles.\n    drawInnerRectangle(x, y, width, height)\n\ndef drawInnerRectangle(x, y, width, height):\n    if isTooSmall(width, height):\n        # BASE CASE\n        return\n    else:\n        # RECURSIVE CASE\n\n        oneThirdWidth = width / 3\n        oneThirdHeight = height / 3\n        twoThirdsWidth = 2 * (width / 3)\n        twoThirdsHeight = 2 * (height / 3)\n\n # Move into position.\n        turtle.penup()\n        turtle.goto(x + oneThirdWidth, y + oneThirdHeight)\n\n        # Draw the inner rectangle.\n        if DRAW_SOLID:\n            turtle.fillcolor('white')\n            turtle.begin_fill()\n        turtle.pendown()\n        turtle.goto(x + oneThirdWidth, y + twoThirdsHeight)\n        turtle.goto(x + twoThirdsWidth, y + twoThirdsHeight)\n        turtle.goto(x + twoThirdsWidth, y + oneThirdHeight)\n        turtle.goto(x + oneThirdWidth, y + oneThirdHeight)\n        turtle.penup()\n        if DRAW_SOLID:\n            turtle.end_fill()\n\n        # Draw the inner rectangles across the top.\n        drawInnerRectangle(x, y + twoThirdsHeight, oneThirdWidth, oneThirdHeight)\n        drawInnerRectangle(x + oneThirdWidth, y + twoThirdsHeight, oneThirdWidth, oneThirdHeight)\n        drawInnerRectangle(x + twoThirdsWidth, y + twoThirdsHeight, oneThirdWidth, oneThirdHeight)\n\n        # Draw the inner rectangles across the middle.\n        drawInnerRectangle(x, y + oneThirdHeight, oneThirdWidth, \n        oneThirdHeight)\n        drawInnerRectangle(x + twoThirdsWidth, y + oneThirdHeight, oneThirdWidth, \n        oneThirdHeight)\n\n        # Draw the inner rectangles across the bottom.\n        drawInnerRectangle(x, y, oneThirdWidth, oneThirdHeight)\n        drawInnerRectangle(x + oneThirdWidth, y, oneThirdWidth, oneThirdHeight)\n        drawInnerRectangle(x + twoThirdsWidth, y, oneThirdWidth, \n        oneThirdHeight)\n\ndrawCarpet(50, 50, 600, 600)\nturtle.exitonclick()\n```", "```py\nimport random\nimport time\nimport turtle\nturtle.tracer(1000, 0) # Increase the first argument to speed up the drawing.\nturtle.setworldcoordinates(0, 0, 700, 700)\nturtle.hideturtle()\n\ndef drawBranch(startPosition, direction, branchLength):\n    if branchLength < 5:\n        # BASE CASE\n        return\n\n    # Go to the starting point & direction.\n    turtle.penup()\n    turtle.goto(startPosition)\n    turtle.setheading(direction)\n\n    # Draw the branch (thickness is 1/7 the length).\n    turtle.pendown()\n    turtle.pensize(max(branchLength / 7.0, 1))\n    turtle.forward(branchLength)\n\n    # Record the position of the branch's end.\n    endPosition = turtle.position()\n    leftDirection = direction + LEFT_ANGLE\n    leftBranchLength = branchLength - LEFT_DECREASE\n    rightDirection = direction - RIGHT_ANGLE\n    rightBranchLength = branchLength - RIGHT_DECREASE\n\n # RECURSIVE CASE\n    drawBranch(endPosition, leftDirection, leftBranchLength)\n    drawBranch(endPosition, rightDirection, rightBranchLength)\n\nseed = 0\nwhile True:\n    # Get pseudorandom numbers for the branch properties.\n    random.seed(seed)\n    LEFT_ANGLE     = random.randint(10,  30)\n    LEFT_DECREASE  = random.randint( 8,  15)\n    RIGHT_ANGLE    = random.randint(10,  30)\n    RIGHT_DECREASE = random.randint( 8,  15)\n    START_LENGTH   = random.randint(80, 120)\n\n    # Write out the seed number.\n    turtle.clear()\n    turtle.penup()\n    turtle.goto(10, 10)\n    turtle.write('Seed: %s' % (seed))\n\n    # Draw the tree.\n    drawBranch((350, 10), 90, START_LENGTH)\n    turtle.update()\n    time.sleep(2)\n\n    seed = seed + 1\n```", "```py\n>>> **import random**\n>>> **random.seed(42)**\n>>> **[random.randint(0, 9) for i in range(20)]**\n [1, 0, 4, 3, 3, 2, 1, 8, 1, 9, 6, 0, 0, 1, 3, 3, 8, 9, 0, 8]\n>>> **[random.randint(0, 9) for i in range(20)]**\n [3, 8, 6, 3, 7, 9, 4, 0, 2, 6, 5, 4, 2, 3, 5, 1, 1, 6, 1, 5]\n>>> **random.seed(42)**\n>>> **[random.randint(0, 9) for i in range(20)]**\n [1, 0, 4, 3, 3, 2, 1, 8, 1, 9, 6, 0, 0, 1, 3, 3, 8, 9, 0, 8]\n```", "```py\n # Record the position of the branch's end.\n    endPosition = turtle.position()\n    leftDirection = direction + random.randint(10, 30)\n    leftBranchLength = branchLength - random.randint(8, 15)\n    rightDirection = direction - random.randint(10, 30)\n    rightBranchLength = branchLength - random.randint(8, 15)\n```", "```py\nimport turtle\nturtle.tracer(10, 0) # Increase the first argument to speed up the drawing.\nturtle.setworldcoordinates(0, 0, 700, 700)\nturtle.hideturtle()\nturtle.pensize(2)\n\ndef drawKochCurve(startPosition, heading, length):\n    if length < 1:\n        # BASE CASE\n        return\n    else:\n        # RECURSIVE CASE\n        # Move to the start position.\n        recursiveArgs = []\n        turtle.penup()\n        turtle.goto(startPosition)\n        turtle.setheading(heading)\n        recursiveArgs.append({'position':turtle.position(),\n                              'heading':turtle.heading()})\n\n        # Erase the middle third.\n        turtle.forward(length / 3)\n        turtle.pencolor('white')\n        turtle.pendown()\n turtle.forward(length / 3)\n\n        # Draw the bump.\n        turtle.backward(length / 3)\n        turtle.left(60)\n        recursiveArgs.append({'position':turtle.position(),\n                              'heading':turtle.heading()})\n        turtle.pencolor('black')\n        turtle.forward(length / 3)\n        turtle.right(120)\n        recursiveArgs.append({'position':turtle.position(),\n                              'heading':turtle.heading()})\n        turtle.forward(length / 3)\n        turtle.left(60)\n        recursiveArgs.append({'position':turtle.position(),\n                              'heading':turtle.heading()})\n\n        for i in range(4):\n            drawKochCurve(recursiveArgs[i]['position'],\n                     recursiveArgs[i]['heading'],\n                     length / 3)\n        return\n\ndef drawKochSnowflake(startPosition, heading, length):\n    # A Koch snowflake is three Koch curves in a triangle.\n\n    # Move to the starting position.\n    turtle.penup()\n    turtle.goto(startPosition)\n    turtle.setheading(heading)\n\n    for i in range(3):\n        # Record the starting position and heading.\n        curveStartingPosition = turtle.position()\n        curveStartingHeading = turtle.heading()\n        drawKochCurve(curveStartingPosition,\n                      curveStartingHeading, length)\n\n        # Move back to the start position for this side.\n        turtle.penup()\n        turtle.goto(curveStartingPosition)\n        turtle.setheading(curveStartingHeading)\n\n        # Move to the start position of the next side.\n        turtle.forward(length)\n        turtle.right(120)\n\ndrawKochSnowflake((100, 500), 0, 500)\nturtle.exitonclick()\n```", "```py\nimport turtle\nturtle.tracer(10, 0) # Increase the first argument to speed up the drawing.\nturtle.setworldcoordinates(0, 0, 700, 700)\nturtle.hideturtle()\n\nLINE_LENGTH  = 5 # Try changing the line length by a little.\nANGLE = 90 # Try changing the turning angle by a few degrees.\nLEVELS = 6 # Try changing the recursive level by a little.\nDRAW_SOLID = False\n#turtle.setheading(20) # Uncomment this line to draw the curve at an angle.\n\ndef hilbertCurveQuadrant(level, angle):\n    if level == 0:\n        # BASE CASE\n        return\n    else:\n        # RECURSIVE CASE\n        turtle.right(angle)\n        hilbertCurveQuadrant(level - 1, -angle)\n        turtle.forward(LINE_LENGTH)\n turtle.left(angle)\n        hilbertCurveQuadrant(level - 1, angle)\n        turtle.forward(LINE_LENGTH)\n        hilbertCurveQuadrant(level - 1, angle)\n        turtle.left(angle)\n        turtle.forward(LINE_LENGTH)\n        hilbertCurveQuadrant(level - 1, -angle)\n        turtle.right(angle)\n        return\n\ndef hilbertCurve(startingPosition):\n    # Move to starting position.\n    turtle.penup()\n    turtle.goto(startingPosition)\n    turtle.pendown()\n    if DRAW_SOLID:\n        turtle.begin_fill()\n\n    hilbertCurveQuadrant(LEVELS, ANGLE) # Draw lower-left quadrant.\n    turtle.forward(LINE_LENGTH)\n\n    hilbertCurveQuadrant(LEVELS, ANGLE) # Draw lower-right quadrant.\n    turtle.left(ANGLE)\n    turtle.forward(LINE_LENGTH)\n    turtle.left(ANGLE)\n\n    hilbertCurveQuadrant(LEVELS, ANGLE) # Draw upper-right quadrant.\n    turtle.forward(LINE_LENGTH)\n\n    hilbertCurveQuadrant(LEVELS, ANGLE) # Draw upper-left quadrant.\n\n    turtle.left(ANGLE)\n    turtle.forward(LINE_LENGTH)\n    turtle.left(ANGLE)\n    if DRAW_SOLID:\n        turtle.end_fill()\n\nhilbertCurve((30, 350))\nturtle.exitonclick()\n```"]
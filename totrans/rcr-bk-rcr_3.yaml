- en: Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: UNDERSTANDING RECURSION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 理解递归
- en: '1'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: What Is Recursion?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是递归？
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'Recursion has an intimidating reputation. It’s considered hard to understand,
    but at its core, it depends on only two things: function calls and stack data
    structures.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 递归有着令人望而生畏的声誉。人们认为很难理解，但其核心只依赖于两件事：函数调用和栈数据结构。
- en: 'Most new programmers trace through what a program does by following the execution.
    It’s an easy way to read code: you just put your finger on the line of code at
    the top of the program and move down. Sometimes your finger will loop back; other
    times, it will jump into a function and later return. This makes it easy to visualize
    what a program does and in what order.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数新程序员通过跟踪执行来追踪程序的操作。这是阅读代码的简单方法：你只需把手指放在程序顶部的代码行上，然后向下移动。有时你的手指会回到原点；其他时候，它会进入一个函数，然后返回。这使得很容易可视化程序的操作和顺序。
- en: But to understand recursion, you need to become familiar with a less obvious
    data structure, called the *call stack*, that controls the program’s flow of execution.
    Most programming beginners don’t know about stacks, because programming tutorials
    often don’t even mention them when discussing function calls. Furthermore, the
    call stack that automatically manages function calls doesn’t appear anywhere in
    the source code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但要理解递归，你需要熟悉一个不太明显的数据结构，称为*调用栈*，它控制程序的执行流程。大多数编程初学者不了解栈，因为编程教程在讨论函数调用时通常甚至不提及它们。此外，自动管理函数调用的调用栈在源代码中根本看不到。
- en: It’s hard to understand something when you can’t see it and don’t know it exists!
    In this chapter, we’ll pull back the curtain to dispel the overblown notion that
    recursion is hard, and you’ll be able to appreciate the elegance underneath.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '当你看不见并且不知道它的存在时，很难理解某件事！在本章中，我们将拉开窗帘，消除递归难以理解的夸大概念，你将能够欣赏其中的优雅之处。 '
- en: The Definition of Recursion
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归的定义
- en: 'Before we begin, let’s get the clichéd recursion jokes out of the way, starting
    with this: “To understand recursion, you must first understand recursion.”'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们先把陈词滥调的递归笑话搞定，比如：“要理解递归，你必须先理解递归。”
- en: During the months I’ve spent writing this book, I can assure you that this joke
    gets funnier the more you hear it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我写这本书的几个月里，我可以向你保证，这个笑话听得越多就越好笑。
- en: Another joke is that if you search Google for *recursion*, the results page
    asks if you mean *recursion*. Following the link, as shown in [Figure 1-1](#figure1-1),
    takes you to . . . the search results for *recursion*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个笑话是，如果你在谷歌上搜索*递归*，结果页面会问你是否是指*递归*。点击链接，如[图1-1](#figure1-1)所示，会带你到...*递归*的搜索结果。
- en: '![Screenshot of a Google search for the term “recursion.” Below the search
    bar is a banner that reads, “Did you mean: recursion.”](image_fi/502024c01/f01001.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![谷歌搜索术语“递归”的截图。在搜索栏下方是一个横幅，上面写着“您是不是要找：递归。”](image_fi/502024c01/f01001.png)'
- en: 'Figure 1-1: The Google search results for *recursion* link to the Google search
    results for *recursion*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-1：*递归*的谷歌搜索结果链接到*递归*的谷歌搜索结果。
- en: '[Figure 1-2](#figure1-2) shows a recursion joke from the webcomic xkcd.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-2](#figure1-2)显示了网络漫画xkcd中的一个递归笑话。'
- en: '![A one-panel comic of someone reading the text “I’m so meta, even this acronym.”](image_fi/502024c01/f01002.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![一个单格漫画，有人在读“我如此元，甚至这个首字母缩略词。”](image_fi/502024c01/f01002.png)'
- en: 'Figure 1-2: I’m So Meta, Even This Acronym (I.S. M.E.T.A.) ([xkcd.com/917](http://xkcd.com/917)
    by Randall Munroe)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2：我如此元，甚至这个首字母缩略词（I.S. M.E.T.A.）([xkcd.com/917](http://xkcd.com/917) by Randall
    Munroe)
- en: Most jokes about the 2010 science fiction action movie *Inception* are recursion
    jokes. The film features characters having dreams within dreams within dreams.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于2010年科幻动作电影《盗梦空间》的大多数笑话都是递归笑话。电影中的角色在梦中有梦，而这些梦中还有梦。
- en: And finally, what computer scientist could forget that monster from Greek mythology,
    the recursive centaur? As you can see in [Figure 1-3](#figure1-3), it is half
    horse, half recursive centaur.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为计算机科学家，谁能忘记希腊神话中的递归半人马怪物？正如你在[图1-3](#figure1-3)中所看到的，它是半马半递归半人马。
- en: '![Image of a statue with a horse’s body whose front legs and torso repeat,
    decreasing in size, in a spiral pattern.](image_fi/502024c01/f01003.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图中是一个雕像，有马的身体，前腿和躯干呈螺旋状重复，尺寸逐渐减小。](image_fi/502024c01/f01003.png)'
- en: 'Figure 1-3: The recursive centaur. Image by Joseph Parker.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3：递归半人马。Joseph Parker提供的图片。
- en: 'Based on these jokes, you might conclude that recursion is a sort of meta,
    self-referencing, dream-within-a-dream, infinite mirror-into-mirror sort of thing.
    Let’s establish a concrete definition: a *recursive* thing is something whose
    definition includes itself. That is, it has a self-referential definition.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些笑话，你可能会得出结论，递归是一种元、自我引用、梦中梦、无限镜中镜的东西。让我们建立一个具体的定义：*递归*是指其定义包括自身的东西。也就是说，它具有自我引用的定义。
- en: The Sierpiński triangle in [Figure 1-4](#figure1-4) is defined as an equilateral
    triangle with an upside-down triangle in the middle that forms three new equilateral
    triangles, each of which contains a Sierpiński triangle. The definition of Sierpiński
    triangles includes Sierpiński triangles.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-4](#figure1-4)中的谢尔宾斯基三角形被定义为一个等边三角形，中间有一个倒置的三角形，形成三个新的等边三角形，每个三角形都包含一个谢尔宾斯基三角形。谢尔宾斯基三角形的定义包括谢尔宾斯基三角形。'
- en: '![Graphic depicting three triangles. The first triangle has a smaller upside-down
    triangle in the center that divides the original into smaller triangles. The next
    triangle shows those three smaller outer triangles, each divided into still smaller
    triangles. The third triangle shows those smaller triangles further divided into
    triangles.](image_fi/502024c01/f01004.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图形描绘了三角形。第一个三角形中间有一个较小的倒置三角形，将原始三角形分成较小的三角形。下一个三角形显示了这三个较小的外部三角形，每个都分成更小的三角形。第三个三角形显示了这些更小的三角形进一步分成三角形。](image_fi/502024c01/f01004.png)'
- en: 'Figure 1-4: Sierpiński triangles are fractals (recursive shapes) that include
    Sierpiński triangles.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4：谢尔宾斯基三角形是包含谢尔宾斯基三角形的分形（递归形状）。
- en: In a programming context, a *recursive function* is a function that calls itself.
    Before we explore recursive functions, let’s take a step back and understand how
    regular functions work. Programmers tend to take function calls for granted, but
    even experienced programmers will find it worthwhile to review functions in the
    next section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程上下文中，*递归函数*是调用自身的函数。在我们探索递归函数之前，让我们退一步，了解正常函数是如何工作的。程序员往往认为函数调用理所当然，但即使是有经验的程序员也会发现值得回顾下一节中的函数。
- en: What Are Functions?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是函数？
- en: '*Functions* can be described as mini-programs inside your program. They’re
    a feature of nearly every programming language. If you need to run identical instructions
    at three different places in a program, instead of copying and pasting the source
    code three times you can write the code in a function once and call the function
    three times. The beneficial result is a shorter and more readable program. The
    program is also easier to change: if you need to fix a bug or add features, you
    need to change your program in only one place instead of three.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*可以被描述为程序中的迷你程序。它们是几乎每种编程语言的特性。如果您需要在程序中的三个不同位置运行相同的指令，而不是将源代码复制粘贴三次，您可以在函数中编写一次代码并调用函数三次。有益的结果是更短和更易读的程序。程序也更容易更改：如果您需要修复错误或添加功能，您只需要在一个地方更改程序，而不是三个地方。'
- en: 'All programming languages implement four features in their functions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程语言在它们的函数中实现了四个特性：
- en: Functions have code that is run when the function is called.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数有在调用函数时运行的代码。
- en: '*Arguments* (that is, values) are passed to the function when it’s called.
    This is the input to the function, and functions can have zero or more arguments.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*参数*（即值）在调用函数时传递。这是函数的输入，函数可以有零个或多个参数。'
- en: Functions return a *return value*. This is the output of the function, though
    some programming languages allow functions not to return anything or to return
    null values like `undefined` or `None`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数返回一个*返回值*。这是函数的输出，尽管一些编程语言允许函数不返回任何东西或返回像`undefined`或`None`这样的空值。
- en: The program remembers which line of code called the function and returns to
    it when the function finishes its execution.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序记住了调用函数的代码行，并在函数完成执行时返回到它。
- en: Different programming languages might have additional features, or different
    options for how to call functions, but they all have these four general elements.
    You can visually see the first three of these elements because you write them
    in the source code, but how does a program keep track of where the execution should
    return to when the function returns?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言可能具有其他特性，或者对如何调用函数有不同的选项，但它们都具有这四个一般元素。您可以在源代码中直观地看到这四个元素中的前三个，但是当函数返回时，程序如何跟踪执行应该返回到哪里呢？
- en: 'To get a better sense of the problem, create a *functionCalls.py* program that
    has three functions: `a()`, which calls `b()`, which calls `c()`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解问题，创建一个*functionCalls.py*程序，其中包含三个函数：`a()`调用`b()`，`b()`调用`c()`：
- en: '**Python**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code is equivalent to the following *functionCalls.html* program:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码等同于以下*functionCalls.html*程序：
- en: '**JavaScript**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you run this code, the output looks like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，输出如下：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output shows the start of functions `a()`, `b()`, and `c()`. Then, when
    the functions return, the output appears in reverse order: `c()`, `b()`, and then
    `a()`. Notice the pattern to the text output: each time a function returns, it
    remembers which line of code originally called it. When the `c()` function call
    ends, the program returns to the `b()` function and displays `b() is returning`.
    Then the `b()` function call ends, and the program returns to the `a()` function
    and displays `a() is returning`. Finally, the program returns to the original
    `a()` function call at the end of the program. In other words, function calls
    don’t send the execution of the program on a one-way trip.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了函数`a()`，`b()`和`c()`的开始。然后，当函数返回时，输出以相反的顺序出现：`c()`，`b()`，然后是`a()`。注意文本输出的模式：每次函数返回时，它都记住了最初调用它的代码行。当`c()`函数调用结束时，程序返回到`b()`函数并显示`b()正在返回`。然后`b()`函数调用结束，程序返回到`a()`函数并显示`a()正在返回`。最后，程序返回到程序末尾的原始`a()`函数调用。换句话说，函数调用并不会使程序的执行成为单向行程。
- en: But how does the program remember if it was `a()` or `b()` that called `c()`?
    This detail is handled by the program implicitly with a call stack. To understand
    how call stacks remember where the execution returns at the end of a function
    call, we need to first understand what a stack is.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但程序如何记住是`a()`还是`b()`调用了`c()`？这个细节由程序隐式处理，使用一个调用栈。要理解调用栈如何记住函数调用结束时执行返回的位置，我们首先需要了解栈是什么。
- en: What Are Stacks?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是栈？
- en: 'Earlier I mentioned the clichéd wisecrack, “To understand recursion, you must
    first understand recursion.” But this is actually wrong: to really understand
    recursion, you must first understand stacks.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我提到过一个陈词滥调的笑话，“要理解递归，你必须先理解递归。”但这实际上是错误的：要真正理解递归，你必须先理解栈。
- en: A *stack* is one of the simplest data structures in computer science. It stores
    multiple values like a list does—but unlike lists, it limits you to adding to
    or removing values from the “top” of the stack only. For stacks implemented with
    lists or arrays, the “top” is the last item, at the right end of the list or array.
    Adding values is called *pushing* values onto the stack, while removing values
    is called *popping* values off the stack.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*栈*是计算机科学中最简单的数据结构之一。它像列表一样存储多个值，但与列表不同的是，它只限制您在栈的“顶部”添加或删除值。对于使用列表或数组实现的栈，“顶部”是最后一个项目，在列表或数组的右端。添加值称为*推送*值到栈上，而删除值称为*弹出*值出栈。'
- en: Imagine that you’re engaged in a meandering conversation with someone. You’re
    talking about your friend Alice, which then reminds you of a story about your
    co-worker Bob, but for that story to make sense, you first have to explain something
    about your cousin Carol. You finish your story about Carol and go back to talking
    about Bob, and when you finish your story about Bob, you go back to talking about
    Alice. Then you are reminded about your brother David, so you tell a story about
    him. Eventually, you get around to finishing your original story about Alice.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您正在与某人进行一场漫谈。您正在谈论您的朋友Alice，然后想起了关于您同事Bob的故事，但为了讲清楚这个故事，您首先必须解释一些关于您表妹Carol的事情。您讲完了关于Carol的故事，然后回到谈论Bob，当您讲完了关于Bob的故事后，您又回到了谈论Alice。然后您想起了您的兄弟David，于是您讲了一个关于他的故事。最终，您回到了最初关于Alice的故事。
- en: Your conversation follows a stack-like structure, as in [Figure 1-5](#figure1-5).
    The conversation is stack-like because the current topic is always at the top
    of the stack.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您的对话遵循类似堆栈的结构，就像[图1-5](#figure1-5)中的那样。对话类似于堆栈，因为当前话题总是在堆栈的顶部。
- en: '![A timeline that shows names stacked one on top of the other at various points
    in time. It begins with no names, then shows Alice, then Bob on top of Alice,
    then Carol on top of Bob on top of Alice, then Bob on top of Alice, then just
    Alice, then David on top of Alice, then Just Alice once more, then no names.](image_fi/502024c01/f01005.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![一个时间轴，显示了各个时间点上叠放在一起的名字。它从没有名字开始，然后显示了Alice，然后是Alice上面的Bob，然后是Alice上面的Bob上面的Carol，然后是Alice上面的Bob，然后只有Alice，然后是Alice上面的David，然后再次只有Alice，最后没有名字。](image_fi/502024c01/f01005.png)'
- en: 'Figure 1-5: Your meandering conversation stack'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-5：您的漫谈对话堆栈
- en: In our conversation stack, the new topics are added to the top of the stack
    and taken off as they are completed. The previous topics are “remembered” underneath
    the current topic in the stack.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的对话堆栈中，新话题被添加到堆栈的顶部，并在完成时被移除。之前的话题在堆栈中的当前话题下面被“记住”。
- en: We can use Python lists as stacks if, to amend the list’s contents, we limit
    ourselves to the `append()` and `pop()` methods to perform pushing and popping.
    JavaScript arrays can also be used as stacks through their `push()` and `pop()`
    methods.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们限制自己使用`append()`和`pop()`方法来执行推入和弹出操作，我们可以将Python列表用作堆栈。JavaScript数组也可以通过它们的`push()`和`pop()`方法用作堆栈。
- en: 'For example, consider this *cardStack.py* program, which pushes and pops string
    values of playing cards to the end of a list named `cardStack`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个*cardStack.py*程序，它将扑克牌的字符串值推入和弹出到名为`cardStack`的列表的末尾：
- en: '**Python**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following *cardStack.html* program contains the equivalent code in JavaScript:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的*cardStack.html*程序包含了JavaScript中的等效代码：
- en: '**JavaScript**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you run this code, the output looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，输出如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The stack starts off as empty ❶. Three strings representing cards are pushed
    onto the stack ❷. Then the stack is popped ❸, which removes the ace of hearts
    and leaves the three of clubs at the top of the stack again. The state of the
    `cardStack` stack is tracked in [Figure 1-6](#figure1-6), going from left to right.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈从空开始❶。推入堆栈的是代表卡片的三个字符串❷。然后弹出堆栈❸，这将移除红桃A并再次将梅花三放在堆栈的顶部。`cardStack`堆栈的状态在[图1-6](#figure1-6)中进行了跟踪，从左到右。
- en: '![Timeline showing playing cards stacked on top of each other at various points
    in time. Begins with no cards, then the five of diamonds, then the three of clubs
    on top of the five of diamonds, then the ace of hearts on top of the three of
    clubs, and finally the ace of hearts removed to reveal the three of clubs.](image_fi/502024c01/f01006.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴显示了在不同时间点上叠放在一起的扑克牌。从没有扑克牌开始，然后是方块五，然后是梅花三叠在方块五上面，然后是红桃A叠在梅花三上面，最后移除红桃A以显示梅花三。](image_fi/502024c01/f01006.png)'
- en: 'Figure 1-6: The stack starts empty. Cards are then pushed onto and popped off
    the stack.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-6：堆栈开始为空。然后将卡片推入和弹出堆栈。
- en: You can see only the topmost card in the card stack, or, in our program’s stacks,
    the topmost value. In the simplest stack implementations, you can’t see how many
    cards (or values) are in the stack. You can see only whether the stack is empty
    or not.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能看到卡堆中的最顶部卡片，或者在我们程序的堆栈中，最顶部的值。在最简单的堆栈实现中，您无法看到堆栈中有多少张卡片（或值）。您只能看到堆栈是否为空。
- en: Stacks are a *LIFO* data structure, which stands for *last in, first out*, since
    the last value pushed onto the stack is the first value popped out of it. This
    behavior is similar to your web browser’s Back button. Your browser tab’s history
    functions like a stack that contains all the pages you’ve visited in the order
    that you visited them. The browser is always displaying the web page at the “top”
    of the history’s “stack.” Clicking a link pushes a new web page onto the history
    stack, while clicking the Back button pops the top web page off and reveals the
    one “underneath.”
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈是一种*LIFO*数据结构，代表*后进先出*，因为推入堆栈的最后一个值是弹出的第一个值。这种行为类似于您的网络浏览器的“返回”按钮。您的浏览器标签的历史记录就像一个包含您按顺序访问的所有页面的堆栈。浏览器始终显示历史记录“堆栈”中的顶部网页。单击链接会将新网页推入历史记录堆栈，而单击“返回”按钮会弹出顶部网页并显示其下面的网页。
- en: What Is the Call Stack?
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用堆栈是什么？
- en: Programs use stacks too. The program’s *call stack*, also simply called *the
    stack*, is a stack of frame objects. *Frame objects*, also simply called *frames*,
    contain information about a single function call, including which line of code
    called the function, so the execution can move back there when the function returns.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 程序也使用堆栈。程序的*调用堆栈*，也简称为*堆栈*，是一堆帧对象。*帧对象*，也简称为*帧*，包含有关单个函数调用的信息，包括调用函数的代码行，因此当函数返回时，执行可以回到那里。
- en: Frame objects are created and pushed onto the stack when a function is called.
    When the function returns, that frame object is popped off the stack. If we call
    a function that calls a function that calls a function, the call stack will have
    three frame objects on the stack. When all these functions return, the call stack
    will have zero frame objects on the stack.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，将创建帧对象并将其推送到堆栈上。当函数返回时，该帧对象将从堆栈中弹出。如果我们调用一个调用一个调用函数的函数，调用堆栈将在堆栈上有三个帧对象。当所有这些函数返回时，调用堆栈将在堆栈上有零个帧对象。
- en: 'Programmers don’t have to write code dealing with frame objects, since the
    programming language handles them automatically. Different programming languages
    have different ways of implementing frame objects, but in general they contain
    the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员不必编写处理帧对象的代码，因为编程语言会自动处理它们。不同的编程语言有不同的实现帧对象的方式，但通常它们包含以下内容：
- en: The return address, or the spot in the program where the execution should move
    when the function returns
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回地址，或者函数返回时执行的位置
- en: The arguments passed to the function call
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给函数调用的参数
- en: A set of local variables created during the function call
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数调用期间创建的一组局部变量
- en: 'For example, take a look at the following *localVariables.py* program, which
    has three functions, just as our previous *functionCalls.py* and *functionCalls.html*
    programs did:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下以下*localVariables.py*程序，它有三个函数，就像我们之前的*functionCalls.py*和*functionCalls.html*程序一样：
- en: '**Python**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This *localVariables.html* is the equivalent JavaScript program:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*localVariables.html*是等效的JavaScript程序：
- en: '**JavaScript**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you run this code, the output looks like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，输出如下所示：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the program calls function `a()` ❼, a frame object is created and placed
    on the top of the call stack. This frame stores any arguments passed to `a()`
    (in this case, there are none), along with the local variable `spam` ❶ and the
    place where the execution should go when the `a()` function returns.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序调用函数`a()` ❼时，将创建一个帧对象并将其放置在调用堆栈顶部。该帧存储传递给`a()`的任何参数（在本例中没有），以及局部变量`spam`
    ❶和`a()`函数返回时执行的位置。
- en: When `a()` is called, it displays the contents of its local `spam` variable,
    which is `Ant` ❷. When the code in `a()` calls function `b()` ❸, a new frame object
    is created and placed on the call stack above the frame object for `a()`. The
    `b()` function has its own local `spam` variable ❹, and calls `c()` ❺. A new frame
    object for the `c()` call is created and placed on the call stack, and it contains
    `c()`’s local `spam` variable ❻. As these functions return, the frame objects
    pop off the call stack. The program execution knows where to return to, because
    that return information is stored in the frame object. When the execution has
    returned from all function calls, the call stack is empty.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`a()`时，它显示其局部`spam`变量的内容，即`Ant` ❷。当`a()`中的代码调用函数`b()` ❸时，将创建一个新的帧对象并将其放置在调用堆栈上方，用于`a()`的帧对象。`b()`函数有自己的局部`spam`变量
    ❹，并调用`c()` ❺。为`c()`调用创建一个新的帧对象并将其放置在调用堆栈上，其中包含`c()`的局部`spam`变量 ❻。随着这些函数的返回，帧对象从调用堆栈中弹出。程序执行知道要返回到哪里，因为返回信息存储在帧对象中。当执行从所有函数调用返回时，调用堆栈为空。
- en: '[Figure 1-7](#figure1-7) shows the state of the call stack as each function
    is called and returns. Notice that all the local variables have the same name:
    `spam`. I did this to highlight the fact that local variables are always separate
    variables with distinct values, even if they have the same name as local variables
    in other functions.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-7](#figure1-7)显示了每个函数调用和返回时调用堆栈的状态。请注意，所有局部变量都具有相同的名称：`spam`。我这样做是为了突出局部变量始终是具有不同值的单独变量，即使它们与其他函数中的局部变量具有相同的名称。'
- en: '![Timeline depicting the state of a call stack at various points in time. It
    begins empty. Then, within the a() function, the spam variable equals “Ant.” Next,
    within the b() variable, spam equals “Bobcat,” and then within the c() function,
    spam equals “Coyote.” Within the b() function, spam once again equals “Bobcat,”
    and within the a() function, spam once again equals “Ant.”](image_fi/502024c01/f01007.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴描绘了调用堆栈在不同时间点的状态。它开始为空。然后，在a()函数中，spam变量等于“Ant”。接下来，在b()函数中，spam等于“Bobcat”，然后在c()函数中，spam等于“Coyote”。在b()函数中，spam再次等于“Bobcat”，在a()函数中，spam再次等于“Ant”。](image_fi/502024c01/f01007.png)'
- en: 'Figure 1-7: The state of the call stack as the *localVariables* program runs'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-7：*localVariables*程序运行时调用堆栈的状态
- en: As you can see, programming languages can have separate local variables with
    the same name (`spam`) because they are kept in separate frame objects. When a
    local variable is used in the source code, the variable with that name in the
    topmost frame object is used.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，编程语言可以具有相同名称（`spam`）的单独的局部变量，因为它们保存在单独的帧对象中。当在源代码中使用局部变量时，将使用顶部帧对象中具有该名称的变量。
- en: Every running program has a call stack, and multithreaded programs have one
    call stack for each thread. But when you look at the source code for a program,
    you can’t see the call stack in the code. The call stack isn’t stored in a variable
    as other data structures are; it’s automatically handled in the background.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行的程序都有一个调用堆栈，多线程程序每个线程都有一个调用堆栈。但是当您查看程序的源代码时，您无法在代码中看到调用堆栈。调用堆栈不像其他数据结构一样存储在变量中；它在后台自动处理。
- en: 'The fact that the call stack doesn’t exist in source code is the main reason
    recursion is so confusing to beginners: recursion relies on something the programmer
    can’t even see! Revealing how stack data structures and the call stack work removes
    much of the mystery behind recursion. Functions and stacks are both simple concepts,
    and we can use them together to understand how recursion works.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 调用堆栈在源代码中不存在的事实是递归对初学者如此令人困惑的主要原因：递归依赖于程序员甚至看不到的东西！揭示堆栈数据结构和调用堆栈的工作原理消除了递归背后的许多神秘之处。函数和堆栈都是简单的概念，我们可以将它们结合起来理解递归是如何工作的。
- en: What Are Recursive Functions and Stack Overflows?
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归函数和堆栈溢出是什么？
- en: 'A *recursive function* is a function that calls itself. This *shortest.py*
    program is the shortest possible example of a recursive function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归函数*是调用自身的函数。这个*shortest.py*程序是递归函数的最短可能示例：'
- en: '**Python**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding program is equivalent to this *shortest.html* program:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序等同于这个*shortest.html*程序：
- en: '**JavaScript**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `shortest()` function does nothing but call the `shortest()` function.
    When this happens, it calls the `shortest()` function again, and that will call
    `shortest()`, and so on, seemingly forever. It is similar to the mythological
    idea that the crust of the Earth rests on the back of a giant space turtle, which
    rests on the back of another turtle. Beneath that turtle: another turtle. And
    so on, forever.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortest()`函数除了调用`shortest()`函数什么也不做。当这发生时，它再次调用`shortest()`函数，然后`shortest()`会调用`shortest()`，依此类推，看起来永远不会停止。这类似于地壳靠着一只巨大的空间乌龟的背部，而那只乌龟又靠着另一只乌龟。在那只乌龟下面：另一只乌龟。如此循环，永无止境。'
- en: But this “turtles all the way down” theory doesn’t do a good job of explaining
    cosmology, nor recursive functions. Since the call stack uses the computer’s finite
    memory, this program cannot continue forever, the way an infinite loop does. The
    only thing this program does is crash and display an error message.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个“无穷递归”的理论并不能很好地解释宇宙学，也不能很好地解释递归函数。由于调用堆栈使用了计算机的有限内存，这个程序不能永远继续下去，就像无限循环那样。这个程序唯一能做的就是崩溃并显示错误消息。
- en: 'The Python output of *shortest.py* looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*shortest.py*的Python输出看起来像这样：'
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The JavaScript output of *shortest.html* looks like this in the Google Chrome
    web browser (other browsers will have similar error messages):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*shortest.html*的JavaScript输出在Google Chrome网页浏览器中看起来像这样（其他浏览器会有类似的错误消息）：'
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This kind of bug is called a *stack overflow*. (This is where the popular website
    [https://stackoverflow.com](https://stackoverflow.com) got its name.) The constant
    function calls with no returns grow the call stack until all the computer’s memory
    allocated for the call stack is used up. To prevent this, the Python and JavaScript
    interpreters crash the program after a certain limit of function calls that don’t
    return a value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误被称为*堆栈溢出*。（这就是流行网站[https://stackoverflow.com](https://stackoverflow.com)得名的地方。）不断的函数调用而没有返回会使调用堆栈增长，直到计算机为调用堆栈分配的所有内存都被用完。为了防止这种情况，Python和JavaScript解释器在一定数量的不返回值的函数调用后会终止程序。
- en: This limit is called the *maximum recursion depth*or *maximum call stack size*.
    For Python, this is set to 1,000 function calls. For JavaScript, the maximum call
    stack size depends on the browser running the code but is generally at least 10,000
    or so. Think of a stack overflow as happening when the call stack gets “too high”
    (that is, consumes too much computer memory), as in [Figure 1-8](#figure1-8).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制被称为*最大递归深度*或*最大调用堆栈大小*。对于Python，这被设置为1,000个函数调用。对于JavaScript，最大调用堆栈大小取决于运行代码的浏览器，但通常至少为10,000左右。把堆栈溢出想象成当调用堆栈变得“太高”（也就是消耗了太多的计算机内存）时发生，就像[图1-8](#figure1-8)中的情况。
- en: '![Graphic depicting a stack of cards with “c() spam = ‘Coyote’” written on
    the top card. A warning reads, “Stack too high.”](image_fi/502024c01/f01008.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图形描绘了一叠卡片，顶部卡片上写着“c() spam = ''Coyote''”。一个警告写着，“堆栈太高。”](image_fi/502024c01/f01008.png)'
- en: 'Figure 1-8: A stack overflow happens when the call stack becomes too high,
    with too many frame objects taking up the computer’s memory.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-8：当调用堆栈变得太高时，堆栈溢出就会发生，有太多的帧对象占用了计算机的内存。
- en: Stack overflows don’t damage the computer. The computer just detects that the
    limit of function calls without returns has been reached and terminates the program.
    At worst, you’ll lose any unsaved work the program had. Stack overflows can be
    prevented by having something called a *base case*, which is explained next.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈溢出不会损坏计算机。计算机只是检测到函数调用的限制已经达到并终止程序。最坏的情况下，你会丢失程序中的任何未保存的工作。堆栈溢出可以通过有一个叫做*基本情况*的东西来防止，接下来会解释。
- en: Base Cases and Recursive Cases
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本情况和递归情况
- en: The stack overflow example has a `shortest()` function that calls `shortest()`
    but never returns. To avoid a crash, there needs to be a case, or set of circumstances,
    where the function stops calling itself and instead just returns. This is called
    a *base case*. By contrast, a case where the function recursively calls itself
    is called a *recursive case*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈溢出示例有一个`shortest()`函数调用`shortest()`但从不返回。为了避免崩溃，需要有一个情况，或一组情况，使得函数停止调用自身，而是直接返回。这被称为*基本情况*。相比之下，函数递归调用自身的情况被称为*递归情况*。
- en: All recursive functions require at least one base case and at least one recursive
    case. If there is no base case, the function never stops making recursive calls
    and eventually causes a stack overflow. If there is no recursive case, the function
    never calls itself and is an ordinary function, not a recursive one. When you
    start writing your own recursive functions, a good first step is to figure out
    what the base case and recursive case should be.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有递归函数都需要至少一个基本情况和至少一个递归情况。如果没有基本情况，函数永远不会停止进行递归调用，最终导致堆栈溢出。如果没有递归情况，函数永远不会调用自身，只是一个普通函数，而不是递归函数。当你开始编写自己的递归函数时，一个很好的第一步是找出基本情况和递归情况应该是什么。
- en: 'Take a look at this *shortestWithBaseCase.py* program, which defines the shortest
    recursive function that won’t crash from a stack overflow:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个*shortestWithBaseCase.py*程序，它定义了不会因堆栈溢出而崩溃的最短递归函数：
- en: '**Python**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code is equivalent to the following *shortestWithBaseCase.html* program:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码等同于以下*shortestWithBaseCase.html*程序：
- en: '**JavaScript**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When you run this code, the output looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，输出看起来像这样：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function doesn’t do anything useful except provide a short example of recursion
    (and it could be made shorter by removing the text output, but the text is useful
    for our explanation). When `shortestWithBaseCase(False)` is called ❸, the base
    case is executed and the function merely returns ❶. However, when `shortestWithBaseCase(True)`
    is called ❹, the recursive case is executed and `shortestWithBaseCase(False)`
    is called ❷.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数除了提供递归的简短示例外并没有做任何有用的事情（并且通过删除文本输出可以使其更短，但文本对我们的解释很有用）。当调用`shortestWithBaseCase(False)`时❸，基本情况被执行，函数仅返回❶。然而，当调用`shortestWithBaseCase(True)`时❹，递归情况被执行，并调用`shortestWithBaseCase(False)`❷。
- en: It’s important to note that when `shortestWithBaseCase(False)` is recursively
    called from ❷ and then returns, the execution doesn’t immediately move back to
    the original function call at ❹. The rest of the code in the recursive case after
    the recursive call still runs, which is why `Returning from recursive case.` appears
    in the output. Returning from the base case doesn’t immediately return from all
    the recursive calls that happened before it. This will be important to keep in
    mind in the `countDownAndUp()` example in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当从❷递归调用`shortestWithBaseCase(False)`并返回时，执行不会立即回到❹处的原始函数调用。递归调用后的递归情况中的其余代码仍然会运行，这就是为什么输出中会出现`Returning
    from recursive case.`。从基本情况返回并不会立即返回到之前发生的所有递归调用。这在下一节中的`countDownAndUp()`示例中将是重要的要记住的。
- en: Code Before and After the Recursive Call
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归调用前后的代码
- en: 'The code in a recursive case can be split into two parts: the code before the
    recursive call and the code after the recursive call. (If there are two recursive
    calls in the recursive case, such as with the Fibonacci sequence example in Chapter
    2, there will be a before, a between, and an after. But let’s keep it simple for
    now.)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 递归情况中的代码可以分为两部分：递归调用前的代码和递归调用后的代码。（如果在递归情况中有两个递归调用，比如第2章中的斐波那契数列示例，那么会有一个前、一个中和一个后。但现在让我们保持简单。）
- en: The important thing to know is that reaching the base case doesn’t necessarily
    mean reaching the end of the recursive algorithm. It only means the base case
    won’t continue to make recursive calls.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，达到基本情况并不一定意味着递归算法的结束。它只意味着基本情况不会继续进行递归调用。
- en: 'For example, consider this *countDownAndUp.py* program whose recursive function
    counts from any number down to zero, and then back up to the number:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个*countDownAndUp.py*程序，其递归函数从任何数字倒数到零，然后再次升到该数字：
- en: '**Python**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the equivalent *countDownAndUp.html* program:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是等效的*countDownAndUp.html*程序：
- en: '**JavaScript**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you run this code, the output looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，输出如下：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Remember that every time a function is called, a new frame is created and pushed
    onto the call stack. This frame is where all the local variables and parameters
    (such as `number`) are stored. So, there is a separate `number variable for each
    frame on the call stack. This is another often confusing point about recursion:
    even though, from the source code, it looks like there is only one `number` variable,
    remember that because it is a local variable, there is actually a different `number`
    variable for each function call.`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每次调用函数时，都会创建一个新帧并推送到调用堆栈上。这个帧是存储所有局部变量和参数（如`number`）的地方。因此，对于调用堆栈上的每个帧都有一个单独的`number`变量。这是关于递归经常令人困惑的另一个要点：尽管从源代码看，似乎只有一个`number`变量，但请记併，因为它是局部变量，实际上对于每个函数调用都有一个不同的`number`变量。
- en: '`When `countDownAndUp(3)` is called ❺, a frame is created, and that frame’s
    local `number` variable is set to `3`. The function prints the `number` variable
    to the screen ❶. As long as `number` isn’t `0`, `countDownAndUp()` is recursively
    called with `number - 1` ❸. When it calls `countDownAndUp(2)`, a new frame is
    pushed onto the stack, and that frame’s local `number` variable is set to `2`.
    Again, the recursive case is reached and calls `countDownAndUp(1)`, which again
    reaches the recursive case and calls `countDownAndUp(0)`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`countDownAndUp(3)`时❺，会创建一个帧，该帧的局部变量`number`设置为`3`。函数将`number`变量打印到屏幕上❶。只要`number`不是`0`，就会递归调用`countDownAndUp()`，参数为`number
    - 1`❸。当调用`countDownAndUp(2)`时，会推送一个新帧到堆栈上，并且该帧的局部变量`number`设置为`2`。同样，递归情况被触发，调用`countDownAndUp(1)`，再次触发递归情况并调用`countDownAndUp(0)`。
- en: This pattern of making consecutive recursive function calls and then returning
    from the recursive function calls is what causes the countdown of numbers to appear.
    Once `countDownAndUp(0)` is called, the base case is reached ❷, and no more recursive
    calls are made. However, this isn’t the end of our program! When the base case
    is reached, the local `number` variable is `0`. But when that base case returns,
    and the frame is popped off the call stack, the frame under it has its own local
    `number` variable, with the same `1` value it’s always had. As the execution returns
    back to the previous frames in the call stack, the code *after* the recursive
    call is executed ❹. This is what causes the count up of numbers to appear. [Figure
    1-9](#figure1-9) shows the state of the call stack as `countDownAndUp()` is recursively
    called and then returns.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 连续进行递归函数调用然后从递归函数调用返回的模式是导致数字倒数出现的原因。一旦调用`countDownAndUp(0)`，就会达到基本情况❷，不会再进行递归调用。然而，这并不是我们程序的结束！当达到基本情况时，局部变量`number`为`0`。但当基本情况返回并且帧从调用堆栈中弹出时，其下面的帧有自己的局部变量`number`，其值始终为`1`。当执行返回到调用堆栈中的前一个帧时，递归调用后的代码会被执行❹。这就是导致数字升序出现的原因。[图1-9](#figure1-9)显示了在递归调用`countDownAndUp()`并返回时调用堆栈的状态。
- en: '![Timeline depicting a call stack after each call to countDownAndUp(). It begins
    empty, then shows the number variable equal to 3, then equal to 2, then equal
    to 1, then equal to 0\. The number variable then begins increasing, first to 1,
    then to 2, then to 3, until the call stack is empty.](image_fi/502024c01/f01009.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴描述了每次调用countDownAndUp()后的调用堆栈。它开始为空，然后显示number变量等于3，然后等于2，然后等于1，然后等于0。然后number变量开始增加，先是1，然后是2，然后是3，直到调用堆栈为空。](image_fi/502024c01/f01009.png)'
- en: 'Figure 1-9: The call stack keeping track of the values in the `number` local
    variable for each function call'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-9：调用堆栈跟踪每个函数调用中“number”局部变量的值
- en: The fact that the code doesn’t stop immediately when the base case is reached
    will be important to keep in mind for the factorial calculation in the next chapter.
    Remember, any code after the recursive case will still have to run.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当基本情况达到时，代码不会立即停止，这一点对于下一章中的阶乘计算非常重要。请记住，递归情况之后的任何代码仍然必须运行。
- en: At this point, you might be thinking that the recursive `countDownAndUp()` function
    is overengineered and difficult to follow. Why not, instead, use an iterative
    solution to print numbers? An *iterative* approach, which uses loops to repeat
    a task until it’s done, is usually thought of as the opposite of recursion.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会认为递归的`countDownAndUp()`函数设计过于复杂，难以理解。为什么不使用迭代解决方案来打印数字呢？*迭代*方法通常被认为是递归的相反，它使用循环重复任务直到完成。
- en: Whenever you find yourself asking, “Wouldn’t using a loop be easier?” the answer
    is almost certainly “Yes,” and you should avoid the recursive solution. Recursion
    can be tricky for both beginner and experienced programmers, and recursive code
    isn’t automatically “better” or “more elegant” than iterative code. Readable,
    easy-to-understand code is more important than any supposed elegance that recursion
    provides. However, on some occasions an algorithm cleanly maps to a recursive
    approach. Algorithms that involve tree-like data structures and require backtracking
    are especially suited for recursion. These ideas are further explored in Chapters
    2 and 4.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您问自己，“使用循环会更容易吗？”答案几乎肯定是“是”，您应该避免使用递归解决方案。递归对于初学者和有经验的程序员都可能很棘手，递归代码并不自动比迭代代码“更好”或“更优雅”。可读性强、易于理解的代码比递归提供的任何所谓的优雅更重要。然而，在某些情况下，算法可以清晰地映射到递归方法。涉及树状数据结构并需要回溯的算法特别适合使用递归。这些想法在第2章和第4章中进一步探讨。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Recursion often confuses new programmers, but it is built on the simple idea
    that a function can call itself. Every time a function call is made, a new frame
    object with information related to the call (such as local variables and a return
    address for the execution to move to when the function returns) is added to the
    call stack. The call stack, being a stack data structure, can be altered only
    by having data added to or removed from its “top.” This is called *pushing to*
    and *popping from* the stack, respectively.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 递归经常会让新手程序员感到困惑，但它建立在一个简单的思想上，即函数可以调用自身。每次进行函数调用时，都会向调用堆栈添加一个新的帧对象，其中包含与调用相关的信息（例如局部变量和函数返回时执行移动到的返回地址）。调用堆栈作为一个堆栈数据结构，只能通过向其“顶部”添加或删除数据来改变。这分别称为*推入*和*弹出*堆栈。
- en: The call stack is handled by the program implicitly, so there is no call stack
    variable. Calling a function pushes a frame object to the call stack, and returning
    from a function pops a frame object from the call stack.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 程序隐式处理调用堆栈，因此没有调用堆栈变量。调用函数会将一个帧对象推入调用堆栈，从函数返回会从调用堆栈中弹出一个帧对象。
- en: Recursive functions have recursive cases, those in which a recursive call is
    made, and base cases, those where the function simply returns. If there is no
    base case or a bug prevents a base case from being run, the execution causes a
    stack overflow that crashes the program.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数有递归情况，即进行递归调用的情况，和基本情况，即函数简单返回的情况。如果没有基本情况或者错误阻止基本情况运行，执行将导致堆栈溢出，从而使程序崩溃。
- en: Recursion is a useful technique, but recursion doesn’t automatically make code
    “better” or more “elegant.” This idea is explored more in the next chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种有用的技术，但递归并不会自动使代码“更好”或更“优雅”。这个想法在下一章中会更详细地探讨。
- en: Further Reading
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find other introductions to recursion in my 2018 North Bay Python conference
    talk, “Recursion for Beginners: A Beginner’s Guide to Recursion,” at [https://youtu.be/AfBqVVKg4GE](https://youtu.be/AfBqVVKg4GE).
    The YouTube channel Computerphile also introduces recursion in its video “What
    on Earth is Recursion?” at [https://youtu.be/Mv9NEXX1VHc](https://youtu.be/Mv9NEXX1VHc).
    Finally, V. Anton Spraul talks about recursion in his book *Think Like a Programmer*
    (No Starch Press, 2012) and in his video “Recursion (Think Like a Programmer)”
    at [https://youtu.be/oKndim5-G94](https://youtu.be/oKndim5-G94). Wikipedia’s article
    on recursion goes into great detail at [https://en.wikipedia.org/wiki/Recursion](https://en.wikipedia.org/wiki/Recursion).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在2018年北湾Python大会上找到有关递归的其他介绍，标题为“递归入门：递归初学者指南”，网址为[https://youtu.be/AfBqVVKg4GE](https://youtu.be/AfBqVVKg4GE)。YouTube频道Computerphile还在其视频“地球上的递归是什么？”中介绍了递归，网址为[https://youtu.be/Mv9NEXX1VHc](https://youtu.be/Mv9NEXX1VHc)。最后，V.
    Anton Spraul在他的书*像程序员一样思考*（No Starch Press，2012）和他的视频“递归（像程序员一样思考）”中讨论了递归，网址为[https://youtu.be/oKndim5-G94](https://youtu.be/oKndim5-G94)。维基百科的递归文章在[https://en.wikipedia.org/wiki/Recursion](https://en.wikipedia.org/wiki/Recursion)中有详细介绍。
- en: You can install the `ShowCallStack` module for Python. This module adds a `showcallstack()`
    function that you can place anywhere in your code to see the state of the call
    stack at that particular point in your program. You can download the module and
    find instructions for it at [https://pypi.org/project/ShowCallStack](https://pypi.org/project/ShowCallStack).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为Python安装“ShowCallStack”模块。该模块添加了一个“showcallstack()”函数，您可以将其放在代码中的任何位置，以查看程序在特定点的调用堆栈状态。您可以在[https://pypi.org/project/ShowCallStack](https://pypi.org/project/ShowCallStack)下载该模块并找到相关说明。
- en: Practice Questions
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习题
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你的理解能力：
- en: In general, what is a recursive thing?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一般来说，什么是递归的东西？
- en: In programming, what is a recursive function?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编程中，什么是递归函数？
- en: What four features do functions have?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数有哪四个特征？
- en: What is a stack?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是堆栈？
- en: What are the terms for adding and removing values to and from the top of a stack?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向堆栈的顶部添加和移除值的术语是什么？
- en: Say you push the letter *J* to a stack, then push the letter *Q*, then pop the
    stack, then push the letter *K*, then pop the stack again. What does the stack
    look like?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你将字母*J*推送到堆栈，然后推送字母*Q*，然后弹出堆栈，然后推送字母*K*，然后再次弹出堆栈。堆栈是什么样子？
- en: What is pushed and popped onto the call stack?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被推送和弹出到调用堆栈上的是什么？
- en: What causes a stack overflow to happen?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是什么导致堆栈溢出？
- en: What is a base case?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？
- en: What is a recursive case?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是递归情况？
- en: How many base cases and recursive cases do recursive functions have?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数有多少个基本情况和递归情况？
- en: What happens if a recursive function has zero base cases?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个递归函数没有基本情况会发生什么？
- en: What happens if a recursive function has zero recursive cases?`  `# 2
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个递归函数没有递归情况会发生什么？`  `# 2
- en: Recursion vs. Iteration
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 递归与迭代
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Neither recursion nor iteration is a superior technique in general. In fact,
    any recursive code can be written as iterative code with a loop and a stack. Recursion
    doesn’t have some special power enabling it to perform calculations that an iterative
    algorithm cannot. And any iterative loop can be rewritten as a recursive function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 递归和迭代都没有一般上是更好的技术。事实上，任何递归代码都可以用循环和堆栈编写成迭代代码。递归并没有某种特殊的能力使其能够执行迭代算法无法执行的计算。任何迭代循环都可以重写为递归函数。
- en: This chapter compares and contrasts recursion and iteration. We’ll look at the
    classic Fibonacci and factorial functions and see why their recursive algorithms
    have critical weaknesses. We’ll also explore the insights a recursive approach
    can yield by considering an exponent algorithm. Altogether this chapter shines
    light on the supposed elegance of recursive algorithms and shows when a recursive
    solution is useful and when it is not.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本章比较和对比了递归和迭代。我们将研究经典的斐波那契和阶乘函数，并看看它们的递归算法为什么有关键的弱点。我们还将通过考虑指数算法来探索递归方法可以产生的见解。总的来说，本章揭示了递归算法的所谓优雅之处，并展示了递归解决方案何时有用以及何时不适用。
- en: Calculating Factorials
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算阶乘
- en: Many computer science courses use factorial calculation as a classic example
    of a recursive function. The factorial of an integer (let’s call it *n*) is the
    product of all integers from 1 to *n*. For example, the factorial of 4 is 4 ×
    3 × 2 × 1, or 24\. An exclamation mark is the math notation for factorials, as
    in 4!, which means *the factorial of 4*. [Table 2-1](#table2-1) shows the first
    few factorials.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机科学课程使用阶乘计算作为递归函数的经典示例。一个整数（我们称之为*n*）的阶乘是从1到*n*的所有整数的乘积。例如，4的阶乘是4 × 3 ×
    2 × 1，即24。感叹号是阶乘的数学表示法，如4!，表示*4的阶乘*。[表2-1](#table2-1)显示了前几个阶乘。
- en: 'Table 2-1: Factorials of the First Few Integers'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1：前几个整数的阶乘
- en: '| ***n*!** |  | **Expanded form** |  | **Product** |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| ***n*!** |  | **展开形式** |  | **乘积** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1! | = | 1 | = | 1 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 1! | = | 1 | = | 1 |'
- en: '| 2! | = | 1 × 2 | = | 2 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 2! | = | 1 × 2 | = | 2 |'
- en: '| 3! | = | 1 × 2 × 3 | = | 6 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 3! | = | 1 × 2 × 3 | = | 6 |'
- en: '| 4! | = | 1 × 2 × 3 × 4 | = | 24 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 4! | = | 1 × 2 × 3 × 4 | = | 24 |'
- en: '| 5! | = | 1 × 2 × 3 × 4 × 5 | = | 120 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 5! | = | 1 × 2 × 3 × 4 × 5 | = | 120 |'
- en: '| 6! | = | 1 × 2 × 3 × 4 × 5 × 6 | = | 720 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 6! | = | 1 × 2 × 3 × 4 × 5 × 6 | = | 720 |'
- en: '| 7! | = | 1 × 2 × 3 × 4 × 5 × 6 × 7 | = | 5,040 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 7! | = | 1 × 2 × 3 × 4 × 5 × 6 × 7 | = | 5,040 |'
- en: '| 8! | = | 1 × 2 × 3 × 4 × 5 × 6 × 7 × 8 | = | 40,320 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 8! | = | 1 × 2 × 3 × 4 × 5 × 6 × 7 × 8 | = | 40,320 |'
- en: Factorials are used in all sorts of calculations—for example, finding the number
    of permutations for something. If you want to know the number of ways that exist
    to order four people—Alice, Bob, Carol, and David—in a line, the answer is the
    factorial of 4\. Four possible people can be first in line (4); then for each
    of those four options, three remaining people can be second in line (4 × 3); then
    two people can be third in line (4 × 3 × 2); and the last person left will be
    fourth in line (4 × 3 × 2 × 1). The number of ways people can be ordered in line—that
    is, the number of permutations—is the factorial of the number of people.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘在各种计算中都有用途——例如，找到某物排列的排列数。如果你想知道有多少种方式可以将四个人——Alice、Bob、Carol和David——排成一行，答案就是4的阶乘。四个可能的人可以先站在队伍中（4）；然后对于这四个选项中的每一个，还有三个人可以站在第二位（4
    × 3）；然后两个人可以站在第三位（4 × 3 × 2）；最后一个人站在第四位（4 × 3 × 2 × 1）。人们可以排成队伍的方式数量——也就是排列的数量——就是人数的阶乘。
- en: Now let’s examine both an iterative and a recursive approach to calculating
    factorials.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看计算阶乘的迭代和递归方法。
- en: The Iterative Factorial Algorithm
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代阶乘算法
- en: 'Calculating factorials iteratively is fairly straightforward: multiply the
    integers 1 up to and including *n* in a loop. *Iterative* algorithms always use
    a loop. A *factorialByIteration.py* program looks like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 用迭代方法计算阶乘相当直接：在循环中将整数1到*n*相乘。*迭代*算法总是使用循环。*factorialByIteration.py*程序看起来像这样：
- en: '**Python**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And a *factorialByIteration.html* program looks like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 而*factorialByIteration.html*程序看起来像这样：
- en: '**JavaScript**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you run this code, the output displays the calculation for 5! like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，输出会显示5!的计算结果如下：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There’s nothing wrong with the iterative solution for calculating factorials;
    it’s straightforward and gets the job done. But let’s also take a look at the
    recursive algorithm for insights into the nature of factorials and recursion itself.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 用迭代方法计算阶乘没有问题；它很直接并且完成了任务。但是让我们也看看递归算法，以便更好地理解阶乘和递归本身的性质。
- en: The Recursive Factorial Algorithm
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归阶乘算法
- en: Notice that the factorial of 4 is 4 × 3 × 2 × 1, and the factorial of 5 is 5
    × 4 × 3 × 2 × 1\. So you could say that 5! = 5 × 4!. This is *recursive* because
    the definition of the factorial of 5 (or any number *n*) includes the definition
    of the factorial of 4 (the number *n* – 1). In turn, 4! = 4 × 3!, and so on, until
    you must calculate 1!, the base case, which is simply 1.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意4的阶乘是4 × 3 × 2 × 1，5的阶乘是5 × 4 × 3 × 2 × 1。所以你可以说5! = 5 × 4!。这是*递归*，因为5的阶乘（或任何数字*n*）的定义包括4的阶乘（数字*n*
    - 1）的定义。依此类推，4! = 4 × 3!，以此类推，直到必须计算1!，即基本情况，它只是1。
- en: 'The *factorialByRecursion.py* Python program uses a recursive factorial algorithm:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 递归阶乘算法的Python程序*factorialByRecursion.py*使用了递归阶乘算法：
- en: '**Python**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And the *factorialByRecursion.html* JavaScript program with equivalent code
    looks like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 而*factorialByRecursion.html*的JavaScript程序与等效代码看起来是这样的：
- en: '**JavaScript**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you run this code to calculate 5! recursively, the output matches the
    iterative program’s output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码递归计算5!时，输出与迭代程序的输出相匹配：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To many programmers, this recursive code looks strange. You know that `factorial(5)`
    must compute 5 × 4 × 3 × 2 × 1, but it’s hard to point to the line of code where
    this multiplication is taking place.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对许多程序员来说，这个递归代码看起来很奇怪。你知道`factorial(5)`必须计算5 × 4 × 3 × 2 × 1，但很难指出这个乘法发生在哪一行代码上。
- en: The confusion arises because the recursive case has one line ❶, half of which
    is executed before the recursive call and half of which takes place after the
    recursive call returns. We aren’t used to the idea of only half of a line of code
    executing at a time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆是因为递归情况有一行 ❶，其中一半在递归调用之前执行，另一半在递归调用返回后执行。我们不习惯一行代码只有一半在执行。
- en: The first half is `factorial(number - 1)`. This involves calculating `number
    - 1` and making a recursive function, causing a new frame object to be pushed
    to the call stack. This happens before the recursive call is made.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是`factorial(number - 1)`。这涉及计算`number - 1`并创建一个递归函数，导致调用栈中推送一个新的帧对象。这发生在递归调用之前。
- en: The next time the code runs with the old frame object is after `factorial(number
    - 1)` has returned. When `factorial(5)` is called, `factorial(number - 1)` will
    be `factorial(4)`, which returns `24`. This is when the second half of the line
    runs. The `return number * factorial(number - 1)` now looks like `return` `5 *
    24`, which is why `factorial(5)` returns `120`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 代码再次运行时，旧的帧对象是在`factorial(number - 1)`返回后。当调用`factorial(5)`时，`factorial(number
    - 1)`将是`factorial(4)`，返回值是`24`。这时第二部分代码运行。`return number * factorial(number -
    1)`现在看起来像`return` `5 * 24`，这就是为什么`factorial(5)`返回`120`。
- en: '[Figure 2-1](#figure2-1) tracks the state of the call stack as frame objects
    are pushed (which happens as recursive function calls are made) and frame objects
    are popped (as recursive function calls return). Notice that the multiplication
    happens after the recursive calls are made, not before.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-1](#figure2-1)跟踪了调用栈的状态，帧对象被推送（当递归函数调用时发生）和帧对象被弹出（当递归函数调用返回时）。注意乘法发生在递归调用之后，而不是之前。'
- en: When the original function call to `factorial()` returns, it returns the calculated
    factorial.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当原始函数调用`factorial()`返回时，它返回了计算出的阶乘。
- en: Why the Recursive Factorial Algorithm Is Terrible
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么递归阶乘算法很糟糕
- en: The recursive implementation for calculating factorials has a critical weakness.
    Calculating the factorial of 5 requires five recursive function calls. This means
    five frame objects are placed on the call stack before the base case is reached.
    This doesn’t scale.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算阶乘的递归实现有一个关键的弱点。计算5的阶乘需要五次递归函数调用。这意味着在基本情况到达之前，调用栈上会有五个帧对象。这不可扩展。
- en: If you want to calculate the factorial of 1,001, the recursive `factorial()`
    function must make 1,001 recursive function calls. However, your program is likely
    to cause a stack overflow before it can finish, because making so many function
    calls without returning would exceed the maximum call stack size of the interpreter.
    This is terrible; you would never want to use a recursive factorial function in
    real-world code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想计算1001的阶乘，递归的`factorial()`函数必须进行1001次递归函数调用。然而，你的程序很可能在完成之前引起堆栈溢出，因为进行如此多的函数调用而不返回会超过解释器的最大调用栈大小。这很糟糕；你绝对不会想在真实世界的代码中使用递归阶乘函数。
- en: '![Timeline of the call stack after each call to the factorial function. We
    begin with the number variable equal to 5 and a return value of 5 times the result
    of the factorial function when called with the argument 4\. Next, number equals
    4, and the return value is 4 times the result of the factorial function when called
    with the argument 3\. Then, number equals 3, and the return value is 3 times the
    return value of the factorial function when called with the argument 2\. Next,
    number equals 2, and the return value is 2 times the return value of the factorial
    function when called with the argument 1\. After that, number equals 1, and the
    return value is 1\. Then, number equals 2, and the return value is 2 times 1\.
    Next, number equals 3, and the return value is 3 times 2\. Then, number equals
    4, and the return value is 4 times 6\. Next, number equals 5, and the return value
    is 5 times 24\. Finally, the call stack is empty.](image_fi/502024c02/f02001.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![调用阶乘函数后每次调用后调用栈的时间线。我们从number变量等于5和阶乘函数在参数4时的返回值5倍阶乘函数结果开始。接下来，number等于4，返回值是4倍阶乘函数在参数3时的返回值。然后，number等于3，返回值是3倍阶乘函数在参数2时的返回值。接下来，number等于2，返回值是2倍阶乘函数在参数1时的返回值。之后，number等于1，返回值是1。然后，number等于2，返回值是2乘1。接下来，number等于3，返回值是3乘2。然后，number等于4，返回值是4乘6。接下来，number等于5，返回值是5乘24。最后，调用栈为空。](image_fi/502024c02/f02001.png)'
- en: 'Figure 2-1: The state of the call stack as the recursive calls to `factorial()`
    are called and then return'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-1：调用栈的状态，递归调用`factorial()`后的返回
- en: The iterative factorial algorithm, on the other hand, will complete the calculation
    quickly and efficiently. The stack overflow can be avoided using a technique available
    in some programming languages called *tail call optimization*. Chapter 8 covers
    this topic. However, this technique further complicates the implementation of
    the recursive function. For calculating factorials, the iterative approach is
    the simplest and most direct.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，迭代阶乘算法将快速高效地完成计算。可以使用一些编程语言中的一种称为*尾递归优化*的技术来避免堆栈溢出。第8章涵盖了这个主题。然而，这种技术进一步复杂化了递归函数的实现。对于计算阶乘，迭代方法是最简单和最直接的。
- en: Calculating the Fibonacci Sequence
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算斐波那契序列
- en: The *Fibonacci sequence* is another classic example for introducing recursion.
    Mathematically, the Fibonacci sequence of integers begins with the numbers 1 and
    1 (or sometimes, 0 and 1). The next number in the sequence is the sum of the previous
    two numbers. This creates the sequence 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,
    and so on, forever.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*斐波那契序列*是介绍递归的另一个经典例子。数学上，整数的斐波那契序列以数字1和1（有时是0和1）开始。序列中的下一个数字是前两个数字的和。这创建了序列1,
    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144等，永远不会结束。'
- en: If we call the latest two numbers in the sequence *a* and *b*, you can see in
    [Figure 2-2](#figure2-2) how the sequence grows.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将序列中的最新两个数字称为*a*和*b*，您可以在[图2-2](#figure2-2)中看到序列是如何增长的。
- en: '![Diagram showing the values of two variables, a and b, and their sum as the
    Fibonacci sequence progresses. We begin with a and b both equal to 1 and their
    sum equal to 2\. Next, a is equal to 1, b is equal to 2, and their sum is equal
    to 3\. Then a is equal to 2, b is equal to 3, and their sum is equal to 5\. Each
    progression of the Fibonacci sequence occurs on a new line, and each new line
    is one number longer than the previous line, forming a pyramid-like shape.](image_fi/502024c02/f02002.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![显示两个变量a和b的值以及它们的和随着斐波那契序列的进展而变化的图表。我们从a和b都等于1以及它们的和等于2开始。接下来，a等于1，b等于2，它们的和等于3。然后a等于2，b等于3，它们的和等于5。斐波那契序列的每次进展都发生在新的一行上，每一行都比上一行多一个数字，形成了金字塔形状。](image_fi/502024c02/f02002.png)'
- en: 'Figure 2-2: Each number of the Fibonacci sequence is the sum of the previous
    two numbers.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-2：斐波那契序列的每个数字都是前两个数字的和。
- en: Let’s explore some code examples of both the iterative and recursive solutions
    for generating Fibonacci numbers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些迭代和递归解决方案的代码示例，用于生成斐波那契数。
- en: The Iterative Fibonacci Algorithm
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代斐波那契算法
- en: 'The iterative Fibonacci example is straightforward, consisting of a simple
    `for` loop and two variables, `a` and `b`. This *fibonacciByIteration.py* Python
    program implements the iterative Fibonacci algorithm:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代斐波那契示例很简单，由一个简单的`for`循环和两个变量`a`和`b`组成。这个*fibonacciByIteration.py* Python程序实现了迭代斐波那契算法：
- en: '**Python**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This *fibonacciByIteration.html* program has the equivalent JavaScript code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*fibonacciByIteration.html*程序包含了等效的JavaScript代码：
- en: '**JavaScript**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you run this code to calculate the 10th Fibonacci number, the output looks
    like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码来计算第10个斐波那契数时，输出如下：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The program needs to track only the latest two numbers of the sequence at a
    time. Since the first two numbers in the Fibonacci sequence are defined as 1,
    we store `1` in variables `a` and `b` ❶. Inside the `for` loop, the next number
    in the sequence is calculated by adding `a` and `b` ❷, which becomes the next
    value of `b`, while `a` obtains the previous value of `b`. By the time the loop
    is finished, `b` contains the *n*th Fibonacci number, so it is returned.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 程序只需要一次跟踪序列中的最新两个数字。由于斐波那契序列中的前两个数字被定义为1，我们将`1`存储在变量`a`和`b`中❶。在`for`循环内，通过将`a`和`b`相加来计算序列中的下一个数字❷，这成为`b`的下一个值，而`a`获得`b`的前一个值。当循环结束时，`b`包含第*n*个斐波那契数，因此返回它。
- en: The Recursive Fibonacci Algorithm
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归斐波那契算法
- en: 'Calculating Fibonacci numbers involves a recursive property. For example, if
    you want to calculate the 10th Fibonacci number, you add the ninth and eighth
    Fibonacci numbers together. To calculate those Fibonacci numbers, you add the
    eighth and seventh, then the seventh and sixth Fibonacci numbers. A lot of repeat
    calculations occur: notice that adding the ninth and eighth Fibonacci numbers
    involves calculating the eighth Fibonacci number again. You continue this recursion
    until you reach the base case of the first or second Fibonacci number, which is
    always 1.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 计算斐波那契数涉及递归属性。例如，如果要计算第10个斐波那契数，您将第九个和第八个斐波那契数相加。要计算这些斐波那契数，您将第八个和第七个，然后第七个和第六个斐波那契数相加。会发生大量重复计算：注意到将第九个和第八个斐波那契数相加涉及再次计算第八个斐波那契数。您继续递归，直到达到第一个或第二个斐波那契数的基本情况，它们始终为1。
- en: 'The recursive Fibonacci function is in this *fibonacciByRecursion.py* Python
    program:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 递归斐波那契函数在这个*fibonacciByRecursion.py* Python程序中：
- en: '[PRE28]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This *fibonacciByRecursion.html* file has the equivalent JavaScript program:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*fibonacciByRecursion.html*文件包含了等效的JavaScript程序：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When you run this code to calculate the 10th Fibonacci number, the output looks
    like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码来计算第10个斐波那契数时，输出如下：
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Much of the code is for displaying this output, but the `fibonacci()` function
    itself is simple. The base case—the circumstances where recursive calls are no
    longer made—occurs when `nthNumber` is `1` or `2` ❶. In this case, the function
    returns `1` since the first and second Fibonacci numbers are always 1\. Any other
    case is a recursive case, so the value that is returned is the sum of `fibonacci(nthNumber
    - 1)` and `fibonacci(nthNumber - 2)`. As long as the original `nthNumber` argument
    is an integer greater than `0`, these recursive calls will eventually reach the
    base case and stop making more recursive calls.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码用于显示这个输出，但`fibonacci()`函数本身很简单。基本情况——不再进行递归调用的情况——发生在`nthNumber`为`1`或`2`时❶。在这种情况下，函数返回`1`，因为第一个和第二个斐波那契数始终为1。任何其他情况都是递归情况，因此返回的值是`fibonacci(nthNumber
    - 1)`和`fibonacci(nthNumber - 2)`的和。只要原始的`nthNumber`参数是大于`0`的整数，这些递归调用最终会达到基本情况并停止进行更多的递归调用。
- en: 'Remember how the recursive factorial example had a “before the recursive call”
    and “after the recursive call” part? Because the recursive Fibonacci algorithm
    makes two recursive calls in its recursive case, you should keep in mind that
    it has three parts: “before the first recursive call,” “after the first recursive
    call but before the second recursive call,” and “after the second recursive call.”
    But the same principles apply. And don’t think that because a base case is reached,
    no more code remains to run after either recursive call. The recursive algorithm
    is finished only after the original function call has returned.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得递归阶乘示例中的“递归调用之前”和“递归调用之后”部分吗？因为递归斐波那契算法在其递归情况中进行了两次递归调用，所以你应该记住它有三个部分：“第一个递归调用之前”，“第一个递归调用之后但第二个递归调用之前”，以及“第二个递归调用之后”。但相同的原则适用。不要认为因为达到了基本情况，递归调用之后就不再需要运行任何代码。只有在原始函数调用返回后，递归算法才算完成。
- en: You might ask, “Isn’t the iterative Fibonacci solution simpler than the recursive
    Fibonacci solution?” The answer is “Yes.” Even worse, the recursive solution has
    a critical inefficiency that is explained in the next section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：“迭代斐波那契解决方案是否比递归斐波那契解决方案更简单？”答案是“是的”。更糟糕的是，递归解决方案存在一个关键的低效性，下一节将对此进行解释。
- en: Why the Recursive Fibonacci Algorithm Is Terrible
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么递归斐波那契算法很糟糕
- en: 'Like the recursive factorial algorithm, the recursive Fibonacci algorithm also
    suffers from a critical weakness: it repeats the same calculations over and over.
    [Figure 2-3](#figure2-3) shows how calling `fibonacci(6)`, marked in the tree
    diagram as `fib(6)` for brevity, calls `fibonacci(5)` and `fibonacci(4)`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与递归阶乘算法一样，递归斐波那契算法也存在一个关键的弱点：它一遍又一遍地重复相同的计算。[图2-3](#figure2-3)显示了调用`fibonacci(6)`（在树形图中标记为`fib(6)`以简洁表示）时调用了`fibonacci(5)`和`fibonacci(4)`。
- en: '![Tree diagram beginning with the Fibonacci function called with an argument
    of 6\. Two subsequent branches show the next calls to the Fibonacci function,
    with arguments of 5 and 4, respectively. The tree continues to branch until each
    branch ends with a value of 1\. Several of the branches are grayed out, indicating
    that the Fibonacci function was called with the same argument as a previous branch.](image_fi/502024c02/f02003.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![以参数6调用斐波那契函数开始的树形图。两个后续分支显示了对斐波那契函数的下一次调用，参数分别为5和4。树继续分支，直到每个分支以值1结束。其中一些分支被标记为灰色，表示斐波那契函数以与先前分支相同的参数调用。](image_fi/502024c02/f02003.png)'
- en: 'Figure 2-3: A tree diagram of the recursive function calls made starting with
    `fibonacci(6)`. The redundant function calls are in gray.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-3：从`fibonacci(6)`开始进行的递归函数调用的树形图。冗余的函数调用以灰色显示。
- en: This causes a cascade of other function calls until they reach the base cases
    of `fibonacci(2)` and `fibonacci(1)`, which return `1`. But notice that `fibonacci(4)`
    is called twice, and `fibonacci(3)` is called three times, and so on. This slows
    the overall algorithm with unnecessarily repeated calculations. This inefficiency
    gets worse as the Fibonacci number you want to calculate gets larger. While the
    iterative Fibonacci algorithm can complete `fibonacci(100)` in less than a second,
    the recursive algorithm would take over a million years to complete.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这会引起其他函数调用的级联，直到它们达到`fibonacci(2)`和`fibonacci(1)`的基本情况，返回`1`。但请注意，`fibonacci(4)`被调用了两次，`fibonacci(3)`被调用了三次，依此类推。这会使整体算法变慢，因为存在不必要的重复计算。随着要计算的斐波那契数变得更大，这种低效性会变得更糟。虽然迭代斐波那契算法可以在不到一秒的时间内完成`fibonacci(100)`，但递归算法需要超过一百万年才能完成。
- en: Converting a Recursive Algorithm into an Iterative Algorithm
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将递归算法转换为迭代算法
- en: Converting a recursive algorithm into an iterative algorithm is always possible.
    While recursive functions repeat a calculation by calling themselves, this repetition
    can be performed instead by a loop. Recursive functions also make use of the call
    stack; however, an iterative algorithm can replace this with a stack data structure.
    Thus, any recursive algorithm can be performed iteratively by using a loop and
    a stack.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将递归算法转换为迭代算法总是可能的。虽然递归函数通过调用自身重复计算，但这种重复可以通过循环来执行。递归函数还利用调用堆栈；然而，迭代算法可以用堆栈数据结构来替代。因此，任何递归算法都可以通过使用循环和堆栈来进行迭代执行。
- en: 'To demonstrate this, here is *factorialEmulateRecursion.py*, a Python program
    that implements an iterative algorithm to emulate a recursive algorithm:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，这里有一个名为*factorialEmulateRecursion.py*的Python程序，它实现了一个迭代算法来模拟递归算法：
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The *factorialEmulateRecursion.html* program holds the equivalent JavaScript:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*factorialEmulateRecursion.html*程序包含了等效的JavaScript代码：'
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that this program doesn’t have a recursive function; it doesn’t have
    any functions at all! The program emulates recursive function calls by using a
    list as a stack data structure (stored in the `callStack` variable ❶) to mimic
    the call stack. A dictionary storing the return address information and `nthNumber`
    local variable emulates a frame object ❷. The program emulates function calls
    by pushing these frame objects onto the call stack ❹, and it emulates returning
    from a function call by popping frame objects off the call stack 35.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个程序没有递归函数；它根本没有任何函数！该程序通过使用列表作为堆栈数据结构（存储在`callStack`变量中❶）来模拟调用堆栈，从而模拟递归函数调用。存储返回地址信息和`nthNumber`本地变量的字典模拟了帧对象❷。该程序通过将这些帧对象推送到调用堆栈❹来模拟函数调用，并通过从调用堆栈中弹出帧对象35来模拟从函数调用返回。
- en: Any recursive function can be written iteratively this way. Although this code
    is incredibly difficult to understand and you’d never write a real-world factorial
    algorithm this way, it does demonstrate that recursion has no innate capability
    that iterative code does not have.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 任何递归函数都可以以这种方式被写成迭代的。虽然这段代码非常难以理解，你永远不会以这种方式编写一个真实的阶乘算法，但它确实证明了递归没有任何迭代代码没有的固有能力。
- en: Converting an Iterative Algorithm into a Recursive Algorithm
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将迭代算法转换为递归算法
- en: Likewise, converting an iterative algorithm into a recursive algorithm is always
    possible. An iterative algorithm is simply code that uses a loop. The code that
    is repeatedly executed (the loop’s body) can be placed in a recursive function’s
    body. And just as the code in the loop’s body is executed repeatedly, we need
    to repeatedly call the function to execute its code. We can do this by calling
    the function from the function itself, creating a recursive function.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，将迭代算法转换为递归算法总是可能的。迭代算法只是使用循环的代码。重复执行的代码（循环的主体）可以放在递归函数的主体中。就像循环主体中的代码被重复执行一样，我们需要重复调用函数来执行它的代码。我们可以通过从函数本身调用函数来做到这一点，创建一个递归函数。
- en: 'The Python code in *hello.py* demonstrates printing `Hello, world!` five times
    by using a loop and then also using a recursive function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello.py*中的Python代码演示了通过使用循环打印`Hello, world!`五次，然后还使用递归函数：'
- en: '**Python**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The equivalent JavaScript code is in *hello.html*:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 等价的JavaScript代码在*hello.html*中：
- en: '**JavaScript**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of these programs looks like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `while` loop has a condition, `i < 5`, that determines whether the program
    keeps looping. Similarly, the recursive function uses this condition for its recursive
    case, which causes the function to call itself and execute the `Hello, world!`
    to display its code again.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环有一个条件，`i < 5`，用于确定程序是否继续循环。同样，递归函数使用这个条件作为它的递归情况，这会导致函数调用自身并执行`Hello,
    world!`来再次显示它的代码。'
- en: For a more real-world example, the following are iterative and recursive functions
    that return the index of a substring, `needle`, in a string, `haystack. The functions
    return `-1` if the substring isn’t found. This is similar to Python’s `find()`
    string method and JavaScript’s `indexOf()` string method. This *findSubstring.py*
    program has a Python version:`
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更真实的例子，以下是迭代和递归函数，它们返回字符串`haystack`中子字符串`needle`的索引。如果没有找到子字符串，这些函数返回`-1`。这类似于Python的`find()`字符串方法和JavaScript的`indexOf()`字符串方法。这个*findSubstring.py*程序有一个Python版本：`
- en: '`**Python**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`**Python**'
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This *findSubstring.html* program has the equivalent JavaScript version:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*findSubstring.html*程序有等价的JavaScript版本：
- en: '**JavaScript**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'These programs make a call to `findSubstringIterative()` and `findSubstringRecursive()`,
    which return `3` because that is the index where `cat` is found in `My cat Zophie`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序调用`findSubstringIterative()`和`findSubstringRecursive()`，它们返回`3`，因为这是在`My
    cat Zophie`中找到`cat`的索引：
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The programs in this section demonstrate that it is always possible to turn
    any loop into an equivalent recursive function. While replacing a loop with recursion
    is possible, I advise against it. This is doing recursion for recursion’s sake,
    and since recursion is often harder to understand than iterative code, code readability
    deteriorates.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的程序表明，将任何循环转换为等价的递归函数总是可能的。虽然用递归替换循环是可能的，但我建议不要这样做。这是为了递归而递归，而且由于递归通常比迭代代码更难理解，代码的可读性会下降。
- en: 'Case Study: Calculating Exponents'
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：计算指数
- en: Although recursion doesn’t necessarily produce better code, taking a recursive
    approach can give you new insights into your programming problem. As a case study,
    let’s examine how to calculate exponents.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管递归不一定会产生更好的代码，但采用递归方法可以让你对编程问题有新的见解。作为一个案例研究，让我们来看看如何计算指数。
- en: '*Exponents* are calculated by multiplying a number by itself. For example,
    the exponent “three raised to the sixth power,” or 3⁶, is equal to multiplying
    3 by itself six times: 3 × 3 × 3 × 3 × 3 × 3 = 729\. This is such a common operation
    that Python has the `**` operator and JavaScript has the built-in `Math.pow()`
    function to perform exponentiation. We can calculate 3⁶ with the Python code `3
    ** 6` and with the JavaScript code `Math.pow(3, 6)`.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*指数*是通过将一个数字乘以自身来计算的。例如，指数“三的六次方”，或3⁶，等于将3乘以自身六次：3 × 3 × 3 × 3 × 3 × 3 = 729。这是一个如此常见的操作，以至于Python有`**`运算符，JavaScript有内置的`Math.pow()`函数来执行指数运算。我们可以用Python代码`3
    ** 6`和JavaScript代码`Math.pow(3, 6)`来计算3⁶。'
- en: 'But let’s write our own exponent-calculating code. The solution is straightforward:
    create a loop that repeatedly multiplies a number by itself and returns the final
    product. Here is an iterative *exponentByIteration.py* Python program:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们编写我们自己的指数计算代码。解决方案很简单：创建一个循环，重复地将一个数字乘以自身，并返回最终的乘积。下面是一个迭代的*exponentByIteration.py*
    Python程序：
- en: '**Python**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And here is an equivalent JavaScript *exponentByIteration.html* program:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个等价的JavaScript*exponentByIteration.html*程序：
- en: '**JavaScript**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you run these programs, the output looks like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这些程序时，输出如下：
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is a straightforward calculation that we can easily write with a loop.
    The downside to using a loop is that the function slows as the exponents get larger:
    calculating 3^(12) takes twice as long as 3⁶, and 3^(600) takes one hundred times
    as long as 3⁶. In the next section, we address this by thinking recursively.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个直接的计算，我们可以很容易地用循环来编写。使用循环的缺点是，随着指数变大，函数的速度变慢：计算3^(12)需要的时间是3⁶的两倍，而3^(600)需要的时间是3⁶的一百倍。在下一节中，我们将通过递归来解决这个问题。
- en: Creating a Recursive Exponents Function
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个递归指数函数
- en: 'Let’s think of what a recursive solution for the exponentiation of, say, 3⁶
    would be. Because of the associative property of multiplication, 3 × 3 × 3 × 3
    × 3 × 3 is the same as (3 × 3 × 3) × (3 × 3 × 3), which is the same as (3 × 3
    × 3)². And since (3 × 3 × 3) is the same as 3³, we can determine that 3⁶ is the
    same as (3³)². This is an example of what mathematics calls the *power rule*:
    (*a*^(*m*))^(*n*) = *a*^(*mn*). Mathematics also gives us the *product rule*:
    *a*^(*n*) × *a*^(*m*) = *a*^(*n*) ^(+ m), including *a*^(*n*) × *a* = *a*^(*n*)
    ^(+ 1).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想一想，比如说，3⁶的指数的递归解决方案会是什么样的。由于乘法的结合性质，3 × 3 × 3 × 3 × 3 × 3与(3 × 3 × 3) ×
    (3 × 3 × 3)是相同的，这与(3 × 3 × 3)²是相同的。由于(3 × 3 × 3)与3³是相同的，我们可以确定3⁶与(3³)²是相同的。这是数学所称的*幂规则*的一个例子：(*a*^(*m*))^(*n*)
    = *a*^(*mn*)。数学还给了我们*乘法规则*：*a*^(*n*) × *a*^(*m*) = *a*^(*n*) ^(+ m)，包括*a*^(*n*)
    × *a* = *a*^(*n*) ^(+ 1)。
- en: 'We can use these mathematical rules to make an `exponentByRecursion()` function.
    If `exponentByRecursion(3, 6)` is called, it’s the same as `exponentByRecursion(3,
    3) * exponentByRecursion(3, 3)`. Of course, we don’t actually have to make both
    `exponentByRecursion(3, 3)` calls: we could just save the return value to a variable
    and multiply it by itself.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些数学规则来制作一个`exponentByRecursion()`函数。如果调用`exponentByRecursion(3, 6)`，它与`exponentByRecursion(3,
    3) * exponentByRecursion(3, 3)`是相同的。当然，我们实际上不必进行两次`exponentByRecursion(3, 3)`调用：我们可以将返回值保存到一个变量中，然后将其乘以自身。
- en: That works for even-numbered exponents, but what about for odd-numbered exponents?
    If we had to calculate 3⁷, or 3 × 3 × 3 × 3 × 3 × 3 × 3, this is the same as (3
    × 3 × 3 × 3 × 3 × 3) × 3, or (3⁶) × 3\. Then we can make the same recursive call
    to calculate 3⁶.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于偶数次幂有效，但对于奇数次幂呢？如果我们必须计算3⁷，或3 × 3 × 3 × 3 × 3 × 3 × 3，这与(3 × 3 × 3 × 3 ×
    3 × 3) × 3相同，或(3⁶) × 3。然后我们可以进行相同的递归调用来计算3⁶。
- en: Those are the recursive cases, but what are the base cases? Mathematically speaking,
    any number to the zeroth power is defined as 1, while any number to the first
    power is the number itself. So for any function call `exponentByRecursion(a, n)`,
    if `n` is `0` or `1`, we can simply return `1` or `a`, respectively, because `a``0`
    is always `1` and `a``1` is always `a`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是递归情况，但基本情况是什么？从数学上讲，任何数的零次幂被定义为1，而任何数的一次幂就是这个数本身。因此，对于任何函数调用`exponentByRecursion(a,
    n)`，如果`n`是`0`或`1`，我们可以简单地返回`1`或`a`，因为`a``0`总是`1`，而`a``1`总是`a`。
- en: 'Using all this information, we can write code for the `exponentByRecursion()`
    function. Here is an *exponentByRecursion.py* file with the Python code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 利用所有这些信息，我们可以为`exponentByRecursion()`函数编写代码。以下是带有Python代码的*exponentByRecursion.py*文件：
- en: '**Python**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE42]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And here is the equivalent JavaScript code in *exponentByRecursion.html*:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*exponentByRecursion.html*中等效的JavaScript代码：
- en: '**JavaScript**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE43]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you run this code, the output is identical to the iterative version:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，输出与迭代版本相同：
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Each recursive call effectively cuts the problem size in half. This is what
    makes our recursive exponent algorithm faster than the iterative version; calculating
    3^(1000) iteratively entails 1,000 multiplication operations, while doing it recursively
    requires only 23 multiplications and divisions. When running the Python code under
    a performance profiler, calculating 3^(1000) iteratively 100,000 times takes 10.633
    seconds, but the recursive calculation takes only 0.406 seconds. That is a huge
    improvement!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 每个递归调用实际上将问题规模减半。这就是使我们的递归指数算法比迭代版本更快的原因；迭代地计算3^(1000)需要1000次乘法操作，而递归计算只需要23次乘法和除法。在性能分析器下运行Python代码时，迭代地计算3^(1000)100,000次需要10.633秒，但递归计算只需要0.406秒。这是一个巨大的改进！
- en: Creating an Iterative Exponents Function Based on Recursive Insights
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于递归洞察力创建一个迭代指数函数
- en: 'Our original iterative exponents function took a straightforward approach:
    loop the same number of times as the exponent power. However, this doesn’t scale
    well for larger powers. Our recursive implementation forced us to think about
    how to break this problem into smaller subproblems. This approach turns out to
    be much more efficient.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的迭代指数函数采用了一种直接的方法：循环的次数与指数幂相同。然而，这对于更大的幂并不适用。我们的递归实现迫使我们考虑如何将这个问题分解为更小的子问题。这种方法事实证明更加高效。
- en: 'Because every recursive algorithm has an equivalent iterative algorithm, we
    could make a new iterative exponents function based on the power rule that the
    recursive algorithm uses. The following *exponentWithPowerRule.py* program has
    such a function:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个递归算法都有一个等效的迭代算法，我们可以基于递归算法使用的幂规则创建一个新的迭代指数函数。以下*exponentWithPowerRule.py*程序有这样一个函数：
- en: '**Python**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE45]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here is the equivalent JavaScript program in *exponentWithPowerRule.html*:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*exponentWithPowerRule.html*中等效的JavaScript程序：
- en: '**JavaScript**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE46]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our algorithm keeps reducing `n` by dividing it in half (if it’s even) or subtracting
    1 (if it’s odd) until it is `1`. This gives us the squaring or multiply-by-`a`
    operations we have to perform. After finishing this step, we perform these operations
    in reverse order. A generic stack data structure (separate from the call stack)
    is useful for reversing the order of these operations since it’s a first-in, last-out
    data structure. The first step pushes squaring or multiply-by-`a` operations to
    a stack in the `opStack` variable. In the second step, it performs these operations
    as it pops them off the stack.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的算法通过将“n”减半（如果它是偶数）或减1（如果它是奇数）来不断减少“n”，直到它变为“1”。这给了我们必须执行的平方或乘以“a”的操作。完成此步骤后，我们按相反的顺序执行这些操作。通用的堆栈数据结构（与调用堆栈分开）对于颠倒这些操作的顺序非常有用，因为它是一种先进后出的数据结构。第一步将平方或乘以“a”的操作推送到“opStack”变量中的堆栈。在第二步中，它在弹出堆栈时执行这些操作。
- en: For example, calling `exponentWithPowerRule(6, 5)` to calculate 6⁵ sets `a`
    as `6` and `n` as `5`. The function notes that `n` is odd. This means we should
    subtract `1` from `n` to get `4` and push a multiply-by-`a` operation to `opStack`.
    Now that `n` is `4` (even), we divide it by `2` to get `2` and push a squaring
    operation to `opStack`. Since `n` is now `2` and even again, we divide it by `2`
    to get `1` and push another squaring operation to `opStack`. Now that `n` is `1`,
    we are finished with this first step.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，调用“exponentWithPowerRule(6, 5)”来计算6⁵，将“a”设置为“6”，将“n”设置为“5”。函数注意到“n”是奇数。这意味着我们应该从“n”中减去“1”得到“4”，并将一个乘以“a”的操作推送到“opStack”。现在“n”是“4”（偶数），我们将其除以“2”得到“2”，并将一个平方操作推送到“opStack”。由于“n”现在是“2”并且再次是偶数，我们将其除以“2”得到“1”，并将另一个平方操作推送到“opStack”。现在“n”是“1”，我们已经完成了这一步。
- en: To perform the second step, we start the `result` as `a` (which is `6`). We
    pop the `opStack` stack to get a squaring operation, telling the program to set
    `result` to `result * result` (that is, `result``2`) or `36`. We pop the next
    operation off `opStack`, and it is another squaring operation, so the program
    changes the `36` in `result` to `36 * 36`, or `1296`. We pop the last operation
    off `opStack`, and it is a multiply-by-`a` operation, so we multiply the `1296`
    in `result` by `a` (which is `6`) to get `7776`. There are no more operations
    on `opStack`, so the function is now finished. When we double-check our math,
    we find that 6⁵ is indeed 7,776.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行第二步，我们将“result”开始为“a”（即“6”）。我们弹出opStack堆栈以获得一个平方操作，告诉程序将“result”设置为“result
    * result”（即“result”2）或“36”。我们弹出opStack的下一个操作，又是一个平方操作，所以程序将“result”中的“36”更改为“36
    * 36”，或“1296”。我们弹出opStack的最后一个操作，它是一个乘以“a”的操作，所以我们将“result”中的“1296”乘以“a”（即“6”）得到“7776”。opStack上没有更多的操作，所以函数现在已经完成。当我们再次检查我们的数学时，我们发现6⁵确实是7,776。
- en: The stack in `opStack` looks like [Figure 2-4](#figure2-4) as the function call
    `exponentWithPowerRule(6, 5)` executes.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: opStack中的堆栈在函数调用“exponentWithPowerRule(6, 5)”执行时看起来像[图2-4](#figure2-4)。
- en: '![Timeline showing the state of the opStack stack over time. In the first step,
    it begins empty; then Multiply is pushed to the stack, Square is pushed to the
    stack, and, finally, a second Square operation is pushed to the top of the stack.
    In the second step, the most recent Square operation is popped off the stack,
    the first Square operation is popped off the stack, and then the Multiply operation
    is popped off the stack, which is now empty.](image_fi/502024c02/f02004.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴显示了随时间推移opStack堆栈的状态。在第一步中，它开始为空；然后将Multiply推送到堆栈，将Square推送到堆栈，最后将第二个Square操作推送到堆栈顶部。在第二步中，最近的Square操作从堆栈中弹出，第一个Square操作从堆栈中弹出，然后将Multiply操作从堆栈中弹出，现在堆栈为空。](image_fi/502024c02/f02004.png)'
- en: 'Figure 2-4: The stack in `opStack` during the `exponentWithPowerRule(6, 5)`
    function call'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-4：在函数调用“exponentWithPowerRule(6, 5)”期间opStack中的堆栈
- en: 'When you run this code, the output is identical to the other exponent programs:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，输出与其他指数程序相同：
- en: '[PRE47]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The iterative exponents function that uses the power rule has the improved performance
    of the recursive algorithm, while not suffering from the risk of a stack overflow.
    We might not have thought of this new, improved iterative algorithm without the
    insights of recursive thinking.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用幂规则的迭代指数函数具有递归算法的改进性能，同时不会遭受堆栈溢出的风险。如果没有递归思维的见解，我们可能不会想到这种新的、改进的迭代算法。
- en: When Do You Need to Use Recursion?
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时需要使用递归？
- en: You never *need* to use recursion. No programming problem *requires* recursion.
    This chapter has shown that recursion has no magical power to do things that iterative
    code in a loop with a stack data structure cannot do. In fact, a recursive function
    might be an overcomplicated solution for what you’re trying to achieve.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您永远不需要使用递归。没有编程问题需要递归。本章已经表明，递归没有魔力可以做迭代代码和堆栈数据结构中的循环无法做的事情。实际上，递归函数可能是您尝试实现的内容的过于复杂的解决方案。
- en: 'However, as the exponent functions we created in the previous section show,
    recursion can provide new insights into how to think about our programming problem.
    Three features of a programming problem, when present, make it especially suitable
    to a recursive approach:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在上一节中创建的指数函数所示，递归可以为我们如何思考编程问题提供新的见解。编程问题的三个特征，当存在时，使其特别适合递归方法：
- en: It involves a tree-like structure.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它涉及树状结构。
- en: It involves backtracking.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它涉及回溯。
- en: It isn’t so deeply recursive as to potentially cause a stack overflow.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它并不是如此深度递归，以至于可能导致堆栈溢出。
- en: 'A tree has a *self-similar* structure: the branching points look similar to
    the root of a smaller subtree. Recursion often deals with self-similarity and
    problems that can be divided into smaller, similar subproblems. The root of the
    tree is analogous to the first call to a recursive function, the branching points
    are analogous to recursive cases, and the leaves are analogous to the base cases
    where no more recursive calls are made.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 树具有*自相似*结构：分叉点看起来类似于较小子树的根。递归通常涉及自相似性和可以分解为更小、相似子问题的问题。树的根类似于对递归函数的第一次调用，分叉点类似于递归情况，叶子类似于没有更多递归调用的基本情况。
- en: A maze is also a good example of a problem that has a tree-like structure and
    requires backtracking. In a maze, the branching points occur wherever you must
    pick one of many paths to follow. If you reach a dead end, you’ve encountered
    the base case. You must then backtrack to a previous branching point to select
    a different path to follow.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫也是一个具有树状结构并需要回溯的问题的很好例子。在迷宫中，分叉点出现在您必须选择许多路径中的一个时。如果您到达了死胡同，那么您已经遇到了基本情况。然后您必须回溯到先前的分叉点，选择一个不同的路径继续前进。
- en: '[Figure 2-5](#figure2-5) shows a maze’s path visually morphed to look like
    a biological tree. Despite the visual difference between the maze paths and the
    tree-shaped paths, their branching points are related to each other in the same
    way. Mathematically, these graphs are equivalent.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-5](#figure2-5)显示了一个迷宫的路径在视觉上形变成生物树的样子。尽管迷宫路径和树形路径在视觉上有所不同，但它们的分叉点在数学上是相关的。从数学上讲，这些图是等价的。'
- en: '![Three images: the first is a classic maze with branching paths, the second
    shows lines tracing through every path of the maze with a circle at every branch,
    and the third is this line-and-circle drawing distorted to look like the branches
    of a tree.](image_fi/502024c02/f02005.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![三幅图像：第一幅是一个经典的迷宫，有分叉路径，第二幅显示了迷宫中每条路径的线条，并在每个分叉处有一个圆圈，第三幅是这条线和圆圈的图案扭曲成树枝的样子。](image_fi/502024c02/f02005.png)'
- en: 'Figure 2-5: A maze (left) along with its interior paths (center) morphed to
    match a biological tree’s shape (right)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-5：一个迷宫（左）以及其内部路径（中）形变成生物树的形状（右）
- en: Many programming problems have this tree-like structure at their core. For example,
    a filesystem has a tree-like structure; the subfolders look like the root folders
    of a smaller filesystem. [Figure 2-6](#figure2-6) compares a filesystem to a tree.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程问题都具有这种树状结构。例如，文件系统具有树状结构；子文件夹看起来像较小文件系统的根文件夹。[图2-6](#figure2-6)将文件系统与树进行了比较。
- en: '![Two images, one of a tree and the other of a filesystem, with arrows pointing
    out the equivalent of leaves, branching points, and the root on each.](image_fi/502024c02/f02006.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![两幅图像，一幅是一棵树，另一幅是一个文件系统，箭头指出了每个等价的叶子、分叉点和根。](image_fi/502024c02/f02006.png)'
- en: 'Figure 2-6: A filesystem is similar to a tree structure.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-6：文件系统类似于树结构。
- en: 'Searching for a specific filename in a folder is a recursive problem: you search
    the folder and then recursively search the folder’s subfolders. Folders with no
    subfolders are the base cases that cause the recursive searching to stop. If your
    recursive algorithm doesn’t find the filename it’s looking for, it backtracks
    to a previous parent folder and continues searching from there.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件夹中搜索特定文件名是一个递归问题：您搜索文件夹，然后递归搜索文件夹的子文件夹。没有子文件夹的文件夹是导致递归搜索停止的基本情况。如果您的递归算法找不到它正在寻找的文件名，它会回溯到先前的父文件夹，并从那里继续搜索。
- en: The third point is a matter of practicality. If your tree structure has so many
    levels of branches that a recursive function would cause a stack overflow before
    it can reach the leaves, then recursion isn’t a suitable solution.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第三点是实用性问题。如果您的树结构具有如此多层的分支，以至于递归函数在到达叶子之前就会导致堆栈溢出，那么递归就不是一个合适的解决方案。
- en: On the other hand, recursion is the best approach for creating programming language
    compilers. Compiler design is its own expansive subject and beyond the scope of
    this book. But programming languages have a set of grammar rules that can break
    source code into a tree structure similar to the way grammar rules can break English
    sentences into a tree diagram. Recursion is an ideal technique to apply to compilers.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，递归是创建编程语言编译器的最佳方法。编译器设计是一个庞大的课题，超出了本书的范围。但是编程语言有一组语法规则，可以将源代码分解成类似于语法规则可以将英语句子分解成树状图的树状结构。递归是应用于编译器的理想技术。
- en: We’ll identify many recursive algorithms in this book, and they often have the
    tree-like structure or backtracking features that lend themselves to recursion
    well.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中识别许多递归算法，它们通常具有树状结构或回溯特性，非常适合递归。
- en: Coming Up with Recursive Algorithms
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提出递归算法
- en: Hopefully, this chapter has given you a firm idea of how recursive functions
    compare to the iterative algorithms you’re likely more familiar with. The rest
    of this book dives into the details of various recursive algorithms. But how should
    you go about writing your own recursive functions?
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 希望本章让您对递归函数与您可能更熟悉的迭代算法有了一个坚实的概念。本书的其余部分将深入探讨各种递归算法的细节。但是，您应该如何编写自己的递归函数呢？
- en: The first step is always to identify the recursive case and the base case. You
    can take a top-down approach by breaking the problem into subproblems that are
    similar to the original problem but smaller; this is your *recursive case*. Then
    consider when the subproblems are small enough to have a trivial answer; this
    is your *base case*. Your recursive function may have more than one recursive
    case or base case, but all recursive functions will always have at least one recursive
    case and at least one base case.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步总是要确定递归情况和基本情况。您可以采用自顶向下的方法，将问题分解为与原始问题相似但更小的子问题；这就是您的*递归情况*。然后考虑子问题何时足够小以获得一个微不足道的答案；这就是您的*基本情况*。您的递归函数可能有多个递归情况或基本情况，但所有递归函数都至少有一个递归情况和至少一个基本情况。
- en: The recursive Fibonacci algorithm is an example. A Fibonacci number is the sum
    of the previous two Fibonacci numbers. We can break the problem of finding a Fibonacci
    number into the subproblems of finding two smaller Fibonacci numbers. We know
    the first two Fibonacci numbers are both 1, so that provides the base case answer
    once the subproblems are small enough.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 递归斐波那契算法就是一个例子。斐波那契数是前两个斐波那契数的和。我们可以将查找斐波那契数的问题分解为查找两个较小斐波那契数的子问题。我们知道前两个斐波那契数都是1，所以一旦子问题足够小，就可以得到基本情况的答案。
- en: Sometimes it helps to take a bottom-up approach and consider the base case first,
    and then see how larger and larger problems are constructed and solved from there.
    The recursive factorial problem is an example. The factorial of 1! is 1\. This
    forms the base case. The next factorial is 2!, and you create it by multiplying
    1! by 2\. The factorial after that, 3!, is created by multiplying 2! by 3, and
    so on. From this general pattern, we can figure out what the recursive case for
    our algorithm will be.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，先采用自下而上的方法考虑基本情况，然后再看如何从中构建和解决更大的问题。递归阶乘问题就是一个例子。1的阶乘是1。这形成了基本情况。下一个阶乘是2！，你可以通过将1！乘以2来创建它。之后的阶乘，3！，是通过将2！乘以3来创建的，依此类推。通过这种一般模式，我们可以找出我们算法的递归情况会是什么。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered calculating factorials and the Fibonacci sequence,
    two classic recursive programming problems. This chapter featured both iterative
    and recursive implementations for these algorithms. Despite being classic examples
    of recursion, their recursive algorithms suffer from critical flaws. The recursive
    factorial function can cause stack overflows, while the recursive Fibonacci function
    performs so many redundant calculations that it’s far too slow to be effective
    in the real world.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们涵盖了计算阶乘和斐波那契数列，这两个经典的递归编程问题。本章介绍了这些算法的迭代和递归实现。尽管它们是递归的经典示例，但它们的递归算法存在严重的缺陷。递归阶乘函数可能会导致堆栈溢出，而递归斐波那契函数执行了太多的冗余计算，以至于在现实世界中效率太低。
- en: We explored how to create recursive algorithms from iterative algorithms and
    how to create iterative algorithms from recursive algorithms. Iterative algorithms
    use a loop, and any recursive algorithm can be performed iteratively by using
    a loop and a stack data structure. Recursion is often an overly complicated solution,
    but programming problems that involve a tree-like structure and backtracking are
    particularly suitable for recursive implementations.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何从迭代算法创建递归算法，以及如何从递归算法创建迭代算法。迭代算法使用循环，任何递归算法都可以通过使用循环和堆栈数据结构来进行迭代执行。递归通常是一个过于复杂的解决方案，但涉及树状结构和回溯的编程问题特别适合递归实现。
- en: Writing recursive functions is a skill that improves with practice and experience.
    The rest of this book covers several well-known recursion examples and explores
    their strengths and limitations.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 编写递归函数是一种随着练习和经验而提高的技能。本书的其余部分涵盖了几个众所周知的递归示例，并探讨了它们的优势和局限性。
- en: Further Reading
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You can find more information about comparing iteration and recursion in the
    Computerphile YouTube channel’s video “Programming Loops vs. Recursion” at [https://youtu.be/HXNhEYqFo0o](https://youtu.be/HXNhEYqFo0o).
    If you want to compare the performance of iterative and recursive functions, you
    need to learn how to use a profiler. Python profilers are explained in Chapter
    13 of my book *Beyond the Basic Stuff with Python* (No Starch Press, 2020), which
    can be read at [https://inventwithpython.com/beyond/chapter13.html](https://inventwithpython.com/beyond/chapter13.html).
    The official Python documentation also covers profilers at [https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html).
    The Firefox profiler for JavaScript is explained on Mozilla’s website at [https://developer.mozilla.org/en-US/docs/Tools/Performance](https://developer.mozilla.org/en-US/docs/Tools/Performance).
    Other browsers have profilers similar to Firefox’s.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Computerphile YouTube频道的视频“Programming Loops vs. Recursion”中找到有关比较迭代和递归的更多信息，网址为[https://youtu.be/HXNhEYqFo0o](https://youtu.be/HXNhEYqFo0o)。如果您想比较迭代和递归函数的性能，您需要学习如何使用分析器。Python分析器在我的书*Beyond
    the Basic Stuff with Python*（No Starch Press, 2020）的第13章中有解释，可以在[https://inventwithpython.com/beyond/chapter13.html](https://inventwithpython.com/beyond/chapter13.html)上阅读。官方的Python文档也涵盖了分析器，网址为[https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html)。Mozilla网站上解释了JavaScript的Firefox分析器，网址为[https://developer.mozilla.org/en-US/docs/Tools/Performance](https://developer.mozilla.org/en-US/docs/Tools/Performance)。其他浏览器也有类似于Firefox的分析器。
- en: Practice Questions
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习问题
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试您的理解：
- en: What is 4! (that is, the factorial of 4)?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4的阶乘是多少？
- en: How can you use the factorial of (*n* – 1) to calculate the factorial of *n*?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用(*n* – 1)的阶乘来计算*n*的阶乘？
- en: What is the critical weakness of the recursive factorial function?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归阶乘函数的关键弱点是什么？
- en: What are the first five numbers of the Fibonacci sequence?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 斐波那契数列的前五个数字是什么？
- en: What two numbers do you add to get the *n*th Fibonacci number?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了得到第*n*个斐波那契数，你需要加上哪两个数字？
- en: What is the critical weakness of the recursive Fibonacci function?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归斐波那契函数的关键弱点是什么？
- en: What does an iterative algorithm always use?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代算法总是使用什么？
- en: Is it always possible to convert an iterative algorithm into a recursive one?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是可以将迭代算法转换为递归算法吗？
- en: Is it always possible to convert a recursive algorithm into an iterative one?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是可以将递归算法转换为迭代算法吗？
- en: Any recursive algorithm can be performed iteratively by using what two things?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何递归算法都可以通过使用哪两种方法来进行迭代执行？
- en: What three features do programming problems that are suitable to recursive solutions
    have?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适合递归解决方案的编程问题具有哪三个特征？
- en: When is recursion required to solve a programming problem?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时需要递归来解决编程问题？
- en: Practice Projects
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习项目
- en: 'For practice, write a function for each of the following tasks:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 练习时，为以下每个任务编写一个函数：
- en: Iteratively calculate the sum of the integer series from `1` to `n`. This is
    similar to the `factorial()` function, except it performs addition instead of
    multiplication. For example, `sumSeries(1)` returns `1`, `sumSeries(2)` returns
    `3` (that is, `1 + 2`), `sumSeries(3)` returns `6` (that is, `1 + 2 + 3`), and
    so on. This function should use a loop instead of recursion. Take a look at the
    *factorialByIteration.py* program in this chapter for guidance.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代计算从`1`到`n`的整数序列的和。这类似于`factorial()`函数，只是它执行加法而不是乘法。例如，`sumSeries(1)`返回`1`，`sumSeries(2)`返回`3`（即`1
    + 2`），`sumSeries(3)`返回`6`（即`1 + 2 + 3`），依此类推。这个函数应该使用循环而不是递归。可以参考本章的*factorialByIteration.py*程序。
- en: Write the recursive form of `sumSeries()`. This function should use recursive
    function calls instead of a loop. Look at the *factorialByRecursion.py* program
    in this chapter for guidance.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`sumSeries()`的递归形式。这个函数应该使用递归函数调用而不是循环。可以参考本章的*factorialByRecursion.py*程序。
- en: Iteratively calculate the sum of the first `n` powers of 2 in a function named
    `sumPowersOf2()`. The powers of 2 are 2, 4, 8, 16, 32, and so on. In Python, these
    are calculated with `2 ** 1`, `2 ** 2`, `2 ** 3`, `2 ** 4`, `2 ** 5`, and so on,
    respectively. In JavaScript, these are calculated with `Math.pow(2, 1)`, `Math.pow(2,
    2)`, and so on. For example, `sumPowersOf2(1)` returns `2`, `sumPowersOf2(2)`
    returns `6` (that is, `2 + 4`), `sumPowersOf2(3)` returns `14` (that is, `2 +
    4 + 8`), and so on.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为`sumPowersOf2()`的函数中迭代计算前`n`个2的幂的和。2的幂是2、4、8、16、32等等。在Python中，这些是通过`2 **
    1`、`2 ** 2`、`2 ** 3`、`2 ** 4`、`2 ** 5`等等计算的。在JavaScript中，这些是通过`Math.pow(2, 1)`、`Math.pow(2,
    2)`等等计算的。例如，`sumPowersOf2(1)`返回`2`，`sumPowersOf2(2)`返回`6`（即`2 + 4`），`sumPowersOf2(3)`返回`14`（即`2
    + 4 + 8`），依此类推。
- en: Write the recursive form of `sumPowersOf2()`. This function should use recursive
    function calls instead of a loop.`  `# 3
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`sumPowersOf2()`的递归形式。这个函数应该使用递归函数调用而不是循环。`# 3`
- en: Classic Recursion Algorithms
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 经典递归算法
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: If you take a computer science course, the unit on recursion is sure to cover
    some of the classic algorithms presented in this chapter. Coding interviews (which,
    for lack of suitable ways to evaluate candidates, often crib notes from freshman
    computer science curricula) can touch upon them too. This chapter covers six classic
    problems in recursion, along with their solutions.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你上了计算机科学课，递归单元肯定会涵盖本章介绍的一些经典算法。编码面试（由于缺乏合适的评估候选人的方法，通常抄袭大一计算机科学课程笔记）也可能涉及到它们。本章介绍了递归中的六个经典问题以及它们的解决方案。
- en: 'We begin with three simple algorithms: summing the numbers in an array, reversing
    a text string, and detecting whether a string is a palindrome. Then we explore
    an algorithm for solving the Tower of Hanoi puzzle, implement the flood fill drawing
    algorithm, and tackle the absurdly recursive Ackermann function.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍三个简单的算法：对数组中的数字求和、反转文本字符串以及检测字符串是否为回文。然后我们探讨解决汉诺塔难题的算法，实现泛洪填充绘图算法，并解决荒谬的递归Ackermann函数。
- en: 'In the process, you’ll learn about the head-tail technique for splitting up
    the data in the recursive function arguments. We’ll also ask ourselves three questions
    when trying to come up with recursive solutions: What is the base case? What argument
    is passed to the recursive function call? And how do the arguments passed to the
    recursive function calls become closer to the base case? As you gain more experience,
    answering these questions should come more naturally.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，你将学习到递归函数参数中的头尾技术。当尝试提出递归解决方案时，我们还会问自己三个问题：什么是基本情况？递归函数调用传递了什么参数？递归函数调用传递的参数如何接近基本情况？随着经验的增加，回答这些问题应该会更加自然。
- en: Summing Numbers in an Array
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数组中的数字求和
- en: 'Our first example is simple: given a list (in Python) or an array (in JavaScript)
    of integers, return the total sum of all the integers. For example, a call such
    as `sum([5, 2, 4, 8])` should return `19`.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子很简单：给定一个整数列表（在Python中）或一个整数数组（在JavaScript中），返回所有整数的总和。例如，像`sum([5, 2,
    4, 8])`这样的调用应该返回`19`。
- en: This is easy to solve with a loop, but solving it with recursion requires more
    thought. After reading Chapter 2, you might also notice that this algorithm doesn’t
    map well enough to recursion’s capabilities to justify recursion’s added complexity.
    Still, summing numbers in an array (or some other calculation based on processing
    data in a linear data structure) is a common enough recursion problem in coding
    interviews that it deserves our attention.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题用循环很容易解决，但用递归解决需要更多的思考。在阅读第二章之后，你可能也会注意到这个算法与递归的能力不够匹配，无法证明递归的复杂性。然而，在编码面试中，对数组中的数字求和（或者基于线性数据结构处理数据的其他计算）是一个常见的递归问题，值得我们关注。
- en: 'To solve this problem, let’s examine the *head-tail technique* for implementing
    recursive functions. This technique splits the recursive function’s array argument
    into two parts: the *head* (the first element of the array) and the *tail* (a
    new array including everything after the first element). We define the recursive
    `sum()` function to find the sum of the array argument’s integers by adding the
    head to the sum of the tail array. To find out the sum of the tail array, we recursively
    pass it as the array argument to `sum()`.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们来看看实现递归函数的*头尾技术*。这个技术将递归函数的数组参数分成两部分：*头*（数组的第一个元素）和*尾*（包括第一个元素之后的所有内容的新数组）。我们定义递归的`sum()`函数来通过将头部添加到尾部数组的总和来找到数组参数的整数的总和。为了找出尾部数组的总和，我们将其递归地作为数组参数传递给`sum()`。
- en: 'Because the tail array is one element smaller than the original array argument,
    we’ll eventually end up calling the recursive function and passing it an empty
    array. An empty array argument is trivial to sum and doesn’t require more recursive
    calls; it is merely `0`. From these facts, our answers to the three questions
    are as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 因为尾部数组比原始数组参数少一个元素，所以我们最终将调用递归函数并传递一个空数组。空数组参数很容易求和，不需要更多的递归调用；它只是`0`。根据这些事实，我们对三个问题的答案如下：
- en: What is the base case? An empty array, which has the sum of `0`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？一个空数组，其和为`0`。
- en: What argument is passed to the recursive function call? The tail of the original
    number array, which has one less number than the original array argument.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？原始数字数组的尾部，比原始数组参数少一个数字。
- en: How does this argument become closer to the base case? The array argument shrinks
    by one element for each recursive call until it becomes a zero-length, or empty,
    array.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何变得更接近基本情况？数组参数每次递归调用都会减少一个元素，直到变成长度为零的空数组。
- en: 'Here is *sumHeadTail.py*, a Python program to sum a list of numbers:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*sumHeadTail.py*，一个用于对数字列表求和的Python程序：
- en: '**Python**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE48]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And here is the equivalent JavaScript program, *sumHeadTail.html*:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这是等效的JavaScript程序*sumHeadTail.html*：
- en: '**JavaScript**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE49]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output of these programs is shown here:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下所示：
- en: '[PRE50]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When called with an empty array argument, the base case of our function simply
    returns `0` ❶. In the recursive case, we form the head ❷ and the tail ❸ from the
    original `numbers` argument. Keep in mind that the data type of `tail` is an array
    of numbers, just like the `numbers` argument. But the data type of `head` is just
    a single number value, and not an array with one number value. The return value
    of the `sum()` function is also a single number value and not an array of numbers;
    this is why we can add `head` and `sum(tail)` together in the recursive case ❹.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用空数组参数调用时，我们的函数的基本情况简单地返回`0`❶。在递归情况中，我们从原始的`numbers`参数中形成头❷和尾部❸。请记住，`tail`的数据类型是一个数字数组，就像`numbers`参数一样。但是`head`的数据类型只是一个单一的数字值，而不是一个带有一个数字值的数组。`sum()`函数的返回值也是一个单一的数字值，而不是一个数字数组；这就是为什么我们可以在递归情况中将`head`和`sum(tail)`相加❹。
- en: Each recursive call passes a smaller and smaller array to `sum()`, bringing
    it closer to the base case of an empty array. For example, [Figure 3-1](#figure3-1)
    shows the state of the call stack for `sum([5, 2, 4, 8])`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 每次递归调用都将一个越来越小的数组传递给`sum()`，使其更接近空数组的基本情况。例如，[图3-1](#figure3-1)显示了对`sum([5,
    2, 4, 8])`的调用堆栈的状态。
- en: 'In this figure, each card in the stack represents a function call. At the top
    of each card is the function name with the argument it was passed when called.
    Beneath that are the local variables: the `numbers` parameter, and the `head`
    and `tail` local variables created during the call. At the bottom of the card
    is the `head + sum(tail)` expression that the function call returns. When a new
    recursive function is made, a new card is pushed to the stack. When the function
    call returns, the top card is popped from the stack.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，堆栈中的每张卡片代表一个函数调用。每张卡片的顶部是函数名和调用时传递的参数。其下是局部变量：`numbers`参数，以及在调用过程中创建的`head`和`tail`局部变量。卡片底部是函数调用返回的`head
    + sum(tail)`表达式。当创建一个新的递归函数时，一个新的卡片被推到堆栈上。当函数调用返回时，顶部的卡片从堆栈中弹出。
- en: '![A series of stacks of cards representing frame objects on the call stack.
    In order, the new top card represents a call to sum() passing [5, 2, 4, 8], then
    passing [2, 4, 8], then passing [4, 8], then passing [8], then passing an empty
    list. Then the top cards are removed, first removing the empty list card, then
    the [8] card, then [4, 8], then [2, 4, 8], then [5, 2, 4, 8].](image_fi/502024c03/f03001.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![一系列代表调用堆栈上的帧对象的卡片堆叠。依次，新的顶部卡片代表对sum()传递[5, 2, 4, 8]的调用，然后传递[2, 4, 8]，然后传递[4,
    8]，然后传递[8]，然后传递一个空列表。然后顶部卡片被移除，首先移除空列表卡片，然后[8]卡片，然后[4, 8]卡片，然后[2, 4, 8]卡片，然后[5,
    2, 4, 8]卡片。](image_fi/502024c03/f03001.png)'
- en: 'Figure 3-1: The state of the call stack when `sum([5, 2, 4, 8])` runs'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1：当运行`sum([5, 2, 4, 8])`时调用堆栈的状态
- en: We can use the `sum()` function as a template for applying the head-tail technique
    to other recursive functions. For example, you can change the `sum()` function
    from one that sums an array of numbers to a `concat()` function that concatenates
    an array of strings together. The base case would return an empty string for an
    empty array argument, while the recursive case would return the head string joined
    with the return value of the recursive call that is passed the tail.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`sum()`函数作为应用头尾技术到其他递归函数的模板。例如，你可以将`sum()`函数从对数字数组求和的函数更改为`concat()`函数，用于将字符串数组连接在一起。基本情况将返回一个空字符串作为空数组参数，而递归情况将返回头字符串与传递尾部的递归调用的返回值连接在一起。
- en: Recall from Chapter 2 that recursion is especially suited for problems that
    involve a tree-like structure and backtracking. An array, string, or other linear
    data structure can be considered a tree-like structure, albeit a tree that has
    only one branch at each node, as in [Figure 3-2](#figure3-2).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第2章，递归特别适用于涉及树状结构和回溯的问题。数组、字符串或其他线性数据结构可以被视为树状结构，尽管这是一个只有一个分支的树，就像[图3-2](#figure3-2)中所示的那样。
- en: '![Two images, one of a tree with every node circled, and one of a crooked branch
    with every bend circled and the numbers 8, 4, 2, and 5 written in the circles.](image_fi/502024c03/f03002.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![两幅图像，一幅是每个节点都被圈起来的树，另一幅是每个弯曲处都被圈起来的树枝，并且圈内写着数字8、4、2和5。](image_fi/502024c03/f03002.png)'
- en: 'Figure 3-2: A `[5, 2, 4, 8]` array (right) is like a tree data structure (left)
    with only one branch at each node.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-2：一个`[5, 2, 4, 8]`数组（右侧）就像一个只有一个分支的树状数据结构（左侧）。
- en: The key “tell” that our recursive function is unnecessary is that it never does
    any backtracking over the data it processes. It makes a single pass over each
    element in the array from beginning to end, which is something a basic loop can
    accomplish. Additionally, the Python recursive summation function is about 100
    times slower than a straightforward iterative algorithm. Even if performance weren’t
    an issue, the recursive `sum()` function would cause a stack overflow if passed
    a list with tens of thousands of numbers to sum. Recursion is an advanced technique,
    but it isn’t always the best approach.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的递归函数不必要的关键“告诉”是它从不在处理的数据上进行任何回溯。它对数组中的每个元素进行单次遍历，这是基本循环可以完成的事情。此外，Python递归求和函数比直接迭代算法慢大约100倍。即使性能不是问题，递归`sum()`函数如果传递一个要求求和的数目为数万的列表会导致堆栈溢出。递归是一种高级技术，但并不总是最佳方法。
- en: In Chapter 5, we’ll examine a recursive summation function that uses a divide-and-conquer
    strategy, and in Chapter 8 we’ll examine one that uses tail call optimization.
    These alternate recursive approaches work around some of the problems in the summation
    function in this chapter.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章中，我们将研究使用分而治之策略的递归求和函数，在第8章中，我们将研究使用尾调用优化的递归函数。这些替代的递归方法解决了本章中求和函数的一些问题。
- en: Reversing a String
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转字符串
- en: Like summing the numbers in an array, reversing a string is another frequently
    cited recursive algorithm even though the iterative solution is straightforward.
    Because a string is essentially an array of single characters, we’ll employ the
    head and tail approach for our `rev()` function just as we did for the summation
    algorithm.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 像对数组中的数字求和一样，反转字符串是另一个经常被引用的递归算法，尽管迭代解决方案很简单。因为字符串本质上是一个由单个字符组成的数组，所以我们将为我们的`rev()`函数采用头部和尾部的方法，就像我们为求和算法所做的那样。
- en: 'Let’s start with the smallest strings possible. A blank string and a single-character
    string are already the reverse of themselves. These naturally form our base cases:
    if the string argument is a string such as `''''` or `′A′`, our function should
    simply return the string argument.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从可能的最小的字符串开始。一个空字符串和一个单字符字符串已经是它们自己的反转。这自然形成了我们的基本情况：如果字符串参数是`''`或`′A′`这样的字符串，我们的函数应该简单地返回字符串参数。
- en: 'For larger strings, let’s try splitting the string into a head (just the first
    character) and tail (all characters after the first). For a two-character string
    like `′XY′`, `′X′` is the head and `′Y′` is the tail. To reverse the string, we
    need to place the head behind the tail: `′YX′`.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更长的字符串，让我们尝试将字符串分割成头部（仅为第一个字符）和尾部（第一个字符之后的所有字符）。对于一个两个字符的字符串，比如`′XY′`，`′X′`是头部，`′Y′`是尾部。要反转字符串，我们需要将头部放在尾部后面：`′YX′`。
- en: Does this algorithm hold for longer strings? To reverse a string like `′CAT′`,
    we would break it into the head `′C′` and the tail `′AT′`. But placing the head
    behind the tail alone doesn’t reverse the string; it gives us `′ATC′`. What we
    actually want to do is put the head behind *the reverse of* the tail. In other
    words, `′AT′` would reverse to `′TA′`, and then adding the head to the end of
    that would produce the reversed string, `′TAC′`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法对更长的字符串有效吗？要反转像`′CAT′`这样的字符串，我们会将它分成头部`′C′`和尾部`′AT′`。但仅仅将头部放在尾部后面并不能反转字符串；它给我们的是`′ATC′`。实际上，我们想要做的是将头部放在尾部的*反转*后面。换句话说，`′AT′`会反转成`′TA′`，然后将头部添加到末尾会产生反转后的字符串`′TAC′`。
- en: 'How can we reverse the tail? Well, we can recursively call `rev()` and pass
    it the tail. Forget about the implementation of our function for a moment and
    focus on its input and output: `rev()` takes one string argument and returns a
    string with the argument’s characters reversed.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何反转尾部？嗯，我们可以递归调用`rev()`并将尾部传递给它。暂时忘记我们函数的实现，专注于它的输入和输出：`rev()`接受一个字符串参数，并返回一个将参数的字符反转的字符串。
- en: Thinking about how to implement a recursive function like `rev()` can be difficult
    because it involves a chicken-and-egg problem. In order to write `rev()`’s recursive
    case, we need to call a function that reverses a string—that is, `rev()`. As long
    as we have a solid understanding of what our recursive function’s arguments and
    return value will be, we can use the *leap-of-faith* technique to get around this
    chicken-and-egg problem by writing our recursive case assuming the `rev()` function
    call returns the correct value even though we haven’t finished writing it yet.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如何实现像`rev()`这样的递归函数可能很困难，因为它涉及到一个鸡和蛋的问题。为了编写`rev()`的递归情况，我们需要调用一个反转字符串的函数，也就是`rev()`。只要我们对我们的递归函数的参数和返回值有一个坚实的理解，我们就可以使用“信任飞跃”技术来解决这个鸡和蛋问题，即使我们还没有完成编写它。
- en: Taking a leap of faith in recursion is not a magical technique that guarantees
    your code works bug free. It is merely a perspective to hold to break past the
    mental programmer’s block you can have when thinking about how to implement your
    recursive function. The leap of faith requires you to have a firm understanding
    of your recursive function’s arguments and return value.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归中进行信任飞跃并不是一个可以保证您的代码无错误的神奇技术。它只是一种观点，可以打破您在思考如何实现递归函数时可能遇到的心理程序员障碍。信任飞跃要求您对递归函数的参数和返回值有坚定的理解。
- en: 'Note that the leap-of-faith technique only helps you write the recursive case.
    You must pass to the recursive call an argument that is closer to the base case.
    You can’t simply pass the same argument that the recursive function received,
    like this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，信任飞跃技术只有在编写递归情况时才有帮助。您必须将一个接近基本情况的参数传递给递归调用。您不能简单地传递递归函数接收到的相同参数，就像这样：
- en: '[PRE51]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To continue our `′CAT′` example, when we pass the tail `′AT′` to `rev()`, the
    head is `′A′` and the tail is `′T′` in *that* function call. We already know that
    the reverse of a single-character string like `′T′` is simply `′T′`; that’s our
    base case. So this second call to `rev()` will reverse `′AT′` to `′TA′`, which
    is precisely what the previous call to `rev()` needs. [Figure 3-3](#figure3-3)
    shows the state of the call stack during all the recursive calls to `rev()`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的`′CAT′`例子，当我们将尾部`′AT′`传递给`rev()`时，在*那个*函数调用中，头部是`′A′`，尾部是`′T′`。我们已经知道单个字符字符串的反转就是它自己；这是我们的基本情况。因此，对`rev()`的第二次调用将`′AT′`反转为`′TA′`，这正是之前对`rev()`的调用所需要的。[图3-3](#figure3-3)显示了在所有对`rev()`的递归调用期间调用堆栈的状态。
- en: 'Let’s ask our three recursive algorithm questions about the `rev()` function:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们问`rev()`函数的三个递归算法问题：
- en: What is the base case? A zero- or one-character string.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本情况是什么？零个或一个字符的字符串。
- en: What argument is passed to the recursive function call? The tail of the original
    string argument, which has one less character than the original string argument.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？原始字符串参数的尾部，比原始字符串参数少一个字符。
- en: How does this argument become closer to the base case? The array argument shrinks
    by one element for each recursive call until it becomes a one- or zero-length
    array.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何变得更接近基本情况？每次递归调用时，数组参数都会减少一个元素，直到成为一个零长度的数组。
- en: '![Timeline showing the state of the call stack during each recursive call to
    the rev function. It begins with rev called with the argument “CAT,” the theString
    variable equal to “CAT,” the head variable equal to “C,” the tail variable equal
    to “AT,” and a return value of rev(‘AT’) + ‘C’. Next, rev is called with the argument
    “AT,” theString is “AT,” head is “A,” tail is “T,” and the return value is rev(‘T’)
    + ‘A’. Then, rev is called with the argument “T,” theString is equal to “T,” and
    the function returns ‘T’. In the fourth state, rev is called with an argument
    of “AT,” theString is “AT,” head is “A,” tail is “T,” and the function returns
    ‘T’ + ‘A’. Finally, rev is called with the argument “CAT,” theString is “CAT,”
    head is “C,” tail is “AT,” and the function returns ‘TA’ + ‘C’. After this, the
    call stack is empty.](image_fi/502024c03/f03003.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴显示了在对rev函数的每次递归调用期间调用堆栈的状态。它以参数“CAT”调用rev开始，theString变量等于“CAT”，head变量等于“C”，tail变量等于“AT”，返回值为rev（‘AT’）+‘C’。接下来，使用参数“AT”调用rev，theString为“AT”，head为“A”，tail为“T”，返回值为rev（‘T’）+‘A’。然后，使用参数“T”调用rev，theString等于“T”，函数返回‘T’。在第四种状态下，使用参数“AT”调用rev，theString为“AT”，head为“A”，tail为“T”，函数返回‘T’+‘A’。最后，使用参数“CAT”调用rev，theString为“CAT”，head为“C”，tail为“AT”，函数返回‘TA’+‘C’。之后，调用堆栈为空。](image_fi/502024c03/f03003.png)'
- en: 'Figure 3-3: The state of the call stack as the `rev()` function reverses the
    `CAT` string'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3：`rev()`函数反转`CAT`字符串时调用堆栈的状态
- en: 'Here is *reverseString.py*, a Python program to reverse a string:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于反转字符串的Python程序*reverseString.py*：
- en: '**Python**'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE52]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And here is the equivalent JavaScript code in *reverseString.html*:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*reverseString.html*中等效的JavaScript代码：
- en: '**JavaScript**'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE53]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here is the output of these programs:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下：
- en: '[PRE54]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Our recursive function `rev()` returns the string that is the reverse of the
    argument, `theString`. Let’s consider the simplest strings to reverse: the empty
    string and a single-character string would “reverse” to themselves. These are
    the two base cases with which we’ll start (though we combine them with an `or`
    or `||` Boolean operator ❶). For the recursive case, we form `head` from the first
    character in `theString` ❷, and `tail` from every character after the first ❸.
    The recursive case then returns the reverse of `tail` followed by the `head` character
    ❹.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的递归函数`rev()`返回与参数`theString`相反的字符串。让我们考虑最简单的字符串进行反转：空字符串和单个字符字符串会“反转”成它们自己。这是我们将开始的两个基本情况（尽管我们将它们与`or`或`||`布尔运算符结合在一起）。对于递归情况，我们从`theString`中的第一个字符形成`head`，从第一个字符之后的每个字符形成`tail`。然后递归情况返回`tail`的反转，后跟`head`字符。
- en: Detecting Palindromes
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测回文
- en: A *palindrome* is a word or phrase that is spelled the same when written forward
    and backward. *Level*, *race car*, *taco cat*, and *a man, a plan, a canal . .
    . Panama* are all examples of palindromes. If you would like to detect whether
    a string is a palindrome, you can write a recursive `isPalindrome()` function.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '*回文*是一个正向和反向拼写相同的单词或短语。*Level*、*race car*、*taco cat*和*a man, a plan, a canal
    . . . Panama*都是回文的例子。如果您想要检测一个字符串是否是回文，您可以编写一个递归的`isPalindrome()`函数。'
- en: The base case is a zero- or one-character string, which by its nature is always
    the same, whether forward or backward. We’ll use an approach similar to the head-tail
    technique, except that we’ll split the string argument into head, middle, and
    last strings instead. If the head and last characters are the same and the middle
    characters also form a palindrome, the string is a palindrome. The recursion comes
    from passing the middle string to `isPalindrome()`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 基本情况是零个或一个字符的字符串，根据其性质，无论是正向还是反向，它总是相同的。我们将使用类似于头尾技术的方法，只是我们将把字符串参数分成头部、中间和尾部字符串。如果头部和尾部字符相同，并且中间字符也形成回文，那么字符串就是回文。递归来自将中间字符串传递给`isPalindrome()`。
- en: 'Let’s ask the three recursive algorithm questions about the `isPalindrome()`
    function:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们问`isPalindrome()`函数的三个递归算法问题：
- en: What is the base case? A zero- or one-character string, which returns `True`
    because it is always a palindrome.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本情况是什么？零个或一个字符的字符串，它返回`True`，因为它总是一个回文。
- en: What argument is passed to the recursive function call? The middle characters
    of the string argument.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？字符串参数的中间字符。
- en: How does this argument become closer to the base case? The string argument shrinks
    by two characters for each recursive call until it becomes a zero- or one-character
    string.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何变得更接近基本情况？每次递归调用时，字符串参数都会减少两个字符，直到成为零个或一个字符的字符串。
- en: 'Here is *palindrome.py*, a Python program to detect palindromes:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于检测回文的Python程序*palindrome.py*：
- en: '**Python**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE55]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here is the equivalent JavaScript code in *palindrome.html*:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*palindrome.html*中等效的JavaScript代码：
- en: '**JavaScript**'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE56]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here is the output of these programs:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下：
- en: '[PRE57]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The base case returns `True` because a zero- or one-character string is always
    a palindrome. Otherwise, the string argument is broken into three pieces: the
    first character ❶, the last character ❸, and the middle characters between them
    ❷.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 基本情况返回`True`，因为零个或一个字符的字符串总是回文。否则，字符串参数被分成三部分：第一个字符❶，最后一个字符❸，以及它们之间的中间字符❷。
- en: The `return` statement in the recursive case ❹ makes use of *Boolean short-circuiting*,
    a feature of almost every programming language. In an expression joined with the
    `and` or `&&` Boolean operators, if the left-side expression is `False`, it doesn’t
    matter if the right-side expression is `True` or `False` because the entire expression
    will be `False`. Boolean short-circuiting is an optimization that skips the evaluation
    of the right-side expression of an `and` operator if the left side is `False`.
    So, in the expression `head == last and isPalindrome(middle)`, if `head == last`
    is `False`, the recursive call to `isPalindrome()` is skipped. This means that
    as soon as the head and last strings don’t match, the recursion stops and simply
    returns `False`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 递归情况下的`return`语句❹利用了*布尔短路*，这是几乎所有编程语言的特性。在使用`and`或`&&`布尔运算符连接的表达式中，如果左侧表达式为`False`，则右侧表达式是`True`还是`False`都无所谓，因为整个表达式都将是`False`。布尔短路是一种优化，如果左侧为`False`，则跳过`and`运算符的右侧表达式的评估。因此，在表达式`head
    == last and isPalindrome(middle)`中，如果`head == last`为`False`，则递归调用`isPalindrome()`将被跳过。这意味着一旦头部和尾部字符串不匹配，递归就会停止并简单地返回`False`。
- en: This recursive algorithm is still sequential, like the summation and reverse-string
    functions in the previous sections, except that instead of going from the start
    of the data to the end, it goes from both ends of the data toward the middle.
    The iterative version of this algorithm that uses a simple loop is more straightforward.
    We cover the recursive version in this book because it’s a common coding interview
    problem.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归算法仍然是顺序的，就像前面章节中的求和和反转字符串函数一样，只是不是从数据的开始到结束，而是从数据的两端向中间移动。使用简单循环的迭代版本更加直接。我们在本书中介绍递归版本，因为这是一个常见的编码面试问题。
- en: Solving the Tower of Hanoi
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决汉诺塔
- en: The *Tower of Hanoi* is a puzzle involving a tower of stacked disks. The puzzle
    begins with the largest disk on the bottom, and the disk sizes decrease going
    up. Each disk has a hole in its center so that the disks can be stacked on top
    of one another on a pole. [Figure 3-4](#figure3-4) shows a wooden Tower of Hanoi
    puzzle.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 汉诺塔是一个涉及堆叠的塔的难题。难题以最大的圆盘在底部开始，圆盘尺寸逐渐减小。每个圆盘的中心都有一个孔，这样圆盘可以在杆上相互堆叠。[图3-4](#figure3-4)显示了一个木制的汉诺塔难题。
- en: '![Picture of a wooden surface with three poles sticking out of it and a stack
    of disks, decreasing in size from bottom to top, placed on the first pole.](image_fi/502024c03/f03004.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![图片上是一个木制表面，上面有三根杆，第一根杆上放着一堆圆盘，从底部到顶部尺寸逐渐减小。](image_fi/502024c03/f03004.png)'
- en: 'Figure 3-4: A wooden Tower of Hanoi puzzle set'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-4：木制汉诺塔难题套装
- en: 'To solve the puzzle, the player must move the stack of disks from one pole
    to another while following three rules:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '要解决这个难题，玩家必须遵循三条规则将圆盘从一根杆移动到另一根杆： '
- en: The player can move only one disk at a time.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家一次只能移动一个圆盘。
- en: The player can move disks only to and from the top of a tower.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家只能将圆盘移动到塔的顶部或从塔的顶部移动。
- en: The player can never place a larger disk on top of a smaller disk.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家永远不能将较大的圆盘放在较小的圆盘上。
- en: Python’s built-in `turtledemo` module has a Tower of Hanoi demonstration that
    you can see by running `python -m turtledemo` on Windows or `python3 -m turtledemo`
    on macOS/Linux, and then selecting **minimum_hanoi** from the Examples menu. Tower
    of Hanoi animations are readily found through an internet search as well.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Python的内置`turtledemo`模块有一个汉诺塔演示，您可以通过在Windows上运行`python -m turtledemo`或在macOS/Linux上运行`python3
    -m turtledemo`，然后从示例菜单中选择**minimum_hanoi**来查看。汉诺塔动画也可以通过互联网搜索轻松找到。
- en: 'The recursive algorithm for solving the Tower of Hanoi puzzle is not intuitive.
    Let’s start with the smallest case: a Tower of Hanoi with one disk. The solution
    is trivial: move the disk to another pole and you’re finished. Solving for two
    disks is slightly more complicated: move the smaller disk to one pole (we’ll call
    it the *temporary pole*) and the larger disk to the other pole (we’ll call it
    the *end pole*), and then finally move the smaller disk from the temporary pole
    to the end pole. Both disks are now on the end pole in the correct order.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 解决汉诺塔难题的递归算法并不直观。让我们从最小的情况开始：一个只有一个圆盘的汉诺塔。解决方案很简单：将圆盘移动到另一个杆上，然后完成。解决两个圆盘的情况稍微复杂一些：将较小的圆盘移动到一个杆上（我们称之为*临时杆*），将较大的圆盘移动到另一个杆上（我们称之为*结束杆*），最后将较小的圆盘从临时杆移动到结束杆。现在两个圆盘按正确顺序放在结束杆上。
- en: 'Once you solve the three-disk tower, you’ll notice that a pattern emerges.
    To solve a tower of *n* disks from the start pole to the end pole, you must do
    the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解决了三个圆盘的塔，你会发现出现了一个模式。要解决从起始杆到结束杆的*n*个圆盘的塔，必须执行以下操作：
- en: Solve the *n* – 1 disks puzzle by moving those disks from the start pole to
    the temporary pole.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将这些圆盘从起始杆移动到临时杆来解决*n* - 1个圆盘的难题。
- en: Move the *n*th disk from the start pole to the end pole.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第*n*个圆盘从起始杆移动到结束杆。
- en: Solve the *n* – 1 disks puzzle by moving those disks from the temporary pole
    to the end pole.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将这些圆盘从临时杆移动到结束杆来解决*n* - 1个圆盘的难题。
- en: 'Like the Fibonacci algorithm, the recursive case for the Tower of Hanoi algorithm
    makes two recursive calls instead of just one. If we draw a tree diagram of the
    operations for solving a four-disk Tower of Hanoi, it looks like [Figure 3-6](#figure3-6).
    Solving the four-disk puzzle requires the same steps as solving the three-disk
    puzzle, as well as moving the fourth disk and performing the steps of solving
    the three-disk puzzle again. Likewise, solving the three-disk puzzle requires
    the same steps as the two-disk puzzle plus moving the third disk, and so on. Solving
    the one-disk puzzle is the trivial base case: it involves only moving the disk.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 就像斐波那契算法一样，汉诺塔算法的递归情况不是只做一次递归调用，而是做两次。如果我们画出一个解决四个盘子汉诺塔问题的操作的树形图，它看起来像[图3-6](#figure3-6)。解决四个盘子的难题需要与解决三个盘子的难题相同的步骤，以及移动第四个盘子和再次执行解决三个盘子难题的步骤。同样，解决三个盘子的难题需要与解决两个盘子的难题相同的步骤，再加上移动第三个盘子，依此类推。解决一个盘子的难题是微不足道的基本情况：它只涉及移动盘子。
- en: The tree-like structure in [Figure 3-5](#figure3-5) hints that a recursive approach
    is ideal for solving the Tower of Hanoi puzzle. In this tree, the execution moves
    from top to bottom and from left to right.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-5](#figure3-5)中的树状结构暗示了递归方法对于解决汉诺塔难题是理想的。在这棵树中，执行从上到下，从左到右移动。'
- en: While a three-disk or four-disk Tower of Hanoi is easy for a human to solve,
    increasing numbers of disks require an exponentially increasing number of operations
    to complete. For *n* disks, it takes a minimum of 2*n* – 1 moves to solve. This
    means a 31-disk tower requires over a billion moves to complete!
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于人类来说，解决三个盘子或四个盘子的汉诺塔很容易，但是盘子数量的增加需要指数级增加的操作次数才能完成。对于*n*个盘子，至少需要2*n* - 1次移动才能解决。这意味着31个盘子的塔需要超过十亿次移动才能完成！
- en: '![Tree diagram showing a series of operations needed to solve a four-disk Tower
    of Hanoi. The root node, “Solve 4,” branches into three nodes: one representing
    the move necessary to place the fourth disk in the correct spot, “Move 4,” and
    two “Solve 3” nodes. Each “Solve 3” node branches into its own series of nodes
    representing moves and steps.](image_fi/502024c03/f03005.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![树状图显示解决四个盘子汉诺塔问题所需的一系列操作。根节点“解决4”分成三个节点：一个代表将第四个盘子放在正确位置所需的移动，“移动4”，和两个“解决3”节点。每个“解决3”节点分成自己的一系列代表移动和步骤的节点。](image_fi/502024c03/f03005.png)'
- en: 'Figure 3-5: The series of operations for solving a four-disk Tower of Hanoi'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-5：解决四个盘子汉诺塔的一系列操作
- en: 'Let’s ask ourselves the three questions for creating a recursive solution:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为创建递归解决方案提出三个问题：
- en: What is the base case? Solving a tower of one disk.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本情况是什么？解决一个盘子的塔。
- en: What argument is passed to the recursive function call? Solving a tower of size
    one less than the current size.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递给递归函数调用的参数是什么？解决一个比当前大小小一个盘子的塔。
- en: How does this argument become closer to the base case? The size of the tower
    to solve decreases by one disk for each recursive call until it is a one-disk
    tower.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何变得更接近基本情况？要解决的塔的大小每递归调用一次减少一个盘子，直到它是一个只有一个盘子的塔。
- en: 'The following *towerOfHanoiSolver.py* program solves the Tower of Hanoi puzzle
    and displays a visualization of each step:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的*towerOfHanoiSolver.py*程序解决了汉诺塔难题，并显示了每一步的可视化：
- en: '[PRE58]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This *towerOfHanoiSolver.html* program contains the equivalent JavaScript code:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*towerOfHanoiSolver.html*程序包含了等效的JavaScript代码：
- en: '[PRE59]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When you run this code, the output shows each move of the disks until the entire
    tower has moved from Tower A to Tower B:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，输出显示了每个盘子的移动，直到整个塔从A塔移动到B塔为止：
- en: '[PRE60]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The Python version has an interactive mode too, where you can solve the puzzle
    yourself. Uncomment the lines of code at the end of *towerOfHanoiSolver.py* to
    play the interactive version.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本也有交互模式，您可以在*towerOfHanoiSolver.py*的末尾取消注释代码行以玩交互版本。
- en: You can start by running the program with the smaller cases by setting the `TOTAL_DISKS`
    constant ❶ at the top of the program to `1` or `2`. In our program, a list of
    integers in Python and an array of integers in JavaScript represent a pole. The
    integer represents a disk, with larger integers representing larger disks. The
    integer at the start of the list or array is at the bottom of the pole, and the
    integer at the end is at the pole’s top. For example, `[6, 5, 4, 3, 2, 1]` represents
    the starting pole with six disks with the largest on the bottom, while `[]` represents
    a pole with no disks. The `TOWERS` variable contains three of these lists ❷.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将程序顶部的`TOTAL_DISKS`常量❶设置为`1`或`2`来从较小的情况开始运行程序。在我们的程序中，Python中的整数列表和JavaScript中的整数数组表示一个柱子。整数表示一个盘子，较大的整数表示较大的盘子。列表或数组的起始整数在柱子的底部，结束整数在柱子的顶部。例如，`[6,
    5, 4, 3, 2, 1]`表示具有六个盘子的起始柱子，最大的盘子在底部，而`[]`表示没有盘子的柱子。`TOWERS`变量包含这三个列表❷。
- en: 'The base case merely moves the smallest disk from the start pole to the end
    pole ❸. The recursive case for a tower of *n* disks carries out three steps: solving
    the *n* – 1 case ❹, moving the *n*th disk ❺, and then solving the *n* – 1 case
    again ❻.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 基本情况只是将最小的盘子从起始柱移动到结束柱❸。*n*个盘子的递归情况执行三个步骤：解决*n* - 1的情况❹，移动第*n*个盘子❺，然后再次解决*n*
    - 1的情况❻。
- en: Using Flood Fill
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用泛洪填充
- en: Graphics programs commonly use the *flood fill algorithm* to fill an arbitrarily
    shaped area of the same color with another color. [Figure 3-6](#figure3-6) shows
    one such shape at the top left. The subsequent panels show three different sections
    of the shape flood-filled with a gray color. The flood fill begins on a white
    pixel and spreads until it meets a non-white pixel, filling the enclosed space.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图形程序通常使用*泛洪填充算法*来填充任意形状的相同颜色区域为另一种颜色。[图3-6](#figure3-6)显示了左上角的一个这样的形状。随后的面板显示了用灰色填充的形状的三个不同部分。泛洪填充从一个白色像素开始，一直扩散，直到遇到非白色像素，填充封闭空间。
- en: 'The flood fill algorithm is recursive: it begins by changing a single pixel
    to a new color. The recursive function is then called on any neighbors of the
    pixel with its same old color. It then moves on to the neighbors of the neighbors,
    and so on, converting each pixel to the new color until the enclosed space is
    filled in.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 泛洪填充算法是递归的：它从将单个像素更改为新颜色开始。然后在具有相同旧颜色的像素的任何邻居上调用递归函数。然后移动到邻居的邻居，依此类推，将每个像素转换为新颜色，直到填充封闭空间。
- en: The base case is a pixel whose color is the edge of the image or is not the
    old color. Since reaching the base case is the only way to stop the “spread” of
    recursive calls for every pixel in the image, this algorithm has the emergent
    behavior of changing all the contiguous pixels from the old color to the new color.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 基本情况是像素的颜色是图像的边缘，或者不是旧颜色。由于达到基本情况是停止图像中每个像素的递归调用“传播”的唯一方法，因此该算法具有将所有连续像素从旧颜色更改为新颜色的紧急行为。
- en: 'Let’s ask the three recursive algorithm questions about our `floodFill()` function:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们问一下关于`floodFill()`函数的三个递归算法问题：
- en: What is the base case? When the x- and y-coordinates are for a pixel that is
    not the old color, or are at the edge of the image.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？当x和y坐标是不是旧颜色的像素，或者在图像的边缘时。
- en: What arguments are passed to the recursive function call? The x- and y-coordinates
    of the four neighboring pixels of the current pixel are the arguments to four
    recursive calls.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了哪些参数？当前像素的四个相邻像素的x和y坐标是四个递归调用的参数。
- en: How do these arguments become closer to the base case? The neighboring pixels
    run up to a different color than the old color or the edge of the image. Either
    way, eventually the algorithm runs out of pixels to check.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些参数如何接近基本情况？相邻像素的颜色与旧颜色或图像边缘不同。无论哪种情况，最终算法都会用完要检查的像素。
- en: '![Four screenshots of MS Paint windows containing the same abstract, squiggly
    shape. Each screenshot shows a different closed portion of the drawing colored
    gray.](image_fi/502024c03/f03006.png)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![MS Paint窗口的四个截图，包含相同的抽象、曲折形状。每个截图显示了不同的绘图封闭部分，颜色为灰色。](image_fi/502024c03/f03006.png)'
- en: 'Figure 3-6: The original shape in a graphics editor (top left) and the same
    shape with three different areas flood-filled with a light gray color'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-6：图形编辑器中的原始形状（左上角）和填充了三个不同区域的相同形状，颜色为浅灰色
- en: 'Instead of an image for our sample program, we’ll use a list of single-character
    strings to form a 2D grid of text characters to represent an “image.” Each string
    represents a “pixel,” and the specific character represents the “color.” The *floodfill.py*
    Python program implements the flood fill algorithm, the image data, and a function
    to print the image on the screen:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例程序不是图像，而是使用单字符字符串列表来形成文本字符的2D网格，以表示“图像”。每个字符串代表一个“像素”，特定字符代表“颜色”。*floodfill.py*
    Python程序实现了泛洪填充算法、图像数据和一个在屏幕上打印图像的函数：
- en: '**Python**'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE61]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The *floodfill.html* program contains the equivalent JavaScript code:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '*floodfill.html*程序包含了等效的JavaScript代码：'
- en: '**JavaScript**'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE62]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When you run this code, the program fills the interior of the shape drawn by
    the `#` characters starting at coordinates 3, 3\. It replaces all the period characters
    (`.`) with `o` characters. The following output shows the before and after images:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，程序从坐标3,3开始填充由`#`字符绘制的形状的内部。它用`o`字符替换所有句号字符(`.`)。以下输出显示了之前和之后的图像：
- en: '[PRE63]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If you want to see every step of the flood fill algorithm as it fills in the
    new character, uncomment the `printImage(image)` line ❶ in the `floodFill()` function
    and run the program again.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要查看泛洪填充算法在填充新字符时的每一步，请取消注释`floodFill()`函数中的`printImage(image)`行❶，然后再次运行程序。
- en: The image is represented by a 2D array of string characters. We can pass this
    `image` data structure, an `x` coordinate and a `y` coordinate, and a new character
    to the `floodFill()` function. The function notes the character currently at the
    `x` and `y` coordinates and saves it to the `oldChar` variable ❷.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 图像由一个字符串字符的2D数组表示。我们可以将这个`image`数据结构、一个`x`坐标和一个`y`坐标以及一个新字符传递给`floodFill()`函数。函数会注意当前在`x`和`y`坐标处的字符，并将其保存到`oldChar`变量中❷。
- en: 'If the current characters at coordinates `x` and `y` in `image` are not the
    same as `oldChar`, this is our base case, and the function simply returns. Otherwise,
    the function continues on to its four recursive cases: passing the x- and y-coordinates
    of the bottom ❸, top ❹, right ❺, and left ❻ neighbors of the current coordinates.
    After these four potential recursive calls are made, the end of the function is
    an implicit base case, made explicit in our program with a `return` statement
    ❼.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`image`中坐标`x`和`y`处的当前字符与`oldChar`不同，这是我们的基本情况，函数就简单地返回。否则，函数继续进行四个递归情况：传递当前坐标的底部❸、顶部❹、右侧❺和左侧❻邻居的x和y坐标。在进行了这四个潜在的递归调用之后，函数的结尾是一个隐式的基本情况，在我们的程序中通过`return`语句❼明确表示。
- en: The flood fill algorithm doesn’t have to be recursive. For large images, a recursive
    function could cause stack overflows. If we were to implement flood fill with
    a loop and a stack instead, the stack would begin with the x- and y-coordinates
    of the starting pixel. The code in the loop would pop the coordinates off the
    top of the stack, and if that coordinate’s pixel matches `oldChar`, it would push
    the coordinates of the four neighboring pixels. When the stack is empty because
    the base case is no longer pushing neighbors to the stack, the loop is finished.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 泛洪填充算法不一定要是递归的。对于大图像，递归函数可能会导致堆栈溢出。如果我们使用循环和堆栈来实现泛洪填充，堆栈将以起始像素的x和y坐标开始。循环中的代码将弹出堆栈顶部的坐标，如果该坐标的像素与`oldChar`匹配，它将推送四个相邻像素的坐标。当堆栈为空时，因为基本情况不再将邻居推送到堆栈中，循环就结束了。
- en: However, the flood fill algorithm doesn’t necessarily have to use a stack. The
    pushing and popping of a first-in, last-out stack is effective for backtracking
    behavior, but the order that the pixels are processed in the flood fill algorithm
    can be arbitrary. This means we could equally effectively use a set data structure
    that removes elements randomly. You can find these iterative flood fill algorithms
    implemented in *floodFillIterative.py* and *floodFillIterative.html* in the downloadable
    resources at [https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，泛洪填充算法不一定要使用堆栈。先进后出堆栈的推送和弹出对于回溯行为是有效的，但在泛洪填充算法中处理像素的顺序可以是任意的。这意味着我们同样可以有效地使用一个随机删除元素的集合数据结构。你可以在[https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion)的可下载资源中找到这些迭代泛洪填充算法的实现，分别是
    *floodFillIterative.py* 和 *floodFillIterative.html*。
- en: Using the Ackermann Function
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ackermann 函数
- en: The *Ackermann function* is named after its discoverer, Wilhelm Ackermann. A
    student of mathematician David Hilbert (whose Hilbert curve fractal we discuss
    in Chapter 9), Ackermann published his function in 1928\. Mathematicians Rózsa
    Péter and Raphael Robinson later developed the version of the function featured
    in this section.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ackermann 函数* 是以其发现者威廉·阿克曼命名的。数学家大卫·希尔伯特的学生（我们在第9章讨论的希尔伯特曲线分形），阿克曼于1928年发表了他的函数。数学家罗莎·彼得和拉斐尔·罗宾逊后来开发了本节中所介绍的函数的版本。'
- en: While the Ackermann function has some application in advanced mathematics, it
    is mostly known for being an example of a highly recursive function. Even slight
    increases to its two integer arguments cause a large increase in the number of
    recursive calls it makes.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Ackermann 函数在高等数学中有一些应用，但它主要以高度递归函数的例子而闻名。即使是对其两个整数参数的轻微增加也会导致其递归调用次数大幅增加。
- en: 'The Ackermann function takes two arguments, `m` and `n`, and has a base case
    of returning `n + 1` when `m` is `0`. There are two recursive cases: when `n`
    is `0`, the function returns `ackermann(m - 1, 1)`, and when `n` is greater than
    `0`, the function returns `ackermann(m - 1, ackermann(m, n - 1))`. These cases
    likely aren’t meaningful to you, but suffice it to say, the number of recursive
    calls the Ackermann function makes grows quickly. Calling `ackermann(1, 1)` results
    in three recursive function calls. Calling `ackermann(2, 3)` results in 43 recursive
    function calls. Calling `ackermann(3, 5)` results in 42,437 recursive function
    calls. And calling `ackermann(5, 7)` results in . . . well, actually I don’t know
    how many recursive function calls, because it would take several times the age
    of the universe to calculate.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: Ackermann 函数接受两个参数 `m` 和 `n`，并且当 `m` 为 `0` 时有一个基本情况，返回 `n + 1`。有两种递归情况：当 `n`
    为 `0` 时，函数返回 `ackermann(m - 1, 1)`，当 `n` 大于 `0` 时，函数返回 `ackermann(m - 1, ackermann(m,
    n - 1))`。这些情况可能对你来说没有意义，但可以说，Ackermann 函数的递归调用次数增长得很快。调用 `ackermann(1, 1)` 会导致三次递归函数调用。调用
    `ackermann(2, 3)` 会导致43次递归函数调用。调用 `ackermann(3, 5)` 会导致42,437次递归函数调用。调用 `ackermann(5,
    7)` 会导致... 好吧，实际上我不知道有多少次递归函数调用，因为这将需要计算几倍于宇宙年龄的时间。
- en: 'Let’s answer the three questions we ask when constructing recursive algorithms:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回答构建递归算法时提出的三个问题：
- en: What is the base case? When `m` is `0`.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？当 `m` 为 `0` 时。
- en: What arguments are passed to the recursive function call? Either `m` or `m -
    1` is passed for the next `m` parameter; and `1`, `n - 1`, or the return value
    of `ackermann(m, n - 1)` is passed for the next `n` parameter.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？下一个 `m` 参数传递了要么 `m` 要么 `m - 1`；下一个 `n` 参数传递了 `1`、`n - 1` 或 `ackermann(m,
    n - 1)` 的返回值。
- en: How do these arguments become closer to the base case? The `m` argument is always
    either decreasing or staying the same size, so it will eventually reach `0`.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些参数如何接近基本情况？`m` 参数总是要么减小，要么保持相同的大小，所以它最终会达到 `0`。
- en: 'Here is an *ackermann.py* Python program:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 *ackermann.py* Python 程序：
- en: '[PRE64]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And here is the equivalent *ackermann.html* JavaScript program:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是等效的 *ackermann.html* JavaScript 程序：
- en: '[PRE65]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When you run this code, the output’s indentation (set by the `indentation`
    argument) tells you how deep on the call stack the given recursive function call
    is:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，输出的缩进（由 `indentation` 参数设置）告诉你给定递归函数调用在调用堆栈上的深度：
- en: '[PRE66]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can also try `ackermann(3, 3)`, but anything with larger arguments will
    probably take far too long to calculate. To speed up the calculation, try commenting
    out all `print()` and `document.write()` calls except the ones that print the
    final return value of `ackermann()`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试 `ackermann(3, 3)`，但任何更大的参数可能需要太长时间来计算。为了加快计算速度，尝试注释掉除了打印 `ackermann()`
    的最终返回值之外的所有 `print()` 和 `document.write()` 调用。
- en: Remember, even a recursive algorithm like the Ackermann function can be implemented
    as an iterative function. The iterative Ackermann algorithms are implemented in
    *ackermannIterative.py* and *ackermannIterative.html* in the downloadable resources
    at [https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使像 Ackermann 函数这样的递归算法也可以作为迭代函数实现。迭代 Ackermann 算法在[https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion)的可下载资源中实现为
    *ackermannIterative.py* 和 *ackermannIterative.html*。
- en: Summary
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter covered some classic recursive algorithms. For each, we asked
    the three important questions you should always ask when designing your own recursive
    functions: What is the base case? What arguments are passed to the recursive function
    call? How do these arguments become closer to the base case? If they don’t, your
    function will continue to recurse until it causes a stack overflow.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了一些经典的递归算法。对于每一个，我们都提出了三个重要的问题，你在设计自己的递归函数时应该总是问的：什么是基本情况？递归函数调用传递了什么参数？这些参数如何接近基本情况？如果它们没有，你的函数将继续递归，直到导致堆栈溢出。
- en: The summation, string reversing, and palindrome detection recursive functions
    could have easily been implemented with a simple loop. The key giveaway is that
    they all make a single pass through the data given to them with no backtracking.
    As explained in Chapter 2, recursive algorithms are especially suited to problems
    that involve a tree-like structure and require backtracking.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 求和、字符串反转和回文检测递归函数都可以很容易地用简单的循环实现。关键的线索是它们都只对给定的数据进行一次遍历，没有回溯。正如第2章所解释的，递归算法特别适用于涉及类似树状结构并需要回溯的问题。
- en: The tree-like structures for solving the Tower of Hanoi puzzle suggest that
    it involves backtracking, as the program execution runs from top to bottom, left
    to right, in the tree. This makes it a prime candidate for recursion, especially
    since the solution requires two recursive calls of smaller towers.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 解决汉诺塔难题的树状结构表明它涉及回溯，因为程序执行从树的顶部到底部，从左到右运行。这使得它成为递归的一个主要候选者，特别是因为解决方案需要对较小的塔进行两次递归调用。
- en: The flood fill algorithm is directly applicable to graphics and drawing programs,
    as well as other algorithms to detect the shape of contiguous areas. If you’ve
    used the paint-bucket tool in a graphics program, you’ve likely used a version
    of the flood fill algorithm.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 洪水填充算法直接适用于图形和绘图程序，以及检测连续区域形状的其他算法。如果你在图形程序中使用了油漆桶工具，你可能使用了洪水填充算法的一个版本。
- en: The Ackermann function is an excellent example of how quickly a recursive function
    can grow as its inputs increase. While it doesn’t have many practical applications
    in day-to-day programming, no discussion about recursion would be complete without
    it. But as recursive as it is, like all recursive functions it can be implemented
    iteratively with a loop and a stack.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 阿克曼函数是递归函数在输入增加时增长速度之快的一个很好的例子。虽然它在日常编程中没有太多实际应用，但没有讨论递归的讨论是不完整的。但是，就像所有递归函数一样，它可以用循环和栈来实现。
- en: Further Reading
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Wikipedia has more information on the Tower of Hanoi problem at [https://en.wikipedia.org/wiki/Tower_of_Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi),
    and the Computerphile video “Recursion ‘Super Power’ (in Python)” covers solving
    the Tower of Hanoi in Python at [https://youtu.be/8lhxIOAfDss](https://youtu.be/8lhxIOAfDss).
    The 3Blue1Brown two-part video series, “Binary, Hanoi, and Sierpiński,” goes into
    even more detail by exploring the relationships among the Tower of Hanoi, binary
    numbers, and the Sierpiński Triangle fractal starting at [https://youtu.be/2SUvWfNJSsM](https://youtu.be/2SUvWfNJSsM).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科上有更多关于汉诺塔问题的信息，网址为[https://en.wikipedia.org/wiki/Tower_of_Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi)，而Computerphile的视频“Recursion
    'Super Power' (in Python)”则介绍了如何在Python中解决汉诺塔问题，网址为[https://youtu.be/8lhxIOAfDss](https://youtu.be/8lhxIOAfDss)。3Blue1Brown的两部视频系列“Binary,
    Hanoi, and Sierpiński”通过探索汉诺塔、二进制数和谢尔宾斯基三角形分形之间的关系，提供了更详细的信息，网址为[https://youtu.be/2SUvWfNJSsM](https://youtu.be/2SUvWfNJSsM)。
- en: Wikipedia has an animation of the flood fill algorithm working on a small image
    at [https://en.wikipedia.org/wiki/Flood_fill](https://en.wikipedia.org/wiki/Flood_fill).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科上有一个关于洪水填充算法在小图像上运行的动画，网址为[https://en.wikipedia.org/wiki/Flood_fill](https://en.wikipedia.org/wiki/Flood_fill)。
- en: The Computerphile video “The Most Difficult Program to Compute?” discusses the
    Ackermann function at [https://youtu.be/i7sm9dzFtEI](https://youtu.be/i7sm9dzFtEI).
    If you’d like to learn more about the Ackermann function’s place in computability
    theory, the Hackers in Cambridge channel has a five-part video series on primitive
    recursive and partial recursive functions at [https://youtu.be/yaDQrOUK-KY](https://youtu.be/yaDQrOUK-KY).
    The series requires a lot of mathematical thinking on the part of the viewer,
    but you don’t need a lot of prior mathematical knowledge.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: Computerphile的视频“The Most Difficult Program to Compute?”讨论了阿克曼函数，网址为[https://youtu.be/i7sm9dzFtEI](https://youtu.be/i7sm9dzFtEI)。如果你想了解更多关于阿克曼函数在可计算性理论中的地位，Hackers
    in Cambridge频道有一个关于原始递归和部分递归函数的五部视频系列，网址为[https://youtu.be/yaDQrOUK-KY](https://youtu.be/yaDQrOUK-KY)。该系列需要观众进行大量的数学思考，但你不需要太多的先前数学知识。
- en: Practice Questions
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习问题
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你的理解：
- en: What is the head of an array or string?
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组或字符串的头部是什么？
- en: What is the tail of an array or string?
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组或字符串的尾部是什么？
- en: What are the three questions this chapter presents for each recursive algorithm?
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章对每个递归算法提出了哪三个问题？
- en: What is the leap of faith in recursion?
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归中的信任飞跃是什么？
- en: What do you need to understand about the recursive function you are writing
    before you can take a leap of faith?
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在进行递归函数编写之前需要了解什么才能做出信任的飞跃？
- en: How does a linear data structure such as an array or string resemble a tree-like
    structure?
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线性数据结构（如数组或字符串）如何类似于树状结构？
- en: Does the recursive `sum()` function involve any backtracking over the data it
    works on?
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归的`sum()`函数是否涉及对其处理的数据的回溯？
- en: In the flood fill program, try changing the `im` variable’s strings to create
    a *C* shape that is not fully enclosed. What happens when you attempt to flood-fill
    the image from the middle of the *C*?
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在洪水填充程序中，尝试更改`im`变量的字符串，创建一个未完全封闭的*C*形状。当你尝试从*C*的中间进行洪水填充时会发生什么？
- en: 'Answer the three questions about recursive solutions for each of the recursive
    algorithms presented in this chapter:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回答本章中每个递归算法的三个问题：
- en: What is the base case?
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本情况是什么？
- en: What argument is passed to the recursive function call?
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？
- en: How does this argument become closer to the base case?
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个论点如何接近基本情况？
- en: Then re-create the recursive algorithms from this chapter without looking at
    the original code.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新创建本章的递归算法，而不查看原始代码。
- en: Practice Projects
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践项目
- en: 'For practice, write a function for each of the following tasks:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 为以下每个任务编写一个函数：
- en: Using the head-tail technique, create a recursive `concat()` function that is
    passed an array of strings and returns these strings concatenated together into
    a single string. For example, `concat(['Hello', 'World'])` should return `HelloWorld`.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用头尾技术，创建一个递归的`concat()`函数，该函数接受一个字符串数组，并将这些字符串连接成一个字符串返回。例如，`concat(['Hello',
    'World'])`应返回`HelloWorld`。
- en: Using the head-tail technique, create a recursive `product()` function that
    is passed an array of integers and returns the total multiplied product of them.
    This code will be almost identical to the `sum()` function in this chapter. However,
    note that the base case of an array with just one integer returns the integer,
    and the base case of an empty array returns `1`.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用头尾技术，创建一个递归的`product()`函数，该函数接受一个整数数组，并返回它们的总乘积。这段代码几乎与本章中的`sum()`函数相同。但是，请注意，只有一个整数的数组的基本情况返回整数，空数组的基本情况返回`1`。
- en: Using the flood fill algorithm, count the number of “rooms,” or enclosed spaces,
    in a 2D grid. You can do this by creating nested `for` loops that call the flood
    fill function on each character in the grid if it is a period, in order to change
    the periods into hash characters. For example, the following data would result
    in the program finding six places in the grid with periods, meaning there are
    five rooms (and the space outside all the rooms).
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用泛洪填充算法，计算二维网格中的“房间”或封闭空间的数量。您可以通过创建嵌套的`for`循环，在网格中的每个字符上调用泛洪填充函数（如果是句点），以将句点更改为井字符。例如，以下数据将导致程序在网格中找到六个句点的位置，这意味着有五个房间（以及所有房间之外的空间）。
- en: '[PRE67]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '4'
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Backtracking and Tree Traversal Algorithms
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯和树遍历算法
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In previous chapters, you learned that recursion is especially suited for problems
    that involve a tree-like structure and backtracking, such as maze-solving algorithms.
    To see why, consider that a tree’s trunk splits off into multiple branches. Those
    branches themselves split off into other branches. In other words, a tree has
    a recursive, self-similar shape.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，您已经了解到递归特别适用于涉及树状结构和回溯的问题，例如解迷宫算法。要了解原因，请考虑树干分成多个分支。这些分支本身又分成其他分支。换句话说，树具有递归的、自相似的形状。
- en: A maze can be represented by a tree data structure, since mazes branch off into
    different paths, which in turn branch off into more paths. When you reach a dead
    end in a maze, you must backtrack to an earlier branching point.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫可以用树数据结构表示，因为迷宫分支成不同的路径，这些路径又分成更多的路径。当您到达迷宫的死胡同时，必须回溯到较早的分叉点。
- en: The task of traversing tree graphs is tightly linked with many recursive algorithms,
    such as the maze-solving algorithm in this chapter and the maze-generation program
    in Chapter 11. We’ll take a look at tree traversal algorithms and employ them
    to find certain names in a tree data structure. We’ll also use tree traversal
    for an algorithm to obtain the deepest node in a tree. Finally, we’ll see how
    mazes can be represented as a tree data structure, and employ tree traversal and
    backtracking to find a path from the start of the maze to the exit.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历树图的任务与许多递归算法紧密相关，例如本章中的解迷宫算法和第11章中的迷宫生成程序。我们将研究树遍历算法，并使用它们来在树数据结构中查找特定名称。我们还将使用树遍历算法来获取树中最深的节点的算法。最后，我们将看到迷宫可以表示为树数据结构，并使用树遍历和回溯来找到从迷宫起点到出口的路径。
- en: Using Tree Traversal
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用树遍历
- en: If you program in Python and JavaScript, you’re used to working with list, array,
    and dictionary data structures. You’ll encounter tree data structures only if
    you are dealing with low-level details of certain computer science algorithms
    such as abstract syntax trees, priority queues, Adelson-Velsky-Landis (AVL) trees,
    and other concepts beyond the scope of this book. However, trees themselves are
    simple enough concepts.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Python和JavaScript中编程，通常会使用列表、数组和字典数据结构。只有在处理特定计算机科学算法的低级细节时，才会遇到树数据结构，例如抽象语法树、优先队列、Adelson-Velsky-Landis（AVL）树等概念，超出了本书的范围。但是，树本身是非常简单的概念。
- en: A *tree* *data structure* is a data structure composed of nodes that are connected
    to other nodes by edges. The *nodes* contain data, while the *edges* represent
    a relationship with another node. Nodes are also called *vertices*. The starting
    node of a tree is called the *root*, and the nodes at the end are called *leaves*.
    Trees always have exactly one root.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '*树* *数据结构*是由节点组成的数据结构，这些节点通过边连接到其他节点。*节点*包含数据，而*边*表示与另一个节点的关系。节点也称为*顶点*。树的起始节点称为*根*，末端的节点称为*叶子*。树始终只有一个根。'
- en: '*Parent nodes* at the top have edges to zero or more *child nodes* beneath
    them. Therefore, leaves are the nodes that do not have children, parent nodes
    are the non-leaf nodes, and child nodes are all the non-root nodes. Nodes in a
    tree can have edges to multiple child nodes. The parent nodes that connect a child
    node to the root node are also called the child node’s *ancestors*. The child
    nodes between a parent node and a leaf node are called the parent node’s *descendants*.
    Parent nodes in a tree can have multiple child nodes. But every child node has
    exactly one parent, except for the root node, which has zero parents. In trees,
    only one path can exist between any two nodes.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的*父节点*与它们下面的零个或多个*子节点*之间有边。因此，叶子是没有子节点的节点，父节点是非叶节点，子节点是所有非根节点。树中的节点可以有多个子节点。将子节点连接到根节点的父节点也称为子节点的*祖先*。父节点和叶节点之间的子节点称为父节点的*后代*。树中的父节点可以有多个子节点。但是，除了根节点外，每个子节点都只有一个父节点。在树中，任何两个节点之间只能存在一条路径。
- en: '[Figure 4-1](#figure4-1) shows an example of a tree and three examples of structures
    that are not trees.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-1](#figure4-1)显示了一棵树的示例，以及三个不是树的结构示例。'
- en: '![Four diagrams. The first, labeled “Tree,” has an A node with two child nodes,
    B and C; B has one child node, D; C has two child nodes, E and F; E has two child
    nodes, G and H. The second diagram, labeled “Not a Tree (Child node has multiple
    parents),” has an A node with two child nodes, B and C; B has two child nodes,
    D and E; C has two child nodes, E and F; E has two child nodes, G and H. The third
    diagram, labeled “Not a Tree (Child node loops back to an ancestor node),” has
    a node A with two child nodes, B and C; B has one child node, D; C has two child
    nodes, E and F; D has one child node, A; E has two child nodes, G and H. The fourth
    diagram, labeled “Not a Tree (Multiple root nodes),” has two root nodes, Z and
    A; Z has one child node, B; A has two child nodes, B and C; B has one child node,
    D; C has two child nodes, E and F; E has two child nodes, G and H.](image_fi/502024c04/f04001.png)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: 四个图。第一个标有“树”的图有一个A节点，有两个子节点B和C；B有一个子节点D；C有两个子节点E和F；E有两个子节点G和H。第二个图标有“不是树（子节点有多个父节点）”，有一个A节点，有两个子节点B和C；B有两个子节点D和E；C有两个子节点E和F；E有两个子节点G和H。第三个图标有“不是树（子节点循环到祖先节点）”，有一个A节点，有两个子节点B和C；B有一个子节点D；C有两个子节点E和F；D有一个子节点A；E有两个子节点G和H。第四个图标有“不是树（多个根节点）”，有两个根节点Z和A；Z有一个子节点B；A有两个子节点B和C；B有一个子节点D；C有两个子节点E和F；E有两个子节点G和H。
- en: 'Figure 4-1: A tree (left) and three examples of non-trees'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1：一棵树（左）和三个非树的示例
- en: As you can see, child nodes must have one parent and not have an edge that creates
    a loop, or else the structure is no longer considered a tree. The recursive algorithms
    we cover in this chapter apply only to tree data structures.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，子节点必须有一个父节点，不能有创建循环的边，否则该结构将不再被视为树。我们在本章中涵盖的递归算法仅适用于树数据结构。
- en: A Tree Data Structure in Python and JavaScript
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python和JavaScript中的树形数据结构
- en: 'Tree data structures are often drawn growing downward, with the root at the
    top. [Figure 4-2](#figure4-2) shows a treecreated with the following Python code
    (it’s also valid JavaScript code):'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 树形数据结构通常向下生长，根在顶部。图4-2显示了使用以下Python代码（也是有效的JavaScript代码）创建的树：
- en: '[PRE68]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![Tree diagram and the order in which the nodes would be traversed in preorder,
    postorder, and inorder tree traversal. The tree has the root note A, which has
    two child nodes, B and C. B has one child node, D. C has two child nodes, E and
    F, and E has two child nodes, G and H. Preorder tree traversal: A, B, D, C, E,
    G, H, F. Postorder tree traversal: D, B, G, H, E, F, C, A. Inorder tree traversal:
    D, B, A, G, E, H, C, F.](image_fi/502024c04/f04002.png)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: 树形图和节点的先序、后序和中序遍历顺序。树的根节点是A，有两个子节点B和C。B有一个子节点D。C有两个子节点E和F，E有两个子节点G和H。先序遍历：A，B，D，C，E，G，H，F。后序遍历：D，B，G，H，E，F，C，A。中序遍历：D，B，A，G，E，H，C，F。
- en: 'Figure 4-2: A tree with root `A` and leaves `D`, `G`, `H`, and `F`, along with
    its traversal orders'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2：根为`A`，叶为`D`，`G`，`H`和`F`的树，以及其遍历顺序
- en: Each node in the tree contains a piece of data (a string of a letter from `A`
    to `H`) and a list of its child nodes. The preorder, postorder, and inorder information
    in [Figure 4-2](#figure4-2) is explained in subsequent sections.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 树中的每个节点包含一段数据（从`A`到`H`的字母字符串）和其子节点的列表。图4-2中的先序、后序和中序信息将在后续章节中解释。
- en: 'In the code for this tree, each node is represented by a Python dictionary
    (or JavaScript object) with a key `data` that stores the node’s data, and a key
    `children` that has a list of other nodes. I use the `root` and `node2` to `node8`
    variables to store each node and make the code more readable, but they aren’t
    required. The following Python/JavaScript code is equivalent to the previous code
    listing, though harder for humans to read:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在这棵树的代码中，每个节点由一个Python字典（或JavaScript对象）表示，其中键`data`存储节点的数据，键`children`有其他节点的列表。我使用`root`和`node2`到`node8`变量来存储每个节点，并使代码更易读，但这不是必需的。以下Python/JavaScript代码等同于前面的代码清单，尽管对人类来说更难阅读：
- en: '[PRE69]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The tree in [Figure 4-2](#figure4-2) is a specific kind of data structure called
    a *directed acyclic graph* *(DAG)*. In mathematics and computer science, a *graph*
    is a collection of nodes and edges, and a tree is a kind of graph. The graph is
    *directed* because its edges have one direction: from parent to child node. Edges
    in a DAG are not undirected—that is, bidirectional. (Trees in general do not have
    this restriction and can have edges in both directions, including from a child
    node back to its parent node.) The graph is *acyclic* because there are no loops,
    or *cycles*, from child nodes to their own ancestor nodes; the “branches” of the
    tree must keep growing in the same direction.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2中的树是一种特定类型的数据结构，称为*有向无环图*（DAG）。在数学和计算机科学中，*图*是节点和边的集合，树是图的一种。图是*有向*的，因为其边有一个方向：从父节点到子节点。DAG中的边不是无向的，即双向的。（一般树没有这个限制，可以有双向的边，包括从子节点返回到父节点。）图是*无环*的，因为没有从子节点到其祖先节点的循环，或*循环*；树的“分支”必须保持在同一方向上不断增长。
- en: You can think of lists, arrays, and strings as linear trees; the root is the
    first element, and the nodes have only one child node. This linear tree terminates
    at its one leaf node. These linear trees are called *linked lists*, as each node
    has only one “next” node until the end of the list. [Figure 4-3](#figure4-3) shows
    a linked list that stores the characters in the word *HELLO*.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将列表、数组和字符串视为线性树；根是第一个元素，节点只有一个子节点。这种线性树在其一个叶节点处终止。这些线性树称为*链表*，因为每个节点只有一个“下一个”节点，直到列表的末尾。图4-3显示了存储单词*HELLO*中字符的链表。
- en: '![Linear Tree Diagram with five nodes. The root node “H” has one child node,
    “E,” which has one child node, “L,” which has one child node, “L,” which has one
    child node, “O.”](image_fi/502024c04/f04003.png)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: 线性树图有五个节点。根节点“H”有一个子节点“E”，它有一个子节点“L”，它有一个子节点“L”，它有一个子节点“O”。
- en: 'Figure 4-3: A linked list data structure storing `HELLO`. Linked lists can
    be considered a kind of tree data structure.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3：存储`HELLO`的链表数据结构。链表可以被认为是一种树数据结构。
- en: We’ll use the code for the tree in [Figure 4-2](#figure4-2) for this chapter’s
    examples. A tree traversal algorithm will visit each of the nodes in a tree by
    following the edges, starting from a root node.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[图4-2](#figure4-2)中的树代码作为本章的示例。树遍历算法将通过跟随边访问树中的每个节点，从根节点开始。
- en: Traversing the Tree
  id: totrans-571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历树
- en: 'We can write code to access data in any node by starting from the root node
    in `root`. For example, after entering the tree code into the Python or JavaScript
    interactive shell, run the following:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写代码从`root`中的根节点开始访问任何节点的数据。例如，在将树代码输入Python或JavaScript交互式shell后，运行以下命令：
- en: '[PRE70]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Our tree traversal code can be written as a recursive function because tree
    data structures have a self-similar structure: a parent node has child nodes,
    and each child node is the parent node of its own children. Tree traversal algorithms
    ensure that your programs can access or modify the data in every node in the tree
    no matter its shape or size.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的树遍历代码可以写成一个递归函数，因为树数据结构具有自相似的结构：父节点有子节点，每个子节点都是其自己子节点的父节点。树遍历算法确保您的程序可以访问或修改树中每个节点的数据，无论其形状或大小如何。
- en: 'Let’s ask the three questions about recursive algorithms for our tree traversal
    code:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们针对树遍历代码提出三个关于递归算法的问题：
- en: What is the base case? A leaf node, which has no more children and requires
    no more recursive calls, causing the algorithm to backtrack to a previous parent
    node.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？叶节点，它没有更多的子节点，也不需要更多的递归调用，导致算法回溯到先前的父节点。
- en: What argument is passed to the recursive function call? The node to traverse
    to, whose child nodes will be the next nodes to traverse.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递给递归函数调用的参数是什么？要遍历的节点，其子节点将是下一个要遍历的节点。
- en: How does this argument become closer to the base case? There are no cycles in
    a DAG, so following the descendant nodes will always eventually reach a leaf node.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何变得更接近基本情况？DAG中没有循环，因此遵循后代节点将始终最终到达叶节点。
- en: Keep in mind that tree data structures that are especially deep will cause a
    stack overflow as the algorithm traverses the deeper nodes. This happens because
    each level deeper into the tree requires yet another function call, and too many
    function calls without returning cause stack overflows. However, it’s unlikely
    for broad, well-balanced trees to be that deep. If every node in a 1,000 level
    deep tree has two children, the tree would have about 2^(1000) nodes. That’s more
    atoms than there are in the universe, and it’s unlikely your tree data structure
    is that big.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，特别深的树数据结构会导致堆栈溢出，因为算法遍历更深的节点。这是因为每个更深入树的层级都需要另一个函数调用，太多的函数调用而没有返回会导致堆栈溢出。然而，广泛、平衡良好的树不太可能会那么深。如果1000级深的树中的每个节点都有两个子节点，那么树将有大约2^(1000)个节点。这比宇宙中的原子还多，而且您的树数据结构不太可能那么大。
- en: 'Trees have three kinds of tree traversal algorithms: preorder, postorder, and
    inorder. We’ll discuss each of these in the next three sections.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 树有三种树遍历算法：先序、后序和中序。我们将在接下来的三个部分讨论每一个。
- en: Preorder Tree Traversal
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 先序树遍历
- en: '*Preorder tree traversal* algorithms access a node’s data before traversing
    its child nodes. Use a preorder traversal if your algorithm needs to access the
    data in parent nodes before the data in their child nodes. For example, preorder
    traversals are used when you are creating a copy of the tree data structure, as
    you need to create the parent nodes before child nodes in the duplicate tree.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '*先序树遍历*算法在遍历子节点之前访问节点的数据。如果您的算法需要在访问子节点的数据之前访问父节点的数据，则使用先序遍历。例如，在创建树数据结构的副本时使用先序遍历，因为您需要在副本树中创建子节点之前创建父节点。'
- en: 'The following *preorderTraversal.py* program has a `preorderTraverse()` function
    that traverses each child node first, before accessing the node’s data to print
    it to the screen:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的*preorderTraversal.py*程序有一个`preorderTraverse()`函数，它在访问节点数据之前首先遍历每个子节点，然后将其打印到屏幕上：
- en: '**Python**'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE71]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The equivalent JavaScript program is in *preorderTraversal.html*:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的JavaScript程序在*preorderTraversal.html*中：
- en: '**JavaScript**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE72]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output of these programs is the node data in preorder order:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出是按照先序顺序的节点数据：
- en: '[PRE73]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: When you look at the tree in [Figure 4-1](#figure4-1), notice that preorder
    traversal order displays the data in left nodes before right nodes, and bottom
    nodes before top nodes.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看[图4-1](#figure4-1)中的树时，请注意先序遍历顺序在显示右节点之前显示左节点，并且在显示顶部节点之前显示底部节点。
- en: All tree traversals begin by passing the root node to the recursive function.
    The function makes a recursive call and passes each of the root node’s children
    as the argument. Since these child nodes have children of their own, the traversal
    continues until a leaf node with no children is reached. At this point, the function
    call simply returns.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 所有树遍历都是通过将根节点传递给递归函数开始的。该函数进行递归调用，并将每个根节点的子节点作为参数传递。由于这些子节点有自己的子节点，遍历将继续直到到达没有子节点的叶节点。在这一点上，函数调用简单地返回。
- en: The recursive case occurs if the node has any child nodes ❶, in which case a
    recursive call is made with each of the children as the node argument. Whether
    or not the node has children, the base case always happens at the end of the function
    when it returns ❷.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点有任何子节点❶，则递归情况发生，在这种情况下，将使用每个子节点作为节点参数进行递归调用。无论节点是否有子节点，基本情况始终发生在函数结束时返回❷。
- en: Postorder Tree Traversal
  id: totrans-594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后序树遍历
- en: '*Postorder tree traversal* traverses a node’s child nodes before accessing
    the node’s data. For example, this traversal is used when deleting a tree and
    ensuring that no child nodes are “orphaned” by deleting their parent nodes first,
    leaving the child node inaccessible to the root node. The code in the following
    *postorderTraversal.py* program is similar to the preorder traversal code in the
    previous section, except the recursive function call comes before the `print()`
    call:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 后序树遍历在访问节点数据之前遍历节点的子节点。例如，在删除树并确保不通过首先删除其父节点而使子节点“孤立”来访问根节点的情况下使用此遍历。以下postorderTraversal.py程序中的代码类似于前一节中的先序遍历代码，只是递归函数调用在print()调用之前。
- en: '**Python**'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE74]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The *postorderTraversal.html* program has the equivalent JavaScript code:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: postorderTraversal.html程序包含等效的JavaScript代码：
- en: '**JavaScript**'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE75]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output of these programs is the node data in postorder order:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出是节点数据按后序顺序排列：
- en: '[PRE76]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The postorder traversal order of the nodes displays the data in left nodes
    before right nodes, and in bottom nodes before top nodes. When we compare the
    `postorderTraverse()` and `preorderTraverse()` functions, we find that the names
    are a bit of a misnomer: *pre* and *post* don’t refer to the order in which nodes
    are visited. The nodes are always traversed in the same order; we go down the
    child nodes first (called a *depth-first search*) as opposed to visiting the nodes
    in each level before going deeper (called a *breadth-first search*). The *pre*
    and *post* refer to *when* the node’s data is accessed: either before or after
    traversing the node’s children.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的后序遍历顺序显示左节点的数据在右节点之前，底部节点在顶部节点之前。当我们比较postorderTraverse()和preorderTraverse()函数时，我们发现名称有点不准确：pre和post不是指节点被访问的顺序。节点总是以相同的顺序遍历；我们首先遍历子节点（称为深度优先搜索），而不是在深入之前访问每个级别的节点（称为广度优先搜索）。pre和post指的是节点的数据何时被访问：在遍历节点的子节点之前或之后。
- en: Inorder Tree Traversal
  id: totrans-604
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中序树遍历
- en: '*Binary trees* are tree data structures with at most two child nodes, often
    called the *left child* and *right child*. An *inorder tree traversal* traverses
    the left child node, then accesses the node’s data, and then traverses the right
    child node. This traversal is used in algorithms that deal with binary search
    trees (which are beyond the scope of this book). The *inorderTraversal.py* program
    contains Python code that performs this kind of traversal:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是最多有两个子节点的树数据结构，通常称为左子节点和右子节点。中序树遍历遍历左子节点，然后访问节点数据，然后遍历右子节点。这种遍历在处理二叉搜索树的算法中使用（这超出了本书的范围）。inorderTraversal.py程序包含执行这种遍历的Python代码：
- en: '**Python**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE77]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The *inorderTraversal.html* program contains the equivalent JavaScript code:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: inorderTraversal.html程序包含等效的JavaScript代码：
- en: '**JavaScript**'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE78]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output of these programs looks like this:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下：
- en: '[PRE79]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Inorder traversal typically refers to the traversal of binary trees, although
    processing a node’s data after traversing the first node and before traversing
    the last node would count as inorder traversal for trees of any size.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 中序遍历通常指的是二叉树的遍历，尽管在遍历第一个节点之后和遍历最后一个节点之前处理节点数据将计为任何大小的树的中序遍历。
- en: Finding Eight-Letter Names in a Tree
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在树中查找八个字母的名称
- en: Instead of printing out the data in each node as we traverse them, we can use
    a *depth-first search* to find specific data in a tree data structure. We’ll write
    an algorithm that searches the tree in [Figure 4-4](#figure4-4) for names that
    are exactly eight letters long. This is a rather contrived example, but it shows
    how an algorithm can use tree traversal to retrieve data out of a tree data structure.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用深度优先搜索来查找树数据结构中的特定数据，而不是在遍历它们时打印出每个节点中的数据。我们将编写一个算法，用于在[图4-4](#figure4-4)中搜索具有确切八个字母的名称的树。这是一个相当牵强的例子，但它展示了算法如何使用树遍历从树数据结构中检索数据。
- en: '![Tree diagram with the root node “Alice,” which has two child nodes, “Bob”
    and “Caroline.” “Bob” has one child node, “Darya.” “Caroline” has two child nodes,
    “Eve” and “Fred.” “Eve” has two child nodes, “Gonzalo” and “Hadassah.”](image_fi/502024c04/f04004.png)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
  zh: '![具有根节点“Alice”的树图，其具有两个子节点“Bob”和“Caroline”。 “Bob”有一个子节点“Darya”。 “Caroline”有两个子节点“Eve”和“Fred”。
    “Eve”有两个子节点“Gonzalo”和“Hadassah”。](image_fi/502024c04/f04004.png)'
- en: 'Figure 4-4: The tree that stores names in our *depthFirstSearch.py* and *depthFirstSearch.html*
    programs'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4：存储在我们的depthFirstSearch.py和depthFirstSearch.html程序中的名称的树
- en: 'Let’s ask the three questions about recursive algorithms for our tree traversal
    code. Their answers are similar to the answers for the tree traversal algorithms:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的树遍历代码的递归算法提出三个问题。它们的答案类似于树遍历算法的答案：
- en: What is the base case? Either a leaf node causing the algorithm to backtrack,
    or a node containing an eight-letter name.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本情况是什么？要么是叶节点导致算法回溯，要么是包含八个字母名称的节点。
- en: What argument is passed to the recursive function call? The node to traverse
    to, whose child nodes will be the next nodes to traverse.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？要遍历到的节点，其子节点将是下一个要遍历的节点。
- en: How does this argument become closer to the base case? There are no cycles in
    a DAG, so following the descendant nodes will always eventually reach a leaf node.
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何接近基本情况？DAG中没有循环，因此遵循后代节点将始终最终到达叶节点。
- en: 'The *depthFirstSearch.py* program contains Python code that performs a depth-first
    search with a preorder traversal:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索.py程序包含执行先序遍历的Python代码：
- en: '**Python**'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE80]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The *depthFirstSearch.html* program contains the equivalent JavaScript program:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: depthFirstSearch.html程序包含等效的JavaScript程序：
- en: '**JavaScript**'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE81]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output of these programs looks like this:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下：
- en: '[PRE82]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `find8LetterName()` function operates in the same way as our previous tree
    traversal functions, except instead of printing the node’s data, the function
    checks the name stored in the node and returns the first eight-letter name it
    finds. You can change the preorder traversal to a postorder traversal by commenting
    out the earlier name length comparison and the `Checking if` line ❶ and uncommenting
    the later name length comparison and the `Checking if` line ❷. When you make this
    change, the first eight-letter name the function finds is `Hadassah`:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`find8LetterName()`函数的操作方式与我们先前的树遍历函数相同，只是不打印节点的数据，而是检查节点中存储的名称，并返回它找到的第一个八个字母的名称。您可以通过注释掉先前的名称长度比较和`Checking
    if`行❶，并取消注释后面的名称长度比较和`Checking if`行❷，将先序遍历更改为后序遍历。当您进行此更改时，函数找到的第一个八个字母的名称是`Hadassah`：'
- en: '[PRE83]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: While both traversal orders correctly find an eight-letter name, changing the
    order of a tree traversal can alter the behavior of your program.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两种遍历顺序都可以正确找到一个八个字母的名称，但更改树遍历的顺序可能会改变程序的行为。
- en: Getting the Maximum Tree Depth
  id: totrans-633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取最大树深度
- en: An algorithm can determine the deepest branch in a tree by recursively asking
    its child nodes how deep they are. The *depth* of a node is the number of edges
    between it and the root node. The root node itself has a depth of 0, the immediate
    child of the root node has a depth of 1, and so on. You may need this information
    as part of a larger algorithm or to gather information about the general size
    of the tree data structure.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 算法可以通过递归询问其子节点有多深来确定树中最深的分支。节点的*深度*是它与根节点之间的边的数量。根节点本身的深度为0，根节点的直接子节点的深度为1，依此类推。您可能需要这些信息作为更大算法的一部分，或者为了收集关于树数据结构的一般大小的信息。
- en: We can have a function named `getDepth()` take a node for an argument and return
    the depth of its deepest child node. A leaf node (the base case) simply returns
    `0`.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个名为`getDepth()`的函数，以一个节点作为参数，并返回其最深子节点的深度。叶节点（基本情况）只返回`0`。
- en: For example, given the root node of the tree in [Figure 4-1](#figure4-1), we
    could call `getDepth()` and pass it the root node (the `A` node). This would return
    the depth of its children, the `B` and `C` nodes, plus one. The function must
    make a recursive call to `getDepth()` to find out this information. Eventually,
    the `A` node would call `getDepth()` on `C`, which would call it on `E`. When
    `E` calls `getDepth()` with its two children, `G` and `H`, they both return `0`,
    so `getDepth()` called on `E` returns `1`, making `getDepth()` called on `C` return
    `2`, and making `getDepth()` called on `A` (the root node) return `3`. Our tree’s
    greatest depth is three levels.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定[图4-1](#figure4-1)中树的根节点，我们可以调用`getDepth()`并将其传递给根节点（`A`节点）。这将返回其子节点`B`和`C`节点的深度，再加一。函数必须递归调用`getDepth()`来获取这些信息。最终，`A`节点将在`C`上调用`getDepth()`，它将在`E`上调用它。当`E`用其两个子节点`G`和`H`调用`getDepth()`时，它们都返回`0`，因此在`E`上调用`getDepth()`返回`1`，使得在`C`上调用`getDepth()`返回`2`，并使在`A`（根节点）上调用`getDepth()`返回`3`。我们树的最大深度为三级。
- en: 'Let’s ask our three recursive algorithm questions for the `getDepth()` function:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`getDepth()`函数提出三个递归算法问题：
- en: What is the base case? A leaf node with no children, which by its nature has
    a depth of one level.
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？没有子节点的叶节点，其本质上具有一级深度。
- en: What argument is passed to the recursive function call? The node whose greatest
    depth we want to find.
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？我们想要找到最大深度的节点。
- en: How does this argument become closer to the base case? A DAG has no cycles,
    so following the descendant nodes will eventually reach a leaf node.
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何变得更接近基本情况？DAG没有循环，因此跟随后代节点最终会到达一个叶节点。
- en: 'The following *getDepth.py* program contains a recursive `getDepth()` function
    that returns the number of levels contained in the deepest node in the tree:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 以下*getDepth.py*程序包含了一个递归的`getDepth()`函数，返回树中最深节点包含的级数：
- en: '**Python**'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE84]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The *getDepth.html* program contains the JavaScript equivalent:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '*getDepth.html*程序包含了JavaScript等效代码：'
- en: '**JavaScript**'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE85]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output of these programs is as follows:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下：
- en: '[PRE86]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This matches what we see in [Figure 4-2](#figure4-2): the number of levels
    from the root node `A` down to the lowest nodes `G` and `H` is three levels.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在[图4-2](#figure4-2)中看到的相匹配：从根节点`A`到最低节点`G`和`H`的级数是三级。
- en: Solving Mazes
  id: totrans-650
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决迷宫
- en: While mazes come in all shapes and sizes, *simply connected mazes*, also called
    *perfect mazes*, contain no loops. A perfect maze has exactly one path between
    any two points, such as the start and exit. These mazes can be represented by
    a DAG.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然迷宫的形状和大小各不相同，*简单连通迷宫*，也称为*完美迷宫*，不包含循环。完美迷宫在任何两点之间都有且仅有一条路径，例如开始和出口。这些迷宫可以用DAG表示。
- en: For example, [Figure 4-5](#figure4-5) shows the maze that our maze program solves,
    and [Figure 4-6](#figure4-6) shows the DAG form of it. The capital *S* marks the
    start of the maze, and the capital *E* marks the exit. A few of the intersections
    that have been marked with lowercase letters in the maze correspond to nodes in
    the DAG.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图4-5](#figure4-5)显示了我们的迷宫程序解决的迷宫，[图4-6](#figure4-6)显示了其DAG形式。大写的*S*标记着迷宫的开始，大写的*E*标记着出口。迷宫中标有小写字母的一些交叉点对应于DAG中的节点。
- en: '![Maze with certain intersections labeled with the letters s, d, b, a, c, f,
    e, g, i, j, h, k, n, m, l, and e.](image_fi/502024c04/f04005.png)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![带有标有字母s、d、b、a、c、f、e、g、i、j、h、k、n、m、l和e的特定交叉点的迷宫。](image_fi/502024c04/f04005.png)'
- en: 'Figure 4-5: The maze solved by our maze program in this chapter. Some intersections
    have lowercase letters that correspond to nodes in [Figure 4-6](#figure4-6).'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-5：本章中我们的迷宫程序解决的迷宫。一些交叉点有小写字母，对应于[图4-6](#figure4-6)中的节点。
- en: '![Tree graph in which every intersection of the maze in Figure 4-5 is represented
    as a node.](image_fi/502024c04/f04006.png)'
  id: totrans-655
  prefs: []
  type: TYPE_IMG
  zh: '![树图，迷宫中的每个交叉点都表示为一个节点。](image_fi/502024c04/f04006.png)'
- en: 'Figure 4-6: In this DAG representation of the maze, nodes represent intersections,
    and edges represent the north, south, east, or west path from the intersection.
    Some nodes have lowercase letters to correspond to intersections in [Figure 4-5](#figure4-5).'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-6：在迷宫的DAG表示中，节点表示交叉点，边表示从交叉点到北、南、东或西的路径。一些节点具有小写字母，以对应[图4-5](#figure4-5)中的交叉点。
- en: Because of this similarity in structure, we can use a tree traversal algorithm
    to solve the maze. The nodes in this tree graph represent intersections where
    the maze solver could choose one of the north, south, east, or west paths to follow
    to the next intersection. The root node is the start of the maze, and the leaf
    nodes represent dead ends.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种结构上的相似性，我们可以使用树遍历算法来解决迷宫。这个树图中的节点表示迷宫解算器可以选择要遵循到下一个交叉点的北、南、东或西路径之一。根节点是迷宫的起点，叶节点表示死胡同。
- en: 'The recursive case occurs when the tree traversal algorithm moves from one
    node to the next. If the tree traversal reaches a leaf node (a dead end in the
    maze), the algorithm has reached a base case and must backtrack to an earlier
    node and follow a different path. Once the algorithm reaches the exit node, the
    path it took from the root node represents the maze solution. Let’s ask our three
    recursive algorithm questions about the maze-solving algorithm:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 递归情况发生在树遍历算法从一个节点移动到下一个节点时。如果树遍历到达叶节点（迷宫中的死胡同），算法已经达到了一个基本情况，并且必须回溯到较早的节点并跟随不同的路径。一旦算法到达出口节点，它从根节点到出口节点的路径代表了迷宫的解决方案。让我们问我们的三个递归算法关于解迷宫算法的问题：
- en: What is the base case? Reaching a dead end or the exit of the maze.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？到达死胡同或迷宫的出口。
- en: What argument is passed to the recursive function call? The x, y coordinates,
    along with the maze data and list of already visited x, y coordinates.
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？x，y坐标，迷宫数据以及已经访问过的x，y坐标的列表。
- en: How does this argument become closer to the base case? Like the flood fill algorithm,
    the x, y coordinates keep moving to neighboring coordinates until they eventually
    reach dead ends or the final exit.
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何变得更接近基本情况？像泛洪填充算法一样，x，y坐标不断移动到相邻的坐标，直到最终到达死胡同或最终出口。
- en: 'This *mazeSolver.py* program contains the Python code for solving the maze
    stored in the `MAZE` variable:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*mazeSolver.py*程序包含了Python代码，用于解决存储在`MAZE`变量中的迷宫：
- en: '**Python**'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE87]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The *mazeSolver.html* program contains the JavaScript equivalent:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '*mazeSolver.html*程序包含了JavaScript等效代码：'
- en: '**JavaScript**'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE88]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: A lot of this code is not directly related to the recursive maze-solving algorithm.
    The `MAZE` variable stores the maze data as a multiline string with hashtags to
    represent walls, an `S` for the starting point, and an `E` for the exit. This
    string is converted into a list that contains lists of strings, with each string
    representing a single character in the maze. This allows us to access `MAZE[y][x]`
    (note that `y` comes first) to get the character at the x, y coordinate in the
    original `MAZE` string. The `printMaze()` function can accept this list-of-list
    data structure and display the maze on the screen. The `findStart()` function
    accepts this data structure and returns the x, y coordinates of the `S` starting
    point. Feel free to edit the maze string yourself—although remember that, in order
    for the solving algorithm to work, the maze cannot have any loops.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与递归解迷宫算法无直接关系。`MAZE`变量将迷宫数据存储为多行字符串，其中井号表示墙壁，`S`表示起点，`E`表示出口。这个字符串被转换为一个包含字符串列表的列表，每个字符串表示迷宫中的一个单个字符。这使我们能够访问`MAZE[y][x]`（注意`y`在前）以获取原始`MAZE`字符串中x，y坐标处的字符。`printMaze()`函数可以接受这个列表-列表数据结构并在屏幕上显示迷宫。`findStart()`函数接受这个数据结构并返回`S`起点的x，y坐标。随意编辑迷宫字符串——但请记住，为了使解决算法起作用，迷宫不能有任何循环。
- en: The recursive algorithm is in the `solveMaze()` function. The arguments to this
    function are the maze data structure, the current x- and y-coordinates, and a
    `visited` list (which is created if none was supplied) ❶. The `visited` list contains
    all the coordinates that have previously been visited so that when the algorithm
    backtracks from a dead end to an earlier intersection, it knows which paths it
    has tried before and can try a different one. The path from the start to the exit
    is marked by replacing the spaces (matching the `EMPTY` constant) in the maze
    data structure with periods (from the `PATH` constant).
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 递归算法在`solveMaze()`函数中。这个函数的参数是迷宫数据结构，当前的x和y坐标，以及一个`visited`列表（如果没有提供，则创建）❶。`visited`列表包含先前访问过的所有坐标，因此当算法从死胡同回溯到较早的交叉点时，它知道它以前尝试过哪些路径，并且可以尝试不同的路径。从起点到出口的路径通过用句点（来自`PATH`常量）替换迷宫数据结构中的空格（匹配`EMPTY`常量）来标记。
- en: The maze-solving algorithm is similar to our flood fill program in Chapter 3
    in that it “spreads” to neighboring coordinates, though when it reaches a dead
    end, it backtracks to an earlier intersection. The `solveMaze()` function receives
    the x, y coordinates indicating the algorithm’s current location in the maze.
    If this is the exit, the function returns `True`, causing all the recursive calls
    to also return `True`. The maze data structure remains marked with the solution
    path.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 解迷宫算法类似于我们在第3章中的泛洪填充程序，它“扩散”到相邻的坐标，但当它到达死胡同时，它会回溯到较早的交叉点。`solveMaze()`函数接收指示算法当前位置的x，y坐标。如果这是出口，函数返回`True`，导致所有递归调用也返回`True`。迷宫数据结构保持标记为解决方案路径。
- en: Otherwise, the algorithm marks the current x, y coordinates in the maze data
    structure with a period and adds the coordinates to the `visited` list ❷. Then
    it looks to the x, y coordinates north of the current coordinates to see if that
    point is not off the edge of the map, is either the empty or exit space, and has
    not been visited before. If these conditions are met, the algorithm makes a recursive
    call to `solveMaze()` with the northern coordinates. If these conditions aren’t
    met or the recursive call to `solveMaze()` returns `False`, the algorithm continues
    on to check the south, east, and west coordinates. Like the flood fill algorithm,
    recursive calls are made with the neighboring coordinates.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，算法会在迷宫数据结构中标记当前的x，y坐标，并将这些坐标添加到“visited”列表中❷。然后它会查看当前坐标北面的x，y坐标，看看那个点是否没有超出地图边缘，是空白或出口空间，并且以前没有被访问过。如果满足这些条件，算法将使用北面的坐标进行递归调用`solveMaze()`。如果不满足这些条件或递归调用`solveMaze()`返回`False`，算法将继续检查南、东和西坐标。与泛洪填充算法一样，使用相邻坐标进行递归调用。
- en: To get a better idea of how this algorithm works, uncomment the two `printMaze(MAZE)`
    calls ❸ ❹ inside the `solveMaze()` function. These will display the maze data
    structure as it attempts new paths, reaches dead ends, backtracks, and tries different
    paths.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地了解这个算法的工作原理，请取消`solveMaze()`函数内的两个`printMaze(MAZE)`调用❸ ❹。这将显示迷宫数据结构在尝试新路径、到达死胡同、回溯和尝试不同路径时的情况。
- en: Summary
  id: totrans-673
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter explored several algorithms that make use of tree data structures
    and backtracking, which are features of a problem that is suitable for solving
    with recursive algorithms. We covered tree data structures, which are composed
    of nodes that contain data and edges that relate nodes together in parent–child
    relationships. In particular, we examined a specific kind of tree called a directed
    acyclic graph (DAG) that is often used in recursive algorithms. A recursive function
    call is analogous to traversing to a child node in a tree, while returning from
    a recursive function call is analogous to backtracking to a previous parent node.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了几种使用树数据结构和回溯的算法，这些算法是适合使用递归算法解决的问题的特点。我们介绍了树数据结构，它由包含数据的节点和将节点联系在一起的边组成，这些边以父-子关系相互关联。特别是，我们研究了一种特定类型的树，称为有向无环图（DAG），它经常在递归算法中使用。递归函数调用类似于在树中遍历到子节点，而从递归函数调用返回类似于回溯到以前的父节点。
- en: While recursion is overused for simple programming problems, it is well matched
    for problems that involve tree-like structures and backtracking. Using these ideas
    of tree-like structures, we wrote several algorithms for traversing, searching,
    and determining the depth of tree structures. We also showed that a simply connected
    maze has a tree-like structure, and employed recursion and backtracking to solve
    a maze.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然递归在简单的编程问题中被滥用，但它非常适合涉及类似树的结构和回溯的问题。利用这些类似树的结构的想法，我们编写了几个用于遍历、搜索和确定树结构深度的算法。我们还展示了一个简单连通的迷宫具有类似树的结构，并利用递归和回溯来解决迷宫。
- en: Further Reading
  id: totrans-676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: There is far more to trees and tree traversal than the brief description of
    DAGs presented in this chapter. The Wikipedia articles at [https://en.wikipedia.org/wiki/Tree_(data_structure)](https://en.wikipedia.org/wiki/Tree_(data_structure))
    and [https://en.wikipedia.org/wiki/Tree_traversal](https://en.wikipedia.org/wiki/Tree_traversal)
    provide additional context for these concepts, which are often used in computer
    science.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 树和树遍历远不止本章中介绍的DAG的简要描述。维基百科的文章[https://en.wikipedia.org/wiki/Tree_(data_structure)](https://en.wikipedia.org/wiki/Tree_(data_structure))和[https://en.wikipedia.org/wiki/Tree_traversal](https://en.wikipedia.org/wiki/Tree_traversal)为这些概念提供了额外的背景信息，这些概念在计算机科学中经常使用。
- en: The Computerphile YouTube channel also has a video titled “Maze Solving” at
    [https://youtu.be/rop0W4QDOUI](https://youtu.be/rop0W4QDOUI) that discusses these
    concepts. V. Anton Spraul, author of *Think Like a Programmer* (No Starch Press,
    2012), also has a video on maze solving titled “Backtracking” at [https://youtu.be/gBC_Fd8EE8A](https://youtu.be/gBC_Fd8EE8A).
    The freeCodeCamp organization ([https://freeCodeCamp.org](https://freeCodeCamp.org))
    has a video series on backtracking algorithms at [https://youtu.be/A80YzvNwqXA](https://youtu.be/A80YzvNwqXA).
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: Computerphile YouTube频道还有一个名为“Maze Solving”的视频，讨论了这些概念。V. Anton Spraul，*Think
    Like a Programmer*（No Starch Press，2012）的作者，还有一个名为“Backtracking”的迷宫解决视频，网址为[https://youtu.be/gBC_Fd8EE8A](https://youtu.be/gBC_Fd8EE8A)。freeCodeCamp组织（[https://freeCodeCamp.org](https://freeCodeCamp.org)）在[https://youtu.be/A80YzvNwqXA](https://youtu.be/A80YzvNwqXA)上有一个关于回溯算法的视频系列。
- en: In addition to maze solving, the recursive backtracker algorithm uses recursion
    to generate mazes. You can find out more about this and other maze-generating
    algorithms at [https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker](https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker).
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解迷宫外，递归回溯算法还使用递归生成迷宫。您可以在[https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker](https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker)找到更多关于这个和其他迷宫生成算法的信息。
- en: Practice Questions
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习问题
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试您的理解能力：
- en: What are nodes and edges?
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点和边是什么？
- en: What are root and leaf nodes?
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根节点和叶节点是什么？
- en: What are the three tree traversal orders?
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树遍历有哪三种顺序？
- en: What does *DAG* stand for?
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*DAG*代表什么？'
- en: What is a cycle, and do DAGs have cycles?
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是循环，DAG有循环吗？
- en: What is a binary tree?
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是二叉树？
- en: What are the child nodes in a binary tree called?
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二叉树中的子节点称为什么？
- en: If a parent node has an edge to a child node, and the child node has an edge
    back to the parent node, is this graph considered a DAG?
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果父节点有一条边指向子节点，并且子节点有一条边返回父节点，这个图被认为是DAG吗？
- en: What is backtracking in a tree traversal algorithm?
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树遍历算法中的回溯是什么？
- en: For the following tree traversal problems, you can use the Python/JavaScript
    code in “A Tree Data Structure in Python and JavaScript” in Chapter 4 for your
    tree and the multiline `MAZE` string from the *mazeSolver.py* and *mazeSolver.html*
    programs for the maze data.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下树遍历问题，您可以使用第4章“Python和JavaScript中的树数据结构”中的Python/JavaScript代码作为您的树，以及*mazeSolver.py*和*mazeSolver.html*程序中的多行`MAZE`字符串作为迷宫数据。
- en: 'Answer the three questions about recursive solutions for each of the recursive
    algorithms presented in this chapter:'
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回答本章中每个递归算法的三个问题：
- en: What is the base case?
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？
- en: What argument is passed to the recursive function call?
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？
- en: How does this argument become closer to the base case?
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个论点如何更接近基本情况？
- en: Then re-create the recursive algorithms from this chapter without looking at
    the original code.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新创建本章中的递归算法，而不看原始代码。
- en: Practice Projects
  id: totrans-697
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习项目
- en: 'For practice, write a function for each of the following tasks:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 练习时，为以下每个任务编写一个函数：
- en: Create a reverse-inorder search, one that performs an inorder traversal but
    traverses the right child node before the left child node.
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个逆中序搜索，执行中序遍历，但在遍历左子节点之前遍历右子节点。
- en: Create a function that, given a root node as an argument, proceeds to make the
    tree one level deeper by adding one child node to each leaf node in the original
    tree. This function will need to perform a tree traversal, detect when it has
    reached a leaf node, and then add one and only one child node to the leaf node.
    Be sure not to go on and add a child node to this new leaf node, as that will
    eventually cause a stack overflow.
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，给定一个根节点作为参数，通过向原始树的每个叶节点添加一个子节点，使树深度增加一级。这个函数需要执行树遍历，检测是否已经到达叶节点，然后向叶节点添加一个且仅一个子节点。确保不要继续向这个新叶节点添加子节点，因为这最终会导致堆栈溢出。
- en: '5'
  id: totrans-701
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Divide-and-Conquer Algorithms
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 分而治之算法
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Divide-and-conquer algorithms*are those that split large problems into smaller
    subproblems, then divide those subproblems into ones that are smaller yet, until
    they become trivial to conquer. This approach makes recursion an ideal technique
    to use: the recursive case divides the problem into self-similar subproblems,
    and the base case occurs when the subproblem has been reduced to a trivial size.
    One benefit of this approach is that these problems can be worked on in parallel,
    allowing multiple central processing unit (CPU) cores or computers to work on
    them.'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '*分而治之算法*是将大问题分解为更小的子问题，然后将这些子问题分解为更小的问题，直到变得微不足道。这种方法使递归成为一种理想的技术：递归情况将问题分解为自相似的子问题，基本情况发生在子问题被减少到微不足道的大小时。这种方法的一个好处是这些问题可以并行处理，允许多个中央处理单元（CPU）核心或计算机处理它们。'
- en: In this chapter, we’ll look at some common algorithms that use recursion to
    divide and conquer, such as binary search, quicksort, and merge sort. We’ll also
    reexamine summing an array of integers, this time with a divide-and-conquer approach.
    Finally, we’ll take a look at the more esoteric Karatsuba multiplication algorithm,
    developed in 1960, that laid the basis for computer hardware’s fast integer multiplication.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一些常见的使用递归进行分而治之的算法，例如二分查找、快速排序和归并排序。我们还将重新审视对整数数组求和，这次采用分而治之的方法。最后，我们将看一下更神秘的Karatsuba乘法算法，它是在1960年开发的，为计算机硬件的快速整数乘法奠定了基础。
- en: 'Binary Search: Finding a Book in an Alphabetized Bookshelf'
  id: totrans-706
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分查找：在按字母顺序排列的书架上找书
- en: 'Let’s say you have a bookshelf of 100 books. You can’t remember which books
    you have or their exact locations on the shelf, but you do know that they are
    sorted alphabetically by title. To find your book *Zebras: The Complete Guide*,
    you wouldn’t start at the beginning of the bookshelf, where *Aaron Burr Biography*
    is, but rather toward the end of the bookshelf. Your zebra book wouldn’t be the
    very last book on the shelf if you also had books on zephyrs, zoos, and zygotes,
    but it would be close. Thus, you can use the facts that the books are in alphabetical
    order and that *Z* is the last letter of the alphabet as *heuristics*, or approximate
    clues, to look toward the end of the shelf rather than the beginning.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '假设你有一个有100本书的书架。你记不得你有哪些书，也不知道它们在书架上的确切位置，但你知道它们是按标题字母顺序排列的。要找到你的书*Zebras:
    The Complete Guide*，你不会从书架的开头开始，那里有*Aaron Burr Biography*，而是朝书架的末尾。如果你还有关于zebras、动物园和合子的书，你的斑马书就不会是书架上的最后一本书，但会很接近。因此，你可以利用书是按字母顺序排列的这一事实，以及*Z*是字母表的最后一个字母作为*启发式*，或者近似线索，向书架的末尾而不是开头寻找。'
- en: '*Binary search* is a technique for locating a target item in a sorted list
    by repeatedly determining which half of the list the item is in. The most impartial
    way to search the bookshelf is to start with a book in the middle, and then ascertain
    if the target book you’re looking for is in the left half or the right half.'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '*二分查找*是一种在排序列表中定位目标项的技术，它通过反复确定项在列表的哪一半来进行。搜索书架的最公正的方法是从中间的一本书开始，然后确定你要找的目标书是在左半部分还是右半部分。'
- en: 'You can then repeat this process, as shown in [Figure 5-1](#figure5-1): look
    at the book in the middle of your chosen half and then determine whether your
    target book is in the left-side quarter or the right-side quarter. You can do
    this until you either find the book, or find the place where the book should be
    but isn’t and declare that the book doesn’t exist on the shelf.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以重复这个过程，如[图5-1](#figure5-1)所示：查看您选择的一半中间的书，然后确定您的目标书是否在左侧四分之一还是右侧四分之一。您可以一直这样做，直到找到书，或者找到书应该在的地方但却没有找到，并宣布书不存在于书架上。
- en: '![Drawing of a bookshelf with labels separating the books into two sections,
    one of which is highlighted. In a second bookshelf drawing, that highlighted portion
    is further split in half. In a third bookshelf drawing, only one book of the previously
    selected portion is highlighted.](image_fi/502024c05/f05001.png)'
  id: totrans-710
  prefs: []
  type: TYPE_IMG
  zh: '![书架的图画，标签将书分成两个部分，其中一个被突出显示。在第二个书架图中，突出显示的部分被进一步分成两半。在第三个书架图中，只有一个书被突出显示。](image_fi/502024c05/f05001.png)'
- en: 'Figure 5-1: A binary search repeatedly determines which half of a range contains
    your target item in a sorted array of items.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1：二分搜索反复确定范围的哪一半包含排序数组中的目标项。
- en: This process scales efficiently; doubling the number of books to search adds
    only one step to the search process. A linear search of a shelf with 50 books
    takes 50 steps, and a linear search of a shelf with 100 books takes 100 steps.
    But a binary search of a shelf with 50 books takes only 6 steps, and a shelf with
    100 books takes only 7 steps.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的扩展效率很高；将要搜索的书籍数量加倍只会增加搜索过程的一步。对于有50本书的书架进行线性搜索需要50步，对于有100本书的书架进行线性搜索需要100步。但对于有50本书的书架进行二分搜索只需要6步，而对于有100本书的书架只需要7步。
- en: 'Let’s ask the three recursion questions about our binary search implementation:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的二分搜索实现提出三个递归问题：
- en: What is the base case? Searching a range of items that is only one item in length.
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？搜索长度为1的项目范围。
- en: What argument is passed to the recursive function call? The indices of the left
    and right ends of the range in the list we are searching.
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递给递归函数调用的参数是什么？我们正在搜索的列表范围的左右端的索引。
- en: How does this argument become closer to the base case? The range halves in size
    for each recursive call, so it eventually becomes one item long.
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何接近基本情况？每次递归调用时，范围的大小减半，因此最终变为一个项目长。
- en: 'Examine the following `binarySearch()` function in our *binarySearch.py* program,
    which locates a value, `needle`, in a sorted list of values, `haystack`:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们*binarySearch.py*程序中的以下`binarySearch()`函数，它在排序值`haystack`的排序列表中定位值`needle`：
- en: '**Python**'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE89]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The *binarySearch.html* program has this JavaScript equivalent:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '*binarySearch.html*程序有这个JavaScript等价物：'
- en: '**JavaScript**'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE90]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'When you run these programs, the list `[1, 4, 8, 11, 13, 16, 19, 19]` is searched
    for `13`, and the output looks like this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行这些程序时，将搜索列表`[1, 4, 8, 11, 13, 16, 19, 19]`中的`13`，输出如下：
- en: '[PRE91]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The target value `13` is indeed at index `4` in that list.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 目标值`13`确实在列表中的索引`4`处。
- en: The code calculates the middle index (stored in `mid`) of the range defined
    by the `left` and `right` indices. At first, this range is the entire length of
    the items list. If the value at the `mid` index is the same as `needle`, then
    `mid` is returned. Otherwise, we need to figure out whether our target value is
    in the left half of the range (in which case, the new range to search is `left`
    to `mid - 1`) or in the right half (in which case, the new range to search is
    `mid + 1` to `end`).
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 代码计算了由`left`和`right`索引定义的范围的中间索引（存储在`mid`中）。起初，这个范围是整个项目列表的长度。如果`mid`索引处的值与`needle`相同，则返回`mid`。否则，我们需要弄清楚我们的目标值是在范围的左半部分（在这种情况下，要搜索的新范围是`left`到`mid
    - 1`）还是在右半部分（在这种情况下，要搜索的新范围是`mid + 1`到`end`）。
- en: 'We already have a function that can search this new range: `binarySearch()`
    itself! A recursive call is made on the new range. If we ever get to the point
    where the right end of the search range comes before the left, we know that our
    search range has shrunk down to zero and our target value isn’t to be found.'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个可以搜索这个新范围的函数：`binarySearch()`本身！对新范围进行递归调用。如果我们最终到达搜索范围的右端在左端之前的点，我们知道我们的搜索范围已经缩小到零，我们的目标值找不到。
- en: Notice that the code performs no actions after the recursive call returns; it
    immediately returns the return value of the recursive function call. This feature
    means that we could implement tail call optimization for this recursive algorithm,
    a practice we explain in Chapter 8. But also, it means that binary search can
    easily be implemented as an iterative algorithm that doesn’t use recursive function
    calls. This book’s downloadable resources at [https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion)
    include the source code for an iterative binary search for you to compare with
    the recursive binary search.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，递归调用返回后，代码不执行任何操作；它立即返回递归函数调用的返回值。这个特性意味着我们可以为这个递归算法实现尾递归优化，这是我们在第8章中解释的一种做法。但也意味着二分搜索可以很容易地作为一个不使用递归函数调用的迭代算法来实现。本书的可下载资源位于[https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion)，其中包括用于比较递归二分搜索的迭代二分搜索的源代码。
- en: 'Quicksort: Splitting an Unsorted Pile of Books into Sorted Piles'
  id: totrans-729
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速排序：将未排序的书堆分成排序的堆
- en: Remember that `binarySearch()`’s speed advantage comes from the fact that the
    values in items are sorted. If the values are out of order, the algorithm won’t
    work. Enter *quicksort*, a recursive sorting algorithm developed by computer scientist
    Tony Hoare in 1959.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`binarySearch()`的速度优势来自于项目中的值是排序的。如果值是无序的，算法将无法工作。输入*quicksort*，这是由计算机科学家Tony
    Hoare在1959年开发的递归排序算法。
- en: 'Quicksort uses a divide-and-conquer technique called *partitioning*. Think
    of partitioning this way: imagine you have a large pile of unalphabetized books.
    Grabbing one book and placing it in the right spot on the shelf means you’ll spend
    a lot of time rearranging the bookshelf as it gets full. It would help if you
    first turned the pile of books into two piles: an *A* to *M* pile and an *N* to
    *Z* pile. (In this example, *M* would be our *pivot*.)'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序使用一种称为*分区*的分而治之技术。想象一下分区：想象你有一大堆未按字母顺序排列的书。拿起一本书并把它放在书架上的正确位置意味着当书架变得满时，你将花费大量时间重新排列书架。如果你首先将书堆分成两堆：一个*A*到*M*的堆和一个*N*到*Z*的堆会有所帮助。（在这个例子中，*M*将是我们的*枢轴*。）
- en: 'You haven’t sorted the pile, but you have *partitioned* it. And partitioning
    is easy: the book doesn’t have to go into the correct place in one of the two
    piles, it just has to go into the correct pile. Then you can further partition
    these two piles into four piles: *A* to *G*, *H* to *M*, *N* to *T*, and *U* to
    *Z*. This is shown in [Figure 5-2](#figure5-2). If you keep partitioning, you
    end up with piles that contain one book each (the base case), and the piles are
    now in sorted order. This means the books are now in sorted order as well. This
    repeated partitioning is how quicksort works.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 你还没有对这堆进行排序，但你已经*分区*了。分区很容易：书不必放在两堆中的一个正确的位置，它只需放在正确的堆中。然后你可以进一步将这两堆分成四堆：*A*到*G*，*H*到*M*，*N*到*T*，和*U*到*Z*。这在[图5-2](#figure5-2)中显示。如果你继续分区，最终会得到每堆包含一本书的情况（基本情况），而且这些堆现在是按顺序排列的。这意味着书现在也是按顺序排列的。这种重复的分区是快速排序的工作原理。
- en: For the first partitioning of *A* to *Z*, we select *M* as the pivot value because
    it’s the middle letter between *A* and *Z*. However, if our collection of books
    consisted of one book about Aaron Burr and 99 books about zebras, zephyrs, zoos,
    zygotes, and other *Z* topics, our two partitioned piles would be heavily unbalanced.
    We would have the single Aaron Burr book in the *A* to *M* pile and every other
    book in the *M* to *Z* pile. The quicksort algorithm works fastest when the partitions
    are evenly balanced, so selecting a good pivot value at each partition step is
    important.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*A*到*Z*的第一次分区，我们选择*M*作为枢轴值，因为它是在*A*和*Z*之间的中间字母。然而，如果我们的书集包括一本关于亚伦·伯尔的书和99本关于斑马、和风、动物园、合子和其他*Z*主题的书，我们的两个分区堆将会严重失衡。我们会在*A*到*M*堆中有一本单独的亚伦·伯尔的书，而在*M*到*Z*堆中有其他所有的书。当分区均匀平衡时，快速排序算法的工作速度最快，因此在每个分区步骤中选择一个好的枢轴值是很重要的。
- en: '![Drawing of several piles of books in a tree-like structure. Shows one pile
    of books, A–Z, split into two piles, A–M and N–Z. A–M is further split into A–G
    and H–M. N–Z is further split into N–T and U–Z.](image_fi/502024c05/f05002.png)'
  id: totrans-734
  prefs: []
  type: TYPE_IMG
  zh: '![树状结构中几堆书的图。显示一堆书，A-Z，分成两堆，A-M和N-Z。A-M进一步分成A-G和H-M。N-Z进一步分成N-T和U-Z。](image_fi/502024c05/f05002.png)'
- en: 'Figure 5-2: Quicksort works by repeatedly partitioning items into two sets.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-2：快速排序通过反复将项目分成两组来工作。
- en: However, if you don’t know anything about the data you’re sorting, it’s impossible
    to select an ideal pivot. This is why the generic quicksort algorithm simply uses
    the last value in the range for the pivot value.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你对你要排序的数据一无所知，那么选择一个理想的枢轴是不可能的。这就是为什么通用的快速排序算法简单地使用范围中的最后一个值作为枢轴值。
- en: In our implementation, each call to `quicksort()` is given an array of items
    to sort. It is also given `left` and `right` arguments specifying the range of
    indices in that array to sort, similar to `binarySearch()`’s left and right arguments.
    The algorithm selects a pivot value to compare with the other values in the range,
    then places the values to either the left side of the range (if they’re less than
    the pivot value) or the right side (if they’re greater than the pivot value).
    This is the partition step. Next, the `quicksort()` function is recursively called
    on these two, smaller ranges until a range has been reduced to zero. The list
    becomes more and more sorted as the recursive calls are made, until finally the
    entire list is in the correct order.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，每次调用`quicksort()`都会给出一个要排序的项目数组。它还给出了`left`和`right`参数，指定了要对该数组中的索引范围进行排序，类似于`binarySearch()`的left和right参数。算法选择一个枢轴值与范围中的其他值进行比较，然后将这些值放在范围的左侧（如果它们小于枢轴值）或右侧（如果它们大于枢轴值）。这是分区步骤。接下来，`quicksort()`函数在这两个更小的范围上递归调用，直到一个范围已经减少到零。随着递归调用的进行，列表变得越来越有序，直到最终整个列表按正确的顺序排列。
- en: Note that the algorithm modifies the array in place. See “Modifying a List or
    Array in Place” in Chapter 4 for details. Thus, the `quicksort()` function doesn’t
    return a sorted array. The base case merely returns to stop producing more recursive
    calls.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该算法会就地修改数组。有关详细信息，请参见第4章中的“就地修改列表或数组”。因此，`quicksort()`函数不会返回一个排序好的数组。基本情况只是返回以停止产生更多的递归调用。
- en: 'Let’s ask the three recursion questions about our binary search implementation:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的二分搜索实现提出三个递归问题：
- en: What is the base case? Being given a range to sort that contains zero or one
    item and that is already in sorted order.
  id: totrans-740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本情况是什么？给定一个要排序的范围，其中包含零个或一个项目，并且已经按顺序排列。
- en: What argument is passed to the recursive function call? The indices of the left
    and right ends of the range in the list we are sorting.
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？我们正在排序的列表中范围的左右端的索引。
- en: How does this argument become closer to the base case? The range halves in size
    for each recursive call, so it eventually becomes empty.
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个论点如何接近基本情况？每次递归调用时，范围的大小减半，所以最终变为空。
- en: 'The following `quicksort()` function in the *quicksort.py* Python program sorts
    the values in the items list into ascending order:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '*quicksort.py* Python程序中的以下`quicksort()`函数将items列表中的值按升序排序：'
- en: '[PRE92]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The *quicksort.html* program contains the JavaScript equivalent:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '*quicksort.html*程序包含了JavaScript等效程序：'
- en: '[PRE93]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This code is similar to the code in the binary search algorithm. As defaults,
    we set the `left` and `right` ends of the range within the `items` array to the
    beginning and end of the entire array. If the algorithm reaches the base case
    of the `right` end at or before the `left` end (a range of one or zero items),
    the sorting is finished ❶.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码类似于二分搜索算法中的代码。作为默认值，我们将`items`数组中范围的`left`和`right`端设置为整个数组的开始和结束。如果算法达到了`right`端在`left`端之前或在`left`端之前的基本情况（一个或零个项目的范围），则排序完成❶。
- en: 'In each call to `quicksort()`, we partition the items in the current range
    (defined by the indices in `left` and `right`), and then swap them around so that
    the items less than the pivot value end up on the left side of the range and the
    items greater than the pivot value end up on the right side of the range. For
    example, if `42` is the pivot value in the array `[81, 48, 94, 87, 83, 14, 6,
    42]`, a partitioned array would be `[14, 6, 42, 81, 48, 94, 87, 83]`. Note that
    a partitioned array is not the same thing as a sorted one: although the two items
    to the left of `42` are less than `42`, and the five items to the right of `42`
    are greater than `42`, the items are not in sorted order.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次调用`quicksort()`时，我们对当前范围内的项目进行分区（由`left`和`right`中的索引定义），然后交换它们，使得小于枢纽值的项目最终位于范围的左侧，而大于枢纽值的项目最终位于范围的右侧。例如，如果数组`[81,
    48, 94, 87, 83, 14, 6, 42]`中的枢纽值为`42`，则分区后的数组将是`[14, 6, 42, 81, 48, 94, 87, 83]`。请注意，分区后的数组与排序后的数组不同：尽管`42`左侧的两个项目小于`42`，`42`右侧的五个项目大于`42`，但项目并不按顺序排列。
- en: The bulk of the `quicksort()` function is the partitioning step. To get an idea
    of how partitioning works, imagine an index `j` that begins at the left end of
    the range and moves to the right end ❷. We compare the item at index `j` with
    the pivot value and then move right to compare the next item. The pivot value
    can be arbitrarily chosen from any value in the range, but we’ll always use the
    value at the right end of the range.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '`quicksort()`函数的主要部分是分区步骤。要了解分区的工作原理，想象一个索引`j`，它从范围的左端开始并向右端移动❷。我们将索引`j`处的项目与枢纽值进行比较，然后向右移动以比较下一个项目。枢纽值可以任意选择范围内的任何值，但我们将始终使用范围的右端的值。'
- en: Imagine a second index `i` that also begins at the left end. If the item at
    index `j` is less than or equal to the pivot, the items at indices `i` and `j`
    are swapped ❸ and `i` is increased to the next index. So while `j` always increases
    (that is, moves right) after each comparison with the pivot value, `i` increases
    only if the item at index `j` is less than or equal to the pivot.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下第二个索引`i`，它也从左端开始。如果索引`j`处的项目小于或等于枢纽值，则交换索引`i`和`j`处的项目❸，并将`i`增加到下一个索引。因此，`j`在与枢纽值进行比较后总是增加（即向右移动），而`i`只有在索引`j`处的项目小于或等于枢纽值时才会增加。
- en: The names `i` and `j` are commonly used for variables that hold array indices.
    Someone else’s `quicksort()` implementation may instead use `j` and `i`, or even
    completely different variables. The important thing to remember is that two variables
    store indices and behave as shown here.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '`i`和`j`这两个名称通常用于保存数组索引的变量。其他人的`quicksort()`实现可能会使用`j`和`i`，甚至完全不同的变量。重要的是要记住，这两个变量存储索引并且表现如此。'
- en: 'As an example, let’s work through the first partitioning of the array `[0,
    7, 6, 3, 1, 2, 5, 4]`, and the range defined by `left` of `0` and `right` of `7`
    to cover the full size of the array. The `pivot` will be the value at the `right`
    end, `4`. The `i` and `j` index begin at index `0`, the left end of the range.
    At each step, index `j` always moves to the right. Index `i` moves only if the
    value at index `j` is less than or equal to the pivot value. The `items` array,
    the `i` index, and the `j` index begin as follows:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们来看看数组`[0, 7, 6, 3, 1, 2, 5, 4]`的第一次分区，范围由`left`为`0`和`right`为`7`定义，覆盖数组的整个大小。`pivot`将是右端的值`4`。`i`和`j`索引从索引`0`开始，即范围的左端。在每一步中，索引`j`总是向右移动。只有当索引`j`处的值小于或等于枢纽值时，索引`i`才会移动。`items`数组，`i`索引和`j`索引的初始状态如下：
- en: '[PRE94]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The value at index `j` (which is `0`) is less than or equal to the pivot value
    (which is `4`), so swap the values at `i` and `j`. This results in no actual change
    since `i` and `j` are the same index. Also, increase `i` so that it moves to the
    right. The `j` index increases for every comparison with the pivot value. The
    state of the variables now looks like this:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`j`处的值（为`0`）小于或等于枢纽值（为`4`），因此交换`i`和`j`处的值。这实际上没有产生任何变化，因为`i`和`j`是相同的索引。此外，增加`i`，使其向右移动。`j`索引在与枢纽值进行比较时每次都会增加。变量的状态现在如下所示：
- en: '[PRE95]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The value at index `j` (which is `7`) is not less than or equal to the pivot
    value (which is `4`), so don’t swap the values. Remember, `j` always increases,
    but `i` increases only after a swap is performed—so `i` is always either at or
    to the left of `j`. The state of the variables now looks like this:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`j`处的值（为`7`）不小于或等于枢纽值（为`4`），因此不交换值。请记住，`j`始终增加，但只有在执行交换后`i`才会增加——因此`i`始终在`j`处或左侧。变量的状态现在如下所示：
- en: '[PRE96]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The value at index `j` (which is `6`) is not less than or equal to the pivot
    value (which is `4`), so don’t swap the values. The state of the variables now
    looks like this:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`j`处的值（为`6`）不小于或等于枢纽值（为`4`），因此不交换值。变量的状态现在如下所示：
- en: '[PRE97]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The value at index `j` (which is `3`) is less than or equal to the pivot value
    (which is `4`), so swap the values at `i` and `j`. The `7` and `3` swap positions.
    Also, increase `i` so that it moves to the right. The state of the variables now
    looks like this:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`j`处的值（为`3`）小于或等于枢纽值（为`4`），因此交换`i`和`j`处的值。`7`和`3`交换位置。此外，增加`i`，使其向右移动。变量的状态现在如下所示：
- en: '[PRE98]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The value at index `j` (which is `1`) is less than or equal to the pivot value
    (which is `4`), so swap the values at `i` and `j`. The `6` and `1` swap positions.
    Also, increase `i` so that it moves to the right. The state of the variables now
    looks like this:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`j`处的值（为`1`）小于或等于枢纽值（为`4`），因此交换`i`和`j`处的值。`6`和`1`交换位置。此外，增加`i`，使其向右移动。变量的状态现在如下所示：
- en: '[PRE99]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The value at index `j` (which is `2`) is less than or equal to the pivot value
    (which is `4`), so swap the values at `i` and `j`. The `7` and `2` swap positions.
    Also, increase `i` so that it moves to the right. The state of the variables now
    looks like this:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`j`处的值（为`2`）小于或等于枢纽值（为`4`），因此交换`i`和`j`处的值。`7`和`2`交换位置。此外，增加`i`，使其向右移动。变量的状态现在如下所示：
- en: '[PRE100]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The value at index `j` (which is `6`) is not less than or equal to the pivot
    value (which is `4`), so don’t swap the values. The state of the variables now
    looks like this:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`j`处的值（为`6`）不小于或等于枢轴值（为`4`），因此不交换值。现在变量的状态如下：
- en: '[PRE101]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We’ve reached the end of the partitioning. The index `j` is at the pivot value
    (which is always the rightmost value in the range), so let’s swap `i` and `j`
    one last time to make sure the pivot is not on the right half of the partition.
    The `6` and `4` swap positions. The state of the variables now looks like this:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了分区的末尾。索引`j`位于枢轴值（始终是范围中最右边的值）处，因此让我们最后一次交换`i`和`j`，以确保枢轴不在分区的右半部分。`6`和`4`交换位置。现在变量的状态如下：
- en: '[PRE102]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Notice what is happening with the `i` index: this index will always receive
    the values smaller than the pivot value as a result of swapping; then the `i`
    index moves right to receive future smaller-than-the-pivot values. As a result,
    everything to the left of the `i` index is smaller than or equal to the pivot,
    and everything to the right of the `i` index is greater than the pivot.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`i`索引的变化：由于交换的结果，该索引始终会接收小于枢轴值的值；然后`i`索引向右移动以接收未来小于枢轴值的值。因此，`i`索引左侧的所有值都小于或等于枢轴，而`i`索引右侧的所有值都大于枢轴。
- en: The entire process repeats as we recursively call `quicksort()` on the left
    and right partitions. When we partition these two halves (and then partition the
    four halves of these two halves with more recursive `quicksort()` calls, and so
    on), the entire array ends up sorted.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程会重复进行，我们会在左右分区上递归调用`quicksort()`。当我们对这两半进行分区（然后对这两半的四半进行分区，再进行更多递归的`quicksort()`调用，依此类推），整个数组最终会被排序。
- en: 'When we run these programs, the output shows the process of sorting the `[0,
    7, 6, 3, 1, 2, 5, 4]` list. The rows of periods are meant to help you line up
    the output when writing the code:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这些程序时，输出显示了对`[0, 7, 6, 3, 1, 2, 5, 4]`列表进行排序的过程。点的行用于在编写代码时对齐输出：
- en: '[PRE103]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Quicksort is a commonly used sorting algorithm because it is straightforward
    to implement and, well, quick. The other commonly used sorting algorithm, merge
    sort, is also fast and uses recursion. We cover it next.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是一种常用的排序算法，因为它易于实现，而且速度快。另一种常用的排序算法——归并排序也很快，而且使用了递归。我们接下来会介绍它。
- en: 'Merge Sort: Merging Small Piles of Playing Cards into Larger Sorted Piles'
  id: totrans-775
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归并排序：将小堆纸牌合并成更大的排序好的堆
- en: 'Computer scientist John von Neumann developed *merge sort* in 1945\. It uses
    a divide-merge approach: each recursive call to `mergeSort()` divides the unsorted
    list into halves until they’ve been whittled down into lists of lengths of zero
    or one. Then, as the recursive calls return, these smaller lists are merged together
    into sorted order. When the last recursive call has returned, the entire list
    will have been sorted.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家约翰·冯·诺伊曼于1945年开发了*归并排序*。它采用了分割-合并的方法：每次对`mergeSort()`的递归调用都将未排序的列表分成两半，直到它们被分割成长度为零或一的列表。然后，随着递归调用的返回，这些较小的列表被合并成排序好的顺序。当最后一个递归调用返回时，整个列表将被排序。
- en: For example, the divide step takes a list, such as `[2, 9, 8, 5, 3, 4, 7, 6]`,
    and splits it into two lists, like `[2, 9, 8, 5]` and `[3, 4, 7, 6]`, to pass
    to two recursive function calls. At the base case, the lists have been divided
    into lists of zero or one item. A list with nothing or one item is naturally sorted.
    After the recursive calls return, the code merges these small, sorted lists together
    into larger sorted lists until finally the entire list is sorted. [Figure 5-3](#figure5-3)
    shows an example using merge sort on playing cards.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，分割步骤将列表`[2, 9, 8, 5, 3, 4, 7, 6]`分成两个列表，如`[2, 9, 8, 5]`和`[3, 4, 7, 6]`，然后传递给两个递归函数调用。在基本情况下，列表已经被分成了零个或一个项目的列表。没有项目或一个项目的列表自然是排序好的。递归调用返回后，代码将这些小的排序好的列表合并成更大的排序好的列表，直到最终整个列表被排序。[图5-3](#figure5-3)展示了使用归并排序对纸牌进行排序的示例。
- en: '![Diagram of playing cards being arranged according to a series of steps. The
    first set of steps divides the playing cards into smaller groups, and the second
    set of steps merges these groups until the cards are all together once more.](image_fi/502024c05/f05003.png)'
  id: totrans-778
  prefs: []
  type: TYPE_IMG
  zh: '![按照一系列步骤排列纸牌的图表。第一组步骤将纸牌分成较小的组，第二组步骤将这些组合并，直到纸牌再次全部在一起。](image_fi/502024c05/f05003.png)'
- en: 'Figure 5-3: The divide and merge phases of merge sort'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-3：归并排序的分割和合并阶段
- en: 'For example, at the end of the division phase, we have eight separate lists
    of single numbers: `[2]`, `[9]`, `[8]`, `[5]`, `[3]`, `[4]`, `[7]`, `[6]`. A list
    of just one number is naturally in sorted order. Merging two sorted lists into
    a larger sorted list involves looking at the start of both smaller lists and appending
    the smaller value to the larger list. [Figure 5-4](#figure5-4) shows an example
    of merging `[2, 9]` and `[5, 8]`. This is repeatedly done in the merge phase until
    the end result is that the original `mergeSort()` call returns the full list in
    sorted order.'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在分割阶段结束时，我们有八个单独的数字列表：`[2]`, `[9]`, `[8]`, `[5]`, `[3]`, `[4]`, `[7]`, `[6]`。只有一个数字的列表自然是按顺序排列的。将两个排序好的列表合并成一个更大的排序好的列表涉及查看两个较小列表的开头，并将较小的值附加到较大的列表上。[图5-4](#figure5-4)显示了合并`[2,
    9]`和`[5, 8]`的示例。在合并阶段中重复执行此操作，直到最终结果是原始的`mergeSort()`调用以排序顺序返回完整列表。
- en: '![Diagram representing a series of steps applied to two pairs of playing cards,
    the 2 and 9 of spades and the 5 and 8 of spades. In the first step, because 2
    is smaller than 5, the 2 of spades is selected. In the second step, because 5
    is smaller than 9, the 5 of spades is placed on top of the 2 of spades. In the
    third step, because 8 is smaller than 9, the 8 of spades is placed on top of the
    5 of spades. In the fourth step, the 9 of spades is placed on top of the 8 of
    spades.](image_fi/502024c05/f05004.png)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
  zh: '![代表对两对纸牌（黑桃2和9，黑桃5和8）应用一系列步骤的图表。在第一步中，因为2小于5，所以选择黑桃2。在第二步中，因为5小于9，所以将黑桃5放在黑桃2的上面。在第三步中，因为8小于9，所以将黑桃8放在黑桃5的上面。在第四步中，将黑桃9放在黑桃8的上面。](image_fi/502024c05/f05004.png)'
- en: 'Figure 5-4: The merge step compares the two values at the start of the smaller
    sorted lists and moves them to the larger sorted list. Merging four cards requires
    only four steps.'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-4：合并步骤比较较小排序列表开头的两个值，并将它们移动到较大的排序列表中。合并四张卡只需要四个步骤。
- en: 'Let’s ask our three recursive algorithm questions about the merge sort algorithm:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们问一下我们的三个递归算法问题关于归并排序算法：
- en: What is the base case? Being given a list to sort that has zero or one item
    in it, which is already in sorted order.
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？ 给定一个要排序的列表，其中有零个或一个项目，已经按排序顺序排列。
- en: What argument is passed to the recursive function call? Lists made from the
    left and right halves of the original list to sort.
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？ 由原始列表的左半部分和右半部分制成的列表。
- en: How does this argument become closer to the base case? The lists passed to the
    recursive call are half the size of the original list, so they eventually become
    a list of zero or one item.
  id: totrans-786
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何接近基本情况？ 传递给递归调用的列表的大小是原始列表的一半，因此最终成为零个或一个项目的列表。
- en: 'The following `mergeSort()` function in the *mergeSort.py* Python program sorts
    the values in the items list into ascending order:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '*mergeSort.py* Python程序中的以下`mergeSort()`函数将项目列表中的值按升序排序：'
- en: '[PRE104]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The *mergeSort.html* program contains the equivalent JavaScript program:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '*mergeSort.html*程序包含等效的JavaScript程序：'
- en: '[PRE105]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The `mergeSort()` function (and all the recursive calls to the `mergeSort()`
    function) takes an unsorted list and returns a sorted list. The first step in
    this function is to check for the base case of a list containing only zero or
    one item ❶. This list is already sorted, so the function returns the list as is.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '`mergeSort()`函数（以及对`mergeSort()`函数的所有递归调用）接受一个未排序的列表并返回一个排序的列表。该函数的第一步是检查列表是否只包含零个或一个项目❶。这个列表已经排序，所以函数原样返回列表。'
- en: Otherwise, the function determines the middle index of the list ❷ so that we
    know where to split it into the left- and right-half lists to pass to two recursive
    function calls ❸. The recursive function calls return sorted lists, which we store
    in the left and right variables.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，函数确定列表的中间索引❷，以便我们知道在哪里将其分成左半部分和右半部分列表，然后传递给两个递归函数调用❸。递归函数调用返回排序的列表，我们将其存储在左侧和右侧变量中。
- en: The next step is to merge these two sorted half lists into one sorted full list
    named `sortedResult`. We’ll maintain two indices for the `left` and `right` lists
    named `iLeft` and `iRight`. Inside a loop, the smaller of the two values ❹ is
    appended to `sortedResult`, and its respective index variable (either `iLeft`
    or `iRight`) is incremented. If either `iLeft` or `iRight` reaches the end of
    its list, the remaining items in the other half’s list are appended to `sortedResult`.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将这两个排序好的半列表合并成一个排序好的完整列表，命名为`sortedResult`。我们将为`left`和`right`列表维护两个索引，命名为`iLeft`和`iRight`。在循环内，将两个值中较小的一个❹附加到`sortedResult`，并递增其相应的索引变量（`iLeft`或`iRight`）。如果`iLeft`或`iRight`达到其列表的末尾，则将另一半列表中剩余的项目附加到`sortedResult`。
- en: Let’s follow an example of the merging step if the recursive calls have returned
    `[2, 9]` for `left` and `[5, 8]` for `right`. Since these lists were returned
    from `mergeSort()` calls, we can always assume they are sorted. We must merge
    them into a single sorted list in `sortedResult` for the current `mergeSort()`
    call to return to its caller.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟随一个合并步骤的示例，如果递归调用已经返回了`[2, 9]`作为`left`和`[5, 8]`作为`right`。由于这些列表是从`mergeSort()`调用返回的，我们总是可以假设它们是排序好的。我们必须将它们合并成一个单独的排序好的列表，以便当前的`mergeSort()`调用将其返回给其调用者。
- en: 'The `iLeft` and `iRight` indices begin at `0`. We compare the value at `left[iLeft]`
    (which is `2`) and `right[iRight]` (which is `5`) to find the smaller one:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '`iLeft`和`iRight`索引从`0`开始。我们比较`left[iLeft]`（为`2`）和`right[iRight]`（为`5`）的值，以找到较小的值：'
- en: '[PRE106]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Since `left[iLeft]`’s value, `2`, is the smaller of the values, we append it
    to `sortedResult` and increase `iLeft` from `0` to `1`. The state of the variables
    is now as follows:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`left[iLeft]`的值`2`是较小的值，我们将其附加到`sortedResult`并将`iLeft`从`0`增加到`1`。 变量的状态现在如下：
- en: '[PRE107]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Comparing `left[iLeft]` and `right[iRight]` again, we find that of `9` and
    `5`, `right[iRight]`’s `5` is smaller. The code appends the `5` to `sortedResult`
    and increases `iRight` from `0` to `1`. The state of the variables is now the
    following:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 再次比较`left[iLeft]`和`right[iRight]`，我们发现`9`和`5`中，`right[iRight]`的`5`更小。 代码将`5`附加到`sortedResult`并将`iRight`从`0`增加到`1`。
    变量的状态现在如下：
- en: '[PRE108]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Comparing `left[iLeft]` and `right[iRight]` again, we find that, of `9` and
    `8`, `right[iRight]`’s `8` is smaller. The code appends the `8` to `sortedResult`
    and increases `iRight` from `0` to `1`. Here’s the state of the variables now:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 再次比较`left[iLeft]`和`right[iRight]`，我们发现`9`和`8`中，`right[iRight]`的`8`更小。 代码将`8`附加到`sortedResult`并将`iRight`从`0`增加到`1`。
    现在变量的状态如下：
- en: '[PRE109]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Because `iRight` is now `2` and equal to the length of the `right` list, the
    remaining items in `left` from the `iLeft` index to the end are appended to `sortedResult`,
    as no more items remain in `right` to compare them to. This leaves `sortedResult`
    as `[2, 5, 8, 9]`, the sorted list it needs to return. This merging step is performed
    for every call to `mergeSort()` to produce the final sorted list.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`iRight`现在是`2`，等于`right`列表的长度，所以从`iLeft`索引到末尾的`left`中剩余的项目被附加到`sortedResult`，因为`right`中没有更多的项目可以与它们进行比较。这使得`sortedResult`成为`[2,
    5, 8, 9]`，它需要返回的排序列表。这个合并步骤对每次`mergeSort()`调用都执行，以产生最终排序的列表。
- en: 'When we run the *mergeSort.py* and *mergeSort.html* programs, the output shows
    the process of sorting the `[2, 9, 8, 5, 3, 4, 7, 6]` list:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行*mergeSort.py*和*mergeSort.html*程序时，输出显示了对`[2, 9, 8, 5, 3, 4, 7, 6]`列表进行排序的过程。
- en: '[PRE110]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: As you can see from the output, the function divides the `[2, 9, 8, 5, 3, 4,
    7, 6]` list into `[2, 9, 8, 5]` and `[3, 4, 7, 6]` and passes these to recursive
    `mergeSort()` calls. The first list is further split into `[2, 9]` and `[8, 5]`.
    That `[2, 9]` list is split into `[2]` and `[9]`. These single-value lists cannot
    be divided anymore, so we have reached our base case. These lists are merged back
    into sorted order as `[2, 9]`. The function divides the `[8, 5]` list into `[8]`
    and `[5]`, reaches the base case, and then merges back into `[5, 8]`.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，该函数将`[2, 9, 8, 5, 3, 4, 7, 6]`列表分成`[2, 9, 8, 5]`和`[3, 4, 7, 6]`，并将它们传递给递归的`mergeSort()`调用。第一个列表进一步分成`[2,
    9]`和`[8, 5]`。`[2, 9]`列表分成`[2]`和`[9]`。这些单值列表不能再分割，所以我们已经达到了基本情况。这些列表合并成排序后的顺序为`[2,
    9]`。函数将`[8, 5]`列表分成`[8]`和`[5]`，达到基本情况，然后合并成`[5, 8]`。
- en: The `[2, 9]` and `[5, 8]` lists are individually in sorted order. Remember,
    `mergeSort()` doesn’t simply *concatenate* the lists into `[2, 9, 5, 8]`, which
    would not be in sorted order. Rather, the function *merges* them into the sorted
    list `[2, 5, 8, 9]`. By the time the original `mergeSort()` call returns, the
    full list it returns is completely sorted.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '`[2, 9]`和`[5, 8]`列表分别按顺序排序。记住，`mergeSort()`不只是将列表简单地*连接*成`[2, 9, 5, 8]`，这样不会按顺序排序。相反，该函数将它们*合并*成排序后的列表`[2,
    5, 8, 9]`。当原始的`mergeSort()`调用返回时，返回的完整列表已完全排序。'
- en: Summing an Array of Integers
  id: totrans-808
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对整数数组求和
- en: We already covered summing an array of integers in Chapter 3 with the head-tail
    technique. In this chapter, we’ll use a divide-and-conquer strategy. Since the
    associative property of addition means that adding 1 + 2 + 3 + 4 is the same as
    adding the sums of 1 + 2 and 3 + 4, we can divide a large array of numbers to
    sum into two smaller arrays of numbers to sum.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第3章中使用头尾技术对整数数组求和进行了讨论。在本章中，我们将使用分治策略。由于加法的结合律意味着将1 + 2 + 3 + 4相加与将1 +
    2和3 + 4的和相加是相同的，我们可以将要求和的大数组分成两个要求和的小数组。
- en: The benefit is that for larger sets of data to process, we could farm out the
    subproblems to different computers and have them all work together in parallel.
    There’s no need to wait for the first half of the array to be summed before another
    computer can start summing the second half. This is a large advantage of the divide-and-conquer
    technique, as CPUs aren’t getting much faster but we can have multiple CPUs work
    simultaneously.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于，对于更大的数据集，我们可以将子问题分配给不同的计算机，并让它们并行工作。无需等待数组的前半部分被求和，另一台计算机就可以开始对后半部分进行求和。这是分治技术的一个很大的优势，因为
    CPU 的速度并没有提高多少，但我们可以让多个 CPU 同时工作。
- en: 'Let’s ask the three questions about recursive algorithms for our summation
    function:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对求和函数的递归算法提出三个问题：
- en: What is the base case? Either an array containing zero numbers (where we return
    `0`) or an array containing one number (where we return the number).
  id: totrans-812
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本情况是什么？要么是包含零个数字的数组（返回`0`），要么是包含一个数字的数组（返回该数字）。
- en: What argument is passed to the recursive function call? Either the left half
    or the right half of the array of numbers.
  id: totrans-813
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？要么是数字数组的左半部分，要么是右半部分。
- en: How does this argument become closer to the base case? The size of the array
    of numbers is halved each time, eventually becoming an array containing zero or
    one number.
  id: totrans-814
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何变得更接近基本情况？每次数组的大小减半，最终变成一个包含零个或一个数字的数组。
- en: 'The *sumDivConq.py* Python program implements the divide-and-conquer strategy
    for adding numbers in the `sumDivConq()` function:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '*sumDivConq.py* Python程序实现了`sumDivConq()`函数中的分治策略，用于对数字进行求和。'
- en: '**Python**'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE111]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The *sumDivConq.html* program contains the JavaScript equivalent:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '*sumDivConq.html*程序包含了JavaScript的等效内容。'
- en: '**JavaScript**'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE112]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The output of this program is:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出是：
- en: '[PRE113]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The `sumDivConq()` function first checks the `numbers` array for having either
    zero or one number in it. These trivial base cases are easy to sum since they
    require no addition: return either `0` ❶ or the lone number in the array ❷. Everything
    else is a recursive case; the middle index of the array is calculated ❸ so that
    separate recursive calls with the left half and right half of the numbers array
    are made. The sum of these two return values becomes the return value for the
    current `sumDivConq()` call ❹.'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumDivConq()`函数首先检查`numbers`数组是否包含零个或一个数字。这些微不足道的基本情况很容易求和，因为它们不需要进行加法：返回`0`或数组中的单个数字。其他情况是递归的；计算数组的中间索引，以便对数字数组的左半部分和右半部分进行单独的递归调用。这两个返回值的和成为当前`sumDivConq()`调用的返回值。'
- en: Because of the associative nature of addition, there’s no reason an array of
    numbers must be added sequentially by a single computer. Our program carries out
    all operations on the same computer, but for large arrays or calculations more
    complicated than addition, our program could send the halves to other computers
    to complete. The problem can be divided into similar subproblems, which is a huge
    hint that a recursive approach can be taken.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加法的结合性质，没有理由要求一个数字数组必须由单个计算机按顺序相加。我们的程序在同一台计算机上执行所有操作，但对于大数组或比加法更复杂的计算，我们的程序可以将一半数据发送到其他计算机上进行处理。这个问题可以分解成类似的子问题，这是一个递归方法可以被采用的重要提示。
- en: Karatsuba Multiplication
  id: totrans-825
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Karatsuba乘法
- en: 'The `*` operator makes multiplication easy to do in high-level programming
    languages such as Python and JavaScript. But low-level hardware needs a way to
    perform multiplication using more primitive operations. We could multiply two
    integers using only addition with a loop, such as in the following Python code
    to multiply `5678 * 1234`:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`运算符使得在高级编程语言（如Python和JavaScript）中进行乘法变得容易。但是低级硬件需要一种使用更原始操作进行乘法的方法。我们可以使用循环仅使用加法来相乘两个整数，比如下面的Python代码来相乘`5678
    * 1234`：'
- en: '[PRE114]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: However, this code doesn’t scale efficiently for large integers. *Karatsuba
    multiplication* is a fast, recursive algorithm discovered in 1960 by Anatoly Karatsuba
    that can multiply integers using addition, subtraction, and a precomputed multiplication
    table of all products from single-digit numbers. This multiplication table, shown
    in [Figure 5-5](#figure5-5), is called a *lookup table*.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码对大整数的扩展效率并不高。*Karatsuba乘法*是一种快速的递归算法，由Anatoly Karatsuba于1960年发现，可以使用加法、减法和预先计算的所有单个数字乘积的乘法表来相乘整数。这个乘法表，如[图5-5](#figure5-5)所示，被称为*查找表*。
- en: Our algorithm won’t need to multiply single-digit numbers because it can just
    look them up in the table. By using memory to store precomputed values, we increase
    memory usage to decrease CPU runtime.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的算法不需要相乘单个数字，因为它可以直接在表中查找。通过使用内存存储预先计算的值，我们增加了内存使用量以减少CPU运行时间。
- en: '![A multiplication table of the digits 0 through 9.](image_fi/502024c05/F05005.png)'
  id: totrans-830
  prefs: []
  type: TYPE_IMG
  zh: '![数字0到9的乘法表。](image_fi/502024c05/F05005.png)'
- en: 'Figure 5-5: A lookup table, such as this table of products of all single-digit
    numbers, saves our program from repeat calculations as the computer stores the
    precomputed values in memory for later retrieval.'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-5：查找表，比如这个包含所有单个数字乘积的表，可以使我们的程序避免重复计算，因为计算机将预先计算的值存储在内存中以供以后检索。
- en: We’ll implement Karatsuba multiplication in a high-level language like Python
    or JavaScript as though the `*` operator didn’t already exist. Our `karatsuba()`
    function accepts two integer arguments, `x` and `y`, to multiply. The Karatsuba
    algorithm has five steps, and the first three involve making recursive calls to
    `karatsuba()` with arguments that are smaller, broken-down integers derived from
    `x` and `y`. The base case occurs when the `x` and `y` arguments are both single-digit
    numbers, in which case the product can be found in the precomputed lookup table.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在高级语言（如Python或JavaScript）中实现Karatsuba乘法，就好像`*`运算符并不存在一样。我们的`karatsuba()`函数接受两个整数参数`x`和`y`进行相乘。Karatsuba算法有五个步骤，前三个步骤涉及对从`x`和`y`派生的较小的、分解的整数进行递归调用`karatsuba()`。基本情况发生在`x`和`y`参数都是单个数字时，此时可以在预先计算的查找表中找到乘积。
- en: 'We also define four more variables: `a` and `b` are each half of the digits
    of `x`, and `c` and `d` are each half of the digits of `y`, as shown in [Figure
    5-6](#figure5-6). For example, if `x` and `y` are `5678` and `1234`, respectively,
    then `a` is `56`, `b` is `78`, `c` is `12`, and `d` is `34`.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了四个变量：`a`和`b`分别是`x`的数字的一半，`c`和`d`分别是`y`的数字的一半，如[图5-6](#figure5-6)所示。例如，如果`x`和`y`分别是`5678`和`1234`，那么`a`是`56`，`b`是`78`，`c`是`12`，`d`是`34`。
- en: '![Diagram showing x = 5678, with arrows leading to a = 56 and b = 78, and y
    = 1234, with arrows leading to c = 12 and d = 34.](image_fi/502024c05/F05006.png)'
  id: totrans-834
  prefs: []
  type: TYPE_IMG
  zh: '![图示x = 5678，箭头指向a = 56和b = 78，以及y = 1234，箭头指向c = 12和d = 34。](image_fi/502024c05/F05006.png)'
- en: 'Figure 5-6: The integers to multiply, `x` and `y`, are divided into halves
    `a`, `b`, `c`, and `d`.'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-6：要相乘的整数`x`和`y`被分成一半`a`、`b`、`c`和`d`。
- en: 'Here are the five steps of the Karatsuba algorithm:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Karatsuba算法的五个步骤：
- en: Multiply `a` and `c` either from the multiplication lookup table or from a recursive
    call to `karatsuba()`.
  id: totrans-837
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`a`和`c`相乘，可以从乘法查找表中查找，也可以通过对`karatsuba()`进行递归调用来实现。
- en: Multiply `b` and `d` either from the multiplication lookup table or from a recursive
    call to `karatsuba()`.
  id: totrans-838
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`b`和`d`相乘，可以从乘法查找表中查找，也可以通过对`karatsuba()`进行递归调用来实现。
- en: Multiply `a + c` and `b + d` either from the multiplication lookup table or
    from a recursive call to `karatsuba()`.
  id: totrans-839
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`a + c`和`b + d`相乘，可以从乘法查找表中查找，也可以通过对`karatsuba()`进行递归调用来实现。
- en: Calculate step 3 – step 2 – step 1.
  id: totrans-840
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算第3步 - 第2步 - 第1步。
- en: Pad the step 1 and step 4 results with zeros; then add them to step 2.
  id: totrans-841
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用零填充第1步和第4步的结果，然后将它们加到第2步。
- en: The result of step 5 is the product of `x` and `y`. The specifics of how to
    pad the step 1 and step 4 results with zeros are explained later in this section.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 第5步的结果是`x`和`y`的乘积。如何用零填充第1步和第4步的结果的具体方法将在本节后面解释。
- en: 'Let’s ask our three recursive algorithm questions about the `karatsuba()` function:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向`karatsuba()`函数提出三个递归算法的问题：
- en: What is the base case? Multiplying single-digit numbers, which can be done with
    a precomputed lookup table.
  id: totrans-844
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本情况是什么？相乘单个数字，可以在预先计算的查找表中找到。
- en: What argument is passed to the recursive function call? The `a`, `b`, `c`, and
    `d` values derived from the `x` and `y` arguments.
  id: totrans-845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？从`x`和`y`参数派生的`a`、`b`、`c`和`d`的值。
- en: How does this argument become closer to the base case? Since `a`, `b`, `c`,
    and `d` are each half of the digits of `x` and `y` and themselves are used for
    the next recursive call’s `x` and `y` arguments, the recursive call’s arguments
    become closer and closer to the single-digit numbers the base case requires.
  id: totrans-846
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数是如何变得更接近基本情况的呢？因为`a`、`b`、`c`和`d`分别是`x`和`y`的一半，并且它们自己被用作下一个递归调用的`x`和`y`参数，递归调用的参数变得越来越接近基本情况所需的单个数字。
- en: 'Our Python implementation for Karatsuba multiplication is in the *karatsubaMultiplication.py*
    program:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Python实现Karatsuba乘法在*karatsubaMultiplication.py*程序中：
- en: '[PRE115]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The JavaScript equivalent is in *karatsubaMultiplication.html*:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的等价代码在*karatsubaMultiplication.html*中。
- en: '[PRE116]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'When you run this code, the output looks like this:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，输出如下：
- en: '[PRE117]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The first part of this program happens before `karatsuba()` is called. Our program
    needs to create the multiplication lookup table in the `MULT_TABLE` variable ❶.
    Normally, lookup tables are hardcoded directly in the source code, from `MULT_TABLE[[0,
    0]] = 0` to `MULT_TABLE[[9, 9]] = 81`. But to reduce the amount of typing, we’ll
    use nested `for` loops to generate each product. Accessing `MULT_TABLE[[m, n]]`
    gives us the product of integers `m` and `n`.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的第一部分发生在调用`karatsuba()`之前。我们的程序需要在`MULT_TABLE`变量中创建乘法查找表。通常，查找表是直接硬编码在源代码中的，从`MULT_TABLE[[0,
    0]] = 0`到`MULT_TABLE[[9, 9]] = 81`。但为了减少输入量，我们将使用嵌套的`for`循环来生成每个乘积。访问`MULT_TABLE[[m,
    n]]`会给我们整数`m`和`n`的乘积。
- en: Our `karatsuba()` function also relies on a helper function named `padZeros()`,
    which pads a string of digits with additional zeros on the left or right side
    of the string. This padding is done in the fifth step of the Karatsuba algorithm.
    For example, `padZeros("42", 3, "left")` returns the string `00042`, while `padZeros("99",
    1, "right")` returns the string `990`.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`karatsuba()`函数还依赖于一个名为`padZeros()`的辅助函数，它在字符串的左侧或右侧填充额外的零。这种填充是在Karatsuba算法的第五步中完成的。例如，`padZeros("42",
    3, "left")`返回字符串`00042`，而`padZeros("99", 1, "right")`返回字符串`990`。
- en: The `karatsuba()` function itself first checks for the base case, where `x`
    and `y` are single-digit numbers. These can be multiplied using the lookup table,
    and their product is immediately returned. Everything else is a recursive case.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '`karatsuba()`函数本身首先检查基本情况，即`x`和`y`是单个数字。这些可以使用查找表相乘，并且它们的乘积会立即返回。其他情况都是递归情况。'
- en: We need to convert the `x` and `y` integers into strings and adjust them so
    that they contain the same number of digits. If one of these numbers is shorter
    than the other, zeros are padded to the left side. For example, if `x` is `13`
    and `y` is `2468`, our function calls `padZeros()` so that `x` can be replaced
    with `0013`. This is required because we then create the `a`, `b`, `c`, and `d`
    variables to each contain one-half of the digits of `x` and `y` ❷. The `a` and
    `c` variables must have the same number of digits for the Karatsuba algorithm
    to work, as do the `b` and `d` variables.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将`x`和`y`整数转换为字符串，并调整它们，使它们包含相同数量的数字。如果其中一个数字比另一个短，就会在左侧填充0。例如，如果`x`是`13`，`y`是`2468`，我们的函数调用`padZeros()`，这样`x`就可以被替换为`0013`。这是因为我们随后创建`a`、`b`、`c`和`d`变量，每个变量包含`x`和`y`的一半数字。`a`和`c`变量必须具有相同数量的数字，以使Karatsuba算法起作用，`b`和`d`变量也是如此。
- en: 'Note that we use division and rounding down to calculate how much is half of
    the digits of `x` ❸. These mathematical operations are as complicated as multiplication
    and might not be available to the low-level hardware we are programming the Karatsuba
    algorithm for. In a real implementation, we could use another lookup table for
    these values: `HALF_TABLE = [0, 0, 1, 1, 2, 2, 3, 3...]`, and so on. Looking up
    `HALF_TABLE[n]` would evaluate to half of `n`, rounded down. An array of a mere
    100 items would be sufficient for all but the most astronomical numbers and save
    our program from division and rounding. But our programs are for demonstration,
    so we’ll just use the `/` operator and built-in rounding functions.'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用除法和向下取整来计算`x`的数字的一半是多少。这些数学运算和乘法一样复杂，可能在我们为Karatsuba算法编程的低级硬件上不可用。在实际实现中，我们可以使用另一个查找表来存储这些值：`HALF_TABLE
    = [0, 0, 1, 1, 2, 2, 3, 3...]`，以此类推。查找`HALF_TABLE[n]`将得到`n`的一半，向下取整。一个仅有100个项目的数组就足以满足大多数情况，可以避免我们的程序进行除法和取整。但我们的程序是用来演示的，所以我们将使用`/`运算符和内置的取整函数。
- en: Once these variables are set up correctly, we can begin making the recursive
    function calls ❹. The first three steps involve recursive calls with arguments
    `a` and `b`, `c` and `d`, and finally `a + b` and `c + d`. The fourth step subtracts
    the results of the first three steps from each other ❺. The fifth step pads the
    results of the first and fourth steps with zeros on the right side, then adds
    them to the results of the second step ❻.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些变量被正确设置，我们就可以开始进行递归函数调用。前三个步骤涉及使用参数`a`和`b`、`c`和`d`，最后是`a + b`和`c + d`进行递归调用。第四步是将前三步的结果相互相减。第五步是将第一步和第四步的结果右侧填充0，然后加上第二步的结果。
- en: The Algebra Behind the Karatsuba Algorithm
  id: totrans-859
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Karatsuba算法背后的代数
- en: These steps may seem like magic, so let’s dive into the algebra that shows why
    they work. Let’s use 1,357 for *x* and 2,468 for *y* as the integers we want to
    multiply. Let’s also consider a new variable, *n*, for the number of digits in
    *x* or *y*. Since *a* is 13 and *b* is 57, we can calculate the original *x* as
    10^(*n*)^(/2) × *a* + *b*, which is 10² × 13 + 57 or 1,300 + 57, or 1,357\. Similarly,
    *y* is the same as 10^(*n*)^(/2) × *c* + *d*.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤可能看起来像魔术，所以让我们深入代数，看看为什么它们有效。我们使用1,357作为*x*和2,468作为*y*，作为我们要相乘的整数。我们还考虑一个新变量*n*，表示*x*或*y*的数字位数。由于*a*是13，*b*是57，我们可以计算原始*x*为10^(*n*)^(/2)
    × *a* + *b*，即10² × 13 + 57或1,300 + 57，即1,357。同样，*y*也是10^(*n*)^(/2) × *c* + *d*。
- en: This means that the product of *x* × *y* = (10^(*n*)^(/2) × *a* + *b*) × (10^(*n*)^(/2)
    × *c* + *d*). Doing a bit of algebra, we can rewrite this equation as *x* × *y*
    = 10*n* × *ac* + 10^(*n*)^(/2) × (*ad* + *bc*) + *bd*. With our example numbers,
    this means 1,357 × 2,468 = 10,000 × (13 × 24) + 100 × (13 × 68 + 57 × 24) + (57
    × 68). Both sides of this equation evaluate to 3,349,076.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着*x* × *y*的乘积=（10^(*n*)^(/2) × *a* + *b*）×（10^(*n*)^(/2) × *c* + *d*）。通过一些代数运算，我们可以将这个方程重写为*x*
    × *y* = 10*n* × *ac* + 10^(*n*)^(/2) × (*ad* + *bc*) + *bd*。对于我们的示例数字，这意味着1,357
    × 2,468 = 10,000 × (13 × 24) + 100 × (13 × 68 + 57 × 24) + (57 × 68)。这个方程的两边都计算为3,349,076。
- en: 'We’ve broken the multiplication of *xy* into the multiplications of *ac*, *ad*,
    *bc*, and *bd*. This forms the basis of our recursive function: we’ve defined
    the multiplication of *x* and *y* by using multiplication of smaller numbers (remember,
    *a*, *b*, *c*, and *d* are half the digits of *x* or *y*) that approach the base
    case of multiplying single-digit numbers. And we can perform single-digit multiplication
    with a lookup table rather than multiplying.'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将*xy*的乘法分解为*ac*、*ad*、*bc*和*bd*的乘法。这构成了我们递归函数的基础：我们通过使用较小数字的乘法（记住，*a*、*b*、*c*和*d*是*x*或*y*的一半的数字）来定义*x*和*y*的乘法，这接近了将单个数字相乘的基本情况。我们可以使用查找表而不是乘法来执行单个数字的乘法。
- en: So we need to recursively compute *ac* (the first step of the Karatsuba algorithm)
    and *bd* (the second step). We also need to calculate (*a* + *b*)(*c* + *d*) for
    the third step, which we can rewrite as *ac* + *ad* + *bc* + *bd*. We already
    have *ac* and *bd* from the first two steps, so subtracting those gives us *ad*
    + *bc*. This means we need only one multiplication (and one recursive call) to
    calculate (*a* + *b*)(*c* + *d*) instead of two to calculate *ad* + *bc*. And
    *ad* + *bc* is needed for the 10*n*^(/2) × (*ad* + *bc*) part of our original
    equation.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要递归计算*ac*（Karatsuba算法的第一步）和*bd*（第二步）。我们还需要计算(*a* + *b*)(*c* + *d*)作为第三步，我们可以将其重写为*ac*
    + *ad* + *bc* + *bd*。我们已经从前两步得到了*ac*和*bd*，所以减去这些值给了我们*ad* + *bc*。这意味着我们只需要进行一次乘法（和一次递归调用）来计算(*a*
    + *b*)(*c* + *d*)，而不是计算*ad* + *bc*需要两次。而*ad* + *bc*是我们原始方程中10*n*^(/2) × (*ad*
    + *bc*)的一部分。
- en: 'Multiplying by the 10*n* and 10^(*n*)^(/2) powers of 10 can be done by padding
    zero digits: for example, 10,000 × 123 is 1,230,000\. So, there’s no need to make
    recursive calls for those multiplications. In the end, multiplying *x* × *y* can
    be broken into multiplying three smaller products with three recursive calls:
    `karatsuba(a, c)`, `karatsuba(b, d)`, and `karatsuba((a + b), (c + d))`.'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 通过填充零位数，可以通过10*n*和10^(*n*)^(/2)的幂来进行乘法：例如，10,000 × 123是1,230,000。因此，对于这些乘法，没有必要进行递归调用。最后，将*x*
    × *y*的乘法分解为三个较小乘积的乘法，需要进行三次递归调用：`karatsuba(a, c)`、`karatsuba(b, d)`和`karatsuba((a
    + b), (c + d))`。
- en: With some careful study of this section, you can understand the algebra behind
    the Karatsuba algorithm. What I can’t understand is how Anatoly Karatsuba was
    clever enough to devise this algorithm in less than a week as a 23-year-old student
    in the first place.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细研究本节，您可以理解Karatsuba算法背后的代数。我无法理解的是，23岁的学生Anatoly Karatsuba是如何在不到一周的时间里聪明地设计出这个算法的。
- en: Summary
  id: totrans-866
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Dividing problems into smaller, self-similar problems is at the heart of recursion,
    making these divide-and-conquer algorithms especially suited for recursive techniques.
    In this chapter, we created a divide-and-conquer version of Chapter 3’s program
    for summing numbers in an array. One benefit of this version is that upon dividing
    a problem into multiple subproblems, the subproblems can be farmed out to other
    computers to work on in parallel.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 将问题分解为更小的、自相似的问题是递归的核心，使得这些分而治之的算法特别适合递归技术。在本章中，我们为数组中数字求和的第3章程序创建了一个分而治之的版本。这个版本的一个好处是，在将问题分解为多个子问题时，可以将子问题分配给其他计算机并行处理。
- en: A binary search algorithm searches a sorted array by repeatedly narrowing the
    range to search in half. While a linear search starts searching at the beginning
    and searches the entire array, a binary search takes advantage of the array’s
    sorted order to home in on the item it is looking for. The performance improvement
    is so great that it may be worthwhile to sort an unsorted array in order to enable
    a binary search on its items.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索算法通过不断缩小搜索范围的方式在排序数组中搜索。线性搜索从开头开始搜索整个数组，而二分搜索利用数组的排序顺序来定位它正在寻找的项目。性能提升如此之大，以至于值得对未排序的数组进行排序，以便对其项目进行二分搜索。
- en: 'We covered two popular sorting algorithms in this chapter: quicksort and merge
    sort. Quicksort divides an array into two partitions based on a pivot value. The
    algorithm then recursively partitions these two partitions, repeating the process
    until the partitions are the size of a single item. At this point, the partitions,
    and the items in them, are in sorted order. Merge sort takes an opposite approach.
    The algorithm splits the array into smaller arrays first, and then merges the
    smaller arrays into sorted order afterward.'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了两种流行的排序算法：快速排序和归并排序。快速排序根据一个枢轴值将数组分成两个分区。然后算法递归地对这两个分区进行分割，重复这个过程，直到分区的大小为一个单独的项目。在这一点上，分区和其中的项目都是按排序顺序排列的。归并排序采取相反的方法。算法首先将数组分成较小的数组，然后将这些较小的数组合并成排序顺序。
- en: Finally, we covered Karatsuba multiplication, a recursive algorithm for performing
    integer multiplication when the `*` multiplication operator isn’t available. This
    comes up in low-level hardware programming that doesn’t offer a built-in multiplication
    instruction. The Karatsuba algorithm breaks down multiplying two integers into
    three multiplications of smaller integers. To multiply single-digit numbers for
    the base case, the algorithm stores every product from 0 × 0 to 9 × 9 in a lookup
    table.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了Karatsuba乘法，这是一种递归算法，用于执行整数乘法，当`*`乘法运算符不可用时。这在低级硬件编程中会出现，因为它没有内置的乘法指令。Karatsuba算法将两个整数相乘分解为三个较小整数的乘法。为了基本情况下的单个数字相乘，该算法在查找表中存储了从0
    × 0到9 × 9的每个乘积。
- en: The algorithms in this chapter are part of many data structure and algorithm
    courses that freshman computer science students take. In the next chapter, we’ll
    continue to look at other algorithms at the heart of computing with algorithms
    that calculate permutations and combinations.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的算法是大一计算机科学学生学习的许多数据结构和算法课程的一部分。在下一章中，我们将继续研究计算的核心算法，包括计算排列和组合的算法。
- en: Further Reading
  id: totrans-872
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The Computerphile channel on YouTube has videos on quicksort at [https://youtu.be/XE4VP_8Y0BU](https://youtu.be/XE4VP_8Y0BU)
    and merge sort at [https://youtu.be/kgBjXUE_Nwc](https://youtu.be/kgBjXUE_Nwc).
    If you want a more comprehensive tutorial, the free “Algorithmic Toolbox” online
    course covers many of the same topics that a freshman data structures and algorithms
    course would cover, including binary search, quicksort, and merge sort. You can
    sign up for this Coursera course at [https://www.coursera.org/learn/algorithmic-toolbox](https://www.coursera.org/learn/algorithmic-toolbox).
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: YouTube的Computerphile频道有关于快速排序的视频，网址为[https://youtu.be/XE4VP_8Y0BU](https://youtu.be/XE4VP_8Y0BU)，以及关于归并排序的视频，网址为[https://youtu.be/kgBjXUE_Nwc](https://youtu.be/kgBjXUE_Nwc)。如果你想要更全面的教程，免费的“Algorithmic
    Toolbox”在线课程涵盖了许多大一数据结构和算法课程会涵盖的相同主题，包括二分搜索、快速排序和归并排序。你可以在[https://www.coursera.org/learn/algorithmic-toolbox](https://www.coursera.org/learn/algorithmic-toolbox)上报名参加这门Coursera课程。
- en: Sorting algorithms are often compared to each other in lessons on big O algorithm
    analysis, which you can read about in Chapter 13 of my book *Beyond the Basic
    Stuff with Python* (No Starch Press, 2020). You can read this chapter online at
    [https://inventwithpython.com/beyond](https://inventwithpython.com/beyond). Python
    developer Ned Batchelder describes big O and “how code slows as your data grows”
    in his 2018 PyCon talk of the same name at [https://youtu.be/duvZ-2UK0fc](https://youtu.be/duvZ-2UK0fc).
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法经常在大O算法分析课程中相互比较，你可以在我的书*Beyond the Basic Stuff with Python*（No Starch Press,
    2020）的第13章中阅读有关此内容。你可以在[https://inventwithpython.com/beyond](https://inventwithpython.com/beyond)上在线阅读这一章。Python开发者Ned
    Batchelder在2018年的PyCon演讲中描述了大O和“随着数据增长，代码的减速”，演讲的名称也是这个名字，网址为[https://youtu.be/duvZ-2UK0fc](https://youtu.be/duvZ-2UK0fc)。
- en: Divide-and-conquer algorithms are useful because they often can be run on multiple
    computers in parallel. Guy Steele Jr. gives a Google TechTalk titled “Four Solutions
    to a Trivial Problem” on this topic at [https://youtu.be/ftcIcn8AmSY](https://youtu.be/ftcIcn8AmSY).
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 分治算法很有用，因为它们经常可以并行在多台计算机上运行。Guy Steele Jr.在Google TechTalk上发表了题为“Four Solutions
    to a Trivial Problem”的演讲，网址为[https://youtu.be/ftcIcn8AmSY](https://youtu.be/ftcIcn8AmSY)。
- en: Professor Tim Roughgarden produced a video lecture for Stanford University on
    Karatsuba multiplication at [https://youtu.be/JCbZayFr9RE](https://youtu.be/JCbZayFr9RE).
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: Tim Roughgarden教授为斯坦福大学制作了一段关于Karatsuba乘法的视频讲座，网址为[https://youtu.be/JCbZayFr9RE](https://youtu.be/JCbZayFr9RE)。
- en: To help your understanding of quicksort and merge sort, obtain a pack of playing
    cards or simply write numbers on index cards and practice sorting them by hand
    according to the rules of these two algorithms. This offline approach can help
    you remember the pivot-and-partition of quicksort and the divide-merge of merge
    sort.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解快速排序和归并排序，获取一副扑克牌或者简单地在索引卡上写上数字，并按照这两种算法的规则手动排序它们。这种离线方法可以帮助你记住快速排序的中轴和分区以及归并排序的分治。
- en: Practice Questions
  id: totrans-878
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习问题
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你的理解：
- en: What is a benefit of the divide-and-conquer summing algorithm in this chapter
    compared to the head-tail summing algorithm in Chapter 3?
  id: totrans-880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与第3章中的头尾求和算法相比，本章中的分治求和算法有什么好处？
- en: If a binary search of 50 books on a shelf takes six steps, how many steps would
    it take to search twice as many books?
  id: totrans-881
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在书架上搜索50本书的二分搜索需要六步，那么搜索两倍的书需要多少步？
- en: Can a binary search algorithm search an unsorted array?
  id: totrans-882
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二分搜索算法能搜索未排序的数组吗？
- en: Is partitioning the same thing as sorting?
  id: totrans-883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分区和排序是一样的吗？
- en: What happens in quicksort’s partition step?
  id: totrans-884
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速排序的分区步骤发生了什么？
- en: What is the pivot value in quicksort?
  id: totrans-885
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速排序中的中轴值是多少？
- en: What is the base case of quicksort?
  id: totrans-886
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速排序的基本情况是什么？
- en: How many recursive calls does the `quicksort()` function have?
  id: totrans-887
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`quicksort()`函数有多少递归调用？'
- en: How is the array `[0, 3, 1, 2, 5, 4, 7, 6]` not properly partitioned with a
    pivot value of `4`?
  id: totrans-888
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组`[0, 3, 1, 2, 5, 4, 7, 6]`在以`4`为中轴值时没有正确分区？
- en: What is the base case of merge sort?
  id: totrans-889
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 归并排序的基本情况是什么？
- en: How many recursive calls does the `mergeSort()` function have?
  id: totrans-890
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mergeSort()`函数有多少递归调用？'
- en: What is the resultant array when the merge sort algorithm sorts the arrays `[12,
    37, 38, 41, 99]` and `[2, 4, 14, 42]`?
  id: totrans-891
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当归并排序算法对数组`[12, 37, 38, 41, 99]`和`[2, 4, 14, 42]`进行排序时，结果数组是什么？
- en: What is a lookup table?
  id: totrans-892
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找表是什么？
- en: In the Karatsuba algorithm that multiplies integers *x* and *y*, what do the
    *a*, *b*, *c*, and *d* variables store?
  id: totrans-893
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在乘法整数*x*和*y*的Karatsuba算法中，变量*a*、*b*、*c*和*d*分别存储什么？
- en: 'Answer the three questions about recursive solutions for each of the recursive
    algorithms presented in this chapter:'
  id: totrans-894
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回答关于本章中每个递归算法的三个问题：
- en: What is the base case?
  id: totrans-895
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本情况是什么？
- en: What argument is passed to the recursive function call?
  id: totrans-896
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？
- en: How does this argument become closer to the base case?
  id: totrans-897
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何变得更接近基本情况？
- en: Then re-create the recursive algorithms from this chapter without looking at
    the original code.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新创建本章中的递归算法，而不看原始代码。
- en: Practice Projects
  id: totrans-899
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习项目
- en: 'For practice, write a function for each of the following tasks:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习，为以下每个任务编写一个函数：
- en: 'Create a version of the `karatsuba()` function that has a multiplication lookup
    table of products from 0 × 0 to 999 × 999 rather than 0 × 0 to 9 × 9\. Get a rough
    estimate of how long it takes to calculate `karatsuba(12345678, 87654321)` 10,000
    times in a loop with this larger lookup table compared to the original lookup
    table. If this still runs too quickly to measure, increase the number of iterations
    to 100,000 or 1,000,000 or more. (Hint: you should delete or comment out the `print()`
    and `document.write()` calls inside the `karatsuba()` function for this timing
    test.)'
  id: totrans-901
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有从0×0到999×999的乘法查找表的`karatsuba()`函数的版本，而不是从0×0到9×9。粗略估计使用这个更大的查找表在循环中计算`karatsuba(12345678,
    87654321)` 10,000次所需的时间，与原始查找表相比。如果这仍然运行得太快以至于无法测量，增加迭代次数到100,000或1,000,000或更多。（提示：您应该删除或注释掉`karatsuba()`函数内的`print()`和`document.write()`调用，以进行此定时测试。）
- en: Create a function that performs a linear search on a large array of integers
    10,000 times. Get a rough estimate of how long this takes, increasing the number
    of iterations to 100,000 or 1,000,000 if the program executes too quickly. Compare
    this with how long a second function takes to sort the array once before performing
    the same number of binary searches.
  id: totrans-902
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，在一个包含10,000个整数的大数组上执行线性搜索10,000次。粗略估计这需要多长时间，如果程序执行得太快，增加迭代次数到100,000或1,000,000。将此与第二个函数在执行相同数量的二进制搜索之前对数组进行排序所需的时间进行比较。
- en: '6'
  id: totrans-903
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Permutations and Combinations
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 排列和组合
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-905
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Problems involving permutations and combinations are especially suited to recursion.
    These are common in *set theory*, a branch of mathematical logic that deals with
    the selection, arrangement, and manipulation of collections of objects.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及排列和组合的问题特别适合递归。这在*集合论*中很常见，集合论是处理对象集合的选择、排列和操作的数学逻辑分支。
- en: Dealing with small sets in our short-term memory is simple. We can easily come
    up with every possible order (that is, *permutation*) or combination of a set
    of three or four objects. Ordering and combining items in a larger set requires
    the same process but quickly turns into an impossible task for our human brains.
    At that point, it becomes practical to bring in computers to handle the combinatorial
    explosion that occurs as we add more objects to a set.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 处理我们短期记忆中的小集合很简单。我们可以轻松地想出一组三个或四个对象的每种可能顺序（即*排列*）或组合。对更大集合中的项目进行排序和组合需要相同的过程，但很快就变成了我们人类大脑无法完成的任务。在那一点上，引入计算机来处理随着我们向集合中添加更多对象而发生的组合爆炸变得实际。
- en: At its heart, calculating permutations and combinations of large groups involves
    calculating permutations and combinations of smaller groups. This makes these
    calculations suitable for recursion. In this chapter, we’ll look at recursive
    algorithms for generating all possible permutations and combinations of characters
    in a string. We’ll expand on this to generate all possible combinations of balanced
    parentheses (orderings of open parentheses correctly matched to closing parentheses).
    And finally, we will calculate the power set of a set—that is, the set of all
    possible subsets of a set.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，计算大群体的排列和组合涉及计算较小群体的排列和组合。这使得这些计算适合递归。在本章中，我们将看看用于生成字符串中所有可能排列和组合的递归算法。我们将扩展到生成所有可能的平衡括号组合（正确匹配的开括号顺序与闭括号）。最后，我们将计算集合的幂集，即集合的所有可能子集的集合。
- en: Many of the recursive functions in this chapter have an argument named `indent`.
    This isn’t used by the actual recursive algorithms; rather, it is used by their
    debugging output so that you can see which level of recursion produced the output.
    The indentation is increased by one space for each recursive call and rendered
    in the debugging output as periods so that it’s easy to count the level of indentation.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多递归函数都有一个名为`indent`的参数。这并不是由实际的递归算法使用的；相反，它是由它们的调试输出使用的，以便您可以看到哪个递归级别产生了输出。每次递归调用时缩进增加一个空格，并在调试输出中呈现为句点，以便轻松计算缩进级别。
- en: The Terminology of Set Theory
  id: totrans-910
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合论术语
- en: 'This chapter doesn’t cover set theory as completely as a math or computer science
    textbook would. But it covers enough to justify starting with an explanation of
    the discipline’s basic terminology, as doing so will make the rest of this chapter
    easier to understand. A *set* is a collection of unique objects, called *elements*,
    or *members*. For example, the letters *A*, *B*, and *C* form a set of three letters.
    In mathematics (and in Python code syntax), sets are written inside curly braces,
    with the objects separated by commas: {A, B, C}.'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 本章并没有像数学或计算机科学教科书那样完全涵盖集合论。但它涵盖了足够的内容，以证明从解释该学科的基本术语开始是有道理的，因为这样做将使本章的其余部分更容易理解。*集合*是一组唯一对象，称为*元素*或*成员*。例如，字母*A*、*B*和*C*形成了一个三个字母的集合。在数学（以及Python代码语法）中，集合用大括号括起来，对象之间用逗号分隔：{A,
    B, C}。
- en: 'Order doesn’t matter for a set; the set {A, B, C} is the same set as {C, B,
    A}. Sets have distinct elements, meaning there are no duplicates: {A, C, A, B}
    has repeat *A*s and so is not a set.'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的顺序并不重要；集合{A，B，C}与集合{C，B，A}是相同的集合。集合具有不同的元素，这意味着没有重复：{A，C，A，B}有重复的*A*，因此不是一个集合。
- en: A set is a *subset* of another set if it has only members of the other set.
    For example, {A, C} and {B, C} are both subsets of {A, B, C}, but {A, C, D} is
    not a subset of it. Conversely, {A, B, C} is a *superset* to {A, C} and also to
    {B, C} because it contains all their elements. The *empty set* { } is a set that
    contains no members at all. Empty sets are considered subsets of every possible
    set.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个集合只包含另一个集合的成员，则称其为另一个集合的*子集*。例如，{A，C}和{B，C}都是{A，B，C}的子集，但{A，C，D}不是它的子集。相反，{A，B，C}是{A，C}和{B，C}的*超集*，因为它包含它们的所有元素。*空集*{}是一个不包含任何成员的集合。空集被认为是每个可能集合的子集。
- en: 'A subset can also include all the elements of the other set. For example, {A,
    B, C} is a subset of {A, B, C}. But a *proper subset*, or *strict subset*, is
    a subset that does not have all the set’s elements. No set is a proper subset
    of itself: so {A, B, C} is a subset but not a proper subset of {A, B, C}. All
    other subsets are proper subsets. [Figure 6-1](#figure6-1) shows a graphical representation
    of the set {A, B, C} and some of its subsets.'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 一个子集也可以包括另一个集合的所有元素。例如，{A，B，C}是{A，B，C}的一个子集。但是，*真子集*或*严格子集*是一个不包含所有集合元素的子集。没有集合是其自身的真子集：因此{A，B，C}是一个子集，但不是{A，B，C}的真子集。所有其他子集都是真子集。[图6-1](#figure6-1)显示了集合{A，B，C}及其一些子集的图形表示。
- en: '![Drawing of nested circles: an outer, dashed-line circle; a circle within
    the dashed circle, containing B; a circle within that circle, containing A and
    C; and a circle within that circle, containing no letters.](image_fi/502024c06/f06001.png)'
  id: totrans-915
  prefs: []
  type: TYPE_IMG
  zh: '![嵌套圆圈的图示：一个外部虚线圆圈；一个在虚线圆圈内部的圆圈，其中包含B；一个在该圆圈内部的圆圈，其中包含A和C；一个在该圆圈内部的圆圈，其中不包含任何字母。](image_fi/502024c06/f06001.png)'
- en: 'Figure 6-1: The set {A, B, C} within the dashed lines and some of its subsets
    {A, B, C}, {A, C}, and { } within the solid lines. The circles represent sets,
    and the letters represent elements.'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：集合{A，B，C}在虚线内以及其一些子集{A，B，C}，{A，C}和{ }在实线内的图形表示。圆圈代表集合，字母代表元素。
- en: 'A *permutation* of a set is a specific ordering of all elements in the set.
    For example, the set {A, B, C} has six permutations: ABC, ACB, BAC, BCA, CAB,
    and CBA. We call these *permutations* *without* *repetition*, or *permutations*
    *without *replacement*, because each element doesn’t appear in the permutation
    more than once.*'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集合的*排列*是集合中所有元素的特定顺序。例如，集合{A，B，C}有六个排列：ABC，ACB，BAC，BCA，CAB和CBA。我们称这些*排列*为*无重复*的*排列*，或者*无替换*的*排列*，因为每个元素在排列中不会出现超过一次。*
- en: '*A *combination* is a selection of elements of a set. More formally, a *k-combination*
    is a subset of *k* elements from a set. Unlike permutations, combinations don’t
    have an ordering. For example, the 2-combinations of the set {A, B, C} are {A,
    B}, {A, C}, and {B, C}. The 3-combination of the set {A, B, C} is {A, B, C}.'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个*组合*是一个集合的元素选择。更正式地说，*k-组合*是从一个集合中选择k个元素的子集。与排列不同，组合没有顺序。例如，集合{A，B，C}的2-组合是{A，B}，{A，C}和{B，C}。集合{A，B，C}的3-组合是{A，B，C}。'
- en: 'The term *n choose k* refers to the number of possible combinations (without
    repetition) of *k* elements that can be selected from a set of *n* elements. (Some
    mathematicians use the term *n choose r*.) This concept has nothing to do with
    the elements themselves, just the number of them. For example, 4 choose 2 is 6,
    because there are six ways to choose two elements from a set of four elements
    like {A, B, C, D}: {A, B}, {A, C}, {A, D}, {B, C}, {B, D}, and {C, D}. Meanwhile,
    3 choose 3 is 1, because there’s only one 3-combination from a set of three elements
    like {A, B, C}; that is, {A, B, C} itself. The formula for calculating *n* choose
    *k* is (*n!*) / (*k*! × (*n* – *k*)!). Recall that *n*! is the notation for factorials:
    5! is 5 × 4 × 3 × 2 × 1.'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: “n选k”一词指的是可以从n个元素的集合中选择k个元素的可能组合（不重复）。 （一些数学家使用“n选r”一词。）这个概念与元素本身无关，只与它们的数量有关。例如，4选2是6，因为有六种方法可以从四个元素的集合{A，B，C，D}中选择两个元素：{A，B}，{A，C}，{A，D}，{B，C}，{B，D}和{C，D}。同时，3选3是1，因为从三个元素的集合{A，B，C}中只有一种3个元素的组合，即{A，B，C}本身。计算n选k的公式是（n！）/（k！×（n-k）！）。回想一下，n！是阶乘的表示法：5！是5×4×3×2×1。
- en: The term *n multichoose k* refers to the number of possible combinations *with
    repetition* of *k* elements that can be selected from a set of *n* elements. Because
    *k*-combinations are sets and sets do not have duplicate elements, a *k*-combination
    does not have repetition. When we use *k*-combinations with duplicate elements,
    we specifically call them *k-combinations with repetition*.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*n multichoose k*指的是可以从n个元素的集合中选择k个元素的可能组合*带有重复*。因为k-组合是集合，而集合不包含重复元素，所以k-组合不会重复。当我们使用带有重复元素的k-组合时，我们特别称它们为*带重复的k-组合*。
- en: Keep in mind that, both with and without repetition, you can think of permutation
    as a certain arrangement of all elements in a set, while a combination is an orderless
    selection of certain elements from a set. Permutations have an ordering and use
    all the elements from a set, while combinations don’t have an ordering and use
    any number of elements from a set. To get a better idea of these terms, [Table
    6-1](#table6-1) shows the difference between permutations and combinations, with
    and without repetition, of the set {A, B, C}.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，无论有无重复，您都可以将排列视为集合中所有元素的特定排列，而组合是集合中某些元素的无序选择。排列有顺序并使用集合中的所有元素，而组合没有顺序并使用集合中的任意数量的元素。为了更好地了解这些术语，[表6-1](#table6-1)显示了集合{A，B，C}的排列和组合之间的区别，有无重复。
- en: 'Table 6-1: All Possible Permutations and Combinations, with and without Repetition,
    of the Set {A, B, C}'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1：集合{A，B，C}的所有可能排列和组合，有无重复。
- en: '|  | **Permutations** | **Combinations** |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
  zh: '| | **排列** | **组合** |'
- en: '| --- | --- | --- |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Without repetition** | ABC, ACB, BAC, BCA, CAB | (None), A, B, C, AB, AC,
    BC, ABC |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
  zh: '| **无重复** | ABC，ACB，BAC，BCA，CAB | （无），A，B，C，AB，AC，BC，ABC |'
- en: '| **With repetition** | AAA, AAB, AAC, ABA, ABB, ABC, ACA, ACB, ACC, BAA, BAB,
    BAC, BBA, BBB, BBC, BCA, BCB, BCC, CAA, CAB, CAC, CBA, CBB, CBC, CCA, CCB, CCC
    | (None), A, B, C, AA, AB, AC, BB, BC, CC, AAA, AAB, AAC, ABB, ABC, ACC, BBB,
    BBC, BCC, CCC |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
  zh: '| **有重复** | AAA，AAB，AAC，ABA，ABB，ABC，ACA，ACB，ACC，BAA，BAB，BAC，BBA，BBB，BBC，BCA，BCB，BCC，CAA，CAB，CAC，CBA，CBB，CBC，CCA，CCB，CCC
    | （无），A，B，C，AA，AB，AC，BB，BC，CC，AAA，AAB，AAC，ABB，ABC，ACC，BBB，BBC，BCC，CCC |'
- en: It’s surprising how quickly the number of permutations and combinations grows
    as we add elements to a set. This *combinatorial explosion* is captured by the
    formulas in [Table 6-2](#table6-2). For example, a set of 10 elements has 10!,
    or 3,628,800, possible permutations, but a set of twice as many elements has 20!,
    or 2,432,902,008,176,640,000, permutations.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向集合添加元素时，排列和组合的数量会迅速增长，这种*组合爆炸*由[表6-2](#table6-2)中的公式捕捉到。例如，一个包含10个元素的集合有10！，或3,628,800个可能的排列，但是一个包含两倍元素的集合有20！，或2,432,902,008,176,640,000个排列。
- en: 'Table 6-2: Calculating the Number of Possible Permutations and Combinations,
    with and without Repetition, of a Set of *n* Elements'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-2：计算*n*元素集合的可能排列和组合的数量，有重复和无重复
- en: '|  | **Permutations** | **Combinations** |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '|  | **排列** | **组合** |'
- en: '| **Without repetition** | *n*! | 2*n* |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '| **无重复** | *n*! | 2*n* |'
- en: '| **With repetition** | *n*^(*n*) | 2*n* choose *n*, or (2*n*)! / (*n*!)² |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '| **有重复** | *n*^(*n*) | 2*n*选择*n*，或(2*n*)！/(*n*!)² |'
- en: 'Note that permutations without repetition are always the same size as the set.
    For example, the permutations of {A, B, C} are always three letters long: ABC,
    ACB, BAC, and so forth. However, permutations with repetition can be of any length.
    [Table 6-1](#table6-1) shows the three-letter permutations of {A, B, C} ranging
    from AAA to CCC, but you could also, for example, have five-letter permutations
    with repetition ranging from AAAAA to CCCCC. The number of permutations with repetition
    of *n* elements that are *k* elements long is *n*^(*k*). [Table 6-2](#table6-2)
    lists it as *n*^(*n*) for permutations with repetition that are also *n* elements
    long.'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有重复的排列总是与集合的大小相同。例如，{A，B，C}的排列总是三个字母长：ABC，ACB，BAC等。然而，有重复的排列可以是任意长度。[表6-1](#table6-1)显示了{A，B，C}的三个字母排列，范围从AAA到CCC，但是你也可以有有重复的五个字母排列，范围从AAAAA到CCCCC。有重复的*n*元素的排列的长度为*k*的数量是*n*^(*k*)。[表6-2](#table6-2)将其列为*n*^(*n*)，表示有重复的*n*元素的排列也是*n*元素长的排列。
- en: Ordering matters for permutations, but not for combinations. While AAB, ABA,
    and BAA are considered the same combination with repetition, they are considered
    three separate permutations with repetition.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 排列的顺序很重要，但组合的顺序不重要。虽然AAB，ABA和BAA被视为具有重复的相同组合，但它们被视为具有重复的三个不同排列。
- en: 'Finding All Permutations Without Repetition: A Wedding Seating Chart'
  id: totrans-934
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找没有重复的所有排列：婚礼座位表
- en: Imagine you must arrange the seating chart for a wedding reception with delicate
    social requirements. Some of the guests hate each other, while others demand to
    sit near an influential guest. The seats at the rectangular table form one long,
    straight row, rather than a circle. It’d be helpful for your planning to see every
    possible ordering of guests—that is, every permutation without repetition of the
    set of guests. No repetition occurs, because each guest appears in the seating
    chart only once.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你必须为一个有着微妙社交要求的婚礼宴会安排座位表。一些客人彼此讨厌，而其他人则要求坐在一个有影响力的客人附近。长方形桌子上的座位形成一排，而不是一个圆圈。对于你的计划来说，看到每个客人的所有可能的排列，也就是每个客人的没有重复的排列，将是有帮助的。没有重复发生，因为每个客人在座位表中只出现一次。
- en: Let’s use a simple example of Alice, Bob, and Carol, or {A, B, C}. [Figure 6-2](#figure6-2)
    shows all six possible permutations of these three wedding guests.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Alice，Bob和Carol，或{A，B，C}为例。[图6-2](#figure6-2)显示了这三位婚礼客人的所有六种可能排列。
- en: One way we can determine the number of permutations without repetition is with
    a head-tail recursive strategy. We select one element from the set as the head.
    We then get every permutation of the rest of the elements (which constitute the
    tail), and for each permutation we place the head in every possible location in
    the permutation.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确定没有重复的排列数量的一种方法是使用头尾递归策略。我们从集合中选择一个元素作为头部。然后我们得到剩余元素的每个排列（构成尾部），对于每个排列，我们将头部放在排列的每个可能位置上。
- en: In our ABC example, we’ll start with Alice (A) as the head and Bob and Carol
    (BC) as the tail. The permutations of {B, C} are BC and CB. (How we got BC and
    CB is explained in the next paragraph, so just put that question aside for now.)
    We’ll put A in every possible location in BC. That is, we put Alice before Bob
    (ABC), in between Bob and Carol (BAC), and after Carol (BCA). This creates the
    permutations ABC, BAC, and BCA. We also put A in every possible position in CB,
    creating ACB, CAB, and CBA. This creates all six permutations of Alice, Bob, and
    Carol sitting at the reception table. Now we can pick the arrangement that results
    in the fewest fights (or the most fights, if you want a memorable wedding reception).
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的ABC示例中，我们将从Alice（A）作为头部开始，Bob和Carol（BC）作为尾部。{B，C}的排列是BC和CB。（我们如何得到BC和CB将在下一段解释，所以现在先把这个问题放在一边。）我们将A放在BC的每个可能位置上。也就是说，我们将Alice放在Bob之前（ABC），在Bob和Carol之间（BAC），和在Carol之后（BCA）。这样就创建了ABC，BAC和BCA的排列。我们还将A放在CB的每个可能位置上，创建了ACB，CAB和CBA。这样就创建了Alice，Bob和Carol在宴会桌上的所有六种排列。现在我们可以选择导致最少争吵的安排（或者如果你想要一个难忘的婚礼宴会，也可以选择导致最多争吵的安排）。
- en: '![Drawing of six dinner tables seating the same three people arranged in different
    orders.](image_fi/502024c06/f06002.png)'
  id: totrans-939
  prefs: []
  type: TYPE_IMG
  zh: '![六张晚餐桌的图画，上面坐着同样三个人，但是顺序不同。](image_fi/502024c06/f06002.png)'
- en: 'Figure 6-2: All six possible permutations of three wedding guests at a table'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：桌子上三位婚礼客人的六种可能排列
- en: Of course, to get every permutation of {B, C}, we’d recursively repeat the process
    with B as the head and C as the tail. The permutation of a single character is
    the character itself; this is our base case. By putting the head B in every possible
    location in C, we get the BC and CB permutations we used in the previous paragraph.
    Remember that, while order doesn’t matter with sets (as {B, C} is the same as
    {C, B}), it does matter with permutations (BC is not a duplicate of CB).
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要得到{B，C}的每个排列，我们需要用B作为头部，C作为尾部递归重复这个过程。单个字符的排列是字符本身；这是我们的基本情况。通过将头部B放在C的每个可能位置上，我们得到了上一段中使用的BC和CB排列。请记住，虽然集合的顺序无关紧要（如{B，C}与{C，B}相同），但排列的顺序很重要（BC不是CB的重复）。
- en: 'Our recursive permutation function accepts as an argument a string of characters
    and returns an array of strings of every possible permutation of those characters.
    Let’s ask the three questions about our recursive algorithms for this function:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的递归排列函数接受一个字符字符串作为参数，并返回这些字符的每种可能排列的字符串数组。让我们针对这个函数的递归算法提出三个问题：
- en: What is the base case? An argument of a single character string or empty string,
    which returns an array of just that string.
  id: totrans-943
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？单个字符字符串或空字符串的参数，返回一个只包含该字符串的数组。
- en: What argument is passed to the recursive function call? The string argument
    missing one character. A separate recursive call is made for each character missing.
  id: totrans-944
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？缺少一个字符的字符串参数。为每个缺失的字符进行了单独的递归调用。
- en: How does this argument become closer to the base case? The size of the string
    shrinks and eventually becomes a single-character string.
  id: totrans-945
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何接近基本情况？字符串的大小缩小，最终变成一个单字符字符串。
- en: 'The recursive permutations algorithm is implemented in *permutations.py*:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 递归排列算法在*permutations.py*中实现：
- en: '[PRE118]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The equivalent JavaScript program is in *permutations.html*:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的JavaScript程序在*permutations.html*中：
- en: '[PRE119]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The output of these programs is the following:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下：
- en: '[PRE120]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'When `getPerms()` is called, it first checks for the base case ❶. If the `chars`
    string is only one character long, it can have only one permutation: the `chars`
    string itself. The function returns this string in an array.'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`getPerms()`时，首先检查基本情况❶。如果`chars`字符串只有一个字符长，它只能有一个排列：`chars`字符串本身。函数将此字符串返回为数组。
- en: Otherwise, in the recursive case, the function splits the `chars` argument’s
    first character into the `head` variable and the rest into the `tail` variable
    ❷. The function makes a recursive call to `getPerms()` to get all the permutations
    of the string in `tail`. A first `for` loop ❸ iterates over each of these permutations,
    and a second `for` loop ❹ creates a new permutation by placing the `head` character
    in every possible place in the string.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，在递归情况下，函数将`chars`参数的第一个字符分为`head`变量和其余部分为`tail`变量❷。函数调用`getPerms()`递归获取`tail`字符串的所有排列。第一个`for`循环❸遍历这些排列的每一个，第二个`for`循环❹通过将`head`字符放在字符串的每个可能位置来创建一个新的排列。
- en: For example, if `getPerms()` is called with `ABCD` for the `chars` argument,
    `head` is `A` and `tail` is `BCD`. The `getPerms('BCD')` call returns an array
    of the tail permutations, `['BCD', 'CBD', 'CDB', 'BDC', 'DBC', 'DCB']`. The first
    `for` loop starts with the `BCD` permutation, and the second `for` loop places
    the `A` string in `head` in each possible place, producing `ABCD`, `BACD`, `BCAD`,
    `BCDA`. This is repeated with the remaining tail permutations, and the entire
    list is then returned by the `getPerms()` function.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`getPerms()`的`chars`参数为`ABCD`，`head`为`A`，`tail`为`BCD`。`getPerms('BCD')`调用返回一个尾部排列的数组，`['BCD'，'CBD'，'CDB'，'BDC'，'DBC'，'DCB']`。第一个`for`循环从`BCD`排列开始，第二个`for`循环将`A`字符串放在`head`的每个可能位置，产生`ABCD`，`BACD`，`BCAD`，`BCDA`。这将重复进行剩余的尾部排列，并由`getPerms()`函数返回整个列表。
- en: 'Getting Permutations with Nested Loops: A Less-Than-Ideal Approach'
  id: totrans-955
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用嵌套循环获取排列：一个不太理想的方法
- en: Let’s say we have a simple bicycle lock, as in [Figure 6-3](#figure6-3), with
    a four-digit combination. The combination has 10,000 possible permutations of
    digits (0000 to 9999), but only one will unlock it. (They are called *combination
    locks*; however, in this context it’d be more accurate to call them *permutations
    with repetition locks*, since the order matters.)
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的自行车锁，如[图6-3](#figure6-3)，有一个四位数字组合。这个组合有10,000种数字排列（0000到9999），但只有一个可以打开它。（它们被称为*组合锁*；然而，在这种情况下更准确的称呼应该是*重复排列锁*，因为顺序很重要。）
- en: Now let’s say we have a much simpler lock with only the five letters A to E.
    We can calculate the number of possible combinations as 5⁴, or 5 × 5 × 5 × 5,
    or 625\. A combination lock of *k* characters, each character selected from a
    set of *n* possibilities, is *n*^(*k*). But getting a list of the combinations
    themselves is a bit more involved.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有一个更简单的锁，只有五个字母A到E。我们可以计算可能组合的数量为5⁴，或5×5×5×5，即625。一个由*n*个可能性的集合中选择的每个字符的*k*字符组合锁是*n*^(*k*)。但是获取组合本身的列表要复杂一些。
- en: '![Photo of a bicycle lock with a four-digit combination.](image_fi/502024c06/f06003.png)'
  id: totrans-958
  prefs: []
  type: TYPE_IMG
  zh: '![自行车锁的照片，有四位数字组合。](image_fi/502024c06/f06003.png)'
- en: 'Figure 6-3: A four-digit combination bicycle lock has 10⁴, or 10,000, possible
    permutations with repetition (photo courtesy of Shaun Fisher, CC BY 2.0 license).'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3：四位数字组合自行车锁有10⁴，或10,000种可能的重复排列（照片由Shaun Fisher提供，CC BY 2.0许可）。
- en: One way to get permutations with repetition is with *nested loops*—that is,
    a loop within another loop. The inner loop goes through every element in a set,
    whereas the outer loop does the same while repeating the inner loop. Creating
    all possible *k*-character permutations, each character selected from a set of
    *n* possibilities, requires *k* nested loops.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*嵌套循环*获得重复排列的一种方法是，即一个循环内嵌另一个循环。内部循环遍历集合中的每个元素，而外部循环也做同样的事情，同时重复内部循环。创建所有可能的*k*字符排列，每个字符从*n*个可能性的集合中选择，需要*k*个嵌套循环。
- en: 'For example, *nestedLoopPermutations.py* contains code that generates all 3-combinations
    of {A, B, C, D, E}:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*nestedLoopPermutations.py*包含生成{A，B，C，D，E}的所有3组合的代码：
- en: '**Python**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE121]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'And *nestedLoopPermutations.html* contains the equivalent JavaScript program:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '* nestedLoopPermutations.html *包含等效的JavaScript程序：'
- en: '**JavaScript**'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE122]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The output of these programs looks like this:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下：
- en: '[PRE123]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The problem with generating permutations with four nested loops is that it works
    only for permutations that are exactly four characters. Nested loops cannot generate
    permutations for arbitrary lengths. Instead, we can use a recursive function,
    as described in the next section.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 使用四个嵌套循环生成排列的问题在于，它仅适用于恰好为四个字符的排列。嵌套循环无法为任意长度生成排列。相反，我们可以使用递归函数，如下一节所述。
- en: You can remember the difference between permutations with and without repetition
    with the examples in this chapter. Permutations *without* repetition go through
    all possible orderings of the elements in a set, like our wedding guest seating
    chart example. Permutations *with* repetition go through all the possible combinations
    of a combination lock; the order matters, and the same element can appear more
    than once.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过本章中的示例来记住有和没有重复的排列之间的区别。没有重复的排列会遍历集合中元素的所有可能的排序，就像我们的婚礼座位表示例一样。有重复的排列会遍历组合锁的所有可能组合；顺序很重要，同一个元素可以出现多次。
- en: 'Permutations with Repetition: A Password Cracker'
  id: totrans-971
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复排列：密码破解器
- en: Imagine you have received a sensitive encrypted file from a recently deceased
    journalist. In their final message, the journalist told you the file contains
    records of tax evasion by a nefarious trillionaire. They didn’t have the password
    to decrypt the file, but they did know that it is exactly four characters long;
    also, the possible characters are the numbers 2, 4, and 8 and the letters J, P,
    and B. These characters can appear more than once. For example, possible passwords
    are JPB2, JJJJ, and 2442\.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您收到了一份来自一位最近去世的记者的敏感加密文件。在他们的最后一条消息中，记者告诉您该文件包含了一个邪恶的亿万富翁的逃税记录。他们没有解密文件的密码，但他们知道密码正好是四个字符长；可能的字符是数字2、4和8以及字母J、P和B。这些字符可以出现多次。例如，可能的密码是JPB2、JJJJ和2442。
- en: To generate a list of all possible four-character passwords based on this information,
    you want to obtain all possible four-element permutations with repetition of the
    set {J, P, B, 2, 4, 8}. Each of the four characters in the password can be one
    of the six possible characters, making 6 × 6 × 6 × 6, or 6⁴, or 1,296 possible
    permutations. We want to generate the permutations of {J, P, B, 2, 4, 8}, and
    not the combinations, because the ordering matters; JPB2 is a different password
    from B2JP.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息生成所有可能的四位密码列表，您希望获得集合{J，P，B，2，4，8}的所有可能的四元素重复排列。密码中的每个字符都可以是六个可能的字符之一，使得有6×6×6×6，或6⁴，即1,296种可能的排列。我们要生成{J，P，B，2，4，8}的排列，而不是组合，因为顺序很重要；JPB2与B2JP是不同的密码。
- en: 'Let’s ask the three recursive algorithm questions about our permutations function.
    Instead of *k*, we’ll use the more descriptive name `permLength`:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向这三个递归算法问题询问有关我们排列函数的问题。我们将使用更具描述性的名称`permLength`，而不是*k*：
- en: What is the base case? A `permLength` argument of `0`, meaning a permutation
    zero characters long, signals that the `prefix` argument now contains the complete
    permutation and so `prefix` should be returned in an array.
  id: totrans-975
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？`permLength`参数为`0`，表示排列长度为零，表明`prefix`参数现在包含完整的排列，因此应该在数组中返回`prefix`。
- en: What argument is passed to the recursive function call? The `chars` string of
    the characters to get permutations of, a `permLength` argument that begins as
    the length of `chars`, and a `prefix` argument that begins as the blank string.
    Recursive calls decrement the `permLength` argument while appending a character
    from `chars` to the `prefix` argument.
  id: totrans-976
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？`chars`字符串是要获取排列的字符，`permLength`参数开始为`chars`的长度，`prefix`参数开始为空字符串。递归调用会递减`permLength`参数，同时将`chars`中的一个字符附加到`prefix`参数。
- en: How does this argument become closer to the base case? Eventually, the `permLength`
    argument decrements to `0`.
  id: totrans-977
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何接近基本情况？最终，`permLength`参数递减为`0`。
- en: 'The algorithm for recursive permutations with repetition is implemented in
    *permutationsWithRepetition.py*:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 递归排列重复的算法在*permutationsWithRepetition.py*中实现：
- en: '[PRE124]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The equivalent JavaScript program is in *permutationsWithRepetition.html*:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的JavaScript程序在*permutationsWithRepetition.html*中：
- en: '[PRE125]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The output of these programs is shown here:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下所示：
- en: '[PRE126]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The `getPermsWithRep()` function has a `prefix` string argument that begins
    as a blank string by default. When the function is called, it first checks for
    the base case ❶. If `permLength`, the length of the permutations, is `0`, an array
    with `prefix` is returned.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPermsWithRep()`函数有一个`prefix`字符串参数，默认情况下为空字符串。当调用该函数时，首先检查基本情况❶。如果`permLength`，即排列的长度，为`0`，则返回一个包含`prefix`的数组。'
- en: Otherwise, in the recursive case, for each character in the `chars` argument
    the function creates a new prefix ❷ to pass to the recursive `getPermsWithRep()`
    call. This recursive call passes `permLength - 1` for the `permLength` argument.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，在递归情况下，对于`chars`参数中的每个字符，函数创建一个新的前缀❷传递给递归的`getPermsWithRep()`调用。这个递归调用将`permLength
    - 1`作为`permLength`参数传递。
- en: The `permLength` argument starts at the length of the permutations and decreases
    by one for each recursive call ❸. And the `prefix` argument starts as the blank
    string and increases by one character for each recursive call. So by the time
    the base case of `k == 0` is reached, the `prefix` string is the full permutation
    length of `k`.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '`permLength`参数从排列的长度开始，每次递归调用递减一次❸。`prefix`参数从空字符串开始，每次递归调用增加一个字符。因此，当达到`k
    == 0`的基本情况时，`prefix`字符串就是`k`的完整排列长度。'
- en: 'For example, let’s consider the case of calling `getPermsWithRep(''ABC'', 2)`.
    The `prefix` argument defaults to the blank string. The function makes a recursive
    call with each character of `ABC` concatenated to the blank prefix string as the
    new prefix. Calling `getPermsWithRep(''ABC'', 2)` makes these three recursive
    calls:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑调用`getPermsWithRep('ABC', 2)`的情况。`prefix`参数默认为空字符串。该函数对`ABC`的每个字符进行递归调用，并将其连接到空前缀字符串作为新前缀。调用`getPermsWithRep('ABC',
    2)`会进行三次递归调用：
- en: '`getPermsWithRep(''ABC'', 1, ''A'')`'
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPermsWithRep(''ABC'', 1, ''A'')`'
- en: '`getPermsWithRep(''ABC'', 1, ''B'')`'
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPermsWithRep(''ABC'', 1, ''B'')`'
- en: '`getPermsWithRep(''ABC'', 1, ''C'')`'
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPermsWithRep(''ABC'', 1, ''C'')`'
- en: Each of these three calls will make its own three recursive calls, but will
    pass `0` for `permLength` instead of `1`. The base case occurs when `permLength
    == 0`, so these return their prefixes. This is how all nine of the permutations
    are generated. The `getPermsWithRep()` function generates permutations of larger
    sets the same way.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个调用将各自进行三次递归调用，但将`permLength`的值设为`0`而不是`1`。基本情况发生在`permLength == 0`时，因此它们返回它们的前缀。这就是生成所有九个排列的方式。`getPermsWithRep()`函数以相同的方式生成更大集合的排列。
- en: Getting K-Combinations with Recursion
  id: totrans-992
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用递归获取K-组合
- en: 'Recall that order is not significant for combinations in the way it is for
    permutations. Yet generating all *k*-combinations of a set is a bit tricky because
    you don’t want your algorithm to generate duplicates: if you create the AB 2-combination
    from the set {A, B, C}, you don’t want to also create BA, because it’s the same
    2-combination as AB.'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，对于排列而言，顺序并不重要。然而，生成集合的所有*k*-组合有点棘手，因为你不希望算法生成重复项：如果你从集合{A，B，C}创建AB 2-组合，你不希望也创建BA，因为它与AB是相同的2-组合。
- en: To figure out how we can write recursive code to solve this problem, let’s see
    how a tree can visually describe generating all the *k*-combinations of a set.
    [Figure 6-4](#figure6-4) shows a tree with all the combinations from the set {A,
    B, C, D}.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 要弄清楚如何编写递归代码来解决这个问题，让我们看看树如何以可视化方式描述生成集合的所有*k*-组合。[图6-4](#figure6-4)显示了来自集合{A，B，C，D}的所有组合的树。
- en: '![Tree diagram with each level of depth classified as either 0-combinations,
    1-combinations, 2-combinations, 3-combinations, or 4-combinations.](image_fi/502024c06/f06004.png)'
  id: totrans-995
  prefs: []
  type: TYPE_IMG
  zh: '![树状图，每个深度级别被分类为0-组合、1-组合、2-组合、3-组合或4-组合。](image_fi/502024c06/f06004.png)'
- en: 'Figure 6-4: Tree showing every possible *k*-combination (from 0 to 4) from
    the set {A, B, C, D}'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4：显示来自集合{A，B，C，D}的每个可能*k*-组合（从0到4）的树
- en: 'To gather, for example, 3-combinations from this tree, start at the root node
    at the top and do a depth-first tree traversal to the 3-combinations level, while
    memorizing each node’s letter on the way to the bottom. (Depth-first searches
    are discussed in Chapter 4.) Our first 3-combination would be going from the root
    to A in the 1-combination level, then down to B in the 2-combination level, then
    to C in the 3-combination level, where we stop with our complete 3-combination:
    ABC. For the next combination, we traverse from the root to A to B to D, giving
    us the combination ABD. We continue doing this for ACD and BCD. Our tree has four
    nodes in the 3-combination level, and four 3-combinations from {A, B, C, D}: ABC,
    ABD, ACD, and BCD.'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要从这棵树中收集3-组合，从顶部的根节点开始，进行深度优先树遍历到3-组合级别，同时记住每个节点的字母直到底部。（深度优先搜索在第4章中讨论。）我们的第一个3-组合将从根到1-组合级别的A开始，然后到2-组合级别的B，然后到3-组合级别的C，我们停在那里，得到了我们完整的3-组合：ABC。对于下一个组合，我们从根到A到B到D，得到了组合ABD。我们继续为ACD和BCD做同样的操作。我们的树在3-组合级别有四个节点，从{A，B，C，D}中有四个3-组合：ABC，ABD，ACD和BCD。
- en: 'Notice that we create the tree in [Figure 6-4](#figure6-4) by starting with
    a blank string for the root node. This is the 0-combination level, and it applies
    to all combinations of zero selections from the set; it’s simply an empty string.
    The child nodes of the root are all elements from the set. In our case, that is
    all four elements from {A, B, C, D}. While sets don’t have an order, we need to
    be consistent in using the ABCD order of the set while generating this tree. This
    is because every node’s children consist of the letters after it in the ABCD string:
    all A nodes have children B, C, and D; all B nodes have children C and D; all
    C nodes have one D child; and all D nodes have no child nodes.'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过从根节点开始使用空字符串创建了[图6-4](#figure6-4)中的树。这是0-组合级别，并且适用于从集合中选择零个元素的所有组合；它只是一个空字符串。根的子节点都是来自集合的所有元素。在我们的情况下，这是来自{A，B，C，D}的所有四个元素。虽然集合没有顺序，但在生成这棵树时，我们需要一致地使用集合的ABCD顺序。这是因为每个节点的子节点都包括在ABCD字符串中它之后的字母：所有A节点都有B、C和D子节点；所有B节点都有C和D子节点；所有C节点只有一个D子节点；所有D节点没有子节点。
- en: 'While it’s not directly related to the recursive combination function, also
    notice the pattern in the number of *k*-combinations at each level:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它与递归组合函数没有直接关系，但也注意每个级别的*k*-组合数量的模式：
- en: 'The 0-combination and 4-combination levels both have one combination: the empty
    string and ABCD, respectively.'
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-组合和4-组合级别都有一个组合：空字符串和ABCD，分别。
- en: 'The 1-combination and 3-combination levels both have four combinations: A,
    B, C, D and ABC, ABD, ACD, BCD, respectively.'
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-组合和3-组合级别都有四个组合：A，B，C，D和ABC，ABD，ACD，BCD，分别。
- en: 'The 2-combination level in the middle has the most combinations at six: AB,
    AC, AD, BC, BD, and CD.'
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间的2-组合级别有最多的六个组合：AB，AC，AD，BC，BD和CD。
- en: 'The reason the number of combinations increases, peaks in the middle, and then
    decreases is that the *k*-combinations are mirrors of each other. For example,
    the 1-combinations are made from the elements not selected for the 3-combinations:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 组合数量增加、在中间达到峰值，然后减少的原因是*k*-组合是彼此的镜像。例如，1-组合是由未被选中的元素构成3-组合的：
- en: The 1-combination A is the mirror of the 3-combination BCD.
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-组合A是3-组合BCD的镜像。
- en: The 1-combination B is the mirror of the 3-combination ACD.
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-组合B是3-组合ACD的镜像。
- en: The 1-combination C is the mirror of the 3-combination ABD.
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-组合C是3-组合ABD的镜像。
- en: The 1-combination D is the mirror of the 3-combination ABC.
  id: totrans-1007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-组合D是3-组合ABC的镜像。
- en: 'We’ll create a function called `getCombos()` that takes two arguments: a `chars`
    string with the letters to get combinations from, and the size of the combinations
    `k`. The return value is an array of strings of combinations from the string `chars`,
    each of length `k`.'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`getCombos()`的函数，它接受两个参数：一个`chars`字符串，其中包含要获取组合的字母，以及组合的大小`k`。返回值是一个字符串数组，其中包含来自字符串`chars`的组合，每个组合的长度为`k`。
- en: We’ll use a head-tail technique with the `chars` argument. For example, say
    we call `getCombos('ABC', 2)` to get all the 2-combinations from {A, B, C}. The
    function will set `A` as the head and `BC` as the tail. [Figure 6-5](#figure6-5)
    shows the tree for selecting 2-combinations from {A, B, C}.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`chars`参数的头部-尾部技术。例如，假设我们调用`getCombos('ABC', 2)`来从{A, B, C}获取所有2-组合。该函数将`A`设置为头部，`BC`设置为尾部。[图6-5](#figure6-5)显示了从{A,
    B, C}选择2-组合的树。
- en: '![Tree diagram classifying each depth level as 0-combinations, 1-combinations,
    2-combinations, or 3-combinations.](image_fi/502024c06/f06005.png)'
  id: totrans-1010
  prefs: []
  type: TYPE_IMG
  zh: '![树状图将每个深度级别分类为0-组合、1-组合、2-组合或3-组合。](image_fi/502024c06/f06005.png)'
- en: 'Figure 6-5: Tree showing every possible 2-combination from the set {A, B, C}'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：树状图显示了从集合{A, B, C}中的每个可能的2-组合
- en: 'Let’s ask our three recursive algorithm questions:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们问一下我们的三个递归算法问题：
- en: What is the base case? The first base case is a `k` argument of `0`, meaning
    that a 0-combination is requested, which is always an array of the blank string
    no matter what `chars` is. The second case occurs if `chars` is the blank string,
    which is an empty array since no possible combinations can be made from a blank
    string.
  id: totrans-1013
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？第一个基本情况是`k`参数为`0`，这意味着请求0-组合，无论`chars`是什么，它总是一个空字符串数组。第二种情况是如果`chars`是空字符串，则是一个空数组，因为从空字符串中无法生成任何可能的组合。
- en: What argument is passed to the recursive function call? For the first recursive
    call, the tail of `chars` and `k - 1` are passed. For the second recursive call,
    the tail of `chars` and `k` are passed.
  id: totrans-1014
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递给递归函数调用的参数是什么？对于第一个递归调用，传递了`chars`的尾部和`k - 1`。对于第二个递归调用，传递了`chars`的尾部和`k`。
- en: How does this argument become closer to the base case? Since the recursive calls
    decrement `k` and remove the heads from the `chars` arguments, eventually the
    `k` argument decrements to `0` or the `chars` argument becomes the blank string.
  id: totrans-1015
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何接近基本情况？由于递归调用会减少`k`并从`chars`参数中删除头部，最终`k`参数会减少到`0`，或者`chars`参数会变成空字符串。
- en: 'The Python code for generating combinations is in *combinations.py*:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 生成组合的Python代码在*combinations.py*中：
- en: '**Python**'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE127]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The equivalent JavaScript program is in *combinations.html*:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的JavaScript程序在*combinations.html*中：
- en: '[PRE128]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The output of these programs is the following:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下：
- en: '[PRE129]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Every `getCombos()` function call has two recursive calls for the two parts
    of the algorithm. For our `getCombos('ABC', 2)` example, the first part ❶ is to
    get all the combinations that include the head `A`. In the tree, this generates
    all the combinations *under* the A node in the 1-combination level.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`getCombos()`函数调用都有两个递归调用，用于算法的两个部分。对于我们的`getCombos('ABC', 2)`示例，第一部分❶是获取包含头部`A`的所有组合。在树中，这会生成1-组合级别下A节点下的所有组合。
- en: 'We can do this by passing the tail and `k - 1` to the first recursive function
    call: `getCombos(''BC'', 1)` ❷. We add `A` to each combination that this recursive
    function call returns. Let’s use the leap-of-faith principle and just assume our
    `getCombos()` correctly returns a list of *k*-combinations, `[''B'', ''C'']`,
    even though we haven’t finished writing it yet. We now have all the *k*-combinations
    that include the head `A` in an array to hold our results: `[''AB'', ''AC'']`.'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将尾部和`k - 1`传递给第一个递归函数调用`getCombos('BC', 1)` ❷来实现这一点。我们将`A`添加到这个递归函数调用返回的每个组合中。让我们使用信任原则，假设我们的`getCombos()`正确返回了一个*k*-组合列表`['B',
    'C']`，即使我们还没有完成编写它。现在我们已经有了包含头部`A`的所有*k*-组合的数组来保存我们的结果：`['AB', 'AC']`。
- en: 'The second part ❸ gets all the combinations that don’t include the head `A`.
    In the tree, this generates all the combinations *to the right* of the A node
    in the 1-combination level. We can do this by passing the tail and `k` to the
    second recursive function call: `getCombos(''BC'', 2)`. This returns `[''BC'']`,
    since BC is the only 2-combination of BC.'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分❸获取不包括头部`A`的所有组合。在树中，这会生成1-组合级别中A节点右侧的所有组合。我们可以通过将尾部和`k`传递给第二个递归函数调用`getCombos('BC',
    2)`来实现这一点。这将返回`['BC']`，因为BC是BC的唯一2-组合。
- en: 'The results from `getCombos(''ABC'', 2)`’s two recursive calls, `[''AB'', ''AC'']`
    and `[''BC'']`, are concatenated together and returned: `[''AB'', ''AC'', ''BC'']`
    ❹. The `getCombos()` function generates combinations of larger sets the same way.'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCombos(''ABC'', 2)`的两个递归调用的结果，`[''AB'', ''AC'']`和`[''BC'']`被连接在一起并返回：`[''AB'',
    ''AC'', ''BC'']` ❹。`getCombos()`函数以相同的方式生成更大集合的组合。'
- en: Get All Combinations of Balanced Parentheses
  id: totrans-1027
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取平衡括号的所有组合
- en: A string has *balanced parentheses* if every opening parenthesis is followed
    by exactly one closing parenthesis. For example, `′()()′` and `′(())′` are strings
    of two balanced parentheses pairs, but `′)(()′` and `′(()′` are not balanced.
    These strings are also called *Dyck words*, after mathematician Walther von Dyck.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个开括号后面都紧跟一个闭括号，则字符串具有*平衡括号*。例如，`′()()′`和`′(())′`是两对平衡括号的字符串，但`′)(()′`和`′(()′`则不是平衡的。这些字符串也被称为*Dyck
    words*，以数学家瓦尔特·冯·迪克命名。
- en: A common coding interview question is to write a recursive function that, given
    the number of pairs of parentheses, produces all possible combinations of balanced
    parentheses. For example, a `getBalancedParens(3)` call should return `['((()))',
    '(()())', '(())()', '()(())', '()()()']`. Note that calling `getBalancedParens(``n``)`
    `returns strings that are 2*n* characters in length, since each string consists
    of *n* pairs of parentheses.`
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的编码面试问题是编写一个递归函数，给定括号对的数量，生成所有可能的平衡括号的组合。例如，调用`getBalancedParens(3)`应该返回`['((()))',
    '(()())', '(())()', '()(())', '()()()']`。请注意，调用`getBalancedParens(``n``)`会返回长度为2*n*的字符串，因为每个字符串由*n*对括号组成。
- en: '`We could try to solve this problem by finding all permutations of the pairs
    of parenthesis characters, but that would result in both balanced and unbalanced
    parentheses strings. Even if we filtered out the invalid strings later, 2*n*!
    permutations exist for *n* pairs of parentheses. That algorithm is far too slow
    to be practical.'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: “我们可以尝试通过找到括号字符的所有排列来解决这个问题，但这将导致平衡和不平衡的括号字符串。即使稍后过滤掉无效的字符串，对于*n*对括号，存在2*n*!种排列。该算法速度太慢，不实用。
- en: Instead, we can implement a recursive function to generate all strings of balanced
    parentheses. Our `getBalancedParens()` function takes an integer of the number
    of pairs of parentheses and returns a list of balanced parentheses strings. The
    function builds these strings by adding either an opening or closing parenthesis.
    An opening parenthesis can be added only if opening parentheses remain to be used.
    A closing parenthesis can be added only if more opening parentheses have been
    added than closing parentheses so far.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以实现一个递归函数来生成所有平衡括号的字符串。我们的`getBalancedParens()`函数接受一个整数，表示括号对的数量，并返回一个平衡括号字符串的列表。该函数通过添加开放或关闭括号来构建这些字符串。只有在剩余要使用的开放括号时才能添加开放括号。只有在迄今为止添加的开放括号比关闭括号多时才能添加关闭括号。
- en: We’ll track the number of opening and closing parentheses remaining to be used
    with function parameters named `openRem` and `closeRem`. The string currently
    being built is another function parameter named `current`, which serves a similar
    purpose as the `prefix` parameter in the *permutationsWithRepetition* program.
    The first base case occurs when `openRem` and `closeRem` are both `0` and no more
    parentheses remain to be added to the `current` string. The second base case happens
    after the two recursive cases have received the lists of balanced parentheses
    strings after adding an opening and/or closing parenthesis (if possible).
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用名为`openRem`和`closeRem`的函数参数跟踪剩余要使用的开放和关闭括号的数量。当前正在构建的字符串是另一个名为`current`的函数参数，它与*permutationsWithRepetition*程序中的`prefix`参数具有类似的作用。第一个基本情况发生在`openRem`和`closeRem`都为`0`且没有更多的括号要添加到`current`字符串时。第二个基本情况发生在两个递归情况在添加开放和/或关闭括号后接收到平衡括号字符串列表之后。
- en: 'Let’s ask the three recursive algorithm questions about the `getBalancedParens()`
    function:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们问一下关于`getBalancedParens()`函数的三个递归算法问题：
- en: What is the base case? When the number of opening and closing parentheses remaining
    to be added to the string being built has reached `0`. A second base case always
    occurs after the recursive cases have finished.
  id: totrans-1034
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？当剩余要添加到正在构建的字符串中的开放和关闭括号的数量达到`0`时。第二个基本情况总是在递归情况完成后发生。
- en: What argument is passed to the recursive function call? The total number of
    pairs of parentheses (`pairs`), the remaining number of opening and closing parentheses
    to add (`openRem` and `closeRem`), and the string currently being built (`current`).
  id: totrans-1035
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？括号对的总数（`pairs`），剩余要添加的开放和关闭括号的数量（`openRem`和`closeRem`），以及当前正在构建的字符串（`current`）。
- en: How does this argument become closer to the base case? As we add more opening
    and closing parentheses to `current`, we decrement the `openRem` and `closeRem`
    arguments until they become 0.
  id: totrans-1036
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何接近基本情况？当我们向`current`添加更多的开放和关闭括号时，我们递减`openRem`和`closeRem`参数，直到它们变为0。
- en: 'The *balancedParentheses.py* file contains the Python code for our balanced
    parentheses recursive function:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '*balancedParentheses.py*文件包含了我们平衡括号递归函数的Python代码：'
- en: '[PRE130]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The *balancedParentheses.html* file contains the JavaScript equivalent of this
    program:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '*balancedParentheses.html*文件包含了该程序的JavaScript等效代码：'
- en: '[PRE131]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The output of these programs looks like this:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下：
- en: '[PRE132]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The `getBalancedParens()` function ❶ requires one argument, the number of pairs
    of parentheses, when called by the user. However, it needs to pass additional
    information in the arguments to its recursive calls. These include the number
    of opening parentheses that remain to be added (`openRem`), the number of closing
    parentheses that remain to be added (`closeRem`), and the current balanced parentheses
    string being built (`current`). Both `openRem` and `closeRem` start as the same
    value as the `pairs` argument, and `current` starts as the blank string. An `indent`
    argument is used only for the debugging output to show the program’s level of
    recursive function call.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBalancedParens()`函数❶在用户调用时需要一个参数，即括号对的数量。但是，它需要在递归调用中传递额外的信息。这些信息包括剩余要添加的开放括号的数量（`openRem`），剩余要添加的关闭括号的数量（`closeRem`）和当前正在构建的平衡括号字符串（`current`）。`openRem`和`closeRem`都以与`pairs`参数相同的值开始，而`current`则以空字符串开始。`indent`参数仅用于调试输出，以显示程序的递归函数调用级别。'
- en: The function first checks the number of opening and closing parentheses remaining
    to be added ❷. If both are `0`, we’ve reached the first base case, and the string
    in `current` is finished. Since the `getBalancedParens()` function returns a list
    of strings, we put `current` in a list and return it ❸.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先检查剩余要添加的开放和关闭括号的数量❷。如果两者都是`0`，我们已经达到了第一个基本情况，并且`current`中的字符串已经完成。由于`getBalancedParens()`函数返回一个字符串列表，我们将`current`放入列表中并返回它❸。
- en: Otherwise, the function continues on to the recursive case. If possible opening
    parentheses remain ❹, the function calls `getBalancedParens()` with an opening
    parenthesis added to the current argument. If more closing parentheses are remaining
    than opening parentheses ❺, the function calls `getBalancedParens()` with a closing
    parenthesis added to the current argument. This check ensures that an unmatched
    closing parenthesis won’t be added, as this would make the string unbalanced,
    such as the second closing parenthesis in `())`.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，函数继续进行递归。如果可能的话，剩余的开放括号❹，函数调用`getBalancedParens()`并向当前参数添加一个开放括号。如果剩余的关闭括号比开放括号多❺，函数调用`getBalancedParens()`并向当前参数添加一个关闭括号。这个检查确保不会添加不匹配的关闭括号，因为这会使字符串不平衡，比如`())`中的第二个关闭括号。
- en: After these recursive cases is an unconditional base case that returns all the
    strings returned from the two recursive function calls (and, of course, the recursive
    function calls made by these recursive function calls, and so on) ❻.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些递归情况之后是一个无条件的基本情况，它返回从两个递归函数调用返回的所有字符串（当然还有这些递归函数调用所做的递归函数调用，依此类推）❻。
- en: 'Power Set: Finding All Subsets of a Set'
  id: totrans-1047
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幂集：查找集合的所有子集
- en: The *power set* of a set is the set of every possible subset of that set. For
    example, the power set of {A, B, C} is {{ }, {A}, {B}, {C}, {A, B}, {A, C}, {B,
    C}, {A, B, C}}. This is equivalent to the set of every possible *k*-combination
    of a set. After all, the power set of {A, B, C} contains all its 0-combinations,
    1-combinations, 2-combinations, and 3-combinations.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集合的*幂集*是该集合的每个可能子集的集合。例如，{A, B, C}的幂集是{{ }, {A}, {B}, {C}, {A, B}, {A, C},
    {B, C}, {A, B, C}}。这等同于集合的每个可能*k*组合的集合。毕竟，{A, B, C}的幂集包含了它的所有0-组合、1-组合、2-组合和3-组合。
- en: If you’re looking for a real-world example in which you would need to generate
    the power set of a set, imagine a job interviewer asked you to generate the power
    set of a set. It is astronomically unlikely you’ll need to generate the power
    set of a set for any other reason, including the job you are interviewing for.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个现实世界的例子，你需要生成一个集合的幂集，想象一下一个面试官要求你生成一个集合的幂集。你几乎不可能需要为任何其他原因生成一个集合的幂集，包括你正在面试的工作。
- en: To find every power set of a set, we could reuse our existing `getCombos()`
    function, calling it repeatedly with each possible *k* argument. This approach
    is taken by the *powerSetCombinations.py* and *powerSetCombinations.html* programs
    in the downloadable resources file from [https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion).
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到集合的每个幂集，我们可以重用我们现有的`getCombos()`函数，用每个可能的*k*参数重复调用它。这种方法被*powerSetCombinations.py*和*powerSetCombinations.html*程序采用，这些程序可以从[https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion)的可下载资源文件中获得。
- en: 'However, we can use a more efficient way to generate power sets. Let’s consider
    the power set of {A, B}, which is {{A, B}, {A}, {B}, { }}. Now say we add one
    more element, C, to the set and want to generate the power set of {A, B, C}. We
    have the four sets in the power set of {A, B} we already generated; in addition,
    we have these same four sets but with the element C added to them: {{A, B, C},
    {A, C}, {B, C}, {C}}. [Table 6-3](#table6-3) shows the pattern of how adding more
    elements to a set adds more sets to its power set.'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用更有效的方法来生成幂集。让我们考虑{A, B}的幂集，即{{A, B}, {A}, {B}, { }}。现在假设我们再添加一个元素C到集合中，并且想要生成{A,
    B, C}的幂集。我们已经生成了{A, B}的幂集中的四个集合；此外，我们有这些相同的四个集合，但是加上了元素C：{{A, B, C}, {A, C}, {B,
    C}, {C}}。[表6-3](#table6-3)显示了向集合添加更多元素如何向其幂集添加更多集合的模式。
- en: 'Table 6-3: How Power Sets Grow as New Elements (in Bold) Are Added to the Set'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-3：随着新元素（加粗）添加到集合中，幂集如何增长
- en: '| **Set with new element** | **New sets to the power set** | **Complete power
    set** |'
  id: totrans-1053
  prefs: []
  type: TYPE_TB
  zh: '| **带有新元素的集合** | **幂集的新集合** | **完整的幂集** |'
- en: '| --- | --- | --- |'
  id: totrans-1054
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| { } | { } | {{ }} |'
  id: totrans-1055
  prefs: []
  type: TYPE_TB
  zh: '| { } | { } | {{ }} |'
- en: '| {A} | {A} | {{ }, **{A}**} |'
  id: totrans-1056
  prefs: []
  type: TYPE_TB
  zh: '| {A} | {A} | {{ }, **{A}**} |'
- en: '| {A, B} | {B}, {A, B} | {{ }, {A}, **{B}**, **{A, B}**} |'
  id: totrans-1057
  prefs: []
  type: TYPE_TB
  zh: '| {A, B} | {B}, {A, B} | {{ }, {A}, **{B}**, **{A, B}**} |'
- en: '| {A, B, C} | {C}, {A, C}, {B, C}, {A, B, C} | {{ }, {A}, {B}, **{C}**, {A,
    B}, **{A, C}**, **{B, C}**, **{A, B, C}**} |'
  id: totrans-1058
  prefs: []
  type: TYPE_TB
  zh: '| {A, B, C} | {C}, {A, C}, {B, C}, {A, B, C} | {{ }, {A}, {B}, **{C}**, {A,
    B}, **{A, C}**, **{B, C}**, **{A, B, C}**} |'
- en: '| {A, B, C, D} | {D}, {A, D}, {B, D}, {C, D}, {A, B, D}, {A, C, D}, {B, C,
    D}, {A, B, C, D} | {{ }, {A}, {B}, {C}, **{D}**, {A, B}, {A, C}, **{A, D}**, {B,
    C}, **{B, D}**, **{C, D}**, {A, B, C}, {A, B, D}, {A, C, D}, **{B, C, D}**, **{A,
    B, C, D}**} |'
  id: totrans-1059
  prefs: []
  type: TYPE_TB
  zh: '| {A, B, C, D} | {D}, {A, D}, {B, D}, {C, D}, {A, B, D}, {A, C, D}, {B, C,
    D}, {A, B, C, D} | {{ }, {A}, {B}, {C}, **{D}**, {A, B}, {A, C}, **{A, D}**, {B,
    C}, **{B, D}**, **{C, D}**, {A, B, C}, {A, B, D}, {A, C, D}, **{B, C, D}**, **{A,
    B, C, D}**} |'
- en: The power sets of larger sets are similar to the power sets of smaller sets,
    hinting that we can create a recursive function to generate them. The base case
    is an empty set, and its power set is a set of just the empty set. We can use
    a head-tail technique for this recursive function. For each new element we add,
    we want to get the power set of the tail to add to our full power set. We also
    add the head element to each set in the tail power set. Together, these form the
    full power set for the `chars` argument.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 更大集合的幂集类似于更小集合的幂集，这暗示我们可以创建一个递归函数来生成它们。基本情况是一个空集，它的幂集是一个只有空集的集合。我们可以使用头尾技术来实现这个递归函数。对于我们添加的每个新元素，我们希望得到尾部的幂集以添加到我们的完整幂集中。我们还将头元素添加到尾部幂集中的每个集合中。这些一起形成了`chars`参数的完整幂集。
- en: 'Let’s ask the three recursive algorithm questions about our power set algorithm:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们问三个递归算法问题关于我们的幂集算法：
- en: What is the base case? If `chars` is the blank string (the empty set), the function
    returns an array with just a blank string, since the empty set is the only subset
    of the empty set.
  id: totrans-1062
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？如果`chars`是空字符串（空集），函数返回一个只有空字符串的数组，因为空集是空集的唯一子集。
- en: What argument is passed to the recursive function call? The tail of `chars`
    is passed.
  id: totrans-1063
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？`chars`的尾部被传递。
- en: How does this argument become closer to the base case? Since the recursive calls
    remove the heads from the `chars` arguments, eventually the `chars` argument becomes
    the blank string.
  id: totrans-1064
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何接近基本情况？由于递归调用从`chars`参数中删除头部，最终`chars`参数变为空字符串。
- en: 'The `getPowerSet()` recursive function is implemented in *powerSet.py*:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPowerSet()`递归函数在*powerSet.py*中实现：'
- en: '**Python**'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE133]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The equivalent JavaScript code is in *powerSet.html*:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的JavaScript代码在*powerSet.html*中：
- en: '[PRE134]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The programs output the following:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出如下：
- en: '[PRE135]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The `getPowerSet()` function accepts a single argument: the string `chars`,
    which contains the characters of the original set. The base case occurs when `chars`
    is the blank string ❶, representing an empty set. Recall that the power set is
    the set of all subsets of the original set. Thus, the power set of the empty set
    is simply a set containing the empty set, since the empty set is the only subset
    of the empty set. This is why the base case returns `['''']`.'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPowerSet()`函数接受一个参数：包含原始集合字符的字符串`chars`。基本情况发生在`chars`是空字符串❶时，表示空集。回想一下，幂集是原始集合的所有子集。因此，空集的幂集只是包含空集的集合，因为空集是空集的唯一子集。这就是为什么基本情况返回`['''']`。'
- en: The recursive case is split into two parts. The first part is acquiring the
    power set of the tail of `chars`. We’ll use the leap-of-faith principle and just
    assume the call to `getPowerSet()` returns the power set of the tail correctly
    ❷, even though at this point we’d still be in the process of writing the code
    for `getPowerSet()`.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 递归情况分为两部分。第一部分是获取`chars`尾部的幂集。我们将使用信任原则，假设调用`getPowerSet()`返回尾部的幂集正确❷，即使在这一点上我们仍在编写`getPowerSet()`的代码。
- en: To form the complete power set of `chars`, the second part of the recursive
    case forms new sets by adding the head to each of the tail power sets ❸. Together
    with the sets from the first part, this forms the power set of `chars` to return
    at the end of the function ❹.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形成`chars`的完整幂集，递归情况的第二部分通过将头部添加到每个尾部幂集来形成新集合❸。与第一部分的集合一起，这形成了`chars`的幂集，在函数结束时返回❹。
- en: Summary
  id: totrans-1075
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Permutations and combinations are two problem domains that many programmers
    don’t know how to even begin to approach. While recursion is often an overly complicated
    solution for common programming problems, it’s well suited for the complexity
    of the tasks in this chapter.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 排列和组合是许多程序员不知道如何开始解决的两个问题领域。虽然递归通常是常见编程问题的过于复杂的解决方案，但它非常适合本章任务的复杂性。
- en: The chapter began with a brief introduction to set theory. This lays the basis
    for the data structures that our recursive algorithms operate on. A set is a collection
    of distinct elements. A subset consists of none, some, or all the elements of
    a set. While sets have no ordering for their elements, a permutation is a specific
    ordering of the elements in a set. And a combination, which has no ordering, is
    a specific selection of none, some, or all the elements in a set. A *k*-combination
    of a set is a subset of *k* elements selected from the set.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以简要介绍集合论开始。这为我们的递归算法操作的数据结构奠定了基础。集合是不同元素的集合。子集包括集合中的一些或所有元素。虽然集合的元素没有顺序，排列是集合中元素的特定顺序。而组合没有顺序，是集合中元素的特定选择。集合的*k*组合是从集合中选择的*k*个元素的子集。
- en: Permutations and combinations can include an element once or can repeat elements.
    We call these permutations or combinations without repetition and with repetition,
    respectively. These are implemented by different algorithms.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 排列和组合可以包括一个元素，也可以重复元素。我们称这些为无重复排列或组合和有重复排列或组合。这些由不同的算法实现。
- en: This chapter also tackled the balanced parentheses problem that is commonly
    used in coding interviews. Our algorithm builds the strings of balanced parentheses
    by starting with a blank string and adding opening and closing parentheses. This
    approach involves backtracking to earlier strings, making recursion an ideal technique.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还解决了在编码面试中常用的平衡括号问题。我们的算法通过从空字符串开始并添加开放和关闭括号来构建平衡括号的字符串。这种方法涉及回溯到较早的字符串，使递归成为一种理想的技术。
- en: Finally, this chapter featured a recursive function for generating power sets—that
    is, sets of all possible *k*-combinations of the elements of a set. The recursive
    function we create to do this is much more efficient than repeatedly calling our
    combinations function for each possible size of subset.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章介绍了一个用于生成幂集的递归函数，即集合中所有可能的*k*组合的集合。我们创建的递归函数比反复调用组合函数来生成每个可能大小的子集要高效得多。
- en: Further Reading
  id: totrans-1081
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Generating permutations and combinations only scratches the surface of what
    you can do with permutations and combinations, as well as the field of mathematical
    logic known as *set theory*. The following Wikipedia articles provide plenty of
    further details on these topics, as do the Wikipedia articles that each links
    to:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 生成排列和组合只是揭示了你可以用排列和组合以及数学逻辑领域*集合论*做什么的冰山一角。以下维基百科文章提供了这些主题的更多细节，每个链接到维基百科文章：
- en: '[https://en.wikipedia.org/wiki/Set_theory](https://en.wikipedia.org/wiki/Set_theory)'
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Set_theory](https://en.wikipedia.org/wiki/Set_theory)'
- en: '[https://en.wikipedia.org/wiki/Combination](https://en.wikipedia.org/wiki/Combination)'
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Combination](https://en.wikipedia.org/wiki/Combination)'
- en: '[https://en.wikipedia.org/wiki/Permutation](https://en.wikipedia.org/wiki/Permutation)'
  id: totrans-1085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Permutation](https://en.wikipedia.org/wiki/Permutation)'
- en: The Python standard library comes with implementations of permutation, combination,
    and other algorithms in its `itertools` module. This module is documented at [https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html).
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库提供了排列、组合和其他算法的实现，位于其`itertools`模块中。该模块在[https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)中有文档。
- en: Permutations and combinations are also covered in statistics and probability
    math courses. Khan Academy’s unit on counting, permutations, and combinations
    can be found online at [https://www.khanacademy.org/math/statistics-probability/counting-permutations-and-combinations](https://www.khanacademy.org/math/statistics-probability/counting-permutations-and-combinations).
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 排列和组合也在统计和概率数学课程中涵盖。可在Khan Academy的计数、排列和组合单元中找到[https://www.khanacademy.org/math/statistics-probability/counting-permutations-and-combinations](https://www.khanacademy.org/math/statistics-probability/counting-permutations-and-combinations)。
- en: Practice Questions
  id: totrans-1088
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习问题
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试您的理解：
- en: Do sets have a specific order for their elements? Do permutations? Do combinations?
  id: totrans-1090
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合的元素是否有特定顺序？排列呢？组合呢？
- en: How many permutations (without repetition) are there of a set of *n* elements?
  id: totrans-1091
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个包含*n*个元素的集合有多少排列（不重复）？
- en: How many combinations (without repetition) are there of a set of *n* elements?
  id: totrans-1092
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个包含*n*个元素的集合有多少组合（不重复）？
- en: Is {A, B, C} a subset of {A, B, C}?
  id: totrans-1093
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '{A，B，C}是{A，B，C}的子集吗？'
- en: What is the formula for calculating *n choose k*, the number of possible combinations
    of *k* elements selected from a set of *n* elements?
  id: totrans-1094
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算*n*选择*k*的公式是什么，即从*n*个元素的集合中选择*k*个元素的可能组合数？
- en: 'Identify which of the following are permutations or combinations, with or without
    repetition:'
  id: totrans-1095
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定以下哪些是排列或组合，有或没有重复：
- en: AAA, AAB, AAC, ABA, ABB, ABC, ACA, ACB, ACC, BAA, BAB, BAC, BBA, BBB, BBC, BCA,
    BCB, BCC, CAA, CAB, CAC, CBA, CBB, CBC, CCA, CCB, CCC
  id: totrans-1096
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AAA，AAB，AAC，ABA，ABB，ABC，ACA，ACB，ACC，BAA，BAB，BAC，BBA，BBB，BBC，BCA，BCB，BCC，CAA，CAB，CAC，CBA，CBB，CBC，CCA，CCB，CCC
- en: ABC, ACB, BAC, BCA, CAB
  id: totrans-1097
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ABC，ACB，BAC，BCA，CAB
- en: (None), A, B, C, AB, AC, BC, ABC
  id: totrans-1098
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （无），A，B，C，AB，AC，BC，ABC
- en: (None), A, B, C, AA, AB, AC, BB, BC, CC, AAA, AAB, AAC, ABB, ABC, ACC, BBB,
    BBC, BCC, CCC
  id: totrans-1099
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （无），A，B，C，AA，AB，AC，BB，BC，CC，AAA，AAB，AAC，ABB，ABC，ACC，BBB，BBC，BCC，CCC
- en: Draw a tree graph that can be used to generate all possible combinations of
    the set {A, B, C, D}.
  id: totrans-1100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个树图，可用于生成集合{A，B，C，D}的所有可能组合。
- en: 'Answer the three questions about recursive solutions for each of the recursive
    algorithms presented in this chapter:'
  id: totrans-1101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回答本章中每个递归算法的递归解决方案的三个问题：
- en: What is the base case?
  id: totrans-1102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本情况是什么？
- en: What argument is passed to the recursive function call?
  id: totrans-1103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？
- en: How does this argument become closer to the base case?
  id: totrans-1104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个论点如何接近基本情况？
- en: Then re-create the recursive algorithms from this chapter without looking at
    the original code.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新创建本章中的递归算法，而不查看原始代码。
- en: Practice Projects
  id: totrans-1106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习项目
- en: 'For practice, write a function for the following task:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 为练习，编写一个执行以下任务的函数：
- en: The permutation function in this chapter operates on characters in a string
    value. Modify it so that the sets are represented by lists (in Python) or arrays
    (in JavaScript) and the elements can be values of any data type. For example,
    your new function should be able to generate permutations of integer values, rather
    than strings.
  id: totrans-1108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章中的排列函数操作字符串值中的字符。修改它，使得集合由列表（在Python中）或数组（在JavaScript中）表示，元素可以是任何数据类型的值。例如，您的新函数应该能够生成整数值的排列，而不是字符串。
- en: The combination function in this chapter operates on characters in a string
    value. Modify it so that the sets are represented by lists (in Python) or arrays
    (in JavaScript) and the elements can be values of any data type. For example,
    your new function should be able to generate combinations of integer values, rather
    than strings.`*  *`# 7
  id: totrans-1109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章中的组合函数操作字符串值中的字符。修改它，使得集合由列表（在Python中）或数组（在JavaScript中）表示，元素可以是任何数据类型的值。例如，您的新函数应该能够生成整数值的组合，而不是字符串。`*  *`#
    7
- en: Memoization and Dynamic Programming
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化和动态规划
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-1111
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, we’ll explore memoization, a technique for making recursive
    algorithms run faster. We’ll discuss what memoization is, how it should be applied,
    and its usefulness in the areas of functional programming and dynamic programming.
    We’ll use the Fibonacci algorithm from Chapter 2 to demonstrate memoizing code
    we write and the memoization features we can find in the Python standard library.
    We’ll also learn why memoization can’t be applied to every recursive function.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨记忆化，这是一种使递归算法运行更快的技术。我们将讨论记忆化是什么，如何应用它，以及它在函数式编程和动态规划领域的用处。我们将使用第2章中的斐波那契算法来演示我们编写的代码和Python标准库中可以找到的记忆化功能。我们还将了解为什么记忆化不能应用于每个递归函数。
- en: Memoization
  id: totrans-1113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记忆化
- en: '*Memoization* is the technique of remembering the return values from a function
    for the specific arguments supplied to it. For example, if someone asked me to
    find the square root of 720, which is the number that when multiplied by itself
    results in 720, I’d have to sit down with pencil and paper for a few minutes (or
    call `Math.sqrt(720)` in JavaScript or `math.sqrt(720)` in Python) to figure it
    out: 26.832815729997478\. If they asked me again a few seconds later, I wouldn’t
    have to repeat my calculation because I’d already have the answer at hand. By
    caching previously calculated results, memoization makes a trade-off to save on
    execution time by increasing memory usage.'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '*记忆化*是记住函数对其提供的特定参数的返回值的技术。例如，如果有人让我找到720的平方根，即乘以自身的结果为720的数字，我将不得不坐下来用铅笔和纸几分钟（或在JavaScript中调用`Math.sqrt(720)`或在Python中调用`math.sqrt(720)`）来算出答案：26.832815729997478。如果他们几秒钟后再问我，我就不必重复计算，因为我已经有了答案。通过缓存先前计算的结果，记忆化通过增加内存使用量来节省执行时间。'
- en: Confusing *memoization* with *memorization* is a modern mistake made by many.
    (Feel free to make a memo to remind yourself of the difference.)
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 将*记忆化*与*记忆*混淆是许多人现代的错误。 （随时可以做一个备忘录来提醒自己它们的区别。）
- en: Top-Down Dynamic Programming
  id: totrans-1116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自顶向下的动态规划
- en: Memoization is a common strategy in *dynamic programming*, a computer programming
    technique that involves breaking a large problem into overlapping subproblems.
    This might sound a lot like the ordinary recursion we’ve already seen. The key
    difference is that dynamic programming uses recursion with repeated recursive
    cases; these are the *overlapping* subproblems.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是*动态规划*中的一种常见策略，这是一种涉及将大问题分解为重叠子问题的计算机编程技术。这听起来很像我们已经看到的普通递归。关键区别在于动态规划使用具有重复递归情况的递归；这些是*重叠*子问题。
- en: For example, let’s consider the recursive Fibonacci algorithm from Chapter 2.
    Making a recursive `fibonacci(6)` function call will in turn call `fibonacci(5)`
    and `fibonacci(4)`. Next, `fibonacci(5)` will call `fibonacci(4)` and `fibonacci(3)`.
    The subproblems of the Fibonacci algorithm overlap, because the `fibonacci(4)`
    call, and many others, are repeated. This makes generating Fibonacci numbers a
    dynamic programming problem.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑第2章中的递归斐波那契算法。进行递归`fibonacci(6)`函数调用将依次调用`fibonacci(5)`和`fibonacci(4)`。接下来，`fibonacci(5)`将调用`fibonacci(4)`和`fibonacci(3)`。斐波那契算法的子问题重叠，因为`fibonacci(4)`调用以及许多其他调用都是重复的。这使得生成斐波那契数成为一个动态规划问题。
- en: 'An inefficiency exists here: performing those same calculations multiple times
    is unnecessary, because `fibonacci(4)` will always return the same thing, the
    integer `3`. Instead, our program could just remember that if the argument to
    our recursive function is `4`, the function should immediately return `3`.'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在一个低效：多次执行相同的计算是不必要的，因为`fibonacci(4)`将始终返回相同的值，即整数`3`。相反，我们的程序可以记住，如果递归函数的参数是`4`，函数应立即返回`3`。
- en: '[Figure 7-1](#figure7-1) shows a tree diagram of all the recursive calls, including
    the redundant function calls that memoization can optimize. Meanwhile, quicksort
    and merge sort are recursive divide-and-conquer algorithms, but their subproblems
    do not overlap; they are unique. Dynamic programming techniques aren’t applied
    to these sorting algorithms.'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-1](#figure7-1)显示了所有递归调用的树状图，包括记忆化可以优化的冗余函数调用。与此同时，快速排序和归并排序是递归分而治之算法，但它们的子问题不重叠；它们是独特的。动态规划技术不适用于这些排序算法。'
- en: '![Tree diagram beginning with the Fibonacci function called with an argument
    of 6\. Two subsequent branches show the next calls to the Fibonacci function,
    with arguments of 5 and 4, respectively. The tree continues to branch until each
    branch ends with a value of 1\. Several branches are grayed out, indicating that
    the Fibonacci function was called with the same argument as a previous branch.](image_fi/502024c07/f07001.png)'
  id: totrans-1121
  prefs: []
  type: TYPE_IMG
  zh: '![以斐波那契函数以6为参数开始的树状图。两个后续分支显示了对斐波那契函数的下一个调用，参数分别为5和4。树继续分支，直到每个分支以值1结束。几个分支被标记为灰色，表明斐波那契函数以与先前分支相同的参数调用。](image_fi/502024c07/f07001.png)'
- en: 'Figure 7-1: A tree diagram of the recursive function calls made starting with
    `fibonacci(6)`. The redundant function calls are in gray.'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-1：从`fibonacci(6)`开始进行的递归函数调用的树状图。冗余的函数调用以灰色显示。
- en: One approach in dynamic programming is to memoize the recursive function so
    that previous calculations are remembered for future function calls. Overlapping
    subproblems become trivial if we can reuse previous return values.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划的一种方法是对递归函数进行记忆化，以便将先前的计算记住以供将来的函数调用使用。如果我们可以重用先前的返回值，重叠子问题就变得微不足道了。
- en: Using recursion with memoization is called *top-down dynamic programming*. This
    process takes a large problem and divides it into smaller overlapping subproblems.
    A contrasting technique, *bottom-up dynamic programming*, starts with the smaller
    subproblems (often related to the base case) and “builds up” to the solution of
    the original, large problem. The iterative Fibonacci algorithm, which begins with
    the base cases of the first and second Fibonacci numbers, is an example of bottom-up
    dynamic programming. Bottom-up approaches don’t use recursive functions.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用记忆化的递归称为*自顶向下动态规划*。这个过程将一个大问题分解成更小的重叠子问题。相反的技术，*自底向上动态规划*，从较小的子问题（通常与基本情况有关）开始，并“构建”到原始大问题的解决方案。从第一个和第二个斐波那契数作为基本情况开始的迭代斐波那契算法就是自底向上动态规划的一个例子。自底向上方法不使用递归函数。
- en: Note that there is no such thing as top-down recursion or bottom-up recursion.
    These are commonly used but incorrect terms. All recursion is already top-down,
    so *top-down recursion* is redundant. And no bottom-up approach uses recursion,
    so there’s no such thing as *bottom-up recursion*.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不存在自顶向下递归或自底向上递归。这些是常用但不正确的术语。所有递归已经是自顶向下的，因此*自顶向下递归*是多余的。而且没有底向上方法使用递归，因此没有*自底向上递归*这种东西。
- en: Memoization in Functional Programming
  id: totrans-1126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式编程中的记忆化
- en: Not all functions can be memoized. To see why, we must discuss *functional programming*,
    a programming paradigm that emphasizes writing functions that don’t modify global
    variables or any *external state* (such as files on the hard drive, internet connections,
    or database contents). Some programming languages, such as Erlang, Lisp, and Haskell,
    are heavily designed around functional programming concepts. But you can apply
    functional programming features to almost any programming language, including
    Python and JavaScript.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有函数都可以进行记忆化。为了理解原因，我们必须讨论*函数式编程*，这是一种强调编写不修改全局变量或任何*外部状态*（如硬盘上的文件、互联网连接或数据库内容）的函数的编程范式。一些编程语言，如Erlang、Lisp和Haskell，都是围绕函数式编程概念进行设计的。但你可以将函数式编程特性应用到几乎任何编程语言，包括Python和JavaScript。
- en: Functional programming includes the concepts of deterministic and nondeterministic
    functions, side effects, and pure functions. The `sqrt()` function mentioned in
    the introduction is a *deterministic* function because it always returns the same
    value when passed the same argument. However, Python’s `random.randint()` function,
    which returns a random integer, is *nondeterministic* because even when passed
    the same arguments, it can return different values. The `time.time()` function,
    which returns the current time, is also nondeterministic because time is constantly
    moving forward.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程包括确定性和非确定性函数、副作用和纯函数的概念。介绍中提到的`sqrt()`函数是一个*确定性*函数，因为当传入相同的参数时，它总是返回相同的值。然而，Python的`random.randint()`函数返回一个随机整数，是*非确定性*的，因为即使传入相同的参数，它也可能返回不同的值。`time.time()`函数返回当前时间，也是非确定性的，因为时间不断向前推移。
- en: '*Side effects* are any changes a function makes to anything outside of its
    own code and local variables. To illustrate this, let’s create a `subtract()`
    function that implements Python’s subtraction operator (`-`):'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '*副作用*是函数对其代码和局部变量之外的任何东西所做的任何更改。为了说明这一点，让我们创建一个实现Python减法运算符（`-`）的`subtract()`函数：'
- en: '**Python**'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE136]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This `subtract()` function has no side effects; calling this function doesn’t
    affect anything in the program outside of its code. There’s no way to tell from
    the program’s or the computer’s state whether the `subtract()` function has been
    called once, twice, or a million times before. A function might modify local variables
    inside the function, but these changes are local to the function and remain isolated
    from the rest of the program.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`subtract()`函数没有副作用；调用这个函数不会影响程序代码外的任何东西。从程序或计算机的状态来看，无法判断`subtract()`函数之前是否被调用过一次、两次或一百万次。函数可能会修改函数内部的局部变量，但这些更改是局限于函数内部的，并与程序的其余部分隔离开来。
- en: 'Now consider an `addToTotal()` function, which adds the numeric argument to
    a global variable named `TOTAL`:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个`addToTotal()`函数，它将数字参数添加到名为`TOTAL`的全局变量中：
- en: '**Python**'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE137]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The `addToTotal()` function does have a side effect, because it modifies an
    element that exists outside of the function: the `TOTAL` global variable.'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '`addToTotal()`函数确实有副作用，因为它修改了函数外存在的元素：`TOTAL`全局变量。'
- en: Side effects can be more than mere changes to global variables. They include
    updating or deleting files, printing text onscreen, opening a database connection,
    authenticating to a server, or any other manipulation of data outside of the function.
    Any trace that a function call leaves behind after returning is a side effect.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用不仅仅是对全局变量的简单更改。它还包括更新或删除文件、在屏幕上打印文本、打开数据库连接、对服务器进行身份验证，或者对函数外的数据进行任何其他操作。函数调用在返回后留下的任何痕迹都是副作用。
- en: If a function is deterministic and has no side effects, it’s known as a *pure
    function*. Only pure functions should be memoized. You’ll see why in the next
    sections when we memoize the recursive Fibonacci function and the impure functions
    of the `doNotMemoize` program.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数是确定性的，没有副作用，那么它被称为*纯函数*。只有纯函数应该被记忆化。在接下来的部分中，当我们对递归斐波那契函数和`doNotMemoize`程序的不纯函数进行记忆化时，你会明白为什么。
- en: Memoizing the Recursive Fibonacci Algorithm
  id: totrans-1139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记忆化递归斐波那契算法
- en: 'Let’s memoize our recursive Fibonacci function from Chapter 2. Remember that
    this function is extraordinarily inefficient: on my computer, the recursive `fibonacci(40)`
    call takes 57.8 seconds to compute. Meanwhile, an iterative version of `fibonacci(40)`
    is literally too fast for my code profiler to measure: 0.000 seconds.'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对第2章的递归斐波那契函数进行记忆化。请记住，这个函数非常低效：在我的计算机上，递归`fibonacci(40)`调用需要57.8秒来计算。与此同时，`fibonacci(40)`的迭代版本实际上太快了，以至于我的代码分析器无法测量：0.000秒。
- en: Memoization can greatly speed up the recursive version of the function. For
    example, [Figure 7-2](#figure7-2) shows the number of function calls the original
    and memoized `fibonacci()` functions make for the first 20 Fibonacci numbers.
    The original, non-memoized function is doing an extraordinary amount of unnecessary
    computation.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化可以极大地加速函数的递归版本。例如，[图7-2](#figure7-2)显示了原始和记忆化`fibonacci()`函数对前20个斐波那契数的函数调用次数。原始的、非记忆化的函数正在进行大量不必要的计算。
- en: The number of function calls sharply increases for the original `fibonacci()`
    function (top) but only slowly grows for the memoized `fibonacci()` function (bottom).
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`fibonacci()`函数的函数调用次数急剧增加（顶部），而记忆化的`fibonacci()`函数的函数调用次数增长缓慢（底部）。
- en: '![f07002a](image_fi/502024c07/f07002a.png)![Two graphs showing how the number
    of function calls increases as the number of Fibonacci numbers to calculate increases.
    The first graph increases rapidly to 14,000 function calls for the 20th Fibonacci
    number to calculate, while the second graph is linear, showing 20 function calls
    for the 20th Fibonacci number to calculate.](image_fi/502024c07/f07002b.png)'
  id: totrans-1143
  prefs: []
  type: TYPE_IMG
  zh: '![f07002a](image_fi/502024c07/f07002a.png)![两个图表显示随着要计算的斐波那契数的增加，函数调用次数的增加。第一个图表迅速增加到第20个要计算的斐波那契数的14,000次函数调用，而第二个图表是线性的，显示第20个要计算的斐波那契数有20次函数调用。](image_fi/502024c07/f07002b.png)'
- en: 'Figure 7-2: The number of function calls sharply increases for the original
    `fibonacci()` function (top) but grows only slowly for the memoized `fibonacci()`
    function (bottom).'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-2：原始的`fibonacci()`函数的函数调用次数急剧增加（顶部），而记忆化的`fibonacci()`函数的函数调用次数增长缓慢（底部）。
- en: 'The Python version of the memoized Fibonacci algorithm is in *fibonacciByRecursionMemoized.py*.
    The additions to the original *fibonacciByRecursion.html* program from Chapter
    2 have been marked in bold:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本的记忆化斐波那契算法在*fibonacciByRecursionMemoized.py*中。第2章原始*fibonacciByRecursion.html*程序的添加已用粗体标记：
- en: '[PRE138]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The JavaScript version of the memoized Fibonacci algorithm is in *fibonacciByRecursionMemoized.html*.
    The additions to the original *fibonacciByRecursion.html* program from Chapter
    2 have been marked in bold:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript版本的记忆化斐波那契算法在*fibonacciByRecursionMemoized.html*中。第2章原始*fibonacciByRecursion.html*程序的添加已用粗体标记：
- en: '**JavaScript**'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE139]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'If you compare the output of this program to the original recursive Fibonacci
    program in Chapter 2, you’ll find it’s much shorter. This reflects the massive
    reduction of computation needed to achieve the same results:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个程序的输出与第2章中的原始递归斐波那契程序进行比较，你会发现它要短得多。这反映了为达到相同结果所需的计算量的大幅减少：
- en: '[PRE140]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: To memoize this function, we’ll create a dictionary (in Python) or object (in
    JavaScript) in a global variable named `fibonacciCache` ❶. Its keys are the arguments
    passed for the `nthNumber` parameter, and its values are the integers returned
    by the `fibonacci()` function given that argument. Every function call first checks
    if its `nthNumber` argument is already in the cache. If so, the cached return
    value is returned ❷. Otherwise, the function runs as normal (though it also adds
    the result to the cache just before the function returns ❸ ❹).
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对这个函数进行记忆，我们将创建一个全局变量命名为`fibonacciCache`的字典（在Python中）或对象（在JavaScript中）❶。它的键是传递给`nthNumber`参数的参数，它的值是`fibonacci()`函数返回的整数，给定该参数。每个函数调用首先检查它的`nthNumber`参数是否已经在缓存中。如果是，缓存的返回值就会被返回❷。否则，函数会正常运行（尽管它也会在函数返回之前将结果添加到缓存中❸
    ❹）。
- en: 'The memoized function is effectively expanding the number of base cases in
    the Fibonacci algorithm. The original base cases are only for the first and second
    Fibonacci numbers: they immediately return `1`. But every time a recursive case
    returns an integer, it becomes a base case for all future `fibonacci()` calls
    with that argument. The result is already in `fibonacciCache` and can be immediately
    returned. If you’ve already called `fibonacci(99)` once before, it becomes a base
    case just like `fibonacci(1)` and `fibonacci(2)`. In other words, memoization
    improves the performance of recursive functions with overlapping subproblems by
    increasing the number of base cases. Notice that the second time our program tries
    to find the 10th Fibonacci number ❺, it immediately returns the memoized result:
    `55`.'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆函数实际上扩展了斐波那契算法中的基本情况数量。原始的基本情况只适用于第一个和第二个斐波那契数：它们立即返回`1`。但是，每当递归情况返回一个整数时，它就成为所有未来`fibonacci()`调用的基本情况。结果已经在`fibonacciCache`中，可以立即返回。如果您之前已经调用过`fibonacci(99)`，它就像`fibonacci(1)`和`fibonacci(2)`一样成为一个基本情况。换句话说，记忆通过增加基本情况的数量来改善具有重叠子问题的递归函数的性能。请注意，当我们的程序第二次尝试找到第10个斐波那契数时❺，它立即返回了记忆的结果：`55`。
- en: Keep in mind that while memoization can reduce the number of redundant function
    calls a recursive algorithm makes, it doesn’t necessarily reduce the growth of
    frame objects on the call stack. Memoization won’t prevent stack overflow errors.
    Once again, you may be better off forgoing a recursive algorithm for a more straightforward
    iterative one.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，虽然记忆可以减少递归算法所做的冗余函数调用的数量，但它不一定会减少调用堆栈上的帧对象的增长。记忆不会防止堆栈溢出错误。再次强调，您可能最好放弃递归算法，选择更直接的迭代算法。
- en: Python’s functools Module
  id: totrans-1155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python的functools模块
- en: Implementing a cache by adding a global variable and code to manage it for every
    function you’d like to memoize can be quite a chore. Python’s standard library
    has a `functools` module with a function decorator named `@lru_cache()` that automatically
    memoizes the function it decorates. In Python syntax, this means adding `@lru_cache()`
    to the line preceding the function’s `def` statement.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个全局变量和管理它的代码来为每个想要记忆的函数实现缓存可能会相当麻烦。Python的标准库有一个`functools`模块，其中有一个名为`@lru_cache()`的函数装饰器，它可以自动记忆它装饰的函数。在Python语法中，这意味着在函数的`def`语句之前添加`@lru_cache()`。
- en: The cache can have a memory size limit set. The *lru* in the decorator name
    stands for the *least recently used* cache replacement policy, meaning that the
    least recently used entry is replaced with new entries when the cache limit is
    reached. The LRU algorithm is simple and fast, though other cache replacement
    policies are available for different software requirements.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存可以设置内存大小限制。装饰器名称中的*lru*代表*最近最少使用*的缓存替换策略，这意味着当缓存达到限制时，最近最少使用的条目将被新条目替换。LRU算法简单快速，尽管其他缓存替换策略可用于不同的软件需求。
- en: 'The *fibonacciFunctools.py* program demonstrates the use of the `@lru_cache()`
    decorator. The additions to the original *fibonacciByRecursion.py* program from
    Chapter 2 have been marked in bold:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '*fibonacciFunctools.py*程序演示了`@lru_cache()`装饰器的使用。第2章中原始的*fibonacciByRecursion.py*程序的添加已经用粗体标记出来：'
- en: '**Python**'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE141]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Compared to the additions required to implement our own cache in *fibonacciByRecursionMemoized.py*,
    using Python’s `@lru_cache()` decorator is much simpler. Normally, calculating
    `fibonacci(99)` with the recursive algorithm would take a few centuries. With
    memoization, our program displays the `218922995834555169026` result in a few
    milliseconds.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 与在*fibonacciByRecursionMemoized.py*中实现自己的缓存所需的添加相比，使用Python的`@lru_cache()`装饰器要简单得多。通常，使用递归算法计算`fibonacci(99)`需要几个世纪。通过记忆，我们的程序在几毫秒内显示了`218922995834555169026`的结果。
- en: Memoization is a useful technique for recursive functions with overlapping subproblems,
    but it can be applied to any pure function to speed up runtime at the expense
    of computer memory.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆是一种对具有重叠子问题的递归函数很有用的技术，但它可以应用于任何纯函数，以加快运行时，代价是计算机内存。
- en: What Happens When You Memoize Impure Functions?
  id: totrans-1163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当您记忆不纯函数时会发生什么？
- en: You should not add the `@lru_cache` to functions that are not pure, meaning
    they are nondeterministic or have side effects. Memoization saves time by skipping
    the code in the function and returning the previously cached return value. This
    is fine for pure functions but can cause various bugs for impure functions.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应该将`@lru_cache`添加到不纯的函数中，这意味着它们是不确定的或具有副作用。记忆通过跳过函数中的代码并返回先前缓存的返回值来节省时间。这对于纯函数来说是可以的，但对于不纯函数可能会导致各种错误。
- en: 'In nondeterministic functions, such as a function that returns the current
    time, memoization causes the function to return incorrect results. For functions
    with side effects, such as printing text to the screen, memoization causes the
    function to skip the intended side effect. The *doNotMemoize.py* program demonstrates
    what happens when the `@lru_cache` function decorator (described in the previous
    section) memoizes these impure functions:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 在非确定性函数中，例如返回当前时间的函数，记忆化会导致函数返回不正确的结果。对于具有副作用的函数，例如向屏幕打印文本的函数，记忆化会导致函数跳过预期的副作用。*doNotMemoize.py*程序演示了当`@lru_cache`函数装饰器（在前一节中描述）记忆化这些不纯函数时会发生什么：
- en: '**Python**'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE142]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'When you run this program, the output looks like this:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此程序时，输出如下：
- en: '[PRE143]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Notice that the second call to `getCurrentTime()` returns the same result as
    the first call despite being called two seconds later. And of the two calls to
    `printMessage()`, only the first call results in displaying the `Hello, world!`
    message on the screen.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管第二次调用`getCurrentTime()`比第一次调用晚了两秒，但返回的结果相同。而对`printMessage()`的两次调用中，只有第一次调用会在屏幕上显示`Hello,
    world!`消息。
- en: These bugs are subtle because they don’t cause an obvious crash, but rather
    cause the functions to behave incorrectly. No matter how you memoize your functions,
    be sure to thoroughly test them.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误很微妙，因为它们不会导致明显的崩溃，而是导致函数的行为不正确。无论如何记忆化函数，一定要彻底测试它们。
- en: Summary
  id: totrans-1172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Memoization (not memorization) is an optimization technique that can speed up
    recursive algorithms that have overlapping subproblems by remembering the previous
    results of identical calculations. Memoization is a common technique in the field
    of dynamic programming. By trading computer memory usage for improved runtime,
    memoization makes some otherwise intractable recursive functions possible.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化（不是记忆）是一种优化技术，可以通过记住相同计算的先前结果来加速具有重叠子问题的递归算法。记忆化是动态规划领域的常见技术。通过交换计算机内存使用量以改善运行时间，记忆化使一些原本难以处理的递归函数成为可能。
- en: However, memoization won’t prevent stack overflow errors. Keep in mind that
    memoization is not a replacement for using a simple iterative solution. Code that
    uses recursion for the sake of recursion is not automatically more elegant than
    non-recursive code.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，记忆化不能防止堆栈溢出错误。请记住，记忆化并不是使用简单迭代解决方案的替代品。仅仅为了使用递归而使用递归的代码并不会自动比非递归代码更加优雅。
- en: Memoized functions must be pure—that is, they must be deterministic (returning
    the same values given the same arguments each time) and not have side effects
    (affecting anything about the computer or program outside of the function). Pure
    functions are often used in functional programming, which is a programming paradigm
    that makes heavy use of recursion.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化函数必须是纯函数——即它们必须是确定性的（每次给定相同的参数返回相同的值）并且不能具有副作用（影响函数之外的计算机或程序的任何内容）。纯函数通常在函数式编程中使用，函数式编程大量使用递归。
- en: Memoization is implemented by creating a data structure called a *cache* for
    each function to memoize. You can write this code yourself, but Python has a built-in
    `@functools.lru_cache()` decorator that can automatically memoize the function
    it decorates.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是通过为每个要记忆化的函数创建一个称为*缓存*的数据结构来实现的。您可以自己编写此代码，但Python具有内置的`@functools.lru_cache()`装饰器，可以自动记忆化它装饰的函数。
- en: Further Reading
  id: totrans-1177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: There’s more to dynamic programming algorithms than simply memoizing functions.
    These algorithms are often used in both coding interviews and programming competitions.
    Coursera offers a free “Dynamic Programming, Greedy Algorithms” course at [https://www.coursera.org/learn/dynamic-programming-greedy-algorithms](https://www.coursera.org/learn/dynamic-programming-greedy-algorithms).
    The freeCodeCamp organization also has a series on dynamic programming at [https://www.freecodecamp.org/news/learn-dynamic-programing-to-solve-coding-challenges](https://www.freecodecamp.org/news/learn-dynamic-programing-to-solve-coding-challenges).
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划算法不仅仅是简单地记忆化函数。这些算法通常在编程面试和编程竞赛中使用。Coursera提供了一个免费的“动态规划，贪婪算法”课程[https://www.coursera.org/learn/dynamic-programming-greedy-algorithms](https://www.coursera.org/learn/dynamic-programming-greedy-algorithms)。freeCodeCamp组织还在[https://www.freecodecamp.org/news/learn-dynamic-programing-to-solve-coding-challenges](https://www.freecodecamp.org/news/learn-dynamic-programing-to-solve-coding-challenges)上推出了一系列关于动态规划的课程。
- en: If you’d like to learn more about the LRU cache and other cache-related functions,
    the official Python documentation for the `functools` module is at [https://docs.python.org/3/library/functools.html](https://docs.python.org/3/library/functools.html).
    More information about other kinds of cache replacement algorithms is mentioned
    on Wikipedia at [https://en.wikipedia.org/wiki/Cache_replacement_policies](https://en.wikipedia.org/wiki/Cache_replacement_policies).
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关LRU缓存和其他与缓存相关的函数的更多信息，请参阅官方Python文档中的`functools`模块[https://docs.python.org/3/library/functools.html](https://docs.python.org/3/library/functools.html)。有关其他类型的缓存替换算法的更多信息，请参阅维基百科[https://en.wikipedia.org/wiki/Cache_replacement_policies](https://en.wikipedia.org/wiki/Cache_replacement_policies)。
- en: Practice Questions
  id: totrans-1180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习问题
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试您的理解：
- en: What is memoization?
  id: totrans-1182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是记忆化？
- en: How do dynamic programming problems differ from regular recursion problems?
  id: totrans-1183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态规划问题与常规递归问题有何不同？
- en: What does functional programming emphasize?
  id: totrans-1184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程强调什么？
- en: What two characteristics must a function have in order to be a pure function?
  id: totrans-1185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个函数必须具备哪两个特征才能成为纯函数？
- en: Is a function that returns the current date and time a deterministic function?
  id: totrans-1186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回当前日期和时间的函数是确定性函数吗？
- en: How does memoization improve the performance of recursive functions with overlapping
    subproblems?
  id: totrans-1187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记忆化如何改善具有重叠子问题的递归函数的性能？
- en: Would adding the `@lru_cache()` function decorator to a merge sort function
    improve its performance? Why or why not?
  id: totrans-1188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`@lru_cache()`函数装饰器添加到归并排序函数中会提高其性能吗？为什么？
- en: Is changing the value in a function’s local variable an example of a side effect?
  id: totrans-1189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数的局部变量中改变值是副作用的一个例子吗？
- en: Does memoization prevent stack overflows?
  id: totrans-1190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记忆化能防止堆栈溢出吗？
- en: '8'
  id: totrans-1191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Tail Call Optimization
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 尾调用优化
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-1193
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In the previous chapter, we covered using memoization to optimize recursive
    functions. This chapter explores a technique called *tail call optimization*,
    which is a feature provided by a compiler or interpreter to avoid stack overflows.
    Tail call optimization is also called *tail call elimination*, or *tail recursion
    elimination*.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了使用记忆化来优化递归函数。本章探讨了一种称为*尾调用优化*的技术，这是编译器或解释器提供的一种功能，用于避免堆栈溢出。尾调用优化也称为*尾调用消除*或*尾递归消除*。
- en: This chapter is meant to explain tail call optimization, not to endorse it.
    I would go so far as to recommend *never* using tail call optimization. As you’ll
    see, rearranging your function’s code to use tail call optimization often makes
    it far less understandable. You should consider tail call optimization to be more
    of a hack or workaround to make recursion work when you shouldn’t be using a recursive
    algorithm in the first place. Remember, a complex recursive solution is not automatically
    an elegant solution; simple coding problems should be solved with simple non-recursive
    methods.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在解释尾调用优化，而不是为其背书。我甚至会建议*永远*不要使用尾调用优化。正如你将看到的，重新排列函数的代码以使用尾调用优化通常会使其变得难以理解。你应该考虑尾调用优化更像是一种黑客或变通方法，用于使递归在你本不应该使用递归算法的情况下工作。记住，一个复杂的递归解决方案并不自动成为一个优雅的解决方案；简单的编码问题应该用简单的非递归方法来解决。
- en: Many implementations of popular programming languages don’t even offer tail
    call optimization as a feature. These include interpreters and compilers for Python,
    JavaScript, and Java. However, tail call optimization is a technique you should
    become familiar with in case you come across it in the code projects you work
    on.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 许多流行编程语言的实现甚至不提供尾调用优化作为一项功能。这些包括Python、JavaScript和Java的解释器和编译器。然而，尾调用优化是一种你应该熟悉的技术，以防你在你的代码项目中遇到它。
- en: How Tail Recursion and Tail Call Optimization Work
  id: totrans-1197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归和尾调用优化的工作原理
- en: To make use of tail call optimization, a function must use *tail recursion**.*
    In tail recursion, the recursive function call is the last action of a recursive
    function. In code, this looks like a `return` statement returning the results
    of a recursive call.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用尾调用优化，一个函数必须使用*尾递归*。在尾递归中，递归函数调用是递归函数的最后一个操作。在代码中，这看起来像是一个`return`语句返回递归调用的结果。
- en: To see this in action, recall the *factorialByRecursion.py* and *factorialByRecursion.html*
    programs in Chapter 2. These programs calculated the factorial of an integer;
    for instance, 5! is equivalent to 5 × 4 × 3 × 2 × 1, or 120\. These calculations
    can be performed recursively because `factorial(n)` is equivalent to `n * factorial(n
    - 1)`, with the base case of `n == 1` returning `1`.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个过程，回想一下第2章中的*factorialByRecursion.py*和*factorialByRecursion.html*程序。这些程序计算了一个整数的阶乘；例如，5！等于5
    × 4 × 3 × 2 × 1，即120。这些计算可以通过递归来进行，因为`factorial(n)`等同于`n * factorial(n - 1)`，其中`n
    == 1`是基本情况，返回`1`。
- en: 'Let’s rewrite these programs to use tail recursion. The following *factorialTailCall.py*
    program has a `factorial()` function that uses tail recursion:'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写这些程序以使用尾递归。下面的*factorialTailCall.py*程序有一个使用尾递归的`factorial()`函数：
- en: '**Python**'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE144]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The *factorialTailCall.html* program has the equivalent JavaScript code:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: '*factorialTailCall.html*程序有等效的JavaScript代码：'
- en: '**JavaScript**'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE145]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Notice that the `factorial()` function’s recursive case ends with a `return`
    statement returning the results of a recursive call to `factorial()`. To allow
    the interpreter or compiler to implement tail call optimization, the last action
    a recursive function makes must be to return the results of the recursive call.
    No instructions can occur between making the recursive call and the `return` statement.
    The base case returns the `accum` parameter. This is the accumulator, explained
    in the next section.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`factorial()`函数的递归情况以`return`语句结束，返回对`factorial()`的递归调用的结果。为了允许解释器或编译器实现尾调用优化，递归函数所做的最后一个操作必须是返回递归调用的结果。在进行递归调用和`return`语句之间不能发生任何指令。基本情况返回`accum`参数。这是累加器，在下一节中解释。
- en: To understand how tail call optimization works, remember from Chapter 1 what
    happens when a function is called. First, a frame object is created and stored
    on the call stack. If the function call calls another function, another frame
    object is created and placed on top of the first frame object on the call stack.
    When a function returns, your program automatically deletes the frame object from
    the top of the stack.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解尾调用优化的工作原理，记住第1章中函数调用时发生了什么。首先，创建一个帧对象并将其存储在调用堆栈上。如果函数调用另一个函数，将创建另一个帧对象并将其放在调用堆栈的第一个帧对象的顶部。当函数返回时，你的程序会自动从调用堆栈的顶部删除帧对象。
- en: A stack overflow happens when too many function calls are made without returning,
    causing the number of frame objects to exceed the capacity of the call stack.
    This capacity is 1,000 function calls for Python and about 10,000 for JavaScript
    programs. While these amounts are more than enough for typical programs, recursive
    algorithms could exceed this limit and cause a stack overflow that crashes your
    program.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈溢出发生在太多的函数调用没有返回的情况下，导致帧对象的数量超过调用堆栈的容量。对于Python来说，这个容量是1,000个函数调用，对于JavaScript程序来说大约是10,000个。虽然这些数量对于典型程序来说已经足够了，但递归算法可能会超过这个限制，导致堆栈溢出，从而使你的程序崩溃。
- en: Recall from Chapter 2 that a frame object stores the local variables in the
    function call as well as the return address of the instruction to return to when
    the function finishes. However, if the last action in the recursive case of a
    function is to return the results of a recursive function call, there’s no need
    to retain the local variables. The function does nothing involving the local variables
    after the recursive call, so the current frame object can be deleted immediately.
    The next frame object’s return address information can be the same as the old
    deleted frame object’s return address.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第2章，帧对象存储了函数调用中的局部变量，以及函数完成时返回的指令地址。然而，如果函数递归情况中的最后一个动作是返回递归函数调用的结果，就没有必要保留局部变量。函数在递归调用之后不涉及任何局部变量，因此当前帧对象可以立即被删除。下一个帧对象的返回地址信息可以与被删除的旧帧对象的返回地址相同。
- en: Since the current frame object is deleted instead of retained on the call stack,
    the call stack never grows in size and can never cause a stack overflow!
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当前帧对象被删除而不是保留在调用堆栈上，调用堆栈永远不会增长并且永远不会导致堆栈溢出！
- en: Recall from Chapter 1 that all recursive algorithms can be implemented with
    a stack and a loop. Since tail call optimization removes the need for a call stack,
    we are effectively using recursion to simulate a loop’s iterative code. However,
    earlier in this book I stated that the problems suitable for recursive solutions
    involve a tree-like data structure and backtracking. Without a call stack, no
    tail recursive function could possibly do any backtracking work. In my view, every
    algorithm that can be implemented with tail recursion would be easier and more
    readable to implement with a loop instead. There’s nothing automatically more
    elegant about using recursion for recursion’s sake.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第1章，所有递归算法都可以使用堆栈和循环来实现。由于尾调用优化消除了对调用堆栈的需求，我们实际上是在使用递归来模拟循环的迭代代码。然而，在本书的前面，我曾经说过适合递归解决方案的问题涉及类似树的数据结构和回溯。没有调用堆栈，没有尾递归函数可能做任何回溯工作。在我看来，每个可以使用尾递归实现的算法都更容易和更可读地使用循环来实现。仅仅因为递归而使用递归并不会自动更加优雅。
- en: Accumulators in Tail Recursion
  id: totrans-1212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归中的累加器
- en: The disadvantage of tail recursion is that it requires rearranging your recursive
    function so that the last action is returning the recursive call’s return value.
    This can make our recursive code even more unreadable. Indeed, the `factorial()`
    function in this chapter’s *factorialTailCall.py* and *factorialTailCall.html*
    programs is a bit harder to comprehend than the version in Chapter 2’s *factorialByRecursion.py*
    and *factorialByRecursion.html* programs.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归的缺点在于它要求重新排列递归函数，使得最后一个动作是返回递归调用的返回值。这会使我们的递归代码变得更加难以阅读。事实上，本章的*factorialTailCall.py*和*factorialTailCall.html*程序中的`factorial()`函数比第2章的*factorialByRecursion.py*和*factorialByRecursion.html*程序中的版本更难理解一些。
- en: In the case of our tail call `factorial()` function, a new parameter named `accum`
    follows the calculated product as recursive function calls are made. This is known
    as an *accumulator* parameter, and it keeps track of a partial result of a calculation
    that would otherwise have been stored in a local variable. Not all tail recursive
    functions use accumulators, but they act as a workaround for tail recursion’s
    inability to use local variables after the final recursive call. Notice that in
    *factorialByRecursion.py*’s `factorial()` function, the recursive case was `return
    number * factorial(number - 1)`. The multiplication happens after the `factorial(number
    - 1)` recursive call. The `accum` accumulator takes the place of the `number`
    local variable.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的尾调用`factorial()`函数中，一个名为`accum`的新参数跟随着递归函数调用产生的计算结果。这被称为*累加器*参数，它跟踪了一个计算的部分结果，否则这个结果将会被存储在一个局部变量中。并不是所有的尾递归函数都使用累加器，但它们充当了尾递归无法在最后的递归调用之后使用局部变量的一种变通方法。请注意，在*factorialByRecursion.py*的`factorial()`函数中，递归情况是`return
    number * factorial(number - 1)`。乘法发生在`factorial(number - 1)`递归调用之后。`accum`累加器取代了`number`局部变量的位置。
- en: Also notice that the base case for `factorial()` no longer returns `1`; rather,
    it returns the `accum` accumulator. By the time `factorial()` is called with `number
    == 1` and the base case is reached, `accum` stores the final result to return.
    Adjusting your code to use tail call optimization often involves changing the
    base case to return the accumulator’s value.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`factorial()`的基本情况不再返回`1`，而是返回`accum`累加器。当`factorial()`被调用时，`number ==
    1`并且达到基本情况时，`accum`存储了要返回的最终结果。调整代码以使用尾调用优化通常涉及更改基本情况以返回累加器的值。
- en: You can think of the `factorial(5)` function call as transforming into the following
    `return`, as shown in [Figure 8-1](#figure8-1).
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把`factorial(5)`函数调用看作是转换成以下的`return`，如[图8-1](#figure8-1)所示。
- en: '![Diagram showing the return statements produced by the factorial function
    called with an argument of 5, in order: “return factorial(5 - 1, 1* 5),” “return
    factorial(4 -1, 5 * 4),” “return factorial(3 - 1, 20 * 3),” “return factorial(2
    - 1, 60 * 2),” “return 120.”](image_fi/502024c08/f08001.png)'
  id: totrans-1217
  prefs: []
  type: TYPE_IMG
  zh: '![图表显示了使用参数5调用阶乘函数产生的返回语句，顺序为：“return factorial(5 - 1, 1* 5),” “return factorial(4
    -1, 5 * 4),” “return factorial(3 - 1, 20 * 3),” “return factorial(2 - 1, 60 *
    2),” “return 120.”](image_fi/502024c08/f08001.png)'
- en: 'Figure 8-1: The process of transformations that `factorial(5)` makes to the
    integer 120'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-1：`factorial(5)`转换为整数120的过程
- en: Rearranging your recursive calls as the last action in the function and adding
    accumulators can make your code even harder to understand than typical recursive
    code. But that’s not the only downside of tail recursion, as we’ll see in the
    next section.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 重新排列递归调用作为函数中的最后一个动作，并添加累加器，会使你的代码变得比典型的递归代码更难理解。但这并不是尾递归的唯一缺点，我们将在下一节中看到。
- en: Limitations of Tail Recursion
  id: totrans-1220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归的限制
- en: Tail recursive functions require rearranging their code to make them suitable
    for the tail call optimization feature of the compiler or interpreter. However,
    not all compilers and interpreters offer tail call optimization as a feature.
    Notably, CPython (the Python interpreter downloaded from [https://python.org](https://python.org))
    does not implement tail call optimization. Even if you write your recursive functions
    with the recursive call as the last action, it will still cause stack overflows
    after enough function calls are made.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归函数需要重新排列它们的代码，使其适合编译器或解释器的尾调用优化功能。然而，并非所有编译器和解释器都提供尾调用优化作为一项功能。值得注意的是，CPython（从[https://python.org](https://python.org)下载的Python解释器）不实现尾调用优化。即使你将递归函数写成递归调用作为最后一个动作，它仍会在足够多的函数调用后导致堆栈溢出。
- en: Not only that, but CPython will likely never have tail call optimization as
    a feature. Guido van Rossum, the creator of the Python programming language, has
    explained that tail call optimization can make programs harder to debug. Tail
    call optimization removes frame objects from the call stack, which in turn removes
    the debugging information that frame objects can provide. He also points out that
    once tail call optimization is implemented, Python programmers will begin to write
    code that depends on the feature, and their code won’t run on non-CPython interpreters
    that don’t implement tail call optimization.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CPython可能永远不会将尾调用优化作为一项功能。Python编程语言的创始人Guido van Rossum解释说，尾调用优化可能会使程序更难调试。尾调用优化会从调用堆栈中移除帧对象，从而移除帧对象可以提供的调试信息。他还指出，一旦实现了尾调用优化，Python程序员将开始编写依赖于该功能的代码，他们的代码将无法在不实现尾调用优化的非CPython解释器上运行。
- en: Finally, and I concur, van Rossum disagrees with the idea that recursion is
    a fundamentally important part of day-to-day programming. Computer scientists
    and mathematicians tend to place recursion on a pedestal. But tail call optimization
    is simply a workaround hack to make some recursive algorithms actually workable,
    rather than simply crashing with a stack overflow.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我同意，van Rossum不同意递归是日常编程的基本重要部分的观点。计算机科学家和数学家倾向于把递归放在一个高位。但尾调用优化只是一个解决方案，使一些递归算法实际可行，而不是简单地因堆栈溢出而崩溃。
- en: While CPython doesn’t feature tail call optimization, this doesn’t mean another
    compiler or interpreter that implements the Python language couldn’t have tail
    call optimization. Unless tail call optimization is explicitly a part of a programming
    language specification, it is not a feature of a programming language, but rather
    of individual compilers or interpreters of a programming language.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CPython不支持尾调用优化，但这并不意味着实现Python语言的其他编译器或解释器不能具有尾调用优化。除非尾调用优化明确地成为编程语言规范的一部分，否则它不是编程语言的特性，而是编程语言的个别编译器或解释器的特性。
- en: The lack of tail call optimization is not unique to Python. The Java compiler
    since version 8 also doesn’t support tail call optimization. Tail call optimization
    is a part of the ECMAScript 6 version of JavaScript; however, as of 2022, only
    the Safari web browser’s implementation of JavaScript actually supports it. One
    way to determine whether your programming language’s compiler or interpreter implements
    this feature is to write a tail recursive factorial function and try to calculate
    the factorial of 100,000\. If the program crashes, tail call optimization is not
    implemented.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏尾调用优化并不是Python独有的。自第8版以来，Java编译器也不支持尾调用优化。尾调用优化是JavaScript的ECMAScript 6版本的一部分；然而，截至2022年，只有Safari浏览器的JavaScript实现实际上支持它。确定你的编程语言的编译器或解释器是否实现了这一功能的一种方法是编写一个尾递归阶乘函数，尝试计算100,000的阶乘。如果程序崩溃，那么尾调用优化没有被实现。
- en: Personally, I take the stance that the tail recursion technique should never
    be used. As stated in Chapter 2, any recursive algorithm can be implemented with
    a loop and a stack. Tail call optimization prevents stack overflows by effectively
    removing the use of the call stack. Therefore, all tail recursive algorithms can
    be implemented with a loop alone. Since the code for loops is much simpler than
    a recursive function, a loop should be used wherever tail call optimization could
    be employed.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我认为尾递归技术不应该被使用。正如第2章所述，任何递归算法都可以用循环和堆栈来实现。尾调用优化通过有效地移除调用堆栈来防止堆栈溢出。因此，所有尾递归算法都可以仅用循环来实现。由于循环的代码比递归函数简单得多，应该在任何可以使用尾调用优化的地方使用循环。
- en: Additionally, potential problems exist even if tail call optimization is implemented.
    Since tail recursion is possible only when the last action of a function is returning
    the recursive call’s return value, it’s impossible to do tail recursion for algorithms
    that require two or more recursive calls. For example, take the Fibonacci sequence
    algorithm calls `fibonacci(n - 1)` and `fibonacci(n - 2)`. While tail call optimization
    can be performed for the latter recursive call, the first recursive call will
    cause a stack overflow for large-enough arguments.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使实现了尾调用优化，也可能存在潜在问题。由于尾递归仅在函数的最后一个动作是返回递归调用的返回值时才可能发生，因此对于需要两个或更多递归调用的算法来说，尾递归是不可能的。例如，考虑斐波那契数列算法调用`fibonacci(n
    - 1)`和`fibonacci(n - 2)`。尽管后者的递归调用可以进行尾调用优化，但对于足够大的参数，第一个递归调用将导致堆栈溢出。
- en: Tail Recursion Case Studies
  id: totrans-1228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归案例研究
- en: Let’s examine some of the recursive functions demonstrated earlier in this book
    to see if they are good candidates for tail recursion. Keep in mind that because
    Python and JavaScript do not actually implement tail call optimization, these
    tail recursive functions will still result in a stack overflow error. These case
    studies are for demonstration purposes only.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查一些在本书中早些时候展示的递归函数，看看它们是否适合尾递归。请记住，由于Python和JavaScript实际上并未实现尾调用优化，这些尾递归函数仍然会导致堆栈溢出错误。这些案例研究仅用于演示目的。
- en: Tail Recursive Reverse String
  id: totrans-1230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尾递归反转字符串
- en: 'The first example is the program to reverse a string that we made in Chapter
    3. The Python code for this tail recursive function is in *reverseStringTailCall.py*:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子是我们在第3章中制作的反转字符串的程序。这个尾递归函数的Python代码在*reverseStringTailCall.py*中：
- en: '**Python**'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE146]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The JavaScript equivalent is in *reverseStringTailCall.html*:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的JavaScript在*reverseStringTailCall.html*中：
- en: '**JavaScript**'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE147]'
  id: totrans-1236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The conversion of the original recursive functions in *reverseString.py* and
    *reverseString.html* involves adding an accumulator parameter. The accumulator,
    named `accum`, is set to the blank string by default if no argument is passed
    for it ❶. We also change the base case from `return ''` to `return accum` ❷, and
    the recursive case from `return rev(tail) + head` (which performs a string concatenation
    after the recursive call returns) to `return rev(tail, head + accum)` ❸. You can
    think of the `rev('abcdef')` function call as transforming into the following
    `return`, as shown in [Figure 8-2](#figure8-2).
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 将*reverseString.py*和*reverseString.html*中的原始递归函数转换为涉及添加累加器参数。如果没有为它传递参数，则默认情况下将累加器命名为`accum`，设置为空字符串❶。我们还将基本情况从`return
    ''`更改为`return accum`❷，将递归情况从`return rev(tail) + head`（在递归调用返回后执行字符串连接）更改为`return
    rev(tail, head + accum)`❸。您可以将`rev('abcdef')`函数调用视为转换为以下`return`，如[图8-2](#figure8-2)所示。
- en: By effectively using the accumulator as a local variable shared across function
    calls, we can make the `rev()` function tail recursive.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有效地使用累加器作为跨函数调用共享的本地变量，我们可以使`rev()`函数成为尾递归。
- en: '![Diagram showing the return statements produced by the rev() function called
    with an argument of abcdef, in order: “return rev(‘bcdef’, ‘a’, + ‘’),” “return
    rev(‘cdef’, ‘b’ + ‘a’),” “return rev(‘def’, ‘c’ + ‘ba’),” “return rev(‘ef’, ‘d’
    + ‘cba’),” “return rev(‘f’, ‘e’ + ‘dcba’),” “return rev(‘’, ‘f’, ‘edcba’),” “return
    ‘fedcba’.”](image_fi/502024c08/f08002.png)'
  id: totrans-1239
  prefs: []
  type: TYPE_IMG
  zh: '![图表显示了rev()函数使用abcdef参数产生的返回语句，顺序为：“return rev(‘bcdef’, ‘a’, + ‘’),”“return
    rev(‘cdef’, ‘b’ + ‘a’),”“return rev(‘def’, ‘c’ + ‘ba’),”“return rev(‘ef’, ‘d’
    + ‘cba’),”“return rev(‘f’, ‘e’ + ‘dcba’),”“return rev(‘’, ‘f’, ‘edcba’),”“return
    ‘fedcba’。”](image_fi/502024c08/f08002.png)'
- en: 'Figure 8-2: The process of transformations that `rev(''abcdef'')` makes to
    the string `fedcba`'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-2：`rev('abcdef')`对字符串`fedcba`进行的转换过程
- en: Tail Recursive Find Substring
  id: totrans-1241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尾递归查找子字符串
- en: Some recursive functions naturally end up using the tail recursion pattern.
    If you look at the `findSubstringRecursive()` function in the *findSubstring.py*
    and *findSubstring.html* programs in Chapter 2, you’ll notice that the last action
    for the recursive case is to return the value of the recursive function call.
    No adjustments are needed to make this function tail recursive.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 一些递归函数自然地使用尾递归模式。如果您查看第2章中*findSubstring.py*和*findSubstring.html*程序中的`findSubstringRecursive()`函数，您会注意到递归情况的最后操作是返回递归函数调用的值。不需要进行任何调整使此函数成为尾递归。
- en: Tail Recursive Exponents
  id: totrans-1243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尾递归指数
- en: 'The *exponentByRecursion.py* and *exponentByRecursion.html* programs, also
    from Chapter 2, are not good candidates for tail recursion. These programs have
    two recursive cases for when the `n` parameter is even or odd. This is fine: as
    long as all the recursive cases return the return value of the recursive function
    call as their last action, the function can use tail call optimization.'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '*exponentByRecursion.py*和*exponentByRecursion.html*程序，也来自第2章，不是尾递归的好候选。这些程序有两个递归情况，当`n`参数为偶数或奇数时。这没问题：只要所有递归情况都将递归函数调用的返回值作为它们的最后操作，函数就可以使用尾调用优化。'
- en: 'However, notice the Python code for the `n is even` recursive case:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意`n为偶数`的Python代码递归情况：
- en: '**Python**'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE148]'
  id: totrans-1247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'And notice the equivalent JavaScript recursive case:'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 并注意等效的JavaScript递归情况：
- en: '**JavaScript**'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE149]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'This recursive case does not have the recursive call as its last action. We
    could get rid of the `result` local variable, and instead call the recursive function
    twice. This would reduce the recursive case to the following:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归情况没有递归调用作为它的最后操作。我们可以摆脱`result`本地变量，而是两次调用递归函数。这将减少递归情况到以下内容：
- en: '[PRE150]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'However, now we have two recursive calls to `exponentByRecursion()`. Not only
    does this needlessly double the amount of computation the algorithm performs,
    but the last action performed by the function is to multiply the two return values.
    This is the same problem the recursive Fibonacci algorithm has: if the recursive
    function has multiple recursive calls, at least one of those recursive calls can’t
    be the last action of the function.'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，现在我们有两个对`exponentByRecursion()`的递归调用。这不仅使算法执行的计算量翻倍，而且函数执行的最后操作是将两个返回值相乘。这与递归斐波那契算法的问题相同：如果递归函数有多个递归调用，那么至少有一个递归调用不能是函数的最后操作。
- en: Tail Recursive Odd-Even
  id: totrans-1254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尾递归奇偶数
- en: 'To determine whether an integer is odd or even, you can use the `%` modulus
    operator. The expression `number % 2 == 0` will be `True` if `number` is even,
    and `False` if `number` is odd. However, if you’d prefer to overengineer a more
    “elegant” recursive algorithm, you can implement the following `isOdd()` function
    in *isOdd.py* (the rest of *isOdd.py* is presented later in this section):'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定一个整数是奇数还是偶数，可以使用`％`模数运算符。表达式`number％2 == 0`如果`number`是偶数，则为`True`，如果`number`是奇数，则为`False`。但是，如果您更喜欢过度设计更“优雅”的递归算法，可以在*isOdd.py*中实现以下`isOdd()`函数（*isOdd.py*的其余部分稍后在本节中介绍）：
- en: '**Python**'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE151]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'The JavaScript equivalent is in *isOdd.html*:'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的JavaScript在*isOdd.html*中：
- en: '**JavaScript**'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE152]'
  id: totrans-1260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: We have two base cases for `isOdd()`. When the `number` argument is `0`, the
    function returns `False` to indicate *even*. For simplicity, our implementation
    of `isOdd()` works for only positive integers. The recursive case returns the
    opposite of `isOdd(number - 1)`.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个`isOdd()`的基本情况。当`number`参数为`0`时，函数返回`False`以表示*偶数*。为简单起见，我们的`isOdd()`实现仅适用于正整数。递归情况返回`isOdd(number
    - 1)`的相反值。
- en: 'You can see why this works with an example: when `isOdd(42)` is called, the
    function can’t determine if `42` is even or odd but does know that the answer
    is the opposite of whether `41` is odd or even. The function will return `not
    isOdd(41)`. This function call, in turn, returns the opposite Boolean value of
    `isOdd(40)`, and so on, until `isOdd(0)` returns `False`. The number of recursive
    function calls determines the number of `not` operators that act on return values
    before the final return value is returned.'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过一个例子看到这是如何工作的：当调用`isOdd(42)`时，函数无法确定`42`是偶数还是奇数，但知道答案与`41`是奇数还是偶数相反。函数将返回`not
    isOdd(41)`。这个函数调用，反过来返回`isOdd(40)`的相反布尔值，依此类推，直到`isOdd(0)`返回`False`。递归函数调用的数量决定了在最终返回值返回之前作用于返回值的`not`运算符的数量。
- en: 'However, this recursive function results in stack overflows for large-number
    arguments. Calling `isOdd(100000)` results in 100,001 function calls without returning—which
    far exceeds the capacity of any call stack. We can rearrange the code in the function
    so that the last action of the recursive case is returning the results of the
    recursive function call, making the function tail recursive. We do this in `isOddTailCall()`
    in *isOdd.py*. Here is the rest of the *isOdd.py* program:'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个递归函数对于大数参数会导致堆栈溢出。调用`isOdd(100000)`会导致100,001个函数调用而没有返回，这远远超出了任何调用堆栈的容量。我们可以重新排列函数中的代码，使递归情况的最后一个操作是返回递归函数调用的结果，使函数成为尾递归。我们在*isOdd.py*中的`isOddTailCall()`中这样做。以下是*isOdd.py*程序的其余部分：
- en: '**Python**'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE153]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The JavaScript equivalent is in the rest of *isOdd.html*:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript等效代码在*isOdd.html*的其余部分中：
- en: '**JavaScript**'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE154]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: If this Python and JavaScript code is run by an interpreter that supports tail
    call optimization, calling `isOddTailCall(100000)` won’t result in a stack overflow.
    However, tail call optimization is still much slower than simply using the `%`
    modulus operator to determine oddness or evenness.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个Python和JavaScript代码是由支持尾调用优化的解释器运行的，调用`isOddTailCall(100000)`不会导致堆栈溢出。然而，尾调用优化仍然比简单使用`％`模运算符确定奇偶性要慢得多。
- en: If you think recursion, with or without tail recursion, is an incredibly inefficient
    way to determine whether a positive integer is odd, you are absolutely correct.
    Unlike iterative solutions, recursion can fail from stack overflows. Adding tail
    call optimization to prevent stack overflows doesn’t fix the efficiency flaws
    of using recursion inappropriately. As a technique, recursion is not automatically
    better or more sophisticated than iterative solutions. And tail recursion is never
    a better approach than a loop or other simple solution.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为递归，无论是否有尾递归，是确定正整数是否为奇数的一种极其低效的方法，那么您是完全正确的。与迭代解决方案不同，递归可能会因堆栈溢出而失败。添加尾调用优化以防止堆栈溢出并不能修复不适当使用递归的效率缺陷。作为一种技术，递归并不自动比迭代解决方案更好或更复杂。而且尾递归永远不是比循环或其他简单解决方案更好的方法。
- en: Summary
  id: totrans-1271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Tail call optimization is a feature of a programming language’s compiler or
    interpreter that can be employed on recursive functions specifically written to
    be tail recursive. Tail recursive functions return the return value of the recursive
    function call as the last action in the recursive case. This allows the function
    to delete the current frame object and prevent the call stack from growing as
    new recursive function calls are made. If the call stack doesn’t grow, the recursive
    function can’t possibly cause a stack overflow.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 尾调用优化是编程语言的编译器或解释器的一个特性，可以用于特别编写为尾递归的递归函数。尾递归函数将递归函数调用的返回值作为递归情况中的最后一个操作返回。这允许函数删除当前帧对象，并防止调用堆栈在进行新的递归函数调用时增长。如果调用堆栈不增长，递归函数不可能导致堆栈溢出。
- en: Tail recursion is a workaround that allows some recursive algorithms to work
    with large arguments without crashing. However, this approach requires rearranging
    your code and possibly adding an accumulator parameter. This could make your code
    harder to understand. You may likely find that sacrificing code readability is
    not worth using a recursive algorithm over an iterative one.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归是一种解决方案，允许一些递归算法在处理大参数时不会崩溃。然而，这种方法需要重新排列代码，可能需要添加一个累加器参数。这可能会使您的代码更难理解。您可能会发现，牺牲代码的可读性不值得使用递归算法而不是迭代算法。
- en: Further Reading
  id: totrans-1274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Stack Overflow (the website, not the programming error) has a detailed discussion
    about the basics of tail recursion at [https://stackoverflow.com/questions/33923/what-is-tail-recursion](https://stackoverflow.com/questions/33923/what-is-tail-recursion).
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: Stack Overflow（网站，而不是编程错误）在[https://stackoverflow.com/questions/33923/what-is-tail-recursion](https://stackoverflow.com/questions/33923/what-is-tail-recursion)上对尾递归的基础进行了详细讨论。
- en: Van Rossum wrote about his decision not to use tail recursion in two blog posts
    at [https://neopythonic.blogspot.com.au/2009/04/tail-recursion-elimination.html](https://neopythonic.blogspot.com.au/2009/04/tail-recursion-elimination.html)
    and [https://neopythonic.blogspot.com.au/2009/04/final-words-on-tail-calls.html](https://neopythonic.blogspot.com.au/2009/04/final-words-on-tail-calls.html).
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: Van Rossum在两篇博文中写到了他决定不使用尾递归的原因，网址分别为[https://neopythonic.blogspot.com.au/2009/04/tail-recursion-elimination.html](https://neopythonic.blogspot.com.au/2009/04/tail-recursion-elimination.html)和[https://neopythonic.blogspot.com.au/2009/04/final-words-on-tail-calls.html](https://neopythonic.blogspot.com.au/2009/04/final-words-on-tail-calls.html)。
- en: Python’s standard library includes a module called `inspect` that allows you
    to view the frame objects on the call stack as a Python program is running. The
    official documentation for the `inspect` module is at [https://docs.python.org/3/library/inspect.html](https://docs.python.org/3/library/inspect.html),
    and a tutorial on Doug Hellmann’s Python 3 Module of the Week blog is at [https://pymotw.com/3/inspect](https://pymotw.com/3/inspect).
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: Python的标准库包括一个名为`inspect`的模块，允许您在Python程序运行时查看调用堆栈上的帧对象。`inspect`模块的官方文档位于[https://docs.python.org/3/library/inspect.html](https://docs.python.org/3/library/inspect.html)，Doug
    Hellmann的Python 3 Module of the Week博客上有一个教程，网址为[https://pymotw.com/3/inspect](https://pymotw.com/3/inspect)。
- en: Practice Questions
  id: totrans-1278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习问题
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试您的理解：
- en: What does tail call optimization prevent?
  id: totrans-1280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尾调用优化可以防止什么？
- en: What does the last action of a recursive function have to do so that the function
    can be tail recursive?
  id: totrans-1281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数的最后一个动作与尾递归函数有什么关系？
- en: Do all compilers and interpreters implement tail call optimization?
  id: totrans-1282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有编译器和解释器都实现尾调用优化吗？
- en: What is an accumulator?
  id: totrans-1283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是累加器？
- en: What is the disadvantage of tail recursion?
  id: totrans-1284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尾递归的缺点是什么？
- en: Can the quicksort algorithm (covered in Chapter 5) be rewritten to use tail
    call optimization?
  id: totrans-1285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速排序算法（第5章介绍）可以重写以使用尾调用优化吗？
- en: '9'
  id: totrans-1286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Drawing Fractals
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制分形
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-1288
  prefs: []
  type: TYPE_IMG
  zh: ！[](image_fi/book_art/chapterart.png)
- en: Certainly, the most fun application of recursion is drawing fractals. *Fractals*
    are shapes that repeat themselves, sometimes chaotically, at different scales.
    The term was coined by the founder of fractal geometry, Benoit B. Mandelbrot,
    in 1975 and is derived from the Latin *frāctus*, meaning broken or fractured,
    like shattered glass. Fractals include many natural and artificial shapes. In
    nature, you might see them in the shapes of trees, fern leaves, mountain ranges,
    lightning bolts, coastlines, river networks, and snowflakes. Mathematicians, programmers,
    and artists can create elaborate geometric shapes based on a few recursive rules.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，递归最有趣的应用是绘制分形。 *分形*是在不同尺度上重复自己的形状，有时是混乱的。 这个术语是由分形几何学的创始人Benoit B. Mandelbrot在1975年创造的，源自拉丁语*frāctus*，意思是破碎或断裂，就像破碎的玻璃一样。
    分形包括许多自然和人造形状。 在自然界中，您可能会在树的形状，蕨类叶子，山脉，闪电，海岸线，河网和雪花的形状中看到它们。 数学家，程序员和艺术家可以根据一些递归规则创建复杂的几何形状。
- en: Recursion can produce elaborate fractal art using surprisingly few lines of
    code. This chapter covers Python’s built-in `turtle` module for generating several
    common fractals with code. To create turtle graphics with JavaScript, you can
    use Greg Reimer’s `jtg` library. For simplicity, this chapter presents only the
    Python fractal drawing programs and not the JavaScript equivalents. However, the
    `jtg` JavaScript library is covered in this chapter.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 递归可以使用惊人地少的代码行生成复杂的分形艺术。 本章介绍了Python的内置“turtle”模块，用于使用代码生成几种常见的分形。 要使用JavaScript创建海龟图形，您可以使用Greg
    Reimer的“jtg”库。 为简单起见，本章仅介绍了Python分形绘图程序，而没有JavaScript等价物。 但是，本章介绍了“jtg”JavaScript库。
- en: Turtle Graphics
  id: totrans-1291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 海龟图形
- en: '*Turtle graphics* were a feature of the Logo programming language designed
    to help kids learn coding concepts. The feature has since been reproduced in many
    languages and platforms. Its central idea is an object called a *turtle*.'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '*海龟图形*是Logo编程语言的一个特性，旨在帮助孩子们学习编码概念。 此功能自那时以来已在许多语言和平台上复制。 其核心思想是一个叫做*海龟*的对象。'
- en: The turtle acts as a programmable pen that draws lines in a 2D window. Imagine
    an actual turtle holding a pen on the ground, drawing a line behind it as it moves
    around. The turtle can adjust the size and color of its pen, or “raise the pen”
    so that it does not draw as it moves. Turtle programs can produce intricate geometric
    drawings such as [Figure 9-1](#figure9-1).
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟充当可编程笔，在2D窗口中绘制线条。 想象一只真正的海龟在地面上拿着一支笔，随着它移动，它在身后画一条线。 海龟可以调整其笔的大小和颜色，或者“抬起笔”，以便在移动时不绘制。
    海龟程序可以产生复杂的几何图形，如[图9-1](#figure9-1)。
- en: 'When you put these instructions inside loops and functions, even small programs
    can create impressive geometric drawings. Consider the following *spiral.py* program:'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将这些指令放在循环和函数中时，即使是小程序也可以创建令人印象深刻的几何图形。 考虑以下*spiral.py*程序：
- en: '**Python**'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE155]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: When you run this program, the turtle window opens. The turtle (represented
    by a triangle) will trace the spiral pattern in [Figure 9-1](#figure9-1). While
    not a fractal, it is a beautiful drawing.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此程序时，海龟窗口会打开。 海龟（由三角形表示）将在[图9-1](#figure9-1)中追踪螺旋图案。 虽然不是分形，但它是一幅美丽的图画。
- en: '![Screenshot of a small triangle icon tracing overlapping lines across the
    window. The lines create a spiral pattern.](image_fi/502024c09/f09001.png)'
  id: totrans-1298
  prefs: []
  type: TYPE_IMG
  zh: '![小三角形图标的屏幕截图，在窗口上跟踪重叠的线条。 这些线条形成螺旋图案。](image_fi/502024c09/f09001.png)'
- en: 'Figure 9-1: The spiral drawn by the program using Python’s `turtle` module'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1：使用Python的“turtle”模块绘制的螺旋
- en: The window in a turtle graphics system uses Cartesian x- and y-coordinates.
    The number for the horizontal x-coordinate increases going right and decreases
    going left, while the number for the vertical y-coordinate increases going up
    and decreases going down. These two coordinates together can provide a unique
    address for any point in the window. By default, the *origin* (the x, y coordinate
    point at 0, 0) is in the center of the window.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟图形系统中的窗口使用笛卡尔x和y坐标。 水平x坐标的数字向右增加，向左减少，而垂直y坐标的数字向上增加，向下减少。 这两个坐标一起可以为窗口中的任何点提供唯一的地址。
    默认情况下，*原点*（坐标点在0,0处）位于窗口的中心。
- en: The turtle also has a *heading*, or direction, that is a number from 0 to 359
    (a circle is split into 360 degrees). In Python’s `turtle` module, a heading of
    0 faces east (toward the right edge of the screen) and increases clockwise; a
    heading of 90 faces north, a heading of 180 faces west, and a heading of 270 faces
    south. In the JavaScript `jtg` library, this orientation is rotated so that 0
    degrees faces north and increases counterclockwise. [Figure 9-2](#figure9-2) demonstrates
    the headings for the Python `turtle` module and the JavaScript `jtg` library.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟还有一个*heading*，或者方向，是从0到359的数字（一个圆被分成360度）。 在Python的“turtle”模块中，0的heading面向东（朝屏幕的右边缘），并且顺时针增加；
    90的heading面向北，180的heading面向西，270的heading面向南。 在JavaScript的“jtg”库中，此方向被旋转，以便0度面向北，并且逆时针增加。
    [图9-2](#figure9-2)演示了Python“turtle”模块和JavaScript“jtg”库的heading。
- en: '![Two compass diagrams indicating the headings for the turtle module and jtg
    library. The turtle module headings, clockwise from top: 90, 45, 0, 315, 270,
    225, 180, 135\. The jtg library headings, clockwise from top: 0, 45, 90, 135,
    180, 225, 270, 315.](image_fi/502024c09/F09002.png)'
  id: totrans-1302
  prefs: []
  type: TYPE_IMG
  zh: '![两个指南针图示表明了海龟模块和jtg库的航向。从上顺时针看，海龟模块的航向依次为：90、45、0、315、270、225、180、135。jtg库的航向从上顺时针看依次为：0、45、90、135、180、225、270、315。](image_fi/502024c09/F09002.png)'
- en: 'Figure 9-2: The headings in Python’s `turtle` module (left) and the JavaScript
    `jtg` library (right)'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2：Python的“turtle”模块（左）和JavaScript的“jtg”库（右）中的航向
- en: 'In the JavaScript `jtg` library at [https://inventwithpython.com/jtg](https://inventwithpython.com/jtg),
    enter the following code into the text field at the bottom of the page:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript的“jtg”库中，进入[https://inventwithpython.com/jtg](https://inventwithpython.com/jtg)，将以下代码输入到页面底部的文本字段中：
- en: '**JavaScript**'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE156]'
  id: totrans-1306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This draws the same spiral shown in [Figure 9-1](#figure9-1) on the main area
    of the web page.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在网页的主要区域绘制与[图9-1](#figure9-1)中显示的相同螺旋线。
- en: Basic Turtle Functions
  id: totrans-1308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本海龟函数
- en: The most commonly used functions in turtle graphics cause the turtle to change
    heading and move forward or backward. The `turtle.left()` and `turtle.right()`
    functions rotate the turtle a certain number of degrees starting from its current
    heading, while the `turtle.forward()` and `turtle.backward()` functions move the
    turtle based on its current position.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟图形中最常用的函数会导致海龟改变航向并向前或向后移动。`turtle.left()`和`turtle.right()`函数从当前航向开始旋转海龟一定角度，而`turtle.forward()`和`turtle.backward()`函数根据当前位置移动海龟。
- en: '[Table 9-1](#table9-1) lists some of the turtle’s functions. The first function
    (beginning with `turtle.`) is for Python, and the second (beginning with `t.`)
    is for JavaScript. The full Python documentation is available at [https://docs.python.org/3/library/turtle.html](https://docs.python.org/3/library/turtle.html).
    In the JavaScript `jtg` software, you can press F1 to display the help screen.'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '[表9-1](#table9-1)列出了一些海龟的函数。第一个函数（以“turtle.”开头）是为Python，第二个（以“t.”开头）是为JavaScript。完整的Python文档可在[https://docs.python.org/3/library/turtle.html](https://docs.python.org/3/library/turtle.html)找到。在JavaScript的“jtg”软件中，您可以按F1键显示帮助屏幕。'
- en: 'Table 9-1: Turtle Functions in Python’s `turtle` Module and JavaScript’s `jtg`
    Library'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-1：Python的“turtle”模块和JavaScript的“jtg”库中的海龟函数
- en: '| **Python** | **JavaScript** | **Description** |'
  id: totrans-1312
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | **JavaScript** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-1313
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `goto(``x``,` `y``)` | `xy(``x``,` `y``)` | Moves the turtle to the x, y
    coordinates. |'
  id: totrans-1314
  prefs: []
  type: TYPE_TB
  zh: '| `goto(``x``,` `y``)` | `xy(``x``,` `y``)` | 将海龟移动到x，y坐标。 |'
- en: '| `setheading(``deg``)` | `heading(``deg``)` | Sets the turtle’s heading. In
    Python, 0 degrees is east (right). In JavaScript, 0 degrees is north (up). |'
  id: totrans-1315
  prefs: []
  type: TYPE_TB
  zh: '| `setheading(``deg``)` | `heading(``deg``)` | 设置海龟的航向。在Python中，0度是东（右）。在JavaScript中，0度是北（向上）。
    |'
- en: '| `forward(``steps``)` | `fd(``steps``)` | Moves the turtle a number of steps
    forward in the heading it is facing. |'
  id: totrans-1316
  prefs: []
  type: TYPE_TB
  zh: '| `forward(``steps``)` | `fd(``steps``)` | 以面对的方向将海龟向前移动一定步数。 |'
- en: '| `backward(``steps``)` | `bk(``steps``)` | Moves the turtle a number of steps
    in the heading opposite from the one it is facing. |'
  id: totrans-1317
  prefs: []
  type: TYPE_TB
  zh: '| `backward(``steps``)` | `bk(``steps``)` | 以面对的相反方向将海龟向后移动一定步数。 |'
- en: '| `left(``deg``)` | `lt(``deg``)` | Turns the turtle’s heading to the left.
    |'
  id: totrans-1318
  prefs: []
  type: TYPE_TB
  zh: '| `left(``deg``)` | `lt(``deg``)` | 将海龟的航向向左转动。 |'
- en: '| `right(``deg``)` | `rt(``deg``)` | Turns the turtle’s heading to the right.
    |'
  id: totrans-1319
  prefs: []
  type: TYPE_TB
  zh: '| `right(``deg``)` | `rt(``deg``)` | 将海龟的航向向右转动。 |'
- en: '| `penup()` | `pu()` | “Raises the pen” so that the turtle stops drawing as
    it moves. |'
  id: totrans-1320
  prefs: []
  type: TYPE_TB
  zh: '| `penup()` | `pu()` | “提起笔”以使海龟在移动时停止绘制。 |'
- en: '| `pendown()` | `pd()` | “Lowers the pen” so that the turtle starts drawing
    as it moves. |'
  id: totrans-1321
  prefs: []
  type: TYPE_TB
  zh: '| `pendown()` | `pd()` | “放下笔”以使海龟在移动时开始绘制。 |'
- en: '| `pensize(``size``)` | `thickness(``size``)` | Changes the thickness of the
    lines the turtle draws. The default is `1`. |'
  id: totrans-1322
  prefs: []
  type: TYPE_TB
  zh: '| `pensize(``size``)` | `thickness(``size``)` | 更改海龟绘制线条的粗细。默认值为`1`。 |'
- en: '| `pencolor(``color``)` | `color(``color``)` | Changes the color of the lines
    the turtle draws. This can be a string of a common color such as `red` or `white`.
    The default is `black`. |'
  id: totrans-1323
  prefs: []
  type: TYPE_TB
  zh: '| `pencolor(``color``)` | `color(``color``)` | 更改海龟绘制线条的颜色。这可以是常见颜色的字符串，如`red`或`white`。默认值为`black`。
    |'
- en: '| `xcor()` | `get.x()` | Returns the turtle’s current x position. |'
  id: totrans-1324
  prefs: []
  type: TYPE_TB
  zh: '| `xcor()` | `get.x()` | 返回海龟当前的x坐标。 |'
- en: '| `ycor()` | `get.y()` | Returns the turtle’s current y position. |'
  id: totrans-1325
  prefs: []
  type: TYPE_TB
  zh: '| `ycor()` | `get.y()` | 返回海龟当前的y坐标。 |'
- en: '| `heading()` | `get.heading()` | Returns the turtle’s current heading as a
    floating-point number from 0 to 359\. In Python, 0 degrees is east (right). In
    JavaScript, 0 degrees is north (up). |'
  id: totrans-1326
  prefs: []
  type: TYPE_TB
  zh: '| `heading()` | `get.heading()` | 以0到359的浮点数返回海龟当前的航向。在Python中，0度是东（右）。在JavaScript中，0度是北（向上）。
    |'
- en: '| `reset()` | `reset()` | Clears any drawn lines, and moves the turtle back
    to the original position and heading. |'
  id: totrans-1327
  prefs: []
  type: TYPE_TB
  zh: '| `reset()` | `reset()` | 清除任何绘制的线条，并将海龟移回原始位置和航向。 |'
- en: '| `clear()` | `clean()` | Clears any drawn lines but doesn’t move the turtle.
    |'
  id: totrans-1328
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | `clean()` | 清除任何绘制的线条，但不移动海龟。 |'
- en: The functions listed in [Table 9-2](#table9-2) are available only in the Python
    `turtle` module.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-2中列出的函数仅在Python的“turtle”模块中可用。
- en: 'Table 9-2: Python-Only Turtle Functions'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-2：仅Python的海龟函数
- en: '| **Python** | **Description** |'
  id: totrans-1331
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | **描述** |'
- en: '| --- | --- |'
  id: totrans-1332
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `begin_fill()` | Begins drawing a filled-in shape. The lines drawn after
    this call will specify the perimeter of the filled-in shape. |'
  id: totrans-1333
  prefs: []
  type: TYPE_TB
  zh: '| `begin_fill()` | 开始绘制填充形状。此调用之后绘制的线条将指定填充形状的周长。 |'
- en: '| `end_fill()` | Draws the filled-in shape that was started with the call to
    `turtle.begin_fill()`. |'
  id: totrans-1334
  prefs: []
  type: TYPE_TB
  zh: '| `end_fill()` | 绘制以调用`turtle.begin_fill()`开始的填充形状。 |'
- en: '| `fillcolor(``color``)` | Sets the color used for filled-in shapes. |'
  id: totrans-1335
  prefs: []
  type: TYPE_TB
  zh: '| `fillcolor(``color``)` | 设置用于填充形状的颜色。 |'
- en: '| `hideturtle()` | Hides the triangle that represents the turtle. |'
  id: totrans-1336
  prefs: []
  type: TYPE_TB
  zh: '| `hideturtle()` | 隐藏代表海龟的三角形。 |'
- en: '| `showturtle()` | Shows the triangle that represents the turtle. |'
  id: totrans-1337
  prefs: []
  type: TYPE_TB
  zh: '| `showturtle()` | 显示代表海龟的三角形。 |'
- en: '| `tracer(``drawingUpdates``,` `delay``)` | Adjusts the speed of drawing. Pass
    `0` for `delay` for a delay of 0 milliseconds after each line the turtle draws.
    The larger the number passed for `drawingUpdates`, the faster the turtle draws
    by increasing the number of drawings before the module updates the screen. |'
  id: totrans-1338
  prefs: []
  type: TYPE_TB
  zh: '| `tracer(``drawingUpdates``,` `delay``)` | 调整绘制速度。将`delay`设置为`0`，表示在乌龟绘制每条线后延迟0毫秒。传递给`drawingUpdates`的数字越大，乌龟绘制的速度就越快，因为模块在更新屏幕之前绘制的次数越多。
    |'
- en: '| `update()` | Draws any buffered lines (explained later in this section) to
    the screen. Call this after the turtle has completed drawing. |'
  id: totrans-1339
  prefs: []
  type: TYPE_TB
  zh: '| `update()` | 将任何缓冲线（稍后在本节中解释）绘制到屏幕上。在乌龟完成绘制后调用此函数。 |'
- en: '| `setworldcoordinates(``llx``,` `lly``,` `urx,``ury``)` | Readjusts which
    part of the coordinate plane the window shows. The first two arguments are the
    x, y coordinates for the lower-left corner of the window. The latter two arguments
    are the x, y coordinates for the upper-right corner of the window. |'
  id: totrans-1340
  prefs: []
  type: TYPE_TB
  zh: '| `setworldcoordinates(``llx``,` `lly``,` `urx,``ury``)` | 重新调整窗口显示坐标平面的哪一部分。前两个参数是窗口左下角的x、y坐标。后两个参数是窗口右上角的x、y坐标。
    |'
- en: '| `exitonclick()` | Pauses the program and closes the window when the user
    clicks anywhere. Without this at the end of your program, the turtle graphics
    window may close as soon as the program ends. |'
  id: totrans-1341
  prefs: []
  type: TYPE_TB
  zh: '| `exitonclick()` | 当用户单击任何位置时，暂停程序并关闭窗口。如果在程序的最后没有这个命令，乌龟图形窗口可能会在程序结束时立即关闭。
    |'
- en: In Python’s `turtle` module, lines are displayed on the screen immediately.
    However, this can slow programs that draw thousands of lines. It’s faster to *buffer*—that
    is, hold off displaying several lines and then display them all at once.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的`turtle`模块中，线条会立即显示在屏幕上。然而，这可能会减慢绘制数千条线的程序。更快的方法是*缓冲*——即暂时不显示几条线，然后一次性显示它们。
- en: By calling `turtle.tracer(1000, 0)`, you can instruct the `turtle` module to
    hold off displaying lines until 1,000 lines have been created by your program.
    After your program has finished calling line-drawing functions, make a final call
    to `turtle.update()` to display any remaining buffered lines to the screen. If
    your program is still taking too long to draw an image, pass a larger integer
    such as `2000` or `10000` as the first argument to `turtle.tracer()`.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`turtle.tracer(1000, 0)`，你可以指示`turtle`模块在程序创建了1,000条线之前不显示这些线。在程序完成调用绘制线条的函数后，最后调用`turtle.update()`来显示剩余的缓冲线。如果你的程序仍然花费太长时间来绘制图像，可以将一个更大的整数，如`2000`或`10000`，作为第一个参数传递给`turtle.tracer()`。
- en: The Sierpiński Triangle
  id: totrans-1344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谢尔宾斯基三角形
- en: The easiest fractal to draw on paper is the *Sierpiński triangle*, introduced
    in Chapter 1. This fractal was described by Polish mathematician Wacław Sierpiński
    in 1915 (predating even the term *fractal*). However, the pattern is at least
    hundreds of years older.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 在纸上绘制的最简单的分形是*谢尔宾斯基三角形*，它是在第1章介绍的。这个分形是由波兰数学家瓦茨瓦夫·谢尔宾斯基于1915年描述的（甚至早于术语*分形*的出现）。然而，这种图案至少有数百年的历史。
- en: To create a Sierpiński triangle, start by drawing an equilateral triangle—a
    triangle with equal-length sides, like the one on the left in [Figure 9-3](#figure9-3).
    Then draw an upside-down equilateral triangle inside the first triangle, as on
    the right in [Figure 9-3](#figure9-3). You’ll form a shape that, if you’re familiar
    with the *Legend of Zelda* video games, looks like the Triforce.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个谢尔宾斯基三角形，首先绘制一个等边三角形——一个三边长度相等的三角形，就像[图9-3](#figure9-3)中左边的那个。然后在第一个三角形内部绘制一个倒置的等边三角形，就像[图9-3](#figure9-3)中右边的那个。你将得到一个形状，如果你熟悉*塞尔达传说*视频游戏，它看起来像三角力量。
- en: '![Graphic depicting four equilateral triangles. The second triangle has a smaller
    triangle in the center that breaks the shape into four smaller triangles. In the
    third triangle, each of the three outer triangles is broken into smaller triangles.
    the fourth triangle shows those smaller triangles further broken into even smaller
    triangles.](image_fi/502024c09/f09003.png)'
  id: totrans-1347
  prefs: []
  type: TYPE_IMG
  zh: '![图形描述了四个等边三角形。第二个三角形中心有一个较小的三角形，将形状分成了四个较小的三角形。在第三个三角形中，每个外部的三角形都被分成了更小的三角形。第四个三角形显示了这些更小的三角形进一步分成了更小的三角形。](image_fi/502024c09/f09003.png)'
- en: 'Figure 9-3: An equilateral triangle (left) with an upside-down triangle added
    to form a Sierpiński triangle, with additional triangles recursively added'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-3：一个等边三角形（左）和一个倒置的三角形相加形成了一个谢尔宾斯基三角形，递归地添加了额外的三角形
- en: An interesting thing happens when you draw the inner, upside-down triangle.
    You form three new, right-side-up equilateral triangles. Inside each of these
    three triangles, you can draw another upside-down triangle, which will create
    nine triangles. This recursion can continue forever mathematically, though in
    reality your pen won’t be able to keep drawing tinier triangles.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 当你绘制内部的倒置三角形时，一个有趣的事情发生了。你形成了三个新的正立等边三角形。在这三个三角形的每一个内部，你可以绘制另一个倒置的三角形，这样就会创建出九个三角形。这种递归在数学上可以无限进行，尽管在现实中，你的笔无法不断地绘制更小的三角形。
- en: 'This property, describing a full object that is similar to a part of itself,
    is called *self-similarity*. Recursive functions can produce these objects, since
    they “call” themselves again and again. Practically, this code must hit a base
    case eventually, but mathematically, these shapes have infinite resolution: you
    could theoretically zoom in on the shape forever.'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 这种描述一个与自身的一部分相似的完整对象的属性被称为*自相似性*。递归函数可以产生这些对象，因为它们一遍又一遍地“调用”自己。实际上，这段代码最终必须达到一个基本情况，但在数学上，这些形状具有无限的分辨率：你理论上可以永远放大这个形状。
- en: Let’s write a recursive program to create the Sierpiński triangle. The recursive
    `drawTriangle()` function will draw an equilateral triangle, and then recursively
    call this function three times to draw the inner equilateral triangles, as in
    [Figure 9-4](#figure9-4). The `midpoint()` function finds the point equidistant
    from two points passed to the function. This will be important as the inner triangles
    use these equidistant points for their vertices.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个递归程序来创建谢尔宾斯基三角形。递归的`drawTriangle()`函数将绘制一个等边三角形，然后递归调用这个函数三次来绘制内部的等边三角形，就像[图9-4](#figure9-4)中那样。`midpoint()`函数找到距离函数传递的两个点等距离的点。这对于内部三角形使用这些等距离的点作为它们的顶点是很重要的。
- en: '![Diagram of an equilateral triangle drawn three times using dotted lines.
    Solid lines isolate a different, smaller equilateral triangle in each of the larger
    triangles. These smaller triangles each share a different vertex with the larger
    triangle and have a side length of one-half the larger triangle’s.](image_fi/502024c09/f09004.png)'
  id: totrans-1352
  prefs: []
  type: TYPE_IMG
  zh: '![通过虚线三次绘制的等边三角形的图表。实线将每个较大三角形中的不同、较小的等边三角形隔离开来。这些较小的三角形每个都与较大三角形共享一个不同的顶点，并且边长是较大三角形的一半。](image_fi/502024c09/f09004.png)'
- en: 'Figure 9-4: The three inner triangles, with midpoints shown with large dots'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-4：三个内部三角形，中点用大点显示
- en: 'Note that this program calls `turtle.setworldcoordinates(0, 0, 700, 700)`,
    which makes the 0, 0 origin at the lower-left corner of the window. The upper-right
    corner has the x, y coordinates 700, 700\. The source code for *sierpinskiTriangle.py*
    is as follows:'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此程序调用了`turtle.setworldcoordinates(0, 0, 700, 700)`，这使得0, 0原点位于窗口的左下角。右上角的x、y坐标为700,
    700。*sierpinskiTriangle.py*的源代码如下：
- en: '[PRE157]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: When you run this code, the output looks like [Figure 9-5](#figure9-5).
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，输出看起来像[图9-5](#figure9-5)。
- en: '![Screenshot of a Sierpiński triangle drawn in the turtle module.](image_fi/502024c09/f09005.png)'
  id: totrans-1357
  prefs: []
  type: TYPE_IMG
  zh: '![使用乌龟模块绘制的谢尔宾斯基三角形的屏幕截图。](image_fi/502024c09/f09005.png)'
- en: 'Figure 9-5: A standard Sierpiński triangle'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-5：标准谢尔宾斯基三角形
- en: Sierpiński triangles don’t have to be drawn with equilateral triangles. As long
    as you use the midpoints of the outer triangle to draw the inner triangles, you
    can use any kind of triangle. Comment out the first `drawTriangle()` call and
    uncomment the second one (under the `# Draw a skewed Sierpinski triangle.` comment)
    and run the program again. The output will look like [Figure 9-6](#figure9-6).
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 谢尔宾斯基三角形不一定要用等边三角形来绘制。只要使用外部三角形的中点来绘制内部三角形，你可以使用任何类型的三角形。注释掉第一个`drawTriangle()`调用，并取消注释第二个（在`#
    Draw a skewed Sierpinski triangle.`注释下面），然后再次运行程序。输出将看起来像[图9-6](#figure9-6)。
- en: '![Screenshot of a Sierpiński triangle drawn using irregular triangles with
    the turtle module. The image looks like an equilateral Sierpiński viewed at an
    angle.](image_fi/502024c09/f09006.png)'
  id: totrans-1360
  prefs: []
  type: TYPE_IMG
  zh: '![使用乌龟模块使用不规则三角形绘制的谢尔宾斯基三角形的屏幕截图。图像看起来像是从一个角度观看的等边谢尔宾斯基。](image_fi/502024c09/f09006.png)'
- en: 'Figure 9-6: A skewed Sierpiński triangle'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-6：一个倾斜的谢尔宾斯基三角形
- en: The `drawTriangle()` function takes six arguments corresponding to the x, y
    coordinates of the triangle’s three points. Try experimenting with different values
    to adjust the shape of the Sierpiński triangle. You can also change the `MIN_SIZE`
    constant to a larger value to make the program reach the base case sooner and
    reduce the number of triangles drawn.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawTriangle()`函数接受六个参数，对应于三角形的三个点的x、y坐标。尝试尝试不同的值来调整谢尔宾斯基三角形的形状。你也可以将`MIN_SIZE`常量更改为较大的值，以使程序更快地达到基本情况，并减少绘制的三角形数量。'
- en: The Sierpiński Carpet
  id: totrans-1363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谢尔宾斯基地毯
- en: A fractal shape similar to the Sierpiński triangle can be drawn using rectangles
    instead. This pattern is known as the *Sierpiński carpet*. Imagine splitting a
    black rectangle into a 3 × 3 grid, then “cutting out” the center rectangle. Repeat
    this pattern in the surrounding eight rectangles of the grid. When this is done
    recursively, you end up with a pattern like [Figure 9-7](#figure9-7).
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似于谢尔宾斯基三角形的分形形状可以使用矩形来绘制。这种模式被称为*Sierpiński carpet*。想象将一个黑色矩形分成3×3的网格，然后“切除”中心矩形。在网格的周围八个矩形中重复这种模式。当这样递归地完成时，你会得到一个像[图9-7](#figure9-7)的图案。
- en: '![Screenshot of a black rectangle containing a pattern of white rectangles
    of various sizes. Drawn with the turtle module.](image_fi/502024c09/f09007.png)'
  id: totrans-1365
  prefs: []
  type: TYPE_IMG
  zh: '![黑色矩形的屏幕截图，其中包含各种大小的白色矩形的图案。使用乌龟模块绘制。](image_fi/502024c09/f09007.png)'
- en: 'Figure 9-7: The Sierpiński carpet'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-7：谢尔宾斯基地毯
- en: The Python program that draws the carpet uses the `turtle.begin_fill()` and
    `turtle.end_fill()` functions to create solid, filled-in shapes. The lines that
    the turtle draws between these calls are used to draw the shape, as in [Figure
    9-8](#figure9-8).
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制地毯的Python程序使用`turtle.begin_fill()`和`turtle.end_fill()`函数来创建实心的填充形状。乌龟在这些调用之间绘制的线用于绘制形状，就像[图9-8](#figure9-8)中那样。
- en: '![Three diagrams representing the steps the turtle takes to draw a filled-in
    rectangle. The first shape shows the turtle traveling in a path that draws three
    sides of a rectangle. The second diagram shows the turtle completing the rectangle.
    The third diagram shows the rectangle filled in.](image_fi/502024c09/f09008.png)'
  id: totrans-1368
  prefs: []
  type: TYPE_IMG
  zh: '![三个图表代表乌龟绘制填充矩形的步骤。第一个形状显示乌龟沿着绘制矩形的三条边的路径。第二个图表显示乌龟完成矩形。第三个图表显示填充的矩形。](image_fi/502024c09/f09008.png)'
- en: 'Figure 9-8: Calling `turtle.begin_fill()`, drawing a path, and calling `turtle.end_fill()`
    creates a filled-in shape.'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-8：调用`turtle.begin_fill()`，绘制路径，然后调用`turtle.end_fill()`创建填充形状。
- en: 'The base case is reached when the rectangles of the 3 × 3 become smaller than
    six steps on a side. You can change the `MIN_SIZE` constant to a larger value
    to make the program reach the base case sooner. The source code for *sierpinskiCarpet.py*
    is as follows:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 当3×3的矩形变得小于一边的六个步骤时，基本情况就会到达。你可以将`MIN_SIZE`常量更改为较大的值，以使程序更快地达到基本情况。*sierpinskiCarpet.py*的源代码如下：
- en: '[PRE158]'
  id: totrans-1371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: You can also set the `DRAW_SOLID` constant to `False` and run the program. This
    will skip the calls to `turtle.begin_fill()` and `turtle.end_fill()` so that only
    the outlines of the rectangles are drawn, as in [Figure 9-9](#figure9-9).
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将`DRAW_SOLID`常量设置为`False`并运行程序。这将跳过对`turtle.begin_fill()`和`turtle.end_fill()`的调用，以便只绘制矩形的轮廓，如[图9-9](#figure9-9)所示。
- en: Try passing different arguments to `drawCarpet()`. The first two arguments are
    the x, y coordinates of the lower-left corner of the carpet, while the latter
    two arguments are the width and height. You can also change the `MIN_SIZE` constant
    to a larger value to make the program reach the base case sooner and reduce the
    number of rectangles drawn.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将不同的参数传递给`drawCarpet()`。前两个参数是地毯左下角的x、y坐标，而后两个参数是宽度和高度。您还可以将`MIN_SIZE`常量更改为较大的值，以使程序更快地达到基本情况，并减少绘制的矩形数量。
- en: '![Turtle graphics screenshot showing a version of the Sierpiński carpet in
    which none of the rectangles are filled in.](image_fi/502024c09/f09009.png)'
  id: totrans-1374
  prefs: []
  type: TYPE_IMG
  zh: '![乌龟图形截图显示了Sierpiński地毯的一个版本，其中没有填充任何矩形。](image_fi/502024c09/f09009.png)'
- en: 'Figure 9-9: The Sierpiński carpet, with only the outlines of the rectangles
    drawn'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-9：Sierpiński地毯，只绘制了矩形的轮廓
- en: Another 3D Sierpiński carpet uses cubes instead of squares. In this form, it
    is called a *Sierpiński cube*, or *Menger sponge*. It was first described by mathematician
    Karl Menger in 1926\. [Figure 9-10](#figure9-10) shows a Menger sponge created
    in the video game *Minecraft*.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个3D Sierpiński地毯使用立方体而不是正方形。在这种形式中，它被称为*Sierpiński立方体*或*Menger海绵*。它最早由数学家卡尔·门格在1926年描述。[图9-10](#figure9-10)显示了在视频游戏*Minecraft*中创建的Menger海绵。
- en: '![Image of a cube viewed at an angle. The visible sides of the cube have squares
    cut out of them in the pattern of a Sierpiński carpet.](image_fi/502024c09/f09010.png)'
  id: totrans-1377
  prefs: []
  type: TYPE_IMG
  zh: '![图像显示了一个以角度观察的立方体。立方体的可见面上有一个Sierpiński地毯的图案。](image_fi/502024c09/f09010.png)'
- en: 'Figure 9-10: A 3D Menger sponge fractal'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-10：3D Menger海绵分形
- en: Fractal Trees
  id: totrans-1379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分形树
- en: While the artificial fractals such as the Sierpiński triangle and carpet are
    perfectly self-similar, fractals can include shapes that do not have perfect self-similarity.
    Fractal geometry, as envisioned by mathematician Benoit B. Mandelbrot (whose middle
    initial recursively stands for Benoit B. Mandelbrot) included natural shapes such
    as mountains, coastlines, plants, blood vessels, and the clustering of galaxies
    as fractals. Upon close examination, these shapes continued to consist of “rougher”
    shapes not easily contained by the smooth curves and straight lines of simplified
    geometry.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Sierpiński三角形和地毯等人造分形是完全自相似的，但分形可以包括没有完美自相似性的形状。数学家Benoit B. Mandelbrot（他的中间名字母递归地代表Benoit
    B. Mandelbrot）构想的分形几何包括自然形状，如山脉、海岸线、植物、血管和星系的聚类。仔细观察，这些形状继续由简化几何的光滑曲线和直线难以包容的“粗糙”形状组成。
- en: As an example, we can use recursion to reproduce *fractal trees*, whether perfectly
    or imperfectly self-similar. Generating trees requires creating a branch with
    two child branches that issue from their parent at set angles and decrease at
    set lengths. The Y shape that they produce is recursively repeated to create a
    convincing drawing of a tree, as in Figures 9-11 and 9-12.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用递归来复制*分形树*，无论是完全还是不完全自相似。生成树需要创建一个具有两个子分支的分支，这些分支从父分支发出，角度和长度减小。它们产生的Y形状被递归重复，以创建一棵树的逼真图像，如图9-11和9-12所示。
- en: '![Turtle graphics screenshot showing a drawing that resembles a leafless tree.
    The branches of the tree lean toward the left and become progressively smaller,
    creating a rounded, asymmetrical shape.](image_fi/502024c09/f09011.png)'
  id: totrans-1382
  prefs: []
  type: TYPE_IMG
  zh: '![乌龟图形截图显示了一个类似无叶树的图画。树的分支朝左倾斜，并逐渐变小，形成一个圆润的不对称形状。](image_fi/502024c09/f09011.png)'
- en: 'Figure 9-11: A perfectly self-similar fractal tree generated with the left
    and right branches using consistent angles and lengths'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-11：使用一致的角度和长度生成的完全自相似的分形树
- en: Movies and video games can use such recursive algorithms in *procedural generation*,
    the automatic (rather than manual) creation of 3D models such as trees, ferns,
    flowers, and other plants. Using algorithms, computers can quickly create entire
    forests consisting of millions of unique trees, saving an army of human 3D artists
    the painstaking effort.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 电影和视频游戏可以在*程序生成*中使用这种递归算法，自动（而不是手动）创建树、蕨类植物、花朵和其他植物等3D模型。使用算法，计算机可以快速创建由数百万棵独特树组成的整个森林，节省了大量人类3D艺术家的辛苦努力。
- en: '![Turtle graphics screenshot showing a drawing that resembles a leafless tree.
    The tree’s branches vary in length and direction of branching, sometimes overlapping.](image_fi/502024c09/f09012.png)'
  id: totrans-1385
  prefs: []
  type: TYPE_IMG
  zh: '![乌龟图形截图显示了一个类似无叶树的图画。树的分支长度和分支方向各不相同，有时会重叠。](image_fi/502024c09/f09012.png)'
- en: 'Figure 9-12: A more realistic tree created using random changes to branch angle
    and lengths'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-12：使用随机改变分支角度和长度创建的更真实的树
- en: 'Our fractal tree program displays a new, randomly generated tree every two
    seconds. The source code for *fractalTree.py* is as follows:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的分形树程序每两秒显示一个新的随机生成的树。*fractalTree.py*的源代码如下：
- en: '**Python**'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE159]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: This program produces perfectly self-similar trees, as the `LEFT_ANGLE`, `LEFT_DECREASE`,
    `RIGHT_ANGLE`, and `RIGHT_DECREASE` variables are initially randomly chosen but
    stay constant for all the recursive calls. The `random.seed()` function sets a
    seed value for Python’s random functions. The *random number seed value* causes
    the program to produce random-seeming numbers, but it uses the same sequence of
    random numbers for each branch of the tree. In other words, the same *seed* value
    reproduces the same *tree* each time you run the program. (I never apologize for
    my puns.)
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序产生完全自相似的树，因为`LEFT_ANGLE`、`LEFT_DECREASE`、`RIGHT_ANGLE`和`RIGHT_DECREASE`变量最初是随机选择的，但对所有递归调用保持不变。`random.seed()`函数为Python的随机函数设置一个种子值。*随机数种子值*使程序产生看似随机的数字，但对树的每个分支使用相同的随机数序列。换句话说，相同的*种子*值每次运行程序都会产生相同的*树*。（我从不为我说的双关语道歉。）
- en: 'To see this in action, enter the following into the Python interactive shell:'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个过程，输入以下内容到Python交互式shell中：
- en: '**Python**'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE160]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: In this example, we set the random seed to 42\. When we generate 20 random integers,
    we get `1`, `0`, `4`, `3`, and so on. We can generate another 20 integers and
    continue to receive random integers. However, if we reset the seed to `42` and
    generate 20 random integers again, they’ll be the same “random” integers as before.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将随机种子设置为42。当我们生成20个随机整数时，我们得到`1`、`0`、`4`、`3`等。我们可以生成另外20个整数，并继续接收随机整数。然而，如果我们将种子重置为`42`，再次生成20个随机整数，它们将与之前的相同的“随机”整数。
- en: 'If you’d like to create a more natural, less self-similar tree, replace the
    lines after the `# Record the position of the branch''s end.` comment with the
    following lines. This generates new random angles and branch lengths for *every*
    recursive call, which is closer to the way trees grow in nature:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个更自然、不那么自相似的树，用以下行替换`#记录分支末端的位置。`注释后的行。这会为*每个*递归调用生成新的随机角度和分支长度，更接近树在自然界中生长的方式：
- en: '**Python**'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE161]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: You can experiment with different ranges for the `random.randint()` call, or
    try adding more recursive calls instead of just the two for the two branches.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试不同范围的`random.randint()`调用，或者尝试添加更多的递归调用，而不仅仅是两个分支。
- en: How Long Is the Coast of Great Britain? The Koch Curve and Snowflake
  id: totrans-1399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英国海岸线有多长？科赫曲线和雪花
- en: 'Before I tell you about the Koch curve and snowflake, consider this question:
    how long is the coast of Great Britain? Look at [Figure 9-13](#figure9-13). The
    map on the left has a rough measure, which puts the coast at about 2,000 miles.
    But the map on the right has a more precise measure, which includes more nooks
    and crannies of the coast and comes to about 2,800 miles.'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 在我告诉你关于科赫曲线和雪花之前，考虑这个问题：英国的海岸线有多长？看一下[图9-13](#figure9-13)。左边的地图有一个粗略的测量，将海岸线长度约为2000英里。但右边的地图有一个更精确的测量，包括了更多海岸的角落，长度约为2800英里。
- en: '![Two screenshots of maps of Great Britain. In the first, the outline of the
    coast is approximated using straight-line segments to connect various points along
    the country’s outline. In the second, more points are added, increasing the number
    of line segments used.](image_fi/502024c09/f09013b.png)'
  id: totrans-1401
  prefs: []
  type: TYPE_IMG
  zh: '![两张大不列颠地图的截图。第一张地图使用直线段来近似连接国家轮廓上的各个点。第二张地图增加了更多的点，增加了使用的线段数量。](image_fi/502024c09/f09013b.png)'
- en: 'Figure 9-13: The island of Great Britain, with a rough measure (left) and more
    precise measure (right). Measuring the coast more precisely adds 800 miles to
    its length.'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-13：大不列颠岛，粗略测量（左）和更精确测量（右）。更精确地测量海岸线长度增加了800英里。
- en: Mandelbrot’s key insight about fractals such as the coastline of Britain is
    that you can continue to look closer and closer, and there will continue to be
    “roughness” at every scale. So, as your measurement gets finer and finer, the
    length of the coastline will get longer and longer. The “coast” will follow the
    Thames upriver, deep into the landmass along one bank and back out to the English
    Channel on the other bank. Thus, the answer to our question of Great Britain’s
    coastline’s length is, “It depends.”
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 曼德布罗特关于英国海岸线等分形的关键见解是，你可以继续越来越近地观察，每个尺度上都会有“粗糙”。因此，随着你的测量变得越来越精细，海岸线的长度也会变得越来越长。这条“海岸线”将沿着泰晤士河上游，深入陆地沿着一岸，然后回到英吉利海峡的另一岸。因此，对于我们关于大不列颠海岸线长度的问题的答案是，“这取决于。”
- en: The *Koch curve* fractal has a similar property pertaining to the length of
    its coastline, or rather, perimeter. First introduced in 1902 by Swedish mathematician
    Helge von Koch, the Koch curve is one of the earliest fractals to be described
    mathematically. To construct it, take a line of length *b* and divide it into
    three equal parts, each of length *b* / 3\. Replace the middle section with a
    “bump” whose sides are also of length *b* / 3\. This bump causes the Koch curve
    to be longer than the original line, since we now have four line segments of length
    *b* / 3\. (We’ll exclude the original middle part of the line segment.) This bump
    creation can be repeated on the new four line segments. [Figure 9-14](#figure9-14)
    shows this construction.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: '*Koch曲线*分形具有与其海岸线长度或周长相关的类似特性。Koch曲线最早由瑞典数学家赫尔格·冯·科赫于1902年提出，是最早被数学描述的分形之一。要构造它，取长度为*b*的线段并将其分成三等分，每部分长度为*b*/3。用长度也为*b*/3的“凸起”替换中间部分。这个凸起使得Koch曲线比原始线段更长，因为现在我们有四条长度为*b*/3的线段。（我们将排除原始线段的中间部分。）这个凸起的创建可以在新的四条线段上重复。[图9-14](#figure9-14)展示了这个构造过程。'
- en: '![Three diagrams. The first is a line divided into three segments, each of
    length b/3\. The second diagram shows the middle segment replaced with two segments
    of length b/3 that angle upward, forming two sides of an equilateral triangle
    whose third side is the missing middle segment. The third diagram shows each of
    the segments of the second diagram altered according to the same pattern, creating
    an irregular, bumpy shape.](image_fi/502024c09/f09014.png)'
  id: totrans-1405
  prefs: []
  type: TYPE_IMG
  zh: '![三个图表。第一个是一条分成三段的线，每段长度为b/3。第二个图表显示中间段被替换为两段长度为b/3的向上倾斜的线段，形成一个等边三角形的两条边，第三条边是缺失的中间段。第三个图表显示第二个图表中的每个段按照相同的图案进行改变，创建一个不规则的凸起形状。](image_fi/502024c09/f09014.png)'
- en: 'Figure 9-14: After splitting the line segment into three equal parts (left),
    add a bump to the middle part (right). We now have four segments of length *b*
    / 3, to which bumps can be added again (bottom).'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-14：将线段分成三等分（左），在中间部分添加一个凸起（右）。现在我们有长度为*b*/3的四段线段，可以再次添加凸起（底部）。
- en: To create the *Koch snowflake*, we start with an equilateral triangle and construct
    three Koch curves from its three sides, as in [Figure 9-15](#figure9-15).
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建*科赫雪花*，我们从一个等边三角形开始，并从其三边构造三个科赫曲线，如[图9-15](#figure9-15)所示。
- en: '![Two diagrams: an equilateral triangle, and the same equilateral triangle
    whose sides have been replaced with Koch curves, forming a snowflake shape.](image_fi/502024c09/f09015.png)'
  id: totrans-1408
  prefs: []
  type: TYPE_IMG
  zh: '![两个图表：一个等边三角形，以及其边被科赫曲线替换后形成的雪花形状。](image_fi/502024c09/f09015.png)'
- en: 'Figure 9-15: Creating three Koch curves on the three sides of an equilateral
    triangle to form a Koch snowflake'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-15：在等边三角形的三边上创建三个科赫曲线，形成科赫雪花
- en: Each time you create a new bump, you are increasing the curve’s length from
    three *b* / 3 lengths to four *b* / 3 lengths, or 4*b* / 3\. If you continue to
    do this with the three sides of an equilateral triangle, you’ll create the Koch
    snowflake, as in [Figure 9-16](#figure9-16). (The small dotted patterns are artifacts,
    because slight rounding errors cause the `turtle` module to be unable to completely
    erase the middle *b* / 3 segment.) You can continue to create new bumps forever,
    though our program stops when they get smaller than a few pixels.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个新的凸起，都会将曲线的长度从三个*b*/3长度增加到四个*b*/3长度，或4*b*/3。如果你继续在等边三角形的三边上这样做，你将创建科赫雪花，就像[图9-16](#figure9-16)中所示的那样。（小点状图案是因为轻微的舍入误差导致`turtle`模块无法完全擦除中间的*b*/3段。）你可以继续永远创建新的凸起，尽管我们的程序在它们变得小于几个像素时停止。
- en: '![Turtle graphic screenshot of a snowflake created using many Koch bumps.](image_fi/502024c09/f09016.png)'
  id: totrans-1411
  prefs: []
  type: TYPE_IMG
  zh: '![使用许多科赫凸起创建的雪花的海龟图形截图。](image_fi/502024c09/f09016.png)'
- en: 'Figure 9-16: A Koch snowflake. Some of the interior lines remain because of
    small rounding errors.'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-16：科赫雪花。由于小的舍入误差，一些内部线条仍然存在。
- en: 'The source code for *kochSnowflake.py* is as follows:'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: '*kochSnowflake.py*的源代码如下：'
- en: '**Python**'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE162]'
  id: totrans-1415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The Koch snowflake is also sometimes called the *Koch island*. Its coastline
    would be literally infinitely long. While the Koch snowflake fits into the finite
    area of a page of this book, the length of its perimeter is infinite, proving
    that, while it seems counterintuitive, the finite can contain the infinite!
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 科赫雪花有时也被称为*科赫岛*。它的海岸线将是无限长的。虽然科赫雪花可以放入本书一页的有限区域，但其周长的长度是无限的，证明了，尽管看起来违反直觉，有限可以包含无限！
- en: The Hilbert Curve
  id: totrans-1417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 希尔伯特曲线
- en: A *space-filling curve* is a 1D line that curves around until it completely
    fills a 2D space without crossing over itself. German mathematician David Hilbert
    described his space-filling *Hilbert curve* in 1891\. If you split a 2D area into
    a grid, the single, 1D line of the Hilbert curve can run through every cell in
    the grid.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: '*填充曲线*是一条1D曲线，它弯曲直到完全填满2D空间而不交叉。德国数学家大卫·希尔伯特于1891年描述了他的填充曲线。如果你将一个2D区域分成一个网格，希尔伯特曲线的单一1D线可以穿过网格中的每个单元格。'
- en: '[Figure 9-17](#figure9-17) contains the first three recursions of the Hilbert
    curve. The next recursion contains four copies of the previous recursion, and
    the dashed line shows how the four copies connect to one another.'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-17包含希尔伯特曲线的前三次递归。下一次递归包含前一次递归的四个副本，虚线显示了这四个副本如何连接在一起。
- en: '![Three diagrams. The first is a grid with four square cells. Three lines are
    drawn to connect the center points of the cells, forming three sides of a square
    in the center of the grid. The second diagram shows each cell of the original
    grid subdivided into four cells and the same lines drawn across each of those
    cells. The fourth shows the cells further subdivided and populated by the same
    line pattern.](image_fi/502024c09/f09017.png)'
  id: totrans-1420
  prefs: []
  type: TYPE_IMG
  zh: '![三个图表。第一个是一个具有四个正方形单元格的网格。画出三条线连接单元格中心点，形成网格中心的正方形的三条边。第二个图表显示原始网格的每个单元格细分为四个单元格，并在每个单元格上画出相同的线。第四个显示单元格进一步细分，并由相同的线条图案填充。](image_fi/502024c09/f09017.png)'
- en: 'Figure 9-17: The first three recursions of the Hilbert space-filling curve'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-17：希尔伯特填充曲线的前三次递归
- en: As the cells become infinitesimal points, the 1D curve can fill the entire 2D
    space the same way a 2D square does. Counterintuitively, this creates a 2D shape
    from a strictly 1D line!
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元格变成无穷小点时，1D曲线可以像2D正方形一样填满整个2D空间。令人费解的是，这样可以从严格的1D线创建一个2D形状！
- en: 'The source code for *hilbertCurve.py* is as follows:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: '*hilbertCurve.py*的源代码如下：'
- en: '**Python**'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE163]'
  id: totrans-1425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Try experimenting with this code by decreasing `LINE_LENGTH` to shorten the
    line segments while increasing `LEVELS` to add more levels of recursion. Because
    this program uses only relative movements for the turtle, you can uncomment the
    `turtle.setheading(20)` line to draw the Hilbert curve at a 20-degree angle. [Figure
    9-18](#figure9-18) shows the drawing produced with `LINE_LENGTH` of `10` and `LEVELS`
    of `5`.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过减小`LINE_LENGTH`来缩短线段的长度，同时增加`LEVELS`来增加递归的层次。因为这个程序只使用海龟的相对移动，你可以取消注释`turtle.setheading(20)`这一行来以20度角绘制希尔伯特曲线。[图9-18](#figure9-18)显示了使用`LINE_LENGTH`为`10`和`LEVELS`为`5`时产生的绘图。
- en: '![Turtle graphics screenshot. The entire window is covered in a Hilbert curve.](image_fi/502024c09/f09018.png)'
  id: totrans-1427
  prefs: []
  type: TYPE_IMG
  zh: '![乌龟图形屏幕截图。整个窗口都覆盖着希尔伯特曲线。](image_fi/502024c09/f09018.png)'
- en: 'Figure 9-18: Five levels of the Hilbert curve, with line length `10`'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-18：希尔伯特曲线的五个级别，线长为`10`
- en: The Hilbert curve makes 90-degree (right-angle) turns. But try adjusting the
    `ANGLE` variable by a few degrees to `89` or `86`, and run the program to view
    the changes. You can also set the `DRAW_SOLID` variable to `True` to produce a
    filled-in Hilbert curve, as in [Figure 9-19](#figure9-19).
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 希尔伯特曲线进行90度（直角）转弯。但尝试将`ANGLE`变量调整几度至`89`或`86`，并运行程序查看变化。您还可以将`DRAW_SOLID`变量设置为`True`，以生成填充的希尔伯特曲线，如[图9-19](#figure9-19)。
- en: '![Turtle graphics screenshot of the same Hilbert curve drawing, this time with
    the black and white portions reversed.](image_fi/502024c09/f09019.png)'
  id: totrans-1430
  prefs: []
  type: TYPE_IMG
  zh: '![乌龟图形屏幕截图，这次黑白部分颠倒的希尔伯特曲线绘制。](image_fi/502024c09/f09019.png)'
- en: 'Figure 9-19: Six levels of the Hilbert curve, filled in, with line length `5`'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-19：填充的希尔伯特曲线的六个级别，线长为`5`
- en: Summary
  id: totrans-1432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The incredibly wide field of fractals combines all the most interesting parts
    of programming and art, making this chapter the most fun to write. Mathematicians
    and computer scientists talk about the beauty and elegance that the advanced topics
    of their fields produce, but recursive fractals are able to turn this conceptual
    beauty into visual beauty that anyone can appreciate.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 分形的广阔领域结合了编程和艺术的最有趣的部分，使得这一章节成为最有趣的写作。数学家和计算机科学家谈论他们领域的高级主题产生的美丽和优雅，但递归分形能够将这种概念上的美丽转化为任何人都能欣赏的视觉美。
- en: 'This chapter covered several fractals and the programs that draw them: the
    Sierpiński triangle, the Sierpiński carpet, procedurally generated fractal trees,
    the Koch curve and snowflake, and the Hilbert curve. All of these were drawn with
    Python’s `turtle` module and functions that recursively call themselves.'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了几种分形和绘制它们的程序：谢尔宾斯基三角形、谢尔宾斯基地毯、程序生成的分形树、科赫曲线和雪花、以及希尔伯特曲线。所有这些都是使用Python的`turtle`模块和递归调用自身的函数绘制的。
- en: Further Reading
  id: totrans-1435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about drawing with Python’s `turtle` module, I’ve written a simple
    tutorial at [https://github.com/asweigart/simple-turtle-tutorial-for-python](https://github.com/asweigart/simple-turtle-tutorial-for-python).
    I also have a personal collection of turtle programs at [https://github.com/asweigart/art-of-turtle-programming](https://github.com/asweigart/art-of-turtle-programming).
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于使用Python的`turtle`模块绘图的知识，我在[https://github.com/asweigart/simple-turtle-tutorial-for-python](https://github.com/asweigart/simple-turtle-tutorial-for-python)写了一个简单的教程。我还在[https://github.com/asweigart/art-of-turtle-programming](https://github.com/asweigart/art-of-turtle-programming)上有一个个人的乌龟程序集合。
- en: The question of Great Britain’s coastline’s length came from the title of a
    1967 paper by Mandelbrot. The idea is summarized nicely on Wikipedia at [https://en.wikipedia.org/wiki/Coastline_paradox](https://en.wikipedia.org/wiki/Coastline_paradox).
    Khan Academy has more on the geometry of the Koch snowflake at [https://www.khanacademy.org/math/geometry-home/geometry-volume-surface-area/koch-snowflake/v/koch-snowflake-fractal](https://www.khanacademy.org/math/geometry-home/geometry-volume-surface-area/koch-snowflake/v/koch-snowflake-fractal).
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 关于英国海岸线长度的问题来自曼德布罗特在1967年的一篇论文的标题。这个想法在维基百科上有很好的总结。可汗学院有更多关于科赫雪花几何的内容。
- en: 'The 3Blue1Brown YouTube channel has excellent animations of fractals, particularly
    the “Fractals Are Typically Not Self-Similar” video at [https://youtu.be/gB9n2gHsHN4](https://youtu.be/gB9n2gHsHN4)
    and the “Fractal Charm: Space-Filling Curves” video at [https://youtu.be/RU0wScIj36o](https://youtu.be/RU0wScIj36o).'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 3Blue1Brown YouTube频道有关分形的出色动画，特别是“分形通常不是自相似”的视频和“分形魅力：填充曲线”视频。
- en: Other space-filling curves require recursion to draw, such as the Peano curve,
    Gosper curve, and dragon curve, and they’re worth researching on the web.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 其他填充曲线需要递归来绘制，例如皮亚诺曲线、戈斯珀曲线和龙曲线，值得在网上进行研究。
- en: Practice Questions
  id: totrans-1440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习问题
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试您的理解：
- en: What are fractals?
  id: totrans-1442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是分形？
- en: What do the x- and y-coordinates represent in a Cartesian coordinate system?
  id: totrans-1443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 笛卡尔坐标系中的x和y坐标代表什么？
- en: What are the origin coordinates in a Cartesian coordinate system?
  id: totrans-1444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 笛卡尔坐标系中的原点坐标是什么？
- en: What is procedural generation?
  id: totrans-1445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是程序生成？
- en: What is a seed value?
  id: totrans-1446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是种子值？
- en: How long is the perimeter of a Koch snowflake?
  id: totrans-1447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 科赫雪花的周长有多长？
- en: What is a space-filling curve?
  id: totrans-1448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是填充曲线？
- en: Practice Projects
  id: totrans-1449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习项目
- en: 'For practice, write a program for each of the following tasks:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习，为以下每个任务编写一个程序：
- en: 'Create a turtle program that draws a box fractal as shown in [Figure 9-20](#figure9-20).
    This program is similar to the Sierpiński carpet program introduced in this chapter.
    Use the `turtle.begin_fill()` and `turtle.end_fill()` functions to draw the first
    large, black square. Then split this square into nine equal sections, and draw
    white squares in the top, left, right, and bottom squares. Repeat this process
    for the four corner squares and the center square.![Turtle graphics screenshot.
    Shows 25 black squares arranged so that they form five larger squares: one square
    in each corner and one square in the center. These five larger squares are arranged
    to form one even larger square.](image_fi/502024c09/f09020.png)'
  id: totrans-1451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个乌龟程序，绘制如[图9-20](#figure9-20)所示的盒子分形。这个程序类似于本章介绍的谢尔宾斯基地毯程序。使用`turtle.begin_fill()`和`turtle.end_fill()`函数来绘制第一个大的黑色正方形。然后将这个正方形分成九个相等的部分，在顶部、左侧、右侧和底部的正方形中绘制白色正方形。对四个角落的正方形和中心正方形重复这个过程。![乌龟图形截图。显示25个黑色正方形排列成五个更大的正方形：每个角落一个正方形，中心一个正方形。这五个更大的正方形排列成一个更大的正方形。](image_fi/502024c09/f09020.png)
- en: 'Figure 9-20: A box fractal, drawn to two levels'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-20：一个绘制了两层的盒子分形
- en: Create a turtle program that draws a Peano space-filling curve. This is similar
    to the Hilbert curve program in this chapter. [Figure 9-21](#figure9-21) shows
    the first three iterations of the Peano curve. While each Hilbert curve iteration
    is split across a 2 × 2 section (which is, in turn, split into 2 × 2 sections),
    the Peano curve is split across 3 × 3 sections.![A straight line bent at right
    angles into a curve-like shape that travels through the center points of the square
    cells in a 3 × 3 grid. The other diagrams show similar curves traveling through
    the center points of increasingly larger grids.](image_fi/502024c09/f09021.png)
  id: totrans-1453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个乌龟程序，绘制Peano填充曲线。这类似于本章中的希尔伯特曲线程序。[图9-21](#figure9-21)显示了Peano曲线的前三次迭代。虽然每个希尔伯特曲线迭代被分割成2×2的部分（依次分割成2×2的部分），Peano曲线被分割成3×3的部分。![一条直线在一个3×3网格的正方形单元格的中心点处弯曲成曲线状，其他图表显示类似的曲线穿过越来越大网格的中心点。](image_fi/502024c09/f09021.png)
- en: 'Figure 9-21: The first three iterations of the Peano curve, from left to right.
    The bottom row includes the 3 × 3 sections that each part of the curve is split
    across.`*``'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-21：Peano曲线的前三次迭代，从左到右。底部一行包括每个曲线部分分割的3×3部分。`*``

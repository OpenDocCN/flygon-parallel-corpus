- en: Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: UNDERSTANDING RECURSION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 理解递归
- en: '1'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: What Is Recursion?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是递归？
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'Recursion has an intimidating reputation. It’s considered hard to understand,
    but at its core, it depends on only two things: function calls and stack data
    structures.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 递归有着令人望而生畏的声誉。人们认为很难理解，但其核心只依赖于两件事：函数调用和栈数据结构。
- en: 'Most new programmers trace through what a program does by following the execution.
    It’s an easy way to read code: you just put your finger on the line of code at
    the top of the program and move down. Sometimes your finger will loop back; other
    times, it will jump into a function and later return. This makes it easy to visualize
    what a program does and in what order.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数新程序员通过跟踪执行来追踪程序的操作。这是阅读代码的简单方法：你只需把手指放在程序顶部的代码行上，然后向下移动。有时你的手指会回到原点；其他时候，它会进入一个函数，然后返回。这使得很容易可视化程序的操作和顺序。
- en: But to understand recursion, you need to become familiar with a less obvious
    data structure, called the *call stack*, that controls the program’s flow of execution.
    Most programming beginners don’t know about stacks, because programming tutorials
    often don’t even mention them when discussing function calls. Furthermore, the
    call stack that automatically manages function calls doesn’t appear anywhere in
    the source code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但要理解递归，你需要熟悉一个不太明显的数据结构，称为*调用栈*，它控制程序的执行流程。大多数编程初学者不了解栈，因为编程教程在讨论函数调用时通常甚至不提及它们。此外，自动管理函数调用的调用栈在源代码中根本看不到。
- en: It’s hard to understand something when you can’t see it and don’t know it exists!
    In this chapter, we’ll pull back the curtain to dispel the overblown notion that
    recursion is hard, and you’ll be able to appreciate the elegance underneath.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '当你看不见并且不知道它的存在时，很难理解某件事！在本章中，我们将拉开窗帘，消除递归难以理解的夸大概念，你将能够欣赏其中的优雅之处。 '
- en: The Definition of Recursion
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归的定义
- en: 'Before we begin, let’s get the clichéd recursion jokes out of the way, starting
    with this: “To understand recursion, you must first understand recursion.”'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们先把陈词滥调的递归笑话搞定，比如：“要理解递归，你必须先理解递归。”
- en: During the months I’ve spent writing this book, I can assure you that this joke
    gets funnier the more you hear it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我写这本书的几个月里，我可以向你保证，这个笑话听得越多就越好笑。
- en: Another joke is that if you search Google for *recursion*, the results page
    asks if you mean *recursion*. Following the link, as shown in [Figure 1-1](#figure1-1),
    takes you to . . . the search results for *recursion*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个笑话是，如果你在谷歌上搜索*递归*，结果页面会问你是否是指*递归*。点击链接，如[图1-1](#figure1-1)所示，会带你到...*递归*的搜索结果。
- en: '![Screenshot of a Google search for the term “recursion.” Below the search
    bar is a banner that reads, “Did you mean: recursion.”](image_fi/502024c01/f01001.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![谷歌搜索术语“递归”的截图。在搜索栏下方是一个横幅，上面写着“您是不是要找：递归。”](image_fi/502024c01/f01001.png)'
- en: 'Figure 1-1: The Google search results for *recursion* link to the Google search
    results for *recursion*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-1：*递归*的谷歌搜索结果链接到*递归*的谷歌搜索结果。
- en: '[Figure 1-2](#figure1-2) shows a recursion joke from the webcomic xkcd.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-2](#figure1-2)显示了网络漫画xkcd中的一个递归笑话。'
- en: '![A one-panel comic of someone reading the text “I’m so meta, even this acronym.”](image_fi/502024c01/f01002.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![一个单格漫画，有人在读“我如此元，甚至这个首字母缩略词。”](image_fi/502024c01/f01002.png)'
- en: 'Figure 1-2: I’m So Meta, Even This Acronym (I.S. M.E.T.A.) ([xkcd.com/917](http://xkcd.com/917)
    by Randall Munroe)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2：我如此元，甚至这个首字母缩略词（I.S. M.E.T.A.）([xkcd.com/917](http://xkcd.com/917) by Randall
    Munroe)
- en: Most jokes about the 2010 science fiction action movie *Inception* are recursion
    jokes. The film features characters having dreams within dreams within dreams.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于2010年科幻动作电影《盗梦空间》的大多数笑话都是递归笑话。电影中的角色在梦中有梦，而这些梦中还有梦。
- en: And finally, what computer scientist could forget that monster from Greek mythology,
    the recursive centaur? As you can see in [Figure 1-3](#figure1-3), it is half
    horse, half recursive centaur.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为计算机科学家，谁能忘记希腊神话中的递归半人马怪物？正如你在[图1-3](#figure1-3)中所看到的，它是半马半递归半人马。
- en: '![Image of a statue with a horse’s body whose front legs and torso repeat,
    decreasing in size, in a spiral pattern.](image_fi/502024c01/f01003.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图中是一个雕像，有马的身体，前腿和躯干呈螺旋状重复，尺寸逐渐减小。](image_fi/502024c01/f01003.png)'
- en: 'Figure 1-3: The recursive centaur. Image by Joseph Parker.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3：递归半人马。Joseph Parker提供的图片。
- en: 'Based on these jokes, you might conclude that recursion is a sort of meta,
    self-referencing, dream-within-a-dream, infinite mirror-into-mirror sort of thing.
    Let’s establish a concrete definition: a *recursive* thing is something whose
    definition includes itself. That is, it has a self-referential definition.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些笑话，你可能会得出结论，递归是一种元、自我引用、梦中梦、无限镜中镜的东西。让我们建立一个具体的定义：*递归*是指其定义包括自身的东西。也就是说，它具有自我引用的定义。
- en: The Sierpiński triangle in [Figure 1-4](#figure1-4) is defined as an equilateral
    triangle with an upside-down triangle in the middle that forms three new equilateral
    triangles, each of which contains a Sierpiński triangle. The definition of Sierpiński
    triangles includes Sierpiński triangles.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-4](#figure1-4)中的谢尔宾斯基三角形被定义为一个等边三角形，中间有一个倒置的三角形，形成三个新的等边三角形，每个三角形都包含一个谢尔宾斯基三角形。谢尔宾斯基三角形的定义包括谢尔宾斯基三角形。'
- en: '![Graphic depicting three triangles. The first triangle has a smaller upside-down
    triangle in the center that divides the original into smaller triangles. The next
    triangle shows those three smaller outer triangles, each divided into still smaller
    triangles. The third triangle shows those smaller triangles further divided into
    triangles.](image_fi/502024c01/f01004.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图形描绘了三角形。第一个三角形中间有一个较小的倒置三角形，将原始三角形分成较小的三角形。下一个三角形显示了这三个较小的外部三角形，每个都分成更小的三角形。第三个三角形显示了这些更小的三角形进一步分成三角形。](image_fi/502024c01/f01004.png)'
- en: 'Figure 1-4: Sierpiński triangles are fractals (recursive shapes) that include
    Sierpiński triangles.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4：谢尔宾斯基三角形是包含谢尔宾斯基三角形的分形（递归形状）。
- en: In a programming context, a *recursive function* is a function that calls itself.
    Before we explore recursive functions, let’s take a step back and understand how
    regular functions work. Programmers tend to take function calls for granted, but
    even experienced programmers will find it worthwhile to review functions in the
    next section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程上下文中，*递归函数*是调用自身的函数。在我们探索递归函数之前，让我们退一步，了解正常函数是如何工作的。程序员往往认为函数调用理所当然，但即使是有经验的程序员也会发现值得回顾下一节中的函数。
- en: What Are Functions?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是函数？
- en: '*Functions* can be described as mini-programs inside your program. They’re
    a feature of nearly every programming language. If you need to run identical instructions
    at three different places in a program, instead of copying and pasting the source
    code three times you can write the code in a function once and call the function
    three times. The beneficial result is a shorter and more readable program. The
    program is also easier to change: if you need to fix a bug or add features, you
    need to change your program in only one place instead of three.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*可以被描述为程序中的迷你程序。它们是几乎每种编程语言的特性。如果您需要在程序中的三个不同位置运行相同的指令，而不是将源代码复制粘贴三次，您可以在函数中编写一次代码并调用函数三次。有益的结果是更短和更易读的程序。程序也更容易更改：如果您需要修复错误或添加功能，您只需要在一个地方更改程序，而不是三个地方。'
- en: 'All programming languages implement four features in their functions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程语言在它们的函数中实现了四个特性：
- en: Functions have code that is run when the function is called.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数有在调用函数时运行的代码。
- en: '*Arguments* (that is, values) are passed to the function when it’s called.
    This is the input to the function, and functions can have zero or more arguments.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*参数*（即值）在调用函数时传递。这是函数的输入，函数可以有零个或多个参数。'
- en: Functions return a *return value*. This is the output of the function, though
    some programming languages allow functions not to return anything or to return
    null values like `undefined` or `None`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数返回一个*返回值*。这是函数的输出，尽管一些编程语言允许函数不返回任何东西或返回像`undefined`或`None`这样的空值。
- en: The program remembers which line of code called the function and returns to
    it when the function finishes its execution.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序记住了调用函数的代码行，并在函数完成执行时返回到它。
- en: Different programming languages might have additional features, or different
    options for how to call functions, but they all have these four general elements.
    You can visually see the first three of these elements because you write them
    in the source code, but how does a program keep track of where the execution should
    return to when the function returns?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言可能具有其他特性，或者对如何调用函数有不同的选项，但它们都具有这四个一般元素。您可以在源代码中直观地看到这四个元素中的前三个，但是当函数返回时，程序如何跟踪执行应该返回到哪里呢？
- en: 'To get a better sense of the problem, create a *functionCalls.py* program that
    has three functions: `a()`, which calls `b()`, which calls `c()`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解问题，创建一个*functionCalls.py*程序，其中包含三个函数：`a()`调用`b()`，`b()`调用`c()`：
- en: '**Python**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code is equivalent to the following *functionCalls.html* program:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码等同于以下*functionCalls.html*程序：
- en: '**JavaScript**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you run this code, the output looks like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，输出如下：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output shows the start of functions `a()`, `b()`, and `c()`. Then, when
    the functions return, the output appears in reverse order: `c()`, `b()`, and then
    `a()`. Notice the pattern to the text output: each time a function returns, it
    remembers which line of code originally called it. When the `c()` function call
    ends, the program returns to the `b()` function and displays `b() is returning`.
    Then the `b()` function call ends, and the program returns to the `a()` function
    and displays `a() is returning`. Finally, the program returns to the original
    `a()` function call at the end of the program. In other words, function calls
    don’t send the execution of the program on a one-way trip.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了函数`a()`，`b()`和`c()`的开始。然后，当函数返回时，输出以相反的顺序出现：`c()`，`b()`，然后是`a()`。注意文本输出的模式：每次函数返回时，它都记住了最初调用它的代码行。当`c()`函数调用结束时，程序返回到`b()`函数并显示`b()正在返回`。然后`b()`函数调用结束，程序返回到`a()`函数并显示`a()正在返回`。最后，程序返回到程序末尾的原始`a()`函数调用。换句话说，函数调用并不会使程序的执行成为单向行程。
- en: But how does the program remember if it was `a()` or `b()` that called `c()`?
    This detail is handled by the program implicitly with a call stack. To understand
    how call stacks remember where the execution returns at the end of a function
    call, we need to first understand what a stack is.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但程序如何记住是`a()`还是`b()`调用了`c()`？这个细节由程序隐式处理，使用一个调用栈。要理解调用栈如何记住函数调用结束时执行返回的位置，我们首先需要了解栈是什么。
- en: What Are Stacks?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是栈？
- en: 'Earlier I mentioned the clichéd wisecrack, “To understand recursion, you must
    first understand recursion.” But this is actually wrong: to really understand
    recursion, you must first understand stacks.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我提到过一个陈词滥调的笑话，“要理解递归，你必须先理解递归。”但这实际上是错误的：要真正理解递归，你必须先理解栈。
- en: A *stack* is one of the simplest data structures in computer science. It stores
    multiple values like a list does—but unlike lists, it limits you to adding to
    or removing values from the “top” of the stack only. For stacks implemented with
    lists or arrays, the “top” is the last item, at the right end of the list or array.
    Adding values is called *pushing* values onto the stack, while removing values
    is called *popping* values off the stack.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*栈*是计算机科学中最简单的数据结构之一。它像列表一样存储多个值，但与列表不同的是，它只限制您在栈的“顶部”添加或删除值。对于使用列表或数组实现的栈，“顶部”是最后一个项目，在列表或数组的右端。添加值称为*推送*值到栈上，而删除值称为*弹出*值出栈。'
- en: Imagine that you’re engaged in a meandering conversation with someone. You’re
    talking about your friend Alice, which then reminds you of a story about your
    co-worker Bob, but for that story to make sense, you first have to explain something
    about your cousin Carol. You finish your story about Carol and go back to talking
    about Bob, and when you finish your story about Bob, you go back to talking about
    Alice. Then you are reminded about your brother David, so you tell a story about
    him. Eventually, you get around to finishing your original story about Alice.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您正在与某人进行一场漫谈。您正在谈论您的朋友Alice，然后想起了关于您同事Bob的故事，但为了讲清楚这个故事，您首先必须解释一些关于您表妹Carol的事情。您讲完了关于Carol的故事，然后回到谈论Bob，当您讲完了关于Bob的故事后，您又回到了谈论Alice。然后您想起了您的兄弟David，于是您讲了一个关于他的故事。最终，您回到了最初关于Alice的故事。
- en: Your conversation follows a stack-like structure, as in [Figure 1-5](#figure1-5).
    The conversation is stack-like because the current topic is always at the top
    of the stack.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您的对话遵循类似堆栈的结构，就像[图1-5](#figure1-5)中的那样。对话类似于堆栈，因为当前话题总是在堆栈的顶部。
- en: '![A timeline that shows names stacked one on top of the other at various points
    in time. It begins with no names, then shows Alice, then Bob on top of Alice,
    then Carol on top of Bob on top of Alice, then Bob on top of Alice, then just
    Alice, then David on top of Alice, then Just Alice once more, then no names.](image_fi/502024c01/f01005.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![一个时间轴，显示了各个时间点上叠放在一起的名字。它从没有名字开始，然后显示了Alice，然后是Alice上面的Bob，然后是Alice上面的Bob上面的Carol，然后是Alice上面的Bob，然后只有Alice，然后是Alice上面的David，然后再次只有Alice，最后没有名字。](image_fi/502024c01/f01005.png)'
- en: 'Figure 1-5: Your meandering conversation stack'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-5：您的漫谈对话堆栈
- en: In our conversation stack, the new topics are added to the top of the stack
    and taken off as they are completed. The previous topics are “remembered” underneath
    the current topic in the stack.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的对话堆栈中，新话题被添加到堆栈的顶部，并在完成时被移除。之前的话题在堆栈中的当前话题下面被“记住”。
- en: We can use Python lists as stacks if, to amend the list’s contents, we limit
    ourselves to the `append()` and `pop()` methods to perform pushing and popping.
    JavaScript arrays can also be used as stacks through their `push()` and `pop()`
    methods.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们限制自己使用`append()`和`pop()`方法来执行推入和弹出操作，我们可以将Python列表用作堆栈。JavaScript数组也可以通过它们的`push()`和`pop()`方法用作堆栈。
- en: 'For example, consider this *cardStack.py* program, which pushes and pops string
    values of playing cards to the end of a list named `cardStack`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个*cardStack.py*程序，它将扑克牌的字符串值推入和弹出到名为`cardStack`的列表的末尾：
- en: '**Python**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following *cardStack.html* program contains the equivalent code in JavaScript:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的*cardStack.html*程序包含了JavaScript中的等效代码：
- en: '**JavaScript**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you run this code, the output looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，输出如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The stack starts off as empty ❶. Three strings representing cards are pushed
    onto the stack ❷. Then the stack is popped ❸, which removes the ace of hearts
    and leaves the three of clubs at the top of the stack again. The state of the
    `cardStack` stack is tracked in [Figure 1-6](#figure1-6), going from left to right.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈从空开始❶。推入堆栈的是代表卡片的三个字符串❷。然后弹出堆栈❸，这将移除红桃A并再次将梅花三放在堆栈的顶部。`cardStack`堆栈的状态在[图1-6](#figure1-6)中进行了跟踪，从左到右。
- en: '![Timeline showing playing cards stacked on top of each other at various points
    in time. Begins with no cards, then the five of diamonds, then the three of clubs
    on top of the five of diamonds, then the ace of hearts on top of the three of
    clubs, and finally the ace of hearts removed to reveal the three of clubs.](image_fi/502024c01/f01006.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴显示了在不同时间点上叠放在一起的扑克牌。从没有扑克牌开始，然后是方块五，然后是梅花三叠在方块五上面，然后是红桃A叠在梅花三上面，最后移除红桃A以显示梅花三。](image_fi/502024c01/f01006.png)'
- en: 'Figure 1-6: The stack starts empty. Cards are then pushed onto and popped off
    the stack.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-6：堆栈开始为空。然后将卡片推入和弹出堆栈。
- en: You can see only the topmost card in the card stack, or, in our program’s stacks,
    the topmost value. In the simplest stack implementations, you can’t see how many
    cards (or values) are in the stack. You can see only whether the stack is empty
    or not.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能看到卡堆中的最顶部卡片，或者在我们程序的堆栈中，最顶部的值。在最简单的堆栈实现中，您无法看到堆栈中有多少张卡片（或值）。您只能看到堆栈是否为空。
- en: Stacks are a *LIFO* data structure, which stands for *last in, first out*, since
    the last value pushed onto the stack is the first value popped out of it. This
    behavior is similar to your web browser’s Back button. Your browser tab’s history
    functions like a stack that contains all the pages you’ve visited in the order
    that you visited them. The browser is always displaying the web page at the “top”
    of the history’s “stack.” Clicking a link pushes a new web page onto the history
    stack, while clicking the Back button pops the top web page off and reveals the
    one “underneath.”
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈是一种*LIFO*数据结构，代表*后进先出*，因为推入堆栈的最后一个值是弹出的第一个值。这种行为类似于您的网络浏览器的“返回”按钮。您的浏览器标签的历史记录就像一个包含您按顺序访问的所有页面的堆栈。浏览器始终显示历史记录“堆栈”中的顶部网页。单击链接会将新网页推入历史记录堆栈，而单击“返回”按钮会弹出顶部网页并显示其下面的网页。
- en: What Is the Call Stack?
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用堆栈是什么？
- en: Programs use stacks too. The program’s *call stack*, also simply called *the
    stack*, is a stack of frame objects. *Frame objects*, also simply called *frames*,
    contain information about a single function call, including which line of code
    called the function, so the execution can move back there when the function returns.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 程序也使用堆栈。程序的*调用堆栈*，也简称为*堆栈*，是一堆帧对象。*帧对象*，也简称为*帧*，包含有关单个函数调用的信息，包括调用函数的代码行，因此当函数返回时，执行可以回到那里。
- en: Frame objects are created and pushed onto the stack when a function is called.
    When the function returns, that frame object is popped off the stack. If we call
    a function that calls a function that calls a function, the call stack will have
    three frame objects on the stack. When all these functions return, the call stack
    will have zero frame objects on the stack.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，将创建帧对象并将其推送到堆栈上。当函数返回时，该帧对象将从堆栈中弹出。如果我们调用一个调用一个调用函数的函数，调用堆栈将在堆栈上有三个帧对象。当所有这些函数返回时，调用堆栈将在堆栈上有零个帧对象。
- en: 'Programmers don’t have to write code dealing with frame objects, since the
    programming language handles them automatically. Different programming languages
    have different ways of implementing frame objects, but in general they contain
    the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员不必编写处理帧对象的代码，因为编程语言会自动处理它们。不同的编程语言有不同的实现帧对象的方式，但通常它们包含以下内容：
- en: The return address, or the spot in the program where the execution should move
    when the function returns
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回地址，或者函数返回时执行的位置
- en: The arguments passed to the function call
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给函数调用的参数
- en: A set of local variables created during the function call
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数调用期间创建的一组局部变量
- en: 'For example, take a look at the following *localVariables.py* program, which
    has three functions, just as our previous *functionCalls.py* and *functionCalls.html*
    programs did:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下以下*localVariables.py*程序，它有三个函数，就像我们之前的*functionCalls.py*和*functionCalls.html*程序一样：
- en: '**Python**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This *localVariables.html* is the equivalent JavaScript program:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*localVariables.html*是等效的JavaScript程序：
- en: '**JavaScript**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you run this code, the output looks like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，输出如下所示：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the program calls function `a()` ❼, a frame object is created and placed
    on the top of the call stack. This frame stores any arguments passed to `a()`
    (in this case, there are none), along with the local variable `spam` ❶ and the
    place where the execution should go when the `a()` function returns.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序调用函数`a()` ❼时，将创建一个帧对象并将其放置在调用堆栈顶部。该帧存储传递给`a()`的任何参数（在本例中没有），以及局部变量`spam`
    ❶和`a()`函数返回时执行的位置。
- en: When `a()` is called, it displays the contents of its local `spam` variable,
    which is `Ant` ❷. When the code in `a()` calls function `b()` ❸, a new frame object
    is created and placed on the call stack above the frame object for `a()`. The
    `b()` function has its own local `spam` variable ❹, and calls `c()` ❺. A new frame
    object for the `c()` call is created and placed on the call stack, and it contains
    `c()`’s local `spam` variable ❻. As these functions return, the frame objects
    pop off the call stack. The program execution knows where to return to, because
    that return information is stored in the frame object. When the execution has
    returned from all function calls, the call stack is empty.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`a()`时，它显示其局部`spam`变量的内容，即`Ant` ❷。当`a()`中的代码调用函数`b()` ❸时，将创建一个新的帧对象并将其放置在调用堆栈上方，用于`a()`的帧对象。`b()`函数有自己的局部`spam`变量
    ❹，并调用`c()` ❺。为`c()`调用创建一个新的帧对象并将其放置在调用堆栈上，其中包含`c()`的局部`spam`变量 ❻。随着这些函数的返回，帧对象从调用堆栈中弹出。程序执行知道要返回到哪里，因为返回信息存储在帧对象中。当执行从所有函数调用返回时，调用堆栈为空。
- en: '[Figure 1-7](#figure1-7) shows the state of the call stack as each function
    is called and returns. Notice that all the local variables have the same name:
    `spam`. I did this to highlight the fact that local variables are always separate
    variables with distinct values, even if they have the same name as local variables
    in other functions.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-7](#figure1-7)显示了每个函数调用和返回时调用堆栈的状态。请注意，所有局部变量都具有相同的名称：`spam`。我这样做是为了突出局部变量始终是具有不同值的单独变量，即使它们与其他函数中的局部变量具有相同的名称。'
- en: '![Timeline depicting the state of a call stack at various points in time. It
    begins empty. Then, within the a() function, the spam variable equals “Ant.” Next,
    within the b() variable, spam equals “Bobcat,” and then within the c() function,
    spam equals “Coyote.” Within the b() function, spam once again equals “Bobcat,”
    and within the a() function, spam once again equals “Ant.”](image_fi/502024c01/f01007.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴描绘了调用堆栈在不同时间点的状态。它开始为空。然后，在a()函数中，spam变量等于“Ant”。接下来，在b()函数中，spam等于“Bobcat”，然后在c()函数中，spam等于“Coyote”。在b()函数中，spam再次等于“Bobcat”，在a()函数中，spam再次等于“Ant”。](image_fi/502024c01/f01007.png)'
- en: 'Figure 1-7: The state of the call stack as the *localVariables* program runs'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-7：*localVariables*程序运行时调用堆栈的状态
- en: As you can see, programming languages can have separate local variables with
    the same name (`spam`) because they are kept in separate frame objects. When a
    local variable is used in the source code, the variable with that name in the
    topmost frame object is used.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，编程语言可以具有相同名称（`spam`）的单独的局部变量，因为它们保存在单独的帧对象中。当在源代码中使用局部变量时，将使用顶部帧对象中具有该名称的变量。
- en: Every running program has a call stack, and multithreaded programs have one
    call stack for each thread. But when you look at the source code for a program,
    you can’t see the call stack in the code. The call stack isn’t stored in a variable
    as other data structures are; it’s automatically handled in the background.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行的程序都有一个调用堆栈，多线程程序每个线程都有一个调用堆栈。但是当您查看程序的源代码时，您无法在代码中看到调用堆栈。调用堆栈不像其他数据结构一样存储在变量中；它在后台自动处理。
- en: 'The fact that the call stack doesn’t exist in source code is the main reason
    recursion is so confusing to beginners: recursion relies on something the programmer
    can’t even see! Revealing how stack data structures and the call stack work removes
    much of the mystery behind recursion. Functions and stacks are both simple concepts,
    and we can use them together to understand how recursion works.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 调用堆栈在源代码中不存在的事实是递归对初学者如此令人困惑的主要原因：递归依赖于程序员甚至看不到的东西！揭示堆栈数据结构和调用堆栈的工作原理消除了递归背后的许多神秘之处。函数和堆栈都是简单的概念，我们可以将它们结合起来理解递归是如何工作的。
- en: What Are Recursive Functions and Stack Overflows?
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归函数和堆栈溢出是什么？
- en: 'A *recursive function* is a function that calls itself. This *shortest.py*
    program is the shortest possible example of a recursive function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归函数*是调用自身的函数。这个*shortest.py*程序是递归函数的最短可能示例：'
- en: '**Python**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding program is equivalent to this *shortest.html* program:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序等同于这个*shortest.html*程序：
- en: '**JavaScript**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `shortest()` function does nothing but call the `shortest()` function.
    When this happens, it calls the `shortest()` function again, and that will call
    `shortest()`, and so on, seemingly forever. It is similar to the mythological
    idea that the crust of the Earth rests on the back of a giant space turtle, which
    rests on the back of another turtle. Beneath that turtle: another turtle. And
    so on, forever.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortest()`函数除了调用`shortest()`函数什么也不做。当这发生时，它再次调用`shortest()`函数，然后`shortest()`会调用`shortest()`，依此类推，看起来永远不会停止。这类似于地壳靠着一只巨大的空间乌龟的背部，而那只乌龟又靠着另一只乌龟。在那只乌龟下面：另一只乌龟。如此循环，永无止境。'
- en: But this “turtles all the way down” theory doesn’t do a good job of explaining
    cosmology, nor recursive functions. Since the call stack uses the computer’s finite
    memory, this program cannot continue forever, the way an infinite loop does. The
    only thing this program does is crash and display an error message.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个“无穷递归”的理论并不能很好地解释宇宙学，也不能很好地解释递归函数。由于调用堆栈使用了计算机的有限内存，这个程序不能永远继续下去，就像无限循环那样。这个程序唯一能做的就是崩溃并显示错误消息。
- en: 'The Python output of *shortest.py* looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*shortest.py*的Python输出看起来像这样：'
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The JavaScript output of *shortest.html* looks like this in the Google Chrome
    web browser (other browsers will have similar error messages):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*shortest.html*的JavaScript输出在Google Chrome网页浏览器中看起来像这样（其他浏览器会有类似的错误消息）：'
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This kind of bug is called a *stack overflow*. (This is where the popular website
    [https://stackoverflow.com](https://stackoverflow.com) got its name.) The constant
    function calls with no returns grow the call stack until all the computer’s memory
    allocated for the call stack is used up. To prevent this, the Python and JavaScript
    interpreters crash the program after a certain limit of function calls that don’t
    return a value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误被称为*堆栈溢出*。（这就是流行网站[https://stackoverflow.com](https://stackoverflow.com)得名的地方。）不断的函数调用而没有返回会使调用堆栈增长，直到计算机为调用堆栈分配的所有内存都被用完。为了防止这种情况，Python和JavaScript解释器在一定数量的不返回值的函数调用后会终止程序。
- en: This limit is called the *maximum recursion depth*or *maximum call stack size*.
    For Python, this is set to 1,000 function calls. For JavaScript, the maximum call
    stack size depends on the browser running the code but is generally at least 10,000
    or so. Think of a stack overflow as happening when the call stack gets “too high”
    (that is, consumes too much computer memory), as in [Figure 1-8](#figure1-8).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制被称为*最大递归深度*或*最大调用堆栈大小*。对于Python，这被设置为1,000个函数调用。对于JavaScript，最大调用堆栈大小取决于运行代码的浏览器，但通常至少为10,000左右。把堆栈溢出想象成当调用堆栈变得“太高”（也就是消耗了太多的计算机内存）时发生，就像[图1-8](#figure1-8)中的情况。
- en: '![Graphic depicting a stack of cards with “c() spam = ‘Coyote’” written on
    the top card. A warning reads, “Stack too high.”](image_fi/502024c01/f01008.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图形描绘了一叠卡片，顶部卡片上写着“c() spam = ''Coyote''”。一个警告写着，“堆栈太高。”](image_fi/502024c01/f01008.png)'
- en: 'Figure 1-8: A stack overflow happens when the call stack becomes too high,
    with too many frame objects taking up the computer’s memory.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-8：当调用堆栈变得太高时，堆栈溢出就会发生，有太多的帧对象占用了计算机的内存。
- en: Stack overflows don’t damage the computer. The computer just detects that the
    limit of function calls without returns has been reached and terminates the program.
    At worst, you’ll lose any unsaved work the program had. Stack overflows can be
    prevented by having something called a *base case*, which is explained next.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈溢出不会损坏计算机。计算机只是检测到函数调用的限制已经达到并终止程序。最坏的情况下，你会丢失程序中的任何未保存的工作。堆栈溢出可以通过有一个叫做*基本情况*的东西来防止，接下来会解释。
- en: Base Cases and Recursive Cases
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本情况和递归情况
- en: The stack overflow example has a `shortest()` function that calls `shortest()`
    but never returns. To avoid a crash, there needs to be a case, or set of circumstances,
    where the function stops calling itself and instead just returns. This is called
    a *base case*. By contrast, a case where the function recursively calls itself
    is called a *recursive case*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈溢出示例有一个`shortest()`函数调用`shortest()`但从不返回。为了避免崩溃，需要有一个情况，或一组情况，使得函数停止调用自身，而是直接返回。这被称为*基本情况*。相比之下，函数递归调用自身的情况被称为*递归情况*。
- en: All recursive functions require at least one base case and at least one recursive
    case. If there is no base case, the function never stops making recursive calls
    and eventually causes a stack overflow. If there is no recursive case, the function
    never calls itself and is an ordinary function, not a recursive one. When you
    start writing your own recursive functions, a good first step is to figure out
    what the base case and recursive case should be.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有递归函数都需要至少一个基本情况和至少一个递归情况。如果没有基本情况，函数永远不会停止进行递归调用，最终导致堆栈溢出。如果没有递归情况，函数永远不会调用自身，只是一个普通函数，而不是递归函数。当你开始编写自己的递归函数时，一个很好的第一步是找出基本情况和递归情况应该是什么。
- en: 'Take a look at this *shortestWithBaseCase.py* program, which defines the shortest
    recursive function that won’t crash from a stack overflow:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个*shortestWithBaseCase.py*程序，它定义了不会因堆栈溢出而崩溃的最短递归函数：
- en: '**Python**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code is equivalent to the following *shortestWithBaseCase.html* program:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码等同于以下*shortestWithBaseCase.html*程序：
- en: '**JavaScript**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When you run this code, the output looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，输出看起来像这样：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function doesn’t do anything useful except provide a short example of recursion
    (and it could be made shorter by removing the text output, but the text is useful
    for our explanation). When `shortestWithBaseCase(False)` is called ❸, the base
    case is executed and the function merely returns ❶. However, when `shortestWithBaseCase(True)`
    is called ❹, the recursive case is executed and `shortestWithBaseCase(False)`
    is called ❷.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数除了提供递归的简短示例外并没有做任何有用的事情（并且通过删除文本输出可以使其更短，但文本对我们的解释很有用）。当调用`shortestWithBaseCase(False)`时❸，基本情况被执行，函数仅返回❶。然而，当调用`shortestWithBaseCase(True)`时❹，递归情况被执行，并调用`shortestWithBaseCase(False)`❷。
- en: It’s important to note that when `shortestWithBaseCase(False)` is recursively
    called from ❷ and then returns, the execution doesn’t immediately move back to
    the original function call at ❹. The rest of the code in the recursive case after
    the recursive call still runs, which is why `Returning from recursive case.` appears
    in the output. Returning from the base case doesn’t immediately return from all
    the recursive calls that happened before it. This will be important to keep in
    mind in the `countDownAndUp()` example in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当从❷递归调用`shortestWithBaseCase(False)`并返回时，执行不会立即回到❹处的原始函数调用。递归调用后的递归情况中的其余代码仍然会运行，这就是为什么输出中会出现`Returning
    from recursive case.`。从基本情况返回并不会立即返回到之前发生的所有递归调用。这在下一节中的`countDownAndUp()`示例中将是重要的要记住的。
- en: Code Before and After the Recursive Call
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归调用前后的代码
- en: 'The code in a recursive case can be split into two parts: the code before the
    recursive call and the code after the recursive call. (If there are two recursive
    calls in the recursive case, such as with the Fibonacci sequence example in Chapter
    2, there will be a before, a between, and an after. But let’s keep it simple for
    now.)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 递归情况中的代码可以分为两部分：递归调用前的代码和递归调用后的代码。（如果在递归情况中有两个递归调用，比如第2章中的斐波那契数列示例，那么会有一个前、一个中和一个后。但现在让我们保持简单。）
- en: The important thing to know is that reaching the base case doesn’t necessarily
    mean reaching the end of the recursive algorithm. It only means the base case
    won’t continue to make recursive calls.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，达到基本情况并不一定意味着递归算法的结束。它只意味着基本情况不会继续进行递归调用。
- en: 'For example, consider this *countDownAndUp.py* program whose recursive function
    counts from any number down to zero, and then back up to the number:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个*countDownAndUp.py*程序，其递归函数从任何数字倒数到零，然后再次升到该数字：
- en: '**Python**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the equivalent *countDownAndUp.html* program:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是等效的*countDownAndUp.html*程序：
- en: '**JavaScript**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you run this code, the output looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，输出如下：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Remember that every time a function is called, a new frame is created and pushed
    onto the call stack. This frame is where all the local variables and parameters
    (such as `number`) are stored. So, there is a separate `number variable for each
    frame on the call stack. This is another often confusing point about recursion:
    even though, from the source code, it looks like there is only one `number` variable,
    remember that because it is a local variable, there is actually a different `number`
    variable for each function call.`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每次调用函数时，都会创建一个新帧并推送到调用堆栈上。这个帧是存储所有局部变量和参数（如`number`）的地方。因此，对于调用堆栈上的每个帧都有一个单独的`number`变量。这是关于递归经常令人困惑的另一个要点：尽管从源代码看，似乎只有一个`number`变量，但请记併，因为它是局部变量，实际上对于每个函数调用都有一个不同的`number`变量。
- en: '`When `countDownAndUp(3)` is called ❺, a frame is created, and that frame’s
    local `number` variable is set to `3`. The function prints the `number` variable
    to the screen ❶. As long as `number` isn’t `0`, `countDownAndUp()` is recursively
    called with `number - 1` ❸. When it calls `countDownAndUp(2)`, a new frame is
    pushed onto the stack, and that frame’s local `number` variable is set to `2`.
    Again, the recursive case is reached and calls `countDownAndUp(1)`, which again
    reaches the recursive case and calls `countDownAndUp(0)`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`countDownAndUp(3)`时❺，会创建一个帧，该帧的局部变量`number`设置为`3`。函数将`number`变量打印到屏幕上❶。只要`number`不是`0`，就会递归调用`countDownAndUp()`，参数为`number
    - 1`❸。当调用`countDownAndUp(2)`时，会推送一个新帧到堆栈上，并且该帧的局部变量`number`设置为`2`。同样，递归情况被触发，调用`countDownAndUp(1)`，再次触发递归情况并调用`countDownAndUp(0)`。
- en: This pattern of making consecutive recursive function calls and then returning
    from the recursive function calls is what causes the countdown of numbers to appear.
    Once `countDownAndUp(0)` is called, the base case is reached ❷, and no more recursive
    calls are made. However, this isn’t the end of our program! When the base case
    is reached, the local `number` variable is `0`. But when that base case returns,
    and the frame is popped off the call stack, the frame under it has its own local
    `number` variable, with the same `1` value it’s always had. As the execution returns
    back to the previous frames in the call stack, the code *after* the recursive
    call is executed ❹. This is what causes the count up of numbers to appear. [Figure
    1-9](#figure1-9) shows the state of the call stack as `countDownAndUp()` is recursively
    called and then returns.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 连续进行递归函数调用然后从递归函数调用返回的模式是导致数字倒数出现的原因。一旦调用`countDownAndUp(0)`，就会达到基本情况❷，不会再进行递归调用。然而，这并不是我们程序的结束！当达到基本情况时，局部变量`number`为`0`。但当基本情况返回并且帧从调用堆栈中弹出时，其下面的帧有自己的局部变量`number`，其值始终为`1`。当执行返回到调用堆栈中的前一个帧时，递归调用后的代码会被执行❹。这就是导致数字升序出现的原因。[图1-9](#figure1-9)显示了在递归调用`countDownAndUp()`并返回时调用堆栈的状态。
- en: '![Timeline depicting a call stack after each call to countDownAndUp(). It begins
    empty, then shows the number variable equal to 3, then equal to 2, then equal
    to 1, then equal to 0\. The number variable then begins increasing, first to 1,
    then to 2, then to 3, until the call stack is empty.](image_fi/502024c01/f01009.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴描述了每次调用countDownAndUp()后的调用堆栈。它开始为空，然后显示number变量等于3，然后等于2，然后等于1，然后等于0。然后number变量开始增加，先是1，然后是2，然后是3，直到调用堆栈为空。](image_fi/502024c01/f01009.png)'
- en: 'Figure 1-9: The call stack keeping track of the values in the `number` local
    variable for each function call'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-9：调用堆栈跟踪每个函数调用中“number”局部变量的值
- en: The fact that the code doesn’t stop immediately when the base case is reached
    will be important to keep in mind for the factorial calculation in the next chapter.
    Remember, any code after the recursive case will still have to run.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当基本情况达到时，代码不会立即停止，这一点对于下一章中的阶乘计算非常重要。请记住，递归情况之后的任何代码仍然必须运行。
- en: At this point, you might be thinking that the recursive `countDownAndUp()` function
    is overengineered and difficult to follow. Why not, instead, use an iterative
    solution to print numbers? An *iterative* approach, which uses loops to repeat
    a task until it’s done, is usually thought of as the opposite of recursion.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会认为递归的`countDownAndUp()`函数设计过于复杂，难以理解。为什么不使用迭代解决方案来打印数字呢？*迭代*方法通常被认为是递归的相反，它使用循环重复任务直到完成。
- en: Whenever you find yourself asking, “Wouldn’t using a loop be easier?” the answer
    is almost certainly “Yes,” and you should avoid the recursive solution. Recursion
    can be tricky for both beginner and experienced programmers, and recursive code
    isn’t automatically “better” or “more elegant” than iterative code. Readable,
    easy-to-understand code is more important than any supposed elegance that recursion
    provides. However, on some occasions an algorithm cleanly maps to a recursive
    approach. Algorithms that involve tree-like data structures and require backtracking
    are especially suited for recursion. These ideas are further explored in Chapters
    2 and 4.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您问自己，“使用循环会更容易吗？”答案几乎肯定是“是”，您应该避免使用递归解决方案。递归对于初学者和有经验的程序员都可能很棘手，递归代码并不自动比迭代代码“更好”或“更优雅”。可读性强、易于理解的代码比递归提供的任何所谓的优雅更重要。然而，在某些情况下，算法可以清晰地映射到递归方法。涉及树状数据结构并需要回溯的算法特别适合使用递归。这些想法在第2章和第4章中进一步探讨。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Recursion often confuses new programmers, but it is built on the simple idea
    that a function can call itself. Every time a function call is made, a new frame
    object with information related to the call (such as local variables and a return
    address for the execution to move to when the function returns) is added to the
    call stack. The call stack, being a stack data structure, can be altered only
    by having data added to or removed from its “top.” This is called *pushing to*
    and *popping from* the stack, respectively.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 递归经常会让新手程序员感到困惑，但它建立在一个简单的思想上，即函数可以调用自身。每次进行函数调用时，都会向调用堆栈添加一个新的帧对象，其中包含与调用相关的信息（例如局部变量和函数返回时执行移动到的返回地址）。调用堆栈作为一个堆栈数据结构，只能通过向其“顶部”添加或删除数据来改变。这分别称为*推入*和*弹出*堆栈。
- en: The call stack is handled by the program implicitly, so there is no call stack
    variable. Calling a function pushes a frame object to the call stack, and returning
    from a function pops a frame object from the call stack.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 程序隐式处理调用堆栈，因此没有调用堆栈变量。调用函数会将一个帧对象推入调用堆栈，从函数返回会从调用堆栈中弹出一个帧对象。
- en: Recursive functions have recursive cases, those in which a recursive call is
    made, and base cases, those where the function simply returns. If there is no
    base case or a bug prevents a base case from being run, the execution causes a
    stack overflow that crashes the program.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数有递归情况，即进行递归调用的情况，和基本情况，即函数简单返回的情况。如果没有基本情况或者错误阻止基本情况运行，执行将导致堆栈溢出，从而使程序崩溃。
- en: Recursion is a useful technique, but recursion doesn’t automatically make code
    “better” or more “elegant.” This idea is explored more in the next chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种有用的技术，但递归并不会自动使代码“更好”或更“优雅”。这个想法在下一章中会更详细地探讨。
- en: Further Reading
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find other introductions to recursion in my 2018 North Bay Python conference
    talk, “Recursion for Beginners: A Beginner’s Guide to Recursion,” at [https://youtu.be/AfBqVVKg4GE](https://youtu.be/AfBqVVKg4GE).
    The YouTube channel Computerphile also introduces recursion in its video “What
    on Earth is Recursion?” at [https://youtu.be/Mv9NEXX1VHc](https://youtu.be/Mv9NEXX1VHc).
    Finally, V. Anton Spraul talks about recursion in his book *Think Like a Programmer*
    (No Starch Press, 2012) and in his video “Recursion (Think Like a Programmer)”
    at [https://youtu.be/oKndim5-G94](https://youtu.be/oKndim5-G94). Wikipedia’s article
    on recursion goes into great detail at [https://en.wikipedia.org/wiki/Recursion](https://en.wikipedia.org/wiki/Recursion).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在2018年北湾Python大会上找到有关递归的其他介绍，标题为“递归入门：递归初学者指南”，网址为[https://youtu.be/AfBqVVKg4GE](https://youtu.be/AfBqVVKg4GE)。YouTube频道Computerphile还在其视频“地球上的递归是什么？”中介绍了递归，网址为[https://youtu.be/Mv9NEXX1VHc](https://youtu.be/Mv9NEXX1VHc)。最后，V.
    Anton Spraul在他的书*像程序员一样思考*（No Starch Press，2012）和他的视频“递归（像程序员一样思考）”中讨论了递归，网址为[https://youtu.be/oKndim5-G94](https://youtu.be/oKndim5-G94)。维基百科的递归文章在[https://en.wikipedia.org/wiki/Recursion](https://en.wikipedia.org/wiki/Recursion)中有详细介绍。
- en: You can install the `ShowCallStack` module for Python. This module adds a `showcallstack()`
    function that you can place anywhere in your code to see the state of the call
    stack at that particular point in your program. You can download the module and
    find instructions for it at [https://pypi.org/project/ShowCallStack](https://pypi.org/project/ShowCallStack).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为Python安装“ShowCallStack”模块。该模块添加了一个“showcallstack()”函数，您可以将其放在代码中的任何位置，以查看程序在特定点的调用堆栈状态。您可以在[https://pypi.org/project/ShowCallStack](https://pypi.org/project/ShowCallStack)下载该模块并找到相关说明。
- en: Practice Questions
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习题
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你的理解能力：
- en: In general, what is a recursive thing?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一般来说，什么是递归的东西？
- en: In programming, what is a recursive function?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编程中，什么是递归函数？
- en: What four features do functions have?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数有哪四个特征？
- en: What is a stack?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是堆栈？
- en: What are the terms for adding and removing values to and from the top of a stack?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向堆栈的顶部添加和移除值的术语是什么？
- en: Say you push the letter *J* to a stack, then push the letter *Q*, then pop the
    stack, then push the letter *K*, then pop the stack again. What does the stack
    look like?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你将字母*J*推送到堆栈，然后推送字母*Q*，然后弹出堆栈，然后推送字母*K*，然后再次弹出堆栈。堆栈是什么样子？
- en: What is pushed and popped onto the call stack?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被推送和弹出到调用堆栈上的是什么？
- en: What causes a stack overflow to happen?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是什么导致堆栈溢出？
- en: What is a base case?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？
- en: What is a recursive case?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是递归情况？
- en: How many base cases and recursive cases do recursive functions have?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数有多少个基本情况和递归情况？
- en: What happens if a recursive function has zero base cases?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个递归函数没有基本情况会发生什么？
- en: What happens if a recursive function has zero recursive cases?`  `# 2
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个递归函数没有递归情况会发生什么？`  `# 2
- en: Recursion vs. Iteration
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 递归与迭代
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Neither recursion nor iteration is a superior technique in general. In fact,
    any recursive code can be written as iterative code with a loop and a stack. Recursion
    doesn’t have some special power enabling it to perform calculations that an iterative
    algorithm cannot. And any iterative loop can be rewritten as a recursive function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 递归和迭代都没有一般上是更好的技术。事实上，任何递归代码都可以用循环和堆栈编写成迭代代码。递归并没有某种特殊的能力使其能够执行迭代算法无法执行的计算。任何迭代循环都可以重写为递归函数。
- en: This chapter compares and contrasts recursion and iteration. We’ll look at the
    classic Fibonacci and factorial functions and see why their recursive algorithms
    have critical weaknesses. We’ll also explore the insights a recursive approach
    can yield by considering an exponent algorithm. Altogether this chapter shines
    light on the supposed elegance of recursive algorithms and shows when a recursive
    solution is useful and when it is not.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本章比较和对比了递归和迭代。我们将研究经典的斐波那契和阶乘函数，并看看它们的递归算法为什么有关键的弱点。我们还将通过考虑指数算法来探索递归方法可以产生的见解。总的来说，本章揭示了递归算法的所谓优雅之处，并展示了递归解决方案何时有用以及何时不适用。
- en: Calculating Factorials
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算阶乘
- en: Many computer science courses use factorial calculation as a classic example
    of a recursive function. The factorial of an integer (let’s call it *n*) is the
    product of all integers from 1 to *n*. For example, the factorial of 4 is 4 ×
    3 × 2 × 1, or 24\. An exclamation mark is the math notation for factorials, as
    in 4!, which means *the factorial of 4*. [Table 2-1](#table2-1) shows the first
    few factorials.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机科学课程使用阶乘计算作为递归函数的经典示例。一个整数（我们称之为*n*）的阶乘是从1到*n*的所有整数的乘积。例如，4的阶乘是4 × 3 ×
    2 × 1，即24。感叹号是阶乘的数学表示法，如4!，表示*4的阶乘*。[表2-1](#table2-1)显示了前几个阶乘。
- en: 'Table 2-1: Factorials of the First Few Integers'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1：前几个整数的阶乘
- en: '| ***n*!** |  | **Expanded form** |  | **Product** |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| ***n*!** |  | **展开形式** |  | **乘积** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1! | = | 1 | = | 1 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 1! | = | 1 | = | 1 |'
- en: '| 2! | = | 1 × 2 | = | 2 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 2! | = | 1 × 2 | = | 2 |'
- en: '| 3! | = | 1 × 2 × 3 | = | 6 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 3! | = | 1 × 2 × 3 | = | 6 |'
- en: '| 4! | = | 1 × 2 × 3 × 4 | = | 24 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 4! | = | 1 × 2 × 3 × 4 | = | 24 |'
- en: '| 5! | = | 1 × 2 × 3 × 4 × 5 | = | 120 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 5! | = | 1 × 2 × 3 × 4 × 5 | = | 120 |'
- en: '| 6! | = | 1 × 2 × 3 × 4 × 5 × 6 | = | 720 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 6! | = | 1 × 2 × 3 × 4 × 5 × 6 | = | 720 |'
- en: '| 7! | = | 1 × 2 × 3 × 4 × 5 × 6 × 7 | = | 5,040 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 7! | = | 1 × 2 × 3 × 4 × 5 × 6 × 7 | = | 5,040 |'
- en: '| 8! | = | 1 × 2 × 3 × 4 × 5 × 6 × 7 × 8 | = | 40,320 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 8! | = | 1 × 2 × 3 × 4 × 5 × 6 × 7 × 8 | = | 40,320 |'
- en: Factorials are used in all sorts of calculations—for example, finding the number
    of permutations for something. If you want to know the number of ways that exist
    to order four people—Alice, Bob, Carol, and David—in a line, the answer is the
    factorial of 4\. Four possible people can be first in line (4); then for each
    of those four options, three remaining people can be second in line (4 × 3); then
    two people can be third in line (4 × 3 × 2); and the last person left will be
    fourth in line (4 × 3 × 2 × 1). The number of ways people can be ordered in line—that
    is, the number of permutations—is the factorial of the number of people.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘在各种计算中都有用途——例如，找到某物排列的排列数。如果你想知道有多少种方式可以将四个人——Alice、Bob、Carol和David——排成一行，答案就是4的阶乘。四个可能的人可以先站在队伍中（4）；然后对于这四个选项中的每一个，还有三个人可以站在第二位（4
    × 3）；然后两个人可以站在第三位（4 × 3 × 2）；最后一个人站在第四位（4 × 3 × 2 × 1）。人们可以排成队伍的方式数量——也就是排列的数量——就是人数的阶乘。
- en: Now let’s examine both an iterative and a recursive approach to calculating
    factorials.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看计算阶乘的迭代和递归方法。
- en: The Iterative Factorial Algorithm
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代阶乘算法
- en: 'Calculating factorials iteratively is fairly straightforward: multiply the
    integers 1 up to and including *n* in a loop. *Iterative* algorithms always use
    a loop. A *factorialByIteration.py* program looks like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 用迭代方法计算阶乘相当直接：在循环中将整数1到*n*相乘。*迭代*算法总是使用循环。*factorialByIteration.py*程序看起来像这样：
- en: '**Python**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And a *factorialByIteration.html* program looks like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 而*factorialByIteration.html*程序看起来像这样：
- en: '**JavaScript**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you run this code, the output displays the calculation for 5! like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，输出会显示5!的计算结果如下：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There’s nothing wrong with the iterative solution for calculating factorials;
    it’s straightforward and gets the job done. But let’s also take a look at the
    recursive algorithm for insights into the nature of factorials and recursion itself.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 用迭代方法计算阶乘没有问题；它很直接并且完成了任务。但是让我们也看看递归算法，以便更好地理解阶乘和递归本身的性质。
- en: The Recursive Factorial Algorithm
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归阶乘算法
- en: Notice that the factorial of 4 is 4 × 3 × 2 × 1, and the factorial of 5 is 5
    × 4 × 3 × 2 × 1\. So you could say that 5! = 5 × 4!. This is *recursive* because
    the definition of the factorial of 5 (or any number *n*) includes the definition
    of the factorial of 4 (the number *n* – 1). In turn, 4! = 4 × 3!, and so on, until
    you must calculate 1!, the base case, which is simply 1.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意4的阶乘是4 × 3 × 2 × 1，5的阶乘是5 × 4 × 3 × 2 × 1。所以你可以说5! = 5 × 4!。这是*递归*，因为5的阶乘（或任何数字*n*）的定义包括4的阶乘（数字*n*
    - 1）的定义。依此类推，4! = 4 × 3!，以此类推，直到必须计算1!，即基本情况，它只是1。
- en: 'The *factorialByRecursion.py* Python program uses a recursive factorial algorithm:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 递归阶乘算法的Python程序*factorialByRecursion.py*使用了递归阶乘算法：
- en: '**Python**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And the *factorialByRecursion.html* JavaScript program with equivalent code
    looks like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 而*factorialByRecursion.html*的JavaScript程序与等效代码看起来是这样的：
- en: '**JavaScript**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you run this code to calculate 5! recursively, the output matches the
    iterative program’s output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码递归计算5!时，输出与迭代程序的输出相匹配：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To many programmers, this recursive code looks strange. You know that `factorial(5)`
    must compute 5 × 4 × 3 × 2 × 1, but it’s hard to point to the line of code where
    this multiplication is taking place.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对许多程序员来说，这个递归代码看起来很奇怪。你知道`factorial(5)`必须计算5 × 4 × 3 × 2 × 1，但很难指出这个乘法发生在哪一行代码上。
- en: The confusion arises because the recursive case has one line ❶, half of which
    is executed before the recursive call and half of which takes place after the
    recursive call returns. We aren’t used to the idea of only half of a line of code
    executing at a time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆是因为递归情况有一行 ❶，其中一半在递归调用之前执行，另一半在递归调用返回后执行。我们不习惯一行代码只有一半在执行。
- en: The first half is `factorial(number - 1)`. This involves calculating `number
    - 1` and making a recursive function, causing a new frame object to be pushed
    to the call stack. This happens before the recursive call is made.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是`factorial(number - 1)`。这涉及计算`number - 1`并创建一个递归函数，导致调用栈中推送一个新的帧对象。这发生在递归调用之前。
- en: The next time the code runs with the old frame object is after `factorial(number
    - 1)` has returned. When `factorial(5)` is called, `factorial(number - 1)` will
    be `factorial(4)`, which returns `24`. This is when the second half of the line
    runs. The `return number * factorial(number - 1)` now looks like `return` `5 *
    24`, which is why `factorial(5)` returns `120`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 代码再次运行时，旧的帧对象是在`factorial(number - 1)`返回后。当调用`factorial(5)`时，`factorial(number
    - 1)`将是`factorial(4)`，返回值是`24`。这时第二部分代码运行。`return number * factorial(number -
    1)`现在看起来像`return` `5 * 24`，这就是为什么`factorial(5)`返回`120`。
- en: '[Figure 2-1](#figure2-1) tracks the state of the call stack as frame objects
    are pushed (which happens as recursive function calls are made) and frame objects
    are popped (as recursive function calls return). Notice that the multiplication
    happens after the recursive calls are made, not before.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-1](#figure2-1)跟踪了调用栈的状态，帧对象被推送（当递归函数调用时发生）和帧对象被弹出（当递归函数调用返回时）。注意乘法发生在递归调用之后，而不是之前。'
- en: When the original function call to `factorial()` returns, it returns the calculated
    factorial.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当原始函数调用`factorial()`返回时，它返回了计算出的阶乘。
- en: Why the Recursive Factorial Algorithm Is Terrible
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么递归阶乘算法很糟糕
- en: The recursive implementation for calculating factorials has a critical weakness.
    Calculating the factorial of 5 requires five recursive function calls. This means
    five frame objects are placed on the call stack before the base case is reached.
    This doesn’t scale.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算阶乘的递归实现有一个关键的弱点。计算5的阶乘需要五次递归函数调用。这意味着在基本情况到达之前，调用栈上会有五个帧对象。这不可扩展。
- en: If you want to calculate the factorial of 1,001, the recursive `factorial()`
    function must make 1,001 recursive function calls. However, your program is likely
    to cause a stack overflow before it can finish, because making so many function
    calls without returning would exceed the maximum call stack size of the interpreter.
    This is terrible; you would never want to use a recursive factorial function in
    real-world code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想计算1001的阶乘，递归的`factorial()`函数必须进行1001次递归函数调用。然而，你的程序很可能在完成之前引起堆栈溢出，因为进行如此多的函数调用而不返回会超过解释器的最大调用栈大小。这很糟糕；你绝对不会想在真实世界的代码中使用递归阶乘函数。
- en: '![Timeline of the call stack after each call to the factorial function. We
    begin with the number variable equal to 5 and a return value of 5 times the result
    of the factorial function when called with the argument 4\. Next, number equals
    4, and the return value is 4 times the result of the factorial function when called
    with the argument 3\. Then, number equals 3, and the return value is 3 times the
    return value of the factorial function when called with the argument 2\. Next,
    number equals 2, and the return value is 2 times the return value of the factorial
    function when called with the argument 1\. After that, number equals 1, and the
    return value is 1\. Then, number equals 2, and the return value is 2 times 1\.
    Next, number equals 3, and the return value is 3 times 2\. Then, number equals
    4, and the return value is 4 times 6\. Next, number equals 5, and the return value
    is 5 times 24\. Finally, the call stack is empty.](image_fi/502024c02/f02001.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![调用阶乘函数后每次调用后调用栈的时间线。我们从number变量等于5和阶乘函数在参数4时的返回值5倍阶乘函数结果开始。接下来，number等于4，返回值是4倍阶乘函数在参数3时的返回值。然后，number等于3，返回值是3倍阶乘函数在参数2时的返回值。接下来，number等于2，返回值是2倍阶乘函数在参数1时的返回值。之后，number等于1，返回值是1。然后，number等于2，返回值是2乘1。接下来，number等于3，返回值是3乘2。然后，number等于4，返回值是4乘6。接下来，number等于5，返回值是5乘24。最后，调用栈为空。](image_fi/502024c02/f02001.png)'
- en: 'Figure 2-1: The state of the call stack as the recursive calls to `factorial()`
    are called and then return'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-1：调用栈的状态，递归调用`factorial()`后的返回
- en: The iterative factorial algorithm, on the other hand, will complete the calculation
    quickly and efficiently. The stack overflow can be avoided using a technique available
    in some programming languages called *tail call optimization*. Chapter 8 covers
    this topic. However, this technique further complicates the implementation of
    the recursive function. For calculating factorials, the iterative approach is
    the simplest and most direct.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，迭代阶乘算法将快速高效地完成计算。可以使用一些编程语言中的一种称为*尾递归优化*的技术来避免堆栈溢出。第8章涵盖了这个主题。然而，这种技术进一步复杂化了递归函数的实现。对于计算阶乘，迭代方法是最简单和最直接的。
- en: Calculating the Fibonacci Sequence
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算斐波那契序列
- en: The *Fibonacci sequence* is another classic example for introducing recursion.
    Mathematically, the Fibonacci sequence of integers begins with the numbers 1 and
    1 (or sometimes, 0 and 1). The next number in the sequence is the sum of the previous
    two numbers. This creates the sequence 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,
    and so on, forever.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*斐波那契序列*是介绍递归的另一个经典例子。数学上，整数的斐波那契序列以数字1和1（有时是0和1）开始。序列中的下一个数字是前两个数字的和。这创建了序列1,
    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144等，永远不会结束。'
- en: If we call the latest two numbers in the sequence *a* and *b*, you can see in
    [Figure 2-2](#figure2-2) how the sequence grows.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将序列中的最新两个数字称为*a*和*b*，您可以在[图2-2](#figure2-2)中看到序列是如何增长的。
- en: '![Diagram showing the values of two variables, a and b, and their sum as the
    Fibonacci sequence progresses. We begin with a and b both equal to 1 and their
    sum equal to 2\. Next, a is equal to 1, b is equal to 2, and their sum is equal
    to 3\. Then a is equal to 2, b is equal to 3, and their sum is equal to 5\. Each
    progression of the Fibonacci sequence occurs on a new line, and each new line
    is one number longer than the previous line, forming a pyramid-like shape.](image_fi/502024c02/f02002.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![显示两个变量a和b的值以及它们的和随着斐波那契序列的进展而变化的图表。我们从a和b都等于1以及它们的和等于2开始。接下来，a等于1，b等于2，它们的和等于3。然后a等于2，b等于3，它们的和等于5。斐波那契序列的每次进展都发生在新的一行上，每一行都比上一行多一个数字，形成了金字塔形状。](image_fi/502024c02/f02002.png)'
- en: 'Figure 2-2: Each number of the Fibonacci sequence is the sum of the previous
    two numbers.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-2：斐波那契序列的每个数字都是前两个数字的和。
- en: Let’s explore some code examples of both the iterative and recursive solutions
    for generating Fibonacci numbers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些迭代和递归解决方案的代码示例，用于生成斐波那契数。
- en: The Iterative Fibonacci Algorithm
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代斐波那契算法
- en: 'The iterative Fibonacci example is straightforward, consisting of a simple
    `for` loop and two variables, `a` and `b`. This *fibonacciByIteration.py* Python
    program implements the iterative Fibonacci algorithm:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代斐波那契示例很简单，由一个简单的`for`循环和两个变量`a`和`b`组成。这个*fibonacciByIteration.py* Python程序实现了迭代斐波那契算法：
- en: '**Python**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This *fibonacciByIteration.html* program has the equivalent JavaScript code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*fibonacciByIteration.html*程序包含了等效的JavaScript代码：
- en: '**JavaScript**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you run this code to calculate the 10th Fibonacci number, the output looks
    like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码来计算第10个斐波那契数时，输出如下：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The program needs to track only the latest two numbers of the sequence at a
    time. Since the first two numbers in the Fibonacci sequence are defined as 1,
    we store `1` in variables `a` and `b` ❶. Inside the `for` loop, the next number
    in the sequence is calculated by adding `a` and `b` ❷, which becomes the next
    value of `b`, while `a` obtains the previous value of `b`. By the time the loop
    is finished, `b` contains the *n*th Fibonacci number, so it is returned.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 程序只需要一次跟踪序列中的最新两个数字。由于斐波那契序列中的前两个数字被定义为1，我们将`1`存储在变量`a`和`b`中❶。在`for`循环内，通过将`a`和`b`相加来计算序列中的下一个数字❷，这成为`b`的下一个值，而`a`获得`b`的前一个值。当循环结束时，`b`包含第*n*个斐波那契数，因此返回它。
- en: The Recursive Fibonacci Algorithm
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归斐波那契算法
- en: 'Calculating Fibonacci numbers involves a recursive property. For example, if
    you want to calculate the 10th Fibonacci number, you add the ninth and eighth
    Fibonacci numbers together. To calculate those Fibonacci numbers, you add the
    eighth and seventh, then the seventh and sixth Fibonacci numbers. A lot of repeat
    calculations occur: notice that adding the ninth and eighth Fibonacci numbers
    involves calculating the eighth Fibonacci number again. You continue this recursion
    until you reach the base case of the first or second Fibonacci number, which is
    always 1.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 计算斐波那契数涉及递归属性。例如，如果要计算第10个斐波那契数，您将第九个和第八个斐波那契数相加。要计算这些斐波那契数，您将第八个和第七个，然后第七个和第六个斐波那契数相加。会发生大量重复计算：注意到将第九个和第八个斐波那契数相加涉及再次计算第八个斐波那契数。您继续递归，直到达到第一个或第二个斐波那契数的基本情况，它们始终为1。
- en: 'The recursive Fibonacci function is in this *fibonacciByRecursion.py* Python
    program:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 递归斐波那契函数在这个*fibonacciByRecursion.py* Python程序中：
- en: '[PRE28]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This *fibonacciByRecursion.html* file has the equivalent JavaScript program:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*fibonacciByRecursion.html*文件包含了等效的JavaScript程序：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When you run this code to calculate the 10th Fibonacci number, the output looks
    like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码来计算第10个斐波那契数时，输出如下：
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Much of the code is for displaying this output, but the `fibonacci()` function
    itself is simple. The base case—the circumstances where recursive calls are no
    longer made—occurs when `nthNumber` is `1` or `2` ❶. In this case, the function
    returns `1` since the first and second Fibonacci numbers are always 1\. Any other
    case is a recursive case, so the value that is returned is the sum of `fibonacci(nthNumber
    - 1)` and `fibonacci(nthNumber - 2)`. As long as the original `nthNumber` argument
    is an integer greater than `0`, these recursive calls will eventually reach the
    base case and stop making more recursive calls.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码用于显示这个输出，但`fibonacci()`函数本身很简单。基本情况——不再进行递归调用的情况——发生在`nthNumber`为`1`或`2`时❶。在这种情况下，函数返回`1`，因为第一个和第二个斐波那契数始终为1。任何其他情况都是递归情况，因此返回的值是`fibonacci(nthNumber
    - 1)`和`fibonacci(nthNumber - 2)`的和。只要原始的`nthNumber`参数是大于`0`的整数，这些递归调用最终会达到基本情况并停止进行更多的递归调用。
- en: 'Remember how the recursive factorial example had a “before the recursive call”
    and “after the recursive call” part? Because the recursive Fibonacci algorithm
    makes two recursive calls in its recursive case, you should keep in mind that
    it has three parts: “before the first recursive call,” “after the first recursive
    call but before the second recursive call,” and “after the second recursive call.”
    But the same principles apply. And don’t think that because a base case is reached,
    no more code remains to run after either recursive call. The recursive algorithm
    is finished only after the original function call has returned.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得递归阶乘示例中的“递归调用之前”和“递归调用之后”部分吗？因为递归斐波那契算法在其递归情况中进行了两次递归调用，所以你应该记住它有三个部分：“第一个递归调用之前”，“第一个递归调用之后但第二个递归调用之前”，以及“第二个递归调用之后”。但相同的原则适用。不要认为因为达到了基本情况，递归调用之后就不再需要运行任何代码。只有在原始函数调用返回后，递归算法才算完成。
- en: You might ask, “Isn’t the iterative Fibonacci solution simpler than the recursive
    Fibonacci solution?” The answer is “Yes.” Even worse, the recursive solution has
    a critical inefficiency that is explained in the next section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：“迭代斐波那契解决方案是否比递归斐波那契解决方案更简单？”答案是“是的”。更糟糕的是，递归解决方案存在一个关键的低效性，下一节将对此进行解释。
- en: Why the Recursive Fibonacci Algorithm Is Terrible
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么递归斐波那契算法很糟糕
- en: 'Like the recursive factorial algorithm, the recursive Fibonacci algorithm also
    suffers from a critical weakness: it repeats the same calculations over and over.
    [Figure 2-3](#figure2-3) shows how calling `fibonacci(6)`, marked in the tree
    diagram as `fib(6)` for brevity, calls `fibonacci(5)` and `fibonacci(4)`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与递归阶乘算法一样，递归斐波那契算法也存在一个关键的弱点：它一遍又一遍地重复相同的计算。[图2-3](#figure2-3)显示了调用`fibonacci(6)`（在树形图中标记为`fib(6)`以简洁表示）时调用了`fibonacci(5)`和`fibonacci(4)`。
- en: '![Tree diagram beginning with the Fibonacci function called with an argument
    of 6\. Two subsequent branches show the next calls to the Fibonacci function,
    with arguments of 5 and 4, respectively. The tree continues to branch until each
    branch ends with a value of 1\. Several of the branches are grayed out, indicating
    that the Fibonacci function was called with the same argument as a previous branch.](image_fi/502024c02/f02003.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![以参数6调用斐波那契函数开始的树形图。两个后续分支显示了对斐波那契函数的下一次调用，参数分别为5和4。树继续分支，直到每个分支以值1结束。其中一些分支被标记为灰色，表示斐波那契函数以与先前分支相同的参数调用。](image_fi/502024c02/f02003.png)'
- en: 'Figure 2-3: A tree diagram of the recursive function calls made starting with
    `fibonacci(6)`. The redundant function calls are in gray.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-3：从`fibonacci(6)`开始进行的递归函数调用的树形图。冗余的函数调用以灰色显示。
- en: This causes a cascade of other function calls until they reach the base cases
    of `fibonacci(2)` and `fibonacci(1)`, which return `1`. But notice that `fibonacci(4)`
    is called twice, and `fibonacci(3)` is called three times, and so on. This slows
    the overall algorithm with unnecessarily repeated calculations. This inefficiency
    gets worse as the Fibonacci number you want to calculate gets larger. While the
    iterative Fibonacci algorithm can complete `fibonacci(100)` in less than a second,
    the recursive algorithm would take over a million years to complete.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这会引起其他函数调用的级联，直到它们达到`fibonacci(2)`和`fibonacci(1)`的基本情况，返回`1`。但请注意，`fibonacci(4)`被调用了两次，`fibonacci(3)`被调用了三次，依此类推。这会使整体算法变慢，因为存在不必要的重复计算。随着要计算的斐波那契数变得更大，这种低效性会变得更糟。虽然迭代斐波那契算法可以在不到一秒的时间内完成`fibonacci(100)`，但递归算法需要超过一百万年才能完成。
- en: Converting a Recursive Algorithm into an Iterative Algorithm
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将递归算法转换为迭代算法
- en: Converting a recursive algorithm into an iterative algorithm is always possible.
    While recursive functions repeat a calculation by calling themselves, this repetition
    can be performed instead by a loop. Recursive functions also make use of the call
    stack; however, an iterative algorithm can replace this with a stack data structure.
    Thus, any recursive algorithm can be performed iteratively by using a loop and
    a stack.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将递归算法转换为迭代算法总是可能的。虽然递归函数通过调用自身重复计算，但这种重复可以通过循环来执行。递归函数还利用调用堆栈；然而，迭代算法可以用堆栈数据结构来替代。因此，任何递归算法都可以通过使用循环和堆栈来进行迭代执行。
- en: 'To demonstrate this, here is *factorialEmulateRecursion.py*, a Python program
    that implements an iterative algorithm to emulate a recursive algorithm:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，这里有一个名为*factorialEmulateRecursion.py*的Python程序，它实现了一个迭代算法来模拟递归算法：
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The *factorialEmulateRecursion.html* program holds the equivalent JavaScript:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*factorialEmulateRecursion.html*程序包含了等效的JavaScript代码：'
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that this program doesn’t have a recursive function; it doesn’t have
    any functions at all! The program emulates recursive function calls by using a
    list as a stack data structure (stored in the `callStack` variable ❶) to mimic
    the call stack. A dictionary storing the return address information and `nthNumber`
    local variable emulates a frame object ❷. The program emulates function calls
    by pushing these frame objects onto the call stack ❹, and it emulates returning
    from a function call by popping frame objects off the call stack 35.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个程序没有递归函数；它根本没有任何函数！该程序通过使用列表作为堆栈数据结构（存储在`callStack`变量中❶）来模拟调用堆栈，从而模拟递归函数调用。存储返回地址信息和`nthNumber`本地变量的字典模拟了帧对象❷。该程序通过将这些帧对象推送到调用堆栈❹来模拟函数调用，并通过从调用堆栈中弹出帧对象35来模拟从函数调用返回。
- en: Any recursive function can be written iteratively this way. Although this code
    is incredibly difficult to understand and you’d never write a real-world factorial
    algorithm this way, it does demonstrate that recursion has no innate capability
    that iterative code does not have.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 任何递归函数都可以以这种方式被写成迭代的。虽然这段代码非常难以理解，你永远不会以这种方式编写一个真实的阶乘算法，但它确实证明了递归没有任何迭代代码没有的固有能力。
- en: Converting an Iterative Algorithm into a Recursive Algorithm
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将迭代算法转换为递归算法
- en: Likewise, converting an iterative algorithm into a recursive algorithm is always
    possible. An iterative algorithm is simply code that uses a loop. The code that
    is repeatedly executed (the loop’s body) can be placed in a recursive function’s
    body. And just as the code in the loop’s body is executed repeatedly, we need
    to repeatedly call the function to execute its code. We can do this by calling
    the function from the function itself, creating a recursive function.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，将迭代算法转换为递归算法总是可能的。迭代算法只是使用循环的代码。重复执行的代码（循环的主体）可以放在递归函数的主体中。就像循环主体中的代码被重复执行一样，我们需要重复调用函数来执行它的代码。我们可以通过从函数本身调用函数来做到这一点，创建一个递归函数。
- en: 'The Python code in *hello.py* demonstrates printing `Hello, world!` five times
    by using a loop and then also using a recursive function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello.py*中的Python代码演示了通过使用循环打印`Hello, world!`五次，然后还使用递归函数：'
- en: '**Python**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The equivalent JavaScript code is in *hello.html*:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 等价的JavaScript代码在*hello.html*中：
- en: '**JavaScript**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of these programs looks like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `while` loop has a condition, `i < 5`, that determines whether the program
    keeps looping. Similarly, the recursive function uses this condition for its recursive
    case, which causes the function to call itself and execute the `Hello, world!`
    to display its code again.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环有一个条件，`i < 5`，用于确定程序是否继续循环。同样，递归函数使用这个条件作为它的递归情况，这会导致函数调用自身并执行`Hello,
    world!`来再次显示它的代码。'
- en: For a more real-world example, the following are iterative and recursive functions
    that return the index of a substring, `needle`, in a string, `haystack. The functions
    return `-1` if the substring isn’t found. This is similar to Python’s `find()`
    string method and JavaScript’s `indexOf()` string method. This *findSubstring.py*
    program has a Python version:`
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更真实的例子，以下是迭代和递归函数，它们返回字符串`haystack`中子字符串`needle`的索引。如果没有找到子字符串，这些函数返回`-1`。这类似于Python的`find()`字符串方法和JavaScript的`indexOf()`字符串方法。这个*findSubstring.py*程序有一个Python版本：`
- en: '`**Python**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`**Python**'
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This *findSubstring.html* program has the equivalent JavaScript version:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*findSubstring.html*程序有等价的JavaScript版本：
- en: '**JavaScript**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'These programs make a call to `findSubstringIterative()` and `findSubstringRecursive()`,
    which return `3` because that is the index where `cat` is found in `My cat Zophie`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序调用`findSubstringIterative()`和`findSubstringRecursive()`，它们返回`3`，因为这是在`My
    cat Zophie`中找到`cat`的索引：
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The programs in this section demonstrate that it is always possible to turn
    any loop into an equivalent recursive function. While replacing a loop with recursion
    is possible, I advise against it. This is doing recursion for recursion’s sake,
    and since recursion is often harder to understand than iterative code, code readability
    deteriorates.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的程序表明，将任何循环转换为等价的递归函数总是可能的。虽然用递归替换循环是可能的，但我建议不要这样做。这是为了递归而递归，而且由于递归通常比迭代代码更难理解，代码的可读性会下降。
- en: 'Case Study: Calculating Exponents'
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：计算指数
- en: Although recursion doesn’t necessarily produce better code, taking a recursive
    approach can give you new insights into your programming problem. As a case study,
    let’s examine how to calculate exponents.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管递归不一定会产生更好的代码，但采用递归方法可以让你对编程问题有新的见解。作为一个案例研究，让我们来看看如何计算指数。
- en: '*Exponents* are calculated by multiplying a number by itself. For example,
    the exponent “three raised to the sixth power,” or 3⁶, is equal to multiplying
    3 by itself six times: 3 × 3 × 3 × 3 × 3 × 3 = 729\. This is such a common operation
    that Python has the `**` operator and JavaScript has the built-in `Math.pow()`
    function to perform exponentiation. We can calculate 3⁶ with the Python code `3
    ** 6` and with the JavaScript code `Math.pow(3, 6)`.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*指数*是通过将一个数字乘以自身来计算的。例如，指数“三的六次方”，或3⁶，等于将3乘以自身六次：3 × 3 × 3 × 3 × 3 × 3 = 729。这是一个如此常见的操作，以至于Python有`**`运算符，JavaScript有内置的`Math.pow()`函数来执行指数运算。我们可以用Python代码`3
    ** 6`和JavaScript代码`Math.pow(3, 6)`来计算3⁶。'
- en: 'But let’s write our own exponent-calculating code. The solution is straightforward:
    create a loop that repeatedly multiplies a number by itself and returns the final
    product. Here is an iterative *exponentByIteration.py* Python program:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们编写我们自己的指数计算代码。解决方案很简单：创建一个循环，重复地将一个数字乘以自身，并返回最终的乘积。下面是一个迭代的*exponentByIteration.py*
    Python程序：
- en: '**Python**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And here is an equivalent JavaScript *exponentByIteration.html* program:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个等价的JavaScript*exponentByIteration.html*程序：
- en: '**JavaScript**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you run these programs, the output looks like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这些程序时，输出如下：
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is a straightforward calculation that we can easily write with a loop.
    The downside to using a loop is that the function slows as the exponents get larger:
    calculating 3^(12) takes twice as long as 3⁶, and 3^(600) takes one hundred times
    as long as 3⁶. In the next section, we address this by thinking recursively.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个直接的计算，我们可以很容易地用循环来编写。使用循环的缺点是，随着指数变大，函数的速度变慢：计算3^(12)需要的时间是3⁶的两倍，而3^(600)需要的时间是3⁶的一百倍。在下一节中，我们将通过递归来解决这个问题。
- en: Creating a Recursive Exponents Function
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个递归指数函数
- en: 'Let’s think of what a recursive solution for the exponentiation of, say, 3⁶
    would be. Because of the associative property of multiplication, 3 × 3 × 3 × 3
    × 3 × 3 is the same as (3 × 3 × 3) × (3 × 3 × 3), which is the same as (3 × 3
    × 3)². And since (3 × 3 × 3) is the same as 3³, we can determine that 3⁶ is the
    same as (3³)². This is an example of what mathematics calls the *power rule*:
    (*a*^(*m*))^(*n*) = *a*^(*mn*). Mathematics also gives us the *product rule*:
    *a*^(*n*) × *a*^(*m*) = *a*^(*n*) ^(+ m), including *a*^(*n*) × *a* = *a*^(*n*)
    ^(+ 1).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想一想，比如说，3⁶的指数的递归解决方案会是什么样的。由于乘法的结合性质，3 × 3 × 3 × 3 × 3 × 3与(3 × 3 × 3) ×
    (3 × 3 × 3)是相同的，这与(3 × 3 × 3)²是相同的。由于(3 × 3 × 3)与3³是相同的，我们可以确定3⁶与(3³)²是相同的。这是数学所称的*幂规则*的一个例子：(*a*^(*m*))^(*n*)
    = *a*^(*mn*)。数学还给了我们*乘法规则*：*a*^(*n*) × *a*^(*m*) = *a*^(*n*) ^(+ m)，包括*a*^(*n*)
    × *a* = *a*^(*n*) ^(+ 1)。
- en: 'We can use these mathematical rules to make an `exponentByRecursion()` function.
    If `exponentByRecursion(3, 6)` is called, it’s the same as `exponentByRecursion(3,
    3) * exponentByRecursion(3, 3)`. Of course, we don’t actually have to make both
    `exponentByRecursion(3, 3)` calls: we could just save the return value to a variable
    and multiply it by itself.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些数学规则来制作一个`exponentByRecursion()`函数。如果调用`exponentByRecursion(3, 6)`，它与`exponentByRecursion(3,
    3) * exponentByRecursion(3, 3)`是相同的。当然，我们实际上不必进行两次`exponentByRecursion(3, 3)`调用：我们可以将返回值保存到一个变量中，然后将其乘以自身。
- en: That works for even-numbered exponents, but what about for odd-numbered exponents?
    If we had to calculate 3⁷, or 3 × 3 × 3 × 3 × 3 × 3 × 3, this is the same as (3
    × 3 × 3 × 3 × 3 × 3) × 3, or (3⁶) × 3\. Then we can make the same recursive call
    to calculate 3⁶.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于偶数次幂有效，但对于奇数次幂呢？如果我们必须计算3⁷，或3 × 3 × 3 × 3 × 3 × 3 × 3，这与(3 × 3 × 3 × 3 ×
    3 × 3) × 3相同，或(3⁶) × 3。然后我们可以进行相同的递归调用来计算3⁶。
- en: Those are the recursive cases, but what are the base cases? Mathematically speaking,
    any number to the zeroth power is defined as 1, while any number to the first
    power is the number itself. So for any function call `exponentByRecursion(a, n)`,
    if `n` is `0` or `1`, we can simply return `1` or `a`, respectively, because `a``0`
    is always `1` and `a``1` is always `a`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是递归情况，但基本情况是什么？从数学上讲，任何数的零次幂被定义为1，而任何数的一次幂就是这个数本身。因此，对于任何函数调用`exponentByRecursion(a,
    n)`，如果`n`是`0`或`1`，我们可以简单地返回`1`或`a`，因为`a``0`总是`1`，而`a``1`总是`a`。
- en: 'Using all this information, we can write code for the `exponentByRecursion()`
    function. Here is an *exponentByRecursion.py* file with the Python code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 利用所有这些信息，我们可以为`exponentByRecursion()`函数编写代码。以下是带有Python代码的*exponentByRecursion.py*文件：
- en: '**Python**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE42]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And here is the equivalent JavaScript code in *exponentByRecursion.html*:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*exponentByRecursion.html*中等效的JavaScript代码：
- en: '**JavaScript**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE43]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you run this code, the output is identical to the iterative version:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，输出与迭代版本相同：
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Each recursive call effectively cuts the problem size in half. This is what
    makes our recursive exponent algorithm faster than the iterative version; calculating
    3^(1000) iteratively entails 1,000 multiplication operations, while doing it recursively
    requires only 23 multiplications and divisions. When running the Python code under
    a performance profiler, calculating 3^(1000) iteratively 100,000 times takes 10.633
    seconds, but the recursive calculation takes only 0.406 seconds. That is a huge
    improvement!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 每个递归调用实际上将问题规模减半。这就是使我们的递归指数算法比迭代版本更快的原因；迭代地计算3^(1000)需要1000次乘法操作，而递归计算只需要23次乘法和除法。在性能分析器下运行Python代码时，迭代地计算3^(1000)100,000次需要10.633秒，但递归计算只需要0.406秒。这是一个巨大的改进！
- en: Creating an Iterative Exponents Function Based on Recursive Insights
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于递归洞察力创建一个迭代指数函数
- en: 'Our original iterative exponents function took a straightforward approach:
    loop the same number of times as the exponent power. However, this doesn’t scale
    well for larger powers. Our recursive implementation forced us to think about
    how to break this problem into smaller subproblems. This approach turns out to
    be much more efficient.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的迭代指数函数采用了一种直接的方法：循环的次数与指数幂相同。然而，这对于更大的幂并不适用。我们的递归实现迫使我们考虑如何将这个问题分解为更小的子问题。这种方法事实证明更加高效。
- en: 'Because every recursive algorithm has an equivalent iterative algorithm, we
    could make a new iterative exponents function based on the power rule that the
    recursive algorithm uses. The following *exponentWithPowerRule.py* program has
    such a function:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个递归算法都有一个等效的迭代算法，我们可以基于递归算法使用的幂规则创建一个新的迭代指数函数。以下*exponentWithPowerRule.py*程序有这样一个函数：
- en: '**Python**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE45]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here is the equivalent JavaScript program in *exponentWithPowerRule.html*:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*exponentWithPowerRule.html*中等效的JavaScript程序：
- en: '**JavaScript**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE46]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our algorithm keeps reducing `n` by dividing it in half (if it’s even) or subtracting
    1 (if it’s odd) until it is `1`. This gives us the squaring or multiply-by-`a`
    operations we have to perform. After finishing this step, we perform these operations
    in reverse order. A generic stack data structure (separate from the call stack)
    is useful for reversing the order of these operations since it’s a first-in, last-out
    data structure. The first step pushes squaring or multiply-by-`a` operations to
    a stack in the `opStack` variable. In the second step, it performs these operations
    as it pops them off the stack.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的算法通过将“n”减半（如果它是偶数）或减1（如果它是奇数）来不断减少“n”，直到它变为“1”。这给了我们必须执行的平方或乘以“a”的操作。完成此步骤后，我们按相反的顺序执行这些操作。通用的堆栈数据结构（与调用堆栈分开）对于颠倒这些操作的顺序非常有用，因为它是一种先进后出的数据结构。第一步将平方或乘以“a”的操作推送到“opStack”变量中的堆栈。在第二步中，它在弹出堆栈时执行这些操作。
- en: For example, calling `exponentWithPowerRule(6, 5)` to calculate 6⁵ sets `a`
    as `6` and `n` as `5`. The function notes that `n` is odd. This means we should
    subtract `1` from `n` to get `4` and push a multiply-by-`a` operation to `opStack`.
    Now that `n` is `4` (even), we divide it by `2` to get `2` and push a squaring
    operation to `opStack`. Since `n` is now `2` and even again, we divide it by `2`
    to get `1` and push another squaring operation to `opStack`. Now that `n` is `1`,
    we are finished with this first step.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，调用“exponentWithPowerRule(6, 5)”来计算6⁵，将“a”设置为“6”，将“n”设置为“5”。函数注意到“n”是奇数。这意味着我们应该从“n”中减去“1”得到“4”，并将一个乘以“a”的操作推送到“opStack”。现在“n”是“4”（偶数），我们将其除以“2”得到“2”，并将一个平方操作推送到“opStack”。由于“n”现在是“2”并且再次是偶数，我们将其除以“2”得到“1”，并将另一个平方操作推送到“opStack”。现在“n”是“1”，我们已经完成了这一步。
- en: To perform the second step, we start the `result` as `a` (which is `6`). We
    pop the `opStack` stack to get a squaring operation, telling the program to set
    `result` to `result * result` (that is, `result``2`) or `36`. We pop the next
    operation off `opStack`, and it is another squaring operation, so the program
    changes the `36` in `result` to `36 * 36`, or `1296`. We pop the last operation
    off `opStack`, and it is a multiply-by-`a` operation, so we multiply the `1296`
    in `result` by `a` (which is `6`) to get `7776`. There are no more operations
    on `opStack`, so the function is now finished. When we double-check our math,
    we find that 6⁵ is indeed 7,776.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行第二步，我们将“result”开始为“a”（即“6”）。我们弹出opStack堆栈以获得一个平方操作，告诉程序将“result”设置为“result
    * result”（即“result”2）或“36”。我们弹出opStack的下一个操作，又是一个平方操作，所以程序将“result”中的“36”更改为“36
    * 36”，或“1296”。我们弹出opStack的最后一个操作，它是一个乘以“a”的操作，所以我们将“result”中的“1296”乘以“a”（即“6”）得到“7776”。opStack上没有更多的操作，所以函数现在已经完成。当我们再次检查我们的数学时，我们发现6⁵确实是7,776。
- en: The stack in `opStack` looks like [Figure 2-4](#figure2-4) as the function call
    `exponentWithPowerRule(6, 5)` executes.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: opStack中的堆栈在函数调用“exponentWithPowerRule(6, 5)”执行时看起来像[图2-4](#figure2-4)。
- en: '![Timeline showing the state of the opStack stack over time. In the first step,
    it begins empty; then Multiply is pushed to the stack, Square is pushed to the
    stack, and, finally, a second Square operation is pushed to the top of the stack.
    In the second step, the most recent Square operation is popped off the stack,
    the first Square operation is popped off the stack, and then the Multiply operation
    is popped off the stack, which is now empty.](image_fi/502024c02/f02004.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴显示了随时间推移opStack堆栈的状态。在第一步中，它开始为空；然后将Multiply推送到堆栈，将Square推送到堆栈，最后将第二个Square操作推送到堆栈顶部。在第二步中，最近的Square操作从堆栈中弹出，第一个Square操作从堆栈中弹出，然后将Multiply操作从堆栈中弹出，现在堆栈为空。](image_fi/502024c02/f02004.png)'
- en: 'Figure 2-4: The stack in `opStack` during the `exponentWithPowerRule(6, 5)`
    function call'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-4：在函数调用“exponentWithPowerRule(6, 5)”期间opStack中的堆栈
- en: 'When you run this code, the output is identical to the other exponent programs:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，输出与其他指数程序相同：
- en: '[PRE47]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The iterative exponents function that uses the power rule has the improved performance
    of the recursive algorithm, while not suffering from the risk of a stack overflow.
    We might not have thought of this new, improved iterative algorithm without the
    insights of recursive thinking.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用幂规则的迭代指数函数具有递归算法的改进性能，同时不会遭受堆栈溢出的风险。如果没有递归思维的见解，我们可能不会想到这种新的、改进的迭代算法。
- en: When Do You Need to Use Recursion?
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时需要使用递归？
- en: You never *need* to use recursion. No programming problem *requires* recursion.
    This chapter has shown that recursion has no magical power to do things that iterative
    code in a loop with a stack data structure cannot do. In fact, a recursive function
    might be an overcomplicated solution for what you’re trying to achieve.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您永远不需要使用递归。没有编程问题需要递归。本章已经表明，递归没有魔力可以做迭代代码和堆栈数据结构中的循环无法做的事情。实际上，递归函数可能是您尝试实现的内容的过于复杂的解决方案。
- en: 'However, as the exponent functions we created in the previous section show,
    recursion can provide new insights into how to think about our programming problem.
    Three features of a programming problem, when present, make it especially suitable
    to a recursive approach:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在上一节中创建的指数函数所示，递归可以为我们如何思考编程问题提供新的见解。编程问题的三个特征，当存在时，使其特别适合递归方法：
- en: It involves a tree-like structure.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它涉及树状结构。
- en: It involves backtracking.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它涉及回溯。
- en: It isn’t so deeply recursive as to potentially cause a stack overflow.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它并不是如此深度递归，以至于可能导致堆栈溢出。
- en: 'A tree has a *self-similar* structure: the branching points look similar to
    the root of a smaller subtree. Recursion often deals with self-similarity and
    problems that can be divided into smaller, similar subproblems. The root of the
    tree is analogous to the first call to a recursive function, the branching points
    are analogous to recursive cases, and the leaves are analogous to the base cases
    where no more recursive calls are made.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 树具有*自相似*结构：分叉点看起来类似于较小子树的根。递归通常涉及自相似性和可以分解为更小、相似子问题的问题。树的根类似于对递归函数的第一次调用，分叉点类似于递归情况，叶子类似于没有更多递归调用的基本情况。
- en: A maze is also a good example of a problem that has a tree-like structure and
    requires backtracking. In a maze, the branching points occur wherever you must
    pick one of many paths to follow. If you reach a dead end, you’ve encountered
    the base case. You must then backtrack to a previous branching point to select
    a different path to follow.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫也是一个具有树状结构并需要回溯的问题的很好例子。在迷宫中，分叉点出现在您必须选择许多路径中的一个时。如果您到达了死胡同，那么您已经遇到了基本情况。然后您必须回溯到先前的分叉点，选择一个不同的路径继续前进。
- en: '[Figure 2-5](#figure2-5) shows a maze’s path visually morphed to look like
    a biological tree. Despite the visual difference between the maze paths and the
    tree-shaped paths, their branching points are related to each other in the same
    way. Mathematically, these graphs are equivalent.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-5](#figure2-5)显示了一个迷宫的路径在视觉上形变成生物树的样子。尽管迷宫路径和树形路径在视觉上有所不同，但它们的分叉点在数学上是相关的。从数学上讲，这些图是等价的。'
- en: '![Three images: the first is a classic maze with branching paths, the second
    shows lines tracing through every path of the maze with a circle at every branch,
    and the third is this line-and-circle drawing distorted to look like the branches
    of a tree.](image_fi/502024c02/f02005.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![三幅图像：第一幅是一个经典的迷宫，有分叉路径，第二幅显示了迷宫中每条路径的线条，并在每个分叉处有一个圆圈，第三幅是这条线和圆圈的图案扭曲成树枝的样子。](image_fi/502024c02/f02005.png)'
- en: 'Figure 2-5: A maze (left) along with its interior paths (center) morphed to
    match a biological tree’s shape (right)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-5：一个迷宫（左）以及其内部路径（中）形变成生物树的形状（右）
- en: Many programming problems have this tree-like structure at their core. For example,
    a filesystem has a tree-like structure; the subfolders look like the root folders
    of a smaller filesystem. [Figure 2-6](#figure2-6) compares a filesystem to a tree.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程问题都具有这种树状结构。例如，文件系统具有树状结构；子文件夹看起来像较小文件系统的根文件夹。[图2-6](#figure2-6)将文件系统与树进行了比较。
- en: '![Two images, one of a tree and the other of a filesystem, with arrows pointing
    out the equivalent of leaves, branching points, and the root on each.](image_fi/502024c02/f02006.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![两幅图像，一幅是一棵树，另一幅是一个文件系统，箭头指出了每个等价的叶子、分叉点和根。](image_fi/502024c02/f02006.png)'
- en: 'Figure 2-6: A filesystem is similar to a tree structure.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-6：文件系统类似于树结构。
- en: 'Searching for a specific filename in a folder is a recursive problem: you search
    the folder and then recursively search the folder’s subfolders. Folders with no
    subfolders are the base cases that cause the recursive searching to stop. If your
    recursive algorithm doesn’t find the filename it’s looking for, it backtracks
    to a previous parent folder and continues searching from there.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件夹中搜索特定文件名是一个递归问题：您搜索文件夹，然后递归搜索文件夹的子文件夹。没有子文件夹的文件夹是导致递归搜索停止的基本情况。如果您的递归算法找不到它正在寻找的文件名，它会回溯到先前的父文件夹，并从那里继续搜索。
- en: The third point is a matter of practicality. If your tree structure has so many
    levels of branches that a recursive function would cause a stack overflow before
    it can reach the leaves, then recursion isn’t a suitable solution.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第三点是实用性问题。如果您的树结构具有如此多层的分支，以至于递归函数在到达叶子之前就会导致堆栈溢出，那么递归就不是一个合适的解决方案。
- en: On the other hand, recursion is the best approach for creating programming language
    compilers. Compiler design is its own expansive subject and beyond the scope of
    this book. But programming languages have a set of grammar rules that can break
    source code into a tree structure similar to the way grammar rules can break English
    sentences into a tree diagram. Recursion is an ideal technique to apply to compilers.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，递归是创建编程语言编译器的最佳方法。编译器设计是一个庞大的课题，超出了本书的范围。但是编程语言有一组语法规则，可以将源代码分解成类似于语法规则可以将英语句子分解成树状图的树状结构。递归是应用于编译器的理想技术。
- en: We’ll identify many recursive algorithms in this book, and they often have the
    tree-like structure or backtracking features that lend themselves to recursion
    well.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中识别许多递归算法，它们通常具有树状结构或回溯特性，非常适合递归。
- en: Coming Up with Recursive Algorithms
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提出递归算法
- en: Hopefully, this chapter has given you a firm idea of how recursive functions
    compare to the iterative algorithms you’re likely more familiar with. The rest
    of this book dives into the details of various recursive algorithms. But how should
    you go about writing your own recursive functions?
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 希望本章让您对递归函数与您可能更熟悉的迭代算法有了一个坚实的概念。本书的其余部分将深入探讨各种递归算法的细节。但是，您应该如何编写自己的递归函数呢？
- en: The first step is always to identify the recursive case and the base case. You
    can take a top-down approach by breaking the problem into subproblems that are
    similar to the original problem but smaller; this is your *recursive case*. Then
    consider when the subproblems are small enough to have a trivial answer; this
    is your *base case*. Your recursive function may have more than one recursive
    case or base case, but all recursive functions will always have at least one recursive
    case and at least one base case.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步总是要确定递归情况和基本情况。您可以采用自顶向下的方法，将问题分解为与原始问题相似但更小的子问题；这就是您的*递归情况*。然后考虑子问题何时足够小以获得一个微不足道的答案；这就是您的*基本情况*。您的递归函数可能有多个递归情况或基本情况，但所有递归函数都至少有一个递归情况和至少一个基本情况。
- en: The recursive Fibonacci algorithm is an example. A Fibonacci number is the sum
    of the previous two Fibonacci numbers. We can break the problem of finding a Fibonacci
    number into the subproblems of finding two smaller Fibonacci numbers. We know
    the first two Fibonacci numbers are both 1, so that provides the base case answer
    once the subproblems are small enough.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 递归斐波那契算法就是一个例子。斐波那契数是前两个斐波那契数的和。我们可以将查找斐波那契数的问题分解为查找两个较小斐波那契数的子问题。我们知道前两个斐波那契数都是1，所以一旦子问题足够小，就可以得到基本情况的答案。
- en: Sometimes it helps to take a bottom-up approach and consider the base case first,
    and then see how larger and larger problems are constructed and solved from there.
    The recursive factorial problem is an example. The factorial of 1! is 1\. This
    forms the base case. The next factorial is 2!, and you create it by multiplying
    1! by 2\. The factorial after that, 3!, is created by multiplying 2! by 3, and
    so on. From this general pattern, we can figure out what the recursive case for
    our algorithm will be.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，先采用自下而上的方法考虑基本情况，然后再看如何从中构建和解决更大的问题。递归阶乘问题就是一个例子。1的阶乘是1。这形成了基本情况。下一个阶乘是2！，你可以通过将1！乘以2来创建它。之后的阶乘，3！，是通过将2！乘以3来创建的，依此类推。通过这种一般模式，我们可以找出我们算法的递归情况会是什么。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered calculating factorials and the Fibonacci sequence,
    two classic recursive programming problems. This chapter featured both iterative
    and recursive implementations for these algorithms. Despite being classic examples
    of recursion, their recursive algorithms suffer from critical flaws. The recursive
    factorial function can cause stack overflows, while the recursive Fibonacci function
    performs so many redundant calculations that it’s far too slow to be effective
    in the real world.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们涵盖了计算阶乘和斐波那契数列，这两个经典的递归编程问题。本章介绍了这些算法的迭代和递归实现。尽管它们是递归的经典示例，但它们的递归算法存在严重的缺陷。递归阶乘函数可能会导致堆栈溢出，而递归斐波那契函数执行了太多的冗余计算，以至于在现实世界中效率太低。
- en: We explored how to create recursive algorithms from iterative algorithms and
    how to create iterative algorithms from recursive algorithms. Iterative algorithms
    use a loop, and any recursive algorithm can be performed iteratively by using
    a loop and a stack data structure. Recursion is often an overly complicated solution,
    but programming problems that involve a tree-like structure and backtracking are
    particularly suitable for recursive implementations.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何从迭代算法创建递归算法，以及如何从递归算法创建迭代算法。迭代算法使用循环，任何递归算法都可以通过使用循环和堆栈数据结构来进行迭代执行。递归通常是一个过于复杂的解决方案，但涉及树状结构和回溯的编程问题特别适合递归实现。
- en: Writing recursive functions is a skill that improves with practice and experience.
    The rest of this book covers several well-known recursion examples and explores
    their strengths and limitations.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 编写递归函数是一种随着练习和经验而提高的技能。本书的其余部分涵盖了几个众所周知的递归示例，并探讨了它们的优势和局限性。
- en: Further Reading
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You can find more information about comparing iteration and recursion in the
    Computerphile YouTube channel’s video “Programming Loops vs. Recursion” at [https://youtu.be/HXNhEYqFo0o](https://youtu.be/HXNhEYqFo0o).
    If you want to compare the performance of iterative and recursive functions, you
    need to learn how to use a profiler. Python profilers are explained in Chapter
    13 of my book *Beyond the Basic Stuff with Python* (No Starch Press, 2020), which
    can be read at [https://inventwithpython.com/beyond/chapter13.html](https://inventwithpython.com/beyond/chapter13.html).
    The official Python documentation also covers profilers at [https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html).
    The Firefox profiler for JavaScript is explained on Mozilla’s website at [https://developer.mozilla.org/en-US/docs/Tools/Performance](https://developer.mozilla.org/en-US/docs/Tools/Performance).
    Other browsers have profilers similar to Firefox’s.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Computerphile YouTube频道的视频“Programming Loops vs. Recursion”中找到有关比较迭代和递归的更多信息，网址为[https://youtu.be/HXNhEYqFo0o](https://youtu.be/HXNhEYqFo0o)。如果您想比较迭代和递归函数的性能，您需要学习如何使用分析器。Python分析器在我的书*Beyond
    the Basic Stuff with Python*（No Starch Press, 2020）的第13章中有解释，可以在[https://inventwithpython.com/beyond/chapter13.html](https://inventwithpython.com/beyond/chapter13.html)上阅读。官方的Python文档也涵盖了分析器，网址为[https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html)。Mozilla网站上解释了JavaScript的Firefox分析器，网址为[https://developer.mozilla.org/en-US/docs/Tools/Performance](https://developer.mozilla.org/en-US/docs/Tools/Performance)。其他浏览器也有类似于Firefox的分析器。
- en: Practice Questions
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习问题
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试您的理解：
- en: What is 4! (that is, the factorial of 4)?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4的阶乘是多少？
- en: How can you use the factorial of (*n* – 1) to calculate the factorial of *n*?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用(*n* – 1)的阶乘来计算*n*的阶乘？
- en: What is the critical weakness of the recursive factorial function?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归阶乘函数的关键弱点是什么？
- en: What are the first five numbers of the Fibonacci sequence?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 斐波那契数列的前五个数字是什么？
- en: What two numbers do you add to get the *n*th Fibonacci number?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了得到第*n*个斐波那契数，你需要加上哪两个数字？
- en: What is the critical weakness of the recursive Fibonacci function?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归斐波那契函数的关键弱点是什么？
- en: What does an iterative algorithm always use?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代算法总是使用什么？
- en: Is it always possible to convert an iterative algorithm into a recursive one?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是可以将迭代算法转换为递归算法吗？
- en: Is it always possible to convert a recursive algorithm into an iterative one?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是可以将递归算法转换为迭代算法吗？
- en: Any recursive algorithm can be performed iteratively by using what two things?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何递归算法都可以通过使用哪两种方法来进行迭代执行？
- en: What three features do programming problems that are suitable to recursive solutions
    have?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适合递归解决方案的编程问题具有哪三个特征？
- en: When is recursion required to solve a programming problem?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时需要递归来解决编程问题？
- en: Practice Projects
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习项目
- en: 'For practice, write a function for each of the following tasks:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Iteratively calculate the sum of the integer series from `1` to `n`. This is
    similar to the `factorial()` function, except it performs addition instead of
    multiplication. For example, `sumSeries(1)` returns `1`, `sumSeries(2)` returns
    `3` (that is, `1 + 2`), `sumSeries(3)` returns `6` (that is, `1 + 2 + 3`), and
    so on. This function should use a loop instead of recursion. Take a look at the
    *factorialByIteration.py* program in this chapter for guidance.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the recursive form of `sumSeries()`. This function should use recursive
    function calls instead of a loop. Look at the *factorialByRecursion.py* program
    in this chapter for guidance.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iteratively calculate the sum of the first `n` powers of 2 in a function named
    `sumPowersOf2()`. The powers of 2 are 2, 4, 8, 16, 32, and so on. In Python, these
    are calculated with `2 ** 1`, `2 ** 2`, `2 ** 3`, `2 ** 4`, `2 ** 5`, and so on,
    respectively. In JavaScript, these are calculated with `Math.pow(2, 1)`, `Math.pow(2,
    2)`, and so on. For example, `sumPowersOf2(1)` returns `2`, `sumPowersOf2(2)`
    returns `6` (that is, `2 + 4`), `sumPowersOf2(3)` returns `14` (that is, `2 +
    4 + 8`), and so on.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the recursive form of `sumPowersOf2()`. This function should use recursive
    function calls instead of a loop.`  `# 3
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Classic Recursion Algorithms
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
- en: If you take a computer science course, the unit on recursion is sure to cover
    some of the classic algorithms presented in this chapter. Coding interviews (which,
    for lack of suitable ways to evaluate candidates, often crib notes from freshman
    computer science curricula) can touch upon them too. This chapter covers six classic
    problems in recursion, along with their solutions.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with three simple algorithms: summing the numbers in an array, reversing
    a text string, and detecting whether a string is a palindrome. Then we explore
    an algorithm for solving the Tower of Hanoi puzzle, implement the flood fill drawing
    algorithm, and tackle the absurdly recursive Ackermann function.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'In the process, you’ll learn about the head-tail technique for splitting up
    the data in the recursive function arguments. We’ll also ask ourselves three questions
    when trying to come up with recursive solutions: What is the base case? What argument
    is passed to the recursive function call? And how do the arguments passed to the
    recursive function calls become closer to the base case? As you gain more experience,
    answering these questions should come more naturally.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Summing Numbers in an Array
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first example is simple: given a list (in Python) or an array (in JavaScript)
    of integers, return the total sum of all the integers. For example, a call such
    as `sum([5, 2, 4, 8])` should return `19`.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: This is easy to solve with a loop, but solving it with recursion requires more
    thought. After reading Chapter 2, you might also notice that this algorithm doesn’t
    map well enough to recursion’s capabilities to justify recursion’s added complexity.
    Still, summing numbers in an array (or some other calculation based on processing
    data in a linear data structure) is a common enough recursion problem in coding
    interviews that it deserves our attention.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, let’s examine the *head-tail technique* for implementing
    recursive functions. This technique splits the recursive function’s array argument
    into two parts: the *head* (the first element of the array) and the *tail* (a
    new array including everything after the first element). We define the recursive
    `sum()` function to find the sum of the array argument’s integers by adding the
    head to the sum of the tail array. To find out the sum of the tail array, we recursively
    pass it as the array argument to `sum()`.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the tail array is one element smaller than the original array argument,
    we’ll eventually end up calling the recursive function and passing it an empty
    array. An empty array argument is trivial to sum and doesn’t require more recursive
    calls; it is merely `0`. From these facts, our answers to the three questions
    are as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? An empty array, which has the sum of `0`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The tail of the original
    number array, which has one less number than the original array argument.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The array argument shrinks
    by one element for each recursive call until it becomes a zero-length, or empty,
    array.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is *sumHeadTail.py*, a Python program to sum a list of numbers:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And here is the equivalent JavaScript program, *sumHeadTail.html*:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output of these programs is shown here:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When called with an empty array argument, the base case of our function simply
    returns `0` ❶. In the recursive case, we form the head ❷ and the tail ❸ from the
    original `numbers` argument. Keep in mind that the data type of `tail` is an array
    of numbers, just like the `numbers` argument. But the data type of `head` is just
    a single number value, and not an array with one number value. The return value
    of the `sum()` function is also a single number value and not an array of numbers;
    this is why we can add `head` and `sum(tail)` together in the recursive case ❹.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Each recursive call passes a smaller and smaller array to `sum()`, bringing
    it closer to the base case of an empty array. For example, [Figure 3-1](#figure3-1)
    shows the state of the call stack for `sum([5, 2, 4, 8])`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, each card in the stack represents a function call. At the top
    of each card is the function name with the argument it was passed when called.
    Beneath that are the local variables: the `numbers` parameter, and the `head`
    and `tail` local variables created during the call. At the bottom of the card
    is the `head + sum(tail)` expression that the function call returns. When a new
    recursive function is made, a new card is pushed to the stack. When the function
    call returns, the top card is popped from the stack.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '![A series of stacks of cards representing frame objects on the call stack.
    In order, the new top card represents a call to sum() passing [5, 2, 4, 8], then
    passing [2, 4, 8], then passing [4, 8], then passing [8], then passing an empty
    list. Then the top cards are removed, first removing the empty list card, then
    the [8] card, then [4, 8], then [2, 4, 8], then [5, 2, 4, 8].](image_fi/502024c03/f03001.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: The state of the call stack when `sum([5, 2, 4, 8])` runs'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `sum()` function as a template for applying the head-tail technique
    to other recursive functions. For example, you can change the `sum()` function
    from one that sums an array of numbers to a `concat()` function that concatenates
    an array of strings together. The base case would return an empty string for an
    empty array argument, while the recursive case would return the head string joined
    with the return value of the recursive call that is passed the tail.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Recall from Chapter 2 that recursion is especially suited for problems that
    involve a tree-like structure and backtracking. An array, string, or other linear
    data structure can be considered a tree-like structure, albeit a tree that has
    only one branch at each node, as in [Figure 3-2](#figure3-2).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![Two images, one of a tree with every node circled, and one of a crooked branch
    with every bend circled and the numbers 8, 4, 2, and 5 written in the circles.](image_fi/502024c03/f03002.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: A `[5, 2, 4, 8]` array (right) is like a tree data structure (left)
    with only one branch at each node.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: The key “tell” that our recursive function is unnecessary is that it never does
    any backtracking over the data it processes. It makes a single pass over each
    element in the array from beginning to end, which is something a basic loop can
    accomplish. Additionally, the Python recursive summation function is about 100
    times slower than a straightforward iterative algorithm. Even if performance weren’t
    an issue, the recursive `sum()` function would cause a stack overflow if passed
    a list with tens of thousands of numbers to sum. Recursion is an advanced technique,
    but it isn’t always the best approach.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的递归函数不必要的关键“告诉”是它从不在处理的数据上进行任何回溯。它对数组中的每个元素进行单次遍历，这是基本循环可以完成的事情。此外，Python递归求和函数比直接迭代算法慢大约100倍。即使性能不是问题，递归`sum()`函数如果传递一个要求求和的数目为数万的列表会导致堆栈溢出。递归是一种高级技术，但并不总是最佳方法。
- en: In Chapter 5, we’ll examine a recursive summation function that uses a divide-and-conquer
    strategy, and in Chapter 8 we’ll examine one that uses tail call optimization.
    These alternate recursive approaches work around some of the problems in the summation
    function in this chapter.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章中，我们将研究使用分而治之策略的递归求和函数，在第8章中，我们将研究使用尾调用优化的递归函数。这些替代的递归方法解决了本章中求和函数的一些问题。
- en: Reversing a String
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转字符串
- en: Like summing the numbers in an array, reversing a string is another frequently
    cited recursive algorithm even though the iterative solution is straightforward.
    Because a string is essentially an array of single characters, we’ll employ the
    head and tail approach for our `rev()` function just as we did for the summation
    algorithm.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 像对数组中的数字求和一样，反转字符串是另一个经常被引用的递归算法，尽管迭代解决方案很简单。因为字符串本质上是一个由单个字符组成的数组，所以我们将为我们的`rev()`函数采用头部和尾部的方法，就像我们为求和算法所做的那样。
- en: 'Let’s start with the smallest strings possible. A blank string and a single-character
    string are already the reverse of themselves. These naturally form our base cases:
    if the string argument is a string such as `''''` or `′A′`, our function should
    simply return the string argument.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从可能的最小的字符串开始。一个空字符串和一个单字符字符串已经是它们自己的反转。这自然形成了我们的基本情况：如果字符串参数是`''`或`′A′`这样的字符串，我们的函数应该简单地返回字符串参数。
- en: 'For larger strings, let’s try splitting the string into a head (just the first
    character) and tail (all characters after the first). For a two-character string
    like `′XY′`, `′X′` is the head and `′Y′` is the tail. To reverse the string, we
    need to place the head behind the tail: `′YX′`.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更长的字符串，让我们尝试将字符串分割成头部（仅为第一个字符）和尾部（第一个字符之后的所有字符）。对于一个两个字符的字符串，比如`′XY′`，`′X′`是头部，`′Y′`是尾部。要反转字符串，我们需要将头部放在尾部后面：`′YX′`。
- en: Does this algorithm hold for longer strings? To reverse a string like `′CAT′`,
    we would break it into the head `′C′` and the tail `′AT′`. But placing the head
    behind the tail alone doesn’t reverse the string; it gives us `′ATC′`. What we
    actually want to do is put the head behind *the reverse of* the tail. In other
    words, `′AT′` would reverse to `′TA′`, and then adding the head to the end of
    that would produce the reversed string, `′TAC′`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法对更长的字符串有效吗？要反转像`′CAT′`这样的字符串，我们会将它分成头部`′C′`和尾部`′AT′`。但仅仅将头部放在尾部后面并不能反转字符串；它给我们的是`′ATC′`。实际上，我们想要做的是将头部放在尾部的*反转*后面。换句话说，`′AT′`会反转成`′TA′`，然后将头部添加到末尾会产生反转后的字符串`′TAC′`。
- en: 'How can we reverse the tail? Well, we can recursively call `rev()` and pass
    it the tail. Forget about the implementation of our function for a moment and
    focus on its input and output: `rev()` takes one string argument and returns a
    string with the argument’s characters reversed.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何反转尾部？嗯，我们可以递归调用`rev()`并将尾部传递给它。暂时忘记我们函数的实现，专注于它的输入和输出：`rev()`接受一个字符串参数，并返回一个将参数的字符反转的字符串。
- en: Thinking about how to implement a recursive function like `rev()` can be difficult
    because it involves a chicken-and-egg problem. In order to write `rev()`’s recursive
    case, we need to call a function that reverses a string—that is, `rev()`. As long
    as we have a solid understanding of what our recursive function’s arguments and
    return value will be, we can use the *leap-of-faith* technique to get around this
    chicken-and-egg problem by writing our recursive case assuming the `rev()` function
    call returns the correct value even though we haven’t finished writing it yet.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如何实现像`rev()`这样的递归函数可能很困难，因为它涉及到一个鸡和蛋的问题。为了编写`rev()`的递归情况，我们需要调用一个反转字符串的函数，也就是`rev()`。只要我们对我们的递归函数的参数和返回值有一个坚实的理解，我们就可以使用“信任飞跃”技术来解决这个鸡和蛋问题，即使我们还没有完成编写它。
- en: Taking a leap of faith in recursion is not a magical technique that guarantees
    your code works bug free. It is merely a perspective to hold to break past the
    mental programmer’s block you can have when thinking about how to implement your
    recursive function. The leap of faith requires you to have a firm understanding
    of your recursive function’s arguments and return value.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归中进行信任飞跃并不是一个可以保证您的代码无错误的神奇技术。它只是一种观点，可以打破您在思考如何实现递归函数时可能遇到的心理程序员障碍。信任飞跃要求您对递归函数的参数和返回值有坚定的理解。
- en: 'Note that the leap-of-faith technique only helps you write the recursive case.
    You must pass to the recursive call an argument that is closer to the base case.
    You can’t simply pass the same argument that the recursive function received,
    like this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，信任飞跃技术只有在编写递归情况时才有帮助。您必须将一个接近基本情况的参数传递给递归调用。您不能简单地传递递归函数接收到的相同参数，就像这样：
- en: '[PRE51]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To continue our `′CAT′` example, when we pass the tail `′AT′` to `rev()`, the
    head is `′A′` and the tail is `′T′` in *that* function call. We already know that
    the reverse of a single-character string like `′T′` is simply `′T′`; that’s our
    base case. So this second call to `rev()` will reverse `′AT′` to `′TA′`, which
    is precisely what the previous call to `rev()` needs. [Figure 3-3](#figure3-3)
    shows the state of the call stack during all the recursive calls to `rev()`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask our three recursive algorithm questions about the `rev()` function:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? A zero- or one-character string.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The tail of the original
    string argument, which has one less character than the original string argument.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The array argument shrinks
    by one element for each recursive call until it becomes a one- or zero-length
    array.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Timeline showing the state of the call stack during each recursive call to
    the rev function. It begins with rev called with the argument “CAT,” the theString
    variable equal to “CAT,” the head variable equal to “C,” the tail variable equal
    to “AT,” and a return value of rev(‘AT’) + ‘C’. Next, rev is called with the argument
    “AT,” theString is “AT,” head is “A,” tail is “T,” and the return value is rev(‘T’)
    + ‘A’. Then, rev is called with the argument “T,” theString is equal to “T,” and
    the function returns ‘T’. In the fourth state, rev is called with an argument
    of “AT,” theString is “AT,” head is “A,” tail is “T,” and the function returns
    ‘T’ + ‘A’. Finally, rev is called with the argument “CAT,” theString is “CAT,”
    head is “C,” tail is “AT,” and the function returns ‘TA’ + ‘C’. After this, the
    call stack is empty.](image_fi/502024c03/f03003.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: The state of the call stack as the `rev()` function reverses the
    `CAT` string'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is *reverseString.py*, a Python program to reverse a string:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And here is the equivalent JavaScript code in *reverseString.html*:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here is the output of these programs:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Our recursive function `rev()` returns the string that is the reverse of the
    argument, `theString`. Let’s consider the simplest strings to reverse: the empty
    string and a single-character string would “reverse” to themselves. These are
    the two base cases with which we’ll start (though we combine them with an `or`
    or `||` Boolean operator ❶). For the recursive case, we form `head` from the first
    character in `theString` ❷, and `tail` from every character after the first ❸.
    The recursive case then returns the reverse of `tail` followed by the `head` character
    ❹.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Palindromes
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *palindrome* is a word or phrase that is spelled the same when written forward
    and backward. *Level*, *race car*, *taco cat*, and *a man, a plan, a canal . .
    . Panama* are all examples of palindromes. If you would like to detect whether
    a string is a palindrome, you can write a recursive `isPalindrome()` function.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: The base case is a zero- or one-character string, which by its nature is always
    the same, whether forward or backward. We’ll use an approach similar to the head-tail
    technique, except that we’ll split the string argument into head, middle, and
    last strings instead. If the head and last characters are the same and the middle
    characters also form a palindrome, the string is a palindrome. The recursion comes
    from passing the middle string to `isPalindrome()`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursive algorithm questions about the `isPalindrome()`
    function:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? A zero- or one-character string, which returns `True`
    because it is always a palindrome.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The middle characters
    of the string argument.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The string argument shrinks
    by two characters for each recursive call until it becomes a zero- or one-character
    string.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is *palindrome.py*, a Python program to detect palindromes:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here is the equivalent JavaScript code in *palindrome.html*:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here is the output of these programs:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The base case returns `True` because a zero- or one-character string is always
    a palindrome. Otherwise, the string argument is broken into three pieces: the
    first character ❶, the last character ❸, and the middle characters between them
    ❷.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: The `return` statement in the recursive case ❹ makes use of *Boolean short-circuiting*,
    a feature of almost every programming language. In an expression joined with the
    `and` or `&&` Boolean operators, if the left-side expression is `False`, it doesn’t
    matter if the right-side expression is `True` or `False` because the entire expression
    will be `False`. Boolean short-circuiting is an optimization that skips the evaluation
    of the right-side expression of an `and` operator if the left side is `False`.
    So, in the expression `head == last and isPalindrome(middle)`, if `head == last`
    is `False`, the recursive call to `isPalindrome()` is skipped. This means that
    as soon as the head and last strings don’t match, the recursion stops and simply
    returns `False`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: This recursive algorithm is still sequential, like the summation and reverse-string
    functions in the previous sections, except that instead of going from the start
    of the data to the end, it goes from both ends of the data toward the middle.
    The iterative version of this algorithm that uses a simple loop is more straightforward.
    We cover the recursive version in this book because it’s a common coding interview
    problem.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Tower of Hanoi
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Tower of Hanoi* is a puzzle involving a tower of stacked disks. The puzzle
    begins with the largest disk on the bottom, and the disk sizes decrease going
    up. Each disk has a hole in its center so that the disks can be stacked on top
    of one another on a pole. [Figure 3-4](#figure3-4) shows a wooden Tower of Hanoi
    puzzle.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture of a wooden surface with three poles sticking out of it and a stack
    of disks, decreasing in size from bottom to top, placed on the first pole.](image_fi/502024c03/f03004.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-4: A wooden Tower of Hanoi puzzle set'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve the puzzle, the player must move the stack of disks from one pole
    to another while following three rules:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: The player can move only one disk at a time.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player can move disks only to and from the top of a tower.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player can never place a larger disk on top of a smaller disk.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python’s built-in `turtledemo` module has a Tower of Hanoi demonstration that
    you can see by running `python -m turtledemo` on Windows or `python3 -m turtledemo`
    on macOS/Linux, and then selecting **minimum_hanoi** from the Examples menu. Tower
    of Hanoi animations are readily found through an internet search as well.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive algorithm for solving the Tower of Hanoi puzzle is not intuitive.
    Let’s start with the smallest case: a Tower of Hanoi with one disk. The solution
    is trivial: move the disk to another pole and you’re finished. Solving for two
    disks is slightly more complicated: move the smaller disk to one pole (we’ll call
    it the *temporary pole*) and the larger disk to the other pole (we’ll call it
    the *end pole*), and then finally move the smaller disk from the temporary pole
    to the end pole. Both disks are now on the end pole in the correct order.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you solve the three-disk tower, you’ll notice that a pattern emerges.
    To solve a tower of *n* disks from the start pole to the end pole, you must do
    the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Solve the *n* – 1 disks puzzle by moving those disks from the start pole to
    the temporary pole.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the *n*th disk from the start pole to the end pole.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve the *n* – 1 disks puzzle by moving those disks from the temporary pole
    to the end pole.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Like the Fibonacci algorithm, the recursive case for the Tower of Hanoi algorithm
    makes two recursive calls instead of just one. If we draw a tree diagram of the
    operations for solving a four-disk Tower of Hanoi, it looks like [Figure 3-6](#figure3-6).
    Solving the four-disk puzzle requires the same steps as solving the three-disk
    puzzle, as well as moving the fourth disk and performing the steps of solving
    the three-disk puzzle again. Likewise, solving the three-disk puzzle requires
    the same steps as the two-disk puzzle plus moving the third disk, and so on. Solving
    the one-disk puzzle is the trivial base case: it involves only moving the disk.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: The tree-like structure in [Figure 3-5](#figure3-5) hints that a recursive approach
    is ideal for solving the Tower of Hanoi puzzle. In this tree, the execution moves
    from top to bottom and from left to right.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: While a three-disk or four-disk Tower of Hanoi is easy for a human to solve,
    increasing numbers of disks require an exponentially increasing number of operations
    to complete. For *n* disks, it takes a minimum of 2*n* – 1 moves to solve. This
    means a 31-disk tower requires over a billion moves to complete!
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagram showing a series of operations needed to solve a four-disk Tower
    of Hanoi. The root node, “Solve 4,” branches into three nodes: one representing
    the move necessary to place the fourth disk in the correct spot, “Move 4,” and
    two “Solve 3” nodes. Each “Solve 3” node branches into its own series of nodes
    representing moves and steps.](image_fi/502024c03/f03005.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-5: The series of operations for solving a four-disk Tower of Hanoi'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask ourselves the three questions for creating a recursive solution:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Solving a tower of one disk.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? Solving a tower of size
    one less than the current size.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The size of the tower
    to solve decreases by one disk for each recursive call until it is a one-disk
    tower.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following *towerOfHanoiSolver.py* program solves the Tower of Hanoi puzzle
    and displays a visualization of each step:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This *towerOfHanoiSolver.html* program contains the equivalent JavaScript code:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When you run this code, the output shows each move of the disks until the entire
    tower has moved from Tower A to Tower B:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The Python version has an interactive mode too, where you can solve the puzzle
    yourself. Uncomment the lines of code at the end of *towerOfHanoiSolver.py* to
    play the interactive version.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: You can start by running the program with the smaller cases by setting the `TOTAL_DISKS`
    constant ❶ at the top of the program to `1` or `2`. In our program, a list of
    integers in Python and an array of integers in JavaScript represent a pole. The
    integer represents a disk, with larger integers representing larger disks. The
    integer at the start of the list or array is at the bottom of the pole, and the
    integer at the end is at the pole’s top. For example, `[6, 5, 4, 3, 2, 1]` represents
    the starting pole with six disks with the largest on the bottom, while `[]` represents
    a pole with no disks. The `TOWERS` variable contains three of these lists ❷.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'The base case merely moves the smallest disk from the start pole to the end
    pole ❸. The recursive case for a tower of *n* disks carries out three steps: solving
    the *n* – 1 case ❹, moving the *n*th disk ❺, and then solving the *n* – 1 case
    again ❻.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Using Flood Fill
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graphics programs commonly use the *flood fill algorithm* to fill an arbitrarily
    shaped area of the same color with another color. [Figure 3-6](#figure3-6) shows
    one such shape at the top left. The subsequent panels show three different sections
    of the shape flood-filled with a gray color. The flood fill begins on a white
    pixel and spreads until it meets a non-white pixel, filling the enclosed space.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'The flood fill algorithm is recursive: it begins by changing a single pixel
    to a new color. The recursive function is then called on any neighbors of the
    pixel with its same old color. It then moves on to the neighbors of the neighbors,
    and so on, converting each pixel to the new color until the enclosed space is
    filled in.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: The base case is a pixel whose color is the edge of the image or is not the
    old color. Since reaching the base case is the only way to stop the “spread” of
    recursive calls for every pixel in the image, this algorithm has the emergent
    behavior of changing all the contiguous pixels from the old color to the new color.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursive algorithm questions about our `floodFill()` function:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? When the x- and y-coordinates are for a pixel that is
    not the old color, or are at the edge of the image.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What arguments are passed to the recursive function call? The x- and y-coordinates
    of the four neighboring pixels of the current pixel are the arguments to four
    recursive calls.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do these arguments become closer to the base case? The neighboring pixels
    run up to a different color than the old color or the edge of the image. Either
    way, eventually the algorithm runs out of pixels to check.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Four screenshots of MS Paint windows containing the same abstract, squiggly
    shape. Each screenshot shows a different closed portion of the drawing colored
    gray.](image_fi/502024c03/f03006.png)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-6: The original shape in a graphics editor (top left) and the same
    shape with three different areas flood-filled with a light gray color'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of an image for our sample program, we’ll use a list of single-character
    strings to form a 2D grid of text characters to represent an “image.” Each string
    represents a “pixel,” and the specific character represents the “color.” The *floodfill.py*
    Python program implements the flood fill algorithm, the image data, and a function
    to print the image on the screen:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The *floodfill.html* program contains the equivalent JavaScript code:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When you run this code, the program fills the interior of the shape drawn by
    the `#` characters starting at coordinates 3, 3\. It replaces all the period characters
    (`.`) with `o` characters. The following output shows the before and after images:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If you want to see every step of the flood fill algorithm as it fills in the
    new character, uncomment the `printImage(image)` line ❶ in the `floodFill()` function
    and run the program again.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: The image is represented by a 2D array of string characters. We can pass this
    `image` data structure, an `x` coordinate and a `y` coordinate, and a new character
    to the `floodFill()` function. The function notes the character currently at the
    `x` and `y` coordinates and saves it to the `oldChar` variable ❷.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'If the current characters at coordinates `x` and `y` in `image` are not the
    same as `oldChar`, this is our base case, and the function simply returns. Otherwise,
    the function continues on to its four recursive cases: passing the x- and y-coordinates
    of the bottom ❸, top ❹, right ❺, and left ❻ neighbors of the current coordinates.
    After these four potential recursive calls are made, the end of the function is
    an implicit base case, made explicit in our program with a `return` statement
    ❼.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: The flood fill algorithm doesn’t have to be recursive. For large images, a recursive
    function could cause stack overflows. If we were to implement flood fill with
    a loop and a stack instead, the stack would begin with the x- and y-coordinates
    of the starting pixel. The code in the loop would pop the coordinates off the
    top of the stack, and if that coordinate’s pixel matches `oldChar`, it would push
    the coordinates of the four neighboring pixels. When the stack is empty because
    the base case is no longer pushing neighbors to the stack, the loop is finished.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: However, the flood fill algorithm doesn’t necessarily have to use a stack. The
    pushing and popping of a first-in, last-out stack is effective for backtracking
    behavior, but the order that the pixels are processed in the flood fill algorithm
    can be arbitrary. This means we could equally effectively use a set data structure
    that removes elements randomly. You can find these iterative flood fill algorithms
    implemented in *floodFillIterative.py* and *floodFillIterative.html* in the downloadable
    resources at [https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Using the Ackermann Function
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Ackermann function* is named after its discoverer, Wilhelm Ackermann. A
    student of mathematician David Hilbert (whose Hilbert curve fractal we discuss
    in Chapter 9), Ackermann published his function in 1928\. Mathematicians Rózsa
    Péter and Raphael Robinson later developed the version of the function featured
    in this section.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: While the Ackermann function has some application in advanced mathematics, it
    is mostly known for being an example of a highly recursive function. Even slight
    increases to its two integer arguments cause a large increase in the number of
    recursive calls it makes.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ackermann function takes two arguments, `m` and `n`, and has a base case
    of returning `n + 1` when `m` is `0`. There are two recursive cases: when `n`
    is `0`, the function returns `ackermann(m - 1, 1)`, and when `n` is greater than
    `0`, the function returns `ackermann(m - 1, ackermann(m, n - 1))`. These cases
    likely aren’t meaningful to you, but suffice it to say, the number of recursive
    calls the Ackermann function makes grows quickly. Calling `ackermann(1, 1)` results
    in three recursive function calls. Calling `ackermann(2, 3)` results in 43 recursive
    function calls. Calling `ackermann(3, 5)` results in 42,437 recursive function
    calls. And calling `ackermann(5, 7)` results in . . . well, actually I don’t know
    how many recursive function calls, because it would take several times the age
    of the universe to calculate.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s answer the three questions we ask when constructing recursive algorithms:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? When `m` is `0`.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What arguments are passed to the recursive function call? Either `m` or `m -
    1` is passed for the next `m` parameter; and `1`, `n - 1`, or the return value
    of `ackermann(m, n - 1)` is passed for the next `n` parameter.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do these arguments become closer to the base case? The `m` argument is always
    either decreasing or staying the same size, so it will eventually reach `0`.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an *ackermann.py* Python program:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And here is the equivalent *ackermann.html* JavaScript program:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When you run this code, the output’s indentation (set by the `indentation`
    argument) tells you how deep on the call stack the given recursive function call
    is:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can also try `ackermann(3, 3)`, but anything with larger arguments will
    probably take far too long to calculate. To speed up the calculation, try commenting
    out all `print()` and `document.write()` calls except the ones that print the
    final return value of `ackermann()`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Remember, even a recursive algorithm like the Ackermann function can be implemented
    as an iterative function. The iterative Ackermann algorithms are implemented in
    *ackermannIterative.py* and *ackermannIterative.html* in the downloadable resources
    at [https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter covered some classic recursive algorithms. For each, we asked
    the three important questions you should always ask when designing your own recursive
    functions: What is the base case? What arguments are passed to the recursive function
    call? How do these arguments become closer to the base case? If they don’t, your
    function will continue to recurse until it causes a stack overflow.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: The summation, string reversing, and palindrome detection recursive functions
    could have easily been implemented with a simple loop. The key giveaway is that
    they all make a single pass through the data given to them with no backtracking.
    As explained in Chapter 2, recursive algorithms are especially suited to problems
    that involve a tree-like structure and require backtracking.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: The tree-like structures for solving the Tower of Hanoi puzzle suggest that
    it involves backtracking, as the program execution runs from top to bottom, left
    to right, in the tree. This makes it a prime candidate for recursion, especially
    since the solution requires two recursive calls of smaller towers.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: The flood fill algorithm is directly applicable to graphics and drawing programs,
    as well as other algorithms to detect the shape of contiguous areas. If you’ve
    used the paint-bucket tool in a graphics program, you’ve likely used a version
    of the flood fill algorithm.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: The Ackermann function is an excellent example of how quickly a recursive function
    can grow as its inputs increase. While it doesn’t have many practical applications
    in day-to-day programming, no discussion about recursion would be complete without
    it. But as recursive as it is, like all recursive functions it can be implemented
    iteratively with a loop and a stack.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wikipedia has more information on the Tower of Hanoi problem at [https://en.wikipedia.org/wiki/Tower_of_Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi),
    and the Computerphile video “Recursion ‘Super Power’ (in Python)” covers solving
    the Tower of Hanoi in Python at [https://youtu.be/8lhxIOAfDss](https://youtu.be/8lhxIOAfDss).
    The 3Blue1Brown two-part video series, “Binary, Hanoi, and Sierpiński,” goes into
    even more detail by exploring the relationships among the Tower of Hanoi, binary
    numbers, and the Sierpiński Triangle fractal starting at [https://youtu.be/2SUvWfNJSsM](https://youtu.be/2SUvWfNJSsM).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Wikipedia has an animation of the flood fill algorithm working on a small image
    at [https://en.wikipedia.org/wiki/Flood_fill](https://en.wikipedia.org/wiki/Flood_fill).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: The Computerphile video “The Most Difficult Program to Compute?” discusses the
    Ackermann function at [https://youtu.be/i7sm9dzFtEI](https://youtu.be/i7sm9dzFtEI).
    If you’d like to learn more about the Ackermann function’s place in computability
    theory, the Hackers in Cambridge channel has a five-part video series on primitive
    recursive and partial recursive functions at [https://youtu.be/yaDQrOUK-KY](https://youtu.be/yaDQrOUK-KY).
    The series requires a lot of mathematical thinking on the part of the viewer,
    but you don’t need a lot of prior mathematical knowledge.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: What is the head of an array or string?
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the tail of an array or string?
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three questions this chapter presents for each recursive algorithm?
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the leap of faith in recursion?
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you need to understand about the recursive function you are writing
    before you can take a leap of faith?
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a linear data structure such as an array or string resemble a tree-like
    structure?
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the recursive `sum()` function involve any backtracking over the data it
    works on?
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the flood fill program, try changing the `im` variable’s strings to create
    a *C* shape that is not fully enclosed. What happens when you attempt to flood-fill
    the image from the middle of the *C*?
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer the three questions about recursive solutions for each of the recursive
    algorithms presented in this chapter:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base case?
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call?
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case?
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then re-create the recursive algorithms from this chapter without looking at
    the original code.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Practice Projects
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For practice, write a function for each of the following tasks:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: Using the head-tail technique, create a recursive `concat()` function that is
    passed an array of strings and returns these strings concatenated together into
    a single string. For example, `concat(['Hello', 'World'])` should return `HelloWorld`.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the head-tail technique, create a recursive `product()` function that
    is passed an array of integers and returns the total multiplied product of them.
    This code will be almost identical to the `sum()` function in this chapter. However,
    note that the base case of an array with just one integer returns the integer,
    and the base case of an empty array returns `1`.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the flood fill algorithm, count the number of “rooms,” or enclosed spaces,
    in a 2D grid. You can do this by creating nested `for` loops that call the flood
    fill function on each character in the grid if it is a period, in order to change
    the periods into hash characters. For example, the following data would result
    in the program finding six places in the grid with periods, meaning there are
    five rooms (and the space outside all the rooms).
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '4'
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backtracking and Tree Traversal Algorithms
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
- en: In previous chapters, you learned that recursion is especially suited for problems
    that involve a tree-like structure and backtracking, such as maze-solving algorithms.
    To see why, consider that a tree’s trunk splits off into multiple branches. Those
    branches themselves split off into other branches. In other words, a tree has
    a recursive, self-similar shape.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: A maze can be represented by a tree data structure, since mazes branch off into
    different paths, which in turn branch off into more paths. When you reach a dead
    end in a maze, you must backtrack to an earlier branching point.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: The task of traversing tree graphs is tightly linked with many recursive algorithms,
    such as the maze-solving algorithm in this chapter and the maze-generation program
    in Chapter 11. We’ll take a look at tree traversal algorithms and employ them
    to find certain names in a tree data structure. We’ll also use tree traversal
    for an algorithm to obtain the deepest node in a tree. Finally, we’ll see how
    mazes can be represented as a tree data structure, and employ tree traversal and
    backtracking to find a path from the start of the maze to the exit.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Using Tree Traversal
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you program in Python and JavaScript, you’re used to working with list, array,
    and dictionary data structures. You’ll encounter tree data structures only if
    you are dealing with low-level details of certain computer science algorithms
    such as abstract syntax trees, priority queues, Adelson-Velsky-Landis (AVL) trees,
    and other concepts beyond the scope of this book. However, trees themselves are
    simple enough concepts.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: A *tree* *data structure* is a data structure composed of nodes that are connected
    to other nodes by edges. The *nodes* contain data, while the *edges* represent
    a relationship with another node. Nodes are also called *vertices*. The starting
    node of a tree is called the *root*, and the nodes at the end are called *leaves*.
    Trees always have exactly one root.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '*Parent nodes* at the top have edges to zero or more *child nodes* beneath
    them. Therefore, leaves are the nodes that do not have children, parent nodes
    are the non-leaf nodes, and child nodes are all the non-root nodes. Nodes in a
    tree can have edges to multiple child nodes. The parent nodes that connect a child
    node to the root node are also called the child node’s *ancestors*. The child
    nodes between a parent node and a leaf node are called the parent node’s *descendants*.
    Parent nodes in a tree can have multiple child nodes. But every child node has
    exactly one parent, except for the root node, which has zero parents. In trees,
    only one path can exist between any two nodes.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-1](#figure4-1) shows an example of a tree and three examples of structures
    that are not trees.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '![Four diagrams. The first, labeled “Tree,” has an A node with two child nodes,
    B and C; B has one child node, D; C has two child nodes, E and F; E has two child
    nodes, G and H. The second diagram, labeled “Not a Tree (Child node has multiple
    parents),” has an A node with two child nodes, B and C; B has two child nodes,
    D and E; C has two child nodes, E and F; E has two child nodes, G and H. The third
    diagram, labeled “Not a Tree (Child node loops back to an ancestor node),” has
    a node A with two child nodes, B and C; B has one child node, D; C has two child
    nodes, E and F; D has one child node, A; E has two child nodes, G and H. The fourth
    diagram, labeled “Not a Tree (Multiple root nodes),” has two root nodes, Z and
    A; Z has one child node, B; A has two child nodes, B and C; B has one child node,
    D; C has two child nodes, E and F; E has two child nodes, G and H.](image_fi/502024c04/f04001.png)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: A tree (left) and three examples of non-trees'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, child nodes must have one parent and not have an edge that creates
    a loop, or else the structure is no longer considered a tree. The recursive algorithms
    we cover in this chapter apply only to tree data structures.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: A Tree Data Structure in Python and JavaScript
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tree data structures are often drawn growing downward, with the root at the
    top. [Figure 4-2](#figure4-2) shows a treecreated with the following Python code
    (it’s also valid JavaScript code):'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![Tree diagram and the order in which the nodes would be traversed in preorder,
    postorder, and inorder tree traversal. The tree has the root note A, which has
    two child nodes, B and C. B has one child node, D. C has two child nodes, E and
    F, and E has two child nodes, G and H. Preorder tree traversal: A, B, D, C, E,
    G, H, F. Postorder tree traversal: D, B, G, H, E, F, C, A. Inorder tree traversal:
    D, B, A, G, E, H, C, F.](image_fi/502024c04/f04002.png)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: A tree with root `A` and leaves `D`, `G`, `H`, and `F`, along with
    its traversal orders'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: Each node in the tree contains a piece of data (a string of a letter from `A`
    to `H`) and a list of its child nodes. The preorder, postorder, and inorder information
    in [Figure 4-2](#figure4-2) is explained in subsequent sections.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code for this tree, each node is represented by a Python dictionary
    (or JavaScript object) with a key `data` that stores the node’s data, and a key
    `children` that has a list of other nodes. I use the `root` and `node2` to `node8`
    variables to store each node and make the code more readable, but they aren’t
    required. The following Python/JavaScript code is equivalent to the previous code
    listing, though harder for humans to read:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The tree in [Figure 4-2](#figure4-2) is a specific kind of data structure called
    a *directed acyclic graph* *(DAG)*. In mathematics and computer science, a *graph*
    is a collection of nodes and edges, and a tree is a kind of graph. The graph is
    *directed* because its edges have one direction: from parent to child node. Edges
    in a DAG are not undirected—that is, bidirectional. (Trees in general do not have
    this restriction and can have edges in both directions, including from a child
    node back to its parent node.) The graph is *acyclic* because there are no loops,
    or *cycles*, from child nodes to their own ancestor nodes; the “branches” of the
    tree must keep growing in the same direction.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: You can think of lists, arrays, and strings as linear trees; the root is the
    first element, and the nodes have only one child node. This linear tree terminates
    at its one leaf node. These linear trees are called *linked lists*, as each node
    has only one “next” node until the end of the list. [Figure 4-3](#figure4-3) shows
    a linked list that stores the characters in the word *HELLO*.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear Tree Diagram with five nodes. The root node “H” has one child node,
    “E,” which has one child node, “L,” which has one child node, “L,” which has one
    child node, “O.”](image_fi/502024c04/f04003.png)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: A linked list data structure storing `HELLO`. Linked lists can
    be considered a kind of tree data structure.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the code for the tree in [Figure 4-2](#figure4-2) for this chapter’s
    examples. A tree traversal algorithm will visit each of the nodes in a tree by
    following the edges, starting from a root node.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Traversing the Tree
  id: totrans-571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can write code to access data in any node by starting from the root node
    in `root`. For example, after entering the tree code into the Python or JavaScript
    interactive shell, run the following:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Our tree traversal code can be written as a recursive function because tree
    data structures have a self-similar structure: a parent node has child nodes,
    and each child node is the parent node of its own children. Tree traversal algorithms
    ensure that your programs can access or modify the data in every node in the tree
    no matter its shape or size.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three questions about recursive algorithms for our tree traversal
    code:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? A leaf node, which has no more children and requires
    no more recursive calls, causing the algorithm to backtrack to a previous parent
    node.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The node to traverse
    to, whose child nodes will be the next nodes to traverse.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? There are no cycles in
    a DAG, so following the descendant nodes will always eventually reach a leaf node.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep in mind that tree data structures that are especially deep will cause a
    stack overflow as the algorithm traverses the deeper nodes. This happens because
    each level deeper into the tree requires yet another function call, and too many
    function calls without returning cause stack overflows. However, it’s unlikely
    for broad, well-balanced trees to be that deep. If every node in a 1,000 level
    deep tree has two children, the tree would have about 2^(1000) nodes. That’s more
    atoms than there are in the universe, and it’s unlikely your tree data structure
    is that big.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 'Trees have three kinds of tree traversal algorithms: preorder, postorder, and
    inorder. We’ll discuss each of these in the next three sections.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: Preorder Tree Traversal
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Preorder tree traversal* algorithms access a node’s data before traversing
    its child nodes. Use a preorder traversal if your algorithm needs to access the
    data in parent nodes before the data in their child nodes. For example, preorder
    traversals are used when you are creating a copy of the tree data structure, as
    you need to create the parent nodes before child nodes in the duplicate tree.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'The following *preorderTraversal.py* program has a `preorderTraverse()` function
    that traverses each child node first, before accessing the node’s data to print
    it to the screen:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The equivalent JavaScript program is in *preorderTraversal.html*:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output of these programs is the node data in preorder order:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: When you look at the tree in [Figure 4-1](#figure4-1), notice that preorder
    traversal order displays the data in left nodes before right nodes, and bottom
    nodes before top nodes.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: All tree traversals begin by passing the root node to the recursive function.
    The function makes a recursive call and passes each of the root node’s children
    as the argument. Since these child nodes have children of their own, the traversal
    continues until a leaf node with no children is reached. At this point, the function
    call simply returns.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: The recursive case occurs if the node has any child nodes ❶, in which case a
    recursive call is made with each of the children as the node argument. Whether
    or not the node has children, the base case always happens at the end of the function
    when it returns ❷.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: Postorder Tree Traversal
  id: totrans-594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Postorder tree traversal* traverses a node’s child nodes before accessing
    the node’s data. For example, this traversal is used when deleting a tree and
    ensuring that no child nodes are “orphaned” by deleting their parent nodes first,
    leaving the child node inaccessible to the root node. The code in the following
    *postorderTraversal.py* program is similar to the preorder traversal code in the
    previous section, except the recursive function call comes before the `print()`
    call:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The *postorderTraversal.html* program has the equivalent JavaScript code:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output of these programs is the node data in postorder order:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The postorder traversal order of the nodes displays the data in left nodes
    before right nodes, and in bottom nodes before top nodes. When we compare the
    `postorderTraverse()` and `preorderTraverse()` functions, we find that the names
    are a bit of a misnomer: *pre* and *post* don’t refer to the order in which nodes
    are visited. The nodes are always traversed in the same order; we go down the
    child nodes first (called a *depth-first search*) as opposed to visiting the nodes
    in each level before going deeper (called a *breadth-first search*). The *pre*
    and *post* refer to *when* the node’s data is accessed: either before or after
    traversing the node’s children.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Inorder Tree Traversal
  id: totrans-604
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Binary trees* are tree data structures with at most two child nodes, often
    called the *left child* and *right child*. An *inorder tree traversal* traverses
    the left child node, then accesses the node’s data, and then traverses the right
    child node. This traversal is used in algorithms that deal with binary search
    trees (which are beyond the scope of this book). The *inorderTraversal.py* program
    contains Python code that performs this kind of traversal:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The *inorderTraversal.html* program contains the equivalent JavaScript code:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output of these programs looks like this:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Inorder traversal typically refers to the traversal of binary trees, although
    processing a node’s data after traversing the first node and before traversing
    the last node would count as inorder traversal for trees of any size.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: Finding Eight-Letter Names in a Tree
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of printing out the data in each node as we traverse them, we can use
    a *depth-first search* to find specific data in a tree data structure. We’ll write
    an algorithm that searches the tree in [Figure 4-4](#figure4-4) for names that
    are exactly eight letters long. This is a rather contrived example, but it shows
    how an algorithm can use tree traversal to retrieve data out of a tree data structure.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagram with the root node “Alice,” which has two child nodes, “Bob”
    and “Caroline.” “Bob” has one child node, “Darya.” “Caroline” has two child nodes,
    “Eve” and “Fred.” “Eve” has two child nodes, “Gonzalo” and “Hadassah.”](image_fi/502024c04/f04004.png)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: The tree that stores names in our *depthFirstSearch.py* and *depthFirstSearch.html*
    programs'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three questions about recursive algorithms for our tree traversal
    code. Their answers are similar to the answers for the tree traversal algorithms:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Either a leaf node causing the algorithm to backtrack,
    or a node containing an eight-letter name.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The node to traverse
    to, whose child nodes will be the next nodes to traverse.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? There are no cycles in
    a DAG, so following the descendant nodes will always eventually reach a leaf node.
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *depthFirstSearch.py* program contains Python code that performs a depth-first
    search with a preorder traversal:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The *depthFirstSearch.html* program contains the equivalent JavaScript program:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output of these programs looks like this:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `find8LetterName()` function operates in the same way as our previous tree
    traversal functions, except instead of printing the node’s data, the function
    checks the name stored in the node and returns the first eight-letter name it
    finds. You can change the preorder traversal to a postorder traversal by commenting
    out the earlier name length comparison and the `Checking if` line ❶ and uncommenting
    the later name length comparison and the `Checking if` line ❷. When you make this
    change, the first eight-letter name the function finds is `Hadassah`:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: While both traversal orders correctly find an eight-letter name, changing the
    order of a tree traversal can alter the behavior of your program.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: Getting the Maximum Tree Depth
  id: totrans-633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An algorithm can determine the deepest branch in a tree by recursively asking
    its child nodes how deep they are. The *depth* of a node is the number of edges
    between it and the root node. The root node itself has a depth of 0, the immediate
    child of the root node has a depth of 1, and so on. You may need this information
    as part of a larger algorithm or to gather information about the general size
    of the tree data structure.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: We can have a function named `getDepth()` take a node for an argument and return
    the depth of its deepest child node. A leaf node (the base case) simply returns
    `0`.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: For example, given the root node of the tree in [Figure 4-1](#figure4-1), we
    could call `getDepth()` and pass it the root node (the `A` node). This would return
    the depth of its children, the `B` and `C` nodes, plus one. The function must
    make a recursive call to `getDepth()` to find out this information. Eventually,
    the `A` node would call `getDepth()` on `C`, which would call it on `E`. When
    `E` calls `getDepth()` with its two children, `G` and `H`, they both return `0`,
    so `getDepth()` called on `E` returns `1`, making `getDepth()` called on `C` return
    `2`, and making `getDepth()` called on `A` (the root node) return `3`. Our tree’s
    greatest depth is three levels.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask our three recursive algorithm questions for the `getDepth()` function:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? A leaf node with no children, which by its nature has
    a depth of one level.
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The node whose greatest
    depth we want to find.
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? A DAG has no cycles,
    so following the descendant nodes will eventually reach a leaf node.
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following *getDepth.py* program contains a recursive `getDepth()` function
    that returns the number of levels contained in the deepest node in the tree:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The *getDepth.html* program contains the JavaScript equivalent:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output of these programs is as follows:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This matches what we see in [Figure 4-2](#figure4-2): the number of levels
    from the root node `A` down to the lowest nodes `G` and `H` is three levels.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: Solving Mazes
  id: totrans-650
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While mazes come in all shapes and sizes, *simply connected mazes*, also called
    *perfect mazes*, contain no loops. A perfect maze has exactly one path between
    any two points, such as the start and exit. These mazes can be represented by
    a DAG.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Figure 4-5](#figure4-5) shows the maze that our maze program solves,
    and [Figure 4-6](#figure4-6) shows the DAG form of it. The capital *S* marks the
    start of the maze, and the capital *E* marks the exit. A few of the intersections
    that have been marked with lowercase letters in the maze correspond to nodes in
    the DAG.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '![Maze with certain intersections labeled with the letters s, d, b, a, c, f,
    e, g, i, j, h, k, n, m, l, and e.](image_fi/502024c04/f04005.png)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: The maze solved by our maze program in this chapter. Some intersections
    have lowercase letters that correspond to nodes in [Figure 4-6](#figure4-6).'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree graph in which every intersection of the maze in Figure 4-5 is represented
    as a node.](image_fi/502024c04/f04006.png)'
  id: totrans-655
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: In this DAG representation of the maze, nodes represent intersections,
    and edges represent the north, south, east, or west path from the intersection.
    Some nodes have lowercase letters to correspond to intersections in [Figure 4-5](#figure4-5).'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: Because of this similarity in structure, we can use a tree traversal algorithm
    to solve the maze. The nodes in this tree graph represent intersections where
    the maze solver could choose one of the north, south, east, or west paths to follow
    to the next intersection. The root node is the start of the maze, and the leaf
    nodes represent dead ends.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive case occurs when the tree traversal algorithm moves from one
    node to the next. If the tree traversal reaches a leaf node (a dead end in the
    maze), the algorithm has reached a base case and must backtrack to an earlier
    node and follow a different path. Once the algorithm reaches the exit node, the
    path it took from the root node represents the maze solution. Let’s ask our three
    recursive algorithm questions about the maze-solving algorithm:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Reaching a dead end or the exit of the maze.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The x, y coordinates,
    along with the maze data and list of already visited x, y coordinates.
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? Like the flood fill algorithm,
    the x, y coordinates keep moving to neighboring coordinates until they eventually
    reach dead ends or the final exit.
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This *mazeSolver.py* program contains the Python code for solving the maze
    stored in the `MAZE` variable:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The *mazeSolver.html* program contains the JavaScript equivalent:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: A lot of this code is not directly related to the recursive maze-solving algorithm.
    The `MAZE` variable stores the maze data as a multiline string with hashtags to
    represent walls, an `S` for the starting point, and an `E` for the exit. This
    string is converted into a list that contains lists of strings, with each string
    representing a single character in the maze. This allows us to access `MAZE[y][x]`
    (note that `y` comes first) to get the character at the x, y coordinate in the
    original `MAZE` string. The `printMaze()` function can accept this list-of-list
    data structure and display the maze on the screen. The `findStart()` function
    accepts this data structure and returns the x, y coordinates of the `S` starting
    point. Feel free to edit the maze string yourself—although remember that, in order
    for the solving algorithm to work, the maze cannot have any loops.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: The recursive algorithm is in the `solveMaze()` function. The arguments to this
    function are the maze data structure, the current x- and y-coordinates, and a
    `visited` list (which is created if none was supplied) ❶. The `visited` list contains
    all the coordinates that have previously been visited so that when the algorithm
    backtracks from a dead end to an earlier intersection, it knows which paths it
    has tried before and can try a different one. The path from the start to the exit
    is marked by replacing the spaces (matching the `EMPTY` constant) in the maze
    data structure with periods (from the `PATH` constant).
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: The maze-solving algorithm is similar to our flood fill program in Chapter 3
    in that it “spreads” to neighboring coordinates, though when it reaches a dead
    end, it backtracks to an earlier intersection. The `solveMaze()` function receives
    the x, y coordinates indicating the algorithm’s current location in the maze.
    If this is the exit, the function returns `True`, causing all the recursive calls
    to also return `True`. The maze data structure remains marked with the solution
    path.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the algorithm marks the current x, y coordinates in the maze data
    structure with a period and adds the coordinates to the `visited` list ❷. Then
    it looks to the x, y coordinates north of the current coordinates to see if that
    point is not off the edge of the map, is either the empty or exit space, and has
    not been visited before. If these conditions are met, the algorithm makes a recursive
    call to `solveMaze()` with the northern coordinates. If these conditions aren’t
    met or the recursive call to `solveMaze()` returns `False`, the algorithm continues
    on to check the south, east, and west coordinates. Like the flood fill algorithm,
    recursive calls are made with the neighboring coordinates.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: To get a better idea of how this algorithm works, uncomment the two `printMaze(MAZE)`
    calls ❸ ❹ inside the `solveMaze()` function. These will display the maze data
    structure as it attempts new paths, reaches dead ends, backtracks, and tries different
    paths.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-673
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter explored several algorithms that make use of tree data structures
    and backtracking, which are features of a problem that is suitable for solving
    with recursive algorithms. We covered tree data structures, which are composed
    of nodes that contain data and edges that relate nodes together in parent–child
    relationships. In particular, we examined a specific kind of tree called a directed
    acyclic graph (DAG) that is often used in recursive algorithms. A recursive function
    call is analogous to traversing to a child node in a tree, while returning from
    a recursive function call is analogous to backtracking to a previous parent node.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: While recursion is overused for simple programming problems, it is well matched
    for problems that involve tree-like structures and backtracking. Using these ideas
    of tree-like structures, we wrote several algorithms for traversing, searching,
    and determining the depth of tree structures. We also showed that a simply connected
    maze has a tree-like structure, and employed recursion and backtracking to solve
    a maze.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is far more to trees and tree traversal than the brief description of
    DAGs presented in this chapter. The Wikipedia articles at [https://en.wikipedia.org/wiki/Tree_(data_structure)](https://en.wikipedia.org/wiki/Tree_(data_structure))
    and [https://en.wikipedia.org/wiki/Tree_traversal](https://en.wikipedia.org/wiki/Tree_traversal)
    provide additional context for these concepts, which are often used in computer
    science.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: The Computerphile YouTube channel also has a video titled “Maze Solving” at
    [https://youtu.be/rop0W4QDOUI](https://youtu.be/rop0W4QDOUI) that discusses these
    concepts. V. Anton Spraul, author of *Think Like a Programmer* (No Starch Press,
    2012), also has a video on maze solving titled “Backtracking” at [https://youtu.be/gBC_Fd8EE8A](https://youtu.be/gBC_Fd8EE8A).
    The freeCodeCamp organization ([https://freeCodeCamp.org](https://freeCodeCamp.org))
    has a video series on backtracking algorithms at [https://youtu.be/A80YzvNwqXA](https://youtu.be/A80YzvNwqXA).
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: In addition to maze solving, the recursive backtracker algorithm uses recursion
    to generate mazes. You can find out more about this and other maze-generating
    algorithms at [https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker](https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker).
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: What are nodes and edges?
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are root and leaf nodes?
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three tree traversal orders?
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does *DAG* stand for?
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a cycle, and do DAGs have cycles?
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a binary tree?
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the child nodes in a binary tree called?
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a parent node has an edge to a child node, and the child node has an edge
    back to the parent node, is this graph considered a DAG?
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is backtracking in a tree traversal algorithm?
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the following tree traversal problems, you can use the Python/JavaScript
    code in “A Tree Data Structure in Python and JavaScript” in Chapter 4 for your
    tree and the multiline `MAZE` string from the *mazeSolver.py* and *mazeSolver.html*
    programs for the maze data.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer the three questions about recursive solutions for each of the recursive
    algorithms presented in this chapter:'
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base case?
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call?
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case?
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then re-create the recursive algorithms from this chapter without looking at
    the original code.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Practice Projects
  id: totrans-697
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For practice, write a function for each of the following tasks:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: Create a reverse-inorder search, one that performs an inorder traversal but
    traverses the right child node before the left child node.
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that, given a root node as an argument, proceeds to make the
    tree one level deeper by adding one child node to each leaf node in the original
    tree. This function will need to perform a tree traversal, detect when it has
    reached a leaf node, and then add one and only one child node to the leaf node.
    Be sure not to go on and add a child node to this new leaf node, as that will
    eventually cause a stack overflow.
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '5'
  id: totrans-701
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Divide-and-Conquer Algorithms
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
- en: '*Divide-and-conquer algorithms*are those that split large problems into smaller
    subproblems, then divide those subproblems into ones that are smaller yet, until
    they become trivial to conquer. This approach makes recursion an ideal technique
    to use: the recursive case divides the problem into self-similar subproblems,
    and the base case occurs when the subproblem has been reduced to a trivial size.
    One benefit of this approach is that these problems can be worked on in parallel,
    allowing multiple central processing unit (CPU) cores or computers to work on
    them.'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at some common algorithms that use recursion to
    divide and conquer, such as binary search, quicksort, and merge sort. We’ll also
    reexamine summing an array of integers, this time with a divide-and-conquer approach.
    Finally, we’ll take a look at the more esoteric Karatsuba multiplication algorithm,
    developed in 1960, that laid the basis for computer hardware’s fast integer multiplication.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary Search: Finding a Book in an Alphabetized Bookshelf'
  id: totrans-706
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say you have a bookshelf of 100 books. You can’t remember which books
    you have or their exact locations on the shelf, but you do know that they are
    sorted alphabetically by title. To find your book *Zebras: The Complete Guide*,
    you wouldn’t start at the beginning of the bookshelf, where *Aaron Burr Biography*
    is, but rather toward the end of the bookshelf. Your zebra book wouldn’t be the
    very last book on the shelf if you also had books on zephyrs, zoos, and zygotes,
    but it would be close. Thus, you can use the facts that the books are in alphabetical
    order and that *Z* is the last letter of the alphabet as *heuristics*, or approximate
    clues, to look toward the end of the shelf rather than the beginning.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '*Binary search* is a technique for locating a target item in a sorted list
    by repeatedly determining which half of the list the item is in. The most impartial
    way to search the bookshelf is to start with a book in the middle, and then ascertain
    if the target book you’re looking for is in the left half or the right half.'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then repeat this process, as shown in [Figure 5-1](#figure5-1): look
    at the book in the middle of your chosen half and then determine whether your
    target book is in the left-side quarter or the right-side quarter. You can do
    this until you either find the book, or find the place where the book should be
    but isn’t and declare that the book doesn’t exist on the shelf.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing of a bookshelf with labels separating the books into two sections,
    one of which is highlighted. In a second bookshelf drawing, that highlighted portion
    is further split in half. In a third bookshelf drawing, only one book of the previously
    selected portion is highlighted.](image_fi/502024c05/f05001.png)'
  id: totrans-710
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: A binary search repeatedly determines which half of a range contains
    your target item in a sorted array of items.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: This process scales efficiently; doubling the number of books to search adds
    only one step to the search process. A linear search of a shelf with 50 books
    takes 50 steps, and a linear search of a shelf with 100 books takes 100 steps.
    But a binary search of a shelf with 50 books takes only 6 steps, and a shelf with
    100 books takes only 7 steps.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursion questions about our binary search implementation:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Searching a range of items that is only one item in length.
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The indices of the left
    and right ends of the range in the list we are searching.
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The range halves in size
    for each recursive call, so it eventually becomes one item long.
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Examine the following `binarySearch()` function in our *binarySearch.py* program,
    which locates a value, `needle`, in a sorted list of values, `haystack`:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The *binarySearch.html* program has this JavaScript equivalent:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'When you run these programs, the list `[1, 4, 8, 11, 13, 16, 19, 19]` is searched
    for `13`, and the output looks like this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The target value `13` is indeed at index `4` in that list.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: The code calculates the middle index (stored in `mid`) of the range defined
    by the `left` and `right` indices. At first, this range is the entire length of
    the items list. If the value at the `mid` index is the same as `needle`, then
    `mid` is returned. Otherwise, we need to figure out whether our target value is
    in the left half of the range (in which case, the new range to search is `left`
    to `mid - 1`) or in the right half (in which case, the new range to search is
    `mid + 1` to `end`).
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have a function that can search this new range: `binarySearch()`
    itself! A recursive call is made on the new range. If we ever get to the point
    where the right end of the search range comes before the left, we know that our
    search range has shrunk down to zero and our target value isn’t to be found.'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the code performs no actions after the recursive call returns; it
    immediately returns the return value of the recursive function call. This feature
    means that we could implement tail call optimization for this recursive algorithm,
    a practice we explain in Chapter 8. But also, it means that binary search can
    easily be implemented as an iterative algorithm that doesn’t use recursive function
    calls. This book’s downloadable resources at [https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion)
    include the source code for an iterative binary search for you to compare with
    the recursive binary search.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 'Quicksort: Splitting an Unsorted Pile of Books into Sorted Piles'
  id: totrans-729
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that `binarySearch()`’s speed advantage comes from the fact that the
    values in items are sorted. If the values are out of order, the algorithm won’t
    work. Enter *quicksort*, a recursive sorting algorithm developed by computer scientist
    Tony Hoare in 1959.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: 'Quicksort uses a divide-and-conquer technique called *partitioning*. Think
    of partitioning this way: imagine you have a large pile of unalphabetized books.
    Grabbing one book and placing it in the right spot on the shelf means you’ll spend
    a lot of time rearranging the bookshelf as it gets full. It would help if you
    first turned the pile of books into two piles: an *A* to *M* pile and an *N* to
    *Z* pile. (In this example, *M* would be our *pivot*.)'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: 'You haven’t sorted the pile, but you have *partitioned* it. And partitioning
    is easy: the book doesn’t have to go into the correct place in one of the two
    piles, it just has to go into the correct pile. Then you can further partition
    these two piles into four piles: *A* to *G*, *H* to *M*, *N* to *T*, and *U* to
    *Z*. This is shown in [Figure 5-2](#figure5-2). If you keep partitioning, you
    end up with piles that contain one book each (the base case), and the piles are
    now in sorted order. This means the books are now in sorted order as well. This
    repeated partitioning is how quicksort works.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: For the first partitioning of *A* to *Z*, we select *M* as the pivot value because
    it’s the middle letter between *A* and *Z*. However, if our collection of books
    consisted of one book about Aaron Burr and 99 books about zebras, zephyrs, zoos,
    zygotes, and other *Z* topics, our two partitioned piles would be heavily unbalanced.
    We would have the single Aaron Burr book in the *A* to *M* pile and every other
    book in the *M* to *Z* pile. The quicksort algorithm works fastest when the partitions
    are evenly balanced, so selecting a good pivot value at each partition step is
    important.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing of several piles of books in a tree-like structure. Shows one pile
    of books, A–Z, split into two piles, A–M and N–Z. A–M is further split into A–G
    and H–M. N–Z is further split into N–T and U–Z.](image_fi/502024c05/f05002.png)'
  id: totrans-734
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: Quicksort works by repeatedly partitioning items into two sets.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: However, if you don’t know anything about the data you’re sorting, it’s impossible
    to select an ideal pivot. This is why the generic quicksort algorithm simply uses
    the last value in the range for the pivot value.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, each call to `quicksort()` is given an array of items
    to sort. It is also given `left` and `right` arguments specifying the range of
    indices in that array to sort, similar to `binarySearch()`’s left and right arguments.
    The algorithm selects a pivot value to compare with the other values in the range,
    then places the values to either the left side of the range (if they’re less than
    the pivot value) or the right side (if they’re greater than the pivot value).
    This is the partition step. Next, the `quicksort()` function is recursively called
    on these two, smaller ranges until a range has been reduced to zero. The list
    becomes more and more sorted as the recursive calls are made, until finally the
    entire list is in the correct order.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: Note that the algorithm modifies the array in place. See “Modifying a List or
    Array in Place” in Chapter 4 for details. Thus, the `quicksort()` function doesn’t
    return a sorted array. The base case merely returns to stop producing more recursive
    calls.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursion questions about our binary search implementation:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Being given a range to sort that contains zero or one
    item and that is already in sorted order.
  id: totrans-740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The indices of the left
    and right ends of the range in the list we are sorting.
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The range halves in size
    for each recursive call, so it eventually becomes empty.
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following `quicksort()` function in the *quicksort.py* Python program sorts
    the values in the items list into ascending order:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The *quicksort.html* program contains the JavaScript equivalent:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This code is similar to the code in the binary search algorithm. As defaults,
    we set the `left` and `right` ends of the range within the `items` array to the
    beginning and end of the entire array. If the algorithm reaches the base case
    of the `right` end at or before the `left` end (a range of one or zero items),
    the sorting is finished ❶.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: 'In each call to `quicksort()`, we partition the items in the current range
    (defined by the indices in `left` and `right`), and then swap them around so that
    the items less than the pivot value end up on the left side of the range and the
    items greater than the pivot value end up on the right side of the range. For
    example, if `42` is the pivot value in the array `[81, 48, 94, 87, 83, 14, 6,
    42]`, a partitioned array would be `[14, 6, 42, 81, 48, 94, 87, 83]`. Note that
    a partitioned array is not the same thing as a sorted one: although the two items
    to the left of `42` are less than `42`, and the five items to the right of `42`
    are greater than `42`, the items are not in sorted order.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of the `quicksort()` function is the partitioning step. To get an idea
    of how partitioning works, imagine an index `j` that begins at the left end of
    the range and moves to the right end ❷. We compare the item at index `j` with
    the pivot value and then move right to compare the next item. The pivot value
    can be arbitrarily chosen from any value in the range, but we’ll always use the
    value at the right end of the range.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a second index `i` that also begins at the left end. If the item at
    index `j` is less than or equal to the pivot, the items at indices `i` and `j`
    are swapped ❸ and `i` is increased to the next index. So while `j` always increases
    (that is, moves right) after each comparison with the pivot value, `i` increases
    only if the item at index `j` is less than or equal to the pivot.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: The names `i` and `j` are commonly used for variables that hold array indices.
    Someone else’s `quicksort()` implementation may instead use `j` and `i`, or even
    completely different variables. The important thing to remember is that two variables
    store indices and behave as shown here.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s work through the first partitioning of the array `[0,
    7, 6, 3, 1, 2, 5, 4]`, and the range defined by `left` of `0` and `right` of `7`
    to cover the full size of the array. The `pivot` will be the value at the `right`
    end, `4`. The `i` and `j` index begin at index `0`, the left end of the range.
    At each step, index `j` always moves to the right. Index `i` moves only if the
    value at index `j` is less than or equal to the pivot value. The `items` array,
    the `i` index, and the `j` index begin as follows:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The value at index `j` (which is `0`) is less than or equal to the pivot value
    (which is `4`), so swap the values at `i` and `j`. This results in no actual change
    since `i` and `j` are the same index. Also, increase `i` so that it moves to the
    right. The `j` index increases for every comparison with the pivot value. The
    state of the variables now looks like this:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The value at index `j` (which is `7`) is not less than or equal to the pivot
    value (which is `4`), so don’t swap the values. Remember, `j` always increases,
    but `i` increases only after a swap is performed—so `i` is always either at or
    to the left of `j`. The state of the variables now looks like this:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The value at index `j` (which is `6`) is not less than or equal to the pivot
    value (which is `4`), so don’t swap the values. The state of the variables now
    looks like this:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The value at index `j` (which is `3`) is less than or equal to the pivot value
    (which is `4`), so swap the values at `i` and `j`. The `7` and `3` swap positions.
    Also, increase `i` so that it moves to the right. The state of the variables now
    looks like this:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The value at index `j` (which is `1`) is less than or equal to the pivot value
    (which is `4`), so swap the values at `i` and `j`. The `6` and `1` swap positions.
    Also, increase `i` so that it moves to the right. The state of the variables now
    looks like this:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The value at index `j` (which is `2`) is less than or equal to the pivot value
    (which is `4`), so swap the values at `i` and `j`. The `7` and `2` swap positions.
    Also, increase `i` so that it moves to the right. The state of the variables now
    looks like this:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The value at index `j` (which is `6`) is not less than or equal to the pivot
    value (which is `4`), so don’t swap the values. The state of the variables now
    looks like this:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We’ve reached the end of the partitioning. The index `j` is at the pivot value
    (which is always the rightmost value in the range), so let’s swap `i` and `j`
    one last time to make sure the pivot is not on the right half of the partition.
    The `6` and `4` swap positions. The state of the variables now looks like this:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Notice what is happening with the `i` index: this index will always receive
    the values smaller than the pivot value as a result of swapping; then the `i`
    index moves right to receive future smaller-than-the-pivot values. As a result,
    everything to the left of the `i` index is smaller than or equal to the pivot,
    and everything to the right of the `i` index is greater than the pivot.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: The entire process repeats as we recursively call `quicksort()` on the left
    and right partitions. When we partition these two halves (and then partition the
    four halves of these two halves with more recursive `quicksort()` calls, and so
    on), the entire array ends up sorted.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run these programs, the output shows the process of sorting the `[0,
    7, 6, 3, 1, 2, 5, 4]` list. The rows of periods are meant to help you line up
    the output when writing the code:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Quicksort is a commonly used sorting algorithm because it is straightforward
    to implement and, well, quick. The other commonly used sorting algorithm, merge
    sort, is also fast and uses recursion. We cover it next.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: 'Merge Sort: Merging Small Piles of Playing Cards into Larger Sorted Piles'
  id: totrans-775
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Computer scientist John von Neumann developed *merge sort* in 1945\. It uses
    a divide-merge approach: each recursive call to `mergeSort()` divides the unsorted
    list into halves until they’ve been whittled down into lists of lengths of zero
    or one. Then, as the recursive calls return, these smaller lists are merged together
    into sorted order. When the last recursive call has returned, the entire list
    will have been sorted.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: For example, the divide step takes a list, such as `[2, 9, 8, 5, 3, 4, 7, 6]`,
    and splits it into two lists, like `[2, 9, 8, 5]` and `[3, 4, 7, 6]`, to pass
    to two recursive function calls. At the base case, the lists have been divided
    into lists of zero or one item. A list with nothing or one item is naturally sorted.
    After the recursive calls return, the code merges these small, sorted lists together
    into larger sorted lists until finally the entire list is sorted. [Figure 5-3](#figure5-3)
    shows an example using merge sort on playing cards.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of playing cards being arranged according to a series of steps. The
    first set of steps divides the playing cards into smaller groups, and the second
    set of steps merges these groups until the cards are all together once more.](image_fi/502024c05/f05003.png)'
  id: totrans-778
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: The divide and merge phases of merge sort'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, at the end of the division phase, we have eight separate lists
    of single numbers: `[2]`, `[9]`, `[8]`, `[5]`, `[3]`, `[4]`, `[7]`, `[6]`. A list
    of just one number is naturally in sorted order. Merging two sorted lists into
    a larger sorted list involves looking at the start of both smaller lists and appending
    the smaller value to the larger list. [Figure 5-4](#figure5-4) shows an example
    of merging `[2, 9]` and `[5, 8]`. This is repeatedly done in the merge phase until
    the end result is that the original `mergeSort()` call returns the full list in
    sorted order.'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram representing a series of steps applied to two pairs of playing cards,
    the 2 and 9 of spades and the 5 and 8 of spades. In the first step, because 2
    is smaller than 5, the 2 of spades is selected. In the second step, because 5
    is smaller than 9, the 5 of spades is placed on top of the 2 of spades. In the
    third step, because 8 is smaller than 9, the 8 of spades is placed on top of the
    5 of spades. In the fourth step, the 9 of spades is placed on top of the 8 of
    spades.](image_fi/502024c05/f05004.png)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: The merge step compares the two values at the start of the smaller
    sorted lists and moves them to the larger sorted list. Merging four cards requires
    only four steps.'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask our three recursive algorithm questions about the merge sort algorithm:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Being given a list to sort that has zero or one item
    in it, which is already in sorted order.
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? Lists made from the
    left and right halves of the original list to sort.
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The lists passed to the
    recursive call are half the size of the original list, so they eventually become
    a list of zero or one item.
  id: totrans-786
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following `mergeSort()` function in the *mergeSort.py* Python program sorts
    the values in the items list into ascending order:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The *mergeSort.html* program contains the equivalent JavaScript program:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The `mergeSort()` function (and all the recursive calls to the `mergeSort()`
    function) takes an unsorted list and returns a sorted list. The first step in
    this function is to check for the base case of a list containing only zero or
    one item ❶. This list is already sorted, so the function returns the list as is.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the function determines the middle index of the list ❷ so that we
    know where to split it into the left- and right-half lists to pass to two recursive
    function calls ❸. The recursive function calls return sorted lists, which we store
    in the left and right variables.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to merge these two sorted half lists into one sorted full list
    named `sortedResult`. We’ll maintain two indices for the `left` and `right` lists
    named `iLeft` and `iRight`. Inside a loop, the smaller of the two values ❹ is
    appended to `sortedResult`, and its respective index variable (either `iLeft`
    or `iRight`) is incremented. If either `iLeft` or `iRight` reaches the end of
    its list, the remaining items in the other half’s list are appended to `sortedResult`.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: Let’s follow an example of the merging step if the recursive calls have returned
    `[2, 9]` for `left` and `[5, 8]` for `right`. Since these lists were returned
    from `mergeSort()` calls, we can always assume they are sorted. We must merge
    them into a single sorted list in `sortedResult` for the current `mergeSort()`
    call to return to its caller.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: 'The `iLeft` and `iRight` indices begin at `0`. We compare the value at `left[iLeft]`
    (which is `2`) and `right[iRight]` (which is `5`) to find the smaller one:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Since `left[iLeft]`’s value, `2`, is the smaller of the values, we append it
    to `sortedResult` and increase `iLeft` from `0` to `1`. The state of the variables
    is now as follows:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Comparing `left[iLeft]` and `right[iRight]` again, we find that of `9` and
    `5`, `right[iRight]`’s `5` is smaller. The code appends the `5` to `sortedResult`
    and increases `iRight` from `0` to `1`. The state of the variables is now the
    following:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Comparing `left[iLeft]` and `right[iRight]` again, we find that, of `9` and
    `8`, `right[iRight]`’s `8` is smaller. The code appends the `8` to `sortedResult`
    and increases `iRight` from `0` to `1`. Here’s the state of the variables now:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Because `iRight` is now `2` and equal to the length of the `right` list, the
    remaining items in `left` from the `iLeft` index to the end are appended to `sortedResult`,
    as no more items remain in `right` to compare them to. This leaves `sortedResult`
    as `[2, 5, 8, 9]`, the sorted list it needs to return. This merging step is performed
    for every call to `mergeSort()` to produce the final sorted list.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the *mergeSort.py* and *mergeSort.html* programs, the output shows
    the process of sorting the `[2, 9, 8, 5, 3, 4, 7, 6]` list:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: As you can see from the output, the function divides the `[2, 9, 8, 5, 3, 4,
    7, 6]` list into `[2, 9, 8, 5]` and `[3, 4, 7, 6]` and passes these to recursive
    `mergeSort()` calls. The first list is further split into `[2, 9]` and `[8, 5]`.
    That `[2, 9]` list is split into `[2]` and `[9]`. These single-value lists cannot
    be divided anymore, so we have reached our base case. These lists are merged back
    into sorted order as `[2, 9]`. The function divides the `[8, 5]` list into `[8]`
    and `[5]`, reaches the base case, and then merges back into `[5, 8]`.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: The `[2, 9]` and `[5, 8]` lists are individually in sorted order. Remember,
    `mergeSort()` doesn’t simply *concatenate* the lists into `[2, 9, 5, 8]`, which
    would not be in sorted order. Rather, the function *merges* them into the sorted
    list `[2, 5, 8, 9]`. By the time the original `mergeSort()` call returns, the
    full list it returns is completely sorted.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: Summing an Array of Integers
  id: totrans-808
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already covered summing an array of integers in Chapter 3 with the head-tail
    technique. In this chapter, we’ll use a divide-and-conquer strategy. Since the
    associative property of addition means that adding 1 + 2 + 3 + 4 is the same as
    adding the sums of 1 + 2 and 3 + 4, we can divide a large array of numbers to
    sum into two smaller arrays of numbers to sum.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: The benefit is that for larger sets of data to process, we could farm out the
    subproblems to different computers and have them all work together in parallel.
    There’s no need to wait for the first half of the array to be summed before another
    computer can start summing the second half. This is a large advantage of the divide-and-conquer
    technique, as CPUs aren’t getting much faster but we can have multiple CPUs work
    simultaneously.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three questions about recursive algorithms for our summation
    function:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Either an array containing zero numbers (where we return
    `0`) or an array containing one number (where we return the number).
  id: totrans-812
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? Either the left half
    or the right half of the array of numbers.
  id: totrans-813
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The size of the array
    of numbers is halved each time, eventually becoming an array containing zero or
    one number.
  id: totrans-814
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *sumDivConq.py* Python program implements the divide-and-conquer strategy
    for adding numbers in the `sumDivConq()` function:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The *sumDivConq.html* program contains the JavaScript equivalent:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The output of this program is:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The `sumDivConq()` function first checks the `numbers` array for having either
    zero or one number in it. These trivial base cases are easy to sum since they
    require no addition: return either `0` ❶ or the lone number in the array ❷. Everything
    else is a recursive case; the middle index of the array is calculated ❸ so that
    separate recursive calls with the left half and right half of the numbers array
    are made. The sum of these two return values becomes the return value for the
    current `sumDivConq()` call ❹.'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: Because of the associative nature of addition, there’s no reason an array of
    numbers must be added sequentially by a single computer. Our program carries out
    all operations on the same computer, but for large arrays or calculations more
    complicated than addition, our program could send the halves to other computers
    to complete. The problem can be divided into similar subproblems, which is a huge
    hint that a recursive approach can be taken.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: Karatsuba Multiplication
  id: totrans-825
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `*` operator makes multiplication easy to do in high-level programming
    languages such as Python and JavaScript. But low-level hardware needs a way to
    perform multiplication using more primitive operations. We could multiply two
    integers using only addition with a loop, such as in the following Python code
    to multiply `5678 * 1234`:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: However, this code doesn’t scale efficiently for large integers. *Karatsuba
    multiplication* is a fast, recursive algorithm discovered in 1960 by Anatoly Karatsuba
    that can multiply integers using addition, subtraction, and a precomputed multiplication
    table of all products from single-digit numbers. This multiplication table, shown
    in [Figure 5-5](#figure5-5), is called a *lookup table*.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: Our algorithm won’t need to multiply single-digit numbers because it can just
    look them up in the table. By using memory to store precomputed values, we increase
    memory usage to decrease CPU runtime.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: '![A multiplication table of the digits 0 through 9.](image_fi/502024c05/F05005.png)'
  id: totrans-830
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: A lookup table, such as this table of products of all single-digit
    numbers, saves our program from repeat calculations as the computer stores the
    precomputed values in memory for later retrieval.'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: We’ll implement Karatsuba multiplication in a high-level language like Python
    or JavaScript as though the `*` operator didn’t already exist. Our `karatsuba()`
    function accepts two integer arguments, `x` and `y`, to multiply. The Karatsuba
    algorithm has five steps, and the first three involve making recursive calls to
    `karatsuba()` with arguments that are smaller, broken-down integers derived from
    `x` and `y`. The base case occurs when the `x` and `y` arguments are both single-digit
    numbers, in which case the product can be found in the precomputed lookup table.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define four more variables: `a` and `b` are each half of the digits
    of `x`, and `c` and `d` are each half of the digits of `y`, as shown in [Figure
    5-6](#figure5-6). For example, if `x` and `y` are `5678` and `1234`, respectively,
    then `a` is `56`, `b` is `78`, `c` is `12`, and `d` is `34`.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing x = 5678, with arrows leading to a = 56 and b = 78, and y
    = 1234, with arrows leading to c = 12 and d = 34.](image_fi/502024c05/F05006.png)'
  id: totrans-834
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: The integers to multiply, `x` and `y`, are divided into halves
    `a`, `b`, `c`, and `d`.'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the five steps of the Karatsuba algorithm:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: Multiply `a` and `c` either from the multiplication lookup table or from a recursive
    call to `karatsuba()`.
  id: totrans-837
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply `b` and `d` either from the multiplication lookup table or from a recursive
    call to `karatsuba()`.
  id: totrans-838
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply `a + c` and `b + d` either from the multiplication lookup table or
    from a recursive call to `karatsuba()`.
  id: totrans-839
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate step 3 – step 2 – step 1.
  id: totrans-840
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pad the step 1 and step 4 results with zeros; then add them to step 2.
  id: totrans-841
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of step 5 is the product of `x` and `y`. The specifics of how to
    pad the step 1 and step 4 results with zeros are explained later in this section.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask our three recursive algorithm questions about the `karatsuba()` function:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Multiplying single-digit numbers, which can be done with
    a precomputed lookup table.
  id: totrans-844
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The `a`, `b`, `c`, and
    `d` values derived from the `x` and `y` arguments.
  id: totrans-845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? Since `a`, `b`, `c`,
    and `d` are each half of the digits of `x` and `y` and themselves are used for
    the next recursive call’s `x` and `y` arguments, the recursive call’s arguments
    become closer and closer to the single-digit numbers the base case requires.
  id: totrans-846
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our Python implementation for Karatsuba multiplication is in the *karatsubaMultiplication.py*
    program:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The JavaScript equivalent is in *karatsubaMultiplication.html*:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'When you run this code, the output looks like this:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The first part of this program happens before `karatsuba()` is called. Our program
    needs to create the multiplication lookup table in the `MULT_TABLE` variable ❶.
    Normally, lookup tables are hardcoded directly in the source code, from `MULT_TABLE[[0,
    0]] = 0` to `MULT_TABLE[[9, 9]] = 81`. But to reduce the amount of typing, we’ll
    use nested `for` loops to generate each product. Accessing `MULT_TABLE[[m, n]]`
    gives us the product of integers `m` and `n`.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: Our `karatsuba()` function also relies on a helper function named `padZeros()`,
    which pads a string of digits with additional zeros on the left or right side
    of the string. This padding is done in the fifth step of the Karatsuba algorithm.
    For example, `padZeros("42", 3, "left")` returns the string `00042`, while `padZeros("99",
    1, "right")` returns the string `990`.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: The `karatsuba()` function itself first checks for the base case, where `x`
    and `y` are single-digit numbers. These can be multiplied using the lookup table,
    and their product is immediately returned. Everything else is a recursive case.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: We need to convert the `x` and `y` integers into strings and adjust them so
    that they contain the same number of digits. If one of these numbers is shorter
    than the other, zeros are padded to the left side. For example, if `x` is `13`
    and `y` is `2468`, our function calls `padZeros()` so that `x` can be replaced
    with `0013`. This is required because we then create the `a`, `b`, `c`, and `d`
    variables to each contain one-half of the digits of `x` and `y` ❷. The `a` and
    `c` variables must have the same number of digits for the Karatsuba algorithm
    to work, as do the `b` and `d` variables.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we use division and rounding down to calculate how much is half of
    the digits of `x` ❸. These mathematical operations are as complicated as multiplication
    and might not be available to the low-level hardware we are programming the Karatsuba
    algorithm for. In a real implementation, we could use another lookup table for
    these values: `HALF_TABLE = [0, 0, 1, 1, 2, 2, 3, 3...]`, and so on. Looking up
    `HALF_TABLE[n]` would evaluate to half of `n`, rounded down. An array of a mere
    100 items would be sufficient for all but the most astronomical numbers and save
    our program from division and rounding. But our programs are for demonstration,
    so we’ll just use the `/` operator and built-in rounding functions.'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: Once these variables are set up correctly, we can begin making the recursive
    function calls ❹. The first three steps involve recursive calls with arguments
    `a` and `b`, `c` and `d`, and finally `a + b` and `c + d`. The fourth step subtracts
    the results of the first three steps from each other ❺. The fifth step pads the
    results of the first and fourth steps with zeros on the right side, then adds
    them to the results of the second step ❻.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: The Algebra Behind the Karatsuba Algorithm
  id: totrans-859
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These steps may seem like magic, so let’s dive into the algebra that shows why
    they work. Let’s use 1,357 for *x* and 2,468 for *y* as the integers we want to
    multiply. Let’s also consider a new variable, *n*, for the number of digits in
    *x* or *y*. Since *a* is 13 and *b* is 57, we can calculate the original *x* as
    10^(*n*)^(/2) × *a* + *b*, which is 10² × 13 + 57 or 1,300 + 57, or 1,357\. Similarly,
    *y* is the same as 10^(*n*)^(/2) × *c* + *d*.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: This means that the product of *x* × *y* = (10^(*n*)^(/2) × *a* + *b*) × (10^(*n*)^(/2)
    × *c* + *d*). Doing a bit of algebra, we can rewrite this equation as *x* × *y*
    = 10*n* × *ac* + 10^(*n*)^(/2) × (*ad* + *bc*) + *bd*. With our example numbers,
    this means 1,357 × 2,468 = 10,000 × (13 × 24) + 100 × (13 × 68 + 57 × 24) + (57
    × 68). Both sides of this equation evaluate to 3,349,076.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve broken the multiplication of *xy* into the multiplications of *ac*, *ad*,
    *bc*, and *bd*. This forms the basis of our recursive function: we’ve defined
    the multiplication of *x* and *y* by using multiplication of smaller numbers (remember,
    *a*, *b*, *c*, and *d* are half the digits of *x* or *y*) that approach the base
    case of multiplying single-digit numbers. And we can perform single-digit multiplication
    with a lookup table rather than multiplying.'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: So we need to recursively compute *ac* (the first step of the Karatsuba algorithm)
    and *bd* (the second step). We also need to calculate (*a* + *b*)(*c* + *d*) for
    the third step, which we can rewrite as *ac* + *ad* + *bc* + *bd*. We already
    have *ac* and *bd* from the first two steps, so subtracting those gives us *ad*
    + *bc*. This means we need only one multiplication (and one recursive call) to
    calculate (*a* + *b*)(*c* + *d*) instead of two to calculate *ad* + *bc*. And
    *ad* + *bc* is needed for the 10*n*^(/2) × (*ad* + *bc*) part of our original
    equation.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying by the 10*n* and 10^(*n*)^(/2) powers of 10 can be done by padding
    zero digits: for example, 10,000 × 123 is 1,230,000\. So, there’s no need to make
    recursive calls for those multiplications. In the end, multiplying *x* × *y* can
    be broken into multiplying three smaller products with three recursive calls:
    `karatsuba(a, c)`, `karatsuba(b, d)`, and `karatsuba((a + b), (c + d))`.'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: With some careful study of this section, you can understand the algebra behind
    the Karatsuba algorithm. What I can’t understand is how Anatoly Karatsuba was
    clever enough to devise this algorithm in less than a week as a 23-year-old student
    in the first place.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-866
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dividing problems into smaller, self-similar problems is at the heart of recursion,
    making these divide-and-conquer algorithms especially suited for recursive techniques.
    In this chapter, we created a divide-and-conquer version of Chapter 3’s program
    for summing numbers in an array. One benefit of this version is that upon dividing
    a problem into multiple subproblems, the subproblems can be farmed out to other
    computers to work on in parallel.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: A binary search algorithm searches a sorted array by repeatedly narrowing the
    range to search in half. While a linear search starts searching at the beginning
    and searches the entire array, a binary search takes advantage of the array’s
    sorted order to home in on the item it is looking for. The performance improvement
    is so great that it may be worthwhile to sort an unsorted array in order to enable
    a binary search on its items.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered two popular sorting algorithms in this chapter: quicksort and merge
    sort. Quicksort divides an array into two partitions based on a pivot value. The
    algorithm then recursively partitions these two partitions, repeating the process
    until the partitions are the size of a single item. At this point, the partitions,
    and the items in them, are in sorted order. Merge sort takes an opposite approach.
    The algorithm splits the array into smaller arrays first, and then merges the
    smaller arrays into sorted order afterward.'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered Karatsuba multiplication, a recursive algorithm for performing
    integer multiplication when the `*` multiplication operator isn’t available. This
    comes up in low-level hardware programming that doesn’t offer a built-in multiplication
    instruction. The Karatsuba algorithm breaks down multiplying two integers into
    three multiplications of smaller integers. To multiply single-digit numbers for
    the base case, the algorithm stores every product from 0 × 0 to 9 × 9 in a lookup
    table.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: The algorithms in this chapter are part of many data structure and algorithm
    courses that freshman computer science students take. In the next chapter, we’ll
    continue to look at other algorithms at the heart of computing with algorithms
    that calculate permutations and combinations.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-872
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Computerphile channel on YouTube has videos on quicksort at [https://youtu.be/XE4VP_8Y0BU](https://youtu.be/XE4VP_8Y0BU)
    and merge sort at [https://youtu.be/kgBjXUE_Nwc](https://youtu.be/kgBjXUE_Nwc).
    If you want a more comprehensive tutorial, the free “Algorithmic Toolbox” online
    course covers many of the same topics that a freshman data structures and algorithms
    course would cover, including binary search, quicksort, and merge sort. You can
    sign up for this Coursera course at [https://www.coursera.org/learn/algorithmic-toolbox](https://www.coursera.org/learn/algorithmic-toolbox).
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms are often compared to each other in lessons on big O algorithm
    analysis, which you can read about in Chapter 13 of my book *Beyond the Basic
    Stuff with Python* (No Starch Press, 2020). You can read this chapter online at
    [https://inventwithpython.com/beyond](https://inventwithpython.com/beyond). Python
    developer Ned Batchelder describes big O and “how code slows as your data grows”
    in his 2018 PyCon talk of the same name at [https://youtu.be/duvZ-2UK0fc](https://youtu.be/duvZ-2UK0fc).
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: Divide-and-conquer algorithms are useful because they often can be run on multiple
    computers in parallel. Guy Steele Jr. gives a Google TechTalk titled “Four Solutions
    to a Trivial Problem” on this topic at [https://youtu.be/ftcIcn8AmSY](https://youtu.be/ftcIcn8AmSY).
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: Professor Tim Roughgarden produced a video lecture for Stanford University on
    Karatsuba multiplication at [https://youtu.be/JCbZayFr9RE](https://youtu.be/JCbZayFr9RE).
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: To help your understanding of quicksort and merge sort, obtain a pack of playing
    cards or simply write numbers on index cards and practice sorting them by hand
    according to the rules of these two algorithms. This offline approach can help
    you remember the pivot-and-partition of quicksort and the divide-merge of merge
    sort.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  id: totrans-878
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: What is a benefit of the divide-and-conquer summing algorithm in this chapter
    compared to the head-tail summing algorithm in Chapter 3?
  id: totrans-880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a binary search of 50 books on a shelf takes six steps, how many steps would
    it take to search twice as many books?
  id: totrans-881
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a binary search algorithm search an unsorted array?
  id: totrans-882
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is partitioning the same thing as sorting?
  id: totrans-883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens in quicksort’s partition step?
  id: totrans-884
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the pivot value in quicksort?
  id: totrans-885
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base case of quicksort?
  id: totrans-886
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many recursive calls does the `quicksort()` function have?
  id: totrans-887
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the array `[0, 3, 1, 2, 5, 4, 7, 6]` not properly partitioned with a
    pivot value of `4`?
  id: totrans-888
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base case of merge sort?
  id: totrans-889
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many recursive calls does the `mergeSort()` function have?
  id: totrans-890
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the resultant array when the merge sort algorithm sorts the arrays `[12,
    37, 38, 41, 99]` and `[2, 4, 14, 42]`?
  id: totrans-891
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a lookup table?
  id: totrans-892
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Karatsuba algorithm that multiplies integers *x* and *y*, what do the
    *a*, *b*, *c*, and *d* variables store?
  id: totrans-893
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer the three questions about recursive solutions for each of the recursive
    algorithms presented in this chapter:'
  id: totrans-894
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base case?
  id: totrans-895
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call?
  id: totrans-896
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case?
  id: totrans-897
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then re-create the recursive algorithms from this chapter without looking at
    the original code.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: Practice Projects
  id: totrans-899
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For practice, write a function for each of the following tasks:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a version of the `karatsuba()` function that has a multiplication lookup
    table of products from 0 × 0 to 999 × 999 rather than 0 × 0 to 9 × 9\. Get a rough
    estimate of how long it takes to calculate `karatsuba(12345678, 87654321)` 10,000
    times in a loop with this larger lookup table compared to the original lookup
    table. If this still runs too quickly to measure, increase the number of iterations
    to 100,000 or 1,000,000 or more. (Hint: you should delete or comment out the `print()`
    and `document.write()` calls inside the `karatsuba()` function for this timing
    test.)'
  id: totrans-901
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that performs a linear search on a large array of integers
    10,000 times. Get a rough estimate of how long this takes, increasing the number
    of iterations to 100,000 or 1,000,000 if the program executes too quickly. Compare
    this with how long a second function takes to sort the array once before performing
    the same number of binary searches.
  id: totrans-902
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '6'
  id: totrans-903
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Permutations and Combinations
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-905
  prefs: []
  type: TYPE_IMG
- en: Problems involving permutations and combinations are especially suited to recursion.
    These are common in *set theory*, a branch of mathematical logic that deals with
    the selection, arrangement, and manipulation of collections of objects.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with small sets in our short-term memory is simple. We can easily come
    up with every possible order (that is, *permutation*) or combination of a set
    of three or four objects. Ordering and combining items in a larger set requires
    the same process but quickly turns into an impossible task for our human brains.
    At that point, it becomes practical to bring in computers to handle the combinatorial
    explosion that occurs as we add more objects to a set.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: At its heart, calculating permutations and combinations of large groups involves
    calculating permutations and combinations of smaller groups. This makes these
    calculations suitable for recursion. In this chapter, we’ll look at recursive
    algorithms for generating all possible permutations and combinations of characters
    in a string. We’ll expand on this to generate all possible combinations of balanced
    parentheses (orderings of open parentheses correctly matched to closing parentheses).
    And finally, we will calculate the power set of a set—that is, the set of all
    possible subsets of a set.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: Many of the recursive functions in this chapter have an argument named `indent`.
    This isn’t used by the actual recursive algorithms; rather, it is used by their
    debugging output so that you can see which level of recursion produced the output.
    The indentation is increased by one space for each recursive call and rendered
    in the debugging output as periods so that it’s easy to count the level of indentation.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: The Terminology of Set Theory
  id: totrans-910
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter doesn’t cover set theory as completely as a math or computer science
    textbook would. But it covers enough to justify starting with an explanation of
    the discipline’s basic terminology, as doing so will make the rest of this chapter
    easier to understand. A *set* is a collection of unique objects, called *elements*,
    or *members*. For example, the letters *A*, *B*, and *C* form a set of three letters.
    In mathematics (and in Python code syntax), sets are written inside curly braces,
    with the objects separated by commas: {A, B, C}.'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: 'Order doesn’t matter for a set; the set {A, B, C} is the same set as {C, B,
    A}. Sets have distinct elements, meaning there are no duplicates: {A, C, A, B}
    has repeat *A*s and so is not a set.'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: A set is a *subset* of another set if it has only members of the other set.
    For example, {A, C} and {B, C} are both subsets of {A, B, C}, but {A, C, D} is
    not a subset of it. Conversely, {A, B, C} is a *superset* to {A, C} and also to
    {B, C} because it contains all their elements. The *empty set* { } is a set that
    contains no members at all. Empty sets are considered subsets of every possible
    set.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: 'A subset can also include all the elements of the other set. For example, {A,
    B, C} is a subset of {A, B, C}. But a *proper subset*, or *strict subset*, is
    a subset that does not have all the set’s elements. No set is a proper subset
    of itself: so {A, B, C} is a subset but not a proper subset of {A, B, C}. All
    other subsets are proper subsets. [Figure 6-1](#figure6-1) shows a graphical representation
    of the set {A, B, C} and some of its subsets.'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing of nested circles: an outer, dashed-line circle; a circle within
    the dashed circle, containing B; a circle within that circle, containing A and
    C; and a circle within that circle, containing no letters.](image_fi/502024c06/f06001.png)'
  id: totrans-915
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: The set {A, B, C} within the dashed lines and some of its subsets
    {A, B, C}, {A, C}, and { } within the solid lines. The circles represent sets,
    and the letters represent elements.'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: 'A *permutation* of a set is a specific ordering of all elements in the set.
    For example, the set {A, B, C} has six permutations: ABC, ACB, BAC, BCA, CAB,
    and CBA. We call these *permutations* *without* *repetition*, or *permutations*
    *without *replacement*, because each element doesn’t appear in the permutation
    more than once.*'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '*A *combination* is a selection of elements of a set. More formally, a *k-combination*
    is a subset of *k* elements from a set. Unlike permutations, combinations don’t
    have an ordering. For example, the 2-combinations of the set {A, B, C} are {A,
    B}, {A, C}, and {B, C}. The 3-combination of the set {A, B, C} is {A, B, C}.'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: 'The term *n choose k* refers to the number of possible combinations (without
    repetition) of *k* elements that can be selected from a set of *n* elements. (Some
    mathematicians use the term *n choose r*.) This concept has nothing to do with
    the elements themselves, just the number of them. For example, 4 choose 2 is 6,
    because there are six ways to choose two elements from a set of four elements
    like {A, B, C, D}: {A, B}, {A, C}, {A, D}, {B, C}, {B, D}, and {C, D}. Meanwhile,
    3 choose 3 is 1, because there’s only one 3-combination from a set of three elements
    like {A, B, C}; that is, {A, B, C} itself. The formula for calculating *n* choose
    *k* is (*n!*) / (*k*! × (*n* – *k*)!). Recall that *n*! is the notation for factorials:
    5! is 5 × 4 × 3 × 2 × 1.'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: The term *n multichoose k* refers to the number of possible combinations *with
    repetition* of *k* elements that can be selected from a set of *n* elements. Because
    *k*-combinations are sets and sets do not have duplicate elements, a *k*-combination
    does not have repetition. When we use *k*-combinations with duplicate elements,
    we specifically call them *k-combinations with repetition*.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that, both with and without repetition, you can think of permutation
    as a certain arrangement of all elements in a set, while a combination is an orderless
    selection of certain elements from a set. Permutations have an ordering and use
    all the elements from a set, while combinations don’t have an ordering and use
    any number of elements from a set. To get a better idea of these terms, [Table
    6-1](#table6-1) shows the difference between permutations and combinations, with
    and without repetition, of the set {A, B, C}.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1: All Possible Permutations and Combinations, with and without Repetition,
    of the Set {A, B, C}'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Permutations** | **Combinations** |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
- en: '| **Without repetition** | ABC, ACB, BAC, BCA, CAB | (None), A, B, C, AB, AC,
    BC, ABC |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
- en: '| **With repetition** | AAA, AAB, AAC, ABA, ABB, ABC, ACA, ACB, ACC, BAA, BAB,
    BAC, BBA, BBB, BBC, BCA, BCB, BCC, CAA, CAB, CAC, CBA, CBB, CBC, CCA, CCB, CCC
    | (None), A, B, C, AA, AB, AC, BB, BC, CC, AAA, AAB, AAC, ABB, ABC, ACC, BBB,
    BBC, BCC, CCC |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
- en: It’s surprising how quickly the number of permutations and combinations grows
    as we add elements to a set. This *combinatorial explosion* is captured by the
    formulas in [Table 6-2](#table6-2). For example, a set of 10 elements has 10!,
    or 3,628,800, possible permutations, but a set of twice as many elements has 20!,
    or 2,432,902,008,176,640,000, permutations.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-2: Calculating the Number of Possible Permutations and Combinations,
    with and without Repetition, of a Set of *n* Elements'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Permutations** | **Combinations** |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
- en: '| **Without repetition** | *n*! | 2*n* |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
- en: '| **With repetition** | *n*^(*n*) | 2*n* choose *n*, or (2*n*)! / (*n*!)² |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
- en: 'Note that permutations without repetition are always the same size as the set.
    For example, the permutations of {A, B, C} are always three letters long: ABC,
    ACB, BAC, and so forth. However, permutations with repetition can be of any length.
    [Table 6-1](#table6-1) shows the three-letter permutations of {A, B, C} ranging
    from AAA to CCC, but you could also, for example, have five-letter permutations
    with repetition ranging from AAAAA to CCCCC. The number of permutations with repetition
    of *n* elements that are *k* elements long is *n*^(*k*). [Table 6-2](#table6-2)
    lists it as *n*^(*n*) for permutations with repetition that are also *n* elements
    long.'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: Ordering matters for permutations, but not for combinations. While AAB, ABA,
    and BAA are considered the same combination with repetition, they are considered
    three separate permutations with repetition.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding All Permutations Without Repetition: A Wedding Seating Chart'
  id: totrans-934
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you must arrange the seating chart for a wedding reception with delicate
    social requirements. Some of the guests hate each other, while others demand to
    sit near an influential guest. The seats at the rectangular table form one long,
    straight row, rather than a circle. It’d be helpful for your planning to see every
    possible ordering of guests—that is, every permutation without repetition of the
    set of guests. No repetition occurs, because each guest appears in the seating
    chart only once.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use a simple example of Alice, Bob, and Carol, or {A, B, C}. [Figure 6-2](#figure6-2)
    shows all six possible permutations of these three wedding guests.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: One way we can determine the number of permutations without repetition is with
    a head-tail recursive strategy. We select one element from the set as the head.
    We then get every permutation of the rest of the elements (which constitute the
    tail), and for each permutation we place the head in every possible location in
    the permutation.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: In our ABC example, we’ll start with Alice (A) as the head and Bob and Carol
    (BC) as the tail. The permutations of {B, C} are BC and CB. (How we got BC and
    CB is explained in the next paragraph, so just put that question aside for now.)
    We’ll put A in every possible location in BC. That is, we put Alice before Bob
    (ABC), in between Bob and Carol (BAC), and after Carol (BCA). This creates the
    permutations ABC, BAC, and BCA. We also put A in every possible position in CB,
    creating ACB, CAB, and CBA. This creates all six permutations of Alice, Bob, and
    Carol sitting at the reception table. Now we can pick the arrangement that results
    in the fewest fights (or the most fights, if you want a memorable wedding reception).
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing of six dinner tables seating the same three people arranged in different
    orders.](image_fi/502024c06/f06002.png)'
  id: totrans-939
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: All six possible permutations of three wedding guests at a table'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: Of course, to get every permutation of {B, C}, we’d recursively repeat the process
    with B as the head and C as the tail. The permutation of a single character is
    the character itself; this is our base case. By putting the head B in every possible
    location in C, we get the BC and CB permutations we used in the previous paragraph.
    Remember that, while order doesn’t matter with sets (as {B, C} is the same as
    {C, B}), it does matter with permutations (BC is not a duplicate of CB).
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: 'Our recursive permutation function accepts as an argument a string of characters
    and returns an array of strings of every possible permutation of those characters.
    Let’s ask the three questions about our recursive algorithms for this function:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? An argument of a single character string or empty string,
    which returns an array of just that string.
  id: totrans-943
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The string argument
    missing one character. A separate recursive call is made for each character missing.
  id: totrans-944
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The size of the string
    shrinks and eventually becomes a single-character string.
  id: totrans-945
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The recursive permutations algorithm is implemented in *permutations.py*:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The equivalent JavaScript program is in *permutations.html*:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The output of these programs is the following:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'When `getPerms()` is called, it first checks for the base case ❶. If the `chars`
    string is only one character long, it can have only one permutation: the `chars`
    string itself. The function returns this string in an array.'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, in the recursive case, the function splits the `chars` argument’s
    first character into the `head` variable and the rest into the `tail` variable
    ❷. The function makes a recursive call to `getPerms()` to get all the permutations
    of the string in `tail`. A first `for` loop ❸ iterates over each of these permutations,
    and a second `for` loop ❹ creates a new permutation by placing the `head` character
    in every possible place in the string.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: For example, if `getPerms()` is called with `ABCD` for the `chars` argument,
    `head` is `A` and `tail` is `BCD`. The `getPerms('BCD')` call returns an array
    of the tail permutations, `['BCD', 'CBD', 'CDB', 'BDC', 'DBC', 'DCB']`. The first
    `for` loop starts with the `BCD` permutation, and the second `for` loop places
    the `A` string in `head` in each possible place, producing `ABCD`, `BACD`, `BCAD`,
    `BCDA`. This is repeated with the remaining tail permutations, and the entire
    list is then returned by the `getPerms()` function.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting Permutations with Nested Loops: A Less-Than-Ideal Approach'
  id: totrans-955
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we have a simple bicycle lock, as in [Figure 6-3](#figure6-3), with
    a four-digit combination. The combination has 10,000 possible permutations of
    digits (0000 to 9999), but only one will unlock it. (They are called *combination
    locks*; however, in this context it’d be more accurate to call them *permutations
    with repetition locks*, since the order matters.)
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s say we have a much simpler lock with only the five letters A to E.
    We can calculate the number of possible combinations as 5⁴, or 5 × 5 × 5 × 5,
    or 625\. A combination lock of *k* characters, each character selected from a
    set of *n* possibilities, is *n*^(*k*). But getting a list of the combinations
    themselves is a bit more involved.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a bicycle lock with a four-digit combination.](image_fi/502024c06/f06003.png)'
  id: totrans-958
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: A four-digit combination bicycle lock has 10⁴, or 10,000, possible
    permutations with repetition (photo courtesy of Shaun Fisher, CC BY 2.0 license).'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: One way to get permutations with repetition is with *nested loops*—that is,
    a loop within another loop. The inner loop goes through every element in a set,
    whereas the outer loop does the same while repeating the inner loop. Creating
    all possible *k*-character permutations, each character selected from a set of
    *n* possibilities, requires *k* nested loops.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, *nestedLoopPermutations.py* contains code that generates all 3-combinations
    of {A, B, C, D, E}:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'And *nestedLoopPermutations.html* contains the equivalent JavaScript program:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The output of these programs looks like this:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The problem with generating permutations with four nested loops is that it works
    only for permutations that are exactly four characters. Nested loops cannot generate
    permutations for arbitrary lengths. Instead, we can use a recursive function,
    as described in the next section.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: You can remember the difference between permutations with and without repetition
    with the examples in this chapter. Permutations *without* repetition go through
    all possible orderings of the elements in a set, like our wedding guest seating
    chart example. Permutations *with* repetition go through all the possible combinations
    of a combination lock; the order matters, and the same element can appear more
    than once.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: 'Permutations with Repetition: A Password Cracker'
  id: totrans-971
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you have received a sensitive encrypted file from a recently deceased
    journalist. In their final message, the journalist told you the file contains
    records of tax evasion by a nefarious trillionaire. They didn’t have the password
    to decrypt the file, but they did know that it is exactly four characters long;
    also, the possible characters are the numbers 2, 4, and 8 and the letters J, P,
    and B. These characters can appear more than once. For example, possible passwords
    are JPB2, JJJJ, and 2442\.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: To generate a list of all possible four-character passwords based on this information,
    you want to obtain all possible four-element permutations with repetition of the
    set {J, P, B, 2, 4, 8}. Each of the four characters in the password can be one
    of the six possible characters, making 6 × 6 × 6 × 6, or 6⁴, or 1,296 possible
    permutations. We want to generate the permutations of {J, P, B, 2, 4, 8}, and
    not the combinations, because the ordering matters; JPB2 is a different password
    from B2JP.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursive algorithm questions about our permutations function.
    Instead of *k*, we’ll use the more descriptive name `permLength`:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? A `permLength` argument of `0`, meaning a permutation
    zero characters long, signals that the `prefix` argument now contains the complete
    permutation and so `prefix` should be returned in an array.
  id: totrans-975
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The `chars` string of
    the characters to get permutations of, a `permLength` argument that begins as
    the length of `chars`, and a `prefix` argument that begins as the blank string.
    Recursive calls decrement the `permLength` argument while appending a character
    from `chars` to the `prefix` argument.
  id: totrans-976
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? Eventually, the `permLength`
    argument decrements to `0`.
  id: totrans-977
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The algorithm for recursive permutations with repetition is implemented in
    *permutationsWithRepetition.py*:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The equivalent JavaScript program is in *permutationsWithRepetition.html*:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The output of these programs is shown here:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The `getPermsWithRep()` function has a `prefix` string argument that begins
    as a blank string by default. When the function is called, it first checks for
    the base case ❶. If `permLength`, the length of the permutations, is `0`, an array
    with `prefix` is returned.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, in the recursive case, for each character in the `chars` argument
    the function creates a new prefix ❷ to pass to the recursive `getPermsWithRep()`
    call. This recursive call passes `permLength - 1` for the `permLength` argument.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: The `permLength` argument starts at the length of the permutations and decreases
    by one for each recursive call ❸. And the `prefix` argument starts as the blank
    string and increases by one character for each recursive call. So by the time
    the base case of `k == 0` is reached, the `prefix` string is the full permutation
    length of `k`.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s consider the case of calling `getPermsWithRep(''ABC'', 2)`.
    The `prefix` argument defaults to the blank string. The function makes a recursive
    call with each character of `ABC` concatenated to the blank prefix string as the
    new prefix. Calling `getPermsWithRep(''ABC'', 2)` makes these three recursive
    calls:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: '`getPermsWithRep(''ABC'', 1, ''A'')`'
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPermsWithRep(''ABC'', 1, ''B'')`'
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPermsWithRep(''ABC'', 1, ''C'')`'
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these three calls will make its own three recursive calls, but will
    pass `0` for `permLength` instead of `1`. The base case occurs when `permLength
    == 0`, so these return their prefixes. This is how all nine of the permutations
    are generated. The `getPermsWithRep()` function generates permutations of larger
    sets the same way.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: Getting K-Combinations with Recursion
  id: totrans-992
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that order is not significant for combinations in the way it is for
    permutations. Yet generating all *k*-combinations of a set is a bit tricky because
    you don’t want your algorithm to generate duplicates: if you create the AB 2-combination
    from the set {A, B, C}, you don’t want to also create BA, because it’s the same
    2-combination as AB.'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: To figure out how we can write recursive code to solve this problem, let’s see
    how a tree can visually describe generating all the *k*-combinations of a set.
    [Figure 6-4](#figure6-4) shows a tree with all the combinations from the set {A,
    B, C, D}.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagram with each level of depth classified as either 0-combinations,
    1-combinations, 2-combinations, 3-combinations, or 4-combinations.](image_fi/502024c06/f06004.png)'
  id: totrans-995
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: Tree showing every possible *k*-combination (from 0 to 4) from
    the set {A, B, C, D}'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: 'To gather, for example, 3-combinations from this tree, start at the root node
    at the top and do a depth-first tree traversal to the 3-combinations level, while
    memorizing each node’s letter on the way to the bottom. (Depth-first searches
    are discussed in Chapter 4.) Our first 3-combination would be going from the root
    to A in the 1-combination level, then down to B in the 2-combination level, then
    to C in the 3-combination level, where we stop with our complete 3-combination:
    ABC. For the next combination, we traverse from the root to A to B to D, giving
    us the combination ABD. We continue doing this for ACD and BCD. Our tree has four
    nodes in the 3-combination level, and four 3-combinations from {A, B, C, D}: ABC,
    ABD, ACD, and BCD.'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we create the tree in [Figure 6-4](#figure6-4) by starting with
    a blank string for the root node. This is the 0-combination level, and it applies
    to all combinations of zero selections from the set; it’s simply an empty string.
    The child nodes of the root are all elements from the set. In our case, that is
    all four elements from {A, B, C, D}. While sets don’t have an order, we need to
    be consistent in using the ABCD order of the set while generating this tree. This
    is because every node’s children consist of the letters after it in the ABCD string:
    all A nodes have children B, C, and D; all B nodes have children C and D; all
    C nodes have one D child; and all D nodes have no child nodes.'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: 'While it’s not directly related to the recursive combination function, also
    notice the pattern in the number of *k*-combinations at each level:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: 'The 0-combination and 4-combination levels both have one combination: the empty
    string and ABCD, respectively.'
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The 1-combination and 3-combination levels both have four combinations: A,
    B, C, D and ABC, ABD, ACD, BCD, respectively.'
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The 2-combination level in the middle has the most combinations at six: AB,
    AC, AD, BC, BD, and CD.'
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reason the number of combinations increases, peaks in the middle, and then
    decreases is that the *k*-combinations are mirrors of each other. For example,
    the 1-combinations are made from the elements not selected for the 3-combinations:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: The 1-combination A is the mirror of the 3-combination BCD.
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 1-combination B is the mirror of the 3-combination ACD.
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 1-combination C is the mirror of the 3-combination ABD.
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 1-combination D is the mirror of the 3-combination ABC.
  id: totrans-1007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll create a function called `getCombos()` that takes two arguments: a `chars`
    string with the letters to get combinations from, and the size of the combinations
    `k`. The return value is an array of strings of combinations from the string `chars`,
    each of length `k`.'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use a head-tail technique with the `chars` argument. For example, say
    we call `getCombos('ABC', 2)` to get all the 2-combinations from {A, B, C}. The
    function will set `A` as the head and `BC` as the tail. [Figure 6-5](#figure6-5)
    shows the tree for selecting 2-combinations from {A, B, C}.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagram classifying each depth level as 0-combinations, 1-combinations,
    2-combinations, or 3-combinations.](image_fi/502024c06/f06005.png)'
  id: totrans-1010
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: Tree showing every possible 2-combination from the set {A, B, C}'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask our three recursive algorithm questions:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? The first base case is a `k` argument of `0`, meaning
    that a 0-combination is requested, which is always an array of the blank string
    no matter what `chars` is. The second case occurs if `chars` is the blank string,
    which is an empty array since no possible combinations can be made from a blank
    string.
  id: totrans-1013
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? For the first recursive
    call, the tail of `chars` and `k - 1` are passed. For the second recursive call,
    the tail of `chars` and `k` are passed.
  id: totrans-1014
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? Since the recursive calls
    decrement `k` and remove the heads from the `chars` arguments, eventually the
    `k` argument decrements to `0` or the `chars` argument becomes the blank string.
  id: totrans-1015
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Python code for generating combinations is in *combinations.py*:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The equivalent JavaScript program is in *combinations.html*:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The output of these programs is the following:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Every `getCombos()` function call has two recursive calls for the two parts
    of the algorithm. For our `getCombos('ABC', 2)` example, the first part ❶ is to
    get all the combinations that include the head `A`. In the tree, this generates
    all the combinations *under* the A node in the 1-combination level.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by passing the tail and `k - 1` to the first recursive function
    call: `getCombos(''BC'', 1)` ❷. We add `A` to each combination that this recursive
    function call returns. Let’s use the leap-of-faith principle and just assume our
    `getCombos()` correctly returns a list of *k*-combinations, `[''B'', ''C'']`,
    even though we haven’t finished writing it yet. We now have all the *k*-combinations
    that include the head `A` in an array to hold our results: `[''AB'', ''AC'']`.'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part ❸ gets all the combinations that don’t include the head `A`.
    In the tree, this generates all the combinations *to the right* of the A node
    in the 1-combination level. We can do this by passing the tail and `k` to the
    second recursive function call: `getCombos(''BC'', 2)`. This returns `[''BC'']`,
    since BC is the only 2-combination of BC.'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: 'The results from `getCombos(''ABC'', 2)`’s two recursive calls, `[''AB'', ''AC'']`
    and `[''BC'']`, are concatenated together and returned: `[''AB'', ''AC'', ''BC'']`
    ❹. The `getCombos()` function generates combinations of larger sets the same way.'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: Get All Combinations of Balanced Parentheses
  id: totrans-1027
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A string has *balanced parentheses* if every opening parenthesis is followed
    by exactly one closing parenthesis. For example, `′()()′` and `′(())′` are strings
    of two balanced parentheses pairs, but `′)(()′` and `′(()′` are not balanced.
    These strings are also called *Dyck words*, after mathematician Walther von Dyck.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: A common coding interview question is to write a recursive function that, given
    the number of pairs of parentheses, produces all possible combinations of balanced
    parentheses. For example, a `getBalancedParens(3)` call should return `['((()))',
    '(()())', '(())()', '()(())', '()()()']`. Note that calling `getBalancedParens(``n``)`
    `returns strings that are 2*n* characters in length, since each string consists
    of *n* pairs of parentheses.`
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: '`We could try to solve this problem by finding all permutations of the pairs
    of parenthesis characters, but that would result in both balanced and unbalanced
    parentheses strings. Even if we filtered out the invalid strings later, 2*n*!
    permutations exist for *n* pairs of parentheses. That algorithm is far too slow
    to be practical.'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can implement a recursive function to generate all strings of balanced
    parentheses. Our `getBalancedParens()` function takes an integer of the number
    of pairs of parentheses and returns a list of balanced parentheses strings. The
    function builds these strings by adding either an opening or closing parenthesis.
    An opening parenthesis can be added only if opening parentheses remain to be used.
    A closing parenthesis can be added only if more opening parentheses have been
    added than closing parentheses so far.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: We’ll track the number of opening and closing parentheses remaining to be used
    with function parameters named `openRem` and `closeRem`. The string currently
    being built is another function parameter named `current`, which serves a similar
    purpose as the `prefix` parameter in the *permutationsWithRepetition* program.
    The first base case occurs when `openRem` and `closeRem` are both `0` and no more
    parentheses remain to be added to the `current` string. The second base case happens
    after the two recursive cases have received the lists of balanced parentheses
    strings after adding an opening and/or closing parenthesis (if possible).
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursive algorithm questions about the `getBalancedParens()`
    function:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? When the number of opening and closing parentheses remaining
    to be added to the string being built has reached `0`. A second base case always
    occurs after the recursive cases have finished.
  id: totrans-1034
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The total number of
    pairs of parentheses (`pairs`), the remaining number of opening and closing parentheses
    to add (`openRem` and `closeRem`), and the string currently being built (`current`).
  id: totrans-1035
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? As we add more opening
    and closing parentheses to `current`, we decrement the `openRem` and `closeRem`
    arguments until they become 0.
  id: totrans-1036
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *balancedParentheses.py* file contains the Python code for our balanced
    parentheses recursive function:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The *balancedParentheses.html* file contains the JavaScript equivalent of this
    program:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The output of these programs looks like this:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The `getBalancedParens()` function ❶ requires one argument, the number of pairs
    of parentheses, when called by the user. However, it needs to pass additional
    information in the arguments to its recursive calls. These include the number
    of opening parentheses that remain to be added (`openRem`), the number of closing
    parentheses that remain to be added (`closeRem`), and the current balanced parentheses
    string being built (`current`). Both `openRem` and `closeRem` start as the same
    value as the `pairs` argument, and `current` starts as the blank string. An `indent`
    argument is used only for the debugging output to show the program’s level of
    recursive function call.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: The function first checks the number of opening and closing parentheses remaining
    to be added ❷. If both are `0`, we’ve reached the first base case, and the string
    in `current` is finished. Since the `getBalancedParens()` function returns a list
    of strings, we put `current` in a list and return it ❸.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the function continues on to the recursive case. If possible opening
    parentheses remain ❹, the function calls `getBalancedParens()` with an opening
    parenthesis added to the current argument. If more closing parentheses are remaining
    than opening parentheses ❺, the function calls `getBalancedParens()` with a closing
    parenthesis added to the current argument. This check ensures that an unmatched
    closing parenthesis won’t be added, as this would make the string unbalanced,
    such as the second closing parenthesis in `())`.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: After these recursive cases is an unconditional base case that returns all the
    strings returned from the two recursive function calls (and, of course, the recursive
    function calls made by these recursive function calls, and so on) ❻.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: 'Power Set: Finding All Subsets of a Set'
  id: totrans-1047
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *power set* of a set is the set of every possible subset of that set. For
    example, the power set of {A, B, C} is {{ }, {A}, {B}, {C}, {A, B}, {A, C}, {B,
    C}, {A, B, C}}. This is equivalent to the set of every possible *k*-combination
    of a set. After all, the power set of {A, B, C} contains all its 0-combinations,
    1-combinations, 2-combinations, and 3-combinations.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: If you’re looking for a real-world example in which you would need to generate
    the power set of a set, imagine a job interviewer asked you to generate the power
    set of a set. It is astronomically unlikely you’ll need to generate the power
    set of a set for any other reason, including the job you are interviewing for.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: To find every power set of a set, we could reuse our existing `getCombos()`
    function, calling it repeatedly with each possible *k* argument. This approach
    is taken by the *powerSetCombinations.py* and *powerSetCombinations.html* programs
    in the downloadable resources file from [https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion).
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can use a more efficient way to generate power sets. Let’s consider
    the power set of {A, B}, which is {{A, B}, {A}, {B}, { }}. Now say we add one
    more element, C, to the set and want to generate the power set of {A, B, C}. We
    have the four sets in the power set of {A, B} we already generated; in addition,
    we have these same four sets but with the element C added to them: {{A, B, C},
    {A, C}, {B, C}, {C}}. [Table 6-3](#table6-3) shows the pattern of how adding more
    elements to a set adds more sets to its power set.'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-3: How Power Sets Grow as New Elements (in Bold) Are Added to the Set'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: '| **Set with new element** | **New sets to the power set** | **Complete power
    set** |'
  id: totrans-1053
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1054
  prefs: []
  type: TYPE_TB
- en: '| { } | { } | {{ }} |'
  id: totrans-1055
  prefs: []
  type: TYPE_TB
- en: '| {A} | {A} | {{ }, **{A}**} |'
  id: totrans-1056
  prefs: []
  type: TYPE_TB
- en: '| {A, B} | {B}, {A, B} | {{ }, {A}, **{B}**, **{A, B}**} |'
  id: totrans-1057
  prefs: []
  type: TYPE_TB
- en: '| {A, B, C} | {C}, {A, C}, {B, C}, {A, B, C} | {{ }, {A}, {B}, **{C}**, {A,
    B}, **{A, C}**, **{B, C}**, **{A, B, C}**} |'
  id: totrans-1058
  prefs: []
  type: TYPE_TB
- en: '| {A, B, C, D} | {D}, {A, D}, {B, D}, {C, D}, {A, B, D}, {A, C, D}, {B, C,
    D}, {A, B, C, D} | {{ }, {A}, {B}, {C}, **{D}**, {A, B}, {A, C}, **{A, D}**, {B,
    C}, **{B, D}**, **{C, D}**, {A, B, C}, {A, B, D}, {A, C, D}, **{B, C, D}**, **{A,
    B, C, D}**} |'
  id: totrans-1059
  prefs: []
  type: TYPE_TB
- en: The power sets of larger sets are similar to the power sets of smaller sets,
    hinting that we can create a recursive function to generate them. The base case
    is an empty set, and its power set is a set of just the empty set. We can use
    a head-tail technique for this recursive function. For each new element we add,
    we want to get the power set of the tail to add to our full power set. We also
    add the head element to each set in the tail power set. Together, these form the
    full power set for the `chars` argument.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursive algorithm questions about our power set algorithm:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? If `chars` is the blank string (the empty set), the function
    returns an array with just a blank string, since the empty set is the only subset
    of the empty set.
  id: totrans-1062
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The tail of `chars`
    is passed.
  id: totrans-1063
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? Since the recursive calls
    remove the heads from the `chars` arguments, eventually the `chars` argument becomes
    the blank string.
  id: totrans-1064
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `getPowerSet()` recursive function is implemented in *powerSet.py*:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The equivalent JavaScript code is in *powerSet.html*:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The programs output the following:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The `getPowerSet()` function accepts a single argument: the string `chars`,
    which contains the characters of the original set. The base case occurs when `chars`
    is the blank string ❶, representing an empty set. Recall that the power set is
    the set of all subsets of the original set. Thus, the power set of the empty set
    is simply a set containing the empty set, since the empty set is the only subset
    of the empty set. This is why the base case returns `['''']`.'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: The recursive case is split into two parts. The first part is acquiring the
    power set of the tail of `chars`. We’ll use the leap-of-faith principle and just
    assume the call to `getPowerSet()` returns the power set of the tail correctly
    ❷, even though at this point we’d still be in the process of writing the code
    for `getPowerSet()`.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: To form the complete power set of `chars`, the second part of the recursive
    case forms new sets by adding the head to each of the tail power sets ❸. Together
    with the sets from the first part, this forms the power set of `chars` to return
    at the end of the function ❹.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1075
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Permutations and combinations are two problem domains that many programmers
    don’t know how to even begin to approach. While recursion is often an overly complicated
    solution for common programming problems, it’s well suited for the complexity
    of the tasks in this chapter.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: The chapter began with a brief introduction to set theory. This lays the basis
    for the data structures that our recursive algorithms operate on. A set is a collection
    of distinct elements. A subset consists of none, some, or all the elements of
    a set. While sets have no ordering for their elements, a permutation is a specific
    ordering of the elements in a set. And a combination, which has no ordering, is
    a specific selection of none, some, or all the elements in a set. A *k*-combination
    of a set is a subset of *k* elements selected from the set.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: Permutations and combinations can include an element once or can repeat elements.
    We call these permutations or combinations without repetition and with repetition,
    respectively. These are implemented by different algorithms.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also tackled the balanced parentheses problem that is commonly
    used in coding interviews. Our algorithm builds the strings of balanced parentheses
    by starting with a blank string and adding opening and closing parentheses. This
    approach involves backtracking to earlier strings, making recursion an ideal technique.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this chapter featured a recursive function for generating power sets—that
    is, sets of all possible *k*-combinations of the elements of a set. The recursive
    function we create to do this is much more efficient than repeatedly calling our
    combinations function for each possible size of subset.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-1081
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generating permutations and combinations only scratches the surface of what
    you can do with permutations and combinations, as well as the field of mathematical
    logic known as *set theory*. The following Wikipedia articles provide plenty of
    further details on these topics, as do the Wikipedia articles that each links
    to:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Set_theory](https://en.wikipedia.org/wiki/Set_theory)'
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Combination](https://en.wikipedia.org/wiki/Combination)'
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Permutation](https://en.wikipedia.org/wiki/Permutation)'
  id: totrans-1085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python standard library comes with implementations of permutation, combination,
    and other algorithms in its `itertools` module. This module is documented at [https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html).
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: Permutations and combinations are also covered in statistics and probability
    math courses. Khan Academy’s unit on counting, permutations, and combinations
    can be found online at [https://www.khanacademy.org/math/statistics-probability/counting-permutations-and-combinations](https://www.khanacademy.org/math/statistics-probability/counting-permutations-and-combinations).
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  id: totrans-1088
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: Do sets have a specific order for their elements? Do permutations? Do combinations?
  id: totrans-1090
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many permutations (without repetition) are there of a set of *n* elements?
  id: totrans-1091
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many combinations (without repetition) are there of a set of *n* elements?
  id: totrans-1092
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is {A, B, C} a subset of {A, B, C}?
  id: totrans-1093
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the formula for calculating *n choose k*, the number of possible combinations
    of *k* elements selected from a set of *n* elements?
  id: totrans-1094
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Identify which of the following are permutations or combinations, with or without
    repetition:'
  id: totrans-1095
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AAA, AAB, AAC, ABA, ABB, ABC, ACA, ACB, ACC, BAA, BAB, BAC, BBA, BBB, BBC, BCA,
    BCB, BCC, CAA, CAB, CAC, CBA, CBB, CBC, CCA, CCB, CCC
  id: totrans-1096
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ABC, ACB, BAC, BCA, CAB
  id: totrans-1097
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (None), A, B, C, AB, AC, BC, ABC
  id: totrans-1098
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (None), A, B, C, AA, AB, AC, BB, BC, CC, AAA, AAB, AAC, ABB, ABC, ACC, BBB,
    BBC, BCC, CCC
  id: totrans-1099
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a tree graph that can be used to generate all possible combinations of
    the set {A, B, C, D}.
  id: totrans-1100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer the three questions about recursive solutions for each of the recursive
    algorithms presented in this chapter:'
  id: totrans-1101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base case?
  id: totrans-1102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call?
  id: totrans-1103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case?
  id: totrans-1104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then re-create the recursive algorithms from this chapter without looking at
    the original code.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: Practice Projects
  id: totrans-1106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For practice, write a function for the following task:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: The permutation function in this chapter operates on characters in a string
    value. Modify it so that the sets are represented by lists (in Python) or arrays
    (in JavaScript) and the elements can be values of any data type. For example,
    your new function should be able to generate permutations of integer values, rather
    than strings.
  id: totrans-1108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The combination function in this chapter operates on characters in a string
    value. Modify it so that the sets are represented by lists (in Python) or arrays
    (in JavaScript) and the elements can be values of any data type. For example,
    your new function should be able to generate combinations of integer values, rather
    than strings.`*  *`# 7
  id: totrans-1109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Memoization and Dynamic Programming
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-1111
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll explore memoization, a technique for making recursive
    algorithms run faster. We’ll discuss what memoization is, how it should be applied,
    and its usefulness in the areas of functional programming and dynamic programming.
    We’ll use the Fibonacci algorithm from Chapter 2 to demonstrate memoizing code
    we write and the memoization features we can find in the Python standard library.
    We’ll also learn why memoization can’t be applied to every recursive function.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  id: totrans-1113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Memoization* is the technique of remembering the return values from a function
    for the specific arguments supplied to it. For example, if someone asked me to
    find the square root of 720, which is the number that when multiplied by itself
    results in 720, I’d have to sit down with pencil and paper for a few minutes (or
    call `Math.sqrt(720)` in JavaScript or `math.sqrt(720)` in Python) to figure it
    out: 26.832815729997478\. If they asked me again a few seconds later, I wouldn’t
    have to repeat my calculation because I’d already have the answer at hand. By
    caching previously calculated results, memoization makes a trade-off to save on
    execution time by increasing memory usage.'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: Confusing *memoization* with *memorization* is a modern mistake made by many.
    (Feel free to make a memo to remind yourself of the difference.)
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: Top-Down Dynamic Programming
  id: totrans-1116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Memoization is a common strategy in *dynamic programming*, a computer programming
    technique that involves breaking a large problem into overlapping subproblems.
    This might sound a lot like the ordinary recursion we’ve already seen. The key
    difference is that dynamic programming uses recursion with repeated recursive
    cases; these are the *overlapping* subproblems.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s consider the recursive Fibonacci algorithm from Chapter 2.
    Making a recursive `fibonacci(6)` function call will in turn call `fibonacci(5)`
    and `fibonacci(4)`. Next, `fibonacci(5)` will call `fibonacci(4)` and `fibonacci(3)`.
    The subproblems of the Fibonacci algorithm overlap, because the `fibonacci(4)`
    call, and many others, are repeated. This makes generating Fibonacci numbers a
    dynamic programming problem.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: 'An inefficiency exists here: performing those same calculations multiple times
    is unnecessary, because `fibonacci(4)` will always return the same thing, the
    integer `3`. Instead, our program could just remember that if the argument to
    our recursive function is `4`, the function should immediately return `3`.'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-1](#figure7-1) shows a tree diagram of all the recursive calls, including
    the redundant function calls that memoization can optimize. Meanwhile, quicksort
    and merge sort are recursive divide-and-conquer algorithms, but their subproblems
    do not overlap; they are unique. Dynamic programming techniques aren’t applied
    to these sorting algorithms.'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagram beginning with the Fibonacci function called with an argument
    of 6\. Two subsequent branches show the next calls to the Fibonacci function,
    with arguments of 5 and 4, respectively. The tree continues to branch until each
    branch ends with a value of 1\. Several branches are grayed out, indicating that
    the Fibonacci function was called with the same argument as a previous branch.](image_fi/502024c07/f07001.png)'
  id: totrans-1121
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: A tree diagram of the recursive function calls made starting with
    `fibonacci(6)`. The redundant function calls are in gray.'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: One approach in dynamic programming is to memoize the recursive function so
    that previous calculations are remembered for future function calls. Overlapping
    subproblems become trivial if we can reuse previous return values.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: Using recursion with memoization is called *top-down dynamic programming*. This
    process takes a large problem and divides it into smaller overlapping subproblems.
    A contrasting technique, *bottom-up dynamic programming*, starts with the smaller
    subproblems (often related to the base case) and “builds up” to the solution of
    the original, large problem. The iterative Fibonacci algorithm, which begins with
    the base cases of the first and second Fibonacci numbers, is an example of bottom-up
    dynamic programming. Bottom-up approaches don’t use recursive functions.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is no such thing as top-down recursion or bottom-up recursion.
    These are commonly used but incorrect terms. All recursion is already top-down,
    so *top-down recursion* is redundant. And no bottom-up approach uses recursion,
    so there’s no such thing as *bottom-up recursion*.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: Memoization in Functional Programming
  id: totrans-1126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all functions can be memoized. To see why, we must discuss *functional programming*,
    a programming paradigm that emphasizes writing functions that don’t modify global
    variables or any *external state* (such as files on the hard drive, internet connections,
    or database contents). Some programming languages, such as Erlang, Lisp, and Haskell,
    are heavily designed around functional programming concepts. But you can apply
    functional programming features to almost any programming language, including
    Python and JavaScript.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming includes the concepts of deterministic and nondeterministic
    functions, side effects, and pure functions. The `sqrt()` function mentioned in
    the introduction is a *deterministic* function because it always returns the same
    value when passed the same argument. However, Python’s `random.randint()` function,
    which returns a random integer, is *nondeterministic* because even when passed
    the same arguments, it can return different values. The `time.time()` function,
    which returns the current time, is also nondeterministic because time is constantly
    moving forward.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: '*Side effects* are any changes a function makes to anything outside of its
    own code and local variables. To illustrate this, let’s create a `subtract()`
    function that implements Python’s subtraction operator (`-`):'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This `subtract()` function has no side effects; calling this function doesn’t
    affect anything in the program outside of its code. There’s no way to tell from
    the program’s or the computer’s state whether the `subtract()` function has been
    called once, twice, or a million times before. A function might modify local variables
    inside the function, but these changes are local to the function and remain isolated
    from the rest of the program.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider an `addToTotal()` function, which adds the numeric argument to
    a global variable named `TOTAL`:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The `addToTotal()` function does have a side effect, because it modifies an
    element that exists outside of the function: the `TOTAL` global variable.'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: Side effects can be more than mere changes to global variables. They include
    updating or deleting files, printing text onscreen, opening a database connection,
    authenticating to a server, or any other manipulation of data outside of the function.
    Any trace that a function call leaves behind after returning is a side effect.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: If a function is deterministic and has no side effects, it’s known as a *pure
    function*. Only pure functions should be memoized. You’ll see why in the next
    sections when we memoize the recursive Fibonacci function and the impure functions
    of the `doNotMemoize` program.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing the Recursive Fibonacci Algorithm
  id: totrans-1139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s memoize our recursive Fibonacci function from Chapter 2. Remember that
    this function is extraordinarily inefficient: on my computer, the recursive `fibonacci(40)`
    call takes 57.8 seconds to compute. Meanwhile, an iterative version of `fibonacci(40)`
    is literally too fast for my code profiler to measure: 0.000 seconds.'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: Memoization can greatly speed up the recursive version of the function. For
    example, [Figure 7-2](#figure7-2) shows the number of function calls the original
    and memoized `fibonacci()` functions make for the first 20 Fibonacci numbers.
    The original, non-memoized function is doing an extraordinary amount of unnecessary
    computation.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: The number of function calls sharply increases for the original `fibonacci()`
    function (top) but only slowly grows for the memoized `fibonacci()` function (bottom).
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: '![f07002a](image_fi/502024c07/f07002a.png)![Two graphs showing how the number
    of function calls increases as the number of Fibonacci numbers to calculate increases.
    The first graph increases rapidly to 14,000 function calls for the 20th Fibonacci
    number to calculate, while the second graph is linear, showing 20 function calls
    for the 20th Fibonacci number to calculate.](image_fi/502024c07/f07002b.png)'
  id: totrans-1143
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: The number of function calls sharply increases for the original
    `fibonacci()` function (top) but grows only slowly for the memoized `fibonacci()`
    function (bottom).'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python version of the memoized Fibonacci algorithm is in *fibonacciByRecursionMemoized.py*.
    The additions to the original *fibonacciByRecursion.html* program from Chapter
    2 have been marked in bold:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The JavaScript version of the memoized Fibonacci algorithm is in *fibonacciByRecursionMemoized.html*.
    The additions to the original *fibonacciByRecursion.html* program from Chapter
    2 have been marked in bold:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'If you compare the output of this program to the original recursive Fibonacci
    program in Chapter 2, you’ll find it’s much shorter. This reflects the massive
    reduction of computation needed to achieve the same results:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: To memoize this function, we’ll create a dictionary (in Python) or object (in
    JavaScript) in a global variable named `fibonacciCache` ❶. Its keys are the arguments
    passed for the `nthNumber` parameter, and its values are the integers returned
    by the `fibonacci()` function given that argument. Every function call first checks
    if its `nthNumber` argument is already in the cache. If so, the cached return
    value is returned ❷. Otherwise, the function runs as normal (though it also adds
    the result to the cache just before the function returns ❸ ❹).
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: 'The memoized function is effectively expanding the number of base cases in
    the Fibonacci algorithm. The original base cases are only for the first and second
    Fibonacci numbers: they immediately return `1`. But every time a recursive case
    returns an integer, it becomes a base case for all future `fibonacci()` calls
    with that argument. The result is already in `fibonacciCache` and can be immediately
    returned. If you’ve already called `fibonacci(99)` once before, it becomes a base
    case just like `fibonacci(1)` and `fibonacci(2)`. In other words, memoization
    improves the performance of recursive functions with overlapping subproblems by
    increasing the number of base cases. Notice that the second time our program tries
    to find the 10th Fibonacci number ❺, it immediately returns the memoized result:
    `55`.'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that while memoization can reduce the number of redundant function
    calls a recursive algorithm makes, it doesn’t necessarily reduce the growth of
    frame objects on the call stack. Memoization won’t prevent stack overflow errors.
    Once again, you may be better off forgoing a recursive algorithm for a more straightforward
    iterative one.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: Python’s functools Module
  id: totrans-1155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing a cache by adding a global variable and code to manage it for every
    function you’d like to memoize can be quite a chore. Python’s standard library
    has a `functools` module with a function decorator named `@lru_cache()` that automatically
    memoizes the function it decorates. In Python syntax, this means adding `@lru_cache()`
    to the line preceding the function’s `def` statement.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: The cache can have a memory size limit set. The *lru* in the decorator name
    stands for the *least recently used* cache replacement policy, meaning that the
    least recently used entry is replaced with new entries when the cache limit is
    reached. The LRU algorithm is simple and fast, though other cache replacement
    policies are available for different software requirements.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: 'The *fibonacciFunctools.py* program demonstrates the use of the `@lru_cache()`
    decorator. The additions to the original *fibonacciByRecursion.py* program from
    Chapter 2 have been marked in bold:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Compared to the additions required to implement our own cache in *fibonacciByRecursionMemoized.py*,
    using Python’s `@lru_cache()` decorator is much simpler. Normally, calculating
    `fibonacci(99)` with the recursive algorithm would take a few centuries. With
    memoization, our program displays the `218922995834555169026` result in a few
    milliseconds.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: Memoization is a useful technique for recursive functions with overlapping subproblems,
    but it can be applied to any pure function to speed up runtime at the expense
    of computer memory.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: What Happens When You Memoize Impure Functions?
  id: totrans-1163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should not add the `@lru_cache` to functions that are not pure, meaning
    they are nondeterministic or have side effects. Memoization saves time by skipping
    the code in the function and returning the previously cached return value. This
    is fine for pure functions but can cause various bugs for impure functions.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: 'In nondeterministic functions, such as a function that returns the current
    time, memoization causes the function to return incorrect results. For functions
    with side effects, such as printing text to the screen, memoization causes the
    function to skip the intended side effect. The *doNotMemoize.py* program demonstrates
    what happens when the `@lru_cache` function decorator (described in the previous
    section) memoizes these impure functions:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'When you run this program, the output looks like this:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Notice that the second call to `getCurrentTime()` returns the same result as
    the first call despite being called two seconds later. And of the two calls to
    `printMessage()`, only the first call results in displaying the `Hello, world!`
    message on the screen.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: These bugs are subtle because they don’t cause an obvious crash, but rather
    cause the functions to behave incorrectly. No matter how you memoize your functions,
    be sure to thoroughly test them.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memoization (not memorization) is an optimization technique that can speed up
    recursive algorithms that have overlapping subproblems by remembering the previous
    results of identical calculations. Memoization is a common technique in the field
    of dynamic programming. By trading computer memory usage for improved runtime,
    memoization makes some otherwise intractable recursive functions possible.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: However, memoization won’t prevent stack overflow errors. Keep in mind that
    memoization is not a replacement for using a simple iterative solution. Code that
    uses recursion for the sake of recursion is not automatically more elegant than
    non-recursive code.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: Memoized functions must be pure—that is, they must be deterministic (returning
    the same values given the same arguments each time) and not have side effects
    (affecting anything about the computer or program outside of the function). Pure
    functions are often used in functional programming, which is a programming paradigm
    that makes heavy use of recursion.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: Memoization is implemented by creating a data structure called a *cache* for
    each function to memoize. You can write this code yourself, but Python has a built-in
    `@functools.lru_cache()` decorator that can automatically memoize the function
    it decorates.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-1177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s more to dynamic programming algorithms than simply memoizing functions.
    These algorithms are often used in both coding interviews and programming competitions.
    Coursera offers a free “Dynamic Programming, Greedy Algorithms” course at [https://www.coursera.org/learn/dynamic-programming-greedy-algorithms](https://www.coursera.org/learn/dynamic-programming-greedy-algorithms).
    The freeCodeCamp organization also has a series on dynamic programming at [https://www.freecodecamp.org/news/learn-dynamic-programing-to-solve-coding-challenges](https://www.freecodecamp.org/news/learn-dynamic-programing-to-solve-coding-challenges).
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to learn more about the LRU cache and other cache-related functions,
    the official Python documentation for the `functools` module is at [https://docs.python.org/3/library/functools.html](https://docs.python.org/3/library/functools.html).
    More information about other kinds of cache replacement algorithms is mentioned
    on Wikipedia at [https://en.wikipedia.org/wiki/Cache_replacement_policies](https://en.wikipedia.org/wiki/Cache_replacement_policies).
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  id: totrans-1180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: What is memoization?
  id: totrans-1182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do dynamic programming problems differ from regular recursion problems?
  id: totrans-1183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does functional programming emphasize?
  id: totrans-1184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What two characteristics must a function have in order to be a pure function?
  id: totrans-1185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is a function that returns the current date and time a deterministic function?
  id: totrans-1186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does memoization improve the performance of recursive functions with overlapping
    subproblems?
  id: totrans-1187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Would adding the `@lru_cache()` function decorator to a merge sort function
    improve its performance? Why or why not?
  id: totrans-1188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is changing the value in a function’s local variable an example of a side effect?
  id: totrans-1189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does memoization prevent stack overflows?
  id: totrans-1190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '8'
  id: totrans-1191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tail Call Optimization
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-1193
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, we covered using memoization to optimize recursive
    functions. This chapter explores a technique called *tail call optimization*,
    which is a feature provided by a compiler or interpreter to avoid stack overflows.
    Tail call optimization is also called *tail call elimination*, or *tail recursion
    elimination*.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is meant to explain tail call optimization, not to endorse it.
    I would go so far as to recommend *never* using tail call optimization. As you’ll
    see, rearranging your function’s code to use tail call optimization often makes
    it far less understandable. You should consider tail call optimization to be more
    of a hack or workaround to make recursion work when you shouldn’t be using a recursive
    algorithm in the first place. Remember, a complex recursive solution is not automatically
    an elegant solution; simple coding problems should be solved with simple non-recursive
    methods.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: Many implementations of popular programming languages don’t even offer tail
    call optimization as a feature. These include interpreters and compilers for Python,
    JavaScript, and Java. However, tail call optimization is a technique you should
    become familiar with in case you come across it in the code projects you work
    on.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: How Tail Recursion and Tail Call Optimization Work
  id: totrans-1197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make use of tail call optimization, a function must use *tail recursion**.*
    In tail recursion, the recursive function call is the last action of a recursive
    function. In code, this looks like a `return` statement returning the results
    of a recursive call.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: To see this in action, recall the *factorialByRecursion.py* and *factorialByRecursion.html*
    programs in Chapter 2. These programs calculated the factorial of an integer;
    for instance, 5! is equivalent to 5 × 4 × 3 × 2 × 1, or 120\. These calculations
    can be performed recursively because `factorial(n)` is equivalent to `n * factorial(n
    - 1)`, with the base case of `n == 1` returning `1`.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite these programs to use tail recursion. The following *factorialTailCall.py*
    program has a `factorial()` function that uses tail recursion:'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The *factorialTailCall.html* program has the equivalent JavaScript code:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Notice that the `factorial()` function’s recursive case ends with a `return`
    statement returning the results of a recursive call to `factorial()`. To allow
    the interpreter or compiler to implement tail call optimization, the last action
    a recursive function makes must be to return the results of the recursive call.
    No instructions can occur between making the recursive call and the `return` statement.
    The base case returns the `accum` parameter. This is the accumulator, explained
    in the next section.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: To understand how tail call optimization works, remember from Chapter 1 what
    happens when a function is called. First, a frame object is created and stored
    on the call stack. If the function call calls another function, another frame
    object is created and placed on top of the first frame object on the call stack.
    When a function returns, your program automatically deletes the frame object from
    the top of the stack.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: A stack overflow happens when too many function calls are made without returning,
    causing the number of frame objects to exceed the capacity of the call stack.
    This capacity is 1,000 function calls for Python and about 10,000 for JavaScript
    programs. While these amounts are more than enough for typical programs, recursive
    algorithms could exceed this limit and cause a stack overflow that crashes your
    program.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: Recall from Chapter 2 that a frame object stores the local variables in the
    function call as well as the return address of the instruction to return to when
    the function finishes. However, if the last action in the recursive case of a
    function is to return the results of a recursive function call, there’s no need
    to retain the local variables. The function does nothing involving the local variables
    after the recursive call, so the current frame object can be deleted immediately.
    The next frame object’s return address information can be the same as the old
    deleted frame object’s return address.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: Since the current frame object is deleted instead of retained on the call stack,
    the call stack never grows in size and can never cause a stack overflow!
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: Recall from Chapter 1 that all recursive algorithms can be implemented with
    a stack and a loop. Since tail call optimization removes the need for a call stack,
    we are effectively using recursion to simulate a loop’s iterative code. However,
    earlier in this book I stated that the problems suitable for recursive solutions
    involve a tree-like data structure and backtracking. Without a call stack, no
    tail recursive function could possibly do any backtracking work. In my view, every
    algorithm that can be implemented with tail recursion would be easier and more
    readable to implement with a loop instead. There’s nothing automatically more
    elegant about using recursion for recursion’s sake.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: Accumulators in Tail Recursion
  id: totrans-1212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The disadvantage of tail recursion is that it requires rearranging your recursive
    function so that the last action is returning the recursive call’s return value.
    This can make our recursive code even more unreadable. Indeed, the `factorial()`
    function in this chapter’s *factorialTailCall.py* and *factorialTailCall.html*
    programs is a bit harder to comprehend than the version in Chapter 2’s *factorialByRecursion.py*
    and *factorialByRecursion.html* programs.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: In the case of our tail call `factorial()` function, a new parameter named `accum`
    follows the calculated product as recursive function calls are made. This is known
    as an *accumulator* parameter, and it keeps track of a partial result of a calculation
    that would otherwise have been stored in a local variable. Not all tail recursive
    functions use accumulators, but they act as a workaround for tail recursion’s
    inability to use local variables after the final recursive call. Notice that in
    *factorialByRecursion.py*’s `factorial()` function, the recursive case was `return
    number * factorial(number - 1)`. The multiplication happens after the `factorial(number
    - 1)` recursive call. The `accum` accumulator takes the place of the `number`
    local variable.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that the base case for `factorial()` no longer returns `1`; rather,
    it returns the `accum` accumulator. By the time `factorial()` is called with `number
    == 1` and the base case is reached, `accum` stores the final result to return.
    Adjusting your code to use tail call optimization often involves changing the
    base case to return the accumulator’s value.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the `factorial(5)` function call as transforming into the following
    `return`, as shown in [Figure 8-1](#figure8-1).
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing the return statements produced by the factorial function
    called with an argument of 5, in order: “return factorial(5 - 1, 1* 5),” “return
    factorial(4 -1, 5 * 4),” “return factorial(3 - 1, 20 * 3),” “return factorial(2
    - 1, 60 * 2),” “return 120.”](image_fi/502024c08/f08001.png)'
  id: totrans-1217
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: The process of transformations that `factorial(5)` makes to the
    integer 120'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: Rearranging your recursive calls as the last action in the function and adding
    accumulators can make your code even harder to understand than typical recursive
    code. But that’s not the only downside of tail recursion, as we’ll see in the
    next section.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Tail Recursion
  id: totrans-1220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tail recursive functions require rearranging their code to make them suitable
    for the tail call optimization feature of the compiler or interpreter. However,
    not all compilers and interpreters offer tail call optimization as a feature.
    Notably, CPython (the Python interpreter downloaded from [https://python.org](https://python.org))
    does not implement tail call optimization. Even if you write your recursive functions
    with the recursive call as the last action, it will still cause stack overflows
    after enough function calls are made.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, but CPython will likely never have tail call optimization as
    a feature. Guido van Rossum, the creator of the Python programming language, has
    explained that tail call optimization can make programs harder to debug. Tail
    call optimization removes frame objects from the call stack, which in turn removes
    the debugging information that frame objects can provide. He also points out that
    once tail call optimization is implemented, Python programmers will begin to write
    code that depends on the feature, and their code won’t run on non-CPython interpreters
    that don’t implement tail call optimization.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: Finally, and I concur, van Rossum disagrees with the idea that recursion is
    a fundamentally important part of day-to-day programming. Computer scientists
    and mathematicians tend to place recursion on a pedestal. But tail call optimization
    is simply a workaround hack to make some recursive algorithms actually workable,
    rather than simply crashing with a stack overflow.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: While CPython doesn’t feature tail call optimization, this doesn’t mean another
    compiler or interpreter that implements the Python language couldn’t have tail
    call optimization. Unless tail call optimization is explicitly a part of a programming
    language specification, it is not a feature of a programming language, but rather
    of individual compilers or interpreters of a programming language.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: The lack of tail call optimization is not unique to Python. The Java compiler
    since version 8 also doesn’t support tail call optimization. Tail call optimization
    is a part of the ECMAScript 6 version of JavaScript; however, as of 2022, only
    the Safari web browser’s implementation of JavaScript actually supports it. One
    way to determine whether your programming language’s compiler or interpreter implements
    this feature is to write a tail recursive factorial function and try to calculate
    the factorial of 100,000\. If the program crashes, tail call optimization is not
    implemented.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I take the stance that the tail recursion technique should never
    be used. As stated in Chapter 2, any recursive algorithm can be implemented with
    a loop and a stack. Tail call optimization prevents stack overflows by effectively
    removing the use of the call stack. Therefore, all tail recursive algorithms can
    be implemented with a loop alone. Since the code for loops is much simpler than
    a recursive function, a loop should be used wherever tail call optimization could
    be employed.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, potential problems exist even if tail call optimization is implemented.
    Since tail recursion is possible only when the last action of a function is returning
    the recursive call’s return value, it’s impossible to do tail recursion for algorithms
    that require two or more recursive calls. For example, take the Fibonacci sequence
    algorithm calls `fibonacci(n - 1)` and `fibonacci(n - 2)`. While tail call optimization
    can be performed for the latter recursive call, the first recursive call will
    cause a stack overflow for large-enough arguments.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: Tail Recursion Case Studies
  id: totrans-1228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s examine some of the recursive functions demonstrated earlier in this book
    to see if they are good candidates for tail recursion. Keep in mind that because
    Python and JavaScript do not actually implement tail call optimization, these
    tail recursive functions will still result in a stack overflow error. These case
    studies are for demonstration purposes only.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: Tail Recursive Reverse String
  id: totrans-1230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first example is the program to reverse a string that we made in Chapter
    3. The Python code for this tail recursive function is in *reverseStringTailCall.py*:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The JavaScript equivalent is in *reverseStringTailCall.html*:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-1236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The conversion of the original recursive functions in *reverseString.py* and
    *reverseString.html* involves adding an accumulator parameter. The accumulator,
    named `accum`, is set to the blank string by default if no argument is passed
    for it ❶. We also change the base case from `return ''` to `return accum` ❷, and
    the recursive case from `return rev(tail) + head` (which performs a string concatenation
    after the recursive call returns) to `return rev(tail, head + accum)` ❸. You can
    think of the `rev('abcdef')` function call as transforming into the following
    `return`, as shown in [Figure 8-2](#figure8-2).
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: By effectively using the accumulator as a local variable shared across function
    calls, we can make the `rev()` function tail recursive.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing the return statements produced by the rev() function called
    with an argument of abcdef, in order: “return rev(‘bcdef’, ‘a’, + ‘’),” “return
    rev(‘cdef’, ‘b’ + ‘a’),” “return rev(‘def’, ‘c’ + ‘ba’),” “return rev(‘ef’, ‘d’
    + ‘cba’),” “return rev(‘f’, ‘e’ + ‘dcba’),” “return rev(‘’, ‘f’, ‘edcba’),” “return
    ‘fedcba’.”](image_fi/502024c08/f08002.png)'
  id: totrans-1239
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: The process of transformations that `rev(''abcdef'')` makes to
    the string `fedcba`'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: Tail Recursive Find Substring
  id: totrans-1241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some recursive functions naturally end up using the tail recursion pattern.
    If you look at the `findSubstringRecursive()` function in the *findSubstring.py*
    and *findSubstring.html* programs in Chapter 2, you’ll notice that the last action
    for the recursive case is to return the value of the recursive function call.
    No adjustments are needed to make this function tail recursive.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: Tail Recursive Exponents
  id: totrans-1243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *exponentByRecursion.py* and *exponentByRecursion.html* programs, also
    from Chapter 2, are not good candidates for tail recursion. These programs have
    two recursive cases for when the `n` parameter is even or odd. This is fine: as
    long as all the recursive cases return the return value of the recursive function
    call as their last action, the function can use tail call optimization.'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: 'However, notice the Python code for the `n is even` recursive case:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-1247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'And notice the equivalent JavaScript recursive case:'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'This recursive case does not have the recursive call as its last action. We
    could get rid of the `result` local variable, and instead call the recursive function
    twice. This would reduce the recursive case to the following:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'However, now we have two recursive calls to `exponentByRecursion()`. Not only
    does this needlessly double the amount of computation the algorithm performs,
    but the last action performed by the function is to multiply the two return values.
    This is the same problem the recursive Fibonacci algorithm has: if the recursive
    function has multiple recursive calls, at least one of those recursive calls can’t
    be the last action of the function.'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: Tail Recursive Odd-Even
  id: totrans-1254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To determine whether an integer is odd or even, you can use the `%` modulus
    operator. The expression `number % 2 == 0` will be `True` if `number` is even,
    and `False` if `number` is odd. However, if you’d prefer to overengineer a more
    “elegant” recursive algorithm, you can implement the following `isOdd()` function
    in *isOdd.py* (the rest of *isOdd.py* is presented later in this section):'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'The JavaScript equivalent is in *isOdd.html*:'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-1260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: We have two base cases for `isOdd()`. When the `number` argument is `0`, the
    function returns `False` to indicate *even*. For simplicity, our implementation
    of `isOdd()` works for only positive integers. The recursive case returns the
    opposite of `isOdd(number - 1)`.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see why this works with an example: when `isOdd(42)` is called, the
    function can’t determine if `42` is even or odd but does know that the answer
    is the opposite of whether `41` is odd or even. The function will return `not
    isOdd(41)`. This function call, in turn, returns the opposite Boolean value of
    `isOdd(40)`, and so on, until `isOdd(0)` returns `False`. The number of recursive
    function calls determines the number of `not` operators that act on return values
    before the final return value is returned.'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this recursive function results in stack overflows for large-number
    arguments. Calling `isOdd(100000)` results in 100,001 function calls without returning—which
    far exceeds the capacity of any call stack. We can rearrange the code in the function
    so that the last action of the recursive case is returning the results of the
    recursive function call, making the function tail recursive. We do this in `isOddTailCall()`
    in *isOdd.py*. Here is the rest of the *isOdd.py* program:'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The JavaScript equivalent is in the rest of *isOdd.html*:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: If this Python and JavaScript code is run by an interpreter that supports tail
    call optimization, calling `isOddTailCall(100000)` won’t result in a stack overflow.
    However, tail call optimization is still much slower than simply using the `%`
    modulus operator to determine oddness or evenness.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: If you think recursion, with or without tail recursion, is an incredibly inefficient
    way to determine whether a positive integer is odd, you are absolutely correct.
    Unlike iterative solutions, recursion can fail from stack overflows. Adding tail
    call optimization to prevent stack overflows doesn’t fix the efficiency flaws
    of using recursion inappropriately. As a technique, recursion is not automatically
    better or more sophisticated than iterative solutions. And tail recursion is never
    a better approach than a loop or other simple solution.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tail call optimization is a feature of a programming language’s compiler or
    interpreter that can be employed on recursive functions specifically written to
    be tail recursive. Tail recursive functions return the return value of the recursive
    function call as the last action in the recursive case. This allows the function
    to delete the current frame object and prevent the call stack from growing as
    new recursive function calls are made. If the call stack doesn’t grow, the recursive
    function can’t possibly cause a stack overflow.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursion is a workaround that allows some recursive algorithms to work
    with large arguments without crashing. However, this approach requires rearranging
    your code and possibly adding an accumulator parameter. This could make your code
    harder to understand. You may likely find that sacrificing code readability is
    not worth using a recursive algorithm over an iterative one.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-1274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stack Overflow (the website, not the programming error) has a detailed discussion
    about the basics of tail recursion at [https://stackoverflow.com/questions/33923/what-is-tail-recursion](https://stackoverflow.com/questions/33923/what-is-tail-recursion).
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: Van Rossum wrote about his decision not to use tail recursion in two blog posts
    at [https://neopythonic.blogspot.com.au/2009/04/tail-recursion-elimination.html](https://neopythonic.blogspot.com.au/2009/04/tail-recursion-elimination.html)
    and [https://neopythonic.blogspot.com.au/2009/04/final-words-on-tail-calls.html](https://neopythonic.blogspot.com.au/2009/04/final-words-on-tail-calls.html).
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: Python’s standard library includes a module called `inspect` that allows you
    to view the frame objects on the call stack as a Python program is running. The
    official documentation for the `inspect` module is at [https://docs.python.org/3/library/inspect.html](https://docs.python.org/3/library/inspect.html),
    and a tutorial on Doug Hellmann’s Python 3 Module of the Week blog is at [https://pymotw.com/3/inspect](https://pymotw.com/3/inspect).
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  id: totrans-1278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: What does tail call optimization prevent?
  id: totrans-1280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the last action of a recursive function have to do so that the function
    can be tail recursive?
  id: totrans-1281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do all compilers and interpreters implement tail call optimization?
  id: totrans-1282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an accumulator?
  id: totrans-1283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the disadvantage of tail recursion?
  id: totrans-1284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can the quicksort algorithm (covered in Chapter 5) be rewritten to use tail
    call optimization?
  id: totrans-1285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '9'
  id: totrans-1286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drawing Fractals
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-1288
  prefs: []
  type: TYPE_IMG
- en: Certainly, the most fun application of recursion is drawing fractals. *Fractals*
    are shapes that repeat themselves, sometimes chaotically, at different scales.
    The term was coined by the founder of fractal geometry, Benoit B. Mandelbrot,
    in 1975 and is derived from the Latin *frāctus*, meaning broken or fractured,
    like shattered glass. Fractals include many natural and artificial shapes. In
    nature, you might see them in the shapes of trees, fern leaves, mountain ranges,
    lightning bolts, coastlines, river networks, and snowflakes. Mathematicians, programmers,
    and artists can create elaborate geometric shapes based on a few recursive rules.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: Recursion can produce elaborate fractal art using surprisingly few lines of
    code. This chapter covers Python’s built-in `turtle` module for generating several
    common fractals with code. To create turtle graphics with JavaScript, you can
    use Greg Reimer’s `jtg` library. For simplicity, this chapter presents only the
    Python fractal drawing programs and not the JavaScript equivalents. However, the
    `jtg` JavaScript library is covered in this chapter.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: Turtle Graphics
  id: totrans-1291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Turtle graphics* were a feature of the Logo programming language designed
    to help kids learn coding concepts. The feature has since been reproduced in many
    languages and platforms. Its central idea is an object called a *turtle*.'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: The turtle acts as a programmable pen that draws lines in a 2D window. Imagine
    an actual turtle holding a pen on the ground, drawing a line behind it as it moves
    around. The turtle can adjust the size and color of its pen, or “raise the pen”
    so that it does not draw as it moves. Turtle programs can produce intricate geometric
    drawings such as [Figure 9-1](#figure9-1).
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: 'When you put these instructions inside loops and functions, even small programs
    can create impressive geometric drawings. Consider the following *spiral.py* program:'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: When you run this program, the turtle window opens. The turtle (represented
    by a triangle) will trace the spiral pattern in [Figure 9-1](#figure9-1). While
    not a fractal, it is a beautiful drawing.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a small triangle icon tracing overlapping lines across the
    window. The lines create a spiral pattern.](image_fi/502024c09/f09001.png)'
  id: totrans-1298
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: The spiral drawn by the program using Python’s `turtle` module'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: The window in a turtle graphics system uses Cartesian x- and y-coordinates.
    The number for the horizontal x-coordinate increases going right and decreases
    going left, while the number for the vertical y-coordinate increases going up
    and decreases going down. These two coordinates together can provide a unique
    address for any point in the window. By default, the *origin* (the x, y coordinate
    point at 0, 0) is in the center of the window.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: The turtle also has a *heading*, or direction, that is a number from 0 to 359
    (a circle is split into 360 degrees). In Python’s `turtle` module, a heading of
    0 faces east (toward the right edge of the screen) and increases clockwise; a
    heading of 90 faces north, a heading of 180 faces west, and a heading of 270 faces
    south. In the JavaScript `jtg` library, this orientation is rotated so that 0
    degrees faces north and increases counterclockwise. [Figure 9-2](#figure9-2) demonstrates
    the headings for the Python `turtle` module and the JavaScript `jtg` library.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: '![Two compass diagrams indicating the headings for the turtle module and jtg
    library. The turtle module headings, clockwise from top: 90, 45, 0, 315, 270,
    225, 180, 135\. The jtg library headings, clockwise from top: 0, 45, 90, 135,
    180, 225, 270, 315.](image_fi/502024c09/F09002.png)'
  id: totrans-1302
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: The headings in Python’s `turtle` module (left) and the JavaScript
    `jtg` library (right)'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: 'In the JavaScript `jtg` library at [https://inventwithpython.com/jtg](https://inventwithpython.com/jtg),
    enter the following code into the text field at the bottom of the page:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-1306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This draws the same spiral shown in [Figure 9-1](#figure9-1) on the main area
    of the web page.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: Basic Turtle Functions
  id: totrans-1308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most commonly used functions in turtle graphics cause the turtle to change
    heading and move forward or backward. The `turtle.left()` and `turtle.right()`
    functions rotate the turtle a certain number of degrees starting from its current
    heading, while the `turtle.forward()` and `turtle.backward()` functions move the
    turtle based on its current position.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-1](#table9-1) lists some of the turtle’s functions. The first function
    (beginning with `turtle.`) is for Python, and the second (beginning with `t.`)
    is for JavaScript. The full Python documentation is available at [https://docs.python.org/3/library/turtle.html](https://docs.python.org/3/library/turtle.html).
    In the JavaScript `jtg` software, you can press F1 to display the help screen.'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9-1: Turtle Functions in Python’s `turtle` Module and JavaScript’s `jtg`
    Library'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** | **Description** |'
  id: totrans-1312
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1313
  prefs: []
  type: TYPE_TB
- en: '| `goto(``x``,` `y``)` | `xy(``x``,` `y``)` | Moves the turtle to the x, y
    coordinates. |'
  id: totrans-1314
  prefs: []
  type: TYPE_TB
- en: '| `setheading(``deg``)` | `heading(``deg``)` | Sets the turtle’s heading. In
    Python, 0 degrees is east (right). In JavaScript, 0 degrees is north (up). |'
  id: totrans-1315
  prefs: []
  type: TYPE_TB
- en: '| `forward(``steps``)` | `fd(``steps``)` | Moves the turtle a number of steps
    forward in the heading it is facing. |'
  id: totrans-1316
  prefs: []
  type: TYPE_TB
- en: '| `backward(``steps``)` | `bk(``steps``)` | Moves the turtle a number of steps
    in the heading opposite from the one it is facing. |'
  id: totrans-1317
  prefs: []
  type: TYPE_TB
- en: '| `left(``deg``)` | `lt(``deg``)` | Turns the turtle’s heading to the left.
    |'
  id: totrans-1318
  prefs: []
  type: TYPE_TB
- en: '| `right(``deg``)` | `rt(``deg``)` | Turns the turtle’s heading to the right.
    |'
  id: totrans-1319
  prefs: []
  type: TYPE_TB
- en: '| `penup()` | `pu()` | “Raises the pen” so that the turtle stops drawing as
    it moves. |'
  id: totrans-1320
  prefs: []
  type: TYPE_TB
- en: '| `pendown()` | `pd()` | “Lowers the pen” so that the turtle starts drawing
    as it moves. |'
  id: totrans-1321
  prefs: []
  type: TYPE_TB
- en: '| `pensize(``size``)` | `thickness(``size``)` | Changes the thickness of the
    lines the turtle draws. The default is `1`. |'
  id: totrans-1322
  prefs: []
  type: TYPE_TB
- en: '| `pencolor(``color``)` | `color(``color``)` | Changes the color of the lines
    the turtle draws. This can be a string of a common color such as `red` or `white`.
    The default is `black`. |'
  id: totrans-1323
  prefs: []
  type: TYPE_TB
- en: '| `xcor()` | `get.x()` | Returns the turtle’s current x position. |'
  id: totrans-1324
  prefs: []
  type: TYPE_TB
- en: '| `ycor()` | `get.y()` | Returns the turtle’s current y position. |'
  id: totrans-1325
  prefs: []
  type: TYPE_TB
- en: '| `heading()` | `get.heading()` | Returns the turtle’s current heading as a
    floating-point number from 0 to 359\. In Python, 0 degrees is east (right). In
    JavaScript, 0 degrees is north (up). |'
  id: totrans-1326
  prefs: []
  type: TYPE_TB
- en: '| `reset()` | `reset()` | Clears any drawn lines, and moves the turtle back
    to the original position and heading. |'
  id: totrans-1327
  prefs: []
  type: TYPE_TB
- en: '| `clear()` | `clean()` | Clears any drawn lines but doesn’t move the turtle.
    |'
  id: totrans-1328
  prefs: []
  type: TYPE_TB
- en: The functions listed in [Table 9-2](#table9-2) are available only in the Python
    `turtle` module.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9-2: Python-Only Turtle Functions'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **Description** |'
  id: totrans-1331
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1332
  prefs: []
  type: TYPE_TB
- en: '| `begin_fill()` | Begins drawing a filled-in shape. The lines drawn after
    this call will specify the perimeter of the filled-in shape. |'
  id: totrans-1333
  prefs: []
  type: TYPE_TB
- en: '| `end_fill()` | Draws the filled-in shape that was started with the call to
    `turtle.begin_fill()`. |'
  id: totrans-1334
  prefs: []
  type: TYPE_TB
- en: '| `fillcolor(``color``)` | Sets the color used for filled-in shapes. |'
  id: totrans-1335
  prefs: []
  type: TYPE_TB
- en: '| `hideturtle()` | Hides the triangle that represents the turtle. |'
  id: totrans-1336
  prefs: []
  type: TYPE_TB
- en: '| `showturtle()` | Shows the triangle that represents the turtle. |'
  id: totrans-1337
  prefs: []
  type: TYPE_TB
- en: '| `tracer(``drawingUpdates``,` `delay``)` | Adjusts the speed of drawing. Pass
    `0` for `delay` for a delay of 0 milliseconds after each line the turtle draws.
    The larger the number passed for `drawingUpdates`, the faster the turtle draws
    by increasing the number of drawings before the module updates the screen. |'
  id: totrans-1338
  prefs: []
  type: TYPE_TB
- en: '| `update()` | Draws any buffered lines (explained later in this section) to
    the screen. Call this after the turtle has completed drawing. |'
  id: totrans-1339
  prefs: []
  type: TYPE_TB
- en: '| `setworldcoordinates(``llx``,` `lly``,` `urx,``ury``)` | Readjusts which
    part of the coordinate plane the window shows. The first two arguments are the
    x, y coordinates for the lower-left corner of the window. The latter two arguments
    are the x, y coordinates for the upper-right corner of the window. |'
  id: totrans-1340
  prefs: []
  type: TYPE_TB
- en: '| `exitonclick()` | Pauses the program and closes the window when the user
    clicks anywhere. Without this at the end of your program, the turtle graphics
    window may close as soon as the program ends. |'
  id: totrans-1341
  prefs: []
  type: TYPE_TB
- en: In Python’s `turtle` module, lines are displayed on the screen immediately.
    However, this can slow programs that draw thousands of lines. It’s faster to *buffer*—that
    is, hold off displaying several lines and then display them all at once.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: By calling `turtle.tracer(1000, 0)`, you can instruct the `turtle` module to
    hold off displaying lines until 1,000 lines have been created by your program.
    After your program has finished calling line-drawing functions, make a final call
    to `turtle.update()` to display any remaining buffered lines to the screen. If
    your program is still taking too long to draw an image, pass a larger integer
    such as `2000` or `10000` as the first argument to `turtle.tracer()`.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: The Sierpiński Triangle
  id: totrans-1344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest fractal to draw on paper is the *Sierpiński triangle*, introduced
    in Chapter 1. This fractal was described by Polish mathematician Wacław Sierpiński
    in 1915 (predating even the term *fractal*). However, the pattern is at least
    hundreds of years older.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: To create a Sierpiński triangle, start by drawing an equilateral triangle—a
    triangle with equal-length sides, like the one on the left in [Figure 9-3](#figure9-3).
    Then draw an upside-down equilateral triangle inside the first triangle, as on
    the right in [Figure 9-3](#figure9-3). You’ll form a shape that, if you’re familiar
    with the *Legend of Zelda* video games, looks like the Triforce.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphic depicting four equilateral triangles. The second triangle has a smaller
    triangle in the center that breaks the shape into four smaller triangles. In the
    third triangle, each of the three outer triangles is broken into smaller triangles.
    the fourth triangle shows those smaller triangles further broken into even smaller
    triangles.](image_fi/502024c09/f09003.png)'
  id: totrans-1347
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: An equilateral triangle (left) with an upside-down triangle added
    to form a Sierpiński triangle, with additional triangles recursively added'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: An interesting thing happens when you draw the inner, upside-down triangle.
    You form three new, right-side-up equilateral triangles. Inside each of these
    three triangles, you can draw another upside-down triangle, which will create
    nine triangles. This recursion can continue forever mathematically, though in
    reality your pen won’t be able to keep drawing tinier triangles.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: 'This property, describing a full object that is similar to a part of itself,
    is called *self-similarity*. Recursive functions can produce these objects, since
    they “call” themselves again and again. Practically, this code must hit a base
    case eventually, but mathematically, these shapes have infinite resolution: you
    could theoretically zoom in on the shape forever.'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write a recursive program to create the Sierpiński triangle. The recursive
    `drawTriangle()` function will draw an equilateral triangle, and then recursively
    call this function three times to draw the inner equilateral triangles, as in
    [Figure 9-4](#figure9-4). The `midpoint()` function finds the point equidistant
    from two points passed to the function. This will be important as the inner triangles
    use these equidistant points for their vertices.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of an equilateral triangle drawn three times using dotted lines.
    Solid lines isolate a different, smaller equilateral triangle in each of the larger
    triangles. These smaller triangles each share a different vertex with the larger
    triangle and have a side length of one-half the larger triangle’s.](image_fi/502024c09/f09004.png)'
  id: totrans-1352
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-4: The three inner triangles, with midpoints shown with large dots'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this program calls `turtle.setworldcoordinates(0, 0, 700, 700)`,
    which makes the 0, 0 origin at the lower-left corner of the window. The upper-right
    corner has the x, y coordinates 700, 700\. The source code for *sierpinskiTriangle.py*
    is as follows:'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: When you run this code, the output looks like [Figure 9-5](#figure9-5).
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a Sierpiński triangle drawn in the turtle module.](image_fi/502024c09/f09005.png)'
  id: totrans-1357
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-5: A standard Sierpiński triangle'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: Sierpiński triangles don’t have to be drawn with equilateral triangles. As long
    as you use the midpoints of the outer triangle to draw the inner triangles, you
    can use any kind of triangle. Comment out the first `drawTriangle()` call and
    uncomment the second one (under the `# Draw a skewed Sierpinski triangle.` comment)
    and run the program again. The output will look like [Figure 9-6](#figure9-6).
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a Sierpiński triangle drawn using irregular triangles with
    the turtle module. The image looks like an equilateral Sierpiński viewed at an
    angle.](image_fi/502024c09/f09006.png)'
  id: totrans-1360
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-6: A skewed Sierpiński triangle'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: The `drawTriangle()` function takes six arguments corresponding to the x, y
    coordinates of the triangle’s three points. Try experimenting with different values
    to adjust the shape of the Sierpiński triangle. You can also change the `MIN_SIZE`
    constant to a larger value to make the program reach the base case sooner and
    reduce the number of triangles drawn.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: The Sierpiński Carpet
  id: totrans-1363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A fractal shape similar to the Sierpiński triangle can be drawn using rectangles
    instead. This pattern is known as the *Sierpiński carpet*. Imagine splitting a
    black rectangle into a 3 × 3 grid, then “cutting out” the center rectangle. Repeat
    this pattern in the surrounding eight rectangles of the grid. When this is done
    recursively, you end up with a pattern like [Figure 9-7](#figure9-7).
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a black rectangle containing a pattern of white rectangles
    of various sizes. Drawn with the turtle module.](image_fi/502024c09/f09007.png)'
  id: totrans-1365
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-7: The Sierpiński carpet'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: The Python program that draws the carpet uses the `turtle.begin_fill()` and
    `turtle.end_fill()` functions to create solid, filled-in shapes. The lines that
    the turtle draws between these calls are used to draw the shape, as in [Figure
    9-8](#figure9-8).
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: '![Three diagrams representing the steps the turtle takes to draw a filled-in
    rectangle. The first shape shows the turtle traveling in a path that draws three
    sides of a rectangle. The second diagram shows the turtle completing the rectangle.
    The third diagram shows the rectangle filled in.](image_fi/502024c09/f09008.png)'
  id: totrans-1368
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-8: Calling `turtle.begin_fill()`, drawing a path, and calling `turtle.end_fill()`
    creates a filled-in shape.'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: 'The base case is reached when the rectangles of the 3 × 3 become smaller than
    six steps on a side. You can change the `MIN_SIZE` constant to a larger value
    to make the program reach the base case sooner. The source code for *sierpinskiCarpet.py*
    is as follows:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-1371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: You can also set the `DRAW_SOLID` constant to `False` and run the program. This
    will skip the calls to `turtle.begin_fill()` and `turtle.end_fill()` so that only
    the outlines of the rectangles are drawn, as in [Figure 9-9](#figure9-9).
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: Try passing different arguments to `drawCarpet()`. The first two arguments are
    the x, y coordinates of the lower-left corner of the carpet, while the latter
    two arguments are the width and height. You can also change the `MIN_SIZE` constant
    to a larger value to make the program reach the base case sooner and reduce the
    number of rectangles drawn.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics screenshot showing a version of the Sierpiński carpet in
    which none of the rectangles are filled in.](image_fi/502024c09/f09009.png)'
  id: totrans-1374
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-9: The Sierpiński carpet, with only the outlines of the rectangles
    drawn'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: Another 3D Sierpiński carpet uses cubes instead of squares. In this form, it
    is called a *Sierpiński cube*, or *Menger sponge*. It was first described by mathematician
    Karl Menger in 1926\. [Figure 9-10](#figure9-10) shows a Menger sponge created
    in the video game *Minecraft*.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: '![Image of a cube viewed at an angle. The visible sides of the cube have squares
    cut out of them in the pattern of a Sierpiński carpet.](image_fi/502024c09/f09010.png)'
  id: totrans-1377
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-10: A 3D Menger sponge fractal'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: Fractal Trees
  id: totrans-1379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the artificial fractals such as the Sierpiński triangle and carpet are
    perfectly self-similar, fractals can include shapes that do not have perfect self-similarity.
    Fractal geometry, as envisioned by mathematician Benoit B. Mandelbrot (whose middle
    initial recursively stands for Benoit B. Mandelbrot) included natural shapes such
    as mountains, coastlines, plants, blood vessels, and the clustering of galaxies
    as fractals. Upon close examination, these shapes continued to consist of “rougher”
    shapes not easily contained by the smooth curves and straight lines of simplified
    geometry.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we can use recursion to reproduce *fractal trees*, whether perfectly
    or imperfectly self-similar. Generating trees requires creating a branch with
    two child branches that issue from their parent at set angles and decrease at
    set lengths. The Y shape that they produce is recursively repeated to create a
    convincing drawing of a tree, as in Figures 9-11 and 9-12.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics screenshot showing a drawing that resembles a leafless tree.
    The branches of the tree lean toward the left and become progressively smaller,
    creating a rounded, asymmetrical shape.](image_fi/502024c09/f09011.png)'
  id: totrans-1382
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-11: A perfectly self-similar fractal tree generated with the left
    and right branches using consistent angles and lengths'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: Movies and video games can use such recursive algorithms in *procedural generation*,
    the automatic (rather than manual) creation of 3D models such as trees, ferns,
    flowers, and other plants. Using algorithms, computers can quickly create entire
    forests consisting of millions of unique trees, saving an army of human 3D artists
    the painstaking effort.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics screenshot showing a drawing that resembles a leafless tree.
    The tree’s branches vary in length and direction of branching, sometimes overlapping.](image_fi/502024c09/f09012.png)'
  id: totrans-1385
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-12: A more realistic tree created using random changes to branch angle
    and lengths'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: 'Our fractal tree program displays a new, randomly generated tree every two
    seconds. The source code for *fractalTree.py* is as follows:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: This program produces perfectly self-similar trees, as the `LEFT_ANGLE`, `LEFT_DECREASE`,
    `RIGHT_ANGLE`, and `RIGHT_DECREASE` variables are initially randomly chosen but
    stay constant for all the recursive calls. The `random.seed()` function sets a
    seed value for Python’s random functions. The *random number seed value* causes
    the program to produce random-seeming numbers, but it uses the same sequence of
    random numbers for each branch of the tree. In other words, the same *seed* value
    reproduces the same *tree* each time you run the program. (I never apologize for
    my puns.)
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, enter the following into the Python interactive shell:'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: In this example, we set the random seed to 42\. When we generate 20 random integers,
    we get `1`, `0`, `4`, `3`, and so on. We can generate another 20 integers and
    continue to receive random integers. However, if we reset the seed to `42` and
    generate 20 random integers again, they’ll be the same “random” integers as before.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like to create a more natural, less self-similar tree, replace the
    lines after the `# Record the position of the branch''s end.` comment with the
    following lines. This generates new random angles and branch lengths for *every*
    recursive call, which is closer to the way trees grow in nature:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: You can experiment with different ranges for the `random.randint()` call, or
    try adding more recursive calls instead of just the two for the two branches.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: How Long Is the Coast of Great Britain? The Koch Curve and Snowflake
  id: totrans-1399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before I tell you about the Koch curve and snowflake, consider this question:
    how long is the coast of Great Britain? Look at [Figure 9-13](#figure9-13). The
    map on the left has a rough measure, which puts the coast at about 2,000 miles.
    But the map on the right has a more precise measure, which includes more nooks
    and crannies of the coast and comes to about 2,800 miles.'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: '![Two screenshots of maps of Great Britain. In the first, the outline of the
    coast is approximated using straight-line segments to connect various points along
    the country’s outline. In the second, more points are added, increasing the number
    of line segments used.](image_fi/502024c09/f09013b.png)'
  id: totrans-1401
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-13: The island of Great Britain, with a rough measure (left) and more
    precise measure (right). Measuring the coast more precisely adds 800 miles to
    its length.'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: Mandelbrot’s key insight about fractals such as the coastline of Britain is
    that you can continue to look closer and closer, and there will continue to be
    “roughness” at every scale. So, as your measurement gets finer and finer, the
    length of the coastline will get longer and longer. The “coast” will follow the
    Thames upriver, deep into the landmass along one bank and back out to the English
    Channel on the other bank. Thus, the answer to our question of Great Britain’s
    coastline’s length is, “It depends.”
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: The *Koch curve* fractal has a similar property pertaining to the length of
    its coastline, or rather, perimeter. First introduced in 1902 by Swedish mathematician
    Helge von Koch, the Koch curve is one of the earliest fractals to be described
    mathematically. To construct it, take a line of length *b* and divide it into
    three equal parts, each of length *b* / 3\. Replace the middle section with a
    “bump” whose sides are also of length *b* / 3\. This bump causes the Koch curve
    to be longer than the original line, since we now have four line segments of length
    *b* / 3\. (We’ll exclude the original middle part of the line segment.) This bump
    creation can be repeated on the new four line segments. [Figure 9-14](#figure9-14)
    shows this construction.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: '![Three diagrams. The first is a line divided into three segments, each of
    length b/3\. The second diagram shows the middle segment replaced with two segments
    of length b/3 that angle upward, forming two sides of an equilateral triangle
    whose third side is the missing middle segment. The third diagram shows each of
    the segments of the second diagram altered according to the same pattern, creating
    an irregular, bumpy shape.](image_fi/502024c09/f09014.png)'
  id: totrans-1405
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-14: After splitting the line segment into three equal parts (left),
    add a bump to the middle part (right). We now have four segments of length *b*
    / 3, to which bumps can be added again (bottom).'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: To create the *Koch snowflake*, we start with an equilateral triangle and construct
    three Koch curves from its three sides, as in [Figure 9-15](#figure9-15).
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: '![Two diagrams: an equilateral triangle, and the same equilateral triangle
    whose sides have been replaced with Koch curves, forming a snowflake shape.](image_fi/502024c09/f09015.png)'
  id: totrans-1408
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-15: Creating three Koch curves on the three sides of an equilateral
    triangle to form a Koch snowflake'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: Each time you create a new bump, you are increasing the curve’s length from
    three *b* / 3 lengths to four *b* / 3 lengths, or 4*b* / 3\. If you continue to
    do this with the three sides of an equilateral triangle, you’ll create the Koch
    snowflake, as in [Figure 9-16](#figure9-16). (The small dotted patterns are artifacts,
    because slight rounding errors cause the `turtle` module to be unable to completely
    erase the middle *b* / 3 segment.) You can continue to create new bumps forever,
    though our program stops when they get smaller than a few pixels.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphic screenshot of a snowflake created using many Koch bumps.](image_fi/502024c09/f09016.png)'
  id: totrans-1411
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-16: A Koch snowflake. Some of the interior lines remain because of
    small rounding errors.'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for *kochSnowflake.py* is as follows:'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-1415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The Koch snowflake is also sometimes called the *Koch island*. Its coastline
    would be literally infinitely long. While the Koch snowflake fits into the finite
    area of a page of this book, the length of its perimeter is infinite, proving
    that, while it seems counterintuitive, the finite can contain the infinite!
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: The Hilbert Curve
  id: totrans-1417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *space-filling curve* is a 1D line that curves around until it completely
    fills a 2D space without crossing over itself. German mathematician David Hilbert
    described his space-filling *Hilbert curve* in 1891\. If you split a 2D area into
    a grid, the single, 1D line of the Hilbert curve can run through every cell in
    the grid.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-17](#figure9-17) contains the first three recursions of the Hilbert
    curve. The next recursion contains four copies of the previous recursion, and
    the dashed line shows how the four copies connect to one another.'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: '![Three diagrams. The first is a grid with four square cells. Three lines are
    drawn to connect the center points of the cells, forming three sides of a square
    in the center of the grid. The second diagram shows each cell of the original
    grid subdivided into four cells and the same lines drawn across each of those
    cells. The fourth shows the cells further subdivided and populated by the same
    line pattern.](image_fi/502024c09/f09017.png)'
  id: totrans-1420
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-17: The first three recursions of the Hilbert space-filling curve'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: As the cells become infinitesimal points, the 1D curve can fill the entire 2D
    space the same way a 2D square does. Counterintuitively, this creates a 2D shape
    from a strictly 1D line!
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for *hilbertCurve.py* is as follows:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-1425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Try experimenting with this code by decreasing `LINE_LENGTH` to shorten the
    line segments while increasing `LEVELS` to add more levels of recursion. Because
    this program uses only relative movements for the turtle, you can uncomment the
    `turtle.setheading(20)` line to draw the Hilbert curve at a 20-degree angle. [Figure
    9-18](#figure9-18) shows the drawing produced with `LINE_LENGTH` of `10` and `LEVELS`
    of `5`.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics screenshot. The entire window is covered in a Hilbert curve.](image_fi/502024c09/f09018.png)'
  id: totrans-1427
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-18: Five levels of the Hilbert curve, with line length `10`'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: The Hilbert curve makes 90-degree (right-angle) turns. But try adjusting the
    `ANGLE` variable by a few degrees to `89` or `86`, and run the program to view
    the changes. You can also set the `DRAW_SOLID` variable to `True` to produce a
    filled-in Hilbert curve, as in [Figure 9-19](#figure9-19).
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics screenshot of the same Hilbert curve drawing, this time with
    the black and white portions reversed.](image_fi/502024c09/f09019.png)'
  id: totrans-1430
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-19: Six levels of the Hilbert curve, filled in, with line length `5`'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The incredibly wide field of fractals combines all the most interesting parts
    of programming and art, making this chapter the most fun to write. Mathematicians
    and computer scientists talk about the beauty and elegance that the advanced topics
    of their fields produce, but recursive fractals are able to turn this conceptual
    beauty into visual beauty that anyone can appreciate.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covered several fractals and the programs that draw them: the
    Sierpiński triangle, the Sierpiński carpet, procedurally generated fractal trees,
    the Koch curve and snowflake, and the Hilbert curve. All of these were drawn with
    Python’s `turtle` module and functions that recursively call themselves.'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-1435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about drawing with Python’s `turtle` module, I’ve written a simple
    tutorial at [https://github.com/asweigart/simple-turtle-tutorial-for-python](https://github.com/asweigart/simple-turtle-tutorial-for-python).
    I also have a personal collection of turtle programs at [https://github.com/asweigart/art-of-turtle-programming](https://github.com/asweigart/art-of-turtle-programming).
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: The question of Great Britain’s coastline’s length came from the title of a
    1967 paper by Mandelbrot. The idea is summarized nicely on Wikipedia at [https://en.wikipedia.org/wiki/Coastline_paradox](https://en.wikipedia.org/wiki/Coastline_paradox).
    Khan Academy has more on the geometry of the Koch snowflake at [https://www.khanacademy.org/math/geometry-home/geometry-volume-surface-area/koch-snowflake/v/koch-snowflake-fractal](https://www.khanacademy.org/math/geometry-home/geometry-volume-surface-area/koch-snowflake/v/koch-snowflake-fractal).
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: 'The 3Blue1Brown YouTube channel has excellent animations of fractals, particularly
    the “Fractals Are Typically Not Self-Similar” video at [https://youtu.be/gB9n2gHsHN4](https://youtu.be/gB9n2gHsHN4)
    and the “Fractal Charm: Space-Filling Curves” video at [https://youtu.be/RU0wScIj36o](https://youtu.be/RU0wScIj36o).'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: Other space-filling curves require recursion to draw, such as the Peano curve,
    Gosper curve, and dragon curve, and they’re worth researching on the web.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  id: totrans-1440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: What are fractals?
  id: totrans-1442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do the x- and y-coordinates represent in a Cartesian coordinate system?
  id: totrans-1443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the origin coordinates in a Cartesian coordinate system?
  id: totrans-1444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is procedural generation?
  id: totrans-1445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a seed value?
  id: totrans-1446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How long is the perimeter of a Koch snowflake?
  id: totrans-1447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a space-filling curve?
  id: totrans-1448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practice Projects
  id: totrans-1449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For practice, write a program for each of the following tasks:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a turtle program that draws a box fractal as shown in [Figure 9-20](#figure9-20).
    This program is similar to the Sierpiński carpet program introduced in this chapter.
    Use the `turtle.begin_fill()` and `turtle.end_fill()` functions to draw the first
    large, black square. Then split this square into nine equal sections, and draw
    white squares in the top, left, right, and bottom squares. Repeat this process
    for the four corner squares and the center square.![Turtle graphics screenshot.
    Shows 25 black squares arranged so that they form five larger squares: one square
    in each corner and one square in the center. These five larger squares are arranged
    to form one even larger square.](image_fi/502024c09/f09020.png)'
  id: totrans-1451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9-20: A box fractal, drawn to two levels'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: Create a turtle program that draws a Peano space-filling curve. This is similar
    to the Hilbert curve program in this chapter. [Figure 9-21](#figure9-21) shows
    the first three iterations of the Peano curve. While each Hilbert curve iteration
    is split across a 2 × 2 section (which is, in turn, split into 2 × 2 sections),
    the Peano curve is split across 3 × 3 sections.![A straight line bent at right
    angles into a curve-like shape that travels through the center points of the square
    cells in a 3 × 3 grid. The other diagrams show similar curves traveling through
    the center points of increasingly larger grids.](image_fi/502024c09/f09021.png)
  id: totrans-1453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9-21: The first three iterations of the Peano curve, from left to right.
    The bottom row includes the 3 × 3 sections that each part of the curve is split
    across.`*``'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL

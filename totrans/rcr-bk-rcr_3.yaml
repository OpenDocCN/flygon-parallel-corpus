- en: Part I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UNDERSTANDING RECURSION
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Is Recursion?
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Recursion has an intimidating reputation. It’s considered hard to understand,
    but at its core, it depends on only two things: function calls and stack data
    structures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most new programmers trace through what a program does by following the execution.
    It’s an easy way to read code: you just put your finger on the line of code at
    the top of the program and move down. Sometimes your finger will loop back; other
    times, it will jump into a function and later return. This makes it easy to visualize
    what a program does and in what order.'
  prefs: []
  type: TYPE_NORMAL
- en: But to understand recursion, you need to become familiar with a less obvious
    data structure, called the *call stack*, that controls the program’s flow of execution.
    Most programming beginners don’t know about stacks, because programming tutorials
    often don’t even mention them when discussing function calls. Furthermore, the
    call stack that automatically manages function calls doesn’t appear anywhere in
    the source code.
  prefs: []
  type: TYPE_NORMAL
- en: It’s hard to understand something when you can’t see it and don’t know it exists!
    In this chapter, we’ll pull back the curtain to dispel the overblown notion that
    recursion is hard, and you’ll be able to appreciate the elegance underneath.
  prefs: []
  type: TYPE_NORMAL
- en: The Definition of Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin, let’s get the clichéd recursion jokes out of the way, starting
    with this: “To understand recursion, you must first understand recursion.”'
  prefs: []
  type: TYPE_NORMAL
- en: During the months I’ve spent writing this book, I can assure you that this joke
    gets funnier the more you hear it.
  prefs: []
  type: TYPE_NORMAL
- en: Another joke is that if you search Google for *recursion*, the results page
    asks if you mean *recursion*. Following the link, as shown in [Figure 1-1](#figure1-1),
    takes you to . . . the search results for *recursion*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a Google search for the term “recursion.” Below the search
    bar is a banner that reads, “Did you mean: recursion.”](image_fi/502024c01/f01001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: The Google search results for *recursion* link to the Google search
    results for *recursion*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-2](#figure1-2) shows a recursion joke from the webcomic xkcd.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A one-panel comic of someone reading the text “I’m so meta, even this acronym.”](image_fi/502024c01/f01002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: I’m So Meta, Even This Acronym (I.S. M.E.T.A.) ([xkcd.com/917](http://xkcd.com/917)
    by Randall Munroe)'
  prefs: []
  type: TYPE_NORMAL
- en: Most jokes about the 2010 science fiction action movie *Inception* are recursion
    jokes. The film features characters having dreams within dreams within dreams.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, what computer scientist could forget that monster from Greek mythology,
    the recursive centaur? As you can see in [Figure 1-3](#figure1-3), it is half
    horse, half recursive centaur.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image of a statue with a horse’s body whose front legs and torso repeat,
    decreasing in size, in a spiral pattern.](image_fi/502024c01/f01003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: The recursive centaur. Image by Joseph Parker.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these jokes, you might conclude that recursion is a sort of meta,
    self-referencing, dream-within-a-dream, infinite mirror-into-mirror sort of thing.
    Let’s establish a concrete definition: a *recursive* thing is something whose
    definition includes itself. That is, it has a self-referential definition.'
  prefs: []
  type: TYPE_NORMAL
- en: The Sierpiński triangle in [Figure 1-4](#figure1-4) is defined as an equilateral
    triangle with an upside-down triangle in the middle that forms three new equilateral
    triangles, each of which contains a Sierpiński triangle. The definition of Sierpiński
    triangles includes Sierpiński triangles.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphic depicting three triangles. The first triangle has a smaller upside-down
    triangle in the center that divides the original into smaller triangles. The next
    triangle shows those three smaller outer triangles, each divided into still smaller
    triangles. The third triangle shows those smaller triangles further divided into
    triangles.](image_fi/502024c01/f01004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-4: Sierpiński triangles are fractals (recursive shapes) that include
    Sierpiński triangles.'
  prefs: []
  type: TYPE_NORMAL
- en: In a programming context, a *recursive function* is a function that calls itself.
    Before we explore recursive functions, let’s take a step back and understand how
    regular functions work. Programmers tend to take function calls for granted, but
    even experienced programmers will find it worthwhile to review functions in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Functions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Functions* can be described as mini-programs inside your program. They’re
    a feature of nearly every programming language. If you need to run identical instructions
    at three different places in a program, instead of copying and pasting the source
    code three times you can write the code in a function once and call the function
    three times. The beneficial result is a shorter and more readable program. The
    program is also easier to change: if you need to fix a bug or add features, you
    need to change your program in only one place instead of three.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All programming languages implement four features in their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions have code that is run when the function is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Arguments* (that is, values) are passed to the function when it’s called.
    This is the input to the function, and functions can have zero or more arguments.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functions return a *return value*. This is the output of the function, though
    some programming languages allow functions not to return anything or to return
    null values like `undefined` or `None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program remembers which line of code called the function and returns to
    it when the function finishes its execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Different programming languages might have additional features, or different
    options for how to call functions, but they all have these four general elements.
    You can visually see the first three of these elements because you write them
    in the source code, but how does a program keep track of where the execution should
    return to when the function returns?
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better sense of the problem, create a *functionCalls.py* program that
    has three functions: `a()`, which calls `b()`, which calls `c()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is equivalent to the following *functionCalls.html* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the start of functions `a()`, `b()`, and `c()`. Then, when
    the functions return, the output appears in reverse order: `c()`, `b()`, and then
    `a()`. Notice the pattern to the text output: each time a function returns, it
    remembers which line of code originally called it. When the `c()` function call
    ends, the program returns to the `b()` function and displays `b() is returning`.
    Then the `b()` function call ends, and the program returns to the `a()` function
    and displays `a() is returning`. Finally, the program returns to the original
    `a()` function call at the end of the program. In other words, function calls
    don’t send the execution of the program on a one-way trip.'
  prefs: []
  type: TYPE_NORMAL
- en: But how does the program remember if it was `a()` or `b()` that called `c()`?
    This detail is handled by the program implicitly with a call stack. To understand
    how call stacks remember where the execution returns at the end of a function
    call, we need to first understand what a stack is.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Stacks?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier I mentioned the clichéd wisecrack, “To understand recursion, you must
    first understand recursion.” But this is actually wrong: to really understand
    recursion, you must first understand stacks.'
  prefs: []
  type: TYPE_NORMAL
- en: A *stack* is one of the simplest data structures in computer science. It stores
    multiple values like a list does—but unlike lists, it limits you to adding to
    or removing values from the “top” of the stack only. For stacks implemented with
    lists or arrays, the “top” is the last item, at the right end of the list or array.
    Adding values is called *pushing* values onto the stack, while removing values
    is called *popping* values off the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you’re engaged in a meandering conversation with someone. You’re
    talking about your friend Alice, which then reminds you of a story about your
    co-worker Bob, but for that story to make sense, you first have to explain something
    about your cousin Carol. You finish your story about Carol and go back to talking
    about Bob, and when you finish your story about Bob, you go back to talking about
    Alice. Then you are reminded about your brother David, so you tell a story about
    him. Eventually, you get around to finishing your original story about Alice.
  prefs: []
  type: TYPE_NORMAL
- en: Your conversation follows a stack-like structure, as in [Figure 1-5](#figure1-5).
    The conversation is stack-like because the current topic is always at the top
    of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![A timeline that shows names stacked one on top of the other at various points
    in time. It begins with no names, then shows Alice, then Bob on top of Alice,
    then Carol on top of Bob on top of Alice, then Bob on top of Alice, then just
    Alice, then David on top of Alice, then Just Alice once more, then no names.](image_fi/502024c01/f01005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-5: Your meandering conversation stack'
  prefs: []
  type: TYPE_NORMAL
- en: In our conversation stack, the new topics are added to the top of the stack
    and taken off as they are completed. The previous topics are “remembered” underneath
    the current topic in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: We can use Python lists as stacks if, to amend the list’s contents, we limit
    ourselves to the `append()` and `pop()` methods to perform pushing and popping.
    JavaScript arrays can also be used as stacks through their `push()` and `pop()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this *cardStack.py* program, which pushes and pops string
    values of playing cards to the end of a list named `cardStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following *cardStack.html* program contains the equivalent code in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The stack starts off as empty ❶. Three strings representing cards are pushed
    onto the stack ❷. Then the stack is popped ❸, which removes the ace of hearts
    and leaves the three of clubs at the top of the stack again. The state of the
    `cardStack` stack is tracked in [Figure 1-6](#figure1-6), going from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: '![Timeline showing playing cards stacked on top of each other at various points
    in time. Begins with no cards, then the five of diamonds, then the three of clubs
    on top of the five of diamonds, then the ace of hearts on top of the three of
    clubs, and finally the ace of hearts removed to reveal the three of clubs.](image_fi/502024c01/f01006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-6: The stack starts empty. Cards are then pushed onto and popped off
    the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see only the topmost card in the card stack, or, in our program’s stacks,
    the topmost value. In the simplest stack implementations, you can’t see how many
    cards (or values) are in the stack. You can see only whether the stack is empty
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks are a *LIFO* data structure, which stands for *last in, first out*, since
    the last value pushed onto the stack is the first value popped out of it. This
    behavior is similar to your web browser’s Back button. Your browser tab’s history
    functions like a stack that contains all the pages you’ve visited in the order
    that you visited them. The browser is always displaying the web page at the “top”
    of the history’s “stack.” Clicking a link pushes a new web page onto the history
    stack, while clicking the Back button pops the top web page off and reveals the
    one “underneath.”
  prefs: []
  type: TYPE_NORMAL
- en: What Is the Call Stack?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programs use stacks too. The program’s *call stack*, also simply called *the
    stack*, is a stack of frame objects. *Frame objects*, also simply called *frames*,
    contain information about a single function call, including which line of code
    called the function, so the execution can move back there when the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: Frame objects are created and pushed onto the stack when a function is called.
    When the function returns, that frame object is popped off the stack. If we call
    a function that calls a function that calls a function, the call stack will have
    three frame objects on the stack. When all these functions return, the call stack
    will have zero frame objects on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers don’t have to write code dealing with frame objects, since the
    programming language handles them automatically. Different programming languages
    have different ways of implementing frame objects, but in general they contain
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The return address, or the spot in the program where the execution should move
    when the function returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arguments passed to the function call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of local variables created during the function call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, take a look at the following *localVariables.py* program, which
    has three functions, just as our previous *functionCalls.py* and *functionCalls.html*
    programs did:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This *localVariables.html* is the equivalent JavaScript program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When the program calls function `a()` ❼, a frame object is created and placed
    on the top of the call stack. This frame stores any arguments passed to `a()`
    (in this case, there are none), along with the local variable `spam` ❶ and the
    place where the execution should go when the `a()` function returns.
  prefs: []
  type: TYPE_NORMAL
- en: When `a()` is called, it displays the contents of its local `spam` variable,
    which is `Ant` ❷. When the code in `a()` calls function `b()` ❸, a new frame object
    is created and placed on the call stack above the frame object for `a()`. The
    `b()` function has its own local `spam` variable ❹, and calls `c()` ❺. A new frame
    object for the `c()` call is created and placed on the call stack, and it contains
    `c()`’s local `spam` variable ❻. As these functions return, the frame objects
    pop off the call stack. The program execution knows where to return to, because
    that return information is stored in the frame object. When the execution has
    returned from all function calls, the call stack is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-7](#figure1-7) shows the state of the call stack as each function
    is called and returns. Notice that all the local variables have the same name:
    `spam`. I did this to highlight the fact that local variables are always separate
    variables with distinct values, even if they have the same name as local variables
    in other functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Timeline depicting the state of a call stack at various points in time. It
    begins empty. Then, within the a() function, the spam variable equals “Ant.” Next,
    within the b() variable, spam equals “Bobcat,” and then within the c() function,
    spam equals “Coyote.” Within the b() function, spam once again equals “Bobcat,”
    and within the a() function, spam once again equals “Ant.”](image_fi/502024c01/f01007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-7: The state of the call stack as the *localVariables* program runs'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, programming languages can have separate local variables with
    the same name (`spam`) because they are kept in separate frame objects. When a
    local variable is used in the source code, the variable with that name in the
    topmost frame object is used.
  prefs: []
  type: TYPE_NORMAL
- en: Every running program has a call stack, and multithreaded programs have one
    call stack for each thread. But when you look at the source code for a program,
    you can’t see the call stack in the code. The call stack isn’t stored in a variable
    as other data structures are; it’s automatically handled in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that the call stack doesn’t exist in source code is the main reason
    recursion is so confusing to beginners: recursion relies on something the programmer
    can’t even see! Revealing how stack data structures and the call stack work removes
    much of the mystery behind recursion. Functions and stacks are both simple concepts,
    and we can use them together to understand how recursion works.'
  prefs: []
  type: TYPE_NORMAL
- en: What Are Recursive Functions and Stack Overflows?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *recursive function* is a function that calls itself. This *shortest.py*
    program is the shortest possible example of a recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding program is equivalent to this *shortest.html* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shortest()` function does nothing but call the `shortest()` function.
    When this happens, it calls the `shortest()` function again, and that will call
    `shortest()`, and so on, seemingly forever. It is similar to the mythological
    idea that the crust of the Earth rests on the back of a giant space turtle, which
    rests on the back of another turtle. Beneath that turtle: another turtle. And
    so on, forever.'
  prefs: []
  type: TYPE_NORMAL
- en: But this “turtles all the way down” theory doesn’t do a good job of explaining
    cosmology, nor recursive functions. Since the call stack uses the computer’s finite
    memory, this program cannot continue forever, the way an infinite loop does. The
    only thing this program does is crash and display an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python output of *shortest.py* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript output of *shortest.html* looks like this in the Google Chrome
    web browser (other browsers will have similar error messages):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This kind of bug is called a *stack overflow*. (This is where the popular website
    [https://stackoverflow.com](https://stackoverflow.com) got its name.) The constant
    function calls with no returns grow the call stack until all the computer’s memory
    allocated for the call stack is used up. To prevent this, the Python and JavaScript
    interpreters crash the program after a certain limit of function calls that don’t
    return a value.
  prefs: []
  type: TYPE_NORMAL
- en: This limit is called the *maximum recursion depth*or *maximum call stack size*.
    For Python, this is set to 1,000 function calls. For JavaScript, the maximum call
    stack size depends on the browser running the code but is generally at least 10,000
    or so. Think of a stack overflow as happening when the call stack gets “too high”
    (that is, consumes too much computer memory), as in [Figure 1-8](#figure1-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphic depicting a stack of cards with “c() spam = ‘Coyote’” written on
    the top card. A warning reads, “Stack too high.”](image_fi/502024c01/f01008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-8: A stack overflow happens when the call stack becomes too high,
    with too many frame objects taking up the computer’s memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Stack overflows don’t damage the computer. The computer just detects that the
    limit of function calls without returns has been reached and terminates the program.
    At worst, you’ll lose any unsaved work the program had. Stack overflows can be
    prevented by having something called a *base case*, which is explained next.
  prefs: []
  type: TYPE_NORMAL
- en: Base Cases and Recursive Cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stack overflow example has a `shortest()` function that calls `shortest()`
    but never returns. To avoid a crash, there needs to be a case, or set of circumstances,
    where the function stops calling itself and instead just returns. This is called
    a *base case*. By contrast, a case where the function recursively calls itself
    is called a *recursive case*.
  prefs: []
  type: TYPE_NORMAL
- en: All recursive functions require at least one base case and at least one recursive
    case. If there is no base case, the function never stops making recursive calls
    and eventually causes a stack overflow. If there is no recursive case, the function
    never calls itself and is an ordinary function, not a recursive one. When you
    start writing your own recursive functions, a good first step is to figure out
    what the base case and recursive case should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this *shortestWithBaseCase.py* program, which defines the shortest
    recursive function that won’t crash from a stack overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is equivalent to the following *shortestWithBaseCase.html* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function doesn’t do anything useful except provide a short example of recursion
    (and it could be made shorter by removing the text output, but the text is useful
    for our explanation). When `shortestWithBaseCase(False)` is called ❸, the base
    case is executed and the function merely returns ❶. However, when `shortestWithBaseCase(True)`
    is called ❹, the recursive case is executed and `shortestWithBaseCase(False)`
    is called ❷.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that when `shortestWithBaseCase(False)` is recursively
    called from ❷ and then returns, the execution doesn’t immediately move back to
    the original function call at ❹. The rest of the code in the recursive case after
    the recursive call still runs, which is why `Returning from recursive case.` appears
    in the output. Returning from the base case doesn’t immediately return from all
    the recursive calls that happened before it. This will be important to keep in
    mind in the `countDownAndUp()` example in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Code Before and After the Recursive Call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code in a recursive case can be split into two parts: the code before the
    recursive call and the code after the recursive call. (If there are two recursive
    calls in the recursive case, such as with the Fibonacci sequence example in Chapter
    2, there will be a before, a between, and an after. But let’s keep it simple for
    now.)'
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to know is that reaching the base case doesn’t necessarily
    mean reaching the end of the recursive algorithm. It only means the base case
    won’t continue to make recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this *countDownAndUp.py* program whose recursive function
    counts from any number down to zero, and then back up to the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the equivalent *countDownAndUp.html* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that every time a function is called, a new frame is created and pushed
    onto the call stack. This frame is where all the local variables and parameters
    (such as `number`) are stored. So, there is a separate `number variable for each
    frame on the call stack. This is another often confusing point about recursion:
    even though, from the source code, it looks like there is only one `number` variable,
    remember that because it is a local variable, there is actually a different `number`
    variable for each function call.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`When `countDownAndUp(3)` is called ❺, a frame is created, and that frame’s
    local `number` variable is set to `3`. The function prints the `number` variable
    to the screen ❶. As long as `number` isn’t `0`, `countDownAndUp()` is recursively
    called with `number - 1` ❸. When it calls `countDownAndUp(2)`, a new frame is
    pushed onto the stack, and that frame’s local `number` variable is set to `2`.
    Again, the recursive case is reached and calls `countDownAndUp(1)`, which again
    reaches the recursive case and calls `countDownAndUp(0)`.'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern of making consecutive recursive function calls and then returning
    from the recursive function calls is what causes the countdown of numbers to appear.
    Once `countDownAndUp(0)` is called, the base case is reached ❷, and no more recursive
    calls are made. However, this isn’t the end of our program! When the base case
    is reached, the local `number` variable is `0`. But when that base case returns,
    and the frame is popped off the call stack, the frame under it has its own local
    `number` variable, with the same `1` value it’s always had. As the execution returns
    back to the previous frames in the call stack, the code *after* the recursive
    call is executed ❹. This is what causes the count up of numbers to appear. [Figure
    1-9](#figure1-9) shows the state of the call stack as `countDownAndUp()` is recursively
    called and then returns.
  prefs: []
  type: TYPE_NORMAL
- en: '![Timeline depicting a call stack after each call to countDownAndUp(). It begins
    empty, then shows the number variable equal to 3, then equal to 2, then equal
    to 1, then equal to 0\. The number variable then begins increasing, first to 1,
    then to 2, then to 3, until the call stack is empty.](image_fi/502024c01/f01009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-9: The call stack keeping track of the values in the `number` local
    variable for each function call'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the code doesn’t stop immediately when the base case is reached
    will be important to keep in mind for the factorial calculation in the next chapter.
    Remember, any code after the recursive case will still have to run.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might be thinking that the recursive `countDownAndUp()` function
    is overengineered and difficult to follow. Why not, instead, use an iterative
    solution to print numbers? An *iterative* approach, which uses loops to repeat
    a task until it’s done, is usually thought of as the opposite of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you find yourself asking, “Wouldn’t using a loop be easier?” the answer
    is almost certainly “Yes,” and you should avoid the recursive solution. Recursion
    can be tricky for both beginner and experienced programmers, and recursive code
    isn’t automatically “better” or “more elegant” than iterative code. Readable,
    easy-to-understand code is more important than any supposed elegance that recursion
    provides. However, on some occasions an algorithm cleanly maps to a recursive
    approach. Algorithms that involve tree-like data structures and require backtracking
    are especially suited for recursion. These ideas are further explored in Chapters
    2 and 4.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recursion often confuses new programmers, but it is built on the simple idea
    that a function can call itself. Every time a function call is made, a new frame
    object with information related to the call (such as local variables and a return
    address for the execution to move to when the function returns) is added to the
    call stack. The call stack, being a stack data structure, can be altered only
    by having data added to or removed from its “top.” This is called *pushing to*
    and *popping from* the stack, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The call stack is handled by the program implicitly, so there is no call stack
    variable. Calling a function pushes a frame object to the call stack, and returning
    from a function pops a frame object from the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions have recursive cases, those in which a recursive call is
    made, and base cases, those where the function simply returns. If there is no
    base case or a bug prevents a base case from being run, the execution causes a
    stack overflow that crashes the program.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is a useful technique, but recursion doesn’t automatically make code
    “better” or more “elegant.” This idea is explored more in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find other introductions to recursion in my 2018 North Bay Python conference
    talk, “Recursion for Beginners: A Beginner’s Guide to Recursion,” at [https://youtu.be/AfBqVVKg4GE](https://youtu.be/AfBqVVKg4GE).
    The YouTube channel Computerphile also introduces recursion in its video “What
    on Earth is Recursion?” at [https://youtu.be/Mv9NEXX1VHc](https://youtu.be/Mv9NEXX1VHc).
    Finally, V. Anton Spraul talks about recursion in his book *Think Like a Programmer*
    (No Starch Press, 2012) and in his video “Recursion (Think Like a Programmer)”
    at [https://youtu.be/oKndim5-G94](https://youtu.be/oKndim5-G94). Wikipedia’s article
    on recursion goes into great detail at [https://en.wikipedia.org/wiki/Recursion](https://en.wikipedia.org/wiki/Recursion).'
  prefs: []
  type: TYPE_NORMAL
- en: You can install the `ShowCallStack` module for Python. This module adds a `showcallstack()`
    function that you can place anywhere in your code to see the state of the call
    stack at that particular point in your program. You can download the module and
    find instructions for it at [https://pypi.org/project/ShowCallStack](https://pypi.org/project/ShowCallStack).
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: In general, what is a recursive thing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In programming, what is a recursive function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What four features do functions have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a stack?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the terms for adding and removing values to and from the top of a stack?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Say you push the letter *J* to a stack, then push the letter *Q*, then pop the
    stack, then push the letter *K*, then pop the stack again. What does the stack
    look like?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is pushed and popped onto the call stack?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What causes a stack overflow to happen?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a base case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a recursive case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many base cases and recursive cases do recursive functions have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if a recursive function has zero base cases?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if a recursive function has zero recursive cases?`  `# 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursion vs. Iteration
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Neither recursion nor iteration is a superior technique in general. In fact,
    any recursive code can be written as iterative code with a loop and a stack. Recursion
    doesn’t have some special power enabling it to perform calculations that an iterative
    algorithm cannot. And any iterative loop can be rewritten as a recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter compares and contrasts recursion and iteration. We’ll look at the
    classic Fibonacci and factorial functions and see why their recursive algorithms
    have critical weaknesses. We’ll also explore the insights a recursive approach
    can yield by considering an exponent algorithm. Altogether this chapter shines
    light on the supposed elegance of recursive algorithms and shows when a recursive
    solution is useful and when it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Factorials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many computer science courses use factorial calculation as a classic example
    of a recursive function. The factorial of an integer (let’s call it *n*) is the
    product of all integers from 1 to *n*. For example, the factorial of 4 is 4 ×
    3 × 2 × 1, or 24\. An exclamation mark is the math notation for factorials, as
    in 4!, which means *the factorial of 4*. [Table 2-1](#table2-1) shows the first
    few factorials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-1: Factorials of the First Few Integers'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***n*!** |  | **Expanded form** |  | **Product** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1! | = | 1 | = | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2! | = | 1 × 2 | = | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 3! | = | 1 × 2 × 3 | = | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 4! | = | 1 × 2 × 3 × 4 | = | 24 |'
  prefs: []
  type: TYPE_TB
- en: '| 5! | = | 1 × 2 × 3 × 4 × 5 | = | 120 |'
  prefs: []
  type: TYPE_TB
- en: '| 6! | = | 1 × 2 × 3 × 4 × 5 × 6 | = | 720 |'
  prefs: []
  type: TYPE_TB
- en: '| 7! | = | 1 × 2 × 3 × 4 × 5 × 6 × 7 | = | 5,040 |'
  prefs: []
  type: TYPE_TB
- en: '| 8! | = | 1 × 2 × 3 × 4 × 5 × 6 × 7 × 8 | = | 40,320 |'
  prefs: []
  type: TYPE_TB
- en: Factorials are used in all sorts of calculations—for example, finding the number
    of permutations for something. If you want to know the number of ways that exist
    to order four people—Alice, Bob, Carol, and David—in a line, the answer is the
    factorial of 4\. Four possible people can be first in line (4); then for each
    of those four options, three remaining people can be second in line (4 × 3); then
    two people can be third in line (4 × 3 × 2); and the last person left will be
    fourth in line (4 × 3 × 2 × 1). The number of ways people can be ordered in line—that
    is, the number of permutations—is the factorial of the number of people.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s examine both an iterative and a recursive approach to calculating
    factorials.
  prefs: []
  type: TYPE_NORMAL
- en: The Iterative Factorial Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calculating factorials iteratively is fairly straightforward: multiply the
    integers 1 up to and including *n* in a loop. *Iterative* algorithms always use
    a loop. A *factorialByIteration.py* program looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And a *factorialByIteration.html* program looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, the output displays the calculation for 5! like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There’s nothing wrong with the iterative solution for calculating factorials;
    it’s straightforward and gets the job done. But let’s also take a look at the
    recursive algorithm for insights into the nature of factorials and recursion itself.
  prefs: []
  type: TYPE_NORMAL
- en: The Recursive Factorial Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the factorial of 4 is 4 × 3 × 2 × 1, and the factorial of 5 is 5
    × 4 × 3 × 2 × 1\. So you could say that 5! = 5 × 4!. This is *recursive* because
    the definition of the factorial of 5 (or any number *n*) includes the definition
    of the factorial of 4 (the number *n* – 1). In turn, 4! = 4 × 3!, and so on, until
    you must calculate 1!, the base case, which is simply 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *factorialByRecursion.py* Python program uses a recursive factorial algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And the *factorialByRecursion.html* JavaScript program with equivalent code
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code to calculate 5! recursively, the output matches the
    iterative program’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To many programmers, this recursive code looks strange. You know that `factorial(5)`
    must compute 5 × 4 × 3 × 2 × 1, but it’s hard to point to the line of code where
    this multiplication is taking place.
  prefs: []
  type: TYPE_NORMAL
- en: The confusion arises because the recursive case has one line ❶, half of which
    is executed before the recursive call and half of which takes place after the
    recursive call returns. We aren’t used to the idea of only half of a line of code
    executing at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The first half is `factorial(number - 1)`. This involves calculating `number
    - 1` and making a recursive function, causing a new frame object to be pushed
    to the call stack. This happens before the recursive call is made.
  prefs: []
  type: TYPE_NORMAL
- en: The next time the code runs with the old frame object is after `factorial(number
    - 1)` has returned. When `factorial(5)` is called, `factorial(number - 1)` will
    be `factorial(4)`, which returns `24`. This is when the second half of the line
    runs. The `return number * factorial(number - 1)` now looks like `return` `5 *
    24`, which is why `factorial(5)` returns `120`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-1](#figure2-1) tracks the state of the call stack as frame objects
    are pushed (which happens as recursive function calls are made) and frame objects
    are popped (as recursive function calls return). Notice that the multiplication
    happens after the recursive calls are made, not before.'
  prefs: []
  type: TYPE_NORMAL
- en: When the original function call to `factorial()` returns, it returns the calculated
    factorial.
  prefs: []
  type: TYPE_NORMAL
- en: Why the Recursive Factorial Algorithm Is Terrible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The recursive implementation for calculating factorials has a critical weakness.
    Calculating the factorial of 5 requires five recursive function calls. This means
    five frame objects are placed on the call stack before the base case is reached.
    This doesn’t scale.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to calculate the factorial of 1,001, the recursive `factorial()`
    function must make 1,001 recursive function calls. However, your program is likely
    to cause a stack overflow before it can finish, because making so many function
    calls without returning would exceed the maximum call stack size of the interpreter.
    This is terrible; you would never want to use a recursive factorial function in
    real-world code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Timeline of the call stack after each call to the factorial function. We
    begin with the number variable equal to 5 and a return value of 5 times the result
    of the factorial function when called with the argument 4\. Next, number equals
    4, and the return value is 4 times the result of the factorial function when called
    with the argument 3\. Then, number equals 3, and the return value is 3 times the
    return value of the factorial function when called with the argument 2\. Next,
    number equals 2, and the return value is 2 times the return value of the factorial
    function when called with the argument 1\. After that, number equals 1, and the
    return value is 1\. Then, number equals 2, and the return value is 2 times 1\.
    Next, number equals 3, and the return value is 3 times 2\. Then, number equals
    4, and the return value is 4 times 6\. Next, number equals 5, and the return value
    is 5 times 24\. Finally, the call stack is empty.](image_fi/502024c02/f02001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: The state of the call stack as the recursive calls to `factorial()`
    are called and then return'
  prefs: []
  type: TYPE_NORMAL
- en: The iterative factorial algorithm, on the other hand, will complete the calculation
    quickly and efficiently. The stack overflow can be avoided using a technique available
    in some programming languages called *tail call optimization*. Chapter 8 covers
    this topic. However, this technique further complicates the implementation of
    the recursive function. For calculating factorials, the iterative approach is
    the simplest and most direct.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Fibonacci Sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Fibonacci sequence* is another classic example for introducing recursion.
    Mathematically, the Fibonacci sequence of integers begins with the numbers 1 and
    1 (or sometimes, 0 and 1). The next number in the sequence is the sum of the previous
    two numbers. This creates the sequence 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,
    and so on, forever.
  prefs: []
  type: TYPE_NORMAL
- en: If we call the latest two numbers in the sequence *a* and *b*, you can see in
    [Figure 2-2](#figure2-2) how the sequence grows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing the values of two variables, a and b, and their sum as the
    Fibonacci sequence progresses. We begin with a and b both equal to 1 and their
    sum equal to 2\. Next, a is equal to 1, b is equal to 2, and their sum is equal
    to 3\. Then a is equal to 2, b is equal to 3, and their sum is equal to 5\. Each
    progression of the Fibonacci sequence occurs on a new line, and each new line
    is one number longer than the previous line, forming a pyramid-like shape.](image_fi/502024c02/f02002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: Each number of the Fibonacci sequence is the sum of the previous
    two numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore some code examples of both the iterative and recursive solutions
    for generating Fibonacci numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The Iterative Fibonacci Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The iterative Fibonacci example is straightforward, consisting of a simple
    `for` loop and two variables, `a` and `b`. This *fibonacciByIteration.py* Python
    program implements the iterative Fibonacci algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This *fibonacciByIteration.html* program has the equivalent JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code to calculate the 10th Fibonacci number, the output looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The program needs to track only the latest two numbers of the sequence at a
    time. Since the first two numbers in the Fibonacci sequence are defined as 1,
    we store `1` in variables `a` and `b` ❶. Inside the `for` loop, the next number
    in the sequence is calculated by adding `a` and `b` ❷, which becomes the next
    value of `b`, while `a` obtains the previous value of `b`. By the time the loop
    is finished, `b` contains the *n*th Fibonacci number, so it is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The Recursive Fibonacci Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calculating Fibonacci numbers involves a recursive property. For example, if
    you want to calculate the 10th Fibonacci number, you add the ninth and eighth
    Fibonacci numbers together. To calculate those Fibonacci numbers, you add the
    eighth and seventh, then the seventh and sixth Fibonacci numbers. A lot of repeat
    calculations occur: notice that adding the ninth and eighth Fibonacci numbers
    involves calculating the eighth Fibonacci number again. You continue this recursion
    until you reach the base case of the first or second Fibonacci number, which is
    always 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive Fibonacci function is in this *fibonacciByRecursion.py* Python
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This *fibonacciByRecursion.html* file has the equivalent JavaScript program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code to calculate the 10th Fibonacci number, the output looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Much of the code is for displaying this output, but the `fibonacci()` function
    itself is simple. The base case—the circumstances where recursive calls are no
    longer made—occurs when `nthNumber` is `1` or `2` ❶. In this case, the function
    returns `1` since the first and second Fibonacci numbers are always 1\. Any other
    case is a recursive case, so the value that is returned is the sum of `fibonacci(nthNumber
    - 1)` and `fibonacci(nthNumber - 2)`. As long as the original `nthNumber` argument
    is an integer greater than `0`, these recursive calls will eventually reach the
    base case and stop making more recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember how the recursive factorial example had a “before the recursive call”
    and “after the recursive call” part? Because the recursive Fibonacci algorithm
    makes two recursive calls in its recursive case, you should keep in mind that
    it has three parts: “before the first recursive call,” “after the first recursive
    call but before the second recursive call,” and “after the second recursive call.”
    But the same principles apply. And don’t think that because a base case is reached,
    no more code remains to run after either recursive call. The recursive algorithm
    is finished only after the original function call has returned.'
  prefs: []
  type: TYPE_NORMAL
- en: You might ask, “Isn’t the iterative Fibonacci solution simpler than the recursive
    Fibonacci solution?” The answer is “Yes.” Even worse, the recursive solution has
    a critical inefficiency that is explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Why the Recursive Fibonacci Algorithm Is Terrible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like the recursive factorial algorithm, the recursive Fibonacci algorithm also
    suffers from a critical weakness: it repeats the same calculations over and over.
    [Figure 2-3](#figure2-3) shows how calling `fibonacci(6)`, marked in the tree
    diagram as `fib(6)` for brevity, calls `fibonacci(5)` and `fibonacci(4)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagram beginning with the Fibonacci function called with an argument
    of 6\. Two subsequent branches show the next calls to the Fibonacci function,
    with arguments of 5 and 4, respectively. The tree continues to branch until each
    branch ends with a value of 1\. Several of the branches are grayed out, indicating
    that the Fibonacci function was called with the same argument as a previous branch.](image_fi/502024c02/f02003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: A tree diagram of the recursive function calls made starting with
    `fibonacci(6)`. The redundant function calls are in gray.'
  prefs: []
  type: TYPE_NORMAL
- en: This causes a cascade of other function calls until they reach the base cases
    of `fibonacci(2)` and `fibonacci(1)`, which return `1`. But notice that `fibonacci(4)`
    is called twice, and `fibonacci(3)` is called three times, and so on. This slows
    the overall algorithm with unnecessarily repeated calculations. This inefficiency
    gets worse as the Fibonacci number you want to calculate gets larger. While the
    iterative Fibonacci algorithm can complete `fibonacci(100)` in less than a second,
    the recursive algorithm would take over a million years to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a Recursive Algorithm into an Iterative Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Converting a recursive algorithm into an iterative algorithm is always possible.
    While recursive functions repeat a calculation by calling themselves, this repetition
    can be performed instead by a loop. Recursive functions also make use of the call
    stack; however, an iterative algorithm can replace this with a stack data structure.
    Thus, any recursive algorithm can be performed iteratively by using a loop and
    a stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, here is *factorialEmulateRecursion.py*, a Python program
    that implements an iterative algorithm to emulate a recursive algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The *factorialEmulateRecursion.html* program holds the equivalent JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this program doesn’t have a recursive function; it doesn’t have
    any functions at all! The program emulates recursive function calls by using a
    list as a stack data structure (stored in the `callStack` variable ❶) to mimic
    the call stack. A dictionary storing the return address information and `nthNumber`
    local variable emulates a frame object ❷. The program emulates function calls
    by pushing these frame objects onto the call stack ❹, and it emulates returning
    from a function call by popping frame objects off the call stack 35.
  prefs: []
  type: TYPE_NORMAL
- en: Any recursive function can be written iteratively this way. Although this code
    is incredibly difficult to understand and you’d never write a real-world factorial
    algorithm this way, it does demonstrate that recursion has no innate capability
    that iterative code does not have.
  prefs: []
  type: TYPE_NORMAL
- en: Converting an Iterative Algorithm into a Recursive Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Likewise, converting an iterative algorithm into a recursive algorithm is always
    possible. An iterative algorithm is simply code that uses a loop. The code that
    is repeatedly executed (the loop’s body) can be placed in a recursive function’s
    body. And just as the code in the loop’s body is executed repeatedly, we need
    to repeatedly call the function to execute its code. We can do this by calling
    the function from the function itself, creating a recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code in *hello.py* demonstrates printing `Hello, world!` five times
    by using a loop and then also using a recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent JavaScript code is in *hello.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these programs looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop has a condition, `i < 5`, that determines whether the program
    keeps looping. Similarly, the recursive function uses this condition for its recursive
    case, which causes the function to call itself and execute the `Hello, world!`
    to display its code again.
  prefs: []
  type: TYPE_NORMAL
- en: For a more real-world example, the following are iterative and recursive functions
    that return the index of a substring, `needle`, in a string, `haystack. The functions
    return `-1` if the substring isn’t found. This is similar to Python’s `find()`
    string method and JavaScript’s `indexOf()` string method. This *findSubstring.py*
    program has a Python version:`
  prefs: []
  type: TYPE_NORMAL
- en: '`**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This *findSubstring.html* program has the equivalent JavaScript version:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'These programs make a call to `findSubstringIterative()` and `findSubstringRecursive()`,
    which return `3` because that is the index where `cat` is found in `My cat Zophie`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The programs in this section demonstrate that it is always possible to turn
    any loop into an equivalent recursive function. While replacing a loop with recursion
    is possible, I advise against it. This is doing recursion for recursion’s sake,
    and since recursion is often harder to understand than iterative code, code readability
    deteriorates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case Study: Calculating Exponents'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although recursion doesn’t necessarily produce better code, taking a recursive
    approach can give you new insights into your programming problem. As a case study,
    let’s examine how to calculate exponents.
  prefs: []
  type: TYPE_NORMAL
- en: '*Exponents* are calculated by multiplying a number by itself. For example,
    the exponent “three raised to the sixth power,” or 3⁶, is equal to multiplying
    3 by itself six times: 3 × 3 × 3 × 3 × 3 × 3 = 729\. This is such a common operation
    that Python has the `**` operator and JavaScript has the built-in `Math.pow()`
    function to perform exponentiation. We can calculate 3⁶ with the Python code `3
    ** 6` and with the JavaScript code `Math.pow(3, 6)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s write our own exponent-calculating code. The solution is straightforward:
    create a loop that repeatedly multiplies a number by itself and returns the final
    product. Here is an iterative *exponentByIteration.py* Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is an equivalent JavaScript *exponentByIteration.html* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run these programs, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a straightforward calculation that we can easily write with a loop.
    The downside to using a loop is that the function slows as the exponents get larger:
    calculating 3^(12) takes twice as long as 3⁶, and 3^(600) takes one hundred times
    as long as 3⁶. In the next section, we address this by thinking recursively.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Recursive Exponents Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s think of what a recursive solution for the exponentiation of, say, 3⁶
    would be. Because of the associative property of multiplication, 3 × 3 × 3 × 3
    × 3 × 3 is the same as (3 × 3 × 3) × (3 × 3 × 3), which is the same as (3 × 3
    × 3)². And since (3 × 3 × 3) is the same as 3³, we can determine that 3⁶ is the
    same as (3³)². This is an example of what mathematics calls the *power rule*:
    (*a*^(*m*))^(*n*) = *a*^(*mn*). Mathematics also gives us the *product rule*:
    *a*^(*n*) × *a*^(*m*) = *a*^(*n*) ^(+ m), including *a*^(*n*) × *a* = *a*^(*n*)
    ^(+ 1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use these mathematical rules to make an `exponentByRecursion()` function.
    If `exponentByRecursion(3, 6)` is called, it’s the same as `exponentByRecursion(3,
    3) * exponentByRecursion(3, 3)`. Of course, we don’t actually have to make both
    `exponentByRecursion(3, 3)` calls: we could just save the return value to a variable
    and multiply it by itself.'
  prefs: []
  type: TYPE_NORMAL
- en: That works for even-numbered exponents, but what about for odd-numbered exponents?
    If we had to calculate 3⁷, or 3 × 3 × 3 × 3 × 3 × 3 × 3, this is the same as (3
    × 3 × 3 × 3 × 3 × 3) × 3, or (3⁶) × 3\. Then we can make the same recursive call
    to calculate 3⁶.
  prefs: []
  type: TYPE_NORMAL
- en: Those are the recursive cases, but what are the base cases? Mathematically speaking,
    any number to the zeroth power is defined as 1, while any number to the first
    power is the number itself. So for any function call `exponentByRecursion(a, n)`,
    if `n` is `0` or `1`, we can simply return `1` or `a`, respectively, because `a``0`
    is always `1` and `a``1` is always `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using all this information, we can write code for the `exponentByRecursion()`
    function. Here is an *exponentByRecursion.py* file with the Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the equivalent JavaScript code in *exponentByRecursion.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, the output is identical to the iterative version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Each recursive call effectively cuts the problem size in half. This is what
    makes our recursive exponent algorithm faster than the iterative version; calculating
    3^(1000) iteratively entails 1,000 multiplication operations, while doing it recursively
    requires only 23 multiplications and divisions. When running the Python code under
    a performance profiler, calculating 3^(1000) iteratively 100,000 times takes 10.633
    seconds, but the recursive calculation takes only 0.406 seconds. That is a huge
    improvement!
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Iterative Exponents Function Based on Recursive Insights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our original iterative exponents function took a straightforward approach:
    loop the same number of times as the exponent power. However, this doesn’t scale
    well for larger powers. Our recursive implementation forced us to think about
    how to break this problem into smaller subproblems. This approach turns out to
    be much more efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because every recursive algorithm has an equivalent iterative algorithm, we
    could make a new iterative exponents function based on the power rule that the
    recursive algorithm uses. The following *exponentWithPowerRule.py* program has
    such a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the equivalent JavaScript program in *exponentWithPowerRule.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Our algorithm keeps reducing `n` by dividing it in half (if it’s even) or subtracting
    1 (if it’s odd) until it is `1`. This gives us the squaring or multiply-by-`a`
    operations we have to perform. After finishing this step, we perform these operations
    in reverse order. A generic stack data structure (separate from the call stack)
    is useful for reversing the order of these operations since it’s a first-in, last-out
    data structure. The first step pushes squaring or multiply-by-`a` operations to
    a stack in the `opStack` variable. In the second step, it performs these operations
    as it pops them off the stack.
  prefs: []
  type: TYPE_NORMAL
- en: For example, calling `exponentWithPowerRule(6, 5)` to calculate 6⁵ sets `a`
    as `6` and `n` as `5`. The function notes that `n` is odd. This means we should
    subtract `1` from `n` to get `4` and push a multiply-by-`a` operation to `opStack`.
    Now that `n` is `4` (even), we divide it by `2` to get `2` and push a squaring
    operation to `opStack`. Since `n` is now `2` and even again, we divide it by `2`
    to get `1` and push another squaring operation to `opStack`. Now that `n` is `1`,
    we are finished with this first step.
  prefs: []
  type: TYPE_NORMAL
- en: To perform the second step, we start the `result` as `a` (which is `6`). We
    pop the `opStack` stack to get a squaring operation, telling the program to set
    `result` to `result * result` (that is, `result``2`) or `36`. We pop the next
    operation off `opStack`, and it is another squaring operation, so the program
    changes the `36` in `result` to `36 * 36`, or `1296`. We pop the last operation
    off `opStack`, and it is a multiply-by-`a` operation, so we multiply the `1296`
    in `result` by `a` (which is `6`) to get `7776`. There are no more operations
    on `opStack`, so the function is now finished. When we double-check our math,
    we find that 6⁵ is indeed 7,776.
  prefs: []
  type: TYPE_NORMAL
- en: The stack in `opStack` looks like [Figure 2-4](#figure2-4) as the function call
    `exponentWithPowerRule(6, 5)` executes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Timeline showing the state of the opStack stack over time. In the first step,
    it begins empty; then Multiply is pushed to the stack, Square is pushed to the
    stack, and, finally, a second Square operation is pushed to the top of the stack.
    In the second step, the most recent Square operation is popped off the stack,
    the first Square operation is popped off the stack, and then the Multiply operation
    is popped off the stack, which is now empty.](image_fi/502024c02/f02004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4: The stack in `opStack` during the `exponentWithPowerRule(6, 5)`
    function call'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this code, the output is identical to the other exponent programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The iterative exponents function that uses the power rule has the improved performance
    of the recursive algorithm, while not suffering from the risk of a stack overflow.
    We might not have thought of this new, improved iterative algorithm without the
    insights of recursive thinking.
  prefs: []
  type: TYPE_NORMAL
- en: When Do You Need to Use Recursion?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You never *need* to use recursion. No programming problem *requires* recursion.
    This chapter has shown that recursion has no magical power to do things that iterative
    code in a loop with a stack data structure cannot do. In fact, a recursive function
    might be an overcomplicated solution for what you’re trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as the exponent functions we created in the previous section show,
    recursion can provide new insights into how to think about our programming problem.
    Three features of a programming problem, when present, make it especially suitable
    to a recursive approach:'
  prefs: []
  type: TYPE_NORMAL
- en: It involves a tree-like structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It involves backtracking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It isn’t so deeply recursive as to potentially cause a stack overflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A tree has a *self-similar* structure: the branching points look similar to
    the root of a smaller subtree. Recursion often deals with self-similarity and
    problems that can be divided into smaller, similar subproblems. The root of the
    tree is analogous to the first call to a recursive function, the branching points
    are analogous to recursive cases, and the leaves are analogous to the base cases
    where no more recursive calls are made.'
  prefs: []
  type: TYPE_NORMAL
- en: A maze is also a good example of a problem that has a tree-like structure and
    requires backtracking. In a maze, the branching points occur wherever you must
    pick one of many paths to follow. If you reach a dead end, you’ve encountered
    the base case. You must then backtrack to a previous branching point to select
    a different path to follow.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-5](#figure2-5) shows a maze’s path visually morphed to look like
    a biological tree. Despite the visual difference between the maze paths and the
    tree-shaped paths, their branching points are related to each other in the same
    way. Mathematically, these graphs are equivalent.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Three images: the first is a classic maze with branching paths, the second
    shows lines tracing through every path of the maze with a circle at every branch,
    and the third is this line-and-circle drawing distorted to look like the branches
    of a tree.](image_fi/502024c02/f02005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-5: A maze (left) along with its interior paths (center) morphed to
    match a biological tree’s shape (right)'
  prefs: []
  type: TYPE_NORMAL
- en: Many programming problems have this tree-like structure at their core. For example,
    a filesystem has a tree-like structure; the subfolders look like the root folders
    of a smaller filesystem. [Figure 2-6](#figure2-6) compares a filesystem to a tree.
  prefs: []
  type: TYPE_NORMAL
- en: '![Two images, one of a tree and the other of a filesystem, with arrows pointing
    out the equivalent of leaves, branching points, and the root on each.](image_fi/502024c02/f02006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-6: A filesystem is similar to a tree structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching for a specific filename in a folder is a recursive problem: you search
    the folder and then recursively search the folder’s subfolders. Folders with no
    subfolders are the base cases that cause the recursive searching to stop. If your
    recursive algorithm doesn’t find the filename it’s looking for, it backtracks
    to a previous parent folder and continues searching from there.'
  prefs: []
  type: TYPE_NORMAL
- en: The third point is a matter of practicality. If your tree structure has so many
    levels of branches that a recursive function would cause a stack overflow before
    it can reach the leaves, then recursion isn’t a suitable solution.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, recursion is the best approach for creating programming language
    compilers. Compiler design is its own expansive subject and beyond the scope of
    this book. But programming languages have a set of grammar rules that can break
    source code into a tree structure similar to the way grammar rules can break English
    sentences into a tree diagram. Recursion is an ideal technique to apply to compilers.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll identify many recursive algorithms in this book, and they often have the
    tree-like structure or backtracking features that lend themselves to recursion
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Coming Up with Recursive Algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hopefully, this chapter has given you a firm idea of how recursive functions
    compare to the iterative algorithms you’re likely more familiar with. The rest
    of this book dives into the details of various recursive algorithms. But how should
    you go about writing your own recursive functions?
  prefs: []
  type: TYPE_NORMAL
- en: The first step is always to identify the recursive case and the base case. You
    can take a top-down approach by breaking the problem into subproblems that are
    similar to the original problem but smaller; this is your *recursive case*. Then
    consider when the subproblems are small enough to have a trivial answer; this
    is your *base case*. Your recursive function may have more than one recursive
    case or base case, but all recursive functions will always have at least one recursive
    case and at least one base case.
  prefs: []
  type: TYPE_NORMAL
- en: The recursive Fibonacci algorithm is an example. A Fibonacci number is the sum
    of the previous two Fibonacci numbers. We can break the problem of finding a Fibonacci
    number into the subproblems of finding two smaller Fibonacci numbers. We know
    the first two Fibonacci numbers are both 1, so that provides the base case answer
    once the subproblems are small enough.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it helps to take a bottom-up approach and consider the base case first,
    and then see how larger and larger problems are constructed and solved from there.
    The recursive factorial problem is an example. The factorial of 1! is 1\. This
    forms the base case. The next factorial is 2!, and you create it by multiplying
    1! by 2\. The factorial after that, 3!, is created by multiplying 2! by 3, and
    so on. From this general pattern, we can figure out what the recursive case for
    our algorithm will be.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we covered calculating factorials and the Fibonacci sequence,
    two classic recursive programming problems. This chapter featured both iterative
    and recursive implementations for these algorithms. Despite being classic examples
    of recursion, their recursive algorithms suffer from critical flaws. The recursive
    factorial function can cause stack overflows, while the recursive Fibonacci function
    performs so many redundant calculations that it’s far too slow to be effective
    in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: We explored how to create recursive algorithms from iterative algorithms and
    how to create iterative algorithms from recursive algorithms. Iterative algorithms
    use a loop, and any recursive algorithm can be performed iteratively by using
    a loop and a stack data structure. Recursion is often an overly complicated solution,
    but programming problems that involve a tree-like structure and backtracking are
    particularly suitable for recursive implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Writing recursive functions is a skill that improves with practice and experience.
    The rest of this book covers several well-known recursion examples and explores
    their strengths and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find more information about comparing iteration and recursion in the
    Computerphile YouTube channel’s video “Programming Loops vs. Recursion” at [https://youtu.be/HXNhEYqFo0o](https://youtu.be/HXNhEYqFo0o).
    If you want to compare the performance of iterative and recursive functions, you
    need to learn how to use a profiler. Python profilers are explained in Chapter
    13 of my book *Beyond the Basic Stuff with Python* (No Starch Press, 2020), which
    can be read at [https://inventwithpython.com/beyond/chapter13.html](https://inventwithpython.com/beyond/chapter13.html).
    The official Python documentation also covers profilers at [https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html).
    The Firefox profiler for JavaScript is explained on Mozilla’s website at [https://developer.mozilla.org/en-US/docs/Tools/Performance](https://developer.mozilla.org/en-US/docs/Tools/Performance).
    Other browsers have profilers similar to Firefox’s.
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is 4! (that is, the factorial of 4)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you use the factorial of (*n* – 1) to calculate the factorial of *n*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the critical weakness of the recursive factorial function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the first five numbers of the Fibonacci sequence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What two numbers do you add to get the *n*th Fibonacci number?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the critical weakness of the recursive Fibonacci function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does an iterative algorithm always use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it always possible to convert an iterative algorithm into a recursive one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it always possible to convert a recursive algorithm into an iterative one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any recursive algorithm can be performed iteratively by using what two things?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What three features do programming problems that are suitable to recursive solutions
    have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is recursion required to solve a programming problem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practice Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For practice, write a function for each of the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Iteratively calculate the sum of the integer series from `1` to `n`. This is
    similar to the `factorial()` function, except it performs addition instead of
    multiplication. For example, `sumSeries(1)` returns `1`, `sumSeries(2)` returns
    `3` (that is, `1 + 2`), `sumSeries(3)` returns `6` (that is, `1 + 2 + 3`), and
    so on. This function should use a loop instead of recursion. Take a look at the
    *factorialByIteration.py* program in this chapter for guidance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the recursive form of `sumSeries()`. This function should use recursive
    function calls instead of a loop. Look at the *factorialByRecursion.py* program
    in this chapter for guidance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iteratively calculate the sum of the first `n` powers of 2 in a function named
    `sumPowersOf2()`. The powers of 2 are 2, 4, 8, 16, 32, and so on. In Python, these
    are calculated with `2 ** 1`, `2 ** 2`, `2 ** 3`, `2 ** 4`, `2 ** 5`, and so on,
    respectively. In JavaScript, these are calculated with `Math.pow(2, 1)`, `Math.pow(2,
    2)`, and so on. For example, `sumPowersOf2(1)` returns `2`, `sumPowersOf2(2)`
    returns `6` (that is, `2 + 4`), `sumPowersOf2(3)` returns `14` (that is, `2 +
    4 + 8`), and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the recursive form of `sumPowersOf2()`. This function should use recursive
    function calls instead of a loop.`  `# 3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Classic Recursion Algorithms
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: If you take a computer science course, the unit on recursion is sure to cover
    some of the classic algorithms presented in this chapter. Coding interviews (which,
    for lack of suitable ways to evaluate candidates, often crib notes from freshman
    computer science curricula) can touch upon them too. This chapter covers six classic
    problems in recursion, along with their solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with three simple algorithms: summing the numbers in an array, reversing
    a text string, and detecting whether a string is a palindrome. Then we explore
    an algorithm for solving the Tower of Hanoi puzzle, implement the flood fill drawing
    algorithm, and tackle the absurdly recursive Ackermann function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the process, you’ll learn about the head-tail technique for splitting up
    the data in the recursive function arguments. We’ll also ask ourselves three questions
    when trying to come up with recursive solutions: What is the base case? What argument
    is passed to the recursive function call? And how do the arguments passed to the
    recursive function calls become closer to the base case? As you gain more experience,
    answering these questions should come more naturally.'
  prefs: []
  type: TYPE_NORMAL
- en: Summing Numbers in an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first example is simple: given a list (in Python) or an array (in JavaScript)
    of integers, return the total sum of all the integers. For example, a call such
    as `sum([5, 2, 4, 8])` should return `19`.'
  prefs: []
  type: TYPE_NORMAL
- en: This is easy to solve with a loop, but solving it with recursion requires more
    thought. After reading Chapter 2, you might also notice that this algorithm doesn’t
    map well enough to recursion’s capabilities to justify recursion’s added complexity.
    Still, summing numbers in an array (or some other calculation based on processing
    data in a linear data structure) is a common enough recursion problem in coding
    interviews that it deserves our attention.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, let’s examine the *head-tail technique* for implementing
    recursive functions. This technique splits the recursive function’s array argument
    into two parts: the *head* (the first element of the array) and the *tail* (a
    new array including everything after the first element). We define the recursive
    `sum()` function to find the sum of the array argument’s integers by adding the
    head to the sum of the tail array. To find out the sum of the tail array, we recursively
    pass it as the array argument to `sum()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the tail array is one element smaller than the original array argument,
    we’ll eventually end up calling the recursive function and passing it an empty
    array. An empty array argument is trivial to sum and doesn’t require more recursive
    calls; it is merely `0`. From these facts, our answers to the three questions
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? An empty array, which has the sum of `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The tail of the original
    number array, which has one less number than the original array argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The array argument shrinks
    by one element for each recursive call until it becomes a zero-length, or empty,
    array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is *sumHeadTail.py*, a Python program to sum a list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the equivalent JavaScript program, *sumHeadTail.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these programs is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When called with an empty array argument, the base case of our function simply
    returns `0` ❶. In the recursive case, we form the head ❷ and the tail ❸ from the
    original `numbers` argument. Keep in mind that the data type of `tail` is an array
    of numbers, just like the `numbers` argument. But the data type of `head` is just
    a single number value, and not an array with one number value. The return value
    of the `sum()` function is also a single number value and not an array of numbers;
    this is why we can add `head` and `sum(tail)` together in the recursive case ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Each recursive call passes a smaller and smaller array to `sum()`, bringing
    it closer to the base case of an empty array. For example, [Figure 3-1](#figure3-1)
    shows the state of the call stack for `sum([5, 2, 4, 8])`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, each card in the stack represents a function call. At the top
    of each card is the function name with the argument it was passed when called.
    Beneath that are the local variables: the `numbers` parameter, and the `head`
    and `tail` local variables created during the call. At the bottom of the card
    is the `head + sum(tail)` expression that the function call returns. When a new
    recursive function is made, a new card is pushed to the stack. When the function
    call returns, the top card is popped from the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A series of stacks of cards representing frame objects on the call stack.
    In order, the new top card represents a call to sum() passing [5, 2, 4, 8], then
    passing [2, 4, 8], then passing [4, 8], then passing [8], then passing an empty
    list. Then the top cards are removed, first removing the empty list card, then
    the [8] card, then [4, 8], then [2, 4, 8], then [5, 2, 4, 8].](image_fi/502024c03/f03001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: The state of the call stack when `sum([5, 2, 4, 8])` runs'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `sum()` function as a template for applying the head-tail technique
    to other recursive functions. For example, you can change the `sum()` function
    from one that sums an array of numbers to a `concat()` function that concatenates
    an array of strings together. The base case would return an empty string for an
    empty array argument, while the recursive case would return the head string joined
    with the return value of the recursive call that is passed the tail.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from Chapter 2 that recursion is especially suited for problems that
    involve a tree-like structure and backtracking. An array, string, or other linear
    data structure can be considered a tree-like structure, albeit a tree that has
    only one branch at each node, as in [Figure 3-2](#figure3-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Two images, one of a tree with every node circled, and one of a crooked branch
    with every bend circled and the numbers 8, 4, 2, and 5 written in the circles.](image_fi/502024c03/f03002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: A `[5, 2, 4, 8]` array (right) is like a tree data structure (left)
    with only one branch at each node.'
  prefs: []
  type: TYPE_NORMAL
- en: The key “tell” that our recursive function is unnecessary is that it never does
    any backtracking over the data it processes. It makes a single pass over each
    element in the array from beginning to end, which is something a basic loop can
    accomplish. Additionally, the Python recursive summation function is about 100
    times slower than a straightforward iterative algorithm. Even if performance weren’t
    an issue, the recursive `sum()` function would cause a stack overflow if passed
    a list with tens of thousands of numbers to sum. Recursion is an advanced technique,
    but it isn’t always the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 5, we’ll examine a recursive summation function that uses a divide-and-conquer
    strategy, and in Chapter 8 we’ll examine one that uses tail call optimization.
    These alternate recursive approaches work around some of the problems in the summation
    function in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing a String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like summing the numbers in an array, reversing a string is another frequently
    cited recursive algorithm even though the iterative solution is straightforward.
    Because a string is essentially an array of single characters, we’ll employ the
    head and tail approach for our `rev()` function just as we did for the summation
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the smallest strings possible. A blank string and a single-character
    string are already the reverse of themselves. These naturally form our base cases:
    if the string argument is a string such as `''''` or `′A′`, our function should
    simply return the string argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For larger strings, let’s try splitting the string into a head (just the first
    character) and tail (all characters after the first). For a two-character string
    like `′XY′`, `′X′` is the head and `′Y′` is the tail. To reverse the string, we
    need to place the head behind the tail: `′YX′`.'
  prefs: []
  type: TYPE_NORMAL
- en: Does this algorithm hold for longer strings? To reverse a string like `′CAT′`,
    we would break it into the head `′C′` and the tail `′AT′`. But placing the head
    behind the tail alone doesn’t reverse the string; it gives us `′ATC′`. What we
    actually want to do is put the head behind *the reverse of* the tail. In other
    words, `′AT′` would reverse to `′TA′`, and then adding the head to the end of
    that would produce the reversed string, `′TAC′`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we reverse the tail? Well, we can recursively call `rev()` and pass
    it the tail. Forget about the implementation of our function for a moment and
    focus on its input and output: `rev()` takes one string argument and returns a
    string with the argument’s characters reversed.'
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about how to implement a recursive function like `rev()` can be difficult
    because it involves a chicken-and-egg problem. In order to write `rev()`’s recursive
    case, we need to call a function that reverses a string—that is, `rev()`. As long
    as we have a solid understanding of what our recursive function’s arguments and
    return value will be, we can use the *leap-of-faith* technique to get around this
    chicken-and-egg problem by writing our recursive case assuming the `rev()` function
    call returns the correct value even though we haven’t finished writing it yet.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a leap of faith in recursion is not a magical technique that guarantees
    your code works bug free. It is merely a perspective to hold to break past the
    mental programmer’s block you can have when thinking about how to implement your
    recursive function. The leap of faith requires you to have a firm understanding
    of your recursive function’s arguments and return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the leap-of-faith technique only helps you write the recursive case.
    You must pass to the recursive call an argument that is closer to the base case.
    You can’t simply pass the same argument that the recursive function received,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To continue our `′CAT′` example, when we pass the tail `′AT′` to `rev()`, the
    head is `′A′` and the tail is `′T′` in *that* function call. We already know that
    the reverse of a single-character string like `′T′` is simply `′T′`; that’s our
    base case. So this second call to `rev()` will reverse `′AT′` to `′TA′`, which
    is precisely what the previous call to `rev()` needs. [Figure 3-3](#figure3-3)
    shows the state of the call stack during all the recursive calls to `rev()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask our three recursive algorithm questions about the `rev()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? A zero- or one-character string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The tail of the original
    string argument, which has one less character than the original string argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The array argument shrinks
    by one element for each recursive call until it becomes a one- or zero-length
    array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Timeline showing the state of the call stack during each recursive call to
    the rev function. It begins with rev called with the argument “CAT,” the theString
    variable equal to “CAT,” the head variable equal to “C,” the tail variable equal
    to “AT,” and a return value of rev(‘AT’) + ‘C’. Next, rev is called with the argument
    “AT,” theString is “AT,” head is “A,” tail is “T,” and the return value is rev(‘T’)
    + ‘A’. Then, rev is called with the argument “T,” theString is equal to “T,” and
    the function returns ‘T’. In the fourth state, rev is called with an argument
    of “AT,” theString is “AT,” head is “A,” tail is “T,” and the function returns
    ‘T’ + ‘A’. Finally, rev is called with the argument “CAT,” theString is “CAT,”
    head is “C,” tail is “AT,” and the function returns ‘TA’ + ‘C’. After this, the
    call stack is empty.](image_fi/502024c03/f03003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: The state of the call stack as the `rev()` function reverses the
    `CAT` string'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is *reverseString.py*, a Python program to reverse a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the equivalent JavaScript code in *reverseString.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of these programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Our recursive function `rev()` returns the string that is the reverse of the
    argument, `theString`. Let’s consider the simplest strings to reverse: the empty
    string and a single-character string would “reverse” to themselves. These are
    the two base cases with which we’ll start (though we combine them with an `or`
    or `||` Boolean operator ❶). For the recursive case, we form `head` from the first
    character in `theString` ❷, and `tail` from every character after the first ❸.
    The recursive case then returns the reverse of `tail` followed by the `head` character
    ❹.'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Palindromes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *palindrome* is a word or phrase that is spelled the same when written forward
    and backward. *Level*, *race car*, *taco cat*, and *a man, a plan, a canal . .
    . Panama* are all examples of palindromes. If you would like to detect whether
    a string is a palindrome, you can write a recursive `isPalindrome()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The base case is a zero- or one-character string, which by its nature is always
    the same, whether forward or backward. We’ll use an approach similar to the head-tail
    technique, except that we’ll split the string argument into head, middle, and
    last strings instead. If the head and last characters are the same and the middle
    characters also form a palindrome, the string is a palindrome. The recursion comes
    from passing the middle string to `isPalindrome()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursive algorithm questions about the `isPalindrome()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? A zero- or one-character string, which returns `True`
    because it is always a palindrome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The middle characters
    of the string argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The string argument shrinks
    by two characters for each recursive call until it becomes a zero- or one-character
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is *palindrome.py*, a Python program to detect palindromes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the equivalent JavaScript code in *palindrome.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of these programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The base case returns `True` because a zero- or one-character string is always
    a palindrome. Otherwise, the string argument is broken into three pieces: the
    first character ❶, the last character ❸, and the middle characters between them
    ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: The `return` statement in the recursive case ❹ makes use of *Boolean short-circuiting*,
    a feature of almost every programming language. In an expression joined with the
    `and` or `&&` Boolean operators, if the left-side expression is `False`, it doesn’t
    matter if the right-side expression is `True` or `False` because the entire expression
    will be `False`. Boolean short-circuiting is an optimization that skips the evaluation
    of the right-side expression of an `and` operator if the left side is `False`.
    So, in the expression `head == last and isPalindrome(middle)`, if `head == last`
    is `False`, the recursive call to `isPalindrome()` is skipped. This means that
    as soon as the head and last strings don’t match, the recursion stops and simply
    returns `False`.
  prefs: []
  type: TYPE_NORMAL
- en: This recursive algorithm is still sequential, like the summation and reverse-string
    functions in the previous sections, except that instead of going from the start
    of the data to the end, it goes from both ends of the data toward the middle.
    The iterative version of this algorithm that uses a simple loop is more straightforward.
    We cover the recursive version in this book because it’s a common coding interview
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Tower of Hanoi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Tower of Hanoi* is a puzzle involving a tower of stacked disks. The puzzle
    begins with the largest disk on the bottom, and the disk sizes decrease going
    up. Each disk has a hole in its center so that the disks can be stacked on top
    of one another on a pole. [Figure 3-4](#figure3-4) shows a wooden Tower of Hanoi
    puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture of a wooden surface with three poles sticking out of it and a stack
    of disks, decreasing in size from bottom to top, placed on the first pole.](image_fi/502024c03/f03004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-4: A wooden Tower of Hanoi puzzle set'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve the puzzle, the player must move the stack of disks from one pole
    to another while following three rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The player can move only one disk at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player can move disks only to and from the top of a tower.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player can never place a larger disk on top of a smaller disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python’s built-in `turtledemo` module has a Tower of Hanoi demonstration that
    you can see by running `python -m turtledemo` on Windows or `python3 -m turtledemo`
    on macOS/Linux, and then selecting **minimum_hanoi** from the Examples menu. Tower
    of Hanoi animations are readily found through an internet search as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive algorithm for solving the Tower of Hanoi puzzle is not intuitive.
    Let’s start with the smallest case: a Tower of Hanoi with one disk. The solution
    is trivial: move the disk to another pole and you’re finished. Solving for two
    disks is slightly more complicated: move the smaller disk to one pole (we’ll call
    it the *temporary pole*) and the larger disk to the other pole (we’ll call it
    the *end pole*), and then finally move the smaller disk from the temporary pole
    to the end pole. Both disks are now on the end pole in the correct order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you solve the three-disk tower, you’ll notice that a pattern emerges.
    To solve a tower of *n* disks from the start pole to the end pole, you must do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Solve the *n* – 1 disks puzzle by moving those disks from the start pole to
    the temporary pole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the *n*th disk from the start pole to the end pole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve the *n* – 1 disks puzzle by moving those disks from the temporary pole
    to the end pole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Like the Fibonacci algorithm, the recursive case for the Tower of Hanoi algorithm
    makes two recursive calls instead of just one. If we draw a tree diagram of the
    operations for solving a four-disk Tower of Hanoi, it looks like [Figure 3-6](#figure3-6).
    Solving the four-disk puzzle requires the same steps as solving the three-disk
    puzzle, as well as moving the fourth disk and performing the steps of solving
    the three-disk puzzle again. Likewise, solving the three-disk puzzle requires
    the same steps as the two-disk puzzle plus moving the third disk, and so on. Solving
    the one-disk puzzle is the trivial base case: it involves only moving the disk.'
  prefs: []
  type: TYPE_NORMAL
- en: The tree-like structure in [Figure 3-5](#figure3-5) hints that a recursive approach
    is ideal for solving the Tower of Hanoi puzzle. In this tree, the execution moves
    from top to bottom and from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: While a three-disk or four-disk Tower of Hanoi is easy for a human to solve,
    increasing numbers of disks require an exponentially increasing number of operations
    to complete. For *n* disks, it takes a minimum of 2*n* – 1 moves to solve. This
    means a 31-disk tower requires over a billion moves to complete!
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagram showing a series of operations needed to solve a four-disk Tower
    of Hanoi. The root node, “Solve 4,” branches into three nodes: one representing
    the move necessary to place the fourth disk in the correct spot, “Move 4,” and
    two “Solve 3” nodes. Each “Solve 3” node branches into its own series of nodes
    representing moves and steps.](image_fi/502024c03/f03005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-5: The series of operations for solving a four-disk Tower of Hanoi'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask ourselves the three questions for creating a recursive solution:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Solving a tower of one disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? Solving a tower of size
    one less than the current size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The size of the tower
    to solve decreases by one disk for each recursive call until it is a one-disk
    tower.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following *towerOfHanoiSolver.py* program solves the Tower of Hanoi puzzle
    and displays a visualization of each step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This *towerOfHanoiSolver.html* program contains the equivalent JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, the output shows each move of the disks until the entire
    tower has moved from Tower A to Tower B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The Python version has an interactive mode too, where you can solve the puzzle
    yourself. Uncomment the lines of code at the end of *towerOfHanoiSolver.py* to
    play the interactive version.
  prefs: []
  type: TYPE_NORMAL
- en: You can start by running the program with the smaller cases by setting the `TOTAL_DISKS`
    constant ❶ at the top of the program to `1` or `2`. In our program, a list of
    integers in Python and an array of integers in JavaScript represent a pole. The
    integer represents a disk, with larger integers representing larger disks. The
    integer at the start of the list or array is at the bottom of the pole, and the
    integer at the end is at the pole’s top. For example, `[6, 5, 4, 3, 2, 1]` represents
    the starting pole with six disks with the largest on the bottom, while `[]` represents
    a pole with no disks. The `TOWERS` variable contains three of these lists ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base case merely moves the smallest disk from the start pole to the end
    pole ❸. The recursive case for a tower of *n* disks carries out three steps: solving
    the *n* – 1 case ❹, moving the *n*th disk ❺, and then solving the *n* – 1 case
    again ❻.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Flood Fill
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graphics programs commonly use the *flood fill algorithm* to fill an arbitrarily
    shaped area of the same color with another color. [Figure 3-6](#figure3-6) shows
    one such shape at the top left. The subsequent panels show three different sections
    of the shape flood-filled with a gray color. The flood fill begins on a white
    pixel and spreads until it meets a non-white pixel, filling the enclosed space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flood fill algorithm is recursive: it begins by changing a single pixel
    to a new color. The recursive function is then called on any neighbors of the
    pixel with its same old color. It then moves on to the neighbors of the neighbors,
    and so on, converting each pixel to the new color until the enclosed space is
    filled in.'
  prefs: []
  type: TYPE_NORMAL
- en: The base case is a pixel whose color is the edge of the image or is not the
    old color. Since reaching the base case is the only way to stop the “spread” of
    recursive calls for every pixel in the image, this algorithm has the emergent
    behavior of changing all the contiguous pixels from the old color to the new color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursive algorithm questions about our `floodFill()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? When the x- and y-coordinates are for a pixel that is
    not the old color, or are at the edge of the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What arguments are passed to the recursive function call? The x- and y-coordinates
    of the four neighboring pixels of the current pixel are the arguments to four
    recursive calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do these arguments become closer to the base case? The neighboring pixels
    run up to a different color than the old color or the edge of the image. Either
    way, eventually the algorithm runs out of pixels to check.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Four screenshots of MS Paint windows containing the same abstract, squiggly
    shape. Each screenshot shows a different closed portion of the drawing colored
    gray.](image_fi/502024c03/f03006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-6: The original shape in a graphics editor (top left) and the same
    shape with three different areas flood-filled with a light gray color'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of an image for our sample program, we’ll use a list of single-character
    strings to form a 2D grid of text characters to represent an “image.” Each string
    represents a “pixel,” and the specific character represents the “color.” The *floodfill.py*
    Python program implements the flood fill algorithm, the image data, and a function
    to print the image on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The *floodfill.html* program contains the equivalent JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, the program fills the interior of the shape drawn by
    the `#` characters starting at coordinates 3, 3\. It replaces all the period characters
    (`.`) with `o` characters. The following output shows the before and after images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If you want to see every step of the flood fill algorithm as it fills in the
    new character, uncomment the `printImage(image)` line ❶ in the `floodFill()` function
    and run the program again.
  prefs: []
  type: TYPE_NORMAL
- en: The image is represented by a 2D array of string characters. We can pass this
    `image` data structure, an `x` coordinate and a `y` coordinate, and a new character
    to the `floodFill()` function. The function notes the character currently at the
    `x` and `y` coordinates and saves it to the `oldChar` variable ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the current characters at coordinates `x` and `y` in `image` are not the
    same as `oldChar`, this is our base case, and the function simply returns. Otherwise,
    the function continues on to its four recursive cases: passing the x- and y-coordinates
    of the bottom ❸, top ❹, right ❺, and left ❻ neighbors of the current coordinates.
    After these four potential recursive calls are made, the end of the function is
    an implicit base case, made explicit in our program with a `return` statement
    ❼.'
  prefs: []
  type: TYPE_NORMAL
- en: The flood fill algorithm doesn’t have to be recursive. For large images, a recursive
    function could cause stack overflows. If we were to implement flood fill with
    a loop and a stack instead, the stack would begin with the x- and y-coordinates
    of the starting pixel. The code in the loop would pop the coordinates off the
    top of the stack, and if that coordinate’s pixel matches `oldChar`, it would push
    the coordinates of the four neighboring pixels. When the stack is empty because
    the base case is no longer pushing neighbors to the stack, the loop is finished.
  prefs: []
  type: TYPE_NORMAL
- en: However, the flood fill algorithm doesn’t necessarily have to use a stack. The
    pushing and popping of a first-in, last-out stack is effective for backtracking
    behavior, but the order that the pixels are processed in the flood fill algorithm
    can be arbitrary. This means we could equally effectively use a set data structure
    that removes elements randomly. You can find these iterative flood fill algorithms
    implemented in *floodFillIterative.py* and *floodFillIterative.html* in the downloadable
    resources at [https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion).
  prefs: []
  type: TYPE_NORMAL
- en: Using the Ackermann Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Ackermann function* is named after its discoverer, Wilhelm Ackermann. A
    student of mathematician David Hilbert (whose Hilbert curve fractal we discuss
    in Chapter 9), Ackermann published his function in 1928\. Mathematicians Rózsa
    Péter and Raphael Robinson later developed the version of the function featured
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: While the Ackermann function has some application in advanced mathematics, it
    is mostly known for being an example of a highly recursive function. Even slight
    increases to its two integer arguments cause a large increase in the number of
    recursive calls it makes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ackermann function takes two arguments, `m` and `n`, and has a base case
    of returning `n + 1` when `m` is `0`. There are two recursive cases: when `n`
    is `0`, the function returns `ackermann(m - 1, 1)`, and when `n` is greater than
    `0`, the function returns `ackermann(m - 1, ackermann(m, n - 1))`. These cases
    likely aren’t meaningful to you, but suffice it to say, the number of recursive
    calls the Ackermann function makes grows quickly. Calling `ackermann(1, 1)` results
    in three recursive function calls. Calling `ackermann(2, 3)` results in 43 recursive
    function calls. Calling `ackermann(3, 5)` results in 42,437 recursive function
    calls. And calling `ackermann(5, 7)` results in . . . well, actually I don’t know
    how many recursive function calls, because it would take several times the age
    of the universe to calculate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s answer the three questions we ask when constructing recursive algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? When `m` is `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What arguments are passed to the recursive function call? Either `m` or `m -
    1` is passed for the next `m` parameter; and `1`, `n - 1`, or the return value
    of `ackermann(m, n - 1)` is passed for the next `n` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do these arguments become closer to the base case? The `m` argument is always
    either decreasing or staying the same size, so it will eventually reach `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an *ackermann.py* Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the equivalent *ackermann.html* JavaScript program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, the output’s indentation (set by the `indentation`
    argument) tells you how deep on the call stack the given recursive function call
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You can also try `ackermann(3, 3)`, but anything with larger arguments will
    probably take far too long to calculate. To speed up the calculation, try commenting
    out all `print()` and `document.write()` calls except the ones that print the
    final return value of `ackermann()`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, even a recursive algorithm like the Ackermann function can be implemented
    as an iterative function. The iterative Ackermann algorithms are implemented in
    *ackermannIterative.py* and *ackermannIterative.html* in the downloadable resources
    at [https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter covered some classic recursive algorithms. For each, we asked
    the three important questions you should always ask when designing your own recursive
    functions: What is the base case? What arguments are passed to the recursive function
    call? How do these arguments become closer to the base case? If they don’t, your
    function will continue to recurse until it causes a stack overflow.'
  prefs: []
  type: TYPE_NORMAL
- en: The summation, string reversing, and palindrome detection recursive functions
    could have easily been implemented with a simple loop. The key giveaway is that
    they all make a single pass through the data given to them with no backtracking.
    As explained in Chapter 2, recursive algorithms are especially suited to problems
    that involve a tree-like structure and require backtracking.
  prefs: []
  type: TYPE_NORMAL
- en: The tree-like structures for solving the Tower of Hanoi puzzle suggest that
    it involves backtracking, as the program execution runs from top to bottom, left
    to right, in the tree. This makes it a prime candidate for recursion, especially
    since the solution requires two recursive calls of smaller towers.
  prefs: []
  type: TYPE_NORMAL
- en: The flood fill algorithm is directly applicable to graphics and drawing programs,
    as well as other algorithms to detect the shape of contiguous areas. If you’ve
    used the paint-bucket tool in a graphics program, you’ve likely used a version
    of the flood fill algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The Ackermann function is an excellent example of how quickly a recursive function
    can grow as its inputs increase. While it doesn’t have many practical applications
    in day-to-day programming, no discussion about recursion would be complete without
    it. But as recursive as it is, like all recursive functions it can be implemented
    iteratively with a loop and a stack.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wikipedia has more information on the Tower of Hanoi problem at [https://en.wikipedia.org/wiki/Tower_of_Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi),
    and the Computerphile video “Recursion ‘Super Power’ (in Python)” covers solving
    the Tower of Hanoi in Python at [https://youtu.be/8lhxIOAfDss](https://youtu.be/8lhxIOAfDss).
    The 3Blue1Brown two-part video series, “Binary, Hanoi, and Sierpiński,” goes into
    even more detail by exploring the relationships among the Tower of Hanoi, binary
    numbers, and the Sierpiński Triangle fractal starting at [https://youtu.be/2SUvWfNJSsM](https://youtu.be/2SUvWfNJSsM).
  prefs: []
  type: TYPE_NORMAL
- en: Wikipedia has an animation of the flood fill algorithm working on a small image
    at [https://en.wikipedia.org/wiki/Flood_fill](https://en.wikipedia.org/wiki/Flood_fill).
  prefs: []
  type: TYPE_NORMAL
- en: The Computerphile video “The Most Difficult Program to Compute?” discusses the
    Ackermann function at [https://youtu.be/i7sm9dzFtEI](https://youtu.be/i7sm9dzFtEI).
    If you’d like to learn more about the Ackermann function’s place in computability
    theory, the Hackers in Cambridge channel has a five-part video series on primitive
    recursive and partial recursive functions at [https://youtu.be/yaDQrOUK-KY](https://youtu.be/yaDQrOUK-KY).
    The series requires a lot of mathematical thinking on the part of the viewer,
    but you don’t need a lot of prior mathematical knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the head of an array or string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the tail of an array or string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three questions this chapter presents for each recursive algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the leap of faith in recursion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you need to understand about the recursive function you are writing
    before you can take a leap of faith?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a linear data structure such as an array or string resemble a tree-like
    structure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the recursive `sum()` function involve any backtracking over the data it
    works on?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the flood fill program, try changing the `im` variable’s strings to create
    a *C* shape that is not fully enclosed. What happens when you attempt to flood-fill
    the image from the middle of the *C*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer the three questions about recursive solutions for each of the recursive
    algorithms presented in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then re-create the recursive algorithms from this chapter without looking at
    the original code.
  prefs: []
  type: TYPE_NORMAL
- en: Practice Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For practice, write a function for each of the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the head-tail technique, create a recursive `concat()` function that is
    passed an array of strings and returns these strings concatenated together into
    a single string. For example, `concat(['Hello', 'World'])` should return `HelloWorld`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the head-tail technique, create a recursive `product()` function that
    is passed an array of integers and returns the total multiplied product of them.
    This code will be almost identical to the `sum()` function in this chapter. However,
    note that the base case of an array with just one integer returns the integer,
    and the base case of an empty array returns `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the flood fill algorithm, count the number of “rooms,” or enclosed spaces,
    in a 2D grid. You can do this by creating nested `for` loops that call the flood
    fill function on each character in the grid if it is a period, in order to change
    the periods into hash characters. For example, the following data would result
    in the program finding six places in the grid with periods, meaning there are
    five rooms (and the space outside all the rooms).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backtracking and Tree Traversal Algorithms
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In previous chapters, you learned that recursion is especially suited for problems
    that involve a tree-like structure and backtracking, such as maze-solving algorithms.
    To see why, consider that a tree’s trunk splits off into multiple branches. Those
    branches themselves split off into other branches. In other words, a tree has
    a recursive, self-similar shape.
  prefs: []
  type: TYPE_NORMAL
- en: A maze can be represented by a tree data structure, since mazes branch off into
    different paths, which in turn branch off into more paths. When you reach a dead
    end in a maze, you must backtrack to an earlier branching point.
  prefs: []
  type: TYPE_NORMAL
- en: The task of traversing tree graphs is tightly linked with many recursive algorithms,
    such as the maze-solving algorithm in this chapter and the maze-generation program
    in Chapter 11. We’ll take a look at tree traversal algorithms and employ them
    to find certain names in a tree data structure. We’ll also use tree traversal
    for an algorithm to obtain the deepest node in a tree. Finally, we’ll see how
    mazes can be represented as a tree data structure, and employ tree traversal and
    backtracking to find a path from the start of the maze to the exit.
  prefs: []
  type: TYPE_NORMAL
- en: Using Tree Traversal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you program in Python and JavaScript, you’re used to working with list, array,
    and dictionary data structures. You’ll encounter tree data structures only if
    you are dealing with low-level details of certain computer science algorithms
    such as abstract syntax trees, priority queues, Adelson-Velsky-Landis (AVL) trees,
    and other concepts beyond the scope of this book. However, trees themselves are
    simple enough concepts.
  prefs: []
  type: TYPE_NORMAL
- en: A *tree* *data structure* is a data structure composed of nodes that are connected
    to other nodes by edges. The *nodes* contain data, while the *edges* represent
    a relationship with another node. Nodes are also called *vertices*. The starting
    node of a tree is called the *root*, and the nodes at the end are called *leaves*.
    Trees always have exactly one root.
  prefs: []
  type: TYPE_NORMAL
- en: '*Parent nodes* at the top have edges to zero or more *child nodes* beneath
    them. Therefore, leaves are the nodes that do not have children, parent nodes
    are the non-leaf nodes, and child nodes are all the non-root nodes. Nodes in a
    tree can have edges to multiple child nodes. The parent nodes that connect a child
    node to the root node are also called the child node’s *ancestors*. The child
    nodes between a parent node and a leaf node are called the parent node’s *descendants*.
    Parent nodes in a tree can have multiple child nodes. But every child node has
    exactly one parent, except for the root node, which has zero parents. In trees,
    only one path can exist between any two nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-1](#figure4-1) shows an example of a tree and three examples of structures
    that are not trees.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Four diagrams. The first, labeled “Tree,” has an A node with two child nodes,
    B and C; B has one child node, D; C has two child nodes, E and F; E has two child
    nodes, G and H. The second diagram, labeled “Not a Tree (Child node has multiple
    parents),” has an A node with two child nodes, B and C; B has two child nodes,
    D and E; C has two child nodes, E and F; E has two child nodes, G and H. The third
    diagram, labeled “Not a Tree (Child node loops back to an ancestor node),” has
    a node A with two child nodes, B and C; B has one child node, D; C has two child
    nodes, E and F; D has one child node, A; E has two child nodes, G and H. The fourth
    diagram, labeled “Not a Tree (Multiple root nodes),” has two root nodes, Z and
    A; Z has one child node, B; A has two child nodes, B and C; B has one child node,
    D; C has two child nodes, E and F; E has two child nodes, G and H.](image_fi/502024c04/f04001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: A tree (left) and three examples of non-trees'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, child nodes must have one parent and not have an edge that creates
    a loop, or else the structure is no longer considered a tree. The recursive algorithms
    we cover in this chapter apply only to tree data structures.
  prefs: []
  type: TYPE_NORMAL
- en: A Tree Data Structure in Python and JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tree data structures are often drawn growing downward, with the root at the
    top. [Figure 4-2](#figure4-2) shows a treecreated with the following Python code
    (it’s also valid JavaScript code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '![Tree diagram and the order in which the nodes would be traversed in preorder,
    postorder, and inorder tree traversal. The tree has the root note A, which has
    two child nodes, B and C. B has one child node, D. C has two child nodes, E and
    F, and E has two child nodes, G and H. Preorder tree traversal: A, B, D, C, E,
    G, H, F. Postorder tree traversal: D, B, G, H, E, F, C, A. Inorder tree traversal:
    D, B, A, G, E, H, C, F.](image_fi/502024c04/f04002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: A tree with root `A` and leaves `D`, `G`, `H`, and `F`, along with
    its traversal orders'
  prefs: []
  type: TYPE_NORMAL
- en: Each node in the tree contains a piece of data (a string of a letter from `A`
    to `H`) and a list of its child nodes. The preorder, postorder, and inorder information
    in [Figure 4-2](#figure4-2) is explained in subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code for this tree, each node is represented by a Python dictionary
    (or JavaScript object) with a key `data` that stores the node’s data, and a key
    `children` that has a list of other nodes. I use the `root` and `node2` to `node8`
    variables to store each node and make the code more readable, but they aren’t
    required. The following Python/JavaScript code is equivalent to the previous code
    listing, though harder for humans to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The tree in [Figure 4-2](#figure4-2) is a specific kind of data structure called
    a *directed acyclic graph* *(DAG)*. In mathematics and computer science, a *graph*
    is a collection of nodes and edges, and a tree is a kind of graph. The graph is
    *directed* because its edges have one direction: from parent to child node. Edges
    in a DAG are not undirected—that is, bidirectional. (Trees in general do not have
    this restriction and can have edges in both directions, including from a child
    node back to its parent node.) The graph is *acyclic* because there are no loops,
    or *cycles*, from child nodes to their own ancestor nodes; the “branches” of the
    tree must keep growing in the same direction.'
  prefs: []
  type: TYPE_NORMAL
- en: You can think of lists, arrays, and strings as linear trees; the root is the
    first element, and the nodes have only one child node. This linear tree terminates
    at its one leaf node. These linear trees are called *linked lists*, as each node
    has only one “next” node until the end of the list. [Figure 4-3](#figure4-3) shows
    a linked list that stores the characters in the word *HELLO*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear Tree Diagram with five nodes. The root node “H” has one child node,
    “E,” which has one child node, “L,” which has one child node, “L,” which has one
    child node, “O.”](image_fi/502024c04/f04003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: A linked list data structure storing `HELLO`. Linked lists can
    be considered a kind of tree data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the code for the tree in [Figure 4-2](#figure4-2) for this chapter’s
    examples. A tree traversal algorithm will visit each of the nodes in a tree by
    following the edges, starting from a root node.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing the Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can write code to access data in any node by starting from the root node
    in `root`. For example, after entering the tree code into the Python or JavaScript
    interactive shell, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Our tree traversal code can be written as a recursive function because tree
    data structures have a self-similar structure: a parent node has child nodes,
    and each child node is the parent node of its own children. Tree traversal algorithms
    ensure that your programs can access or modify the data in every node in the tree
    no matter its shape or size.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three questions about recursive algorithms for our tree traversal
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? A leaf node, which has no more children and requires
    no more recursive calls, causing the algorithm to backtrack to a previous parent
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The node to traverse
    to, whose child nodes will be the next nodes to traverse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? There are no cycles in
    a DAG, so following the descendant nodes will always eventually reach a leaf node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep in mind that tree data structures that are especially deep will cause a
    stack overflow as the algorithm traverses the deeper nodes. This happens because
    each level deeper into the tree requires yet another function call, and too many
    function calls without returning cause stack overflows. However, it’s unlikely
    for broad, well-balanced trees to be that deep. If every node in a 1,000 level
    deep tree has two children, the tree would have about 2^(1000) nodes. That’s more
    atoms than there are in the universe, and it’s unlikely your tree data structure
    is that big.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trees have three kinds of tree traversal algorithms: preorder, postorder, and
    inorder. We’ll discuss each of these in the next three sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Preorder Tree Traversal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Preorder tree traversal* algorithms access a node’s data before traversing
    its child nodes. Use a preorder traversal if your algorithm needs to access the
    data in parent nodes before the data in their child nodes. For example, preorder
    traversals are used when you are creating a copy of the tree data structure, as
    you need to create the parent nodes before child nodes in the duplicate tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following *preorderTraversal.py* program has a `preorderTraverse()` function
    that traverses each child node first, before accessing the node’s data to print
    it to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent JavaScript program is in *preorderTraversal.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these programs is the node data in preorder order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: When you look at the tree in [Figure 4-1](#figure4-1), notice that preorder
    traversal order displays the data in left nodes before right nodes, and bottom
    nodes before top nodes.
  prefs: []
  type: TYPE_NORMAL
- en: All tree traversals begin by passing the root node to the recursive function.
    The function makes a recursive call and passes each of the root node’s children
    as the argument. Since these child nodes have children of their own, the traversal
    continues until a leaf node with no children is reached. At this point, the function
    call simply returns.
  prefs: []
  type: TYPE_NORMAL
- en: The recursive case occurs if the node has any child nodes ❶, in which case a
    recursive call is made with each of the children as the node argument. Whether
    or not the node has children, the base case always happens at the end of the function
    when it returns ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Postorder Tree Traversal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Postorder tree traversal* traverses a node’s child nodes before accessing
    the node’s data. For example, this traversal is used when deleting a tree and
    ensuring that no child nodes are “orphaned” by deleting their parent nodes first,
    leaving the child node inaccessible to the root node. The code in the following
    *postorderTraversal.py* program is similar to the preorder traversal code in the
    previous section, except the recursive function call comes before the `print()`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The *postorderTraversal.html* program has the equivalent JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these programs is the node data in postorder order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The postorder traversal order of the nodes displays the data in left nodes
    before right nodes, and in bottom nodes before top nodes. When we compare the
    `postorderTraverse()` and `preorderTraverse()` functions, we find that the names
    are a bit of a misnomer: *pre* and *post* don’t refer to the order in which nodes
    are visited. The nodes are always traversed in the same order; we go down the
    child nodes first (called a *depth-first search*) as opposed to visiting the nodes
    in each level before going deeper (called a *breadth-first search*). The *pre*
    and *post* refer to *when* the node’s data is accessed: either before or after
    traversing the node’s children.'
  prefs: []
  type: TYPE_NORMAL
- en: Inorder Tree Traversal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Binary trees* are tree data structures with at most two child nodes, often
    called the *left child* and *right child*. An *inorder tree traversal* traverses
    the left child node, then accesses the node’s data, and then traverses the right
    child node. This traversal is used in algorithms that deal with binary search
    trees (which are beyond the scope of this book). The *inorderTraversal.py* program
    contains Python code that performs this kind of traversal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The *inorderTraversal.html* program contains the equivalent JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these programs looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Inorder traversal typically refers to the traversal of binary trees, although
    processing a node’s data after traversing the first node and before traversing
    the last node would count as inorder traversal for trees of any size.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Eight-Letter Names in a Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of printing out the data in each node as we traverse them, we can use
    a *depth-first search* to find specific data in a tree data structure. We’ll write
    an algorithm that searches the tree in [Figure 4-4](#figure4-4) for names that
    are exactly eight letters long. This is a rather contrived example, but it shows
    how an algorithm can use tree traversal to retrieve data out of a tree data structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagram with the root node “Alice,” which has two child nodes, “Bob”
    and “Caroline.” “Bob” has one child node, “Darya.” “Caroline” has two child nodes,
    “Eve” and “Fred.” “Eve” has two child nodes, “Gonzalo” and “Hadassah.”](image_fi/502024c04/f04004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: The tree that stores names in our *depthFirstSearch.py* and *depthFirstSearch.html*
    programs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three questions about recursive algorithms for our tree traversal
    code. Their answers are similar to the answers for the tree traversal algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Either a leaf node causing the algorithm to backtrack,
    or a node containing an eight-letter name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The node to traverse
    to, whose child nodes will be the next nodes to traverse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? There are no cycles in
    a DAG, so following the descendant nodes will always eventually reach a leaf node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *depthFirstSearch.py* program contains Python code that performs a depth-first
    search with a preorder traversal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The *depthFirstSearch.html* program contains the equivalent JavaScript program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these programs looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find8LetterName()` function operates in the same way as our previous tree
    traversal functions, except instead of printing the node’s data, the function
    checks the name stored in the node and returns the first eight-letter name it
    finds. You can change the preorder traversal to a postorder traversal by commenting
    out the earlier name length comparison and the `Checking if` line ❶ and uncommenting
    the later name length comparison and the `Checking if` line ❷. When you make this
    change, the first eight-letter name the function finds is `Hadassah`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: While both traversal orders correctly find an eight-letter name, changing the
    order of a tree traversal can alter the behavior of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the Maximum Tree Depth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An algorithm can determine the deepest branch in a tree by recursively asking
    its child nodes how deep they are. The *depth* of a node is the number of edges
    between it and the root node. The root node itself has a depth of 0, the immediate
    child of the root node has a depth of 1, and so on. You may need this information
    as part of a larger algorithm or to gather information about the general size
    of the tree data structure.
  prefs: []
  type: TYPE_NORMAL
- en: We can have a function named `getDepth()` take a node for an argument and return
    the depth of its deepest child node. A leaf node (the base case) simply returns
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, given the root node of the tree in [Figure 4-1](#figure4-1), we
    could call `getDepth()` and pass it the root node (the `A` node). This would return
    the depth of its children, the `B` and `C` nodes, plus one. The function must
    make a recursive call to `getDepth()` to find out this information. Eventually,
    the `A` node would call `getDepth()` on `C`, which would call it on `E`. When
    `E` calls `getDepth()` with its two children, `G` and `H`, they both return `0`,
    so `getDepth()` called on `E` returns `1`, making `getDepth()` called on `C` return
    `2`, and making `getDepth()` called on `A` (the root node) return `3`. Our tree’s
    greatest depth is three levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask our three recursive algorithm questions for the `getDepth()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? A leaf node with no children, which by its nature has
    a depth of one level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The node whose greatest
    depth we want to find.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? A DAG has no cycles,
    so following the descendant nodes will eventually reach a leaf node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following *getDepth.py* program contains a recursive `getDepth()` function
    that returns the number of levels contained in the deepest node in the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The *getDepth.html* program contains the JavaScript equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these programs is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This matches what we see in [Figure 4-2](#figure4-2): the number of levels
    from the root node `A` down to the lowest nodes `G` and `H` is three levels.'
  prefs: []
  type: TYPE_NORMAL
- en: Solving Mazes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While mazes come in all shapes and sizes, *simply connected mazes*, also called
    *perfect mazes*, contain no loops. A perfect maze has exactly one path between
    any two points, such as the start and exit. These mazes can be represented by
    a DAG.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Figure 4-5](#figure4-5) shows the maze that our maze program solves,
    and [Figure 4-6](#figure4-6) shows the DAG form of it. The capital *S* marks the
    start of the maze, and the capital *E* marks the exit. A few of the intersections
    that have been marked with lowercase letters in the maze correspond to nodes in
    the DAG.
  prefs: []
  type: TYPE_NORMAL
- en: '![Maze with certain intersections labeled with the letters s, d, b, a, c, f,
    e, g, i, j, h, k, n, m, l, and e.](image_fi/502024c04/f04005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: The maze solved by our maze program in this chapter. Some intersections
    have lowercase letters that correspond to nodes in [Figure 4-6](#figure4-6).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree graph in which every intersection of the maze in Figure 4-5 is represented
    as a node.](image_fi/502024c04/f04006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: In this DAG representation of the maze, nodes represent intersections,
    and edges represent the north, south, east, or west path from the intersection.
    Some nodes have lowercase letters to correspond to intersections in [Figure 4-5](#figure4-5).'
  prefs: []
  type: TYPE_NORMAL
- en: Because of this similarity in structure, we can use a tree traversal algorithm
    to solve the maze. The nodes in this tree graph represent intersections where
    the maze solver could choose one of the north, south, east, or west paths to follow
    to the next intersection. The root node is the start of the maze, and the leaf
    nodes represent dead ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive case occurs when the tree traversal algorithm moves from one
    node to the next. If the tree traversal reaches a leaf node (a dead end in the
    maze), the algorithm has reached a base case and must backtrack to an earlier
    node and follow a different path. Once the algorithm reaches the exit node, the
    path it took from the root node represents the maze solution. Let’s ask our three
    recursive algorithm questions about the maze-solving algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Reaching a dead end or the exit of the maze.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The x, y coordinates,
    along with the maze data and list of already visited x, y coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? Like the flood fill algorithm,
    the x, y coordinates keep moving to neighboring coordinates until they eventually
    reach dead ends or the final exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This *mazeSolver.py* program contains the Python code for solving the maze
    stored in the `MAZE` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The *mazeSolver.html* program contains the JavaScript equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: A lot of this code is not directly related to the recursive maze-solving algorithm.
    The `MAZE` variable stores the maze data as a multiline string with hashtags to
    represent walls, an `S` for the starting point, and an `E` for the exit. This
    string is converted into a list that contains lists of strings, with each string
    representing a single character in the maze. This allows us to access `MAZE[y][x]`
    (note that `y` comes first) to get the character at the x, y coordinate in the
    original `MAZE` string. The `printMaze()` function can accept this list-of-list
    data structure and display the maze on the screen. The `findStart()` function
    accepts this data structure and returns the x, y coordinates of the `S` starting
    point. Feel free to edit the maze string yourself—although remember that, in order
    for the solving algorithm to work, the maze cannot have any loops.
  prefs: []
  type: TYPE_NORMAL
- en: The recursive algorithm is in the `solveMaze()` function. The arguments to this
    function are the maze data structure, the current x- and y-coordinates, and a
    `visited` list (which is created if none was supplied) ❶. The `visited` list contains
    all the coordinates that have previously been visited so that when the algorithm
    backtracks from a dead end to an earlier intersection, it knows which paths it
    has tried before and can try a different one. The path from the start to the exit
    is marked by replacing the spaces (matching the `EMPTY` constant) in the maze
    data structure with periods (from the `PATH` constant).
  prefs: []
  type: TYPE_NORMAL
- en: The maze-solving algorithm is similar to our flood fill program in Chapter 3
    in that it “spreads” to neighboring coordinates, though when it reaches a dead
    end, it backtracks to an earlier intersection. The `solveMaze()` function receives
    the x, y coordinates indicating the algorithm’s current location in the maze.
    If this is the exit, the function returns `True`, causing all the recursive calls
    to also return `True`. The maze data structure remains marked with the solution
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the algorithm marks the current x, y coordinates in the maze data
    structure with a period and adds the coordinates to the `visited` list ❷. Then
    it looks to the x, y coordinates north of the current coordinates to see if that
    point is not off the edge of the map, is either the empty or exit space, and has
    not been visited before. If these conditions are met, the algorithm makes a recursive
    call to `solveMaze()` with the northern coordinates. If these conditions aren’t
    met or the recursive call to `solveMaze()` returns `False`, the algorithm continues
    on to check the south, east, and west coordinates. Like the flood fill algorithm,
    recursive calls are made with the neighboring coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: To get a better idea of how this algorithm works, uncomment the two `printMaze(MAZE)`
    calls ❸ ❹ inside the `solveMaze()` function. These will display the maze data
    structure as it attempts new paths, reaches dead ends, backtracks, and tries different
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter explored several algorithms that make use of tree data structures
    and backtracking, which are features of a problem that is suitable for solving
    with recursive algorithms. We covered tree data structures, which are composed
    of nodes that contain data and edges that relate nodes together in parent–child
    relationships. In particular, we examined a specific kind of tree called a directed
    acyclic graph (DAG) that is often used in recursive algorithms. A recursive function
    call is analogous to traversing to a child node in a tree, while returning from
    a recursive function call is analogous to backtracking to a previous parent node.
  prefs: []
  type: TYPE_NORMAL
- en: While recursion is overused for simple programming problems, it is well matched
    for problems that involve tree-like structures and backtracking. Using these ideas
    of tree-like structures, we wrote several algorithms for traversing, searching,
    and determining the depth of tree structures. We also showed that a simply connected
    maze has a tree-like structure, and employed recursion and backtracking to solve
    a maze.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is far more to trees and tree traversal than the brief description of
    DAGs presented in this chapter. The Wikipedia articles at [https://en.wikipedia.org/wiki/Tree_(data_structure)](https://en.wikipedia.org/wiki/Tree_(data_structure))
    and [https://en.wikipedia.org/wiki/Tree_traversal](https://en.wikipedia.org/wiki/Tree_traversal)
    provide additional context for these concepts, which are often used in computer
    science.
  prefs: []
  type: TYPE_NORMAL
- en: The Computerphile YouTube channel also has a video titled “Maze Solving” at
    [https://youtu.be/rop0W4QDOUI](https://youtu.be/rop0W4QDOUI) that discusses these
    concepts. V. Anton Spraul, author of *Think Like a Programmer* (No Starch Press,
    2012), also has a video on maze solving titled “Backtracking” at [https://youtu.be/gBC_Fd8EE8A](https://youtu.be/gBC_Fd8EE8A).
    The freeCodeCamp organization ([https://freeCodeCamp.org](https://freeCodeCamp.org))
    has a video series on backtracking algorithms at [https://youtu.be/A80YzvNwqXA](https://youtu.be/A80YzvNwqXA).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to maze solving, the recursive backtracker algorithm uses recursion
    to generate mazes. You can find out more about this and other maze-generating
    algorithms at [https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker](https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker).
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are nodes and edges?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are root and leaf nodes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three tree traversal orders?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does *DAG* stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a cycle, and do DAGs have cycles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a binary tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the child nodes in a binary tree called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a parent node has an edge to a child node, and the child node has an edge
    back to the parent node, is this graph considered a DAG?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is backtracking in a tree traversal algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the following tree traversal problems, you can use the Python/JavaScript
    code in “A Tree Data Structure in Python and JavaScript” in Chapter 4 for your
    tree and the multiline `MAZE` string from the *mazeSolver.py* and *mazeSolver.html*
    programs for the maze data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer the three questions about recursive solutions for each of the recursive
    algorithms presented in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then re-create the recursive algorithms from this chapter without looking at
    the original code.
  prefs: []
  type: TYPE_NORMAL
- en: Practice Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For practice, write a function for each of the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a reverse-inorder search, one that performs an inorder traversal but
    traverses the right child node before the left child node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that, given a root node as an argument, proceeds to make the
    tree one level deeper by adding one child node to each leaf node in the original
    tree. This function will need to perform a tree traversal, detect when it has
    reached a leaf node, and then add one and only one child node to the leaf node.
    Be sure not to go on and add a child node to this new leaf node, as that will
    eventually cause a stack overflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Divide-and-Conquer Algorithms
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Divide-and-conquer algorithms*are those that split large problems into smaller
    subproblems, then divide those subproblems into ones that are smaller yet, until
    they become trivial to conquer. This approach makes recursion an ideal technique
    to use: the recursive case divides the problem into self-similar subproblems,
    and the base case occurs when the subproblem has been reduced to a trivial size.
    One benefit of this approach is that these problems can be worked on in parallel,
    allowing multiple central processing unit (CPU) cores or computers to work on
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at some common algorithms that use recursion to
    divide and conquer, such as binary search, quicksort, and merge sort. We’ll also
    reexamine summing an array of integers, this time with a divide-and-conquer approach.
    Finally, we’ll take a look at the more esoteric Karatsuba multiplication algorithm,
    developed in 1960, that laid the basis for computer hardware’s fast integer multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary Search: Finding a Book in an Alphabetized Bookshelf'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say you have a bookshelf of 100 books. You can’t remember which books
    you have or their exact locations on the shelf, but you do know that they are
    sorted alphabetically by title. To find your book *Zebras: The Complete Guide*,
    you wouldn’t start at the beginning of the bookshelf, where *Aaron Burr Biography*
    is, but rather toward the end of the bookshelf. Your zebra book wouldn’t be the
    very last book on the shelf if you also had books on zephyrs, zoos, and zygotes,
    but it would be close. Thus, you can use the facts that the books are in alphabetical
    order and that *Z* is the last letter of the alphabet as *heuristics*, or approximate
    clues, to look toward the end of the shelf rather than the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Binary search* is a technique for locating a target item in a sorted list
    by repeatedly determining which half of the list the item is in. The most impartial
    way to search the bookshelf is to start with a book in the middle, and then ascertain
    if the target book you’re looking for is in the left half or the right half.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then repeat this process, as shown in [Figure 5-1](#figure5-1): look
    at the book in the middle of your chosen half and then determine whether your
    target book is in the left-side quarter or the right-side quarter. You can do
    this until you either find the book, or find the place where the book should be
    but isn’t and declare that the book doesn’t exist on the shelf.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing of a bookshelf with labels separating the books into two sections,
    one of which is highlighted. In a second bookshelf drawing, that highlighted portion
    is further split in half. In a third bookshelf drawing, only one book of the previously
    selected portion is highlighted.](image_fi/502024c05/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: A binary search repeatedly determines which half of a range contains
    your target item in a sorted array of items.'
  prefs: []
  type: TYPE_NORMAL
- en: This process scales efficiently; doubling the number of books to search adds
    only one step to the search process. A linear search of a shelf with 50 books
    takes 50 steps, and a linear search of a shelf with 100 books takes 100 steps.
    But a binary search of a shelf with 50 books takes only 6 steps, and a shelf with
    100 books takes only 7 steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursion questions about our binary search implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Searching a range of items that is only one item in length.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The indices of the left
    and right ends of the range in the list we are searching.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The range halves in size
    for each recursive call, so it eventually becomes one item long.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Examine the following `binarySearch()` function in our *binarySearch.py* program,
    which locates a value, `needle`, in a sorted list of values, `haystack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The *binarySearch.html* program has this JavaScript equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run these programs, the list `[1, 4, 8, 11, 13, 16, 19, 19]` is searched
    for `13`, and the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The target value `13` is indeed at index `4` in that list.
  prefs: []
  type: TYPE_NORMAL
- en: The code calculates the middle index (stored in `mid`) of the range defined
    by the `left` and `right` indices. At first, this range is the entire length of
    the items list. If the value at the `mid` index is the same as `needle`, then
    `mid` is returned. Otherwise, we need to figure out whether our target value is
    in the left half of the range (in which case, the new range to search is `left`
    to `mid - 1`) or in the right half (in which case, the new range to search is
    `mid + 1` to `end`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have a function that can search this new range: `binarySearch()`
    itself! A recursive call is made on the new range. If we ever get to the point
    where the right end of the search range comes before the left, we know that our
    search range has shrunk down to zero and our target value isn’t to be found.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the code performs no actions after the recursive call returns; it
    immediately returns the return value of the recursive function call. This feature
    means that we could implement tail call optimization for this recursive algorithm,
    a practice we explain in Chapter 8. But also, it means that binary search can
    easily be implemented as an iterative algorithm that doesn’t use recursive function
    calls. This book’s downloadable resources at [https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion)
    include the source code for an iterative binary search for you to compare with
    the recursive binary search.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quicksort: Splitting an Unsorted Pile of Books into Sorted Piles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that `binarySearch()`’s speed advantage comes from the fact that the
    values in items are sorted. If the values are out of order, the algorithm won’t
    work. Enter *quicksort*, a recursive sorting algorithm developed by computer scientist
    Tony Hoare in 1959.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quicksort uses a divide-and-conquer technique called *partitioning*. Think
    of partitioning this way: imagine you have a large pile of unalphabetized books.
    Grabbing one book and placing it in the right spot on the shelf means you’ll spend
    a lot of time rearranging the bookshelf as it gets full. It would help if you
    first turned the pile of books into two piles: an *A* to *M* pile and an *N* to
    *Z* pile. (In this example, *M* would be our *pivot*.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You haven’t sorted the pile, but you have *partitioned* it. And partitioning
    is easy: the book doesn’t have to go into the correct place in one of the two
    piles, it just has to go into the correct pile. Then you can further partition
    these two piles into four piles: *A* to *G*, *H* to *M*, *N* to *T*, and *U* to
    *Z*. This is shown in [Figure 5-2](#figure5-2). If you keep partitioning, you
    end up with piles that contain one book each (the base case), and the piles are
    now in sorted order. This means the books are now in sorted order as well. This
    repeated partitioning is how quicksort works.'
  prefs: []
  type: TYPE_NORMAL
- en: For the first partitioning of *A* to *Z*, we select *M* as the pivot value because
    it’s the middle letter between *A* and *Z*. However, if our collection of books
    consisted of one book about Aaron Burr and 99 books about zebras, zephyrs, zoos,
    zygotes, and other *Z* topics, our two partitioned piles would be heavily unbalanced.
    We would have the single Aaron Burr book in the *A* to *M* pile and every other
    book in the *M* to *Z* pile. The quicksort algorithm works fastest when the partitions
    are evenly balanced, so selecting a good pivot value at each partition step is
    important.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing of several piles of books in a tree-like structure. Shows one pile
    of books, A–Z, split into two piles, A–M and N–Z. A–M is further split into A–G
    and H–M. N–Z is further split into N–T and U–Z.](image_fi/502024c05/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: Quicksort works by repeatedly partitioning items into two sets.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you don’t know anything about the data you’re sorting, it’s impossible
    to select an ideal pivot. This is why the generic quicksort algorithm simply uses
    the last value in the range for the pivot value.
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, each call to `quicksort()` is given an array of items
    to sort. It is also given `left` and `right` arguments specifying the range of
    indices in that array to sort, similar to `binarySearch()`’s left and right arguments.
    The algorithm selects a pivot value to compare with the other values in the range,
    then places the values to either the left side of the range (if they’re less than
    the pivot value) or the right side (if they’re greater than the pivot value).
    This is the partition step. Next, the `quicksort()` function is recursively called
    on these two, smaller ranges until a range has been reduced to zero. The list
    becomes more and more sorted as the recursive calls are made, until finally the
    entire list is in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the algorithm modifies the array in place. See “Modifying a List or
    Array in Place” in Chapter 4 for details. Thus, the `quicksort()` function doesn’t
    return a sorted array. The base case merely returns to stop producing more recursive
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursion questions about our binary search implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Being given a range to sort that contains zero or one
    item and that is already in sorted order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The indices of the left
    and right ends of the range in the list we are sorting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The range halves in size
    for each recursive call, so it eventually becomes empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following `quicksort()` function in the *quicksort.py* Python program sorts
    the values in the items list into ascending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The *quicksort.html* program contains the JavaScript equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This code is similar to the code in the binary search algorithm. As defaults,
    we set the `left` and `right` ends of the range within the `items` array to the
    beginning and end of the entire array. If the algorithm reaches the base case
    of the `right` end at or before the `left` end (a range of one or zero items),
    the sorting is finished ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'In each call to `quicksort()`, we partition the items in the current range
    (defined by the indices in `left` and `right`), and then swap them around so that
    the items less than the pivot value end up on the left side of the range and the
    items greater than the pivot value end up on the right side of the range. For
    example, if `42` is the pivot value in the array `[81, 48, 94, 87, 83, 14, 6,
    42]`, a partitioned array would be `[14, 6, 42, 81, 48, 94, 87, 83]`. Note that
    a partitioned array is not the same thing as a sorted one: although the two items
    to the left of `42` are less than `42`, and the five items to the right of `42`
    are greater than `42`, the items are not in sorted order.'
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of the `quicksort()` function is the partitioning step. To get an idea
    of how partitioning works, imagine an index `j` that begins at the left end of
    the range and moves to the right end ❷. We compare the item at index `j` with
    the pivot value and then move right to compare the next item. The pivot value
    can be arbitrarily chosen from any value in the range, but we’ll always use the
    value at the right end of the range.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a second index `i` that also begins at the left end. If the item at
    index `j` is less than or equal to the pivot, the items at indices `i` and `j`
    are swapped ❸ and `i` is increased to the next index. So while `j` always increases
    (that is, moves right) after each comparison with the pivot value, `i` increases
    only if the item at index `j` is less than or equal to the pivot.
  prefs: []
  type: TYPE_NORMAL
- en: The names `i` and `j` are commonly used for variables that hold array indices.
    Someone else’s `quicksort()` implementation may instead use `j` and `i`, or even
    completely different variables. The important thing to remember is that two variables
    store indices and behave as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s work through the first partitioning of the array `[0,
    7, 6, 3, 1, 2, 5, 4]`, and the range defined by `left` of `0` and `right` of `7`
    to cover the full size of the array. The `pivot` will be the value at the `right`
    end, `4`. The `i` and `j` index begin at index `0`, the left end of the range.
    At each step, index `j` always moves to the right. Index `i` moves only if the
    value at index `j` is less than or equal to the pivot value. The `items` array,
    the `i` index, and the `j` index begin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The value at index `j` (which is `0`) is less than or equal to the pivot value
    (which is `4`), so swap the values at `i` and `j`. This results in no actual change
    since `i` and `j` are the same index. Also, increase `i` so that it moves to the
    right. The `j` index increases for every comparison with the pivot value. The
    state of the variables now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The value at index `j` (which is `7`) is not less than or equal to the pivot
    value (which is `4`), so don’t swap the values. Remember, `j` always increases,
    but `i` increases only after a swap is performed—so `i` is always either at or
    to the left of `j`. The state of the variables now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The value at index `j` (which is `6`) is not less than or equal to the pivot
    value (which is `4`), so don’t swap the values. The state of the variables now
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The value at index `j` (which is `3`) is less than or equal to the pivot value
    (which is `4`), so swap the values at `i` and `j`. The `7` and `3` swap positions.
    Also, increase `i` so that it moves to the right. The state of the variables now
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The value at index `j` (which is `1`) is less than or equal to the pivot value
    (which is `4`), so swap the values at `i` and `j`. The `6` and `1` swap positions.
    Also, increase `i` so that it moves to the right. The state of the variables now
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The value at index `j` (which is `2`) is less than or equal to the pivot value
    (which is `4`), so swap the values at `i` and `j`. The `7` and `2` swap positions.
    Also, increase `i` so that it moves to the right. The state of the variables now
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The value at index `j` (which is `6`) is not less than or equal to the pivot
    value (which is `4`), so don’t swap the values. The state of the variables now
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve reached the end of the partitioning. The index `j` is at the pivot value
    (which is always the rightmost value in the range), so let’s swap `i` and `j`
    one last time to make sure the pivot is not on the right half of the partition.
    The `6` and `4` swap positions. The state of the variables now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice what is happening with the `i` index: this index will always receive
    the values smaller than the pivot value as a result of swapping; then the `i`
    index moves right to receive future smaller-than-the-pivot values. As a result,
    everything to the left of the `i` index is smaller than or equal to the pivot,
    and everything to the right of the `i` index is greater than the pivot.'
  prefs: []
  type: TYPE_NORMAL
- en: The entire process repeats as we recursively call `quicksort()` on the left
    and right partitions. When we partition these two halves (and then partition the
    four halves of these two halves with more recursive `quicksort()` calls, and so
    on), the entire array ends up sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run these programs, the output shows the process of sorting the `[0,
    7, 6, 3, 1, 2, 5, 4]` list. The rows of periods are meant to help you line up
    the output when writing the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Quicksort is a commonly used sorting algorithm because it is straightforward
    to implement and, well, quick. The other commonly used sorting algorithm, merge
    sort, is also fast and uses recursion. We cover it next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Merge Sort: Merging Small Piles of Playing Cards into Larger Sorted Piles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Computer scientist John von Neumann developed *merge sort* in 1945\. It uses
    a divide-merge approach: each recursive call to `mergeSort()` divides the unsorted
    list into halves until they’ve been whittled down into lists of lengths of zero
    or one. Then, as the recursive calls return, these smaller lists are merged together
    into sorted order. When the last recursive call has returned, the entire list
    will have been sorted.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the divide step takes a list, such as `[2, 9, 8, 5, 3, 4, 7, 6]`,
    and splits it into two lists, like `[2, 9, 8, 5]` and `[3, 4, 7, 6]`, to pass
    to two recursive function calls. At the base case, the lists have been divided
    into lists of zero or one item. A list with nothing or one item is naturally sorted.
    After the recursive calls return, the code merges these small, sorted lists together
    into larger sorted lists until finally the entire list is sorted. [Figure 5-3](#figure5-3)
    shows an example using merge sort on playing cards.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of playing cards being arranged according to a series of steps. The
    first set of steps divides the playing cards into smaller groups, and the second
    set of steps merges these groups until the cards are all together once more.](image_fi/502024c05/f05003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: The divide and merge phases of merge sort'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, at the end of the division phase, we have eight separate lists
    of single numbers: `[2]`, `[9]`, `[8]`, `[5]`, `[3]`, `[4]`, `[7]`, `[6]`. A list
    of just one number is naturally in sorted order. Merging two sorted lists into
    a larger sorted list involves looking at the start of both smaller lists and appending
    the smaller value to the larger list. [Figure 5-4](#figure5-4) shows an example
    of merging `[2, 9]` and `[5, 8]`. This is repeatedly done in the merge phase until
    the end result is that the original `mergeSort()` call returns the full list in
    sorted order.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram representing a series of steps applied to two pairs of playing cards,
    the 2 and 9 of spades and the 5 and 8 of spades. In the first step, because 2
    is smaller than 5, the 2 of spades is selected. In the second step, because 5
    is smaller than 9, the 5 of spades is placed on top of the 2 of spades. In the
    third step, because 8 is smaller than 9, the 8 of spades is placed on top of the
    5 of spades. In the fourth step, the 9 of spades is placed on top of the 8 of
    spades.](image_fi/502024c05/f05004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: The merge step compares the two values at the start of the smaller
    sorted lists and moves them to the larger sorted list. Merging four cards requires
    only four steps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask our three recursive algorithm questions about the merge sort algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Being given a list to sort that has zero or one item
    in it, which is already in sorted order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? Lists made from the
    left and right halves of the original list to sort.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The lists passed to the
    recursive call are half the size of the original list, so they eventually become
    a list of zero or one item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following `mergeSort()` function in the *mergeSort.py* Python program sorts
    the values in the items list into ascending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The *mergeSort.html* program contains the equivalent JavaScript program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The `mergeSort()` function (and all the recursive calls to the `mergeSort()`
    function) takes an unsorted list and returns a sorted list. The first step in
    this function is to check for the base case of a list containing only zero or
    one item ❶. This list is already sorted, so the function returns the list as is.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the function determines the middle index of the list ❷ so that we
    know where to split it into the left- and right-half lists to pass to two recursive
    function calls ❸. The recursive function calls return sorted lists, which we store
    in the left and right variables.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to merge these two sorted half lists into one sorted full list
    named `sortedResult`. We’ll maintain two indices for the `left` and `right` lists
    named `iLeft` and `iRight`. Inside a loop, the smaller of the two values ❹ is
    appended to `sortedResult`, and its respective index variable (either `iLeft`
    or `iRight`) is incremented. If either `iLeft` or `iRight` reaches the end of
    its list, the remaining items in the other half’s list are appended to `sortedResult`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s follow an example of the merging step if the recursive calls have returned
    `[2, 9]` for `left` and `[5, 8]` for `right`. Since these lists were returned
    from `mergeSort()` calls, we can always assume they are sorted. We must merge
    them into a single sorted list in `sortedResult` for the current `mergeSort()`
    call to return to its caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `iLeft` and `iRight` indices begin at `0`. We compare the value at `left[iLeft]`
    (which is `2`) and `right[iRight]` (which is `5`) to find the smaller one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `left[iLeft]`’s value, `2`, is the smaller of the values, we append it
    to `sortedResult` and increase `iLeft` from `0` to `1`. The state of the variables
    is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing `left[iLeft]` and `right[iRight]` again, we find that of `9` and
    `5`, `right[iRight]`’s `5` is smaller. The code appends the `5` to `sortedResult`
    and increases `iRight` from `0` to `1`. The state of the variables is now the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing `left[iLeft]` and `right[iRight]` again, we find that, of `9` and
    `8`, `right[iRight]`’s `8` is smaller. The code appends the `8` to `sortedResult`
    and increases `iRight` from `0` to `1`. Here’s the state of the variables now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Because `iRight` is now `2` and equal to the length of the `right` list, the
    remaining items in `left` from the `iLeft` index to the end are appended to `sortedResult`,
    as no more items remain in `right` to compare them to. This leaves `sortedResult`
    as `[2, 5, 8, 9]`, the sorted list it needs to return. This merging step is performed
    for every call to `mergeSort()` to produce the final sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the *mergeSort.py* and *mergeSort.html* programs, the output shows
    the process of sorting the `[2, 9, 8, 5, 3, 4, 7, 6]` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, the function divides the `[2, 9, 8, 5, 3, 4,
    7, 6]` list into `[2, 9, 8, 5]` and `[3, 4, 7, 6]` and passes these to recursive
    `mergeSort()` calls. The first list is further split into `[2, 9]` and `[8, 5]`.
    That `[2, 9]` list is split into `[2]` and `[9]`. These single-value lists cannot
    be divided anymore, so we have reached our base case. These lists are merged back
    into sorted order as `[2, 9]`. The function divides the `[8, 5]` list into `[8]`
    and `[5]`, reaches the base case, and then merges back into `[5, 8]`.
  prefs: []
  type: TYPE_NORMAL
- en: The `[2, 9]` and `[5, 8]` lists are individually in sorted order. Remember,
    `mergeSort()` doesn’t simply *concatenate* the lists into `[2, 9, 5, 8]`, which
    would not be in sorted order. Rather, the function *merges* them into the sorted
    list `[2, 5, 8, 9]`. By the time the original `mergeSort()` call returns, the
    full list it returns is completely sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Summing an Array of Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already covered summing an array of integers in Chapter 3 with the head-tail
    technique. In this chapter, we’ll use a divide-and-conquer strategy. Since the
    associative property of addition means that adding 1 + 2 + 3 + 4 is the same as
    adding the sums of 1 + 2 and 3 + 4, we can divide a large array of numbers to
    sum into two smaller arrays of numbers to sum.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit is that for larger sets of data to process, we could farm out the
    subproblems to different computers and have them all work together in parallel.
    There’s no need to wait for the first half of the array to be summed before another
    computer can start summing the second half. This is a large advantage of the divide-and-conquer
    technique, as CPUs aren’t getting much faster but we can have multiple CPUs work
    simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three questions about recursive algorithms for our summation
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Either an array containing zero numbers (where we return
    `0`) or an array containing one number (where we return the number).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? Either the left half
    or the right half of the array of numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The size of the array
    of numbers is halved each time, eventually becoming an array containing zero or
    one number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *sumDivConq.py* Python program implements the divide-and-conquer strategy
    for adding numbers in the `sumDivConq()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The *sumDivConq.html* program contains the JavaScript equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sumDivConq()` function first checks the `numbers` array for having either
    zero or one number in it. These trivial base cases are easy to sum since they
    require no addition: return either `0` ❶ or the lone number in the array ❷. Everything
    else is a recursive case; the middle index of the array is calculated ❸ so that
    separate recursive calls with the left half and right half of the numbers array
    are made. The sum of these two return values becomes the return value for the
    current `sumDivConq()` call ❹.'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the associative nature of addition, there’s no reason an array of
    numbers must be added sequentially by a single computer. Our program carries out
    all operations on the same computer, but for large arrays or calculations more
    complicated than addition, our program could send the halves to other computers
    to complete. The problem can be divided into similar subproblems, which is a huge
    hint that a recursive approach can be taken.
  prefs: []
  type: TYPE_NORMAL
- en: Karatsuba Multiplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `*` operator makes multiplication easy to do in high-level programming
    languages such as Python and JavaScript. But low-level hardware needs a way to
    perform multiplication using more primitive operations. We could multiply two
    integers using only addition with a loop, such as in the following Python code
    to multiply `5678 * 1234`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: However, this code doesn’t scale efficiently for large integers. *Karatsuba
    multiplication* is a fast, recursive algorithm discovered in 1960 by Anatoly Karatsuba
    that can multiply integers using addition, subtraction, and a precomputed multiplication
    table of all products from single-digit numbers. This multiplication table, shown
    in [Figure 5-5](#figure5-5), is called a *lookup table*.
  prefs: []
  type: TYPE_NORMAL
- en: Our algorithm won’t need to multiply single-digit numbers because it can just
    look them up in the table. By using memory to store precomputed values, we increase
    memory usage to decrease CPU runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '![A multiplication table of the digits 0 through 9.](image_fi/502024c05/F05005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: A lookup table, such as this table of products of all single-digit
    numbers, saves our program from repeat calculations as the computer stores the
    precomputed values in memory for later retrieval.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll implement Karatsuba multiplication in a high-level language like Python
    or JavaScript as though the `*` operator didn’t already exist. Our `karatsuba()`
    function accepts two integer arguments, `x` and `y`, to multiply. The Karatsuba
    algorithm has five steps, and the first three involve making recursive calls to
    `karatsuba()` with arguments that are smaller, broken-down integers derived from
    `x` and `y`. The base case occurs when the `x` and `y` arguments are both single-digit
    numbers, in which case the product can be found in the precomputed lookup table.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define four more variables: `a` and `b` are each half of the digits
    of `x`, and `c` and `d` are each half of the digits of `y`, as shown in [Figure
    5-6](#figure5-6). For example, if `x` and `y` are `5678` and `1234`, respectively,
    then `a` is `56`, `b` is `78`, `c` is `12`, and `d` is `34`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing x = 5678, with arrows leading to a = 56 and b = 78, and y
    = 1234, with arrows leading to c = 12 and d = 34.](image_fi/502024c05/F05006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: The integers to multiply, `x` and `y`, are divided into halves
    `a`, `b`, `c`, and `d`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the five steps of the Karatsuba algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiply `a` and `c` either from the multiplication lookup table or from a recursive
    call to `karatsuba()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply `b` and `d` either from the multiplication lookup table or from a recursive
    call to `karatsuba()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply `a + c` and `b + d` either from the multiplication lookup table or
    from a recursive call to `karatsuba()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate step 3 – step 2 – step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pad the step 1 and step 4 results with zeros; then add them to step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of step 5 is the product of `x` and `y`. The specifics of how to
    pad the step 1 and step 4 results with zeros are explained later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask our three recursive algorithm questions about the `karatsuba()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? Multiplying single-digit numbers, which can be done with
    a precomputed lookup table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The `a`, `b`, `c`, and
    `d` values derived from the `x` and `y` arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? Since `a`, `b`, `c`,
    and `d` are each half of the digits of `x` and `y` and themselves are used for
    the next recursive call’s `x` and `y` arguments, the recursive call’s arguments
    become closer and closer to the single-digit numbers the base case requires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our Python implementation for Karatsuba multiplication is in the *karatsubaMultiplication.py*
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript equivalent is in *karatsubaMultiplication.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The first part of this program happens before `karatsuba()` is called. Our program
    needs to create the multiplication lookup table in the `MULT_TABLE` variable ❶.
    Normally, lookup tables are hardcoded directly in the source code, from `MULT_TABLE[[0,
    0]] = 0` to `MULT_TABLE[[9, 9]] = 81`. But to reduce the amount of typing, we’ll
    use nested `for` loops to generate each product. Accessing `MULT_TABLE[[m, n]]`
    gives us the product of integers `m` and `n`.
  prefs: []
  type: TYPE_NORMAL
- en: Our `karatsuba()` function also relies on a helper function named `padZeros()`,
    which pads a string of digits with additional zeros on the left or right side
    of the string. This padding is done in the fifth step of the Karatsuba algorithm.
    For example, `padZeros("42", 3, "left")` returns the string `00042`, while `padZeros("99",
    1, "right")` returns the string `990`.
  prefs: []
  type: TYPE_NORMAL
- en: The `karatsuba()` function itself first checks for the base case, where `x`
    and `y` are single-digit numbers. These can be multiplied using the lookup table,
    and their product is immediately returned. Everything else is a recursive case.
  prefs: []
  type: TYPE_NORMAL
- en: We need to convert the `x` and `y` integers into strings and adjust them so
    that they contain the same number of digits. If one of these numbers is shorter
    than the other, zeros are padded to the left side. For example, if `x` is `13`
    and `y` is `2468`, our function calls `padZeros()` so that `x` can be replaced
    with `0013`. This is required because we then create the `a`, `b`, `c`, and `d`
    variables to each contain one-half of the digits of `x` and `y` ❷. The `a` and
    `c` variables must have the same number of digits for the Karatsuba algorithm
    to work, as do the `b` and `d` variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we use division and rounding down to calculate how much is half of
    the digits of `x` ❸. These mathematical operations are as complicated as multiplication
    and might not be available to the low-level hardware we are programming the Karatsuba
    algorithm for. In a real implementation, we could use another lookup table for
    these values: `HALF_TABLE = [0, 0, 1, 1, 2, 2, 3, 3...]`, and so on. Looking up
    `HALF_TABLE[n]` would evaluate to half of `n`, rounded down. An array of a mere
    100 items would be sufficient for all but the most astronomical numbers and save
    our program from division and rounding. But our programs are for demonstration,
    so we’ll just use the `/` operator and built-in rounding functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Once these variables are set up correctly, we can begin making the recursive
    function calls ❹. The first three steps involve recursive calls with arguments
    `a` and `b`, `c` and `d`, and finally `a + b` and `c + d`. The fourth step subtracts
    the results of the first three steps from each other ❺. The fifth step pads the
    results of the first and fourth steps with zeros on the right side, then adds
    them to the results of the second step ❻.
  prefs: []
  type: TYPE_NORMAL
- en: The Algebra Behind the Karatsuba Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These steps may seem like magic, so let’s dive into the algebra that shows why
    they work. Let’s use 1,357 for *x* and 2,468 for *y* as the integers we want to
    multiply. Let’s also consider a new variable, *n*, for the number of digits in
    *x* or *y*. Since *a* is 13 and *b* is 57, we can calculate the original *x* as
    10^(*n*)^(/2) × *a* + *b*, which is 10² × 13 + 57 or 1,300 + 57, or 1,357\. Similarly,
    *y* is the same as 10^(*n*)^(/2) × *c* + *d*.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the product of *x* × *y* = (10^(*n*)^(/2) × *a* + *b*) × (10^(*n*)^(/2)
    × *c* + *d*). Doing a bit of algebra, we can rewrite this equation as *x* × *y*
    = 10*n* × *ac* + 10^(*n*)^(/2) × (*ad* + *bc*) + *bd*. With our example numbers,
    this means 1,357 × 2,468 = 10,000 × (13 × 24) + 100 × (13 × 68 + 57 × 24) + (57
    × 68). Both sides of this equation evaluate to 3,349,076.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve broken the multiplication of *xy* into the multiplications of *ac*, *ad*,
    *bc*, and *bd*. This forms the basis of our recursive function: we’ve defined
    the multiplication of *x* and *y* by using multiplication of smaller numbers (remember,
    *a*, *b*, *c*, and *d* are half the digits of *x* or *y*) that approach the base
    case of multiplying single-digit numbers. And we can perform single-digit multiplication
    with a lookup table rather than multiplying.'
  prefs: []
  type: TYPE_NORMAL
- en: So we need to recursively compute *ac* (the first step of the Karatsuba algorithm)
    and *bd* (the second step). We also need to calculate (*a* + *b*)(*c* + *d*) for
    the third step, which we can rewrite as *ac* + *ad* + *bc* + *bd*. We already
    have *ac* and *bd* from the first two steps, so subtracting those gives us *ad*
    + *bc*. This means we need only one multiplication (and one recursive call) to
    calculate (*a* + *b*)(*c* + *d*) instead of two to calculate *ad* + *bc*. And
    *ad* + *bc* is needed for the 10*n*^(/2) × (*ad* + *bc*) part of our original
    equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying by the 10*n* and 10^(*n*)^(/2) powers of 10 can be done by padding
    zero digits: for example, 10,000 × 123 is 1,230,000\. So, there’s no need to make
    recursive calls for those multiplications. In the end, multiplying *x* × *y* can
    be broken into multiplying three smaller products with three recursive calls:
    `karatsuba(a, c)`, `karatsuba(b, d)`, and `karatsuba((a + b), (c + d))`.'
  prefs: []
  type: TYPE_NORMAL
- en: With some careful study of this section, you can understand the algebra behind
    the Karatsuba algorithm. What I can’t understand is how Anatoly Karatsuba was
    clever enough to devise this algorithm in less than a week as a 23-year-old student
    in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dividing problems into smaller, self-similar problems is at the heart of recursion,
    making these divide-and-conquer algorithms especially suited for recursive techniques.
    In this chapter, we created a divide-and-conquer version of Chapter 3’s program
    for summing numbers in an array. One benefit of this version is that upon dividing
    a problem into multiple subproblems, the subproblems can be farmed out to other
    computers to work on in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: A binary search algorithm searches a sorted array by repeatedly narrowing the
    range to search in half. While a linear search starts searching at the beginning
    and searches the entire array, a binary search takes advantage of the array’s
    sorted order to home in on the item it is looking for. The performance improvement
    is so great that it may be worthwhile to sort an unsorted array in order to enable
    a binary search on its items.
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered two popular sorting algorithms in this chapter: quicksort and merge
    sort. Quicksort divides an array into two partitions based on a pivot value. The
    algorithm then recursively partitions these two partitions, repeating the process
    until the partitions are the size of a single item. At this point, the partitions,
    and the items in them, are in sorted order. Merge sort takes an opposite approach.
    The algorithm splits the array into smaller arrays first, and then merges the
    smaller arrays into sorted order afterward.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered Karatsuba multiplication, a recursive algorithm for performing
    integer multiplication when the `*` multiplication operator isn’t available. This
    comes up in low-level hardware programming that doesn’t offer a built-in multiplication
    instruction. The Karatsuba algorithm breaks down multiplying two integers into
    three multiplications of smaller integers. To multiply single-digit numbers for
    the base case, the algorithm stores every product from 0 × 0 to 9 × 9 in a lookup
    table.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithms in this chapter are part of many data structure and algorithm
    courses that freshman computer science students take. In the next chapter, we’ll
    continue to look at other algorithms at the heart of computing with algorithms
    that calculate permutations and combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Computerphile channel on YouTube has videos on quicksort at [https://youtu.be/XE4VP_8Y0BU](https://youtu.be/XE4VP_8Y0BU)
    and merge sort at [https://youtu.be/kgBjXUE_Nwc](https://youtu.be/kgBjXUE_Nwc).
    If you want a more comprehensive tutorial, the free “Algorithmic Toolbox” online
    course covers many of the same topics that a freshman data structures and algorithms
    course would cover, including binary search, quicksort, and merge sort. You can
    sign up for this Coursera course at [https://www.coursera.org/learn/algorithmic-toolbox](https://www.coursera.org/learn/algorithmic-toolbox).
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms are often compared to each other in lessons on big O algorithm
    analysis, which you can read about in Chapter 13 of my book *Beyond the Basic
    Stuff with Python* (No Starch Press, 2020). You can read this chapter online at
    [https://inventwithpython.com/beyond](https://inventwithpython.com/beyond). Python
    developer Ned Batchelder describes big O and “how code slows as your data grows”
    in his 2018 PyCon talk of the same name at [https://youtu.be/duvZ-2UK0fc](https://youtu.be/duvZ-2UK0fc).
  prefs: []
  type: TYPE_NORMAL
- en: Divide-and-conquer algorithms are useful because they often can be run on multiple
    computers in parallel. Guy Steele Jr. gives a Google TechTalk titled “Four Solutions
    to a Trivial Problem” on this topic at [https://youtu.be/ftcIcn8AmSY](https://youtu.be/ftcIcn8AmSY).
  prefs: []
  type: TYPE_NORMAL
- en: Professor Tim Roughgarden produced a video lecture for Stanford University on
    Karatsuba multiplication at [https://youtu.be/JCbZayFr9RE](https://youtu.be/JCbZayFr9RE).
  prefs: []
  type: TYPE_NORMAL
- en: To help your understanding of quicksort and merge sort, obtain a pack of playing
    cards or simply write numbers on index cards and practice sorting them by hand
    according to the rules of these two algorithms. This offline approach can help
    you remember the pivot-and-partition of quicksort and the divide-merge of merge
    sort.
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a benefit of the divide-and-conquer summing algorithm in this chapter
    compared to the head-tail summing algorithm in Chapter 3?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a binary search of 50 books on a shelf takes six steps, how many steps would
    it take to search twice as many books?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a binary search algorithm search an unsorted array?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is partitioning the same thing as sorting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens in quicksort’s partition step?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the pivot value in quicksort?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base case of quicksort?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many recursive calls does the `quicksort()` function have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the array `[0, 3, 1, 2, 5, 4, 7, 6]` not properly partitioned with a
    pivot value of `4`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base case of merge sort?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many recursive calls does the `mergeSort()` function have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the resultant array when the merge sort algorithm sorts the arrays `[12,
    37, 38, 41, 99]` and `[2, 4, 14, 42]`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a lookup table?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Karatsuba algorithm that multiplies integers *x* and *y*, what do the
    *a*, *b*, *c*, and *d* variables store?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer the three questions about recursive solutions for each of the recursive
    algorithms presented in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then re-create the recursive algorithms from this chapter without looking at
    the original code.
  prefs: []
  type: TYPE_NORMAL
- en: Practice Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For practice, write a function for each of the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a version of the `karatsuba()` function that has a multiplication lookup
    table of products from 0 × 0 to 999 × 999 rather than 0 × 0 to 9 × 9\. Get a rough
    estimate of how long it takes to calculate `karatsuba(12345678, 87654321)` 10,000
    times in a loop with this larger lookup table compared to the original lookup
    table. If this still runs too quickly to measure, increase the number of iterations
    to 100,000 or 1,000,000 or more. (Hint: you should delete or comment out the `print()`
    and `document.write()` calls inside the `karatsuba()` function for this timing
    test.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that performs a linear search on a large array of integers
    10,000 times. Get a rough estimate of how long this takes, increasing the number
    of iterations to 100,000 or 1,000,000 if the program executes too quickly. Compare
    this with how long a second function takes to sort the array once before performing
    the same number of binary searches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Permutations and Combinations
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Problems involving permutations and combinations are especially suited to recursion.
    These are common in *set theory*, a branch of mathematical logic that deals with
    the selection, arrangement, and manipulation of collections of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with small sets in our short-term memory is simple. We can easily come
    up with every possible order (that is, *permutation*) or combination of a set
    of three or four objects. Ordering and combining items in a larger set requires
    the same process but quickly turns into an impossible task for our human brains.
    At that point, it becomes practical to bring in computers to handle the combinatorial
    explosion that occurs as we add more objects to a set.
  prefs: []
  type: TYPE_NORMAL
- en: At its heart, calculating permutations and combinations of large groups involves
    calculating permutations and combinations of smaller groups. This makes these
    calculations suitable for recursion. In this chapter, we’ll look at recursive
    algorithms for generating all possible permutations and combinations of characters
    in a string. We’ll expand on this to generate all possible combinations of balanced
    parentheses (orderings of open parentheses correctly matched to closing parentheses).
    And finally, we will calculate the power set of a set—that is, the set of all
    possible subsets of a set.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the recursive functions in this chapter have an argument named `indent`.
    This isn’t used by the actual recursive algorithms; rather, it is used by their
    debugging output so that you can see which level of recursion produced the output.
    The indentation is increased by one space for each recursive call and rendered
    in the debugging output as periods so that it’s easy to count the level of indentation.
  prefs: []
  type: TYPE_NORMAL
- en: The Terminology of Set Theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter doesn’t cover set theory as completely as a math or computer science
    textbook would. But it covers enough to justify starting with an explanation of
    the discipline’s basic terminology, as doing so will make the rest of this chapter
    easier to understand. A *set* is a collection of unique objects, called *elements*,
    or *members*. For example, the letters *A*, *B*, and *C* form a set of three letters.
    In mathematics (and in Python code syntax), sets are written inside curly braces,
    with the objects separated by commas: {A, B, C}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Order doesn’t matter for a set; the set {A, B, C} is the same set as {C, B,
    A}. Sets have distinct elements, meaning there are no duplicates: {A, C, A, B}
    has repeat *A*s and so is not a set.'
  prefs: []
  type: TYPE_NORMAL
- en: A set is a *subset* of another set if it has only members of the other set.
    For example, {A, C} and {B, C} are both subsets of {A, B, C}, but {A, C, D} is
    not a subset of it. Conversely, {A, B, C} is a *superset* to {A, C} and also to
    {B, C} because it contains all their elements. The *empty set* { } is a set that
    contains no members at all. Empty sets are considered subsets of every possible
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'A subset can also include all the elements of the other set. For example, {A,
    B, C} is a subset of {A, B, C}. But a *proper subset*, or *strict subset*, is
    a subset that does not have all the set’s elements. No set is a proper subset
    of itself: so {A, B, C} is a subset but not a proper subset of {A, B, C}. All
    other subsets are proper subsets. [Figure 6-1](#figure6-1) shows a graphical representation
    of the set {A, B, C} and some of its subsets.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing of nested circles: an outer, dashed-line circle; a circle within
    the dashed circle, containing B; a circle within that circle, containing A and
    C; and a circle within that circle, containing no letters.](image_fi/502024c06/f06001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: The set {A, B, C} within the dashed lines and some of its subsets
    {A, B, C}, {A, C}, and { } within the solid lines. The circles represent sets,
    and the letters represent elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *permutation* of a set is a specific ordering of all elements in the set.
    For example, the set {A, B, C} has six permutations: ABC, ACB, BAC, BCA, CAB,
    and CBA. We call these *permutations* *without* *repetition*, or *permutations*
    *without *replacement*, because each element doesn’t appear in the permutation
    more than once.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*A *combination* is a selection of elements of a set. More formally, a *k-combination*
    is a subset of *k* elements from a set. Unlike permutations, combinations don’t
    have an ordering. For example, the 2-combinations of the set {A, B, C} are {A,
    B}, {A, C}, and {B, C}. The 3-combination of the set {A, B, C} is {A, B, C}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The term *n choose k* refers to the number of possible combinations (without
    repetition) of *k* elements that can be selected from a set of *n* elements. (Some
    mathematicians use the term *n choose r*.) This concept has nothing to do with
    the elements themselves, just the number of them. For example, 4 choose 2 is 6,
    because there are six ways to choose two elements from a set of four elements
    like {A, B, C, D}: {A, B}, {A, C}, {A, D}, {B, C}, {B, D}, and {C, D}. Meanwhile,
    3 choose 3 is 1, because there’s only one 3-combination from a set of three elements
    like {A, B, C}; that is, {A, B, C} itself. The formula for calculating *n* choose
    *k* is (*n!*) / (*k*! × (*n* – *k*)!). Recall that *n*! is the notation for factorials:
    5! is 5 × 4 × 3 × 2 × 1.'
  prefs: []
  type: TYPE_NORMAL
- en: The term *n multichoose k* refers to the number of possible combinations *with
    repetition* of *k* elements that can be selected from a set of *n* elements. Because
    *k*-combinations are sets and sets do not have duplicate elements, a *k*-combination
    does not have repetition. When we use *k*-combinations with duplicate elements,
    we specifically call them *k-combinations with repetition*.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that, both with and without repetition, you can think of permutation
    as a certain arrangement of all elements in a set, while a combination is an orderless
    selection of certain elements from a set. Permutations have an ordering and use
    all the elements from a set, while combinations don’t have an ordering and use
    any number of elements from a set. To get a better idea of these terms, [Table
    6-1](#table6-1) shows the difference between permutations and combinations, with
    and without repetition, of the set {A, B, C}.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1: All Possible Permutations and Combinations, with and without Repetition,
    of the Set {A, B, C}'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Permutations** | **Combinations** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Without repetition** | ABC, ACB, BAC, BCA, CAB | (None), A, B, C, AB, AC,
    BC, ABC |'
  prefs: []
  type: TYPE_TB
- en: '| **With repetition** | AAA, AAB, AAC, ABA, ABB, ABC, ACA, ACB, ACC, BAA, BAB,
    BAC, BBA, BBB, BBC, BCA, BCB, BCC, CAA, CAB, CAC, CBA, CBB, CBC, CCA, CCB, CCC
    | (None), A, B, C, AA, AB, AC, BB, BC, CC, AAA, AAB, AAC, ABB, ABC, ACC, BBB,
    BBC, BCC, CCC |'
  prefs: []
  type: TYPE_TB
- en: It’s surprising how quickly the number of permutations and combinations grows
    as we add elements to a set. This *combinatorial explosion* is captured by the
    formulas in [Table 6-2](#table6-2). For example, a set of 10 elements has 10!,
    or 3,628,800, possible permutations, but a set of twice as many elements has 20!,
    or 2,432,902,008,176,640,000, permutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-2: Calculating the Number of Possible Permutations and Combinations,
    with and without Repetition, of a Set of *n* Elements'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Permutations** | **Combinations** |'
  prefs: []
  type: TYPE_TB
- en: '| **Without repetition** | *n*! | 2*n* |'
  prefs: []
  type: TYPE_TB
- en: '| **With repetition** | *n*^(*n*) | 2*n* choose *n*, or (2*n*)! / (*n*!)² |'
  prefs: []
  type: TYPE_TB
- en: 'Note that permutations without repetition are always the same size as the set.
    For example, the permutations of {A, B, C} are always three letters long: ABC,
    ACB, BAC, and so forth. However, permutations with repetition can be of any length.
    [Table 6-1](#table6-1) shows the three-letter permutations of {A, B, C} ranging
    from AAA to CCC, but you could also, for example, have five-letter permutations
    with repetition ranging from AAAAA to CCCCC. The number of permutations with repetition
    of *n* elements that are *k* elements long is *n*^(*k*). [Table 6-2](#table6-2)
    lists it as *n*^(*n*) for permutations with repetition that are also *n* elements
    long.'
  prefs: []
  type: TYPE_NORMAL
- en: Ordering matters for permutations, but not for combinations. While AAB, ABA,
    and BAA are considered the same combination with repetition, they are considered
    three separate permutations with repetition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding All Permutations Without Repetition: A Wedding Seating Chart'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you must arrange the seating chart for a wedding reception with delicate
    social requirements. Some of the guests hate each other, while others demand to
    sit near an influential guest. The seats at the rectangular table form one long,
    straight row, rather than a circle. It’d be helpful for your planning to see every
    possible ordering of guests—that is, every permutation without repetition of the
    set of guests. No repetition occurs, because each guest appears in the seating
    chart only once.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use a simple example of Alice, Bob, and Carol, or {A, B, C}. [Figure 6-2](#figure6-2)
    shows all six possible permutations of these three wedding guests.
  prefs: []
  type: TYPE_NORMAL
- en: One way we can determine the number of permutations without repetition is with
    a head-tail recursive strategy. We select one element from the set as the head.
    We then get every permutation of the rest of the elements (which constitute the
    tail), and for each permutation we place the head in every possible location in
    the permutation.
  prefs: []
  type: TYPE_NORMAL
- en: In our ABC example, we’ll start with Alice (A) as the head and Bob and Carol
    (BC) as the tail. The permutations of {B, C} are BC and CB. (How we got BC and
    CB is explained in the next paragraph, so just put that question aside for now.)
    We’ll put A in every possible location in BC. That is, we put Alice before Bob
    (ABC), in between Bob and Carol (BAC), and after Carol (BCA). This creates the
    permutations ABC, BAC, and BCA. We also put A in every possible position in CB,
    creating ACB, CAB, and CBA. This creates all six permutations of Alice, Bob, and
    Carol sitting at the reception table. Now we can pick the arrangement that results
    in the fewest fights (or the most fights, if you want a memorable wedding reception).
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing of six dinner tables seating the same three people arranged in different
    orders.](image_fi/502024c06/f06002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: All six possible permutations of three wedding guests at a table'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, to get every permutation of {B, C}, we’d recursively repeat the process
    with B as the head and C as the tail. The permutation of a single character is
    the character itself; this is our base case. By putting the head B in every possible
    location in C, we get the BC and CB permutations we used in the previous paragraph.
    Remember that, while order doesn’t matter with sets (as {B, C} is the same as
    {C, B}), it does matter with permutations (BC is not a duplicate of CB).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our recursive permutation function accepts as an argument a string of characters
    and returns an array of strings of every possible permutation of those characters.
    Let’s ask the three questions about our recursive algorithms for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? An argument of a single character string or empty string,
    which returns an array of just that string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The string argument
    missing one character. A separate recursive call is made for each character missing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? The size of the string
    shrinks and eventually becomes a single-character string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The recursive permutations algorithm is implemented in *permutations.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent JavaScript program is in *permutations.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these programs is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'When `getPerms()` is called, it first checks for the base case ❶. If the `chars`
    string is only one character long, it can have only one permutation: the `chars`
    string itself. The function returns this string in an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, in the recursive case, the function splits the `chars` argument’s
    first character into the `head` variable and the rest into the `tail` variable
    ❷. The function makes a recursive call to `getPerms()` to get all the permutations
    of the string in `tail`. A first `for` loop ❸ iterates over each of these permutations,
    and a second `for` loop ❹ creates a new permutation by placing the `head` character
    in every possible place in the string.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if `getPerms()` is called with `ABCD` for the `chars` argument,
    `head` is `A` and `tail` is `BCD`. The `getPerms('BCD')` call returns an array
    of the tail permutations, `['BCD', 'CBD', 'CDB', 'BDC', 'DBC', 'DCB']`. The first
    `for` loop starts with the `BCD` permutation, and the second `for` loop places
    the `A` string in `head` in each possible place, producing `ABCD`, `BACD`, `BCAD`,
    `BCDA`. This is repeated with the remaining tail permutations, and the entire
    list is then returned by the `getPerms()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting Permutations with Nested Loops: A Less-Than-Ideal Approach'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we have a simple bicycle lock, as in [Figure 6-3](#figure6-3), with
    a four-digit combination. The combination has 10,000 possible permutations of
    digits (0000 to 9999), but only one will unlock it. (They are called *combination
    locks*; however, in this context it’d be more accurate to call them *permutations
    with repetition locks*, since the order matters.)
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s say we have a much simpler lock with only the five letters A to E.
    We can calculate the number of possible combinations as 5⁴, or 5 × 5 × 5 × 5,
    or 625\. A combination lock of *k* characters, each character selected from a
    set of *n* possibilities, is *n*^(*k*). But getting a list of the combinations
    themselves is a bit more involved.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a bicycle lock with a four-digit combination.](image_fi/502024c06/f06003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: A four-digit combination bicycle lock has 10⁴, or 10,000, possible
    permutations with repetition (photo courtesy of Shaun Fisher, CC BY 2.0 license).'
  prefs: []
  type: TYPE_NORMAL
- en: One way to get permutations with repetition is with *nested loops*—that is,
    a loop within another loop. The inner loop goes through every element in a set,
    whereas the outer loop does the same while repeating the inner loop. Creating
    all possible *k*-character permutations, each character selected from a set of
    *n* possibilities, requires *k* nested loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, *nestedLoopPermutations.py* contains code that generates all 3-combinations
    of {A, B, C, D, E}:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'And *nestedLoopPermutations.html* contains the equivalent JavaScript program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these programs looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The problem with generating permutations with four nested loops is that it works
    only for permutations that are exactly four characters. Nested loops cannot generate
    permutations for arbitrary lengths. Instead, we can use a recursive function,
    as described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: You can remember the difference between permutations with and without repetition
    with the examples in this chapter. Permutations *without* repetition go through
    all possible orderings of the elements in a set, like our wedding guest seating
    chart example. Permutations *with* repetition go through all the possible combinations
    of a combination lock; the order matters, and the same element can appear more
    than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Permutations with Repetition: A Password Cracker'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you have received a sensitive encrypted file from a recently deceased
    journalist. In their final message, the journalist told you the file contains
    records of tax evasion by a nefarious trillionaire. They didn’t have the password
    to decrypt the file, but they did know that it is exactly four characters long;
    also, the possible characters are the numbers 2, 4, and 8 and the letters J, P,
    and B. These characters can appear more than once. For example, possible passwords
    are JPB2, JJJJ, and 2442\.
  prefs: []
  type: TYPE_NORMAL
- en: To generate a list of all possible four-character passwords based on this information,
    you want to obtain all possible four-element permutations with repetition of the
    set {J, P, B, 2, 4, 8}. Each of the four characters in the password can be one
    of the six possible characters, making 6 × 6 × 6 × 6, or 6⁴, or 1,296 possible
    permutations. We want to generate the permutations of {J, P, B, 2, 4, 8}, and
    not the combinations, because the ordering matters; JPB2 is a different password
    from B2JP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursive algorithm questions about our permutations function.
    Instead of *k*, we’ll use the more descriptive name `permLength`:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? A `permLength` argument of `0`, meaning a permutation
    zero characters long, signals that the `prefix` argument now contains the complete
    permutation and so `prefix` should be returned in an array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The `chars` string of
    the characters to get permutations of, a `permLength` argument that begins as
    the length of `chars`, and a `prefix` argument that begins as the blank string.
    Recursive calls decrement the `permLength` argument while appending a character
    from `chars` to the `prefix` argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? Eventually, the `permLength`
    argument decrements to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The algorithm for recursive permutations with repetition is implemented in
    *permutationsWithRepetition.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent JavaScript program is in *permutationsWithRepetition.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these programs is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The `getPermsWithRep()` function has a `prefix` string argument that begins
    as a blank string by default. When the function is called, it first checks for
    the base case ❶. If `permLength`, the length of the permutations, is `0`, an array
    with `prefix` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, in the recursive case, for each character in the `chars` argument
    the function creates a new prefix ❷ to pass to the recursive `getPermsWithRep()`
    call. This recursive call passes `permLength - 1` for the `permLength` argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `permLength` argument starts at the length of the permutations and decreases
    by one for each recursive call ❸. And the `prefix` argument starts as the blank
    string and increases by one character for each recursive call. So by the time
    the base case of `k == 0` is reached, the `prefix` string is the full permutation
    length of `k`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s consider the case of calling `getPermsWithRep(''ABC'', 2)`.
    The `prefix` argument defaults to the blank string. The function makes a recursive
    call with each character of `ABC` concatenated to the blank prefix string as the
    new prefix. Calling `getPermsWithRep(''ABC'', 2)` makes these three recursive
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getPermsWithRep(''ABC'', 1, ''A'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPermsWithRep(''ABC'', 1, ''B'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPermsWithRep(''ABC'', 1, ''C'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these three calls will make its own three recursive calls, but will
    pass `0` for `permLength` instead of `1`. The base case occurs when `permLength
    == 0`, so these return their prefixes. This is how all nine of the permutations
    are generated. The `getPermsWithRep()` function generates permutations of larger
    sets the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting K-Combinations with Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that order is not significant for combinations in the way it is for
    permutations. Yet generating all *k*-combinations of a set is a bit tricky because
    you don’t want your algorithm to generate duplicates: if you create the AB 2-combination
    from the set {A, B, C}, you don’t want to also create BA, because it’s the same
    2-combination as AB.'
  prefs: []
  type: TYPE_NORMAL
- en: To figure out how we can write recursive code to solve this problem, let’s see
    how a tree can visually describe generating all the *k*-combinations of a set.
    [Figure 6-4](#figure6-4) shows a tree with all the combinations from the set {A,
    B, C, D}.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagram with each level of depth classified as either 0-combinations,
    1-combinations, 2-combinations, 3-combinations, or 4-combinations.](image_fi/502024c06/f06004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: Tree showing every possible *k*-combination (from 0 to 4) from
    the set {A, B, C, D}'
  prefs: []
  type: TYPE_NORMAL
- en: 'To gather, for example, 3-combinations from this tree, start at the root node
    at the top and do a depth-first tree traversal to the 3-combinations level, while
    memorizing each node’s letter on the way to the bottom. (Depth-first searches
    are discussed in Chapter 4.) Our first 3-combination would be going from the root
    to A in the 1-combination level, then down to B in the 2-combination level, then
    to C in the 3-combination level, where we stop with our complete 3-combination:
    ABC. For the next combination, we traverse from the root to A to B to D, giving
    us the combination ABD. We continue doing this for ACD and BCD. Our tree has four
    nodes in the 3-combination level, and four 3-combinations from {A, B, C, D}: ABC,
    ABD, ACD, and BCD.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we create the tree in [Figure 6-4](#figure6-4) by starting with
    a blank string for the root node. This is the 0-combination level, and it applies
    to all combinations of zero selections from the set; it’s simply an empty string.
    The child nodes of the root are all elements from the set. In our case, that is
    all four elements from {A, B, C, D}. While sets don’t have an order, we need to
    be consistent in using the ABCD order of the set while generating this tree. This
    is because every node’s children consist of the letters after it in the ABCD string:
    all A nodes have children B, C, and D; all B nodes have children C and D; all
    C nodes have one D child; and all D nodes have no child nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While it’s not directly related to the recursive combination function, also
    notice the pattern in the number of *k*-combinations at each level:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The 0-combination and 4-combination levels both have one combination: the empty
    string and ABCD, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The 1-combination and 3-combination levels both have four combinations: A,
    B, C, D and ABC, ABD, ACD, BCD, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The 2-combination level in the middle has the most combinations at six: AB,
    AC, AD, BC, BD, and CD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reason the number of combinations increases, peaks in the middle, and then
    decreases is that the *k*-combinations are mirrors of each other. For example,
    the 1-combinations are made from the elements not selected for the 3-combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: The 1-combination A is the mirror of the 3-combination BCD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 1-combination B is the mirror of the 3-combination ACD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 1-combination C is the mirror of the 3-combination ABD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 1-combination D is the mirror of the 3-combination ABC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll create a function called `getCombos()` that takes two arguments: a `chars`
    string with the letters to get combinations from, and the size of the combinations
    `k`. The return value is an array of strings of combinations from the string `chars`,
    each of length `k`.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use a head-tail technique with the `chars` argument. For example, say
    we call `getCombos('ABC', 2)` to get all the 2-combinations from {A, B, C}. The
    function will set `A` as the head and `BC` as the tail. [Figure 6-5](#figure6-5)
    shows the tree for selecting 2-combinations from {A, B, C}.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagram classifying each depth level as 0-combinations, 1-combinations,
    2-combinations, or 3-combinations.](image_fi/502024c06/f06005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: Tree showing every possible 2-combination from the set {A, B, C}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask our three recursive algorithm questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? The first base case is a `k` argument of `0`, meaning
    that a 0-combination is requested, which is always an array of the blank string
    no matter what `chars` is. The second case occurs if `chars` is the blank string,
    which is an empty array since no possible combinations can be made from a blank
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? For the first recursive
    call, the tail of `chars` and `k - 1` are passed. For the second recursive call,
    the tail of `chars` and `k` are passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? Since the recursive calls
    decrement `k` and remove the heads from the `chars` arguments, eventually the
    `k` argument decrements to `0` or the `chars` argument becomes the blank string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Python code for generating combinations is in *combinations.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent JavaScript program is in *combinations.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these programs is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Every `getCombos()` function call has two recursive calls for the two parts
    of the algorithm. For our `getCombos('ABC', 2)` example, the first part ❶ is to
    get all the combinations that include the head `A`. In the tree, this generates
    all the combinations *under* the A node in the 1-combination level.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by passing the tail and `k - 1` to the first recursive function
    call: `getCombos(''BC'', 1)` ❷. We add `A` to each combination that this recursive
    function call returns. Let’s use the leap-of-faith principle and just assume our
    `getCombos()` correctly returns a list of *k*-combinations, `[''B'', ''C'']`,
    even though we haven’t finished writing it yet. We now have all the *k*-combinations
    that include the head `A` in an array to hold our results: `[''AB'', ''AC'']`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part ❸ gets all the combinations that don’t include the head `A`.
    In the tree, this generates all the combinations *to the right* of the A node
    in the 1-combination level. We can do this by passing the tail and `k` to the
    second recursive function call: `getCombos(''BC'', 2)`. This returns `[''BC'']`,
    since BC is the only 2-combination of BC.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results from `getCombos(''ABC'', 2)`’s two recursive calls, `[''AB'', ''AC'']`
    and `[''BC'']`, are concatenated together and returned: `[''AB'', ''AC'', ''BC'']`
    ❹. The `getCombos()` function generates combinations of larger sets the same way.'
  prefs: []
  type: TYPE_NORMAL
- en: Get All Combinations of Balanced Parentheses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A string has *balanced parentheses* if every opening parenthesis is followed
    by exactly one closing parenthesis. For example, `′()()′` and `′(())′` are strings
    of two balanced parentheses pairs, but `′)(()′` and `′(()′` are not balanced.
    These strings are also called *Dyck words*, after mathematician Walther von Dyck.
  prefs: []
  type: TYPE_NORMAL
- en: A common coding interview question is to write a recursive function that, given
    the number of pairs of parentheses, produces all possible combinations of balanced
    parentheses. For example, a `getBalancedParens(3)` call should return `['((()))',
    '(()())', '(())()', '()(())', '()()()']`. Note that calling `getBalancedParens(``n``)`
    `returns strings that are 2*n* characters in length, since each string consists
    of *n* pairs of parentheses.`
  prefs: []
  type: TYPE_NORMAL
- en: '`We could try to solve this problem by finding all permutations of the pairs
    of parenthesis characters, but that would result in both balanced and unbalanced
    parentheses strings. Even if we filtered out the invalid strings later, 2*n*!
    permutations exist for *n* pairs of parentheses. That algorithm is far too slow
    to be practical.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can implement a recursive function to generate all strings of balanced
    parentheses. Our `getBalancedParens()` function takes an integer of the number
    of pairs of parentheses and returns a list of balanced parentheses strings. The
    function builds these strings by adding either an opening or closing parenthesis.
    An opening parenthesis can be added only if opening parentheses remain to be used.
    A closing parenthesis can be added only if more opening parentheses have been
    added than closing parentheses so far.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll track the number of opening and closing parentheses remaining to be used
    with function parameters named `openRem` and `closeRem`. The string currently
    being built is another function parameter named `current`, which serves a similar
    purpose as the `prefix` parameter in the *permutationsWithRepetition* program.
    The first base case occurs when `openRem` and `closeRem` are both `0` and no more
    parentheses remain to be added to the `current` string. The second base case happens
    after the two recursive cases have received the lists of balanced parentheses
    strings after adding an opening and/or closing parenthesis (if possible).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursive algorithm questions about the `getBalancedParens()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? When the number of opening and closing parentheses remaining
    to be added to the string being built has reached `0`. A second base case always
    occurs after the recursive cases have finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The total number of
    pairs of parentheses (`pairs`), the remaining number of opening and closing parentheses
    to add (`openRem` and `closeRem`), and the string currently being built (`current`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? As we add more opening
    and closing parentheses to `current`, we decrement the `openRem` and `closeRem`
    arguments until they become 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *balancedParentheses.py* file contains the Python code for our balanced
    parentheses recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The *balancedParentheses.html* file contains the JavaScript equivalent of this
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these programs looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The `getBalancedParens()` function ❶ requires one argument, the number of pairs
    of parentheses, when called by the user. However, it needs to pass additional
    information in the arguments to its recursive calls. These include the number
    of opening parentheses that remain to be added (`openRem`), the number of closing
    parentheses that remain to be added (`closeRem`), and the current balanced parentheses
    string being built (`current`). Both `openRem` and `closeRem` start as the same
    value as the `pairs` argument, and `current` starts as the blank string. An `indent`
    argument is used only for the debugging output to show the program’s level of
    recursive function call.
  prefs: []
  type: TYPE_NORMAL
- en: The function first checks the number of opening and closing parentheses remaining
    to be added ❷. If both are `0`, we’ve reached the first base case, and the string
    in `current` is finished. Since the `getBalancedParens()` function returns a list
    of strings, we put `current` in a list and return it ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the function continues on to the recursive case. If possible opening
    parentheses remain ❹, the function calls `getBalancedParens()` with an opening
    parenthesis added to the current argument. If more closing parentheses are remaining
    than opening parentheses ❺, the function calls `getBalancedParens()` with a closing
    parenthesis added to the current argument. This check ensures that an unmatched
    closing parenthesis won’t be added, as this would make the string unbalanced,
    such as the second closing parenthesis in `())`.
  prefs: []
  type: TYPE_NORMAL
- en: After these recursive cases is an unconditional base case that returns all the
    strings returned from the two recursive function calls (and, of course, the recursive
    function calls made by these recursive function calls, and so on) ❻.
  prefs: []
  type: TYPE_NORMAL
- en: 'Power Set: Finding All Subsets of a Set'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *power set* of a set is the set of every possible subset of that set. For
    example, the power set of {A, B, C} is {{ }, {A}, {B}, {C}, {A, B}, {A, C}, {B,
    C}, {A, B, C}}. This is equivalent to the set of every possible *k*-combination
    of a set. After all, the power set of {A, B, C} contains all its 0-combinations,
    1-combinations, 2-combinations, and 3-combinations.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re looking for a real-world example in which you would need to generate
    the power set of a set, imagine a job interviewer asked you to generate the power
    set of a set. It is astronomically unlikely you’ll need to generate the power
    set of a set for any other reason, including the job you are interviewing for.
  prefs: []
  type: TYPE_NORMAL
- en: To find every power set of a set, we could reuse our existing `getCombos()`
    function, calling it repeatedly with each possible *k* argument. This approach
    is taken by the *powerSetCombinations.py* and *powerSetCombinations.html* programs
    in the downloadable resources file from [https://nostarch.com/recursive-book-recursion](https://nostarch.com/recursive-book-recursion).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can use a more efficient way to generate power sets. Let’s consider
    the power set of {A, B}, which is {{A, B}, {A}, {B}, { }}. Now say we add one
    more element, C, to the set and want to generate the power set of {A, B, C}. We
    have the four sets in the power set of {A, B} we already generated; in addition,
    we have these same four sets but with the element C added to them: {{A, B, C},
    {A, C}, {B, C}, {C}}. [Table 6-3](#table6-3) shows the pattern of how adding more
    elements to a set adds more sets to its power set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-3: How Power Sets Grow as New Elements (in Bold) Are Added to the Set'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Set with new element** | **New sets to the power set** | **Complete power
    set** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| { } | { } | {{ }} |'
  prefs: []
  type: TYPE_TB
- en: '| {A} | {A} | {{ }, **{A}**} |'
  prefs: []
  type: TYPE_TB
- en: '| {A, B} | {B}, {A, B} | {{ }, {A}, **{B}**, **{A, B}**} |'
  prefs: []
  type: TYPE_TB
- en: '| {A, B, C} | {C}, {A, C}, {B, C}, {A, B, C} | {{ }, {A}, {B}, **{C}**, {A,
    B}, **{A, C}**, **{B, C}**, **{A, B, C}**} |'
  prefs: []
  type: TYPE_TB
- en: '| {A, B, C, D} | {D}, {A, D}, {B, D}, {C, D}, {A, B, D}, {A, C, D}, {B, C,
    D}, {A, B, C, D} | {{ }, {A}, {B}, {C}, **{D}**, {A, B}, {A, C}, **{A, D}**, {B,
    C}, **{B, D}**, **{C, D}**, {A, B, C}, {A, B, D}, {A, C, D}, **{B, C, D}**, **{A,
    B, C, D}**} |'
  prefs: []
  type: TYPE_TB
- en: The power sets of larger sets are similar to the power sets of smaller sets,
    hinting that we can create a recursive function to generate them. The base case
    is an empty set, and its power set is a set of just the empty set. We can use
    a head-tail technique for this recursive function. For each new element we add,
    we want to get the power set of the tail to add to our full power set. We also
    add the head element to each set in the tail power set. Together, these form the
    full power set for the `chars` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask the three recursive algorithm questions about our power set algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? If `chars` is the blank string (the empty set), the function
    returns an array with just a blank string, since the empty set is the only subset
    of the empty set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The tail of `chars`
    is passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? Since the recursive calls
    remove the heads from the `chars` arguments, eventually the `chars` argument becomes
    the blank string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `getPowerSet()` recursive function is implemented in *powerSet.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent JavaScript code is in *powerSet.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The programs output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getPowerSet()` function accepts a single argument: the string `chars`,
    which contains the characters of the original set. The base case occurs when `chars`
    is the blank string ❶, representing an empty set. Recall that the power set is
    the set of all subsets of the original set. Thus, the power set of the empty set
    is simply a set containing the empty set, since the empty set is the only subset
    of the empty set. This is why the base case returns `['''']`.'
  prefs: []
  type: TYPE_NORMAL
- en: The recursive case is split into two parts. The first part is acquiring the
    power set of the tail of `chars`. We’ll use the leap-of-faith principle and just
    assume the call to `getPowerSet()` returns the power set of the tail correctly
    ❷, even though at this point we’d still be in the process of writing the code
    for `getPowerSet()`.
  prefs: []
  type: TYPE_NORMAL
- en: To form the complete power set of `chars`, the second part of the recursive
    case forms new sets by adding the head to each of the tail power sets ❸. Together
    with the sets from the first part, this forms the power set of `chars` to return
    at the end of the function ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Permutations and combinations are two problem domains that many programmers
    don’t know how to even begin to approach. While recursion is often an overly complicated
    solution for common programming problems, it’s well suited for the complexity
    of the tasks in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter began with a brief introduction to set theory. This lays the basis
    for the data structures that our recursive algorithms operate on. A set is a collection
    of distinct elements. A subset consists of none, some, or all the elements of
    a set. While sets have no ordering for their elements, a permutation is a specific
    ordering of the elements in a set. And a combination, which has no ordering, is
    a specific selection of none, some, or all the elements in a set. A *k*-combination
    of a set is a subset of *k* elements selected from the set.
  prefs: []
  type: TYPE_NORMAL
- en: Permutations and combinations can include an element once or can repeat elements.
    We call these permutations or combinations without repetition and with repetition,
    respectively. These are implemented by different algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also tackled the balanced parentheses problem that is commonly
    used in coding interviews. Our algorithm builds the strings of balanced parentheses
    by starting with a blank string and adding opening and closing parentheses. This
    approach involves backtracking to earlier strings, making recursion an ideal technique.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this chapter featured a recursive function for generating power sets—that
    is, sets of all possible *k*-combinations of the elements of a set. The recursive
    function we create to do this is much more efficient than repeatedly calling our
    combinations function for each possible size of subset.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generating permutations and combinations only scratches the surface of what
    you can do with permutations and combinations, as well as the field of mathematical
    logic known as *set theory*. The following Wikipedia articles provide plenty of
    further details on these topics, as do the Wikipedia articles that each links
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Set_theory](https://en.wikipedia.org/wiki/Set_theory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Combination](https://en.wikipedia.org/wiki/Combination)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Permutation](https://en.wikipedia.org/wiki/Permutation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python standard library comes with implementations of permutation, combination,
    and other algorithms in its `itertools` module. This module is documented at [https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html).
  prefs: []
  type: TYPE_NORMAL
- en: Permutations and combinations are also covered in statistics and probability
    math courses. Khan Academy’s unit on counting, permutations, and combinations
    can be found online at [https://www.khanacademy.org/math/statistics-probability/counting-permutations-and-combinations](https://www.khanacademy.org/math/statistics-probability/counting-permutations-and-combinations).
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Do sets have a specific order for their elements? Do permutations? Do combinations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many permutations (without repetition) are there of a set of *n* elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many combinations (without repetition) are there of a set of *n* elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is {A, B, C} a subset of {A, B, C}?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the formula for calculating *n choose k*, the number of possible combinations
    of *k* elements selected from a set of *n* elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Identify which of the following are permutations or combinations, with or without
    repetition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AAA, AAB, AAC, ABA, ABB, ABC, ACA, ACB, ACC, BAA, BAB, BAC, BBA, BBB, BBC, BCA,
    BCB, BCC, CAA, CAB, CAC, CBA, CBB, CBC, CCA, CCB, CCC
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ABC, ACB, BAC, BCA, CAB
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (None), A, B, C, AB, AC, BC, ABC
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (None), A, B, C, AA, AB, AC, BB, BC, CC, AAA, AAB, AAC, ABB, ABC, ACC, BBB,
    BBC, BCC, CCC
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a tree graph that can be used to generate all possible combinations of
    the set {A, B, C, D}.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer the three questions about recursive solutions for each of the recursive
    algorithms presented in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then re-create the recursive algorithms from this chapter without looking at
    the original code.
  prefs: []
  type: TYPE_NORMAL
- en: Practice Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For practice, write a function for the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: The permutation function in this chapter operates on characters in a string
    value. Modify it so that the sets are represented by lists (in Python) or arrays
    (in JavaScript) and the elements can be values of any data type. For example,
    your new function should be able to generate permutations of integer values, rather
    than strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The combination function in this chapter operates on characters in a string
    value. Modify it so that the sets are represented by lists (in Python) or arrays
    (in JavaScript) and the elements can be values of any data type. For example,
    your new function should be able to generate combinations of integer values, rather
    than strings.`*  *`# 7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Memoization and Dynamic Programming
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll explore memoization, a technique for making recursive
    algorithms run faster. We’ll discuss what memoization is, how it should be applied,
    and its usefulness in the areas of functional programming and dynamic programming.
    We’ll use the Fibonacci algorithm from Chapter 2 to demonstrate memoizing code
    we write and the memoization features we can find in the Python standard library.
    We’ll also learn why memoization can’t be applied to every recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Memoization* is the technique of remembering the return values from a function
    for the specific arguments supplied to it. For example, if someone asked me to
    find the square root of 720, which is the number that when multiplied by itself
    results in 720, I’d have to sit down with pencil and paper for a few minutes (or
    call `Math.sqrt(720)` in JavaScript or `math.sqrt(720)` in Python) to figure it
    out: 26.832815729997478\. If they asked me again a few seconds later, I wouldn’t
    have to repeat my calculation because I’d already have the answer at hand. By
    caching previously calculated results, memoization makes a trade-off to save on
    execution time by increasing memory usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Confusing *memoization* with *memorization* is a modern mistake made by many.
    (Feel free to make a memo to remind yourself of the difference.)
  prefs: []
  type: TYPE_NORMAL
- en: Top-Down Dynamic Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Memoization is a common strategy in *dynamic programming*, a computer programming
    technique that involves breaking a large problem into overlapping subproblems.
    This might sound a lot like the ordinary recursion we’ve already seen. The key
    difference is that dynamic programming uses recursion with repeated recursive
    cases; these are the *overlapping* subproblems.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s consider the recursive Fibonacci algorithm from Chapter 2.
    Making a recursive `fibonacci(6)` function call will in turn call `fibonacci(5)`
    and `fibonacci(4)`. Next, `fibonacci(5)` will call `fibonacci(4)` and `fibonacci(3)`.
    The subproblems of the Fibonacci algorithm overlap, because the `fibonacci(4)`
    call, and many others, are repeated. This makes generating Fibonacci numbers a
    dynamic programming problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'An inefficiency exists here: performing those same calculations multiple times
    is unnecessary, because `fibonacci(4)` will always return the same thing, the
    integer `3`. Instead, our program could just remember that if the argument to
    our recursive function is `4`, the function should immediately return `3`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-1](#figure7-1) shows a tree diagram of all the recursive calls, including
    the redundant function calls that memoization can optimize. Meanwhile, quicksort
    and merge sort are recursive divide-and-conquer algorithms, but their subproblems
    do not overlap; they are unique. Dynamic programming techniques aren’t applied
    to these sorting algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagram beginning with the Fibonacci function called with an argument
    of 6\. Two subsequent branches show the next calls to the Fibonacci function,
    with arguments of 5 and 4, respectively. The tree continues to branch until each
    branch ends with a value of 1\. Several branches are grayed out, indicating that
    the Fibonacci function was called with the same argument as a previous branch.](image_fi/502024c07/f07001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: A tree diagram of the recursive function calls made starting with
    `fibonacci(6)`. The redundant function calls are in gray.'
  prefs: []
  type: TYPE_NORMAL
- en: One approach in dynamic programming is to memoize the recursive function so
    that previous calculations are remembered for future function calls. Overlapping
    subproblems become trivial if we can reuse previous return values.
  prefs: []
  type: TYPE_NORMAL
- en: Using recursion with memoization is called *top-down dynamic programming*. This
    process takes a large problem and divides it into smaller overlapping subproblems.
    A contrasting technique, *bottom-up dynamic programming*, starts with the smaller
    subproblems (often related to the base case) and “builds up” to the solution of
    the original, large problem. The iterative Fibonacci algorithm, which begins with
    the base cases of the first and second Fibonacci numbers, is an example of bottom-up
    dynamic programming. Bottom-up approaches don’t use recursive functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is no such thing as top-down recursion or bottom-up recursion.
    These are commonly used but incorrect terms. All recursion is already top-down,
    so *top-down recursion* is redundant. And no bottom-up approach uses recursion,
    so there’s no such thing as *bottom-up recursion*.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization in Functional Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all functions can be memoized. To see why, we must discuss *functional programming*,
    a programming paradigm that emphasizes writing functions that don’t modify global
    variables or any *external state* (such as files on the hard drive, internet connections,
    or database contents). Some programming languages, such as Erlang, Lisp, and Haskell,
    are heavily designed around functional programming concepts. But you can apply
    functional programming features to almost any programming language, including
    Python and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming includes the concepts of deterministic and nondeterministic
    functions, side effects, and pure functions. The `sqrt()` function mentioned in
    the introduction is a *deterministic* function because it always returns the same
    value when passed the same argument. However, Python’s `random.randint()` function,
    which returns a random integer, is *nondeterministic* because even when passed
    the same arguments, it can return different values. The `time.time()` function,
    which returns the current time, is also nondeterministic because time is constantly
    moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: '*Side effects* are any changes a function makes to anything outside of its
    own code and local variables. To illustrate this, let’s create a `subtract()`
    function that implements Python’s subtraction operator (`-`):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: This `subtract()` function has no side effects; calling this function doesn’t
    affect anything in the program outside of its code. There’s no way to tell from
    the program’s or the computer’s state whether the `subtract()` function has been
    called once, twice, or a million times before. A function might modify local variables
    inside the function, but these changes are local to the function and remain isolated
    from the rest of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider an `addToTotal()` function, which adds the numeric argument to
    a global variable named `TOTAL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addToTotal()` function does have a side effect, because it modifies an
    element that exists outside of the function: the `TOTAL` global variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Side effects can be more than mere changes to global variables. They include
    updating or deleting files, printing text onscreen, opening a database connection,
    authenticating to a server, or any other manipulation of data outside of the function.
    Any trace that a function call leaves behind after returning is a side effect.
  prefs: []
  type: TYPE_NORMAL
- en: If a function is deterministic and has no side effects, it’s known as a *pure
    function*. Only pure functions should be memoized. You’ll see why in the next
    sections when we memoize the recursive Fibonacci function and the impure functions
    of the `doNotMemoize` program.
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing the Recursive Fibonacci Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s memoize our recursive Fibonacci function from Chapter 2. Remember that
    this function is extraordinarily inefficient: on my computer, the recursive `fibonacci(40)`
    call takes 57.8 seconds to compute. Meanwhile, an iterative version of `fibonacci(40)`
    is literally too fast for my code profiler to measure: 0.000 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: Memoization can greatly speed up the recursive version of the function. For
    example, [Figure 7-2](#figure7-2) shows the number of function calls the original
    and memoized `fibonacci()` functions make for the first 20 Fibonacci numbers.
    The original, non-memoized function is doing an extraordinary amount of unnecessary
    computation.
  prefs: []
  type: TYPE_NORMAL
- en: The number of function calls sharply increases for the original `fibonacci()`
    function (top) but only slowly grows for the memoized `fibonacci()` function (bottom).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07002a](image_fi/502024c07/f07002a.png)![Two graphs showing how the number
    of function calls increases as the number of Fibonacci numbers to calculate increases.
    The first graph increases rapidly to 14,000 function calls for the 20th Fibonacci
    number to calculate, while the second graph is linear, showing 20 function calls
    for the 20th Fibonacci number to calculate.](image_fi/502024c07/f07002b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: The number of function calls sharply increases for the original
    `fibonacci()` function (top) but grows only slowly for the memoized `fibonacci()`
    function (bottom).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python version of the memoized Fibonacci algorithm is in *fibonacciByRecursionMemoized.py*.
    The additions to the original *fibonacciByRecursion.html* program from Chapter
    2 have been marked in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript version of the memoized Fibonacci algorithm is in *fibonacciByRecursionMemoized.html*.
    The additions to the original *fibonacciByRecursion.html* program from Chapter
    2 have been marked in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compare the output of this program to the original recursive Fibonacci
    program in Chapter 2, you’ll find it’s much shorter. This reflects the massive
    reduction of computation needed to achieve the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: To memoize this function, we’ll create a dictionary (in Python) or object (in
    JavaScript) in a global variable named `fibonacciCache` ❶. Its keys are the arguments
    passed for the `nthNumber` parameter, and its values are the integers returned
    by the `fibonacci()` function given that argument. Every function call first checks
    if its `nthNumber` argument is already in the cache. If so, the cached return
    value is returned ❷. Otherwise, the function runs as normal (though it also adds
    the result to the cache just before the function returns ❸ ❹).
  prefs: []
  type: TYPE_NORMAL
- en: 'The memoized function is effectively expanding the number of base cases in
    the Fibonacci algorithm. The original base cases are only for the first and second
    Fibonacci numbers: they immediately return `1`. But every time a recursive case
    returns an integer, it becomes a base case for all future `fibonacci()` calls
    with that argument. The result is already in `fibonacciCache` and can be immediately
    returned. If you’ve already called `fibonacci(99)` once before, it becomes a base
    case just like `fibonacci(1)` and `fibonacci(2)`. In other words, memoization
    improves the performance of recursive functions with overlapping subproblems by
    increasing the number of base cases. Notice that the second time our program tries
    to find the 10th Fibonacci number ❺, it immediately returns the memoized result:
    `55`.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that while memoization can reduce the number of redundant function
    calls a recursive algorithm makes, it doesn’t necessarily reduce the growth of
    frame objects on the call stack. Memoization won’t prevent stack overflow errors.
    Once again, you may be better off forgoing a recursive algorithm for a more straightforward
    iterative one.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s functools Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing a cache by adding a global variable and code to manage it for every
    function you’d like to memoize can be quite a chore. Python’s standard library
    has a `functools` module with a function decorator named `@lru_cache()` that automatically
    memoizes the function it decorates. In Python syntax, this means adding `@lru_cache()`
    to the line preceding the function’s `def` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The cache can have a memory size limit set. The *lru* in the decorator name
    stands for the *least recently used* cache replacement policy, meaning that the
    least recently used entry is replaced with new entries when the cache limit is
    reached. The LRU algorithm is simple and fast, though other cache replacement
    policies are available for different software requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *fibonacciFunctools.py* program demonstrates the use of the `@lru_cache()`
    decorator. The additions to the original *fibonacciByRecursion.py* program from
    Chapter 2 have been marked in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Compared to the additions required to implement our own cache in *fibonacciByRecursionMemoized.py*,
    using Python’s `@lru_cache()` decorator is much simpler. Normally, calculating
    `fibonacci(99)` with the recursive algorithm would take a few centuries. With
    memoization, our program displays the `218922995834555169026` result in a few
    milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization is a useful technique for recursive functions with overlapping subproblems,
    but it can be applied to any pure function to speed up runtime at the expense
    of computer memory.
  prefs: []
  type: TYPE_NORMAL
- en: What Happens When You Memoize Impure Functions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should not add the `@lru_cache` to functions that are not pure, meaning
    they are nondeterministic or have side effects. Memoization saves time by skipping
    the code in the function and returning the previously cached return value. This
    is fine for pure functions but can cause various bugs for impure functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In nondeterministic functions, such as a function that returns the current
    time, memoization causes the function to return incorrect results. For functions
    with side effects, such as printing text to the screen, memoization causes the
    function to skip the intended side effect. The *doNotMemoize.py* program demonstrates
    what happens when the `@lru_cache` function decorator (described in the previous
    section) memoizes these impure functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this program, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the second call to `getCurrentTime()` returns the same result as
    the first call despite being called two seconds later. And of the two calls to
    `printMessage()`, only the first call results in displaying the `Hello, world!`
    message on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: These bugs are subtle because they don’t cause an obvious crash, but rather
    cause the functions to behave incorrectly. No matter how you memoize your functions,
    be sure to thoroughly test them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memoization (not memorization) is an optimization technique that can speed up
    recursive algorithms that have overlapping subproblems by remembering the previous
    results of identical calculations. Memoization is a common technique in the field
    of dynamic programming. By trading computer memory usage for improved runtime,
    memoization makes some otherwise intractable recursive functions possible.
  prefs: []
  type: TYPE_NORMAL
- en: However, memoization won’t prevent stack overflow errors. Keep in mind that
    memoization is not a replacement for using a simple iterative solution. Code that
    uses recursion for the sake of recursion is not automatically more elegant than
    non-recursive code.
  prefs: []
  type: TYPE_NORMAL
- en: Memoized functions must be pure—that is, they must be deterministic (returning
    the same values given the same arguments each time) and not have side effects
    (affecting anything about the computer or program outside of the function). Pure
    functions are often used in functional programming, which is a programming paradigm
    that makes heavy use of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization is implemented by creating a data structure called a *cache* for
    each function to memoize. You can write this code yourself, but Python has a built-in
    `@functools.lru_cache()` decorator that can automatically memoize the function
    it decorates.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s more to dynamic programming algorithms than simply memoizing functions.
    These algorithms are often used in both coding interviews and programming competitions.
    Coursera offers a free “Dynamic Programming, Greedy Algorithms” course at [https://www.coursera.org/learn/dynamic-programming-greedy-algorithms](https://www.coursera.org/learn/dynamic-programming-greedy-algorithms).
    The freeCodeCamp organization also has a series on dynamic programming at [https://www.freecodecamp.org/news/learn-dynamic-programing-to-solve-coding-challenges](https://www.freecodecamp.org/news/learn-dynamic-programing-to-solve-coding-challenges).
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to learn more about the LRU cache and other cache-related functions,
    the official Python documentation for the `functools` module is at [https://docs.python.org/3/library/functools.html](https://docs.python.org/3/library/functools.html).
    More information about other kinds of cache replacement algorithms is mentioned
    on Wikipedia at [https://en.wikipedia.org/wiki/Cache_replacement_policies](https://en.wikipedia.org/wiki/Cache_replacement_policies).
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is memoization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do dynamic programming problems differ from regular recursion problems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does functional programming emphasize?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What two characteristics must a function have in order to be a pure function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is a function that returns the current date and time a deterministic function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does memoization improve the performance of recursive functions with overlapping
    subproblems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Would adding the `@lru_cache()` function decorator to a merge sort function
    improve its performance? Why or why not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is changing the value in a function’s local variable an example of a side effect?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does memoization prevent stack overflows?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tail Call Optimization
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, we covered using memoization to optimize recursive
    functions. This chapter explores a technique called *tail call optimization*,
    which is a feature provided by a compiler or interpreter to avoid stack overflows.
    Tail call optimization is also called *tail call elimination*, or *tail recursion
    elimination*.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is meant to explain tail call optimization, not to endorse it.
    I would go so far as to recommend *never* using tail call optimization. As you’ll
    see, rearranging your function’s code to use tail call optimization often makes
    it far less understandable. You should consider tail call optimization to be more
    of a hack or workaround to make recursion work when you shouldn’t be using a recursive
    algorithm in the first place. Remember, a complex recursive solution is not automatically
    an elegant solution; simple coding problems should be solved with simple non-recursive
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Many implementations of popular programming languages don’t even offer tail
    call optimization as a feature. These include interpreters and compilers for Python,
    JavaScript, and Java. However, tail call optimization is a technique you should
    become familiar with in case you come across it in the code projects you work
    on.
  prefs: []
  type: TYPE_NORMAL
- en: How Tail Recursion and Tail Call Optimization Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make use of tail call optimization, a function must use *tail recursion**.*
    In tail recursion, the recursive function call is the last action of a recursive
    function. In code, this looks like a `return` statement returning the results
    of a recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: To see this in action, recall the *factorialByRecursion.py* and *factorialByRecursion.html*
    programs in Chapter 2. These programs calculated the factorial of an integer;
    for instance, 5! is equivalent to 5 × 4 × 3 × 2 × 1, or 120\. These calculations
    can be performed recursively because `factorial(n)` is equivalent to `n * factorial(n
    - 1)`, with the base case of `n == 1` returning `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite these programs to use tail recursion. The following *factorialTailCall.py*
    program has a `factorial()` function that uses tail recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The *factorialTailCall.html* program has the equivalent JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `factorial()` function’s recursive case ends with a `return`
    statement returning the results of a recursive call to `factorial()`. To allow
    the interpreter or compiler to implement tail call optimization, the last action
    a recursive function makes must be to return the results of the recursive call.
    No instructions can occur between making the recursive call and the `return` statement.
    The base case returns the `accum` parameter. This is the accumulator, explained
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how tail call optimization works, remember from Chapter 1 what
    happens when a function is called. First, a frame object is created and stored
    on the call stack. If the function call calls another function, another frame
    object is created and placed on top of the first frame object on the call stack.
    When a function returns, your program automatically deletes the frame object from
    the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: A stack overflow happens when too many function calls are made without returning,
    causing the number of frame objects to exceed the capacity of the call stack.
    This capacity is 1,000 function calls for Python and about 10,000 for JavaScript
    programs. While these amounts are more than enough for typical programs, recursive
    algorithms could exceed this limit and cause a stack overflow that crashes your
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from Chapter 2 that a frame object stores the local variables in the
    function call as well as the return address of the instruction to return to when
    the function finishes. However, if the last action in the recursive case of a
    function is to return the results of a recursive function call, there’s no need
    to retain the local variables. The function does nothing involving the local variables
    after the recursive call, so the current frame object can be deleted immediately.
    The next frame object’s return address information can be the same as the old
    deleted frame object’s return address.
  prefs: []
  type: TYPE_NORMAL
- en: Since the current frame object is deleted instead of retained on the call stack,
    the call stack never grows in size and can never cause a stack overflow!
  prefs: []
  type: TYPE_NORMAL
- en: Recall from Chapter 1 that all recursive algorithms can be implemented with
    a stack and a loop. Since tail call optimization removes the need for a call stack,
    we are effectively using recursion to simulate a loop’s iterative code. However,
    earlier in this book I stated that the problems suitable for recursive solutions
    involve a tree-like data structure and backtracking. Without a call stack, no
    tail recursive function could possibly do any backtracking work. In my view, every
    algorithm that can be implemented with tail recursion would be easier and more
    readable to implement with a loop instead. There’s nothing automatically more
    elegant about using recursion for recursion’s sake.
  prefs: []
  type: TYPE_NORMAL
- en: Accumulators in Tail Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The disadvantage of tail recursion is that it requires rearranging your recursive
    function so that the last action is returning the recursive call’s return value.
    This can make our recursive code even more unreadable. Indeed, the `factorial()`
    function in this chapter’s *factorialTailCall.py* and *factorialTailCall.html*
    programs is a bit harder to comprehend than the version in Chapter 2’s *factorialByRecursion.py*
    and *factorialByRecursion.html* programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of our tail call `factorial()` function, a new parameter named `accum`
    follows the calculated product as recursive function calls are made. This is known
    as an *accumulator* parameter, and it keeps track of a partial result of a calculation
    that would otherwise have been stored in a local variable. Not all tail recursive
    functions use accumulators, but they act as a workaround for tail recursion’s
    inability to use local variables after the final recursive call. Notice that in
    *factorialByRecursion.py*’s `factorial()` function, the recursive case was `return
    number * factorial(number - 1)`. The multiplication happens after the `factorial(number
    - 1)` recursive call. The `accum` accumulator takes the place of the `number`
    local variable.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that the base case for `factorial()` no longer returns `1`; rather,
    it returns the `accum` accumulator. By the time `factorial()` is called with `number
    == 1` and the base case is reached, `accum` stores the final result to return.
    Adjusting your code to use tail call optimization often involves changing the
    base case to return the accumulator’s value.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the `factorial(5)` function call as transforming into the following
    `return`, as shown in [Figure 8-1](#figure8-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing the return statements produced by the factorial function
    called with an argument of 5, in order: “return factorial(5 - 1, 1* 5),” “return
    factorial(4 -1, 5 * 4),” “return factorial(3 - 1, 20 * 3),” “return factorial(2
    - 1, 60 * 2),” “return 120.”](image_fi/502024c08/f08001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: The process of transformations that `factorial(5)` makes to the
    integer 120'
  prefs: []
  type: TYPE_NORMAL
- en: Rearranging your recursive calls as the last action in the function and adding
    accumulators can make your code even harder to understand than typical recursive
    code. But that’s not the only downside of tail recursion, as we’ll see in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Tail Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tail recursive functions require rearranging their code to make them suitable
    for the tail call optimization feature of the compiler or interpreter. However,
    not all compilers and interpreters offer tail call optimization as a feature.
    Notably, CPython (the Python interpreter downloaded from [https://python.org](https://python.org))
    does not implement tail call optimization. Even if you write your recursive functions
    with the recursive call as the last action, it will still cause stack overflows
    after enough function calls are made.
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, but CPython will likely never have tail call optimization as
    a feature. Guido van Rossum, the creator of the Python programming language, has
    explained that tail call optimization can make programs harder to debug. Tail
    call optimization removes frame objects from the call stack, which in turn removes
    the debugging information that frame objects can provide. He also points out that
    once tail call optimization is implemented, Python programmers will begin to write
    code that depends on the feature, and their code won’t run on non-CPython interpreters
    that don’t implement tail call optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, and I concur, van Rossum disagrees with the idea that recursion is
    a fundamentally important part of day-to-day programming. Computer scientists
    and mathematicians tend to place recursion on a pedestal. But tail call optimization
    is simply a workaround hack to make some recursive algorithms actually workable,
    rather than simply crashing with a stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: While CPython doesn’t feature tail call optimization, this doesn’t mean another
    compiler or interpreter that implements the Python language couldn’t have tail
    call optimization. Unless tail call optimization is explicitly a part of a programming
    language specification, it is not a feature of a programming language, but rather
    of individual compilers or interpreters of a programming language.
  prefs: []
  type: TYPE_NORMAL
- en: The lack of tail call optimization is not unique to Python. The Java compiler
    since version 8 also doesn’t support tail call optimization. Tail call optimization
    is a part of the ECMAScript 6 version of JavaScript; however, as of 2022, only
    the Safari web browser’s implementation of JavaScript actually supports it. One
    way to determine whether your programming language’s compiler or interpreter implements
    this feature is to write a tail recursive factorial function and try to calculate
    the factorial of 100,000\. If the program crashes, tail call optimization is not
    implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I take the stance that the tail recursion technique should never
    be used. As stated in Chapter 2, any recursive algorithm can be implemented with
    a loop and a stack. Tail call optimization prevents stack overflows by effectively
    removing the use of the call stack. Therefore, all tail recursive algorithms can
    be implemented with a loop alone. Since the code for loops is much simpler than
    a recursive function, a loop should be used wherever tail call optimization could
    be employed.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, potential problems exist even if tail call optimization is implemented.
    Since tail recursion is possible only when the last action of a function is returning
    the recursive call’s return value, it’s impossible to do tail recursion for algorithms
    that require two or more recursive calls. For example, take the Fibonacci sequence
    algorithm calls `fibonacci(n - 1)` and `fibonacci(n - 2)`. While tail call optimization
    can be performed for the latter recursive call, the first recursive call will
    cause a stack overflow for large-enough arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Tail Recursion Case Studies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s examine some of the recursive functions demonstrated earlier in this book
    to see if they are good candidates for tail recursion. Keep in mind that because
    Python and JavaScript do not actually implement tail call optimization, these
    tail recursive functions will still result in a stack overflow error. These case
    studies are for demonstration purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: Tail Recursive Reverse String
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first example is the program to reverse a string that we made in Chapter
    3. The Python code for this tail recursive function is in *reverseStringTailCall.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript equivalent is in *reverseStringTailCall.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The conversion of the original recursive functions in *reverseString.py* and
    *reverseString.html* involves adding an accumulator parameter. The accumulator,
    named `accum`, is set to the blank string by default if no argument is passed
    for it ❶. We also change the base case from `return ''` to `return accum` ❷, and
    the recursive case from `return rev(tail) + head` (which performs a string concatenation
    after the recursive call returns) to `return rev(tail, head + accum)` ❸. You can
    think of the `rev('abcdef')` function call as transforming into the following
    `return`, as shown in [Figure 8-2](#figure8-2).
  prefs: []
  type: TYPE_NORMAL
- en: By effectively using the accumulator as a local variable shared across function
    calls, we can make the `rev()` function tail recursive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing the return statements produced by the rev() function called
    with an argument of abcdef, in order: “return rev(‘bcdef’, ‘a’, + ‘’),” “return
    rev(‘cdef’, ‘b’ + ‘a’),” “return rev(‘def’, ‘c’ + ‘ba’),” “return rev(‘ef’, ‘d’
    + ‘cba’),” “return rev(‘f’, ‘e’ + ‘dcba’),” “return rev(‘’, ‘f’, ‘edcba’),” “return
    ‘fedcba’.”](image_fi/502024c08/f08002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: The process of transformations that `rev(''abcdef'')` makes to
    the string `fedcba`'
  prefs: []
  type: TYPE_NORMAL
- en: Tail Recursive Find Substring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some recursive functions naturally end up using the tail recursion pattern.
    If you look at the `findSubstringRecursive()` function in the *findSubstring.py*
    and *findSubstring.html* programs in Chapter 2, you’ll notice that the last action
    for the recursive case is to return the value of the recursive function call.
    No adjustments are needed to make this function tail recursive.
  prefs: []
  type: TYPE_NORMAL
- en: Tail Recursive Exponents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *exponentByRecursion.py* and *exponentByRecursion.html* programs, also
    from Chapter 2, are not good candidates for tail recursion. These programs have
    two recursive cases for when the `n` parameter is even or odd. This is fine: as
    long as all the recursive cases return the return value of the recursive function
    call as their last action, the function can use tail call optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, notice the Python code for the `n is even` recursive case:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'And notice the equivalent JavaScript recursive case:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'This recursive case does not have the recursive call as its last action. We
    could get rid of the `result` local variable, and instead call the recursive function
    twice. This would reduce the recursive case to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'However, now we have two recursive calls to `exponentByRecursion()`. Not only
    does this needlessly double the amount of computation the algorithm performs,
    but the last action performed by the function is to multiply the two return values.
    This is the same problem the recursive Fibonacci algorithm has: if the recursive
    function has multiple recursive calls, at least one of those recursive calls can’t
    be the last action of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: Tail Recursive Odd-Even
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To determine whether an integer is odd or even, you can use the `%` modulus
    operator. The expression `number % 2 == 0` will be `True` if `number` is even,
    and `False` if `number` is odd. However, if you’d prefer to overengineer a more
    “elegant” recursive algorithm, you can implement the following `isOdd()` function
    in *isOdd.py* (the rest of *isOdd.py* is presented later in this section):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript equivalent is in *isOdd.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: We have two base cases for `isOdd()`. When the `number` argument is `0`, the
    function returns `False` to indicate *even*. For simplicity, our implementation
    of `isOdd()` works for only positive integers. The recursive case returns the
    opposite of `isOdd(number - 1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see why this works with an example: when `isOdd(42)` is called, the
    function can’t determine if `42` is even or odd but does know that the answer
    is the opposite of whether `41` is odd or even. The function will return `not
    isOdd(41)`. This function call, in turn, returns the opposite Boolean value of
    `isOdd(40)`, and so on, until `isOdd(0)` returns `False`. The number of recursive
    function calls determines the number of `not` operators that act on return values
    before the final return value is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this recursive function results in stack overflows for large-number
    arguments. Calling `isOdd(100000)` results in 100,001 function calls without returning—which
    far exceeds the capacity of any call stack. We can rearrange the code in the function
    so that the last action of the recursive case is returning the results of the
    recursive function call, making the function tail recursive. We do this in `isOddTailCall()`
    in *isOdd.py*. Here is the rest of the *isOdd.py* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript equivalent is in the rest of *isOdd.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: If this Python and JavaScript code is run by an interpreter that supports tail
    call optimization, calling `isOddTailCall(100000)` won’t result in a stack overflow.
    However, tail call optimization is still much slower than simply using the `%`
    modulus operator to determine oddness or evenness.
  prefs: []
  type: TYPE_NORMAL
- en: If you think recursion, with or without tail recursion, is an incredibly inefficient
    way to determine whether a positive integer is odd, you are absolutely correct.
    Unlike iterative solutions, recursion can fail from stack overflows. Adding tail
    call optimization to prevent stack overflows doesn’t fix the efficiency flaws
    of using recursion inappropriately. As a technique, recursion is not automatically
    better or more sophisticated than iterative solutions. And tail recursion is never
    a better approach than a loop or other simple solution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tail call optimization is a feature of a programming language’s compiler or
    interpreter that can be employed on recursive functions specifically written to
    be tail recursive. Tail recursive functions return the return value of the recursive
    function call as the last action in the recursive case. This allows the function
    to delete the current frame object and prevent the call stack from growing as
    new recursive function calls are made. If the call stack doesn’t grow, the recursive
    function can’t possibly cause a stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursion is a workaround that allows some recursive algorithms to work
    with large arguments without crashing. However, this approach requires rearranging
    your code and possibly adding an accumulator parameter. This could make your code
    harder to understand. You may likely find that sacrificing code readability is
    not worth using a recursive algorithm over an iterative one.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stack Overflow (the website, not the programming error) has a detailed discussion
    about the basics of tail recursion at [https://stackoverflow.com/questions/33923/what-is-tail-recursion](https://stackoverflow.com/questions/33923/what-is-tail-recursion).
  prefs: []
  type: TYPE_NORMAL
- en: Van Rossum wrote about his decision not to use tail recursion in two blog posts
    at [https://neopythonic.blogspot.com.au/2009/04/tail-recursion-elimination.html](https://neopythonic.blogspot.com.au/2009/04/tail-recursion-elimination.html)
    and [https://neopythonic.blogspot.com.au/2009/04/final-words-on-tail-calls.html](https://neopythonic.blogspot.com.au/2009/04/final-words-on-tail-calls.html).
  prefs: []
  type: TYPE_NORMAL
- en: Python’s standard library includes a module called `inspect` that allows you
    to view the frame objects on the call stack as a Python program is running. The
    official documentation for the `inspect` module is at [https://docs.python.org/3/library/inspect.html](https://docs.python.org/3/library/inspect.html),
    and a tutorial on Doug Hellmann’s Python 3 Module of the Week blog is at [https://pymotw.com/3/inspect](https://pymotw.com/3/inspect).
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What does tail call optimization prevent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the last action of a recursive function have to do so that the function
    can be tail recursive?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do all compilers and interpreters implement tail call optimization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an accumulator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the disadvantage of tail recursion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can the quicksort algorithm (covered in Chapter 5) be rewritten to use tail
    call optimization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drawing Fractals
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Certainly, the most fun application of recursion is drawing fractals. *Fractals*
    are shapes that repeat themselves, sometimes chaotically, at different scales.
    The term was coined by the founder of fractal geometry, Benoit B. Mandelbrot,
    in 1975 and is derived from the Latin *frāctus*, meaning broken or fractured,
    like shattered glass. Fractals include many natural and artificial shapes. In
    nature, you might see them in the shapes of trees, fern leaves, mountain ranges,
    lightning bolts, coastlines, river networks, and snowflakes. Mathematicians, programmers,
    and artists can create elaborate geometric shapes based on a few recursive rules.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion can produce elaborate fractal art using surprisingly few lines of
    code. This chapter covers Python’s built-in `turtle` module for generating several
    common fractals with code. To create turtle graphics with JavaScript, you can
    use Greg Reimer’s `jtg` library. For simplicity, this chapter presents only the
    Python fractal drawing programs and not the JavaScript equivalents. However, the
    `jtg` JavaScript library is covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Turtle Graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Turtle graphics* were a feature of the Logo programming language designed
    to help kids learn coding concepts. The feature has since been reproduced in many
    languages and platforms. Its central idea is an object called a *turtle*.'
  prefs: []
  type: TYPE_NORMAL
- en: The turtle acts as a programmable pen that draws lines in a 2D window. Imagine
    an actual turtle holding a pen on the ground, drawing a line behind it as it moves
    around. The turtle can adjust the size and color of its pen, or “raise the pen”
    so that it does not draw as it moves. Turtle programs can produce intricate geometric
    drawings such as [Figure 9-1](#figure9-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you put these instructions inside loops and functions, even small programs
    can create impressive geometric drawings. Consider the following *spiral.py* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: When you run this program, the turtle window opens. The turtle (represented
    by a triangle) will trace the spiral pattern in [Figure 9-1](#figure9-1). While
    not a fractal, it is a beautiful drawing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a small triangle icon tracing overlapping lines across the
    window. The lines create a spiral pattern.](image_fi/502024c09/f09001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: The spiral drawn by the program using Python’s `turtle` module'
  prefs: []
  type: TYPE_NORMAL
- en: The window in a turtle graphics system uses Cartesian x- and y-coordinates.
    The number for the horizontal x-coordinate increases going right and decreases
    going left, while the number for the vertical y-coordinate increases going up
    and decreases going down. These two coordinates together can provide a unique
    address for any point in the window. By default, the *origin* (the x, y coordinate
    point at 0, 0) is in the center of the window.
  prefs: []
  type: TYPE_NORMAL
- en: The turtle also has a *heading*, or direction, that is a number from 0 to 359
    (a circle is split into 360 degrees). In Python’s `turtle` module, a heading of
    0 faces east (toward the right edge of the screen) and increases clockwise; a
    heading of 90 faces north, a heading of 180 faces west, and a heading of 270 faces
    south. In the JavaScript `jtg` library, this orientation is rotated so that 0
    degrees faces north and increases counterclockwise. [Figure 9-2](#figure9-2) demonstrates
    the headings for the Python `turtle` module and the JavaScript `jtg` library.
  prefs: []
  type: TYPE_NORMAL
- en: '![Two compass diagrams indicating the headings for the turtle module and jtg
    library. The turtle module headings, clockwise from top: 90, 45, 0, 315, 270,
    225, 180, 135\. The jtg library headings, clockwise from top: 0, 45, 90, 135,
    180, 225, 270, 315.](image_fi/502024c09/F09002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: The headings in Python’s `turtle` module (left) and the JavaScript
    `jtg` library (right)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the JavaScript `jtg` library at [https://inventwithpython.com/jtg](https://inventwithpython.com/jtg),
    enter the following code into the text field at the bottom of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: This draws the same spiral shown in [Figure 9-1](#figure9-1) on the main area
    of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Turtle Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most commonly used functions in turtle graphics cause the turtle to change
    heading and move forward or backward. The `turtle.left()` and `turtle.right()`
    functions rotate the turtle a certain number of degrees starting from its current
    heading, while the `turtle.forward()` and `turtle.backward()` functions move the
    turtle based on its current position.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-1](#table9-1) lists some of the turtle’s functions. The first function
    (beginning with `turtle.`) is for Python, and the second (beginning with `t.`)
    is for JavaScript. The full Python documentation is available at [https://docs.python.org/3/library/turtle.html](https://docs.python.org/3/library/turtle.html).
    In the JavaScript `jtg` software, you can press F1 to display the help screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9-1: Turtle Functions in Python’s `turtle` Module and JavaScript’s `jtg`
    Library'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `goto(``x``,` `y``)` | `xy(``x``,` `y``)` | Moves the turtle to the x, y
    coordinates. |'
  prefs: []
  type: TYPE_TB
- en: '| `setheading(``deg``)` | `heading(``deg``)` | Sets the turtle’s heading. In
    Python, 0 degrees is east (right). In JavaScript, 0 degrees is north (up). |'
  prefs: []
  type: TYPE_TB
- en: '| `forward(``steps``)` | `fd(``steps``)` | Moves the turtle a number of steps
    forward in the heading it is facing. |'
  prefs: []
  type: TYPE_TB
- en: '| `backward(``steps``)` | `bk(``steps``)` | Moves the turtle a number of steps
    in the heading opposite from the one it is facing. |'
  prefs: []
  type: TYPE_TB
- en: '| `left(``deg``)` | `lt(``deg``)` | Turns the turtle’s heading to the left.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `right(``deg``)` | `rt(``deg``)` | Turns the turtle’s heading to the right.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `penup()` | `pu()` | “Raises the pen” so that the turtle stops drawing as
    it moves. |'
  prefs: []
  type: TYPE_TB
- en: '| `pendown()` | `pd()` | “Lowers the pen” so that the turtle starts drawing
    as it moves. |'
  prefs: []
  type: TYPE_TB
- en: '| `pensize(``size``)` | `thickness(``size``)` | Changes the thickness of the
    lines the turtle draws. The default is `1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `pencolor(``color``)` | `color(``color``)` | Changes the color of the lines
    the turtle draws. This can be a string of a common color such as `red` or `white`.
    The default is `black`. |'
  prefs: []
  type: TYPE_TB
- en: '| `xcor()` | `get.x()` | Returns the turtle’s current x position. |'
  prefs: []
  type: TYPE_TB
- en: '| `ycor()` | `get.y()` | Returns the turtle’s current y position. |'
  prefs: []
  type: TYPE_TB
- en: '| `heading()` | `get.heading()` | Returns the turtle’s current heading as a
    floating-point number from 0 to 359\. In Python, 0 degrees is east (right). In
    JavaScript, 0 degrees is north (up). |'
  prefs: []
  type: TYPE_TB
- en: '| `reset()` | `reset()` | Clears any drawn lines, and moves the turtle back
    to the original position and heading. |'
  prefs: []
  type: TYPE_TB
- en: '| `clear()` | `clean()` | Clears any drawn lines but doesn’t move the turtle.
    |'
  prefs: []
  type: TYPE_TB
- en: The functions listed in [Table 9-2](#table9-2) are available only in the Python
    `turtle` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9-2: Python-Only Turtle Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `begin_fill()` | Begins drawing a filled-in shape. The lines drawn after
    this call will specify the perimeter of the filled-in shape. |'
  prefs: []
  type: TYPE_TB
- en: '| `end_fill()` | Draws the filled-in shape that was started with the call to
    `turtle.begin_fill()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `fillcolor(``color``)` | Sets the color used for filled-in shapes. |'
  prefs: []
  type: TYPE_TB
- en: '| `hideturtle()` | Hides the triangle that represents the turtle. |'
  prefs: []
  type: TYPE_TB
- en: '| `showturtle()` | Shows the triangle that represents the turtle. |'
  prefs: []
  type: TYPE_TB
- en: '| `tracer(``drawingUpdates``,` `delay``)` | Adjusts the speed of drawing. Pass
    `0` for `delay` for a delay of 0 milliseconds after each line the turtle draws.
    The larger the number passed for `drawingUpdates`, the faster the turtle draws
    by increasing the number of drawings before the module updates the screen. |'
  prefs: []
  type: TYPE_TB
- en: '| `update()` | Draws any buffered lines (explained later in this section) to
    the screen. Call this after the turtle has completed drawing. |'
  prefs: []
  type: TYPE_TB
- en: '| `setworldcoordinates(``llx``,` `lly``,` `urx,``ury``)` | Readjusts which
    part of the coordinate plane the window shows. The first two arguments are the
    x, y coordinates for the lower-left corner of the window. The latter two arguments
    are the x, y coordinates for the upper-right corner of the window. |'
  prefs: []
  type: TYPE_TB
- en: '| `exitonclick()` | Pauses the program and closes the window when the user
    clicks anywhere. Without this at the end of your program, the turtle graphics
    window may close as soon as the program ends. |'
  prefs: []
  type: TYPE_TB
- en: In Python’s `turtle` module, lines are displayed on the screen immediately.
    However, this can slow programs that draw thousands of lines. It’s faster to *buffer*—that
    is, hold off displaying several lines and then display them all at once.
  prefs: []
  type: TYPE_NORMAL
- en: By calling `turtle.tracer(1000, 0)`, you can instruct the `turtle` module to
    hold off displaying lines until 1,000 lines have been created by your program.
    After your program has finished calling line-drawing functions, make a final call
    to `turtle.update()` to display any remaining buffered lines to the screen. If
    your program is still taking too long to draw an image, pass a larger integer
    such as `2000` or `10000` as the first argument to `turtle.tracer()`.
  prefs: []
  type: TYPE_NORMAL
- en: The Sierpiński Triangle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest fractal to draw on paper is the *Sierpiński triangle*, introduced
    in Chapter 1. This fractal was described by Polish mathematician Wacław Sierpiński
    in 1915 (predating even the term *fractal*). However, the pattern is at least
    hundreds of years older.
  prefs: []
  type: TYPE_NORMAL
- en: To create a Sierpiński triangle, start by drawing an equilateral triangle—a
    triangle with equal-length sides, like the one on the left in [Figure 9-3](#figure9-3).
    Then draw an upside-down equilateral triangle inside the first triangle, as on
    the right in [Figure 9-3](#figure9-3). You’ll form a shape that, if you’re familiar
    with the *Legend of Zelda* video games, looks like the Triforce.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphic depicting four equilateral triangles. The second triangle has a smaller
    triangle in the center that breaks the shape into four smaller triangles. In the
    third triangle, each of the three outer triangles is broken into smaller triangles.
    the fourth triangle shows those smaller triangles further broken into even smaller
    triangles.](image_fi/502024c09/f09003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: An equilateral triangle (left) with an upside-down triangle added
    to form a Sierpiński triangle, with additional triangles recursively added'
  prefs: []
  type: TYPE_NORMAL
- en: An interesting thing happens when you draw the inner, upside-down triangle.
    You form three new, right-side-up equilateral triangles. Inside each of these
    three triangles, you can draw another upside-down triangle, which will create
    nine triangles. This recursion can continue forever mathematically, though in
    reality your pen won’t be able to keep drawing tinier triangles.
  prefs: []
  type: TYPE_NORMAL
- en: 'This property, describing a full object that is similar to a part of itself,
    is called *self-similarity*. Recursive functions can produce these objects, since
    they “call” themselves again and again. Practically, this code must hit a base
    case eventually, but mathematically, these shapes have infinite resolution: you
    could theoretically zoom in on the shape forever.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write a recursive program to create the Sierpiński triangle. The recursive
    `drawTriangle()` function will draw an equilateral triangle, and then recursively
    call this function three times to draw the inner equilateral triangles, as in
    [Figure 9-4](#figure9-4). The `midpoint()` function finds the point equidistant
    from two points passed to the function. This will be important as the inner triangles
    use these equidistant points for their vertices.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of an equilateral triangle drawn three times using dotted lines.
    Solid lines isolate a different, smaller equilateral triangle in each of the larger
    triangles. These smaller triangles each share a different vertex with the larger
    triangle and have a side length of one-half the larger triangle’s.](image_fi/502024c09/f09004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-4: The three inner triangles, with midpoints shown with large dots'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this program calls `turtle.setworldcoordinates(0, 0, 700, 700)`,
    which makes the 0, 0 origin at the lower-left corner of the window. The upper-right
    corner has the x, y coordinates 700, 700\. The source code for *sierpinskiTriangle.py*
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: When you run this code, the output looks like [Figure 9-5](#figure9-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a Sierpiński triangle drawn in the turtle module.](image_fi/502024c09/f09005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-5: A standard Sierpiński triangle'
  prefs: []
  type: TYPE_NORMAL
- en: Sierpiński triangles don’t have to be drawn with equilateral triangles. As long
    as you use the midpoints of the outer triangle to draw the inner triangles, you
    can use any kind of triangle. Comment out the first `drawTriangle()` call and
    uncomment the second one (under the `# Draw a skewed Sierpinski triangle.` comment)
    and run the program again. The output will look like [Figure 9-6](#figure9-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a Sierpiński triangle drawn using irregular triangles with
    the turtle module. The image looks like an equilateral Sierpiński viewed at an
    angle.](image_fi/502024c09/f09006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-6: A skewed Sierpiński triangle'
  prefs: []
  type: TYPE_NORMAL
- en: The `drawTriangle()` function takes six arguments corresponding to the x, y
    coordinates of the triangle’s three points. Try experimenting with different values
    to adjust the shape of the Sierpiński triangle. You can also change the `MIN_SIZE`
    constant to a larger value to make the program reach the base case sooner and
    reduce the number of triangles drawn.
  prefs: []
  type: TYPE_NORMAL
- en: The Sierpiński Carpet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A fractal shape similar to the Sierpiński triangle can be drawn using rectangles
    instead. This pattern is known as the *Sierpiński carpet*. Imagine splitting a
    black rectangle into a 3 × 3 grid, then “cutting out” the center rectangle. Repeat
    this pattern in the surrounding eight rectangles of the grid. When this is done
    recursively, you end up with a pattern like [Figure 9-7](#figure9-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a black rectangle containing a pattern of white rectangles
    of various sizes. Drawn with the turtle module.](image_fi/502024c09/f09007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-7: The Sierpiński carpet'
  prefs: []
  type: TYPE_NORMAL
- en: The Python program that draws the carpet uses the `turtle.begin_fill()` and
    `turtle.end_fill()` functions to create solid, filled-in shapes. The lines that
    the turtle draws between these calls are used to draw the shape, as in [Figure
    9-8](#figure9-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Three diagrams representing the steps the turtle takes to draw a filled-in
    rectangle. The first shape shows the turtle traveling in a path that draws three
    sides of a rectangle. The second diagram shows the turtle completing the rectangle.
    The third diagram shows the rectangle filled in.](image_fi/502024c09/f09008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-8: Calling `turtle.begin_fill()`, drawing a path, and calling `turtle.end_fill()`
    creates a filled-in shape.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The base case is reached when the rectangles of the 3 × 3 become smaller than
    six steps on a side. You can change the `MIN_SIZE` constant to a larger value
    to make the program reach the base case sooner. The source code for *sierpinskiCarpet.py*
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: You can also set the `DRAW_SOLID` constant to `False` and run the program. This
    will skip the calls to `turtle.begin_fill()` and `turtle.end_fill()` so that only
    the outlines of the rectangles are drawn, as in [Figure 9-9](#figure9-9).
  prefs: []
  type: TYPE_NORMAL
- en: Try passing different arguments to `drawCarpet()`. The first two arguments are
    the x, y coordinates of the lower-left corner of the carpet, while the latter
    two arguments are the width and height. You can also change the `MIN_SIZE` constant
    to a larger value to make the program reach the base case sooner and reduce the
    number of rectangles drawn.
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics screenshot showing a version of the Sierpiński carpet in
    which none of the rectangles are filled in.](image_fi/502024c09/f09009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-9: The Sierpiński carpet, with only the outlines of the rectangles
    drawn'
  prefs: []
  type: TYPE_NORMAL
- en: Another 3D Sierpiński carpet uses cubes instead of squares. In this form, it
    is called a *Sierpiński cube*, or *Menger sponge*. It was first described by mathematician
    Karl Menger in 1926\. [Figure 9-10](#figure9-10) shows a Menger sponge created
    in the video game *Minecraft*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image of a cube viewed at an angle. The visible sides of the cube have squares
    cut out of them in the pattern of a Sierpiński carpet.](image_fi/502024c09/f09010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-10: A 3D Menger sponge fractal'
  prefs: []
  type: TYPE_NORMAL
- en: Fractal Trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the artificial fractals such as the Sierpiński triangle and carpet are
    perfectly self-similar, fractals can include shapes that do not have perfect self-similarity.
    Fractal geometry, as envisioned by mathematician Benoit B. Mandelbrot (whose middle
    initial recursively stands for Benoit B. Mandelbrot) included natural shapes such
    as mountains, coastlines, plants, blood vessels, and the clustering of galaxies
    as fractals. Upon close examination, these shapes continued to consist of “rougher”
    shapes not easily contained by the smooth curves and straight lines of simplified
    geometry.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we can use recursion to reproduce *fractal trees*, whether perfectly
    or imperfectly self-similar. Generating trees requires creating a branch with
    two child branches that issue from their parent at set angles and decrease at
    set lengths. The Y shape that they produce is recursively repeated to create a
    convincing drawing of a tree, as in Figures 9-11 and 9-12.
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics screenshot showing a drawing that resembles a leafless tree.
    The branches of the tree lean toward the left and become progressively smaller,
    creating a rounded, asymmetrical shape.](image_fi/502024c09/f09011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-11: A perfectly self-similar fractal tree generated with the left
    and right branches using consistent angles and lengths'
  prefs: []
  type: TYPE_NORMAL
- en: Movies and video games can use such recursive algorithms in *procedural generation*,
    the automatic (rather than manual) creation of 3D models such as trees, ferns,
    flowers, and other plants. Using algorithms, computers can quickly create entire
    forests consisting of millions of unique trees, saving an army of human 3D artists
    the painstaking effort.
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics screenshot showing a drawing that resembles a leafless tree.
    The tree’s branches vary in length and direction of branching, sometimes overlapping.](image_fi/502024c09/f09012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-12: A more realistic tree created using random changes to branch angle
    and lengths'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our fractal tree program displays a new, randomly generated tree every two
    seconds. The source code for *fractalTree.py* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: This program produces perfectly self-similar trees, as the `LEFT_ANGLE`, `LEFT_DECREASE`,
    `RIGHT_ANGLE`, and `RIGHT_DECREASE` variables are initially randomly chosen but
    stay constant for all the recursive calls. The `random.seed()` function sets a
    seed value for Python’s random functions. The *random number seed value* causes
    the program to produce random-seeming numbers, but it uses the same sequence of
    random numbers for each branch of the tree. In other words, the same *seed* value
    reproduces the same *tree* each time you run the program. (I never apologize for
    my puns.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, enter the following into the Python interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we set the random seed to 42\. When we generate 20 random integers,
    we get `1`, `0`, `4`, `3`, and so on. We can generate another 20 integers and
    continue to receive random integers. However, if we reset the seed to `42` and
    generate 20 random integers again, they’ll be the same “random” integers as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like to create a more natural, less self-similar tree, replace the
    lines after the `# Record the position of the branch''s end.` comment with the
    following lines. This generates new random angles and branch lengths for *every*
    recursive call, which is closer to the way trees grow in nature:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: You can experiment with different ranges for the `random.randint()` call, or
    try adding more recursive calls instead of just the two for the two branches.
  prefs: []
  type: TYPE_NORMAL
- en: How Long Is the Coast of Great Britain? The Koch Curve and Snowflake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before I tell you about the Koch curve and snowflake, consider this question:
    how long is the coast of Great Britain? Look at [Figure 9-13](#figure9-13). The
    map on the left has a rough measure, which puts the coast at about 2,000 miles.
    But the map on the right has a more precise measure, which includes more nooks
    and crannies of the coast and comes to about 2,800 miles.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two screenshots of maps of Great Britain. In the first, the outline of the
    coast is approximated using straight-line segments to connect various points along
    the country’s outline. In the second, more points are added, increasing the number
    of line segments used.](image_fi/502024c09/f09013b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-13: The island of Great Britain, with a rough measure (left) and more
    precise measure (right). Measuring the coast more precisely adds 800 miles to
    its length.'
  prefs: []
  type: TYPE_NORMAL
- en: Mandelbrot’s key insight about fractals such as the coastline of Britain is
    that you can continue to look closer and closer, and there will continue to be
    “roughness” at every scale. So, as your measurement gets finer and finer, the
    length of the coastline will get longer and longer. The “coast” will follow the
    Thames upriver, deep into the landmass along one bank and back out to the English
    Channel on the other bank. Thus, the answer to our question of Great Britain’s
    coastline’s length is, “It depends.”
  prefs: []
  type: TYPE_NORMAL
- en: The *Koch curve* fractal has a similar property pertaining to the length of
    its coastline, or rather, perimeter. First introduced in 1902 by Swedish mathematician
    Helge von Koch, the Koch curve is one of the earliest fractals to be described
    mathematically. To construct it, take a line of length *b* and divide it into
    three equal parts, each of length *b* / 3\. Replace the middle section with a
    “bump” whose sides are also of length *b* / 3\. This bump causes the Koch curve
    to be longer than the original line, since we now have four line segments of length
    *b* / 3\. (We’ll exclude the original middle part of the line segment.) This bump
    creation can be repeated on the new four line segments. [Figure 9-14](#figure9-14)
    shows this construction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Three diagrams. The first is a line divided into three segments, each of
    length b/3\. The second diagram shows the middle segment replaced with two segments
    of length b/3 that angle upward, forming two sides of an equilateral triangle
    whose third side is the missing middle segment. The third diagram shows each of
    the segments of the second diagram altered according to the same pattern, creating
    an irregular, bumpy shape.](image_fi/502024c09/f09014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-14: After splitting the line segment into three equal parts (left),
    add a bump to the middle part (right). We now have four segments of length *b*
    / 3, to which bumps can be added again (bottom).'
  prefs: []
  type: TYPE_NORMAL
- en: To create the *Koch snowflake*, we start with an equilateral triangle and construct
    three Koch curves from its three sides, as in [Figure 9-15](#figure9-15).
  prefs: []
  type: TYPE_NORMAL
- en: '![Two diagrams: an equilateral triangle, and the same equilateral triangle
    whose sides have been replaced with Koch curves, forming a snowflake shape.](image_fi/502024c09/f09015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-15: Creating three Koch curves on the three sides of an equilateral
    triangle to form a Koch snowflake'
  prefs: []
  type: TYPE_NORMAL
- en: Each time you create a new bump, you are increasing the curve’s length from
    three *b* / 3 lengths to four *b* / 3 lengths, or 4*b* / 3\. If you continue to
    do this with the three sides of an equilateral triangle, you’ll create the Koch
    snowflake, as in [Figure 9-16](#figure9-16). (The small dotted patterns are artifacts,
    because slight rounding errors cause the `turtle` module to be unable to completely
    erase the middle *b* / 3 segment.) You can continue to create new bumps forever,
    though our program stops when they get smaller than a few pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphic screenshot of a snowflake created using many Koch bumps.](image_fi/502024c09/f09016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-16: A Koch snowflake. Some of the interior lines remain because of
    small rounding errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for *kochSnowflake.py* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: The Koch snowflake is also sometimes called the *Koch island*. Its coastline
    would be literally infinitely long. While the Koch snowflake fits into the finite
    area of a page of this book, the length of its perimeter is infinite, proving
    that, while it seems counterintuitive, the finite can contain the infinite!
  prefs: []
  type: TYPE_NORMAL
- en: The Hilbert Curve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *space-filling curve* is a 1D line that curves around until it completely
    fills a 2D space without crossing over itself. German mathematician David Hilbert
    described his space-filling *Hilbert curve* in 1891\. If you split a 2D area into
    a grid, the single, 1D line of the Hilbert curve can run through every cell in
    the grid.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-17](#figure9-17) contains the first three recursions of the Hilbert
    curve. The next recursion contains four copies of the previous recursion, and
    the dashed line shows how the four copies connect to one another.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Three diagrams. The first is a grid with four square cells. Three lines are
    drawn to connect the center points of the cells, forming three sides of a square
    in the center of the grid. The second diagram shows each cell of the original
    grid subdivided into four cells and the same lines drawn across each of those
    cells. The fourth shows the cells further subdivided and populated by the same
    line pattern.](image_fi/502024c09/f09017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-17: The first three recursions of the Hilbert space-filling curve'
  prefs: []
  type: TYPE_NORMAL
- en: As the cells become infinitesimal points, the 1D curve can fill the entire 2D
    space the same way a 2D square does. Counterintuitively, this creates a 2D shape
    from a strictly 1D line!
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for *hilbertCurve.py* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Try experimenting with this code by decreasing `LINE_LENGTH` to shorten the
    line segments while increasing `LEVELS` to add more levels of recursion. Because
    this program uses only relative movements for the turtle, you can uncomment the
    `turtle.setheading(20)` line to draw the Hilbert curve at a 20-degree angle. [Figure
    9-18](#figure9-18) shows the drawing produced with `LINE_LENGTH` of `10` and `LEVELS`
    of `5`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics screenshot. The entire window is covered in a Hilbert curve.](image_fi/502024c09/f09018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-18: Five levels of the Hilbert curve, with line length `10`'
  prefs: []
  type: TYPE_NORMAL
- en: The Hilbert curve makes 90-degree (right-angle) turns. But try adjusting the
    `ANGLE` variable by a few degrees to `89` or `86`, and run the program to view
    the changes. You can also set the `DRAW_SOLID` variable to `True` to produce a
    filled-in Hilbert curve, as in [Figure 9-19](#figure9-19).
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics screenshot of the same Hilbert curve drawing, this time with
    the black and white portions reversed.](image_fi/502024c09/f09019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-19: Six levels of the Hilbert curve, filled in, with line length `5`'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The incredibly wide field of fractals combines all the most interesting parts
    of programming and art, making this chapter the most fun to write. Mathematicians
    and computer scientists talk about the beauty and elegance that the advanced topics
    of their fields produce, but recursive fractals are able to turn this conceptual
    beauty into visual beauty that anyone can appreciate.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covered several fractals and the programs that draw them: the
    Sierpiński triangle, the Sierpiński carpet, procedurally generated fractal trees,
    the Koch curve and snowflake, and the Hilbert curve. All of these were drawn with
    Python’s `turtle` module and functions that recursively call themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about drawing with Python’s `turtle` module, I’ve written a simple
    tutorial at [https://github.com/asweigart/simple-turtle-tutorial-for-python](https://github.com/asweigart/simple-turtle-tutorial-for-python).
    I also have a personal collection of turtle programs at [https://github.com/asweigart/art-of-turtle-programming](https://github.com/asweigart/art-of-turtle-programming).
  prefs: []
  type: TYPE_NORMAL
- en: The question of Great Britain’s coastline’s length came from the title of a
    1967 paper by Mandelbrot. The idea is summarized nicely on Wikipedia at [https://en.wikipedia.org/wiki/Coastline_paradox](https://en.wikipedia.org/wiki/Coastline_paradox).
    Khan Academy has more on the geometry of the Koch snowflake at [https://www.khanacademy.org/math/geometry-home/geometry-volume-surface-area/koch-snowflake/v/koch-snowflake-fractal](https://www.khanacademy.org/math/geometry-home/geometry-volume-surface-area/koch-snowflake/v/koch-snowflake-fractal).
  prefs: []
  type: TYPE_NORMAL
- en: 'The 3Blue1Brown YouTube channel has excellent animations of fractals, particularly
    the “Fractals Are Typically Not Self-Similar” video at [https://youtu.be/gB9n2gHsHN4](https://youtu.be/gB9n2gHsHN4)
    and the “Fractal Charm: Space-Filling Curves” video at [https://youtu.be/RU0wScIj36o](https://youtu.be/RU0wScIj36o).'
  prefs: []
  type: TYPE_NORMAL
- en: Other space-filling curves require recursion to draw, such as the Peano curve,
    Gosper curve, and dragon curve, and they’re worth researching on the web.
  prefs: []
  type: TYPE_NORMAL
- en: Practice Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your comprehension by answering the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are fractals?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do the x- and y-coordinates represent in a Cartesian coordinate system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the origin coordinates in a Cartesian coordinate system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is procedural generation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a seed value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How long is the perimeter of a Koch snowflake?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a space-filling curve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practice Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For practice, write a program for each of the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a turtle program that draws a box fractal as shown in [Figure 9-20](#figure9-20).
    This program is similar to the Sierpiński carpet program introduced in this chapter.
    Use the `turtle.begin_fill()` and `turtle.end_fill()` functions to draw the first
    large, black square. Then split this square into nine equal sections, and draw
    white squares in the top, left, right, and bottom squares. Repeat this process
    for the four corner squares and the center square.![Turtle graphics screenshot.
    Shows 25 black squares arranged so that they form five larger squares: one square
    in each corner and one square in the center. These five larger squares are arranged
    to form one even larger square.](image_fi/502024c09/f09020.png)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9-20: A box fractal, drawn to two levels'
  prefs: []
  type: TYPE_NORMAL
- en: Create a turtle program that draws a Peano space-filling curve. This is similar
    to the Hilbert curve program in this chapter. [Figure 9-21](#figure9-21) shows
    the first three iterations of the Peano curve. While each Hilbert curve iteration
    is split across a 2 × 2 section (which is, in turn, split into 2 × 2 sections),
    the Peano curve is split across 3 × 3 sections.![A straight line bent at right
    angles into a curve-like shape that travels through the center points of the square
    cells in a 3 × 3 grid. The other diagrams show similar curves traveling through
    the center points of increasingly larger grids.](image_fi/502024c09/f09021.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9-21: The first three iterations of the Peano curve, from left to right.
    The bottom row includes the 3 × 3 sections that each part of the curve is split
    across.`*``'
  prefs: []
  type: TYPE_NORMAL

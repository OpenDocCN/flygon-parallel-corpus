["```py\nimport os\n\ndef hasEvenByteSize(fullFilePath):\n    \"\"\"Returns True if fullFilePath has an even size in bytes,\n    otherwise returns False.\"\"\"\n    fileSize = os.path.getsize(fullFilePath)\n    return fileSize % 2 == 0\n\ndef hasEveryVowel(fullFilePath):\n    \"\"\"Returns True if the fullFilePath has a, e, i, o, and u,\n    otherwise returns False.\"\"\"\n    name = os.path.basename(fullFilePath).lower()\n    return ('a' in name) and ('e' in name) and ('i' in name) and ('o' in name) and ('u' in name)\n\ndef walk(folder, matchFunc):\n    \"\"\"Calls the match function with every file in the folder and its\n    subfolders. Returns a list of files that the match function\n    returned True for.\"\"\"\n    matchedFiles = [] # This list holds all the matches.\n    folder = os.path.abspath(folder) # Use the folder's absolute path.\n\n    # Loop over every file and subfolder in the folder:\n    for name in os.listdir(folder):\n        filepath = os.path.join(folder, name)\n        if os.path.isfile(filepath):\n            # Call the match function for each file:\n            if matchFunc(filepath):\n                matchedFiles.append(filepath)\n        elif os.path.isdir(filepath):\n            # Recursively call walk for each subfolder, extending\n            # the matchedFiles with their matches:\n            matchedFiles.extend(walk(filepath, matchFunc))\n    return matchedFiles\n\nprint('All files with even byte sizes:')\nprint(walk('.', hasEvenByteSize))\nprint('All files with every vowel in their name:')\nprint(walk('.', hasEveryVowel))\n```", "```py\n>>> **def callTwice(func):**\n...     **func()**\n...     **func()**\n...\n>>> **def sayHello():**\n...     **print('Hello!')**\n...\n>>> **def sayGoodbye():**\n...     **print('Goodbye!')**\n...\n>>> **callTwice(sayHello)**\nHello!\nHello!\n>>> **callTwice(sayGoodbye)**\nGoodbye!\nGoodbye!\n```", "```py\nimport os\n\ndef hasEvenByteSize(fullFilePath):\n    \"\"\"Returns True if fullFilePath has an even size in bytes,\n    otherwise returns False.\"\"\"\n    fileSize = os.path.getsize(fullFilePath)\n    return fileSize % 2 == 0\n```", "```py\n>>> **import os**\n>>> **os.path.getsize('C:/Windows/system32/notepad.exe')**\n211968\n>>> **211968 % 2 == 0**\nTrue\n```", "```py\ndef hasEveryVowel(fullFilePath):\n    \"\"\"Returns True if the fullFilePath has a, e, i, o, and u,\n    otherwise returns False.\"\"\"\n    name = os.path.basename(fullFilePath).lower()\n    return ('a' in name) and ('e' in name) and ('i' in name) and ('o' in name) and ('u' in name)\n```", "```py\ndef walk(folder, matchFunc):\n    \"\"\"Calls the match function with every file in the folder and its\n    subfolders. Returns a list of files that the match function\n    returned True for.\"\"\"\n    matchedFiles = [] # This list holds all the matches.\n    folder = os.path.abspath(folder) # Use the folder's absolute path.\n```", "```py\n # Loop over every file and subfolder in the folder:\n    for name in os.listdir(folder):\n        filepath = os.path.join(folder, name)\n        if os.path.isfile(filepath):\n```", "```py\n # Call the match function for each file:\n            if matchFunc(filepath):\n                matchedFiles.append(filepath)\n```", "```py\n elif os.path.isdir(filepath):\n            # Recursively call walk for each subfolder, extending\n            # the matchedFiles with their matches:\n            matchedFiles.extend(walk(filepath, matchFunc))\n```", "```py\n return matchedFiles\n```", "```py\nprint('All files with even byte sizes:')\nprint(walk('.', hasEvenByteSize))\nprint('All files with every vowel in their name:')\nprint(walk('.', hasEveryVowel))\n```", "```py\nAll files with even byte sizes:\n['C:\\\\Path\\\\accesschk.exe', 'C:\\\\Path\\\\accesschk64.exe', \n'C:\\\\Path\\\\AccessEnum.exe', 'C:\\\\Path\\\\ADExplorer.exe', \n'C:\\\\Path\\\\Bginfo.exe', 'C:\\\\Path\\\\Bginfo64.exe', \n'C:\\\\Path\\\\diskext.exe', 'C:\\\\Path\\\\diskext64.exe', \n'C:\\\\Path\\\\Diskmon.exe', 'C:\\\\Path\\\\DiskView.exe', \n'C:\\\\Path\\\\hex2dec64.exe', 'C:\\\\Path\\\\jpegtran.exe', \n'C:\\\\Path\\\\Tcpview.exe', 'C:\\\\Path\\\\Testlimit.exe', \n'C:\\\\Path\\\\wget.exe', 'C:\\\\Path\\\\whois.exe']\nAll files with every vowel in their name:\n['C:\\\\Path\\\\recursionbook.bat']\n```", "```py\n>>> **import os**\n>>> **filename = 'C:/Windows/system32/notepad.exe'**\n>>> **os.path.basename(filename)**\n'notepad.exe'\n>>> **os.path.dirname(filename)**\n'C:/Windows/system32'\n>>> **os.path.split(filename)**\n('C:/Windows/system32', 'notepad.exe')\n>>> **folder, file = os.path.split(filename)**\n>>> **folder**\n'C:/Windows/system32'\n>>> **file**\n'notepad.exe'\n```", "```py\n> **import os**\n> **filename = 'C:/Windows/system32/notepad.exe'**\n> **os.path.getctime(filename)**\n1625705942.1165037\n> **os.path.getmtime(filename)**\n1625705942.1205275\n> **os.path.getatime(filename)**\n1631217101.8869188\n```", "```py\n>>> **import os**\n>>> **filename = 'C:/Windows/system32/notepad.exe'**\n>>> **ctimestamp = os.path.getctime(filename)**\n>>> **import time**\n>>> **time.localtime(ctimestamp)**\ntime.struct_time(tm_year=2021, tm_mon=7, tm_mday=7, tm_hour=19, \ntm_min=59, tm_sec=2, tm_wday=2, tm_yday=188, tm_isdst=1)\n>>> **st = time.localtime(ctimestamp)**\n>>> **st.tm_year**\n2021\n>>> **st.tm_mon**\n7\n>>> **st.tm_mday**\n7\n>>> **st.tm_wday**\n2\n>>> **st.tm_hour**\n19\n>>> **st.tm_min**\n59\n>>> **st.tm_sec**\n2\n```", "```py\n>>> **import os**\n>>> **filename = 'C:/Windows/system32/notepad.exe'**\n>>> **ctimestamp = os.path.getctime(filename)**\n>>> **import time**\n>>> **st = time.localtime(ctimestamp)**\n>>> **time.asctime(st)**\n'Wed Jul  7 19:59:02 2021'\n```", "```py\n>>> **import os**\n>>> **filename = 'C:/Windows/system32/notepad.exe'**\n>>> **ctimestamp = os.path.getctime(filename)**\n>>> **import time**\n>>> **ctimestamp = os.path.getctime(filename)**\n>>> **time.localtime(ctimestamp)**\ntime.struct_time(tm_year=2021, tm_mon=7, tm_mday=7, tm_hour=19, \ntm_min=59, tm_sec=2, tm_wday=2, tm_yday=188, tm_isdst=1)\n>>> **time.gmtime(ctimestamp)**\ntime.struct_time(tm_year=2021, tm_mon=7, tm_mday=8, tm_hour=0, \ntm_min=59, tm_sec=2, tm_wday=3, tm_yday=189, tm_isdst=0)\n```", "```py\n>>> **import shutil**\n>>> **shutil.move('spam.txt', 'someFolder')**\n'someFolder\\\\spam.txt'\n```", "```py\n>>> **import shutil**\n>>> **shutil.move('spam.txt', 'someFolder\\\\newName.txt')**\n'someFolder\\\\newName.txt'\n```", "```py\n>>> **import shutil**\n>>> **shutil.move('spam.txt', 'newName.txt')**\n'newName.txt'\n```", "```py\n>>> **import shutil**\n>>> **shutil.copy('spam.txt', 'spam-copy.txt')**\n'spam-copy.txt'\n```", "```py\n>>> **import os**\n>>> **os.unlink('spam.txt')**\n>>>\n```", "```py\n>>> **open('deleteme.txt', 'w').close()** # Create a blank file.\n>>> **import send2trash**\n>>> **send2trash.send2trash('deleteme.txt')**\n```", "```py\nimport random\n\nWIDTH = 39 # Width of the maze (must be odd).\nHEIGHT = 19 # Height of the maze (must be odd).\nassert WIDTH % 2 == 1 and WIDTH >= 3\nassert HEIGHT % 2 == 1 and HEIGHT >= 3\nSEED = 1\nrandom.seed(SEED)\n\n# Use these characters for displaying the maze:\nEMPTY = ' '\nMARK = '@'\nWALL = chr(9608) # Character 9608 is '\u2588'\nNORTH, SOUTH, EAST, WEST = 'n', 's', 'e', 'w'\n\n# Create the filled-in maze data structure to start: \nmaze = {}\nfor x in range(WIDTH):\n    for y in range(HEIGHT):\n        maze[(x, y)] = WALL # Every space is a wall at first.\n\ndef printMaze(maze, markX=None, markY=None):\n    \"\"\"Displays the maze data structure in the maze argument. The\n    markX and markY arguments are coordinates of the current\n    '@' location of the algorithm as it generates the maze.\"\"\"\n\n    for y in range(HEIGHT):\n        for x in range(WIDTH):\n            if markX == x and markY == y:\n                # Display the '@' mark here:\n                print(MARK, end='')\n            else:\n                # Display the wall or empty space:\n                print(maze[(x, y)], end='')\n        print() # Print a newline after printing the row.\n\ndef visit(x, y):\n    \"\"\"\"Carve out\" empty spaces in the maze at x, y and then\n    recursively move to neighboring unvisited spaces. This\n    function backtracks when the mark has reached a dead end.\"\"\"\n maze[(x, y)] = EMPTY # \"Carve out\" the space at x, y.\n    printMaze(maze, x, y) # Display the maze as we generate it.\n    print('\\n\\n')\n\n    while True:\n        # Check which neighboring spaces adjacent to\n        # the mark have not been visited already:\n        unvisitedNeighbors = []\n        if y > 1 and (x, y - 2) not in hasVisited:\n            unvisitedNeighbors.append(NORTH)\n\n        if y < HEIGHT - 2 and (x, y + 2) not in hasVisited:\n            unvisitedNeighbors.append(SOUTH)\n\n        if x > 1 and (x - 2, y) not in hasVisited:\n            unvisitedNeighbors.append(WEST)\n\n        if x < WIDTH - 2 and (x + 2, y) not in hasVisited:\n            unvisitedNeighbors.append(EAST)\n\n        if len(unvisitedNeighbors) == 0:\n            # BASE CASE\n            # All neighboring spaces have been visited, so this is a\n            # dead end. Backtrack to an earlier space:\n            return\n        else:\n            # RECURSIVE CASE\n            # Randomly pick an unvisited neighbor to visit:\n            nextIntersection = random.choice(unvisitedNeighbors)\n\n            # Move the mark to an unvisited neighboring space:\n\n            if nextIntersection == NORTH:\n                nextX = x\n                nextY = y - 2\n                maze[(x, y - 1)] = EMPTY # Connecting hallway.\n            elif nextIntersection == SOUTH:\n                nextX = x\n                nextY = y + 2\n                maze[(x, y + 1)] = EMPTY # Connecting hallway.\n            elif nextIntersection == WEST:\n                nextX = x - 2\n                nextY = y\n                maze[(x - 1, y)] = EMPTY # Connecting hallway.\n            elif nextIntersection == EAST:\n                nextX = x + 2\n                nextY = y\n                maze[(x + 1, y)] = EMPTY # Connecting hallway.\n\n            hasVisited.append((nextX, nextY)) # Mark as visited.\n            visit(nextX, nextY) # Recursively visit this space.\n\n# Carve out the paths in the maze data structure:\nhasVisited = [(1, 1)] # Start by visiting the top-left corner.\nvisit(1, 1)\n\n# Display the final resulting maze data structure:\nprintMaze(maze)\n```", "```py\n<script type=\"text/javascript\">\n\nconst WIDTH = 39; // Width of the maze (must be odd).\nconst HEIGHT = 19; // Height of the maze (must be odd).\nconsole.assert(WIDTH % 2 == 1 && WIDTH >= 2);\nconsole.assert(HEIGHT % 2 == 1 && HEIGHT >= 2);\n\n// Use these characters for displaying the maze:\nconst EMPTY = \"&nbsp;\";\nconst MARK = \"@\";\nconst WALL = \"&#9608;\"; // Character 9608 is \u2032\u2588\u2032\nconst [NORTH, SOUTH, EAST, WEST] = [\"n\", \"s\", \"e\", \"w\"];\n\n// Create the filled-in maze data structure to start:\nlet maze = {};\nfor (let x = 0; x < WIDTH; x++) {\n    for (let y = 0; y < HEIGHT; y++) {\n        maze[[x, y]] = WALL; // Every space is a wall at first.\n    }\n}\n\nfunction printMaze(maze, markX, markY) {\n    // Displays the maze data structure in the maze argument. The\n    // markX and markY arguments are coordinates of the current\n    // '@' location of the algorithm as it generates the maze.\n    document.write('<code>');\n    for (let y = 0; y < HEIGHT; y++) {\n        for (let x = 0; x < WIDTH; x++) {\n            if (markX === x && markY === y) {\n                // Display the \u2032@\u2032 mark here:\n                document.write(MARK);\n            } else {\n                // Display the wall or empty space:\n                document.write(maze[[x, y]]);\n            }\n        }\n        document.write('<br />'); // Print a newline after printing the row.\n    }\n    document.write('</code>');\n}\n\nfunction visit(x, y) {\n    // \"Carve out\" empty spaces in the maze at x, y and then\n    // recursively move to neighboring unvisited spaces. This\n    // function backtracks when the mark has reached a dead end.\n\n maze[[x, y]] = EMPTY; // \"Carve out\" the space at x, y.\n    printMaze(maze, x, y); // Display the maze as we generate it.\n    document.write('<br /><br /><br />');\n\n    while (true) {\n        // Check which neighboring spaces adjacent to\n        // the mark have not been visited already:\n        let unvisitedNeighbors = [];\n        if (y > 1 && !JSON.stringify(hasVisited).includes(JSON.stringify([x, y - 2]))) {\n            unvisitedNeighbors.push(NORTH);\n        }\n        if (y < HEIGHT - 2 && \n        !JSON.stringify(hasVisited).includes(JSON.stringify([x, y + 2]))) {\n            unvisitedNeighbors.push(SOUTH);\n        }\n        if (x > 1 && \n        !JSON.stringify(hasVisited).includes(JSON.stringify([x - 2, y]))) {\n            unvisitedNeighbors.push(WEST);\n        }\n        if (x < WIDTH - 2 && \n        !JSON.stringify(hasVisited).includes(JSON.stringify([x + 2, y]))) {\n            unvisitedNeighbors.push(EAST);\n        }\n\n        if (unvisitedNeighbors.length === 0) {\n            // BASE CASE\n            // All neighboring spaces have been visited, so this is a\n            // dead end. Backtrack to an earlier space:\n            return;\n        } else {\n            // RECURSIVE CASE\n            // Randomly pick an unvisited neighbor to visit:\n            let nextIntersection = unvisitedNeighbors[\n            Math.floor(Math.random() * unvisitedNeighbors.length)];\n\n            // Move the mark to an unvisited neighboring space:\n            let nextX, nextY;\n            if (nextIntersection === NORTH) {\n                nextX = x;\n                nextY = y - 2;\n                maze[[x, y - 1]] = EMPTY; // Connecting hallway.\n            } else if (nextIntersection === SOUTH) {\n                nextX = x;\n                nextY = y + 2;\n                maze[[x, y + 1]] = EMPTY; // Connecting hallway.\n            } else if (nextIntersection === WEST) {\n                nextX = x - 2;\n                nextY = y;\n                maze[[x - 1, y]] = EMPTY; // Connecting hallway.\n            } else if (nextIntersection === EAST) {\n                nextX = x + 2;\n                nextY = y;\n                maze[[x + 1, y]] = EMPTY; // Connecting hallway.\n            }\n hasVisited.push([nextX, nextY]); // Mark space as visited.\n            visit(nextX, nextY); // Recursively visit this space.\n        }\n    }\n}\n\n// Carve out the paths in the maze data structure:\nlet hasVisited = [[1, 1]]; // Start by visiting the top-left corner.\nvisit(1, 1);\n\n// Display the final resulting maze data structure:\nprintMaze(maze);\n</script>\n```", "```py\nimport random\n\nWIDTH = 39 # Width of the maze (must be odd).\nHEIGHT = 19 # Height of the maze (must be odd).\nassert WIDTH % 2 == 1 and WIDTH >= 3\nassert HEIGHT % 2 == 1 and HEIGHT >= 3\nSEED = 1\nrandom.seed(SEED)\n```", "```py\n<script type=\"text/javascript\">\n\nconst WIDTH = 39; // Width of the maze (must be odd).\nconst HEIGHT = 19; // Height of the maze (must be odd).\nconsole.assert(WIDTH % 2 == 1 && WIDTH >= 3);\nconsole.assert(HEIGHT % 2 == 1 && HEIGHT >= 3);\n```", "```py\n# Use these characters for displaying the maze:\nEMPTY = ' '\nMARK = '@'\nWALL = chr(9608) # Character 9608 is '\u2588'\nNORTH, SOUTH, EAST, WEST = 'n', 's', 'e', 'w'\n```", "```py\n// Use these characters for displaying the maze:\nconst EMPTY = \"&nbsp;\";\nconst MARK = \"@\";\nconst WALL = \"&#9608;\"; // Character 9608 is \u2032\u2588\u2032\nconst [NORTH, SOUTH, EAST, WEST] = [\"n\", \"s\", \"e\", \"w\"];\n```", "```py\n{(0, 0): '\u2588', (0, 1): '\u2588', (0, 2): '\u2588', (0, 3): '\u2588', (0, 4): '\u2588', \n(0, 5): '\u2588', (0, 6): '\u2588', (1, 0): '\u2588', (1, 1): ' ', (1, 2): ' ', \n(1, 3): ' ', (1, 4): ' ', (1, 5): ' ', (1, 6): '\u2588', (2, 0): '\u2588', \n(2, 1): '\u2588', (2, 2): '\u2588', (2, 3): '\u2588', (2, 4): '\u2588', (2, 5): ' ', \n(2, 6): '\u2588', (3, 0): '\u2588', (3, 1): ' ', (3, 2): '\u2588', (3, 3): ' ', \n(3, 4): ' ', (3, 5): ' ', (3, 6): '\u2588', (4, 0): '\u2588', (4, 1): ' ', \n(4, 2): '\u2588', (4, 3): ' ', (4, 4): '\u2588', (4, 5): '\u2588', (4, 6): '\u2588', \n(5, 0): '\u2588', (5, 1): ' ', (5, 2): ' ', (5, 3): ' ', (5, 4): ' ', \n(5, 5): ' ', (5, 6): '\u2588', (6, 0): '\u2588', (6, 1): '\u2588', (6, 2): '\u2588', \n(6, 3): '\u2588', (6, 4): '\u2588', (6, 5): '\u2588', (6, 6): '\u2588'}\n```", "```py\n# Create the filled-in maze data structure to start:\nmaze = {}\nfor x in range(WIDTH):\n    for y in range(HEIGHT):\n        maze[(x, y)] = WALL # Every space is a wall at first.\n```", "```py\n// Create the filled-in maze data structure to start:\nlet maze = {};\nfor (let x = 0; x < WIDTH; x++) {\n    for (let y = 0; y < HEIGHT; y++) {\n        maze[[x, y]] = WALL; // Every space is a wall at first.\n    }\n}\n```", "```py\ndef printMaze(maze, markX=None, markY=None):\n    \"\"\"Displays the maze data structure in the maze argument. The\n    markX and markY arguments are coordinates of the current\n    '@' location of the algorithm as it generates the maze.\"\"\"\n\n    for y in range(HEIGHT):\n        for x in range(WIDTH):\n```", "```py\nfunction printMaze(maze, markX, markY) {\n    // Displays the maze data structure in the maze argument. The\n    // markX and markY arguments are coordinates of the current\n    // '@' location of the algorithm as it generates the maze.\n    document.write('<code>');\n for (let y = 0; y < HEIGHT; y++) {\n        for (let x = 0; x < WIDTH; x++) {\n```", "```py\n if markX == x and markY == y:\n                # Display the '@' mark here:\n                print(MARK, end='')\n            else:\n                # Display the wall or empty space:\n                print(maze[(x, y)], end='')\n\n        print() # Print a newline after printing the row.\n```", "```py\n if (markX === x && markY === y) {\n                // Display the \u2032@\u2032 mark here:\n                document.write(MARK);\n            } else {\n                // Display the wall or empty space:\n                document.write(maze[[x, y]]);\n            }\n        }\n        document.write('<br />'); // Print a newline after printing the row.\n    }\n    document.write('</code>');\n}\n```", "```py\ndef visit(x, y):\n    \"\"\"\"Carve out\" empty spaces in the maze at x, y and then\n    recursively move to neighboring unvisited spaces. This\n    function backtracks when the mark has reached a dead end.\"\"\"\n    maze[(x, y)] = EMPTY # \"Carve out\" the space at x, y.\n    printMaze(maze, x, y) # Display the maze as we generate it.\n    print('\\n\\n')\n```", "```py\nfunction visit(x, y) {\n    // \"Carve out\" empty spaces in the maze at x, y and then\n    // recursively move to neighboring unvisited spaces. This\n    // function backtracks when the mark has reached a dead end.\n\n    maze[[x, y]] = EMPTY; // \"Carve out\" the space at x, y.\n    printMaze(maze, x, y); // Display the maze as we generate it.\n    document.write('<br /><br /><br />');\n```", "```py\n while True:\n        # Check which neighboring spaces adjacent to\n        # the mark have not been visited already:\n        unvisitedNeighbors = []\n        if y > 1 and (x, y - 2) not in hasVisited:\n            unvisitedNeighbors.append(NORTH)\n\n        if y < HEIGHT - 2 and (x, y + 2) not in hasVisited:\n            unvisitedNeighbors.append(SOUTH)\n\n        if x > 1 and (x - 2, y) not in hasVisited:\n            unvisitedNeighbors.append(WEST)\n\n        if x < WIDTH - 2 and (x + 2, y) not in hasVisited:\n            unvisitedNeighbors.append(EAST)\n```", "```py\n while (true) {\n        // Check which neighboring spaces adjacent to\n        // the mark have not been visited already:\n        let unvisitedNeighbors = [];\n        if (y > 1 && !JSON.stringify(hasVisited).includes(JSON.stringify([x, y - 2]))) {\n            unvisitedNeighbors.push(NORTH);\n        }\n        if (y < HEIGHT - 2 && !JSON.stringify(hasVisited).includes(JSON.stringify([x, y + 2]))) {\n            unvisitedNeighbors.push(SOUTH);\n        }\n        if (x > 1 && !JSON.stringify(hasVisited).includes(JSON.stringify([x - 2, y]))) {\n            unvisitedNeighbors.push(WEST);\n        }\n        if (x < WIDTH - 2 && !JSON.stringify(hasVisited).includes(JSON.stringify([x + 2, y]))) {\n            unvisitedNeighbors.push(EAST);\n        }\n```", "```py\n if len(unvisitedNeighbors) == 0:\n            # BASE CASE\n            # All neighboring spaces have been visited, so this is a\n            # dead end. Backtrack to an earlier space:\n            return\n```", "```py\n if (unvisitedNeighbors.length === 0) {\n            // BASE CASE\n            // All neighboring spaces have been visited, so this is a\n            // dead end. Backtrack to an earlier space:\n            return;\n```", "```py\n else:\n            # RECURSIVE CASE\n            # Randomly pick an unvisited neighbor to visit:\n            nextIntersection = random.choice(unvisitedNeighbors)\n\n            # Move the mark to an unvisited neighboring space:\n\n            if nextIntersection == NORTH:\n                nextX = x\n                nextY = y - 2\n                maze[(x, y - 1)] = EMPTY # Connecting hallway.\n            elif nextIntersection == SOUTH:\n                nextX = x\n                nextY = y + 2\n                maze[(x, y + 1)] = EMPTY # Connecting hallway.\n            elif nextIntersection == WEST:\n                nextX = x - 2\n                nextY = y\n                maze[(x - 1, y)] = EMPTY # Connecting hallway.\n            elif nextIntersection == EAST:\n                nextX = x + 2\n                nextY = y\n                maze[(x + 1, y)] = EMPTY # Connecting hallway.\n\n            hasVisited.append((nextX, nextY)) # Mark space as visited.\n            visit(nextX, nextY) # Recursively visit this space.\n```", "```py\n } else {\n            // RECURSIVE CASE\n            // Randomly pick an unvisited neighbor to visit:\n            let nextIntersection = unvisitedNeighbors[\n            Math.floor(Math.random() * unvisitedNeighbors.length)];\n\n            // Move the mark to an unvisited neighboring space:\n            let nextX, nextY;\n            if (nextIntersection === NORTH) {\n                nextX = x;\n                nextY = y - 2;\n                maze[[x, y - 1]] = EMPTY; // Connecting hallway.\n            } else if (nextIntersection === SOUTH) {\n                nextX = x;\n                nextY = y + 2;\n                maze[[x, y + 1]] = EMPTY; // Connecting hallway.\n            } else if (nextIntersection === WEST) {\n                nextX = x - 2;\n                nextY = y;\n                maze[[x - 1, y]] = EMPTY; // Connecting hallway.\n            } else if (nextIntersection === EAST) {\n                nextX = x + 2;\n                nextY = y;\n maze[[x + 1, y]] = EMPTY;    // Connecting hallway.\n            }\n            hasVisited.push([nextX, nextY]); // Mark space as visited.\n            visit(nextX, nextY);             // Recursively visit this space.\n        }\n    }\n}\n```", "```py\n# Carve out the paths in the maze data structure:\nhasVisited = [(1, 1)] # Start by visiting the top-left corner.\nvisit(1, 1)\n\n# Display the final resulting maze data structure:\nprintMaze(maze)\n```", "```py\n// Carve out the paths in the maze data structure:\nlet hasVisited = [[1, 1]]; // Start by visiting the top-left corner.\nvisit(1, 1);\n\n// Display the final resulting maze data structure:\nprintMaze(maze);\n```", "```py\nimport random, time\n\nDIFFICULTY = 40 # How many random slides a puzzle starts with.\nSIZE = 4 # The board is SIZE x SIZE spaces.\nrandom.seed(1) # Select which puzzle to solve.\n\nBLANK = 0\nUP = 'up'\nDOWN = 'down'\nLEFT = 'left'\nRIGHT = 'right'\n\ndef displayBoard(board):\n    \"\"\"Display the tiles stored in `board` on the screen.\"\"\"\n    for y in range(SIZE): # Iterate over each row.\n        for x in range(SIZE): # Iterate over each column.\n            if board[y * SIZE + x] == BLANK:\n                print('__ ', end='') # Display blank tile.\n            else:\n                print(str(board[y * SIZE + x]).rjust(2) + ' ', end='')\n        print() # Print a newline at the end of the row.\n\ndef getNewBoard():\n    \"\"\"Return a list that represents a new tile puzzle.\"\"\"\n    board = []\n    for i in range(1, SIZE * SIZE):\n        board.append(i)\n    board.append(BLANK)\n    return board\n\ndef findBlankSpace(board):\n    \"\"\"Return an [x, y] list of the blank space's location.\"\"\"\n    for x in range(SIZE):\n for y in range(SIZE):\n            if board[y * SIZE + x] == BLANK:\n                return [x, y]\n\ndef makeMove(board, move):\n    \"\"\"Modify `board` in place to carry out the slide in `move`.\"\"\"\n    bx, by = findBlankSpace(board)\n    blankIndex = by * SIZE + bx\n\n    if move == UP:\n        tileIndex = (by + 1) * SIZE + bx\n    elif move == LEFT:\n        tileIndex = by * SIZE + (bx + 1)\n    elif move == DOWN:\n        tileIndex = (by - 1) * SIZE + bx\n    elif move == RIGHT:\n        tileIndex = by * SIZE + (bx - 1)\n\n    # Swap the tiles at blankIndex and tileIndex:\n    board[blankIndex], board[tileIndex] = board[tileIndex], board[blankIndex]\n\ndef undoMove(board, move):\n    \"\"\"Do the opposite move of `move` to undo it on `board`.\"\"\"\n    if move == UP:\n        makeMove(board, DOWN)\n    elif move == DOWN:\n        makeMove(board, UP)\n    elif move == LEFT:\n        makeMove(board, RIGHT)\n    elif move == RIGHT:\n        makeMove(board, LEFT)\n\ndef getValidMoves(board, prevMove=None):\n    \"\"\"Returns a list of the valid moves to make on this board. If\n    prevMove is provided, do not include the move that would undo it.\"\"\"\n\n    blankx, blanky = findBlankSpace(board)\n\n    validMoves = []\n    if blanky != SIZE - 1 and prevMove != DOWN:\n        # Blank space is not on the bottom row.\n        validMoves.append(UP)\n\n    if blankx != SIZE - 1 and prevMove != RIGHT:\n        # Blank space is not on the right column.\n        validMoves.append(LEFT)\n\n    if blanky != 0 and prevMove != UP:\n        # Blank space is not on the top row.\n        validMoves.append(DOWN)\n\n if blankx != 0 and prevMove != LEFT:\n        # Blank space is not on the left column.\n        validMoves.append(RIGHT)\n\n    return validMoves\n\ndef getNewPuzzle():\n    \"\"\"Get a new puzzle by making random slides from the solved state.\"\"\"\n    board = getNewBoard()\n    for i in range(DIFFICULTY):\n        validMoves = getValidMoves(board)\n        makeMove(board, random.choice(validMoves))\n    return board\n\ndef solve(board, maxMoves):\n    \"\"\"Attempt to solve the puzzle in `board` in at most `maxMoves`\n    moves. Returns True if solved, otherwise False.\"\"\"\n    print('Attempting to solve in at most', maxMoves, 'moves...')\n    solutionMoves = [] # A list of UP, DOWN, LEFT, RIGHT values.\n    solved = attemptMove(board, solutionMoves, maxMoves, None)\n\n    if solved:\n        displayBoard(board)\n        for move in solutionMoves:\n            print('Move', move)\n            makeMove(board, move)\n            print() # Print a newline.\n            displayBoard(board)\n            print() # Print a newline.\n\n        print('Solved in', len(solutionMoves), 'moves:')\n        print(', '.join(solutionMoves))\n        return True # Puzzle was solved.\n    else:\n        return False # Unable to solve in maxMoves moves.\n\ndef attemptMove(board, movesMade, movesRemaining, prevMove):\n    \"\"\"A recursive function that attempts all possible moves on `board`\n    until it finds a solution or reaches the `maxMoves` limit.\n    Returns True if a solution was found, in which case `movesMade`\n    contains the series of moves to solve the puzzle. Returns False\n    if `movesRemaining` is less than 0.\"\"\"\n\n    if movesRemaining < 0:\n        # BASE CASE - Ran out of moves.\n        return False\n\n    if board == SOLVED_BOARD:\n        # BASE CASE - Solved the puzzle.\n        return True\n\n    # RECURSIVE CASE - Attempt each of the valid moves:\n for move in getValidMoves(board, prevMove):\n        # Make the move:\n        makeMove(board, move)\n        movesMade.append(move)\n\n        if attemptMove(board, movesMade, movesRemaining - 1, move):\n            # If the puzzle is solved, return True:\n            undoMove(board, move) # Reset to the original puzzle.\n            return True\n\n        # Undo the move to set up for the next move:\n        undoMove(board, move)\n        movesMade.pop() # Remove the last move since it was undone.\n    return False # BASE CASE - Unable to find a solution.\n\n# Start the program:\nSOLVED_BOARD = getNewBoard()\npuzzleBoard = getNewPuzzle()\ndisplayBoard(puzzleBoard)\nstartTime = time.time()\n\nmaxMoves = 10\nwhile True:\n    if solve(puzzleBoard, maxMoves):\n        break # Break out of the loop when a solution is found.\n    maxMoves += 1\nprint('Run in', round(time.time() - startTime, 3), 'seconds.')\n```", "```py\n<script type=\"text/javascript\">\nconst DIFFICULTY = 40; // How many random slides a puzzle starts with.\nconst SIZE = 4; // The board is SIZE x SIZE spaces.\n\nconst BLANK = 0;\nconst UP = \"up\";\nconst DOWN = \"down\";\nconst LEFT = \"left\";\nconst RIGHT = \"right\";\n\nfunction displayBoard(board) {\n    // Display the tiles stored in `board` on the screen.\n    document.write(\"<pre>\");\n    for (let y = 0; y < SIZE; y++) { // Iterate over each row.\n        for (let x = 0; x < SIZE; x++) { // Iterate over each column.\n            if (board[y * SIZE + x] == BLANK) {\n                document.write('__ '); // Display blank tile.\n            } else {\n                document.write(board[y * SIZE + x].toString().padStart(2) + \" \");\n            }\n        }\n document.write(\"<br />\"); // Print a newline at the end of the row.\n    }\n    document.write(\"</pre>\");\n}\n\nfunction getNewBoard() {\n    // Return a list that represents a new tile puzzle.\n    let board = [];\n    for (let i = 1; i < SIZE * SIZE; i++) {\n        board.push(i);\n    }\n    board.push(BLANK);\n    return board;\n}\n\nfunction findBlankSpace(board) {\n    // Return an [x, y] array of the blank space's location.\n    for (let x = 0; x < SIZE; x++) {\n        for (let y = 0; y < SIZE; y++) {\n            if (board[y * SIZE + x] === BLANK) {\n                return [x, y];\n            }\n        }\n    }\n}\n\nfunction makeMove(board, move) {\n    // Modify `board` in place to carry out the slide in `move`.\n    let bx, by;\n    [bx, by] = findBlankSpace(board);\n    let blankIndex = by * SIZE + bx;\n\n    let tileIndex;\n    if (move === UP) {\n        tileIndex = (by + 1) * SIZE + bx;\n    } else if (move === LEFT) {\n        tileIndex = by * SIZE + (bx + 1);\n    } else if (move === DOWN) {\n        tileIndex = (by - 1) * SIZE + bx;\n    } else if (move === RIGHT) {\n        tileIndex = by * SIZE + (bx - 1);\n    }\n\n    // Swap the tiles at blankIndex and tileIndex:\n    [board[blankIndex], board[tileIndex]] = [board[tileIndex], board[blankIndex]];\n}\n\nfunction undoMove(board, move) {\n    // Do the opposite move of `move` to undo it on `board`.\n if (move === UP) {\n        makeMove(board, DOWN);\n    } else if (move === DOWN) {\n        makeMove(board, UP);\n    } else if (move === LEFT) {\n        makeMove(board, RIGHT);\n    } else if (move === RIGHT) {\n        makeMove(board, LEFT);\n    }\n}\n\nfunction getValidMoves(board, prevMove) {\n    // Returns a list of the valid moves to make on this board. If\n    // prevMove is provided, do not include the move that would undo it.\n\n    let blankx, blanky;\n    [blankx, blanky] = findBlankSpace(board);\n\n    let validMoves = [];\n    if (blanky != SIZE - 1 && prevMove != DOWN) {\n        // Blank space is not on the bottom row.\n        validMoves.push(UP);\n    }\n    if (blankx != SIZE - 1 && prevMove != RIGHT) {\n        // Blank space is not on the right column.\n        validMoves.push(LEFT);\n    }\n    if (blanky != 0 && prevMove != UP) {\n        // Blank space is not on the top row.\n        validMoves.push(DOWN);\n    }\n    if (blankx != 0 && prevMove != LEFT) {\n        // Blank space is not on the left column.\n        validMoves.push(RIGHT);\n    }\n    return validMoves;\n}\n\nfunction getNewPuzzle() {\n    // Get a new puzzle by making random slides from the solved state.\n    let board = getNewBoard();\n    for (let i = 0; i < DIFFICULTY; i++) {\n        let validMoves = getValidMoves(board);\n        makeMove(board, validMoves[Math.floor(Math.random() * validMoves.length)]);\n    }\n    return board;\n}\n\nfunction solve(board, maxMoves) {\n    // Attempt to solve the puzzle in `board` in at most `maxMoves`\n    // moves. Returns true if solved, otherwise false.\n    document.write(\"Attempting to solve in at most \" + maxMoves + \" moves...<br />\");\n    let solutionMoves = []; // A list of UP, DOWN, LEFT, RIGHT values.\n let solved = attemptMove(board, solutionMoves, maxMoves, null);\n\n    if (solved) {\n        displayBoard(board);\n        for (let move of solutionMoves) {\n            document.write(\"Move \" + move + \"<br />\");\n            makeMove(board, move);\n            document.write(\"<br />\"); // Print a newline.\n            displayBoard(board);\n            document.write(\"<br />\"); // Print a newline.\n        }\n        document.write(\"Solved in \" + solutionMoves.length + \" moves:<br />\");\n        document.write(solutionMoves.join(\", \") + \"<br />\");\n        return true; // Puzzle was solved.\n    } else {\n        return false; // Unable to solve in maxMoves moves.\n    }\n}\n\nfunction attemptMove(board, movesMade, movesRemaining, prevMove) {\n    // A recursive function that attempts all possible moves on `board`\n    // until it finds a solution or reaches the `maxMoves` limit.\n    // Returns true if a solution was found, in which case `movesMade`\n    // contains the series of moves to solve the puzzle. Returns false\n    // if `movesRemaining` is less than 0.\n\n    if (movesRemaining < 0) {\n        // BASE CASE - Ran out of moves.\n        return false;\n    }\n\n    if (JSON.stringify(board) == SOLVED_BOARD) {\n        // BASE CASE - Solved the puzzle.\n        return true;\n    }\n\n    // RECURSIVE CASE - Attempt each of the valid moves:\n    for (let move of getValidMoves(board, prevMove)) {\n        // Make the move:\n        makeMove(board, move);\n        movesMade.push(move);\n\n        if (attemptMove(board, movesMade, movesRemaining - 1, move)) {\n            // If the puzzle is solved, return true:\n            undoMove(board, move); // Reset to the original puzzle.\n            return true;\n        }\n\n        // Undo the move to set up for the next move:\n        undoMove(board, move);\n        movesMade.pop(); // Remove the last move since it was undone.\n    }\n    return false; // BASE CASE - Unable to find a solution.\n}\n // Start the program:\nconst SOLVED_BOARD = JSON.stringify(getNewBoard());\nlet puzzleBoard = getNewPuzzle();\ndisplayBoard(puzzleBoard);\nlet startTime = Date.now();\n\nlet maxMoves = 10;\nwhile (true) {\n    if (solve(puzzleBoard, maxMoves)) {\n        break; // Break out of the loop when a solution is found.\n    }\n    maxMoves += 1;\n}\ndocument.write(\"Run in \" + Math.round((Date.now() - startTime) / 100) / 10 + \" seconds.<br />\");\n</script>\n```", "```py\n 7  1  3  4\n 2  5 10  8\n__  6  9 11\n13 14 15 12\nAttempting to solve in at most 10 moves...\nAttempting to solve in at most 11 moves...\nAttempting to solve in at most 12 moves...\n`--snip--`\n 1  2  3  4\n 5  6  7  8\n 9 10 11 __\n13 14 15 12\n\nMove up\n\n 1  2  3  4\n 5  6  7  8\n 9 10 11 12\n13 14 15 __\n\nSolved in 18 moves:\nleft, down, right, down, left, up, right, up, left, left, down, \nright, right, up, left, left, left, up\nRun in 39.519 seconds.\n```", "```py\nimport random, time\n\nDIFFICULTY = 40 # How many random slides a puzzle starts with.\nSIZE = 4 # The board is SIZE x SIZE spaces.\nrandom.seed(1) # Select which puzzle to solve.\n\nBLANK = 0\nUP = 'up'\nDOWN = 'down'\nLEFT = 'left'\nRIGHT = 'right'\n```", "```py\n<script type=\"text/javascript\">\nconst DIFFICULTY = 40; // How many random slides a puzzle starts with.\nconst SIZE = 4; // The board is SIZE x SIZE spaces.\n\nconst BLANK = 0;\nconst UP = \"up\";\nconst DOWN = \"down\";\nconst LEFT = \"left\";\nconst RIGHT = \"right\";\n```", "```py\ndef displayBoard(board):\n    \"\"\"Display the tiles stored in `board` on the screen.\"\"\"\n    for y in range(SIZE): # Iterate over each row.\n        for x in range(SIZE): # Iterate over each column.\n            if board[y * SIZE + x] == BLANK:\n                print('__ ', end='') # Display blank tile.\n            else:\n                print(str(board[y * SIZE + x]).rjust(2) + ' ', end='')\n        print() # Print a newline at the end of the row.\n```", "```py\nfunction displayBoard(board) {\n    // Display the tiles stored in `board` on the screen.\n    document.write(\"<pre>\");\n    for (let y = 0; y < SIZE; y++) { // Iterate over each row.\n        for (let x = 0; x < SIZE; x++) { // Iterate over each column.\n            if (board[y * SIZE + x] == BLANK) {\n                document.write('__ '); // Display blank tile.\n            } else {\n                document.write(board[y * SIZE + x].toString().padStart(2) + \" \");\n            }\n        }\n        document.write(\"<br />\");\n    }\n    document.write(\"</pre>\");\n}\n```", "```py\n15  2  1 12 \n 8  5  6 11 \n 4  9 10  7 \n 3 14 13 __\n```", "```py\ndef getNewBoard():\n    \"\"\"Return a list that represents a new tile puzzle.\"\"\"\n    board = []\n    for i in range(1, SIZE * SIZE):\n        board.append(i)\n    board.append(BLANK)\n    return board\n```", "```py\nfunction getNewBoard() {\n    // Return a list that represents a new tile puzzle.\n    let board = [];\n    for (let i = 1; i < SIZE * SIZE; i++) {\n        board.push(i);\n    }\n    board.push(BLANK);\n    return board;\n}\n```", "```py\ndef findBlankSpace(board):\n    \"\"\"Return an [x, y] list of the blank space's location.\"\"\"\n    for x in range(SIZE):\n        for y in range(SIZE):\n            if board[y * SIZE + x] == BLANK:\n                return [x, y]\n```", "```py\nfunction findBlankSpace(board) {\n    // Return an [x, y] array of the blank space's location.\n    for (let x = 0; x < SIZE; x++) {\n        for (let y = 0; y < SIZE; y++) {\n            if (board[y * SIZE + x] === BLANK) {\n                return [x, y];\n            }\n        }\n    }\n}\n```", "```py\ndef makeMove(board, move):\n    \"\"\"Modify `board` in place to carry out the slide in `move`.\"\"\"\n    bx, by = findBlankSpace(board)\n    blankIndex = by * SIZE + bx\n\n    if move == UP:\n        tileIndex = (by + 1) * SIZE + bx\n    elif move == LEFT:\n        tileIndex = by * SIZE + (bx + 1)\n    elif move == DOWN:\n        tileIndex = (by - 1) * SIZE + bx\n    elif move == RIGHT:\n        tileIndex = by * SIZE + (bx - 1)\n\n    # Swap the tiles at blankIndex and tileIndex:\n    board[blankIndex], board[tileIndex] = board[tileIndex], board[blankIndex]\n```", "```py\nfunction makeMove(board, move) {\n    // Modify `board` in place to carry out the slide in `move`.\n    let bx, by;\n    [bx, by] = findBlankSpace(board);\n    let blankIndex = by * SIZE + bx;\n\n let tileIndex;\n    if (move === UP) {\n        tileIndex = (by + 1) * SIZE + bx;\n    } else if (move === LEFT) {\n        tileIndex = by * SIZE + (bx + 1);\n    } else if (move === DOWN) {\n        tileIndex = (by - 1) * SIZE + bx;\n    } else if (move === RIGHT) {\n        tileIndex = by * SIZE + (bx - 1);\n    }\n\n    // Swap the tiles at blankIndex and tileIndex:\n    [board[blankIndex], board[tileIndex]] = [board[tileIndex], board[blankIndex]];\n}\n```", "```py\ndef undoMove(board, move):\n    \"\"\"Do the opposite move of `move` to undo it on `board`.\"\"\"\n    if move == UP:\n        makeMove(board, DOWN)\n    elif move == DOWN:\n        makeMove(board, UP)\n    elif move == LEFT:\n        makeMove(board, RIGHT)\n    elif move == RIGHT:\n        makeMove(board, LEFT)\n```", "```py\nfunction undoMove(board, move) {\n    // Do the opposite move of `move` to undo it on `board`.\n    if (move === UP) {\n        makeMove(board, DOWN);\n    } else if (move === DOWN) {\n        makeMove(board, UP);\n    } else if (move === LEFT) {\n        makeMove(board, RIGHT);\n } else if (move === RIGHT) {\n        makeMove(board, LEFT);\n    }\n}\n```", "```py\ndef getValidMoves(board, prevMove=None):\n    \"\"\"Returns a list of the valid moves to make on this board. If\n    prevMove is provided, do not include the move that would undo it.\"\"\"\n\n    blankx, blanky = findBlankSpace(board)\n\n    validMoves = []\n if blanky != SIZE - 1 and prevMove != DOWN:\n        # Blank space is not on the bottom row.\n        validMoves.append(UP)\n\n    if blankx != SIZE - 1 and prevMove != RIGHT:\n        # Blank space is not on the right column.\n        validMoves.append(LEFT)\n\n    if blanky != 0 and prevMove != UP:\n        # Blank space is not on the top row.\n        validMoves.append(DOWN)\n\n    if blankx != 0 and prevMove != LEFT:\n        # Blank space is not on the left column.\n        validMoves.append(RIGHT)\n\n    return validMoves\n```", "```py\nfunction getValidMoves(board, prevMove) {\n    // Returns a list of the valid moves to make on this board. If\n    // prevMove is provided, do not include the move that would undo it.\n\n    let blankx, blanky;\n    [blankx, blanky] = findBlankSpace(board);\n\n    let validMoves = [];\n    if (blanky != SIZE - 1 && prevMove != DOWN) {\n        // Blank space is not on the bottom row.\n        validMoves.push(UP);\n    }\n    if (blankx != SIZE - 1 && prevMove != RIGHT) {\n        // Blank space is not on the right column.\n        validMoves.push(LEFT);\n    }\n    if (blanky != 0 && prevMove != UP) {\n        // Blank space is not on the top row.\n        validMoves.push(DOWN);\n    }\n    if (blankx != 0 && prevMove != LEFT) {\n        // Blank space is not on the left column.\n        validMoves.push(RIGHT);\n    }\n    return validMoves;\n}\n```", "```py\ndef getNewPuzzle():\n    \"\"\"Get a new puzzle by making random slides from the solved state.\"\"\"\n    board = getNewBoard()\n    for i in range(DIFFICULTY):\n        validMoves = getValidMoves(board)\n        makeMove(board, random.choice(validMoves))\n    return board\n```", "```py\nfunction getNewPuzzle() {\n    // Get a new puzzle by making random slides from the solved state.\n    let board = getNewBoard();\n    for (let i = 0; i < DIFFICULTY; i++) {\n        let validMoves = getValidMoves(board);\n        makeMove(board, validMoves[Math.floor(Math.random() * validMoves.length)]);\n    }\n    return board;\n}\n```", "```py\ndef solve(board, maxMoves):\n    \"\"\"Attempt to solve the puzzle in `board` in at most `maxMoves`\n    moves. Returns True if solved, otherwise False.\"\"\"\n    print('Attempting to solve in at most', maxMoves, 'moves...')\n    solutionMoves = [] # A list of UP, DOWN, LEFT, RIGHT values.\n    solved = attemptMove(board, solutionMoves, maxMoves, None)\n```", "```py\nfunction solve(board, maxMoves) {\n    // Attempt to solve the puzzle in `board` in at most `maxMoves`\n    // moves. Returns true if solved, otherwise false.\n    document.write(\"Attempting to solve in at most \" + maxMoves + \" moves...<br />\");\n    let solutionMoves = []; // A list of UP, DOWN, LEFT, RIGHT values.\n    let solved = attemptMove(board, solutionMoves, maxMoves, null);\n```", "```py\n if solved:\n        displayBoard(board)\n        for move in solutionMoves:\n            print('Move', move)\n            makeMove(board, move)\n            print() # Print a newline.\n            displayBoard(board)\n            print() # Print a newline.\n\n        print('Solved in', len(solutionMoves), 'moves:')\n        print(', '.join(solutionMoves))\n        return True # Puzzle was solved.\n    else:\n        return False # Unable to solve in maxMoves moves.\n```", "```py\n if (solved) {\n        displayBoard(board);\n        for (let move of solutionMoves) {\n            document.write(\"Move \" + move + \"<br />\");\n            makeMove(board, move);\n            document.write(\"<br />\"); // Print a newline.\n            displayBoard(board);\n            document.write(\"<br />\"); // Print a newline.\n        }\n        document.write(\"Solved in \" + solutionMoves.length + \" moves:<br />\");\n        document.write(solutionMoves.join(\", \") + \"<br />\");\n        return true; // Puzzle was solved.\n    } else {\n        return false; // Unable to solve in maxMoves moves.\n    }\n}\n```", "```py\ndef attemptMove(board, movesMade, movesRemaining, prevMove):\n    \"\"\"A recursive function that attempts all possible moves on `board`\n    until it finds a solution or reaches the `maxMoves` limit.\n    Returns True if a solution was found, in which case `movesMade`\n    contains the series of moves to solve the puzzle. Returns False\n    if `movesRemaining` is less than 0.\"\"\"\n\n    if movesRemaining < 0:\n        # BASE CASE - Ran out of moves.\n        return False\n\n    if board == SOLVED_BOARD:\n        # BASE CASE - Solved the puzzle.\n        return True\n```", "```py\nfunction attemptMove(board, movesMade, movesRemaining, prevMove) {\n    // A recursive function that attempts all possible moves on `board`\n    // until it finds a solution or reaches the `maxMoves` limit.\n    // Returns true if a solution was found, in which case `movesMade`\n    // contains the series of moves to solve the puzzle. Returns false\n    // if `movesRemaining` is less than 0.\n\n    if (movesRemaining < 0) {\n        // BASE CASE - Ran out of moves.\n        return false;\n    }\n\n    if (JSON.stringify(board) == SOLVED_BOARD) {\n        // BASE CASE - Solved the puzzle.\n        return true;\n    }\n```", "```py\n # RECURSIVE CASE - Attempt each of the valid moves:\n    for move in getValidMoves(board, prevMove):\n        # Make the move:\n        makeMove(board, move)\n        movesMade.append(move)\n\n        if attemptMove(board, movesMade, movesRemaining - 1, move):\n            # If the puzzle is solved, return True:\n            undoMove(board, move) # Reset to the original puzzle.\n            return True\n```", "```py\n // RECURSIVE CASE - Attempt each of the valid moves:\n    for (let move of getValidMoves(board, prevMove)) {\n        // Make the move:\n        makeMove(board, move);\n        movesMade.push(move);\n\n        if (attemptMove(board, movesMade, movesRemaining - 1, move)) {\n            // If the puzzle is solved, return True:\n            undoMove(board, move); // Reset to the original puzzle.\n            return true;\n        }\n```", "```py\n # Undo the move to set up for the next move:\n        undoMove(board, move)\n        movesMade.pop() # Remove the last move since it was undone.\n    return False # BASE CASE - Unable to find a solution.\n```", "```py\n // Undo the move to set up for the next move:\n        undoMove(board, move);\n        movesMade.pop(); // Remove the last move since it was undone.\n    }\n    return false; // BASE CASE - Unable to find a solution.\n}\n```", "```py\n# Start the program:\nSOLVED_BOARD = getNewBoard()\npuzzleBoard = getNewPuzzle()\ndisplayBoard(puzzleBoard)\nstartTime = time.time()\n```", "```py\n// Start the program:\nconst SOLVED_BOARD = JSON.stringify(getNewBoard());\nlet puzzleBoard = getNewPuzzle();\ndisplayBoard(puzzleBoard);\nlet startTime = Date.now();\n```", "```py\nmaxMoves = 10\nwhile True:\n    if solve(puzzleBoard, maxMoves):\n        break # Break out of the loop when a solution is found.\n    maxMoves += 1\nprint('Run in', round(time.time() - startTime, 3), 'seconds.')\n```", "```py\nlet maxMoves = 10;\nwhile (true) {\n    if (solve(puzzleBoard, maxMoves)) {\n        break; // Break out of the loop when a solution is found.\n    }\n    maxMoves += 1;\n}\ndocument.write(\"Run in \" + Math.round((Date.now() - startTime) / 100) / 10 + \" seconds.<br />\");\n</script>\n```", "```py\nimport turtle, math\n\nDRAW_FRACTAL = 1 # Set to 1 through 11 and run the program.\n\nturtle.tracer(5000, 0) # Increase the first argument to speed up the drawing.\nturtle.hideturtle()\n\ndef drawFilledSquare(size, depth):\n    size = int(size)\n\n    # Move to the top-right corner before drawing:\n    turtle.penup()\n    turtle.forward(size // 2)\n    turtle.left(90)\n    turtle.forward(size // 2)\n    turtle.left(180)\n    turtle.pendown()\n\n    # Alternate between white and gray (with black border):\n    if depth % 2 == 0:\n        turtle.pencolor('black')\n        turtle.fillcolor('white')\n    else:\n        turtle.pencolor('black')\n        turtle.fillcolor('gray')\n\n    # Draw a square:\n    turtle.begin_fill()\n    for i in range(4): # Draw four lines.\n        turtle.forward(size)\n        turtle.right(90)\n    turtle.end_fill()\n\ndef drawTriangleOutline(size, depth):\n    size = int(size)\n\n    # Move the turtle to the top of the equilateral triangle:\n    height = size * math.sqrt(3) / 2\n    turtle.penup()\n    turtle.left(90) # Turn to face upward.\n    turtle.forward(height * (2/3)) # Move to the top corner.\n    turtle.right(150) # Turn to face the bottom-right corner.\n    turtle.pendown()\n\n    # Draw the three sides of the triangle:\n    for i in range(3):\n        turtle.forward(size)\n        turtle.right(120)\n\ndef drawFractal(shapeDrawFunction, size, specs, maxDepth=8, depth=0):\n    if depth > maxDepth or size < 1:\n        return # BASE CASE\n\n    # Save the position and heading at the start of this function call:\n    initialX = turtle.xcor()\n    initialY = turtle.ycor()\n    initialHeading = turtle.heading()\n\n # Call the draw function to draw the shape:\n    turtle.pendown()\n    shapeDrawFunction(size, depth)\n    turtle.penup()\n\n    # RECURSIVE CASE\n    for spec in specs:\n        # Each dictionary in specs has keys 'sizeChange', 'xChange',\n        # 'yChange', and 'angleChange'. The size, x, and y changes\n        # are multiplied by the size parameter. The x change and y\n        # change are added to the turtle's current position. The angle\n        # change is added to the turtle's current heading.\n        sizeCh = spec.get('sizeChange', 1.0)\n        xCh = spec.get('xChange', 0.0)\n        yCh = spec.get('yChange', 0.0)\n        angleCh = spec.get('angleChange', 0.0)\n\n        # Reset the turtle to the shape's starting point:\n        turtle.goto(initialX, initialY)\n        turtle.setheading(initialHeading + angleCh)\n        turtle.forward(size * xCh)\n        turtle.left(90)\n        turtle.forward(size * yCh)\n        turtle.right(90)\n\n        # Make the recursive call:\n        drawFractal(shapeDrawFunction, size * sizeCh, specs, maxDepth, \n        depth + 1)\n\nif DRAW_FRACTAL == 1:\n    # Four Corners:\n    drawFractal(drawFilledSquare, 350,\n        [{'sizeChange': 0.5, 'xChange': -0.5, 'yChange': 0.5},\n         {'sizeChange': 0.5, 'xChange': 0.5, 'yChange': 0.5},\n         {'sizeChange': 0.5, 'xChange': -0.5, 'yChange': -0.5},\n         {'sizeChange': 0.5, 'xChange': 0.5, 'yChange': -0.5}], 5)\nelif DRAW_FRACTAL == 2:\n    # Spiral Squares:\n    drawFractal(drawFilledSquare, 600, [{'sizeChange': 0.95,\n        'angleChange': 7}], 50)\nelif DRAW_FRACTAL == 3:\n    # Double Spiral Squares:\n    drawFractal(drawFilledSquare, 600,\n        [{'sizeChange': 0.8, 'yChange': 0.1, 'angleChange': -10},\n         {'sizeChange': 0.8, 'yChange': -0.1, 'angleChange': 10}])\nelif DRAW_FRACTAL == 4:\n    # Triangle Spiral:\n    drawFractal(drawTriangleOutline, 20,\n        [{'sizeChange': 1.05, 'angleChange': 7}], 80)\nelif DRAW_FRACTAL == 5:\n    # Conway's Game of Life Glider:\n    third = 1 / 3\n    drawFractal(drawFilledSquare, 600,\n        [{'sizeChange': third, 'yChange': third},\n {'sizeChange': third, 'xChange': third},\n         {'sizeChange': third, 'xChange': third, 'yChange': -third},\n         {'sizeChange': third, 'yChange': -third},\n         {'sizeChange': third, 'xChange': -third, 'yChange': -third}])\nelif DRAW_FRACTAL == 6:\n    # Sierpi\u0144ski Triangle:\n    toMid = math.sqrt(3) / 6\n    drawFractal(drawTriangleOutline, 600,\n        [{'sizeChange': 0.5, 'yChange': toMid, 'angleChange': 0},\n         {'sizeChange': 0.5, 'yChange': toMid, 'angleChange': 120},\n         {'sizeChange': 0.5, 'yChange': toMid, 'angleChange': 240}])\nelif DRAW_FRACTAL == 7:\n    # Wave:\n    drawFractal(drawTriangleOutline, 280,\n        [{'sizeChange': 0.5, 'xChange': -0.5, 'yChange': 0.5},\n         {'sizeChange': 0.3, 'xChange': 0.5, 'yChange': 0.5},\n         {'sizeChange': 0.5, 'yChange': -0.7, 'angleChange': 15}])\nelif DRAW_FRACTAL == 8:\n    # Horn:\n    drawFractal(drawFilledSquare, 100,\n        [{'sizeChange': 0.96, 'yChange': 0.5, 'angleChange': 11}], 100)\nelif DRAW_FRACTAL == 9:\n    # Snowflake:\n    drawFractal(drawFilledSquare, 200,\n        [{'xChange': math.cos(0 * math.pi / 180),\n          'yChange': math.sin(0 * math.pi / 180), 'sizeChange': 0.4},\n         {'xChange': math.cos(72 * math.pi / 180),\n          'yChange': math.sin(72 * math.pi / 180), 'sizeChange': 0.4},\n         {'xChange': math.cos(144 * math.pi / 180),\n          'yChange': math.sin(144 * math.pi / 180), 'sizeChange': 0.4},\n         {'xChange': math.cos(216 * math.pi / 180),\n          'yChange': math.sin(216 * math.pi / 180), 'sizeChange': 0.4},\n         {'xChange': math.cos(288 * math.pi / 180),\n          'yChange': math.sin(288 * math.pi / 180), 'sizeChange': 0.4}])\nelif DRAW_FRACTAL == 10:\n    # The filled square shape:\n    turtle.tracer(1, 0)\n    drawFilledSquare(400, 0)\nelif DRAW_FRACTAL == 11:\n    # The triangle outline shape:\n    turtle.tracer(1, 0)\n    drawTriangleOutline(400, 0)\nelse:\n    assert False, 'Set DRAW_FRACTAL to a number from 1 to 11.'\n\nturtle.exitonclick() # Click the window to exit.\n```", "```py\nimport turtle, math\n\nDRAW_FRACTAL = 1 # Set to 1 through 11 and run the program.\n\nturtle.tracer(5000, 0) # Increase the first argument to speed up the drawing.\nturtle.hideturtle()\n```", "```py\ndef drawFilledSquare(size, depth):\n    size = int(size)\n```", "```py\n # Move to the top-right corner before drawing:\n    turtle.penup()\n    turtle.forward(size // 2)\n    turtle.left(90)\n    turtle.forward(size // 2)\n    turtle.left(180)\n    turtle.pendown()\n```", "```py\n # Alternate between white and gray (with black border):\n    if depth % 2 == 0:\n        turtle.pencolor('black')\n        turtle.fillcolor('white')\n    else:\n        turtle.pencolor('black')\n        turtle.fillcolor('gray')\n```", "```py\n # Draw a square:\n    turtle.begin_fill()\n    for i in range(4): # Draw four lines.\n        turtle.forward(size)\n        turtle.right(90)\n    turtle.end_fill()\n```", "```py\n`height = size * math.sqrt(3) / 2`\n```", "```py\ndef drawTriangleOutline(size, depth):\n    size = int(size)\n\n    # Move the turtle to the top of the equilateral triangle:\n    height = size * math.sqrt(3) / 2\n    turtle.penup()\n    turtle.left(90) # Turn to face upward.\n    turtle.forward(height * (2/3)) # Move to the top corner.\n    turtle.right(150) # Turn to face the bottom-right corner.\n    turtle.pendown()\n```", "```py\n # Draw the three sides of the triangle:\n    for i in range(3):\n        turtle.forward(size)\n        turtle.right(120)\n```", "```py\ndef drawFractal(shapeDrawFunction, size, specs, maxDepth=8, depth=0):\n    if depth > maxDepth or size < 1:\n        return # BASE CASE\n```", "```py\n # Save the position and heading at the start of this function call:\n    initialX = turtle.xcor()\n    initialY = turtle.ycor()\n    initialHeading = turtle.heading()\n```", "```py\n # Call the draw function to draw the shape:\n    turtle.pendown()\n    shapeDrawFunction(size, depth)\n    turtle.penup()\n```", "```py\n[{'sizeChange': 0.5, 'xChange': -0.5, 'yChange': 0.5},\n {'sizeChange': 0.5, 'xChange': 0.5, 'yChange': 0.5},\n {'sizeChange': 0.5, 'xChange': -0.5, 'yChange': -0.5},\n {'sizeChange': 0.5, 'xChange': 0.5, 'yChange': -0.5}]\n```", "```py\n # RECURSIVE CASE\n    for spec in specs:\n        # Each dictionary in specs has keys 'sizeChange', 'xChange',\n        # 'yChange', and 'angleChange'. The size, x, and y changes\n        # are multiplied by the size parameter. The x change and y\n        # change are added to the turtle's current position. The angle\n        # change is added to the turtle's current heading.\n        sizeCh = spec.get('sizeChange', 1.0)\n        xCh = spec.get('xChange', 0.0)\n        yCh = spec.get('yChange', 0.0)\n        angleCh = spec.get('angleChange', 0.0)\n```", "```py\n # Reset the turtle to the shape's starting point:\n        turtle.goto(initialX, initialY)\n        turtle.setheading(initialHeading + angleCh)\n\n        turtle.forward(size * xCh)\n        turtle.left(90)\n        turtle.forward(size * yCh)\n        turtle.right(90)\n```", "```py\n # Make the recursive call:\n        drawFractal(shapeDrawFunction, size * sizeCh, specs, maxDepth, \n        depth + 1)\n```", "```py\nif DRAW_FRACTAL == 1:\n    # Four Corners:\n    drawFractal(drawFilledSquare, 350,\n        [{'sizeChange': 0.5, 'xChange': -0.5, 'yChange': 0.5},\n         {'sizeChange': 0.5, 'xChange': 0.5, 'yChange': 0.5},\n         {'sizeChange': 0.5, 'xChange': -0.5, 'yChange': -0.5},\n         {'sizeChange': 0.5, 'xChange': 0.5, 'yChange': -0.5}], 5)\n```", "```py\nelif DRAW_FRACTAL == 2:\n    # Spiral Squares:\n    drawFractal(drawFilledSquare, 600, [{'sizeChange': 0.95,\n        'angleChange': 7}], 50)\n```", "```py\nelif DRAW_FRACTAL == 3:\n    # Double Spiral Squares:\n    drawFractal(drawFilledSquare, 600,\n        [{'sizeChange': 0.8, 'yChange': 0.1, 'angleChange': -10},\n         {'sizeChange': 0.8, 'yChange': -0.1, 'angleChange': 10}])\n```", "```py\nelif DRAW_FRACTAL == 4:\n    # Triangle Spiral:\n    drawFractal(drawTriangleOutline, 20,\n        [{'sizeChange': 1.05, 'angleChange': 7}], 80)\n```", "```py\nelif DRAW_FRACTAL == 5:\n    # Conway's Game of Life Glider:\n    third = 1 / 3\n    drawFractal(drawFilledSquare, 600,\n        [{'sizeChange': third, 'yChange': third},\n         {'sizeChange': third, 'xChange': third},\n         {'sizeChange': third, 'xChange': third, 'yChange': -third},\n         {'sizeChange': third, 'yChange': -third},\n         {'sizeChange': third, 'xChange': -third, 'yChange': -third}])\n```", "```py\nelif DRAW_FRACTAL == 6:\n    # Sierpi\u0144ski Triangle:\n    toMid = math.sqrt(3) / 6\n    drawFractal(drawTriangleOutline, 600,\n        [{'sizeChange': 0.5, 'yChange': toMid, 'angleChange': 0},\n         {'sizeChange': 0.5, 'yChange': toMid, 'angleChange': 120},\n         {'sizeChange': 0.5, 'yChange': toMid, 'angleChange': 240}])\n```", "```py\nelif DRAW_FRACTAL == 7:\n    # Wave:\n    drawFractal(drawTriangleOutline, 280,\n        [{'sizeChange': 0.5, 'xChange': -0.5, 'yChange': 0.5},\n         {'sizeChange': 0.3, 'xChange': 0.5, 'yChange': 0.5},\n         {'sizeChange': 0.5, 'yChange': -0.7, 'angleChange': 15}])\n```", "```py\nelif DRAW_FRACTAL == 8:\n    # Horn:\n    drawFractal(drawFilledSquare, 100,\n        [{'sizeChange': 0.96, 'yChange': 0.5, 'angleChange': 11}], 100)\n```", "```py\nelif DRAW_FRACTAL == 9:\n    # Snowflake:\n    drawFractal(drawFilledSquare, 200,\n        [{'xChange': math.cos(0 * math.pi / 180),\n          'yChange': math.sin(0 * math.pi / 180), 'sizeChange': 0.4},\n         {'xChange': math.cos(72 * math.pi / 180),\n          'yChange': math.sin(72 * math.pi / 180), 'sizeChange': 0.4},\n         {'xChange': math.cos(144 * math.pi / 180),\n          'yChange': math.sin(144 * math.pi / 180), 'sizeChange': 0.4},\n         {'xChange': math.cos(216 * math.pi / 180),\n          'yChange': math.sin(216 * math.pi / 180), 'sizeChange': 0.4},\n         {'xChange': math.cos(288 * math.pi / 180),\n          'yChange': math.sin(288 * math.pi / 180), 'sizeChange': 0.4}])\n```", "```py\nelif DRAW_FRACTAL == 10:\n    # The filled square shape:\n    turtle.tracer(1, 0)\n    drawFilledSquare(400, 0)\nelif DRAW_FRACTAL == 11:\n    # The triangle outline shape:\n    turtle.tracer(1, 0)\n    drawTriangleOutline(400, 0)\nturtle.exitonclick() # Click the window to exit.\n```", "```py\nfrom PIL import Image\n\ndef makeDroste(baseImage, stopAfter=10):\n    # If baseImage is a string of an image filename, load that image:\n    if isinstance(baseImage, str):\n        baseImage = Image.open(baseImage)\n\n    if stopAfter == 0:\n        # BASE CASE\n        return baseImage\n    # The magenta color has max red/blue/alpha, zero green:\n    if baseImage.mode == 'RGBA':\n        magentaColor = (255, 0, 255, 255)\n    elif baseImage.mode == 'RGB':\n        magentaColor = (255, 0, 255)\n\n    # Find the dimensions of the base image and its magenta area:\n    baseImageWidth, baseImageHeight = baseImage.size\n    magentaLeft = None\n    magentaRight = None\n    magentaTop = None\n    magentaBottom = None\n\n    for x in range(baseImageWidth):\n        for y in range(baseImageHeight):\n            if baseImage.getpixel((x, y)) == magentaColor:\n                if magentaLeft is None or x < magentaLeft:\n                    magentaLeft = x\n                if magentaRight is None or x > magentaRight:\n                    magentaRight = x\n                if magentaTop is None or y < magentaTop:\n                    magentaTop = y\n                if magentaBottom is None or y > magentaBottom:\n                    magentaBottom = y\n\n    if magentaLeft is None:\n        # BASE CASE - No magenta pixels are in the image.\n        return baseImage\n\n    # Get a resized version of the base image:\n    magentaWidth = magentaRight - magentaLeft + 1\n    magentaHeight = magentaBottom - magentaTop + 1\n    baseImageAspectRatio = baseImageWidth / baseImageHeight\n    magentaAspectRatio = magentaWidth / magentaHeight\n\n    if baseImageAspectRatio < magentaAspectRatio:\n        # Make the resized width match the width of the magenta area:\n        widthRatio = magentaWidth / baseImageWidth\n        resizedImage = baseImage.resize((magentaWidth, \n        int(baseImageHeight * widthRatio) + 1), Image.NEAREST)\n    else:\n        # Make the resized height match the height of the magenta area:\n        heightRatio =  magentaHeight / baseImageHeight\n resizedImage = baseImage.resize((int(baseImageWidth * \n        heightRatio) + 1, magentaHeight), Image.NEAREST)\n\n    # Replace the magenta pixels with the smaller, resized image:\n    for x in range(magentaLeft, magentaRight + 1):\n        for y in range(magentaTop, magentaBottom + 1):\n            if baseImage.getpixel((x, y)) == magentaColor:\n                pix = resizedImage.getpixel((x - magentaLeft, y - magentaTop))\n                baseImage.putpixel((x, y), pix)\n\n    # RECURSIVE CASE:\n    return makeDroste(baseImage, stopAfter=stopAfter - 1)\n\nrecursiveImage = makeDroste('museum.png')\nrecursiveImage.save('museum-recursive.png')\nrecursiveImage.show()\n```", "```py\nfrom PIL import Image\n\ndef makeDroste(baseImage, stopAfter=10):\n    # If baseImage is a string of an image filename, load that image:\n    if isinstance(baseImage, str):\n        baseImage = Image.open(baseImage)\n```", "```py\n if stopAfter == 0:\n        # BASE CASE\n        return baseImage\n```", "```py\n # The magenta color has max red/blue/alpha, zero green:\n    if baseImage.mode == 'RGBA':\n        magentaColor = (255, 0, 255, 255)\n    elif baseImage.mode == 'RGB':\n        magentaColor = (255, 0, 255)\n```", "```py\n # Find the dimensions of the base image and its magenta area:\n    baseImageWidth, baseImageHeight = baseImage.size\n    magentaLeft = None\n    magentaRight = None\n    magentaTop = None\n    magentaBottom = None\n```", "```py\n for x in range(baseImageWidth):\n        for y in range(baseImageHeight):\n            if baseImage.getpixel((x, y)) == magentaColor:\n                if magentaLeft is None or x < magentaLeft:\n                    magentaLeft = x\n                if magentaRight is None or x > magentaRight:\n                    magentaRight = x\n                if magentaTop is None or y < magentaTop:\n                    magentaTop = y\n                if magentaBottom is None or y > magentaBottom:\n                    magentaBottom = y\n```", "```py\n if magentaLeft is None:\n        # BASE CASE - No magenta pixels are in the image.\n        return baseImage\n```", "```py\n # Get a resized version of the base image:\n    magentaWidth = magentaRight - magentaLeft + 1\n    magentaHeight = magentaBottom - magentaTop + 1\n    baseImageAspectRatio = baseImageWidth / baseImageHeight\n    magentaAspectRatio = magentaWidth / magentaHeight\n```", "```py\n if baseImageAspectRatio < magentaAspectRatio:\n        # Make the resized width match the width of the magenta area:\n        widthRatio = magentaWidth / baseImageWidth\n        resizedImage = baseImage.resize((magentaWidth, \n        int(baseImageHeight * widthRatio) + 1), Image.NEAREST)\n else:\n        # Make the resized height match the height of the magenta area:\n        heightRatio =  magentaHeight / baseImageHeight\n        resizedImage = baseImage.resize((int(baseImageWidth * \n        heightRatio) + 1, magentaHeight), Image.NEAREST)\n```", "```py\n # Replace the magenta pixels with the smaller, resized image:\n    for x in range(magentaLeft, magentaRight + 1):\n        for y in range(magentaTop, magentaBottom + 1):\n            if baseImage.getpixel((x, y)) == magentaColor:\n                pix = resizedImage.getpixel((x - magentaLeft, y - magentaTop))\n                baseImage.putpixel((x, y), pix)\n```", "```py\n # RECURSIVE CASE:\n    return makeDroste(baseImage, stopAfter - 1)\n```", "```py\nrecursiveImage = makeDroste('museum.png')\nrecursiveImage.save('museum-recursive.png')\nrecursiveImage.show()\n```"]
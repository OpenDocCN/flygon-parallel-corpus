- en: Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Projects
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File Finder
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll write your own recursive program to search for files
    according to custom needs. Your computer already has some file-searching commands
    and apps, but often they’re limited to retrieving files based on a partial filename.
    What if you need to make esoteric, highly specific searches? For example, what
    if you need to find all files that have an even number of bytes, or files with
    names that contain every vowel?
  prefs: []
  type: TYPE_NORMAL
- en: You likely will never need to do these searches specifically, but you’ll probably
    have odd search criteria someday. You’ll be out of luck if you can’t code this
    search yourself.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve learned, recursion is especially suited to problems that have a tree-like
    structure. The filesystem on your computer is like a tree, as you saw back in
    Figure 2-6. Each folder branches into subfolders, which in turn can branch into
    other subfolders. We’ll write a recursive function to navigate this tree.
  prefs: []
  type: TYPE_NORMAL
- en: The Complete File-Search Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin by taking a look at the complete source code for the recursive
    file-search program. The rest of this chapter explains each section of code individually.
    Copy the source code for the file-search program to a file named *fileFinder.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The file-search program’s main function is `walk()`, which “walks” across the
    entire span of files in a base folder and its subfolders. It calls one of two
    other functions that implement the custom search criteria it’s looking for. In
    the context of this program, we’ll call these *match functions*. A match function
    call returns `True` if the file matches the search criteria; otherwise, it returns
    `False`.
  prefs: []
  type: TYPE_NORMAL
- en: The job of the `walk()` function is to call the match function once for each
    file in the folders it walks across. Let’s take a look at the code in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Match Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, you can pass functions themselves as arguments to a function call.
    In the following example, a `callTwice()` function calls its function argument
    twice, whether it’s `sayHello()` or `sayGoodbye()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `callTwice()` function calls whichever function was passed to it as the
    `func` parameter. Notice that we leave out the parentheses from the function argument,
    writing `callTwice(sayHello)` instead of `callTwice(sayHello())`. This is because
    we are passing the `sayHello()` function itself, and not calling `sayHello()`
    and passing its return value.
  prefs: []
  type: TYPE_NORMAL
- en: The `walk()` function accepts a match function argument for its search criteria.
    This lets us customize the behavior of the file search without modifying the code
    of the `walk()` function itself. We’ll take a look at `walk()` later. First, let’s
    look at the two sample match functions in the program.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Files with an Even Number of Bytes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first matching function finds files with an even byte size:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We import the `os` module, which is used throughout the program to get information
    about the files on your computer through functions such as `getsize()`, `basename()`,
    and others. Then we create a match function named `hasEvenByteSize()`. All match
    functions take a single string argument named `fullFilePath`, and return either
    `True` or `False` to signify a match or miss.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os.path.getsize()` function determines the size of the file in `fullFilePath`
    in bytes. Then we use the `%` modulus operator to determine whether this number
    is even. If it’s even, the `return` statement returns `True`; if it’s odd, it
    returns `False`. For example, let’s consider the size of the Notepad application
    that comes with the Windows operating system (on macOS or Linux, try running this
    function on the */bin/ls* program):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `hasEvenByteSize()` match function can use any Python function to find more
    information about the `fullFilePath` file. This gives you the powerful capability
    to write code for any search criteria you want. As `walk()` calls the match function
    for each file in the folder and subfolders it walks across, the match function
    returns `True` or `False` for each one. This tells `walk()` whether the file is
    a match.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Filenames That Contain Every Vowel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at the next match function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We call `os.path.basename()` to remove the folder names from the filepath. Python
    does case-sensitive string comparisons, which ensures that `hasEveryVowel()` doesn’t
    miss any vowels in the filename because they are uppercase. For example, calling
    `os.path.basename('C:/Windows/system32/notepad.exe')` returns the string `notepad.exe`.
    This string’s `lower()` method call returns a lowercase form of the string so
    that we have to check for only lowercase vowels in it. “Useful Python Standard
    Library Functions for Working with Files” later in this chapter explores some
    more functions for finding out information about files.
  prefs: []
  type: TYPE_NORMAL
- en: We use a `return` statement with a lengthy expression that evaluates to `True`
    if `name` contains `a`, `e`, `i`, `o`, or `u`, indicating the file matches the
    search criteria. Otherwise, the `return` statement returns `False`.
  prefs: []
  type: TYPE_NORMAL
- en: The Recursive walk() Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the match functions check whether a file matches the search criteria,
    the `walk()` function finds all the files to check. The recursive `walk()` function
    is passed the name of a base folder to search along with a match function to call
    for each file in the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `walk()` function also recursively calls itself for each subfolder in the
    base folder it’s searching. These subfolders become the base folder in the recursive
    call. Let’s ask the three questions about this recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the base case? When the function has finished processing each file and
    subfolder in its given base folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What argument is passed to the recursive function call? The base folder to search
    and the match function to use for finding matched files. For each subfolder in
    this folder, a recursive call is made with the subfolder as the new folder argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does this argument become closer to the base case? Eventually, the function
    either recursively calls itself on all the subfolders or encounters base folders
    that don’t have any subfolders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Figure 10-1](#figure10-1) shows an example filesystem along with the recursive
    calls to `walk()`, which it makes with a base folder of `C:\`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphic depicting each folder in a filesystem and the corresponding calls
    to the walk() function. The base folder, C:\, corresponds to “walk(‘C:\\’, hasEvenByteSize).”
    The folder “spam” corresponds to “walk(‘C:\\spam’, hasEvenByteSize).” Within “spam,”
    the folder “eggs” corresponds to “walk(‘C:\\eggs’, hasEvenByteSize),” and the
    folder “ham” corresponds “walk(‘C:\\spam\\ham’, hasEvenByteSize).” Within “eggs,”
    the folder “bacon” corresponds to “walk(‘C\\spam\\eggs\\bacon’, hasEvenByteSize).”](image_fi/502024c10/f10001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: An example filesystem and the recursive `walk()` function calls
    over it'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the `walk()` function’s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `walk()` function has two parameters: `folder` is a string of the base
    folder to search (we can pass `''.''` to refer to the current folder the Python
    program is run from), and `matchFunc` is a Python function that is passed a filename
    and returns `True` if the function says it is a search match. Otherwise, the function
    returns `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of the function examines the contents of `folder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop calls `os.listdir()` to return a list of the contents of the
    `folder` folder. This list includes all files and subfolders. For each file, we
    create the full, absolute path by joining the folder with the name of the file
    or folder. If the name refers to a file, the `os.path.isfile()` function call
    returns `True`, and we’ll check to see if the file is a search match:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the match function, passing it the full absolute filepath of the `for`
    loop’s current file. Note that `matchFunc` is the name of one of `walk()`’s parameters.
    If `hasEvenByteSize()`, `hasEveryVowel()`, or another function is passed as the
    argument for the `matchFunc` parameter, then that is the function `walk()` calls.
    If `filepath` contains a file that is a match according to the matching algorithm,
    it’s added to the `matches` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, if the `for` loop’s file is a subfolder, the `os.path.isdir()` function
    call returns `True`. We then pass the subfolder to a recursive function call.
    The recursive call returns a list of all matching files in the subfolder (and
    its subfolders), which are then added to the `matches` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After the `for` loop finishes, the `matches` list contains all the matching
    files in this folder (and in all its subfolders). This list becomes the return
    value for the `walk()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the walk() Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve implemented the `walk()` function and some match functions,
    we can run our custom file search. We pass the `''.''` string, a special directory
    name meaning *the current directory*, for the first argument to `walk()` so that
    it uses the folder the program was run from as the base folder to search:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program depends on what files are on your computer, but
    this demonstrates how you can write code for any search criteria you have. For
    example, the output could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Useful Python Standard Library Functions for Working with Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a look at some functions that could help you as you write your own
    match functions. The standard library of modules that comes with Python features
    several useful functions for getting information about files. Many of these are
    in the `os` and `shutil` modules, so your program must run `import os` or `import
    shutil` before it can call these functions.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Information About the File’s Name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The full filepath passed to the match functions can be broken into the base
    name and directory name with the `os.path.basename()` and `os.path.dirname()`
    functions. You can also call `os.path.split()` to obtain these names as a tuple.
    Enter the following into Python’s interactive shell. On macOS or Linux, try using
    `/bin/ls` as the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can use any of Python’s string methods on these string values to help evaluate
    the file against your search criteria, such as `lower()` in the `hasEveryVowel()`
    match function.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Information About the File’s Timestamps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Files have timestamps indicating when they were created, last modified, and
    last accessed. Python’s `os.path.getctime()`, `os.path.getmtime()`, and `os.path.getatime()`,
    respectively, return these timestamps as floating-point values indicating the
    number of seconds since the *Unix epoch*, midnight on January 1, 1970, in the
    Coordinated Universal Time (UTC) time zone. Enter the following into the interactive
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'These float values are easy for programs to use since they’re just single numbers,
    but you’ll need functions from Python’s `time` module to make them simpler for
    humans to read. The `time.localtime()` function converts a Unix epoch timestamp
    into a `struct_time` object in the computer’s time zone. A `struct_time` object
    has several attributes whose names begin with `tm_` for obtaining date and time
    information. Enter the following into the interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `tm_mday` attribute is the day of the month, ranging from `1`
    to `31`. The `tm_wday` attribute is the day of the week, starting at `0` for Monday,
    `1` for Tuesday, and so on, up to `6` for Sunday.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a brief, human-readable string of the `time_struct` object, pass
    it to the `time.asctime()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `time.localtime()` function returns a `struct_time` object in the
    local time zone, the `time.gmtime()` function returns a `struct_time` object in
    the UTC or Greenwich Mean time zone. Enter the following into the interactive
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The interaction between these `os.path` functions (which return Unix epoch timestamps)
    and `time` functions (which return `struct_time` objects) can be confusing. [Figure
    10-2](#figure10-2) shows the chain of code starting from the filename string and
    ending with obtaining the individual parts of the timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flowchart. Arrow points from “filename” to “os.path.getctime(), os.path.getmtime(),
    os.path.getatime()” to “time.localtime(), time.gmtime()” to “time.asctime(), .tm_year,
    .tm_mon, .tm_mday, .tm_wday, .tm_hour, .tm_min, .tm_sec.”](image_fi/502024c10/f10002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-2: Going from the filename to the individual attributes of a timestamp'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `time.time()` function returns the number of seconds since the
    Unix epoch to the current time.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Your Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the `walk()` function returns a list of files matching your search criteria,
    you may want to rename, delete, or perform another operation on them. The `shutil`
    and `os` modules in the Python standard library have functions to do this. Further,
    the `send2trash` third-party module can also send files to your operating system’s
    Recycle Bin, rather than permanently deleting them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To move a file, call the `shutil.move()` function with two arguments. The first
    argument is the file to move, and the second is the folder to move it to. For
    example, you could call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shutil.move()` function returns the string of the new filepath of the
    file. You can also specify a filename to move and rename the file at the same
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the second argument lacks a folder, you can just specify a new name for
    the file to rename it in its current folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `shutil.move()` function both moves and renames files, similar
    to the way the Unix and macOS `mv` command both moves and renames files. There
    is no separate `shutil.rename()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy a file, call the `shutil.copy()` function with two arguments. The first
    argument is the filename of the file to copy, and the second argument is the new
    name of the copy. For example, you could call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shutil.copy()` function returns the name of the copy. To delete a file,
    call the `os.unlink()` function and pass it the name of the file to delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The name *unlink* is used instead of *delete* because of the technical detail
    that it removes the filename linked to the file. But since most files have only
    one linked filename, this unlinking also deletes the file. It’s all right if you
    don’t understand these filesystem concepts; just know that `os.unlink()` deletes
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: Calling `os.unlink()` permanently deletes the file, which can be dangerous if
    a bug in your program causes the function to delete the wrong file. Instead, you
    can use the `send2trash` module’s `send2trash()` function to put the file in your
    operating system’s Recycle Bin. To install this module, run `run python -m pip
    install --user send2trash` from the command prompt on Windows or run `run python3
    -m pip install` from the terminal on macOS or Linux. Once the module is installed,
    you’ll be able to import it with `import send2trash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following into the interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This example creates a blank file named *deleteme.txt*. After calling `send2trash.send2trash()`
    (the module and function share the same name), this file is removed to the Recycle
    Bin.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter’s file-search project uses recursion to “walk” across the contents
    of a folder and all its subfolders. The file-finder program’s `walk()` function
    navigates these folders recursively, applying custom search criteria to every
    file in every subfolder. The search criteria are implemented as match functions,
    which are passed to the `walk()` function. This allows us to change the search
    criteria by writing new functions instead of modifying the code in `walk()`.
  prefs: []
  type: TYPE_NORMAL
- en: Our project had two match functions, for finding files with an even byte file
    size or containing every vowel in its name, but you can write your own functions
    to pass to `walk()`. This is the power behind programming; you can create features
    for your own needs that are not available in commercial apps.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The documentation for Python’s built-in `os.walk()` function (similar to the
    `walk()` function in the file-finder project) is at [https://docs.python.org/3/library/os.html#os.walk](https://docs.python.org/3/library/os.html#os.walk).
    You can also learn more about your computer’s filesystem and Python’s file functions
    in Chapter 9 of my book *Automate the Boring Stuff with Python*, 2nd edition (No
    Starch Press, 2019) at [https://automatetheboringstuff.com/2e/chapter9](https://automatetheboringstuff.com/2e/chapter9).
  prefs: []
  type: TYPE_NORMAL
- en: The `datetime` module in the Python standard library also has more ways to interact
    with timestamp data. You can learn more about it in Chapter 17 of *Automate the
    Boring Stuff with Python*, 2nd edition at [https://automatetheboringstuff.com/2e/chapter17](https://automatetheboringstuff.com/2e/chapter17).
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maze Generator
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 described a recursive algorithm that solves mazes, but another recursive
    algorithm generates mazes. In this chapter, we’ll generate mazes in the same format
    as the maze-solver program in Chapter 4. So, whether you’re a fan of solving mazes
    or creating them, you’ll now have the power to apply programming to the task.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm works by visiting a starting space in the maze and then recursively
    visiting a neighboring space. The maze’s hallways are “carved out” of the maze
    as the algorithm continues to visit neighbors. If the algorithm reaches a dead
    end that has no neighboring spaces, it backtracks to earlier spaces until it finds
    an unvisited neighbor and continues visiting from there. By the time the algorithm
    backtracks to the starting space, the entire maze has been generated.
  prefs: []
  type: TYPE_NORMAL
- en: The recursive backtracking algorithm we’ll use here produces mazes that tend
    to have long hallways (the maze spaces that connect branching intersections) and
    are fairly simple to solve. However, this algorithm is easier to implement than
    many other maze-generation algorithms, such as Kruskal’s algorithm or Wilson’s
    algorithm, so it serves as a good introduction to the topic.
  prefs: []
  type: TYPE_NORMAL
- en: The Complete Maze-Generator Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin by taking a look at the complete Python and JavaScript source code
    for the program, which uses the recursive backtracking algorithm for maze generation.
    The rest of this chapter explains each section of code individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy this Python code to a file named *mazeGenerator.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy this JavaScript code to a file named *mazeGenerator.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When you run this program, it produces a large amount of text that will fill
    the terminal window or browser with each step of the maze’s construction. You’ll
    have to scroll back up to the top to view the entire output.
  prefs: []
  type: TYPE_NORMAL
- en: The maze data structure begins as a completely filled-in 2D space. The recursive
    backtracker algorithm is given a starting point in this maze and then visits a
    previously unvisited neighboring space, “carving out” any hallway space in the
    process. Then it recursively calls itself on a neighboring space it hasn’t visited
    before. If all the neighboring spaces have already been visited, the algorithm
    is at a dead end and backtracks to an earlier visited space to visit its unvisited
    neighbors. The program ends when the algorithm backtracks to its starting location.
  prefs: []
  type: TYPE_NORMAL
- en: You can see this algorithm in action by running the maze-generator program.
    As the maze is carved out, it displays the current x, y coordinates by using the
    `@` character. The process looks like [Figure 11-1](#figure11-1). Notice that
    the fifth image in the top-right corner has backtracked to an earlier space after
    reaching a dead end to explore a new neighboring direction from that space.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing a maze being created one line at a time. The line backtracks
    every time it encounters a dead end. It eventually fills the entire screen.](image_fi/502024c11/f11001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: The maze as it gets “carved out” by the recursive backtracking
    algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the code in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Maze Generator’s Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The maze generator uses several constants, which we can change before running
    the program to alter the size and appearance of the maze. The Python code for
    these constants is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The constants `WIDTH` and `HEIGHT` dictate the size of the maze. They must be
    odd numbers, because our maze data structure requires walls between the visited
    spaces of the maze, leaving us with odd-numbered dimensions. To make sure the
    `WIDTH` and `HEIGHT` constants are set correctly, we use assertions to stop the
    program if the constants aren’t odd or are too small.
  prefs: []
  type: TYPE_NORMAL
- en: The program relies on a random seed value to reproduce the same maze, given
    the same seed value. The Python version of this program lets us set this value
    by calling the `random.seed()` function. Unfortunately, JavaScript doesn’t have
    a way to set the seed value explicitly and will generate different mazes each
    time we run the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code continues by setting a few more constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code for these constants is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `EMPTY` and `WALL` constants affect how the maze is displayed on the screen.
    The `MARK` constant is used to point out the position of the algorithm in the
    maze as it runs. The `NORTH`, `SOUTH`, `EAST`, and `WEST` constants represent
    the directions that the mark can move through the maze and are used to make the
    code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Maze Data Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The maze data structure is a Python dictionary or JavaScript object that has
    keys of Python tuples or JavaScript arrays of the x, y coordinates of every space
    in the maze. The value for these keys is a string in the `WALL` or `EMPTY` constant.
    This string notes whether this space is a blocking wall or a passable empty space
    in the maze.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the maze in [Figure 11-2](#figure11-2) is represented by the following
    data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![Diagram of a grid whose x- and y-axes are numbered 0 through 6, assigning
    each cell in the grid a numerical x and y value.](image_fi/502024c11/f11002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: An example maze that can be represented by a data structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program must start with every space set to `WALL`. The recursive `visit()`
    function then carves out the hallways and intersections of the maze by setting
    spaces to `EMPTY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding JavaScript code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We create the blank dictionary (in Python) or object (in JavaScript) in the
    `maze` global variable. The `for` loops loop over every possible x, y coordinate,
    setting each to `WALL` to create a completely filled-in maze. The call to `visit()`
    will carve out the hallways of the maze from this data structure by setting the
    spaces in it to `EMPTY`.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the Maze Data Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To represent the maze as a data structure, the Python program uses a dictionary,
    and the JavaScript program uses an object. Within this structure, the keys are
    lists or arrays of two integers for the x- and y-coordinates, while the value
    is either the `WALL` or `EMPTY` single-character strings. Thus, we can access
    the wall or empty hallway space at the coordinates x, y in the maze as `maze[(x,
    y)]` in Python code and as `maze[[x, y]]` in JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for `printMaze()` starts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code for `printMaze()` starts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `printMaze()` function prints the maze data structure it’s passed as the
    maze parameter on the screen. Optionally, if `markX` and `markY` integer arguments
    are passed, the `MARK` constant (which we set to `@`) appears at these x, y coordinates
    in the printed maze. To make sure the maze is printed in a monospace font, the
    JavaScript version writes the HTML tag `<code>` before printing the maze itself.
    Without this HTML tag, the maze will appear distorted in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Within the function, nested `for` loops loop over every space in the maze data
    structure. These `for` loops iterate over each y-coordinate from `0` up to, but
    not including, `HEIGHT`, and each x-coordinate from `0` up to, but not including,
    `WIDTH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the inner `for` loop, if the current x, y coordinates match the position
    of the mark (the location where the algorithm is currently carving), the program
    displays the `@` in the `MARK` constant. The Python code does this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, the program displays either the `WALL` or `EMPTY` constant’s character
    at this x, y coordinate in the `maze` data structure by printing `maze[(x, y)]`
    in Python and `maze[[x, y]]` in JavaScript. After the inner `for` loop is done
    looping over the x-coordinates, we print a newline at the end of the row in preparation
    for the next row.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Recursive Backtracker Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `visit()` function implements the recursive backtracker algorithm. The
    function has a list (in Python) or array (in JavaScript) that keeps track of the
    x, y coordinates that have already been visited by previous `visit()` function
    calls. It also in-place modifies the global `maze` variable that stores the maze
    data structure. The Python code for `visit()` begins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code for `visit()` begins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `visit()` function accepts x, y coordinates as arguments for the place in
    the maze the algorithm is visiting. Then the function changes the data structure
    in `maze` at this location to an empty space. To let the user see the progression
    of the maze generation, it calls `printMaze()`, passing the `x` and `y` arguments
    as the current position of the mark.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the recursive backtracker calls `visit()` with the coordinates of a previously
    unvisited neighboring space. The Python code continues as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code continues as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop continues to loop as long as unvisited neighbors remain for
    this location in the maze. We create a list or array of unvisited neighboring
    spaces in the `unvisitedNeighbors` variables. Four `if` statements check that
    the current x, y position is not on the border of the maze (so that we still have
    a neighboring space to check) and whether the neighboring space’s x, y coordinates
    don’t appear in the `hasVisited` list or array already.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all the neighbors have been visited, the function returns so that it can
    backtrack to an earlier space. The Python code continues on to check for the base
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code does so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The base case for the recursive backtracking algorithm occurs when no unvisited
    neighbors remain to visit next. In this case, the function simply returns. The
    `visit()` function itself has no return value. Rather, the recursive function
    calls `visit()` to modify the maze data structure in the global `maze` variable
    as a side effect. When the original function call to `maze()` returns, the `maze`
    global variable contains the completely generated maze.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code continues on to the recursive case like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code continues as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `unvisitedNeighbors` list or array contains one or more of the `NORTH`,
    `SOUTH`, `WEST`, and `EAST` constants. We choose one of these directions for the
    next recursive call to `visit()`, and then set the `nextX` and `nextY` variables
    with the coordinates of the neighboring space in this direction.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we add the x, y coordinates of `nextX` and `nextY` to the `hasVisited`
    list or array before making the recursive call for this neighboring space. In
    this way, the `visit()` function continues to visit neighboring spaces, carving
    out the maze hallways by setting locations in `maze` to `EMPTY`. The connecting
    hallway between the current space and neighboring space is also set to `EMPTY`.
  prefs: []
  type: TYPE_NORMAL
- en: When no neighbors exist, the base case simply returns to an earlier location.
    In the `visit()` function, the execution jumps back to the start of the `while`
    loop. The code in the `while` loop again checks which neighboring spaces haven’t
    been visited and makes a recursive `visit()` call on one of them, or returns if
    all neighboring spaces have already been visited.
  prefs: []
  type: TYPE_NORMAL
- en: As the maze fills up with hallways and each space has been visited, the recursive
    calls will continue to return until the original `visit()` function call returns.
    At this point, the maze variable contains the completely generated maze.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Chain of Recursive Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The recursive `visit()` uses two global variables, `maze` and `hasVisited`.
    The `hasVisited` variable is a list or array containing the x, y coordinates of
    every space the algorithm has visited and begins with `(1, 1)` since that is the
    maze starting point. The Python code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: After setting up `hasVisited` to include the x, y coordinates of 1, 1 (the top-left
    corner of the maze), we call `visit()` with these coordinates. This function call
    will result in all the recursive function calls that generate the hallways of
    the maze. By the time this function call returns, `hasVisited` will contain every
    x, y coordinate of the maze, and `maze` will contain the completely generated
    maze.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you just learned, we can use recursion to not only solve mazes (by traversing
    them as tree data structures) but also generate them using the recursive backtracker
    algorithm. The algorithm “carves out” hallways in the maze, backtracking to earlier
    points when it encounters a dead end. Once the algorithm is forced to backtrack
    to the starting point, the maze is completely generated.
  prefs: []
  type: TYPE_NORMAL
- en: We can represent a well-connected maze with no loops as a DAG—that is, a tree
    data structure. The recursive backtracker algorithm makes use of the idea that
    recursive algorithms are well suited to problems involving tree-like data structures
    and backtracking.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wikipedia has an entry on maze generation in general, with a section on the
    recursive backtracker algorithm, at [https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker](https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker).
    I’ve created a browser-based animation of the recursive backtracker algorithm
    that shows the “carving” of hallways in action at [https://scratch.mit.edu/projects/17358777](https://scratch.mit.edu/projects/17358777).
  prefs: []
  type: TYPE_NORMAL
- en: 'If maze generation interests you, you should read *Mazes for Programmers: Code
    Your Own Twisty Little Passages* by Jamis Buck (Pragmatic Bookshelf, 2015).'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sliding-Tile Solver
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: A *sliding-tile puzzle*, or *15-puzzle*, is a small puzzle game implemented
    as a set of 15 numbered sliding tiles on a 4 × 4 board. One tile is missing, allowing
    adjacent tiles to slide into the empty space on the board. The player’s goal is
    to move the tiles into numeric order, as in [Figure 12-1](#figure12-1). Some versions
    of this game have fragments of a picture on the tiles that create a whole image
    when the puzzle is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image of two 4 × 4 grids of numbered tiles with one missing tile each. The
    first grid’s numbers are out of order. The second grid’s numbers are ordered 1–15
    from left to right.](image_fi/502024c12/f12001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: Solving a numeric sliding-tile puzzle from its scrambled state
    (left) to its solved, ordered state (right)'
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, mathematicians have proven that even the hardest 15-puzzle can
    be solved in 80 moves.
  prefs: []
  type: TYPE_NORMAL
- en: Solving 15-Puzzles Recursively
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The algorithm that solves 15-puzzles is similar to the maze-solving algorithm.
    Each state of the board (that is, one arrangement of tiles) can be thought of
    as a maze intersection with four hallways to go down. In the case of 15-puzzles,
    sliding a tile in one of the four directions is like picking a hallway to follow
    to the next intersection.
  prefs: []
  type: TYPE_NORMAL
- en: Just as you can turn a maze into a DAG, you can convert a 15-puzzle into a tree
    graph, as in [Figure 12-2](#figure12-2). The board states are nodes with up to
    four edges (representing a direction to slide a tile) to other nodes (representing
    the resultant state). The root node is the starting state of the 15-puzzle. The
    solved-state node is the one in which the tiles are ordered correctly. The path
    from the root node to the solved state details the slides needed to solve the
    puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree graph in which each node is a 4 × 4 tile puzzle. The top node has two
    child nodes representing the two possible moves a player could make from that
    position, and each of those nodes has two child nodes representing all possible
    moves a player could make from those positions.](image_fi/502024c12/f12002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: The task of solving a 15-puzzle can be represented as a graph
    with tile states as nodes and slides as edges.'
  prefs: []
  type: TYPE_NORMAL
- en: Clever algorithms are available for solving 15-puzzles, but we could also just
    recursively explore the entire tree graph until we find a path from the root node
    to the solution node. This puzzle’s tree can be searched with a depth-first search
    (DFS) algorithm. However, unlike a well-connected maze, the 15-puzzle’s tree graph
    is not a DAG. Rather, the graph’s nodes are *undirected*, because you can traverse
    both directions of an edge by undoing the previous slide you made.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-3](#figure12-3) shows an example of the undirected edges between
    two nodes. Because it is possible to go back and forth between these two nodes
    forever, our 15-puzzle algorithm could encounter a stack overflow before it finds
    a solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two tile puzzles. The tiles are positioned identically save for one, which
    has been slid downward in the second puzzle.](image_fi/502024c12/f12003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3: The 15-puzzle has undirected edges (drawn without an arrowhead)
    between its nodes because slides can be undone by performing the opposite slide.'
  prefs: []
  type: TYPE_NORMAL
- en: To optimize our algorithm, we’ll avoid slides that undo the previous slide.
    However, this optimization alone won’t save the algorithm from a stack overflow.
    While it makes the *edges* in the tree graph directed, it doesn’t turn the puzzle-solver
    algorithm into a DAG, because it has cycles, or loops, from lower nodes to higher
    ones. These loops happen if you slide the tiles in a circular pattern, as in [Figure
    12-4](#figure12-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Twelve tile puzzles connected by arrows that travel in a complete loop. In
    each subsequent puzzle, one tile is slid out of place until the state of the puzzle
    is the same as the starting puzzle’s state.](image_fi/502024c12/f12004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-4: An example of a loop in the 15-puzzle’s graph'
  prefs: []
  type: TYPE_NORMAL
- en: Cycles in the graph mean that the later nodes at the bottom could loop back
    to a node at the top. Our solving algorithm could get “stuck” following this loop
    and never explore the branch that has the actual solution. In practice, this infinite
    loop would result in a stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: We can still use recursion to solve a 15-puzzle. We just need to add our own
    base case for the maximum number of moves in order to avoid causing a stack overflow.
    Then, when the maximum number of slide moves is reached, the algorithm will begin
    backtracking to earlier nodes. If the 15-puzzle solver project can’t find a solution
    in every possible combination of 10 slides, it will try again using a maximum
    of 11 slides. If the puzzle can’t be solved in 11 moves, the project tries 12
    moves, and so on. This prevents the algorithm from getting stuck exploring the
    moves of an infinite loop instead of exploring possible solutions of fewer moves.
  prefs: []
  type: TYPE_NORMAL
- en: The Complete Sliding-Tile Solver Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin by taking a look at the complete source code for the sliding-tile
    puzzle solver program. The rest of this chapter explains each section of code
    individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the Python version of the code to a file named *slidingTileSolver.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the JavaScript version of the code to a file named *slidingTileSolver.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The program’s output looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that when JavaScript runs in a browser, the code must complete before it
    displays any output. Until then, it may appear to have frozen, and your browser
    might ask if you’d like to prematurely stop it. You can ignore this warning and
    let the program keep working until it has solved the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: The program’s recursive `attemptMove()` function solves sliding-tile puzzles
    by trying every possible combination of slides. The function is given a move to
    try. If this solves the puzzle, the function returns a Boolean `True` value. Otherwise,
    it calls `attemptMove()` with all the other possible moves it can make and returns
    a Boolean `False` value if none of them find a solution before exceeding the maximum
    number of moves. We’ll explore this function in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: The data structure we use to represent a sliding-tile board is a list (in Python)
    or array (in JavaScript) of integers, with `0` representing the blank space. In
    our program, this data structure is often stored in a variable named `board`.
    The values at `board[y * SIZE + x]` match the tile at the x, y coordinates on
    the board, as depicted in [Figure 12-5](#figure12-5). For example, if the `SIZE`
    constant is `4`, the value at the x, y coordinates 3, 1 can be found at `board[1
    * 4 + 3]`.
  prefs: []
  type: TYPE_NORMAL
- en: This small calculation enables us to use a 1D array or list to store the values
    of a 2D tile board. This programming technique is useful not just in our project
    but for any 2D data structure that must be stored in an array or list, such as
    a 2D image stored as a stream of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Two sliding-tile puzzles. In the first, each tile and the blank space are
    represented by their x, y coordinates. In the second, the tiles and blank space
    are numbered from 0 to 15\. The coordinates correspond to the following numbered
    tiles: 0,0 corresponds to 0; 1,0 corresponds to 1; 2,0 corresponds to 2; 3,0 corresponds
    to 3; 0,1 corresponds to 4; 1,1 corresponds to 5; 2,1 corresponds to 6; 3,1 corresponds
    to 7; 0,2 corresponds to 8; 1,2 corresponds to 9; 2,2 corresponds to 10; 3,2 corresponds
    to 11; 0,3 corresponds to 12; 1,3 corresponds to 13; 2,3 corresponds to 14; 3,3
    (the blank space) corresponds to 15.](image_fi/502024c12/f12005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-5: The x, y coordinates for each space on the board (left) and the
    corresponding data structure index (right)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some example data structures. The board with mixed-up tiles shown
    previously on the left side of [Figure 12-1](#figure12-1) would be represented
    by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[15, 2, 1, 12, 8, 5, 6, 11, 4, 9, 10, 7, 3, 14, 13, 0]`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The solved, ordered puzzle on the right side of [Figure 12-1](#figure12-1)
    would be represented by this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the functions in our program will expect board data structures that follow
    this format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the 4 × 4 version of the sliding-tile puzzle has so many possible
    moves that it would take a normal laptop weeks to solve. You can change the `SIZE`
    constant from `4` to `3` to solve a simpler 3 × 3 version of the puzzle. The finished,
    ordered 3 × 3 puzzle’s data structure would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[1, 2, 3, 4, 5, 6, 7, 8, 0]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting Up the Program’s Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the beginning of the source code, the program uses a few constants to make
    the code more readable. The Python code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: To have reproducible random numbers, the Python program sets the random number
    seed to `1`. The same seed value will always reproduce the same random puzzle,
    which is useful for debugging. You can change the seed value to any other integer
    to create different puzzles. JavaScript has no way to set its random seed value,
    and *slidingtilesolver.html* doesn’t have an equivalent feature.
  prefs: []
  type: TYPE_NORMAL
- en: The `SIZE` constant sets the size of the square board. You can change this size
    to anything, but 4 × 4 boards are standard, while 3 × 3 boards are useful for
    testing, because the program is quick to solve them. The `BLANK` constant is used
    in the puzzle data structure to represent the blank space and must be kept at
    `0`. The `UP`, `DOWN`, `LEFT`, and `RIGHT` constants are used to make the code
    readable, similar to the `NORTH`, `SOUTH`, `WEST`, and `EAST` constants in the
    maze-generator project in Chapter 11.
  prefs: []
  type: TYPE_NORMAL
- en: Representing the Sliding-Tile Puzzle as Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sliding-tile board’s data structure is just a list or array of integers.
    What makes it representative of an actual puzzle board is the way it’s used by
    the functions in the program. The `displayBoard()`, `getNewBoard()`, `findBlankSpace()`,
    and other functions in this program all deal with this data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Board
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first function, `displayBoard()`, prints the board data structure on the
    screen. The Python code for the `displayBoard()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code for the `displayBoard()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The pair of nested `for` loops iterate over every row and column on the board.
    The first `for` loop loops over the y-coordinates, and the second `for` loop loops
    over the x-coordinates. This is because the program needs to print all the columns
    of a single row before printing a newline character to move on to the next row.
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement checks whether the tile at the current x, y coordinates is
    the blank tile. If it is, the program prints two underscores with a trailing space.
    Otherwise, the code in the `else` block prints the tile number with a trailing
    space. The trailing space is what separates the tile numbers from one another
    on the screen. If the tile number is a single digit, the `rjust()` or `padStart()`
    method will insert an extra space so that the tile number is aligned with the
    two-digit numbers on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say the scrambled puzzle on the left side of [Figure 12-1](#figure12-1)
    is represented by this data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[15, 2, 1, 12, 8, 5, 6, 11, 4, 9, 10, 7, 3, 14, 13, 0]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the data structure is passed to `displayBoard()`, it prints the following
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Creating a New Board Data Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, the `getNewBoard()` function returns a new board data structure with
    the tiles in their ordered, solved places. The Python code for the `getNewBoard()`
    function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code for the `getNewBoard()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `getNewBoard()` function returns a board data structure appropriate to the
    integer in the `SIZE` constant (either 3 × 3 or 4 × 4). The `for` loop generates
    this list or array with the integers from `1` up to, but not including, `SIZE`
    squared, with a `0` (the value stored in the `BLANK` constant) at the end to represent
    the blank space in the lower-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Coordinates of the Blank Space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our program uses the `findBlankSpace()` function to find the x, y coordinates
    of the blank space on the board. The Python code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Like the `displayBoard()` function, the `findBlankSpace()` function has a pair
    of nested `for` loops. These `for` loops will loop over every position in the
    board data structure. When the `board[y * SIZE + x]` code finds the blank space,
    it returns the x- and y-coordinates as two integers in a Python list or JavaScript
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Making a Move
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, the `makeMove()` function accepts two arguments: a board data structure
    and an `UP`, `DOWN`, `LEFT`, or `RIGHT` direction to slide a tile on that board.
    This code is fairly repetitive, so the short variable names `bx` and `by` are
    used to represent the x- and y-coordinates of the blank space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a move, the board data structure swaps the value of the moved tile
    with the `0` of the blank tile. The Python code for the `makeMove()` function
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code for the `makeMove()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statements determine the index of the tile to move based on the `move`
    parameter. The function then “slides” a tile by swapping the `BLANK` value at
    `board[blankindex]` with the numbered tile at `board[tileIndex]`. The `makeMove()`
    function doesn’t return anything. Instead, it modifies the `board` data structure
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: Python has the `a, b = b, a` syntax to swap the value of two variables. For
    JavaScript, we need to envelop them in an array, such as `[a, b] = [b, a]` to
    perform the swap. We use this syntax at the end of the function to swap the values
    in `board[blankIndex]` and `board[tileIndex]` with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Undoing a Move
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, as part of the backtracking in the recursive algorithm, our program needs
    to undo moves. This is as simple as making a move in the opposite direction as
    the initial move. The Python code for the `undoMove()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code for the `undoMove()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We’ve already programmed the swapping logic into the `makeMove()` function,
    so `undoMove()` can just call that function for the direction opposite of the
    `move` argument. This way, a hypothetical `someMove` move made on a hypothetical
    `someBoard` data structure by the `makeMove(someBoard, someMove)` function call
    can be undone by calling `undoMove(someBoard, someMove)`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a New Puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a new, scrambled puzzle, we cannot simply put the tiles in random
    places, because some configurations of tiles produce invalid, unsolvable puzzles.
    Instead, we need to start from a solved puzzle and make many random moves. Solving
    the puzzle becomes a matter of figuring out which slides will undo these random
    slides to get back to the original, ordered configuration.
  prefs: []
  type: TYPE_NORMAL
- en: But it’s not always possible to make moves in each of the four directions. For
    example, if the blank space is in the bottom-right corner, as in [Figure 12-6](#figure12-6),
    tiles can slide only down or right because no tiles can slide left or up. Furthermore,
    if sliding the 7 tile in [Figure 12-6](#figure12-6) up was the previous move,
    then sliding it down is removed as a valid move because it would undo the previous
    move.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sliding-tile puzzle with a blank space in the lower-right corner. Arrows
    indicate the two possible moves: sliding the 7 tile down, and sliding the 13 tile
    to the right.](image_fi/502024c12/f12006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-6: If the blank space is in the bottom-right corner, down and right
    are the only valid slide directions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us, we need a `getValidMoves()` function that can tell us which slide
    directions are possible on a given board data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code for this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the `getValidMoves()` function does is call `findBlankSpace()`
    and store the x, y coordinates of the blank space in the variables `blankx` and
    `blanky`. Next, the function sets up the `validMoves` variable with an empty Python
    list or empty JavaScript array to hold all the valid directions for a slide.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at [Figure 12-5](#figure12-5), a y-coordinate of `0` represents
    the top edge of the board. If `blanky`, the blank space’s y-coordinate, is not
    `0`, then we know the blank space is not on the top edge. If the previous move
    was also not `DOWN`, then *up* is a valid move, and the code adds `UP` to `validMoves`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the left edge has an x-coordinate of `0`, the bottom edge has a y-coordinate
    of `SIZE - 1`, and the right edge has an x-coordinate of `SIZE - 1`. Using the
    expression `SIZE - 1` ensures that this code works no matter whether the board
    is 3 × 3, 4 × 4, or any other size. The `getValidMoves()` function does these
    checks for all four directions and then returns `validMoves`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `getNewPuzzle()` function returns the data structure of a scrambled
    board for the program to solve. Tiles can’t simply be randomly placed on the board,
    because some configurations of tiles produce puzzles that are impossible to solve.
    To avoid this, the `getNewPuzzle()` function starts with an ordered, solved board
    and then applies a large number of random slides to it. Solving this puzzle is,
    in effect, figuring out the moves that undo these slides. The Python code for
    the `getNewPuzzle()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The call to `getNewBoard()` obtains a board data structure in the ordered, solved
    state. The `for` loop calls `getValidMoves()` to obtain a list of valid moves,
    given the current state of the board, and then calls `makeMove()` with a randomly
    selected move from the list. The `random.choice()` function in Python and the
    `Math.floor()` and `Math.random()` functions in JavaScript will handle the random
    selection from the `validMoves` list or array, no matter what combination of `UP`,
    `DOWN`, `LEFT`, and `RIGHT` values it contains.
  prefs: []
  type: TYPE_NORMAL
- en: The `DIFFICULTY` constant determines how many random slides from `makeMove()`
    the `for` loop applies. The higher the integer in `DIFFICULTY`, the more scrambled
    the puzzle becomes. Even though this results in some moves that undo earlier moves
    by pure chance, such as sliding left and then immediately sliding right, with
    enough slides the function produces a thoroughly scrambled board. For testing
    purposes, `DIFFICULTY` is set to `40`, allowing the program to produce a solution
    in about a minute. For a more realistic 15-puzzle, you should change `DIFFICULTY`
    to `200`.
  prefs: []
  type: TYPE_NORMAL
- en: After the board data structure in `board` is created and scrambled, the `getNewPuzzle()`
    function returns it.
  prefs: []
  type: TYPE_NORMAL
- en: Recursively Solving the Sliding-Tile Puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the functions for creating and manipulating the puzzle data
    structure, let’s create the functions that solve the puzzle by recursively sliding
    the tiles in each possible direction and checking whether this produces a finished,
    ordered board.
  prefs: []
  type: TYPE_NORMAL
- en: The `attemptMove()` function performs a single slide on a board data structure,
    then recursively calls itself once for each of the valid moves the board can make.
    Multiple base cases exist. If the board data structure is in a solved state, the
    function returns a Boolean `True` value; if the maximum number of moves has been
    reached, it returns a Boolean `False` value. Also, if a recursive call has returned
    `True`, then `attemptMove()` should return `True`, and if recursive calls for
    all the valid moves have returned `False`, then `attemptMove()` should return
    `False`.
  prefs: []
  type: TYPE_NORMAL
- en: The solve() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `solve()` function takes a board data structure and maximum number of moves
    the algorithm should attempt before backtracking. Then it performs the first call
    to `attemptMove()`. If this first call to `attemptMove()` returns `True`, the
    code in `solve()` displays the series of steps that solves the puzzle. If it returns
    `False`, the code in `solve()` tells the user no solution was found with this
    maximum number of moves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for `solve()` begins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code for `solve()` begins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `solve()` function has two parameters: `board` contains the data structure
    of the puzzle to solve, and `maxMoves` is the maximum number of moves the function
    should make to try to solve the puzzle. The `solutionMoves` list or array contains
    the sequence of `UP`, `DOWN`, `LEFT`, and `RIGHT` values that produce the solved
    state. The `attemptMove()` function modifies this list or array in place as it
    makes recursive calls. If the initial `attemptMove()` function finds a solution
    and returns `True`, `solutionMoves` contains the sequence of moves for the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `solve()` function then makes the initial call to `attemptMove()`, and
    stores the `True` or `False` it returns in the solved variable. The rest of the
    `solve()` function handles these two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If `attemptMove()` finds a solution, the program runs through all the moves
    gathered in the `solutionMoves` list or array and displays the board after each
    slide. This proves to the user that the moves collected by `attemptMove()` are
    the real solution to the puzzle. Finally, the `solve()` function itself returns
    `True`. If `attemptMove()` is unable to find a solution, the `solve()` function
    simply returns `False`.
  prefs: []
  type: TYPE_NORMAL
- en: The attemptMove() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a look at `attemptMove()`, the core recursive function behind our
    tile-solving algorithm. Remember the tree graph that a sliding-tile puzzle produces;
    calling `attemptMove()` for a certain direction is like traveling down that edge
    of this graph to the next node. A recursive `attemptMove()` call moves further
    down the tree. When this recursive `attemptMove()` call returns, it backtracks
    to a previous node. When `attemptMove()` has backtracked all the way to the root
    node, the program execution has returned to the `solve()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for `attemptMove()` begins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code for `attemptMove()` begins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `attemptMove()` function has four parameters. The `board` parameter contains
    a tile puzzle board data structure to solve. The `movesMade` parameter contains
    a list or array that `attemptMove()` modifies in place, adding the `UP`, `DOWN`,
    `LEFT`, and `RIGHT` values that the recursive algorithm has made. If `attemptMove()`
    solves the puzzle, `movesMade` will contain the moves that led to the solution.
    This list or array is also what the `solutionMoves` variable in the `solve()`
    function refers to.
  prefs: []
  type: TYPE_NORMAL
- en: The `solve()` function uses its `maxMoves` variable as the `movesRemaining`
    parameter in the initial call to `attemptMove()`. Each recursive call passes `maxMoves
    - 1` for the next value of `maxMoves`, causing it to decrease as more recursive
    calls are made. When it becomes less than `0`, the `attemptMove()` function stops
    making additional recursive calls and returns `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `prevMove` parameter contains the `UP`, `DOWN`, `LEFT`, or `RIGHT`
    value that the previous call to `attemptMove()` made so that it doesn’t undo that
    move. For the initial call to `attemptMove()`, the `solve()` function passes Python’s
    `None` or JavaScript’s `null` value for this parameter, since no previous move
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: The beginning of the `attemptMove()` code checks for two base cases, returning
    `False` if `movesRemaining` has become less than `0`, and returning `True` if
    `board` is in the solved state. The `SOLVED_BOARD` constant contains a board in
    the solved state that we can compare to the data structure in `board`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of `attemptMove()` performs each of the valid moves it can do
    on this board. The Python code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop sets the move variable to each of the directions returned by
    `getValidMoves()`. For each move, we call `makeMove()` to modify the board data
    structure with the move and to add the move to the list or array in `movesMade`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code recursively calls `attemptMove()` to explore the range of all
    possible future moves within the depth set by `movesRemaining`. The board and
    `movesMade` variables are forwarded to this recursive call. The code sets the
    recursive call’s `movesRemaining` parameter to `movesRemaining - 1` so that it
    decreases by one. It also sets the `prevMode` parameter to `move` so that it doesn’t
    immediately undo the move just made.
  prefs: []
  type: TYPE_NORMAL
- en: If the recursive call returns `True`, a solution exists and is recorded in the
    `movesMade` list or array. We call the `undoMove()` function so that `board` will
    contain the original puzzle after the execution returns to `solve()` and then
    return `True` to indicate a solution has been found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for `attemptMove()` continues as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: If `attemptMove()` returns `False`, no solution is found. In that case, we call
    `undoMove()` and remove the latest move from the `movesMade` list or array.
  prefs: []
  type: TYPE_NORMAL
- en: All of this is done for each of the valid directions. If none of the calls to
    `attemptMove()` for these directions finds a solution before reaching the maximum
    number of moves, the `attemptMove()` function returns `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Solver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `solve()` function is useful for kicking off the initial call to `attemptMove()`,
    but the program still needs to do some setup. The Python code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code for this setup is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: First, the `SOLVED_BOARD` constant is set to an ordered, solved board as returned
    by `getNewBoard()`. This constant isn’t set at the top of the source code because
    the `getNewBoard()` function needs to be defined before it can be called.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a random puzzle is returned from `getNewPuzzle()` and stored in the `puzzleBoard`
    variable. This variable contains the puzzle board data structure that will be
    solved. If you want to solve a specific 15-puzzle instead of a random one, you
    can replace the call to `getNewPuzzle()` with a list or array containing the puzzle
    you do want to solve.
  prefs: []
  type: TYPE_NORMAL
- en: 'The board in `puzzleBoard` is displayed to the user, and the current time is
    stored in `startTime` so that the program can calculate the runtime of the algorithm.
    The Python code continues as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The program begins trying to solve the puzzle in `puzzleBoard` in a maximum
    of 10 moves. The infinite `while` loop calls `solve()`. If a solution is found,
    `solve()` prints the solution on the screen and returns `True`. In that case,
    the code here can break out of the infinite `while` loop and print the total runtime
    of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if `solve()` returns `False`, `maxMoves` is incremented by `1` and
    the loop calls `solve()` again. This lets the program try progressively longer
    combinations of moves to solve the puzzle. This pattern continues until `solve()`
    finally returns `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A 15-puzzle is a good example of adapting the principles of recursion to a real-world
    problem. Recursion can perform a depth-first search on the tree graph of states
    that a 15-puzzle produces to find the path to a solution state. However, a purely
    recursive algorithm won’t work, which was why we had to make certain adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: The problem arises because a 15-puzzle has a massive number of possible states
    and doesn’t form a DAG. The edges in this graph are undirected, and the graph
    contains loops, or cycles. Our solving algorithm needs to ensure that it doesn’t
    make moves that immediately undo the previous move, so that it traverses the graph
    in one direction. It also needs to have a maximum number of moves the algorithm
    is willing to make before it begins to backtrack; otherwise, the loops guarantee
    that the algorithm will eventually recurse too much and cause a stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion isn’t necessarily the best approach for solving sliding-tile puzzles.
    All but the easiest puzzles simply have too many combinations for a typical laptop
    to solve within a reasonable amount of time. However, I like the 15-puzzle as
    an exercise in recursion because it connects the theoretical ideas of DAGs and
    DFS into a real-world problem. While 15-puzzles were invented over a century ago,
    the advent of computers provides a rich tool for exploring techniques to solve
    these amusing toys.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Wikipedia entry for 15-puzzles at [https://en.wikipedia.org/wiki/15_puzzle](https://en.wikipedia.org/wiki/15_puzzle)
    details their history and mathematical background.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the Python source code for a playable version of the sliding-tile
    puzzle game in my book *The Big Book of Small Python Projects* (No Starch Press,
    2021) and online at [https://inventwithpython.com/bigbookpython/project68.html](https://inventwithpython.com/bigbookpython/project68.html).
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fractal Art Maker
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 introduced you to programs that draw many well-known fractals with
    the `turtle` Python module, but you can also make your own fractal art with the
    project in this chapter. The Fractal Art Maker program uses Python’s `turtle`
    module to turn simple shapes into complex designs with minimal additional code.
  prefs: []
  type: TYPE_NORMAL
- en: The project in this chapter comes with nine example fractals, although you can
    also write new functions to create fractals of your design. Modify the example
    fractals to produce radically different artwork or write code from scratch to
    implement your own creative vision.
  prefs: []
  type: TYPE_NORMAL
- en: The Built-in Fractals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can direct your computer to create an unlimited number of fractals. [Figure
    13-1](#figure13-1) shows the nine fractals that come with the Fractal Art Maker
    program that we’ll use in this chapter. These are produced from functions that
    draw a simple square or equilateral triangle as the base shape, then introduce
    slight differences in their recursive configuration to produce completely different
    images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Nine labeled turtle graphics screenshots. Four Corners: a square containing
    an intricate hexagonal pattern. Spiral Squares: a spiral created by overlapping
    gray and white squares. Double Spiral Squares: a spiral created by overlapping
    multiple sets of white and gray squares. Triangle Spiral: a spiral created by
    overlapping the outlines of triangles. Conway’s Game of Life: a white square partially
    filled in by smaller gray squares. Those smaller squares are partially filled
    in by smaller white-and-dark-gray squares. Sierpinski Triangle: a Sierpinski triangle,
    as seen in Chapters 1 and 9\. Wave: a wave created out of many smaller triangles
    and wave shapes. Horn: a gray-and-white-striped spiral horn shape. Snowflake:
    a snowflake shape.](image_fi/502024c13/f13001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: The nine example fractals that come with the Fractal Art Maker
    program'
  prefs: []
  type: TYPE_NORMAL
- en: You can produce all of these fractals by setting the `DRAW_FRACTAL` constant
    at the top of the program to an integer from `1` to `9` and then running the Fractal
    Art Maker program. You can also set `DRAW_FRACTAL` to `10` or `11` to draw the
    basic square and triangle shapes, respectively, that compose these fractals, as
    shown in [Figure 13-2](#figure13-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Two turtle graphics screenshots, one showing a square and the other showing
    the outline of an equilateral triangle.](image_fi/502024c13/f13002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: The results of calling `drawFilledSquare()` (left) and `drawTriangleOutline()`
    (right) on their own'
  prefs: []
  type: TYPE_NORMAL
- en: 'These shapes are fairly simple: a square filled with either white or gray,
    and a simple outline of a triangle. The `drawFractal()` function uses these basic
    shapes to create amazing fractals.'
  prefs: []
  type: TYPE_NORMAL
- en: The Fractal Art Maker Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Fractal Art Maker’s algorithm has two major components: a shape-drawing
    function and the recursive `drawFractal()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: The shape-drawing function draws a basic shape. The Fractal Art Maker program
    comes with the two shape-drawing functions shown previously in [Figure 13-2](#figure13-2),
    `drawFilledSquare()` and `drawTriangleOutline()`, but you can also create your
    own. We pass a shape-drawing function to the `drawFractal()` function as an argument,
    just as we passed the match functions to the file finder’s `walk()` function in
    Chapter 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `drawFractal()` function also has a parameter indicating changes to the
    size, position, and angle of the shapes between recursive calls to `drawFractal()`.
    We’ll cover these specific details later in this chapter, but let’s look at one
    example: fractal 7, which draws a wave-like image.'
  prefs: []
  type: TYPE_NORMAL
- en: The program produces the Wave fractal by calling the `drawTriangleOutline()`
    shape-drawing function, which creates a single triangle. The additional arguments
    to `drawFractal()` tell it to make three recursive calls to `drawFractal()`. [Figure
    13-3](#figure13-3) shows the triangle produced by the original call to `drawFractal()`
    and the triangles produced by the three recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: '![Two turtle graphics screenshots. The first shows the outline of an equilateral
    triangle. The second shows that same triangle outline, as well as three additional,
    smaller equilateral triangles: two above the first, and the third below it and
    rotated slightly to the left.](image_fi/502024c13/f13003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: The triangle produced by the first call to `drawFractal()` (left)
    and the first set of three recursive calls (right)'
  prefs: []
  type: TYPE_NORMAL
- en: The first recursive call tells `drawFractal()` to call `drawTriangleOutline()`
    but with a triangle that is half the size and positioned to the top left of the
    previous triangle. The second recursive call produces a triangle to the top right
    of the previous triangle that is 30 percent of its size. The third recursive call
    produces a triangle below the previous triangle that is half its size and rotated
    15 degrees compared to it.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these three recursive calls to `drawFractal()` makes three more recursive
    calls to `drawFractal()`, producing nine new triangles. The new triangles have
    the same changes to their size, position, and angle relative to their previous
    triangle. The top-left triangle is always half the size of the previous triangle,
    while the bottom triangle is always rotated 15 degrees more. [Figure 13-4](#figure13-4)
    shows the triangles produced by the first and second levels of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '![Two turtle graphics screenshots. The first shows the same four triangles
    shown in Figure 13-3\. The second shows three smaller triangles clustered in the
    same pattern around each of the three new triangles.](image_fi/502024c13/f13004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: The first level of recursive calls to `drawFractal()` (left) and
    the nine new triangles of the second level of recursive calls (right)'
  prefs: []
  type: TYPE_NORMAL
- en: The nine calls to `drawFractal()` that produce these nine new triangles each
    make three recursive calls to `drawFractal()`, producing 27 new triangles at the
    next level of recursion. As this pattern of recursion continues, eventually the
    triangles become so small that `drawFractal()` stops making new recursive calls.
    This is one of the base cases for the recursive `drawFractal()` function. The
    other occurs when the recursive depth reaches a specified level. Either way, these
    recursive calls produce the final Wave fractal in [Figure 13-5](#figure13-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics screenshot of the Wave fractal.](image_fi/502024c13/f13005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: The final Wave fractal after each triangle recursively generates
    three more triangles'
  prefs: []
  type: TYPE_NORMAL
- en: The nine example fractals in [Figure 13-1](#figure13-1) that come with the Fractal
    Art Maker are made with just two shape-drawing functions and a few changes to
    the arguments to `drawFractal()`. Let’s take a look at the Fractal Art Maker’s
    code to see how it accomplishes this.
  prefs: []
  type: TYPE_NORMAL
- en: The Complete Fractal Art Maker Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enter the following code into a new file and save it as [fractalArtMaker.py](http://fractalArtMaker.py).
    This program relies on Python’s built-in `turtle` module, so no JavaScript code
    is used for this chapter’s project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: When you run this program, it will show the first of nine fractal images from
    [Figure 13-1](#figure13-1). You can change the `DRAW_FRACTAL` constant at the
    beginning of the source code to any integer from `1` to `9` and run the program
    again to see a new fractal. After learning how the program works, you’ll also
    be able to create your own shape-drawing functions and call `drawFractal()` to
    produce fractals of your own design.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Constants and the Turtle Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first lines of the program cover basic setup steps for our turtle-based
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The program imports the `turtle` module for drawing. It also imports the `math`
    module for the `math.sqrt()` function, which the Sierpiński Triangle fractal will
    use, and the `math.cos()` and `math.sin()` functions, for the Snowflake fractal.
  prefs: []
  type: TYPE_NORMAL
- en: The `DRAW_FRACTAL` constant can be set to any integer from `1` to `9` to draw
    one of the nine built-in fractals the program produces. You can also set it to
    `10` or `11` to show the output of the square or triangle shape-drawing function,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We also call some turtle functions to prepare for drawing. The `turtle.tracer(5000,
    0)` call speeds up the drawing of the fractal. The `5000` argument tells the `turtle`
    module to wait until 5,000 turtle drawing instructions have been processed before
    rendering the drawing on the screen, and the `0` argument tells it to pause for
    0 milliseconds after each drawing instruction. Otherwise, the `turtle` module
    would render the image after each drawing instruction, which significantly slows
    the program if we want only the final image.
  prefs: []
  type: TYPE_NORMAL
- en: You can change this call to `turtle.tracer(1, 10)` if you want to slow the drawing
    and watch the lines as they’re produced. This can be useful when making your own
    fractals to debug any problems with the drawing.
  prefs: []
  type: TYPE_NORMAL
- en: The `turtle.hideturtle()` call hides the triangle shape on the screen that represents
    the turtle’s current position and heading. (*Heading* is another term for *direction*.)
    We call this function so that the marker doesn’t appear in the final image.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Shape-Drawing Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `drawFractal()` function uses a shape-drawing function passed to it to draw
    the individual parts of the fractal. This is usually a simple shape, such as a
    square or triangle. The beautiful complexity of the fractals emerges from `drawFractal()`
    recursively calling this function for each individual component of the whole fractal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shape-drawing functions for the Fractal Art Maker have two parameters:
    `size` and `depth`. The `size` parameter is the length of the sides of the square
    or triangle it draws. The shape-drawing functions should always use arguments
    to `turtle.forward()` that are based on `size` so that the lengths will be proportionate
    to `size` at each level of recursion. Avoid code like `turtle.forward(100)` or
    `turtle.forward(200)`; instead, use code that is based on the `size` parameter,
    like `turtle.forward(size)` or `turtle.forward(size * 2)`. In Python’s `turtle`
    module, `turtle.forward(1)` moves the turtle by one *unit*, which is not necessarily
    the same as one pixel.'
  prefs: []
  type: TYPE_NORMAL
- en: The shape-drawing functions’ second parameter is the recursive depth of `drawFractal()`.
    The original call to `drawFractal()` has the `depth` parameter set to `0`. Recursive
    calls to `drawFractal()` use `depth + 1` as the `depth` parameter. In the Wave
    fractal, the first triangle in the center of the window has a depth argument of
    `0`. The three triangles created next have a depth of `1`. The nine triangles
    around those three triangles have a depth of `2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Your shape-drawing function can ignore this argument, but using it can cause
    interesting variations to the basic shape. For example, the `drawFilledSquare()`
    shape-drawing function uses `depth` to alternate between drawing white squares
    and gray squares. Keep this in mind if you’d like to create your own shape-drawing
    functions for the Fractal Art Maker program, as they must accept a `size` and
    `depth` argument.
  prefs: []
  type: TYPE_NORMAL
- en: The drawFilledSquare() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `drawFilledSquare()` function draws a filled-in square with sides of length
    `size`. To color the square, we use the `turtle` module’s `turtle.begin_fill()`
    and `turtle.end_fill()` functions to make the square either white or gray, with
    a black border, depending on whether the `depth` argument is even or odd. Because
    these squares are filled in, any squares drawn on top of them later will cover
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like all shape-drawing functions for the Fractal Art Maker program, `drawFilledSquare()`
    accepts a `size` and `depth` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The `size` argument could be a floating-point number with a fractional part,
    which sometimes causes the `turtle` module to make slightly asymmetrical and uneven
    drawings. To prevent this, the first line of the function rounds `size` down to
    an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the function draws the square, it assumes the turtle is in the center
    of the square. Thus, the turtle must first move to the top-right corner of the
    square, relative to its initial heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `drawFractal()` function always has the pen down and ready to draw when
    the shape-drawing function is called, so `drawFilledSquare()` must call `turtle.penup()
    to avoid drawing a line as it moves to the starting position. To find the starting
    position relative to the middle of the square, the turtle must first move half
    of the square’s length (that is, `size // 2`) forward, to the future right edge
    of the square. Next the turtle turns 90 degrees to face up and then moves `size
    // 2` units forward to the top-right corner. The turtle is now facing the wrong
    way, so it turns around 180 degrees and places the pen down so that it can begin
    drawing.`
  prefs: []
  type: TYPE_NORMAL
- en: '`Note that *top-right* and *up* are relative to the direction the turtle is
    originally facing. This code works just as well if the turtle begins facing to
    the right at 0 degrees or has a heading of 90, 42, or any other number of degrees.
    When you create your own shape-drawing functions, stick to the relative turtle
    movement functions like `turtle.forward()`, `turtle.left()`, and `turtle.right()`
    instead of absolute turtle movement functions like `turtle.goto()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `depth` argument tells the function whether it should draw a white
    square or a gray one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: If `depth` is even, the `depth % 2 == 0` condition is `True`, and the square’s
    *fill color* is white. Otherwise, the code sets the fill color to gray. Either
    way, the border of the square, determined by the *pen color*, is set to black.
    To change either of these colors, use strings of common color names, like `red`
    or `yellow`, or an HTML color code comprising a hash mark and six hexadecimal
    digits, like `#24FF24` for lime green or `#AD7100` for brown.
  prefs: []
  type: TYPE_NORMAL
- en: The website [https://html-color.codes](https://html-color.codes) has charts
    for many HTML color codes. The fractals in this black-and-white book lack color,
    but your computer can render your own fractals in a bright range of colors!
  prefs: []
  type: TYPE_NORMAL
- en: 'With the colors set, we can finally draw the four lines of the actual square:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: To tell the `turtle` module that we intend to draw a filled-in shape and not
    just the outline, we call the `turtle.begin_fill()` function. Next is a `for`
    loop that draws a line of length `size` and turns the turtle 90 degrees to the
    right. The `for` loop repeats this four times to create the square. When the function
    finally calls `turtle.end_fill()`, the filled-in square appears on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The drawTriangleOutline() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second shape-drawing function draws the outline of an equilateral triangle
    whose sides have a length of `size`. The function draws the triangle oriented
    with one corner at the top and two corners at the bottom. [Figure 13-6](#figure13-6)
    illustrates the various dimensions of an equilateral triangle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Annotated diagram of an equilateral triangle showing the following properties.
    Size: the length of one side. Angle: 60 degrees. Height: size times math.sqrt(3)
    / 2\. Also shows two-thirds of the height and one-third of the height.](image_fi/502024c13/f13006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-6: The measurements of an equilateral triangle with sides the length
    of `size`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin drawing, we must determine the triangle’s height based on the
    length of its sides. Geometry tells us that, for equilateral triangles with sides
    of length *L*, the height *h* of the triangle is *L* times the square root of
    3 divided by 2\. In our function, *L* corresponds to the `size` parameter, so
    our code sets the height variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Geometry also tells us that the center of the triangle is one-third of the
    height from the bottom side and two-thirds of the height from the top point. This
    gives us the information we need to move the turtle to its starting position:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: To reach the top corner, we turn the turtle 90 degrees left to face up (relative
    to the turtle’s original heading right at 0 degrees) and then move forward a number
    of units equal to `height * (2/3)`. The turtle is still facing up, so to begin
    drawing the line on the right side, the turtle must turn 90 degrees right to face
    rightward, then an additional 60 degrees to face the bottom-right corner of the
    triangle. This is why we call `turtle.right(150)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the turtle is ready to start drawing the triangle, so we lower
    the pen by calling `turtle.pendown()`. A `for` loop will handle drawing the three
    sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Drawing the actual triangle is a matter of moving forward by `size` units, and
    then turning 120 degrees to the right, three separate times. The third and final
    120-degree turn leaves the turtle facing its original direction. You can see these
    movements and turns in [Figure 13-7](#figure13-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of four equilateral triangles. Each triangle has one additional bolded
    line, representing the steps needed to draw the triangle and return the turtle
    to its original heading.](image_fi/502024c13/f13007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-7: Drawing an equilateral triangle involves three forward movements
    and three 120-degree turns.'
  prefs: []
  type: TYPE_NORMAL
- en: The `drawTriangleOutline()` function draws only the outline and not a filled-in
    shape, so it doesn’t call `turtle.begin_fill()` and `turtle.end_fill()` as `drawFilledSquare()`
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Fractal Drawing Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have two sample drawing functions to work with, let’s examine the
    main function in the Fractal Art Maker project, `drawFractal()`. This function
    has three required parameters and one optional one: `shapeDrawFunction`, `size`,
    `specs`, and `maxDepth`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `shapeDrawFunction` parameter expects a function, like `drawFilledSquare()`
    or `drawTriangleOutline()`. The `size` parameter expects the starting size passed
    to the drawing function. Often, a value between `100` and `500` is a good starting
    size, though this depends on the code in your shape-drawing function, and finding
    the right value may require experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: The `specs` parameter expects a list of dictionaries that specify how the recursive
    shapes should change their size, position, and angle as `drawFractal()` recursively
    calls itself. These specifications are described later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent `drawFractal()` from recursing until it causes a stack overflow,
    the `maxDepth` parameter holds the number of times `drawFractal()` should recursively
    call itself. By default, `maxDepth` has a value of `8`, but you can provide a
    different value if you want more or fewer recursive shapes.
  prefs: []
  type: TYPE_NORMAL
- en: A fifth parameter, `depth`, is handled by `drawFractal()`’s recursive call to
    itself and defaults to `0`. You don’t need to specify it when you call `drawFractal()`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing the `drawFractal()` function does is check for its two base
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: If `depth` is greater than `maxDepth`, the function will stop the recursion
    and return. The other base case occurs if `size` is less than `1`, at which point
    the shapes being drawn would be too small to be seen on the screen and so the
    function should simply return.
  prefs: []
  type: TYPE_NORMAL
- en: 'We keep track of the turtle’s original position and heading in three variables:
    `initialX`, `initialY`, and `initialHeading`. This way, no matter where the shape-drawing
    function leaves the turtle positioned or what direction it is headed, `drawFractal()`
    can revert the turtle back to the original position and heading for the next recursive
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `turtle.xcor()` and `turtle.ycor()` functions return the absolute x- and
    y-coordinates of the turtle on the screen. The `turtle.heading()` function returns
    the direction in which the turtle is pointed in degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next few lines call the shape-drawing function passed to the `shapeDrawFunction`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Because the value passed as the argument for the `shapeDrawFunction` parameter
    is a function, the code `shapeDrawFunction(size, depth)` calls this function with
    the values in `size` and `depth`. The pen is lowered before and raised after the
    `shapeDrawFunction()` call to ensure that the shape-drawing function can consistently
    expect the pen to be down when the drawing begins.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Specifications Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the call to `shapeDrawFunction()`, the rest of `drawFractal()`’s code
    is devoted to making recursive calls to `drawFractal()` based on the specification
    in the `specs` list’s dictionaries. For each dictionary, `drawFractal()` makes
    one recursive call to `drawFractal()`. If `specs` is a list with one dictionary,
    every call to `drawFractal() results in only one recursive call to `drawFractal()`.
    If `specs` is a list with three dictionaries, every call to `drawFractal()` results
    in three recursive calls to `drawFractal()`.`
  prefs: []
  type: TYPE_NORMAL
- en: '`The dictionaries in the `specs` parameter provide specifications for each
    recursive call. Each of these dictionaries has the keys `sizeChange`, `xChange`,
    `yChange`, and `angleChange`. These dictate how the size of the fractal, the position
    of the turtle, and the heading of the turtle change for a recursive `drawFractal()`
    call. [Table 13-1](#table13-1) describes the four keys in a specification.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-1: Keys in the Specification Dictionaries'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Default value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sizeChange` | `1.0` | The next recursive shape’s size value is the current
    size multiplied by this value. |'
  prefs: []
  type: TYPE_TB
- en: '| `xChange` | `0.0` | The next recursive shape’s x-coordinate is the current
    x-coordinate plus the current size multiplied by this value. |'
  prefs: []
  type: TYPE_TB
- en: '| `yChange` | `0.0` | The next recursive shape’s y-coordinate is the current
    y-coordinate plus the current size multiplied by this value. |'
  prefs: []
  type: TYPE_TB
- en: '| `angleChange` | `0.0` | The next recursive shape’s starting angle is the
    current starting angle plus this value. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s take a look at the specification dictionary for the Four Corners fractal,
    which produces the top-left image shown previously in [Figure 13-1](#figure13-1).
    The call to `drawFractal()` for the Four Corners fractal passes the following
    list of dictionaries for the `specs` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The `specs` list has four dictionaries, so each call to `drawFractal()` that
    draws a square will, in turn, recursively call `drawFractal()` four more times
    to draw four more squares. [Figure 13-8](#figure13-8) shows this progression of
    squares (which alternate between white and gray).
  prefs: []
  type: TYPE_NORMAL
- en: To determine the size of the next square to be drawn, the value for the `sizeChange`
    key is multiplied by the current `size` parameter. The first dictionary in the
    `specs` list has a `sizeChange` value of `0.5`, which makes the next recursive
    call have a size argument of `350 * 0.5`, or `175` units. This makes the next
    square half the size of the previous square. A `sizeChange` value of `2.0` would,
    for example, double the size of the next square. If the dictionary has no `sizeChange`
    key, the value defaults to `1.0` for no change to the size.
  prefs: []
  type: TYPE_NORMAL
- en: '![Six turtle graphics screenshots. The first shows a white square. The second
    shows four smaller gray squares covering each corner of the white square. The
    third shows four smaller white squares covering the corners of each of those smaller
    gray squares. This pattern continues in the subsequent three screenshots. As the
    squares begin to overlap, their outlines remain visible.](image_fi/502024c13/f13008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-8: Each step of the Four Corners example from left to right, top
    to bottom. Each square recursively produces four more squares at its corners,
    with colors alternating between white and gray.'
  prefs: []
  type: TYPE_NORMAL
- en: To determine the x-coordinate of the next square, the first dictionary’s `xChange`
    value, `-0.5` in this case, is multiplied by the size. When `size` is `350`, this
    means the next square has an x-coordinate of `-175` units relative to the turtle’s
    current position. This `xChange` value and the `yChange` key’s value of `0.5`
    places the next square’s position a distance of 50 percent of the current square’s
    size, to the left and above the current square’s position. This happens to center
    it on the top-left corner of the current square.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the three other dictionaries in the `specs` list, you’ll notice
    they all have a `sizeChange` value of `0.5`. The difference between them is that
    their `xChange` and `yChange` values place them in the other three corners of
    the current square. As a result, the next four squares are drawn centered on the
    four corners of the current square.
  prefs: []
  type: TYPE_NORMAL
- en: The dictionaries in the `specs` list for this example don’t have an `angleChange`
    value, so this value defaults to `0.0` degrees. A positive `angleChange` value
    indicates a counterclockwise rotation, while a negative value indicates a clockwise
    rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Each dictionary represents a separate square to be drawn each time the recursive
    function is called. If we were to remove the first dictionary from the `specs`
    list, each `drawFractal()` call would produce only three squares, as in [Figure
    13-9](#figure13-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Six screenshots identical to those in Figure 13-8, except the pattern develops
    on only three corners of the original square.](image_fi/502024c13/f13009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-9: The Four Corners fractal with the first dictionary removed from
    the `specs` list'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Specifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at how the code in `drawFractal()` actually does everything we’ve
    described:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop assigns an individual specification dictionary in the `specs`
    list to the loop variable `spec` on each iteration of the loop. The `get()` dictionary
    method calls pull the values for the `sizeChange`, `xChange`, `yChange`, and `angleChange`
    keys from this dictionary and assign them to the shorter-named `sizeCh`, `xCh`,
    `yCh`, and `angleCh` variables. The `get()` method substitutes a default value
    if the key doesn’t exist in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the turtle’s position and heading are reset to the values indicated when
    `drawFractal()` was first called. This ensures that the recursive calls from previous
    loop iterations don’t leave the turtle in some other place. Then the heading and
    position are changed according to the `angleCh`, `xCh`, and `yCh` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The x-change and y-change positions are expressed relative to the turtle’s current
    heading. If the turtle’s heading is `0`, the turtle’s relative x-axis is the same
    as the actual x-axis on the screen. However, if the turtle’s heading is, say,
    `45`, the turtle’s relative x-axis is at a 45-degree tilt. Moving “right” along
    the turtle’s relative x-axis would then move at an up-right angle.
  prefs: []
  type: TYPE_NORMAL
- en: This is why moving forward by `size * xCh` moves the turtle along its relative
    x-axis. If `xCh` is negative, `turtle.forward()` moves left along the turtle’s
    relative x-axis. The `turtle.left(90)` call points the turtle along the turtle’s
    relative y-axis, and `turtle.forward(size * yCh)` moves the turtle to the next
    shape’s starting position. However, the `turtle.left(90)` call changed the turtle’s
    heading, so `turtle.right(90)` is called to reset it back to its original direction.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-10](#figure13-10) shows how these four lines of code move the turtle
    to the right along its relative x-axis and up along its relative y-axis and leave
    it in the correct heading, no matter what its initial heading was.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Four turtle graphics screenshots of the same two perpendicular lines, each
    time rotated a different way.](image_fi/502024c13/f13010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-10: In each of these four images, the turtle always moves 100 units
    “right” and “up” along the relative x-axis and y-axis of its initial heading.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, with the turtle in the correct position and heading for the next shape,
    we make the recursive call to `drawFractal()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The `shapeDrawFunction`, `specs`, and `maxDepth` arguments are passed to the
    recursive `drawFractal()` call unchanged. However, `size * sizeCh` is passed for
    the next `size` parameter to reflect the change in the `size` of the recursive
    shape, and `depth + 1` is passed for the `depth` parameter to increment it for
    the next shape-drawing function call.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Example Fractals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve covered how the shape-drawing functions and recursive `drawFractal()`
    function work, let’s look at the nine example fractals that come with the Fractal
    Art Maker. You can see these examples in [Figure 13-1](#figure13-1).
  prefs: []
  type: TYPE_NORMAL
- en: Four Corners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first fractal is *Four Corners*, which begins as a large square. As the
    function calls itself, the fractal’s specifications cause four smaller squares
    to be drawn in the four corners of the square:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The call to `drawFractal()` here limits the maximum depth to `5`, as any more
    tends to make the fractal so dense that the fine detail becomes hard to see. This
    fractal appears in [Figure 13-8](#figure13-8).
  prefs: []
  type: TYPE_NORMAL
- en: Spiral Squares
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Spiral Squares fractal*also starts as a large square, but it creates just
    one new square on each recursive call:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This square is slightly smaller and rotated by `7` degrees. The centers of all
    the squares are unchanged, so there’s no need to add `xChange` and `yChange` keys
    to the specification. The default maximum depth of `8` is too small to get an
    interesting fractal, so we increase it to `50` to produce a hypnotic spiral pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Double Spiral Squares
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Double Spiral Squares fractal* is similar to Spiral Squares, except each
    square creates two smaller squares. This creates an interesting fan effect, as
    the second square is drawn later and tends to cover up previously drawn squares:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The squares are created slightly higher or lower than their previous square
    and rotated either `10` or `-10` degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Triangle Spiral
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Triangle Spiral* *fractal*, another variation of Spiral Squares, uses
    the `drawTriangleOutline()` shape-drawing function instead of `drawFilledSquare()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the Spiral Squares fractal, the Triangle Spiral fractal begins at the
    small `size` of `20` units and slightly increases in size for each level of recursion.
    The `sizeChange` key is greater than `1.0`, so the shapes are always increasing
    in size. This means the base case occurs when the recursion reaches a depth of
    `80`, because the base case of `size` becoming less than `1` is never reached.
  prefs: []
  type: TYPE_NORMAL
- en: Conway’s Game of Life Glider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Conway’s Game of Life* is a famous example of cellular automata. The game’s
    simple rules cause interesting and wildly chaotic patterns to emerge on a 2D grid.
    One such pattern is a *Glider* consisting of five cells in a 3 × 3 space:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The Glider fractal here has additional Gliders drawn inside each of its five
    cells. The `third` variable helps precisely set the position of the recursive
    shapes in the 3 × 3 space.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a Python implementation of Conway’s Game of Life in my book *The
    Big Book of Small Python Projects* (No Starch Press, 2021) and online at [https://inventwithpython.com/bigbookpython/project13.html](https://inventwithpython.com/bigbookpython/project13.html).
    Tragically, John Conway, the mathematician and professor who developed Conway’s
    Game of Life, passed away of complications from COVID-19 in April 2020.
  prefs: []
  type: TYPE_NORMAL
- en: Sierpiński Triangle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We created the *Sierpiński Triangle* *fractal* in Chapter 9, but our Fractal
    Art Maker can re-create it as well by using the `drawTriangleOutline()` shape
    function. After all, a Sierpiński triangle is an equilateral triangle with three
    smaller equilateral triangles drawn in its interior:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The center of these smaller triangles is `size * math.sqrt(3) / 6` units from
    the center of the previous triangle. The three calls adjust the heading of the
    turtle to `0`, `120`, and `240` degrees before moving up on the turtle’s relative
    y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Wave
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We discussed the *Wave fractal* at the start of this chapter, and you can see
    it in [Figure 13-5](#figure13-5). This relatively simple fractal creates three
    smaller and distinct recursive triangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Horn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Horn fractal* resembles a ram’s horn:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This simple fractal is made up of squares, each of which is slightly smaller,
    moved up, and rotated `11` degrees from the previous square. We increase the maximum
    recursion depth to `100` to extend the horn into a tight spiral.
  prefs: []
  type: TYPE_NORMAL
- en: Snowflake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final fractal, *Snowflake*, is composed of squares laid out in a pentagon
    pattern. This is similar to the Four Corners fractal, but it uses five evenly
    spaced recursive squares instead of four:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This fractal uses the cosine and sine functions from trigonometry, implemented
    in Python’s `math.cos()` and `math.sin()` functions, to determine how to shift
    the squares along the x-axis and y-axis. A full circle has 360 degrees, so to
    evenly space out the five recursive squares in this circle, we place them at intervals
    of 0, 72, 144, 216, and 288 degrees. The `math.cos()` and `math.sin()` functions
    expect the angle argument to be in radians instead of degrees, so we must multiply
    these numbers by `math.pi / 180`.
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that each square is surrounded by five other squares, which
    are surrounded by five other squares, and so on, to form a crystal-like fractal
    that resembles a snowflake.
  prefs: []
  type: TYPE_NORMAL
- en: Producing a Single Square or Triangle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For completion, you can also set `DRAW_FRACTAL` to `10` or `11` to view what
    a single call to `drawFilledSquare()` and `drawTriangleOutline()` produce in the
    turtle window. These shapes are drawn with a size of `600`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: After drawing the fractal or shape based on the value in `DRAW_FRACTAL`, the
    program calls `turtle.exitonclick()` so that the turtle window stays open until
    the user clicks it. Then the program terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your Own Fractals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create your own fractals by changing the specification passed to the
    `drawFractal()` function. Start by thinking about how many recursive calls you’d
    like each call to `drawFractal()` to generate, and how the size, position, and
    heading of the shapes should change. You can use the existing shape-drawing functions
    or create your own.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Figure 13-11](#figure13-11) shows the nine built-in fractals,
    except the square and triangle functions have been swapped. Some of these produce
    bland shapes, but others can result in unexpected beauty.
  prefs: []
  type: TYPE_NORMAL
- en: '![The six fractals from Figure 13-1 with all the squares and triangles swapped.](image_fi/502024c13/f13011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-11: The nine fractals that come with Fractal Art Maker, with the
    shape-drawing functions swapped'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fractal Art Maker projects demonstrate the endless possibilities of recursion.
    A simple recursive `drawFractal()` function, paired with a shape-drawing function,
    can create a large variety of detailed geometric art.
  prefs: []
  type: TYPE_NORMAL
- en: At the core of Fractal Art Maker is the recursive `drawFractal()` function,
    which accepts another function as an argument. This second function draws a basic
    shape repeatedly by using the size, position, and heading given in the list of
    specification dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: You can test an unlimited number of shape-drawing functions and specification
    settings. Let your creativity drive your fractal projects as you experiment with
    the code in this program.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are websites that allow you to create fractals. Interactive Fractal Tree
    at [https://www.visnos.com/demos/fractal](https://www.visnos.com/demos/fractal)
    has sliders to change a binary tree fractal’s angle and size parameters. Procedural
    Snowflake at [https://procedural-snowflake.glitch.me](https://procedural-snowflake.glitch.me)
    generates new snowflakes in your browser. Nico’s Fractal Machine at [https://sciencevsmagic.net/fractal](https://sciencevsmagic.net/fractal)
    creates animated drawings of fractals. You can find others by searching the web
    for *fractal maker* or *fractal generator online*.``  ``# 14
  prefs: []
  type: TYPE_NORMAL
- en: Droste Maker
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: The *Droste effect* is a recursive art technique named after a 1904 illustration
    on a tin of Droste’s Cacao, a Dutch brand of cocoa. Shown in [Figure 14-1](#figure14-1),
    the tin features an image of a nurse holding a meal tray containing a tin of Droste
    cocoa, which itself bears the illustration.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll create a Droste Maker program that can generate similar
    recursive images from any photograph or drawing you have, whether it be a museum
    patron looking at an exhibit of themself, a cat in front of a computer monitor
    of a cat in front of a computer monitor, or something else entirely.
  prefs: []
  type: TYPE_NORMAL
- en: '![A tin of Droste cocoa from 1904\. The illustration on the tin features a
    nurse holding a tray with a steaming mug and a tin of Droste cocoa. The recursive
    illustration on this tin is the same nurse holding a tray with a steaming mug
    and a tin of Droste cocoa.](image_fi/502024c14/f14001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-1: The recursive illustration on a tin of Droste’s Cacao'
  prefs: []
  type: TYPE_NORMAL
- en: Using a graphics program such as Microsoft Paint or Adobe Photoshop, you’ll
    prepare the image by covering an area of it with a pure magenta color, indicating
    where to place the recursive image. The Python program uses the Pillow image library
    to read this image data and produce a recursive image.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll cover how to install the Pillow library and how the Droste Maker
    algorithm works. Next, we’ll present the Python source code for the program with
    accompanying explanation of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Pillow Python Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter’s project requires the Pillow image library. This library allows
    your Python programs to create and modify image files including PNGs, JPEGs, and
    GIFs. It has several functions to perform resizing, copying, cropping, and other
    common actions on images.
  prefs: []
  type: TYPE_NORMAL
- en: To install this library on Windows, open a command prompt window and run `py
    -m pip install --user pillow`. To install this library on macOS or Linux, open
    a Terminal window and run python3 `-m pip install --user pillow`. This command
    makes Python use the pip installer program to download the module from the official
    Python Package Index at [https://pypi.org](https://pypi.org).
  prefs: []
  type: TYPE_NORMAL
- en: To verify that the installation worked, open a Python terminal and run `from
    PIL import Image`. (While the library’s name is Pillow, the Python module installed
    is named `PIL`, in capital letters.) If no error appears, the library was installed
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation for Pillow can be found at [https://pillow.readthedocs.io](https://pillow.readthedocs.io).
  prefs: []
  type: TYPE_NORMAL
- en: Painting Your Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to prepare an image by setting a portion of it to the RGB (red,
    green, blue) color value (255, 0, 255). Computer graphics often use magenta to
    mark which pixels of an image should be rendered as transparent. Our program will
    treat these magenta pixels like a green screen in video production, replacing
    them with a resized version of the initial image. Of course, this resized image
    will have its own smaller magenta area, which the program will replace with another
    resized image. The base case occurs when the final image has no more magenta pixels,
    at which point the algorithm is done.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-2](#figure14-2) shows the progression of images created as the resized
    image is recursively applied to the magenta pixels. In this example, a model stands
    in front of an art museum exhibit that has been replaced with magenta pixels,
    turning the photograph itself into the exhibit. You can download this base image
    from [https://inventwithpython.com/museum.png](https://inventwithpython.com/museum.png).'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure you use only the pure (255, 0, 255) magenta color for painting the magenta
    area in your image. Some tools may have a fading effect that produces a more natural
    look. For example, Photoshop’s Brush tool will produce faded magenta pixels on
    the outline of the painted area, so you will need to use the Pencil tool instead,
    which paints using only the precise pure magenta color you’ve selected. If your
    graphics program doesn’t allow you to specify the precise RGB color for drawing,
    you can copy and paste the colors from the PNG image at [https://inventwithpython.com/magenta.png](https://inventwithpython.com/magenta.png).
  prefs: []
  type: TYPE_NORMAL
- en: The magenta area in the image can be of any size or shape; it does not have
    to be an exact, contiguous rectangle. You can see that in [Figure 14-2](#figure14-2),
    the museum visitor cuts into the magenta rectangle, placing them in front of the
    recursive image.
  prefs: []
  type: TYPE_NORMAL
- en: If you make your own images with Droste Maker, you should use the PNG image
    file format instead of JPEG. JPEG images use *lossy* compression techniques to
    keep the file size small that introduce slight imperfections. These are usually
    imperceptible to the human eye and don’t affect overall image quality. However,
    this lossy compression will replace the pure (255, 0, 255) magenta pixels with
    slightly different shades of magenta. The *lossless* image compression of PNG
    images ensures this won’t happen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Four images of a girl, seen from behind, looking at a work of art. In the
    first image, the work of art is covered by a monochrome rectangle. In the second
    image, the monochrome rectangle has been replaced by a resized version of the
    original image of the girl. In the third and fourth images, the monochrome rectangles
    have once again been replaced, creating the effect that the girl is looking at
    herself looking at herself.](image_fi/502024c14/f14002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-2: Recursive applications of the image to the magenta pixels. If
    you are viewing the black-and-white image printed in this book, the magenta area
    is the rectangle in front of the museum visitor.'
  prefs: []
  type: TYPE_NORMAL
- en: The Complete Droste Maker Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the source code for *drostemaker.py*; because this program
    relies on the Python-only Pillow library, there is no JavaScript equivalent for
    this project in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Before you run this program, place your image file in the same folder as *drostemaker.py*.
    The program will save the recursive image as *museum-recursive.png* and then open
    an image viewer to display it. If you want to run the program on your own image
    that you’ve added a magenta area to, replace `makeDroste('museum.png')` at the
    end of the source code with the name of your image file and `save('museum-recursive.png')`
    with the name you’d like to use to save the recursive image.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Droste Maker program has only one function, `makeDroste()`, which accepts
    a Pillow `Image` object or a string of an image’s filename. The function returns
    a Pillow `Image` object with any magenta pixels recursively replaced by a version
    of the same image:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The program begins by importing the `Image` class from the Pillow library (named
    `PIL` as a Python module). Within the `makeDroste()` function, we check whether
    the `baseImage` parameter is a string, and if so, we replace it with a Pillow
    `Image` object loaded from the corresponding image file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check whether the `stopAfter` parameter is `0`. If it is, we’ve reached
    one of the algorithm’s base cases and the function returns the Pillow `Image`
    object of the base image:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The `stopAfter` parameter is `10` by default if the function call doesn’t provide
    one. The recursive call to `makeDroste()` later in this function passes `stopAfter
    - 1` as the argument for this parameter so that it decreases with each recursive
    call and approaches the base case of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, passing `0` for `stopAfter` results in the function immediately
    returning a recursive image identical to the base image. Passing `1` for `stopAfter`
    replaces the magenta area with a recursive image once, makes one recursive call,
    reaches the base case, and immediately returns. Passing `2` for `stopAfter` causes
    two recursive calls, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This parameter prevents the function from recursing until it causes a stack
    overflow in cases when the magenta area is particularly large. It also lets us
    pass a smaller argument than `10` to limit the number of recursive images placed
    in the base image. For example, the four images in [Figure 14-2](#figure14-2)
    were created by passing `0`, `1`, `2`, and `3` for the `stopAfter` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check the color mode of the base image. This can be either `RGB` for
    an image with red-green-blue pixels or `RGBA` for an image that has an alpha channel
    for its pixels. The *alpha value* tells a pixel’s level of transparency. Here’s
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The Droste Maker needs to know the color mode so that it can find magenta pixels.
    The values for each channel range from `0` to `255`, and magenta pixels have a
    maximum amount of red and blue but no green. Further, if an alpha channel exists,
    it would be set to `255` for a completely opaque color and `0` for a completely
    transparent one. The `magentaColor` variable is set to the correct tuple value
    for a magenta pixel depending on the image’s color mode given in `baseImage.mode`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Magenta Area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the program can recursively insert the image into the magenta area, it
    must find the boundaries of the magenta area in the image. This involves finding
    the leftmost, rightmost, topmost, and bottommost magenta pixels in the image.
  prefs: []
  type: TYPE_NORMAL
- en: While the magenta area itself doesn’t need to be a perfect rectangle, the program
    needs to know the rectangular boundaries of the magenta in order to properly resize
    the image for insertion. For example, [Figure 14-3](#figure14-3) shows a base
    image of the *Mona Lisa* with the magenta area outlined in white. The magenta
    pixels are replaced to produce the recursive image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Two images of the Mona Lisa. In the first, the woman’s face and torso have
    been replaced with a monochrome shape, and a white rectangle indicates the boundaries
    of that shape. In the second image, the monochrome area has been replaced by progressively
    smaller versions of the original image.](image_fi/502024c14/f14003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-3: The base image with a magenta area outlined in white (left) and
    the recursive image it produces (right)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the resizing and placement of the resized image, the program retrieves
    the width and height of the base image from the `size` attribute of the Pillow
    `Image` object in `baseImage`. The following lines initialize four variables for
    the four edges of the magenta area—`magentaLeft`, `magentaRight`, `magentaTop`,
    and `magentaBottom`—to the `None` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'These edge variable values are replaced by integer `x` and `y` coordinates
    in the code that comes next:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: These nested `for` loops iterate the `x` and `y` variables over every possible
    x, y coordinate in the base image. We check whether the pixel at each coordinate
    is the pure magenta color stored in `magentaColor`, then update the `magentaLeft`
    variable if the coordinates of the magenta pixel are further left than currently
    recorded in `magentaLeft`, and so on for the other three directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the time the nested `for` loops are finished, `magentaLeft`, `magentaRight`,
    `magentaTop`, and `magentaBottom` will describe the boundaries of the magenta
    pixels in the base image. If the image has no magenta pixels, these variables
    will remain set to their initial `None` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: If `magentaLeft` (or really, any of the four variables) is still set to `None`
    after the nested `for` loops complete, no magenta pixels are in the image. This
    is a base case for our recursive algorithm because the magenta area becomes smaller
    and smaller with each recursive call to `makeDroste()`. At this point, the function
    returns the Pillow `Image` object in `baseImage`.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing the Base Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to resize the base image to cover the entire magenta area and no more.
    [Figure 14-4](#figure14-4) shows the complete resized image overlayed transparently
    on the original base image. This resized image is cropped so that only the parts
    over magenta pixels are copied over to the final image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Four images of a cat sitting in front of a computer monitor. In the first,
    the computer monitor’s screen is covered in a monochrome shade. In the second,
    the monochrome area has been replaced by a smaller version of the original image,
    but this version is transparent, making visible the places where it overlaps with
    the non-monochrome portions of the larger image. The third image is the completed
    recursive image.](image_fi/502024c14/f14004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-4: The base image with the magenta area in the monitor (top), the
    resized image over the base image (middle), and the final recursive image that
    replaces only the magenta pixels (bottom)'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot simply resize the base image to the dimensions of the magenta area
    because it’s unlikely the two share the same *aspect ratio*, or proportion of
    the width divided by the height. Doing so results in a recursive image that looks
    stretched or squished, like [Figure 14-5](#figure14-5).
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we must make the resized image large enough to completely cover the
    magenta area but still retain the image’s original aspect ratio. This means either
    setting the width of the resized image to the width of the magenta area such that
    the height of the resized image is equal to or larger than the height of the magenta
    area, or setting the height of the resized image to the height of the magenta
    area such that the width of the resized image is equal to or larger than the width
    of the magenta area.
  prefs: []
  type: TYPE_NORMAL
- en: '![Version of the recursive image of the girl looking at herself in which subsequent
    appearances of the girl appear distorted.](image_fi/502024c14/f14005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-5: Resizing the image to the dimensions of the magenta area can result
    in a different aspect ratio, causing it to look stretched or squished.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the correct resizing dimensions, the program needs to determine
    the aspect ratio of both the base image and the magenta area:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'From `magentaRight` and `magentaLeft`, we can calculate the width of the magenta
    area. The `+ 1` accounts for a small, necessary adjustment: if the right side
    of the magenta area was the x-coordinate of 11 and the left side was 10, the width
    would be two pixels. This is correctly calculated by (`magentaRight - magentaLeft
    + 1`), not (`magentaRight - magentaLeft`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the aspect ratio is the width divided by the height, images with large
    aspect ratios are taller than they are wide, and those with small aspect ratios
    are wider than they are tall. An aspect ratio of 1.0 describes a perfect square.
    The next lines set the dimensions of the resized image after comparing the aspect
    ratios of the base image and the magenta area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: If the base image’s aspect ratio is less than the magenta area’s aspect ratio,
    the resized image’s width should match the width of the magenta area. If the base
    image’s aspect ratio is greater, the resized image’s height should match the height
    of the magenta area. We then determine the other dimension by multiplying the
    base image’s height by the width ratio, or the base image’s width by the height
    ratio. This ensures that the resized image both completely covers the magenta
    area and remains proportional to its original aspect ratio.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `resize()` method once to produce a new Pillow `Image` object resized
    to match either the width of the base image or the height of the base image. The
    first argument is a (width, height) tuple for the new image’s size. The second
    argument is the `Image.NEAREST` constant from the Pillow library that tells the
    `resize()` method to use the nearest neighbor algorithm when resizing the image.
    This prevents the `resize()` method from blending the colors of the pixels to
    produce a smooth image.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want this, because it could blur the magenta pixels with neighboring
    non-magenta pixels in the resized image. Our `makeDroste()` function relies on
    detecting magenta pixels with the exact RGB color of (255, 0, 255) and would ignore
    these slightly off magenta pixels. The end result would be a pinkish outline around
    the magenta areas that would ruin our image. The nearest neighbor algorithm doesn’t
    do this blurring, leaving our magenta pixels exactly at the (255, 0, 255) magenta
    color.
  prefs: []
  type: TYPE_NORMAL
- en: Recursively Placing the Image Within the Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the base image has been resized, we can place the resized image over the
    base image. But the pixels from the resized image should be placed over only magenta
    pixels in the base image. The resized image will be placed such that the top-left
    corner of the resized image is at the top-left corner of the magenta area:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Two nested `for` loops iterate over every pixel in the magenta area. Remember
    that the magenta area does not have to be a perfect rectangle, so we check whether
    the pixel at the current coordinates is magenta. If so, we get the pixel color
    from the corresponding coordinates in the resized image and place it on the base
    image. After the two nested `for` loops have finished looping, the magenta pixels
    in the base image will have been replaced by pixels from the resized image.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the resized image itself could have magenta pixels, and if so, these
    will now become part of the base image, as in the top-right image of [Figure 14-2](#figure14-2).
    We’ll need to pass the modified base image to a recursive `makeDroste()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: This line is the recursive call in our recursive algorithm, and it’s the last
    line of code in the `makeDroste()` function. This recursion handles the new magenta
    area copied from the resized image. Note that the value passed for the `stopAfter`
    parameter is `stopAfter - 1`, ensuring that it comes closer to the base case of
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the Droste Maker program begins by passing `′museum.png′` to `makeDroste()`
    to get the Pillow `Image` object of the recursive image. We save this as a new
    image file named *museum-recursive.png*and display the recursive image in a new
    window for the user to view:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: You can change these filenames to whichever image on your computer you’d like
    to use with the program.
  prefs: []
  type: TYPE_NORMAL
- en: Does the `makeDroste()` function need to be implemented with recursion? Simply
    put, no. Notice that no tree-like structure is involved in the problem, and the
    algorithm does no backtracking, which is a sign that recursion may be an overengineered
    approach to this code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter’s project was a program that produces recursive Droste effect images,
    just like the illustration on old tins of Droste’s Cacao. The program works by
    using pure magenta pixels with RGB values of (255, 0, 255) to mark the parts of
    the image that should be replaced by a smaller version. Since this smaller version
    will also have its own smaller magenta area, the replacements will repeat until
    the magenta area is gone to produce a recursive image.
  prefs: []
  type: TYPE_NORMAL
- en: The base case for our recursive algorithm occurs when no more magenta pixels
    remain in the image to place the smaller recursive image in, or when the `stopAfter`
    counter reaches `0`. Otherwise, the recursive case passes the image to the `makeDroste()`
    function to continue to replace the magenta area with even smaller recursive images.
  prefs: []
  type: TYPE_NORMAL
- en: You can modify your own photos to add magenta pixels and then run them through
    the Droste Maker. The museum patron looking at an exhibit of themself, the cat
    in front of a computer monitor of the cat in front of a computer monitor, and
    the faceless *Mona Lisa* images are just a few examples of the surreal possibilities
    you can create with this recursive program.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Wikipedia article for the Droste effect at [https://en.wikipedia.org/wiki/Droste_effect](https://en.wikipedia.org/wiki/Droste_effect)
    has examples of products other than Droste’s Cacao that use the Droste effect.
    Dutch artist M.C. Escher’s *Print Gallery* is a famous example of a scene that
    also contains itself, and you can learn more about it at [https://en.wikipedia.org/wiki/Print_Gallery_(M._C._Escher)](https://en.wikipedia.org/wiki/Print_Gallery_(M._C._Escher)).
  prefs: []
  type: TYPE_NORMAL
- en: In a video titled “The Neverending Story (and Droste Effect)” on the Numberphile
    YouTube channel, Dr. Clifford Stoll discusses recursion and the Droste’s Cacao
    box art at [https://youtu.be/EeuLDnOupCI](https://youtu.be/EeuLDnOupCI).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19 of my book *Automate the Boring Stuff with Python*, 2nd edition (No
    Starch Press, 2019) provides a basic tutorial of the Pillow library at [https://automatetheboringstuff.com/2e/chapter19](https://automatetheboringstuff.com/2e/chapter19).``
  prefs: []
  type: TYPE_NORMAL

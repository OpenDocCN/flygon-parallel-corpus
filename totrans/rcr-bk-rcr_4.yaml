- en: Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分
- en: Projects
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 项目
- en: '10'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: File Finder
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 文件查找器
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, you’ll write your own recursive program to search for files
    according to custom needs. Your computer already has some file-searching commands
    and apps, but often they’re limited to retrieving files based on a partial filename.
    What if you need to make esoteric, highly specific searches? For example, what
    if you need to find all files that have an even number of bytes, or files with
    names that contain every vowel?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将编写自己的递归程序，根据自定义需求搜索文件。你的计算机已经有一些文件搜索命令和应用程序，但通常它们只能根据部分文件名检索文件。如果你需要进行奇特、高度特定的搜索怎么办？例如，如果你需要找到所有具有偶数字节的文件，或者文件名包含每个元音字母的文件？
- en: You likely will never need to do these searches specifically, but you’ll probably
    have odd search criteria someday. You’ll be out of luck if you can’t code this
    search yourself.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能永远不需要专门进行这些搜索，但是你可能会有奇怪的搜索条件。如果你不能自己编写这个搜索，你就会很倒霉。
- en: As you’ve learned, recursion is especially suited to problems that have a tree-like
    structure. The filesystem on your computer is like a tree, as you saw back in
    Figure 2-6. Each folder branches into subfolders, which in turn can branch into
    other subfolders. We’ll write a recursive function to navigate this tree.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所学到的，递归特别适用于具有树状结构的问题。你的计算机上的文件系统就像一棵树，就像你在图2-6中看到的那样。每个文件夹都分成子文件夹，这些子文件夹又可以分成其他子文件夹。我们将编写一个递归函数来遍历这棵树。
- en: The Complete File-Search Program
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的文件搜索程序
- en: 'Let’s begin by taking a look at the complete source code for the recursive
    file-search program. The rest of this chapter explains each section of code individually.
    Copy the source code for the file-search program to a file named *fileFinder.py*:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下递归文件搜索程序的完整源代码。本章的其余部分将逐个解释代码的每个部分。将文件搜索程序的源代码复制到名为*fileFinder.py*的文件中：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The file-search program’s main function is `walk()`, which “walks” across the
    entire span of files in a base folder and its subfolders. It calls one of two
    other functions that implement the custom search criteria it’s looking for. In
    the context of this program, we’ll call these *match functions*. A match function
    call returns `True` if the file matches the search criteria; otherwise, it returns
    `False`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 文件搜索程序的主要函数是`walk()`，它在基本文件夹及其子文件夹中“遍历”整个文件范围。它调用另外两个实现自定义搜索条件的函数中的一个。在这个程序的上下文中，我们将这些称为*匹配函数*。匹配函数调用返回`True`，如果文件符合搜索条件；否则，返回`False`。
- en: The job of the `walk()` function is to call the match function once for each
    file in the folders it walks across. Let’s take a look at the code in more detail.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk()`函数的工作是为它遍历的每个文件夹中的每个文件调用匹配函数。让我们更详细地看一下代码。'
- en: The Match Functions
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配函数
- en: 'In Python, you can pass functions themselves as arguments to a function call.
    In the following example, a `callTwice()` function calls its function argument
    twice, whether it’s `sayHello()` or `sayGoodbye()`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你可以将函数本身作为参数传递给函数调用。在下面的示例中，`callTwice()`函数调用其函数参数两次，无论是`sayHello()`还是`sayGoodbye()`：
- en: '**Python**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `callTwice()` function calls whichever function was passed to it as the
    `func` parameter. Notice that we leave out the parentheses from the function argument,
    writing `callTwice(sayHello)` instead of `callTwice(sayHello())`. This is because
    we are passing the `sayHello()` function itself, and not calling `sayHello()`
    and passing its return value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`callTwice()`函数调用作为`func`参数传递给它的任何函数。请注意，我们从函数参数中省略了括号，而是写成`callTwice(sayHello)`，而不是`callTwice(sayHello())`。这是因为我们传递的是`sayHello()`函数本身，而不是调用`sayHello()`并传递其返回值。'
- en: The `walk()` function accepts a match function argument for its search criteria.
    This lets us customize the behavior of the file search without modifying the code
    of the `walk()` function itself. We’ll take a look at `walk()` later. First, let’s
    look at the two sample match functions in the program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk()`函数接受一个匹配函数参数作为其搜索条件。这使我们能够自定义文件搜索的行为，而无需修改`walk()`函数本身的代码。我们稍后会看一下`walk()`。首先，让我们看一下程序中的两个示例匹配函数。'
- en: Finding the Files with an Even Number of Bytes
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找具有偶数字节的文件
- en: 'The first matching function finds files with an even byte size:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个匹配函数找到具有偶数字节大小的文件：
- en: '**Python**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We import the `os` module, which is used throughout the program to get information
    about the files on your computer through functions such as `getsize()`, `basename()`,
    and others. Then we create a match function named `hasEvenByteSize()`. All match
    functions take a single string argument named `fullFilePath`, and return either
    `True` or `False` to signify a match or miss.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`os`模块，该模块在整个程序中用于通过`getsize()`、`basename()`等函数获取有关计算机上文件的信息。然后我们创建一个名为`hasEvenByteSize()`的匹配函数。所有匹配函数都接受一个名为`fullFilePath`的字符串参数，并返回`True`或`False`来表示匹配或不匹配。
- en: 'The `os.path.getsize()` function determines the size of the file in `fullFilePath`
    in bytes. Then we use the `%` modulus operator to determine whether this number
    is even. If it’s even, the `return` statement returns `True`; if it’s odd, it
    returns `False`. For example, let’s consider the size of the Notepad application
    that comes with the Windows operating system (on macOS or Linux, try running this
    function on the */bin/ls* program):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.getsize()`函数确定`fullFilePath`中文件的大小（以字节为单位）。然后我们使用`%`模运算符来确定这个数字是否是偶数。如果是偶数，`return`语句返回`True`；如果是奇数，返回`False`。例如，让我们考虑Windows操作系统中附带的记事本应用程序的大小（在macOS或Linux上，尝试在*/bin/ls*程序上运行这个函数）：'
- en: '**Python**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `hasEvenByteSize()` match function can use any Python function to find more
    information about the `fullFilePath` file. This gives you the powerful capability
    to write code for any search criteria you want. As `walk()` calls the match function
    for each file in the folder and subfolders it walks across, the match function
    returns `True` or `False` for each one. This tells `walk()` whether the file is
    a match.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasEvenByteSize()`匹配函数可以使用任何Python函数来查找有关`fullFilePath`文件的更多信息。这使您能够为任何搜索条件编写代码。当`walk()`对文件夹和子文件夹中的每个文件调用匹配函数时，匹配函数会为每个文件返回`True`或`False`。这告诉`walk()`文件是否匹配。'
- en: Finding the Filenames That Contain Every Vowel
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找包含所有元音字母的文件名
- en: 'Let’s take a look at the next match function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看下一个匹配函数：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We call `os.path.basename()` to remove the folder names from the filepath. Python
    does case-sensitive string comparisons, which ensures that `hasEveryVowel()` doesn’t
    miss any vowels in the filename because they are uppercase. For example, calling
    `os.path.basename('C:/Windows/system32/notepad.exe')` returns the string `notepad.exe`.
    This string’s `lower()` method call returns a lowercase form of the string so
    that we have to check for only lowercase vowels in it. “Useful Python Standard
    Library Functions for Working with Files” later in this chapter explores some
    more functions for finding out information about files.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`os.path.basename()`来从文件路径中删除文件夹名称。Python对字符串进行区分大小写的比较，这确保了`hasEveryVowel()`不会因为文件名中的元音字母是大写而漏掉任何元音字母。例如，调用`os.path.basename('C:/Windows/system32/notepad.exe')`返回字符串`notepad.exe`。这个字符串的`lower()`方法调用返回字符串的小写形式，这样我们只需要检查其中的小写元音字母。本章后面的“用于处理文件的有用Python标准库函数”探讨了一些更多用于获取文件信息的函数。
- en: We use a `return` statement with a lengthy expression that evaluates to `True`
    if `name` contains `a`, `e`, `i`, `o`, or `u`, indicating the file matches the
    search criteria. Otherwise, the `return` statement returns `False`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个带有长表达式的`return`语句，如果`name`包含`a`、`e`、`i`、`o`或`u`，则表达式求值为`True`，表示文件符合搜索条件。否则，`return`语句返回`False`。
- en: The Recursive walk() Function
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归`walk()`函数
- en: While the match functions check whether a file matches the search criteria,
    the `walk()` function finds all the files to check. The recursive `walk()` function
    is passed the name of a base folder to search along with a match function to call
    for each file in the folder.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配函数检查文件是否符合搜索条件，而`walk()`函数找到所有要检查的文件。递归的`walk()`函数会传入一个要搜索的基础文件夹的名称，以及一个要对文件夹中的每个文件调用的匹配函数。
- en: 'The `walk()` function also recursively calls itself for each subfolder in the
    base folder it’s searching. These subfolders become the base folder in the recursive
    call. Let’s ask the three questions about this recursive function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk()`函数也会递归地对基础文件夹中的每个子文件夹进行调用。这些子文件夹成为递归调用中的基础文件夹。让我们对这个递归函数提出三个问题：'
- en: What is the base case? When the function has finished processing each file and
    subfolder in its given base folder.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？当函数完成对给定基础文件夹中的每个文件和子文件夹的处理时。
- en: What argument is passed to the recursive function call? The base folder to search
    and the match function to use for finding matched files. For each subfolder in
    this folder, a recursive call is made with the subfolder as the new folder argument.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？要搜索的基础文件夹和用于查找匹配文件的匹配函数。对于该文件夹中的每个子文件夹，都会使用子文件夹作为新的文件夹参数进行递归调用。
- en: How does this argument become closer to the base case? Eventually, the function
    either recursively calls itself on all the subfolders or encounters base folders
    that don’t have any subfolders.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何变得更接近基本情况？最终，函数要么在所有子文件夹上递归调用自身，要么遇到没有任何子文件夹的基础文件夹。
- en: '[Figure 10-1](#figure10-1) shows an example filesystem along with the recursive
    calls to `walk()`, which it makes with a base folder of `C:\`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-1](#figure10-1)显示了一个示例文件系统以及对`walk()`的递归调用，它以`C:\`为基础文件夹进行调用。'
- en: '![Graphic depicting each folder in a filesystem and the corresponding calls
    to the walk() function. The base folder, C:\, corresponds to “walk(‘C:\\’, hasEvenByteSize).”
    The folder “spam” corresponds to “walk(‘C:\\spam’, hasEvenByteSize).” Within “spam,”
    the folder “eggs” corresponds to “walk(‘C:\\eggs’, hasEvenByteSize),” and the
    folder “ham” corresponds “walk(‘C:\\spam\\ham’, hasEvenByteSize).” Within “eggs,”
    the folder “bacon” corresponds to “walk(‘C\\spam\\eggs\\bacon’, hasEvenByteSize).”](image_fi/502024c10/f10001.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图形描绘了文件系统中每个文件夹以及对`walk()`函数的相应调用。基础文件夹C:\对应于“walk(‘C:\\’, hasEvenByteSize)”。文件夹“spam”对应于“walk(‘C:\\spam’,
    hasEvenByteSize)”。在“spam”中，文件夹“eggs”对应于“walk(‘C:\\eggs’, hasEvenByteSize)”，文件夹“ham”对应于“walk(‘C:\\spam\\ham’,
    hasEvenByteSize)”。在“eggs”中，文件夹“bacon”对应于“walk(‘C\\spam\\eggs\\bacon’, hasEvenByteSize)”](image_fi/502024c10/f10001.png)'
- en: 'Figure 10-1: An example filesystem and the recursive `walk()` function calls
    over it'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1：一个示例文件系统和递归的`walk()`函数对其的调用
- en: 'Let’s take a look at the `walk()` function’s code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`walk()`函数的代码：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `walk()` function has two parameters: `folder` is a string of the base
    folder to search (we can pass `''.''` to refer to the current folder the Python
    program is run from), and `matchFunc` is a Python function that is passed a filename
    and returns `True` if the function says it is a search match. Otherwise, the function
    returns `False`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk()`函数有两个参数：`folder`是要搜索的基础文件夹的字符串（我们可以传入''.''来指代Python程序所在的当前文件夹），`matchFunc`是一个Python函数，它接受一个文件名并在函数说它是搜索匹配时返回`True`。否则，函数返回`False`。'
- en: 'The next part of the function examines the contents of `folder`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的下一部分检查`folder`的内容：
- en: '**Python**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `for` loop calls `os.listdir()` to return a list of the contents of the
    `folder` folder. This list includes all files and subfolders. For each file, we
    create the full, absolute path by joining the folder with the name of the file
    or folder. If the name refers to a file, the `os.path.isfile()` function call
    returns `True`, and we’ll check to see if the file is a search match:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We call the match function, passing it the full absolute filepath of the `for`
    loop’s current file. Note that `matchFunc` is the name of one of `walk()`’s parameters.
    If `hasEvenByteSize()`, `hasEveryVowel()`, or another function is passed as the
    argument for the `matchFunc` parameter, then that is the function `walk()` calls.
    If `filepath` contains a file that is a match according to the matching algorithm,
    it’s added to the `matches` list:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Otherwise, if the `for` loop’s file is a subfolder, the `os.path.isdir()` function
    call returns `True`. We then pass the subfolder to a recursive function call.
    The recursive call returns a list of all matching files in the subfolder (and
    its subfolders), which are then added to the `matches` list:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After the `for` loop finishes, the `matches` list contains all the matching
    files in this folder (and in all its subfolders). This list becomes the return
    value for the `walk()` function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Calling the walk() Function
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve implemented the `walk()` function and some match functions,
    we can run our custom file search. We pass the `''.''` string, a special directory
    name meaning *the current directory*, for the first argument to `walk()` so that
    it uses the folder the program was run from as the base folder to search:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of this program depends on what files are on your computer, but
    this demonstrates how you can write code for any search criteria you have. For
    example, the output could look like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Useful Python Standard Library Functions for Working with Files
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a look at some functions that could help you as you write your own
    match functions. The standard library of modules that comes with Python features
    several useful functions for getting information about files. Many of these are
    in the `os` and `shutil` modules, so your program must run `import os` or `import
    shutil` before it can call these functions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Finding Information About the File’s Name
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The full filepath passed to the match functions can be broken into the base
    name and directory name with the `os.path.basename()` and `os.path.dirname()`
    functions. You can also call `os.path.split()` to obtain these names as a tuple.
    Enter the following into Python’s interactive shell. On macOS or Linux, try using
    `/bin/ls` as the filename:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can use any of Python’s string methods on these string values to help evaluate
    the file against your search criteria, such as `lower()` in the `hasEveryVowel()`
    match function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Finding Information About the File’s Timestamps
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Files have timestamps indicating when they were created, last modified, and
    last accessed. Python’s `os.path.getctime()`, `os.path.getmtime()`, and `os.path.getatime()`,
    respectively, return these timestamps as floating-point values indicating the
    number of seconds since the *Unix epoch*, midnight on January 1, 1970, in the
    Coordinated Universal Time (UTC) time zone. Enter the following into the interactive
    shell:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These float values are easy for programs to use since they’re just single numbers,
    but you’ll need functions from Python’s `time` module to make them simpler for
    humans to read. The `time.localtime()` function converts a Unix epoch timestamp
    into a `struct_time` object in the computer’s time zone. A `struct_time` object
    has several attributes whose names begin with `tm_` for obtaining date and time
    information. Enter the following into the interactive shell:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the `tm_mday` attribute is the day of the month, ranging from `1`
    to `31`. The `tm_wday` attribute is the day of the week, starting at `0` for Monday,
    `1` for Tuesday, and so on, up to `6` for Sunday.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`tm_mday`属性是月份的日期，范围是`1`到`31`。`tm_wday`属性是星期几，从星期一的`0`开始，星期二的`1`，依此类推，直到星期日的`6`。
- en: 'If you need a brief, human-readable string of the `time_struct` object, pass
    it to the `time.asctime()` function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要`time_struct`对象的简短、可读的字符串，请将其传递给`time.asctime()`函数：
- en: '**Python**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'While the `time.localtime()` function returns a `struct_time` object in the
    local time zone, the `time.gmtime()` function returns a `struct_time` object in
    the UTC or Greenwich Mean time zone. Enter the following into the interactive
    shell:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 而`time.localtime()`函数返回本地时区的`struct_time`对象，`time.gmtime()`函数返回UTC或格林威治标准时间时区的`struct_time`对象。将以下内容输入交互式shell：
- en: '**Python**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The interaction between these `os.path` functions (which return Unix epoch timestamps)
    and `time` functions (which return `struct_time` objects) can be confusing. [Figure
    10-2](#figure10-2) shows the chain of code starting from the filename string and
    ending with obtaining the individual parts of the timestamp.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`os.path`函数（返回Unix纪元时间戳）与`time`函数（返回`struct_time`对象）之间的交互可能会令人困惑。[图10-2](#figure10-2)显示了从文件名字符串开始的代码链，以获取时间戳的各个部分。
- en: '![Flowchart. Arrow points from “filename” to “os.path.getctime(), os.path.getmtime(),
    os.path.getatime()” to “time.localtime(), time.gmtime()” to “time.asctime(), .tm_year,
    .tm_mon, .tm_mday, .tm_wday, .tm_hour, .tm_min, .tm_sec.”](image_fi/502024c10/f10002.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![流程图。箭头从“文件名”指向“os.path.getctime()、os.path.getmtime()、os.path.getatime()”指向“time.localtime()、time.gmtime()”指向“time.asctime()、.tm_year、.tm_mon、.tm_mday、.tm_wday、.tm_hour、.tm_min、.tm_sec。”](image_fi/502024c10/f10002.png)'
- en: 'Figure 10-2: Going from the filename to the individual attributes of a timestamp'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2：从文件名到时间戳的各个属性
- en: Finally, the `time.time()` function returns the number of seconds since the
    Unix epoch to the current time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`time.time()`函数返回自Unix纪元以来到当前时间的秒数。
- en: Modifying Your Files
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改您的文件
- en: After the `walk()` function returns a list of files matching your search criteria,
    you may want to rename, delete, or perform another operation on them. The `shutil`
    and `os` modules in the Python standard library have functions to do this. Further,
    the `send2trash` third-party module can also send files to your operating system’s
    Recycle Bin, rather than permanently deleting them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk()`函数返回与您的搜索条件匹配的文件列表后，您可能希望对它们进行重命名、删除或执行其他操作。Python标准库中的`shutil`和`os`模块具有执行此操作的函数。此外，第三方模块`send2trash`也可以将文件发送到操作系统的回收站，而不是永久删除它们。'
- en: 'To move a file, call the `shutil.move()` function with two arguments. The first
    argument is the file to move, and the second is the folder to move it to. For
    example, you could call the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动文件，请使用`shutil.move()`函数并提供两个参数。第一个参数是要移动的文件，第二个是要将其移动到的文件夹。例如，您可以调用以下内容：
- en: '**Python**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `shutil.move()` function returns the string of the new filepath of the
    file. You can also specify a filename to move and rename the file at the same
    time:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutil.move()`函数返回文件的新文件路径字符串。您还可以指定文件名以同时移动和重命名文件：'
- en: '**Python**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the second argument lacks a folder, you can just specify a new name for
    the file to rename it in its current folder:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个参数缺少文件夹，您可以只指定一个新名称以在当前文件夹中重命名文件：
- en: '**Python**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the `shutil.move()` function both moves and renames files, similar
    to the way the Unix and macOS `mv` command both moves and renames files. There
    is no separate `shutil.rename()` function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`shutil.move()`函数既移动又重命名文件，类似于Unix和macOS的`mv`命令移动和重命名文件。没有单独的`shutil.rename()`函数。
- en: 'To copy a file, call the `shutil.copy()` function with two arguments. The first
    argument is the filename of the file to copy, and the second argument is the new
    name of the copy. For example, you could call the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制文件，请使用`shutil.copy()`函数并提供两个参数。第一个参数是要复制的文件的文件名，第二个参数是副本的新名称。例如，您可以调用以下内容：
- en: '**Python**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `shutil.copy()` function returns the name of the copy. To delete a file,
    call the `os.unlink()` function and pass it the name of the file to delete:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutil.copy()`函数返回副本的名称。要删除文件，请调用`os.unlink()`函数并将要删除的文件的名称传递给它：'
- en: '**Python**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The name *unlink* is used instead of *delete* because of the technical detail
    that it removes the filename linked to the file. But since most files have only
    one linked filename, this unlinking also deletes the file. It’s all right if you
    don’t understand these filesystem concepts; just know that `os.unlink()` deletes
    a file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*unlink*而不是*delete*的名称是因为它删除了与文件链接的文件名的技术细节。但由于大多数文件只有一个链接的文件名，这种取消链接也会删除文件。如果您不理解这些文件系统概念，也没关系，只需知道`os.unlink()`会删除文件。
- en: Calling `os.unlink()` permanently deletes the file, which can be dangerous if
    a bug in your program causes the function to delete the wrong file. Instead, you
    can use the `send2trash` module’s `send2trash()` function to put the file in your
    operating system’s Recycle Bin. To install this module, run `run python -m pip
    install --user send2trash` from the command prompt on Windows or run `run python3
    -m pip install` from the terminal on macOS or Linux. Once the module is installed,
    you’ll be able to import it with `import send2trash`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`os.unlink()`会永久删除文件，如果程序中的错误导致函数删除错误的文件，这可能是危险的。相反，您可以使用`send2trash`模块的`send2trash()`函数将文件放入操作系统的回收站。要安装此模块，请在Windows命令提示符上运行`run
    python -m pip install --user send2trash`，或在macOS或Linux终端上运行`run python3 -m pip
    install`。安装模块后，您将能够使用`import send2trash`导入它。
- en: 'Enter the following into the interactive shell:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容输入交互式shell：
- en: '**Python**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This example creates a blank file named *deleteme.txt*. After calling `send2trash.send2trash()`
    (the module and function share the same name), this file is removed to the Recycle
    Bin.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例创建一个名为*deleteme.txt*的空文件。调用`send2trash.send2trash()`（模块和函数同名），此文件将被移除到回收站。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter’s file-search project uses recursion to “walk” across the contents
    of a folder and all its subfolders. The file-finder program’s `walk()` function
    navigates these folders recursively, applying custom search criteria to every
    file in every subfolder. The search criteria are implemented as match functions,
    which are passed to the `walk()` function. This allows us to change the search
    criteria by writing new functions instead of modifying the code in `walk()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Our project had two match functions, for finding files with an even byte file
    size or containing every vowel in its name, but you can write your own functions
    to pass to `walk()`. This is the power behind programming; you can create features
    for your own needs that are not available in commercial apps.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The documentation for Python’s built-in `os.walk()` function (similar to the
    `walk()` function in the file-finder project) is at [https://docs.python.org/3/library/os.html#os.walk](https://docs.python.org/3/library/os.html#os.walk).
    You can also learn more about your computer’s filesystem and Python’s file functions
    in Chapter 9 of my book *Automate the Boring Stuff with Python*, 2nd edition (No
    Starch Press, 2019) at [https://automatetheboringstuff.com/2e/chapter9](https://automatetheboringstuff.com/2e/chapter9).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The `datetime` module in the Python standard library also has more ways to interact
    with timestamp data. You can learn more about it in Chapter 17 of *Automate the
    Boring Stuff with Python*, 2nd edition at [https://automatetheboringstuff.com/2e/chapter17](https://automatetheboringstuff.com/2e/chapter17).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maze Generator
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 described a recursive algorithm that solves mazes, but another recursive
    algorithm generates mazes. In this chapter, we’ll generate mazes in the same format
    as the maze-solver program in Chapter 4. So, whether you’re a fan of solving mazes
    or creating them, you’ll now have the power to apply programming to the task.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm works by visiting a starting space in the maze and then recursively
    visiting a neighboring space. The maze’s hallways are “carved out” of the maze
    as the algorithm continues to visit neighbors. If the algorithm reaches a dead
    end that has no neighboring spaces, it backtracks to earlier spaces until it finds
    an unvisited neighbor and continues visiting from there. By the time the algorithm
    backtracks to the starting space, the entire maze has been generated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The recursive backtracking algorithm we’ll use here produces mazes that tend
    to have long hallways (the maze spaces that connect branching intersections) and
    are fairly simple to solve. However, this algorithm is easier to implement than
    many other maze-generation algorithms, such as Kruskal’s algorithm or Wilson’s
    algorithm, so it serves as a good introduction to the topic.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The Complete Maze-Generator Program
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin by taking a look at the complete Python and JavaScript source code
    for the program, which uses the recursive backtracking algorithm for maze generation.
    The rest of this chapter explains each section of code individually.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy this Python code to a file named *mazeGenerator.py*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Copy this JavaScript code to a file named *mazeGenerator.html*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you run this program, it produces a large amount of text that will fill
    the terminal window or browser with each step of the maze’s construction. You’ll
    have to scroll back up to the top to view the entire output.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The maze data structure begins as a completely filled-in 2D space. The recursive
    backtracker algorithm is given a starting point in this maze and then visits a
    previously unvisited neighboring space, “carving out” any hallway space in the
    process. Then it recursively calls itself on a neighboring space it hasn’t visited
    before. If all the neighboring spaces have already been visited, the algorithm
    is at a dead end and backtracks to an earlier visited space to visit its unvisited
    neighbors. The program ends when the algorithm backtracks to its starting location.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫数据结构开始时是一个完全填满的二维空间。递归回溯算法在这个迷宫中给出一个起始点，然后访问一个先前未访问的相邻空间，在这个过程中“挖出”任何走廊空间。然后它在一个以前未访问过的相邻空间上递归调用自身。如果所有相邻空间都已经被访问过，算法就会陷入死胡同，并回溯到先前访问过的空间以访问它的未访问的邻居。当算法回溯到起始位置时，程序结束。
- en: You can see this algorithm in action by running the maze-generator program.
    As the maze is carved out, it displays the current x, y coordinates by using the
    `@` character. The process looks like [Figure 11-1](#figure11-1). Notice that
    the fifth image in the top-right corner has backtracked to an earlier space after
    reaching a dead end to explore a new neighboring direction from that space.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行迷宫生成器程序，您可以看到这个算法的运行过程。当迷宫被挖出时，它会使用`@`字符显示当前的x，y坐标。这个过程看起来像[图11-1](#figure11-1)。请注意，右上角的第五张图在到达死胡同后回溯到了一个先前的空间，以探索从那个空间的新邻居方向。
- en: '![Diagram showing a maze being created one line at a time. The line backtracks
    every time it encounters a dead end. It eventually fills the entire screen.](image_fi/502024c11/f11001.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![显示迷宫一行一行地创建的图表。每次遇到死胡同时，该行都会回溯。最终填满整个屏幕。](image_fi/502024c11/f11001.png)'
- en: 'Figure 11-1: The maze as it gets “carved out” by the recursive backtracking
    algorithm'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1：递归回溯算法“挖出”的迷宫
- en: Let’s take a look at the code in more detail.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下代码。
- en: Setting Up the Maze Generator’s Constants
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置迷宫生成器的常量
- en: 'The maze generator uses several constants, which we can change before running
    the program to alter the size and appearance of the maze. The Python code for
    these constants is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫生成器使用了几个常量，我们可以在运行程序之前更改这些常量以改变迷宫的大小和外观。这些常量的Python代码如下：
- en: '**Python**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The JavaScript code is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The constants `WIDTH` and `HEIGHT` dictate the size of the maze. They must be
    odd numbers, because our maze data structure requires walls between the visited
    spaces of the maze, leaving us with odd-numbered dimensions. To make sure the
    `WIDTH` and `HEIGHT` constants are set correctly, we use assertions to stop the
    program if the constants aren’t odd or are too small.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`WIDTH`和`HEIGHT`决定了迷宫的大小。它们必须是奇数，因为我们的迷宫数据结构要求迷宫的访问空间之间有墙壁，留下奇数维度。为了确保`WIDTH`和`HEIGHT`常量被正确设置，我们使用断言来阻止程序如果常量不是奇数或太小的话。
- en: The program relies on a random seed value to reproduce the same maze, given
    the same seed value. The Python version of this program lets us set this value
    by calling the `random.seed()` function. Unfortunately, JavaScript doesn’t have
    a way to set the seed value explicitly and will generate different mazes each
    time we run the program.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 程序依赖于一个随机种子值来根据相同的种子值重现相同的迷宫。这个程序的Python版本让我们通过调用`random.seed()`函数来设置这个值。不幸的是，JavaScript没有一种明确设置种子值的方法，每次运行程序都会生成不同的迷宫。
- en: 'The Python code continues by setting a few more constants:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码继续设置一些常量：
- en: '**Python**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The JavaScript code for these constants is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量的JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `EMPTY` and `WALL` constants affect how the maze is displayed on the screen.
    The `MARK` constant is used to point out the position of the algorithm in the
    maze as it runs. The `NORTH`, `SOUTH`, `EAST`, and `WEST` constants represent
    the directions that the mark can move through the maze and are used to make the
    code more readable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`EMPTY`和`WALL`常量影响了迷宫在屏幕上的显示方式。`MARK`常量用于指出算法在迷宫中的位置。`NORTH`，`SOUTH`，`EAST`和`WEST`常量表示标记可以通过迷宫的方向，并用于使代码更易读。'
- en: Creating the Maze Data Structure
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建迷宫数据结构
- en: The maze data structure is a Python dictionary or JavaScript object that has
    keys of Python tuples or JavaScript arrays of the x, y coordinates of every space
    in the maze. The value for these keys is a string in the `WALL` or `EMPTY` constant.
    This string notes whether this space is a blocking wall or a passable empty space
    in the maze.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫数据结构是一个Python字典或JavaScript对象，它的键是Python元组或JavaScript数组，表示迷宫中每个空间的x，y坐标。这些键的值是`WALL`或`EMPTY`常量的字符串。这个字符串表示这个空间是迷宫中的阻挡墙还是可通过的空白空间。
- en: 'For example, the maze in [Figure 11-2](#figure11-2) is represented by the following
    data structure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图11-2](#figure11-2)中的迷宫由以下数据结构表示：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Diagram of a grid whose x- and y-axes are numbered 0 through 6, assigning
    each cell in the grid a numerical x and y value.](image_fi/502024c11/f11002.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![一个网格的图表，其x轴和y轴从0到6编号，为网格中的每个单元格分配了数值x和y。](image_fi/502024c11/f11002.png)'
- en: 'Figure 11-2: An example maze that can be represented by a data structure'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2：一个可以用数据结构表示的示例迷宫
- en: 'The program must start with every space set to `WALL`. The recursive `visit()`
    function then carves out the hallways and intersections of the maze by setting
    spaces to `EMPTY`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 程序必须从每个空间设置为`WALL`开始。然后递归的`visit()`函数通过将空间设置为`EMPTY`来挖出迷宫的走廊和交叉点：
- en: '**Python**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The corresponding JavaScript code is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We create the blank dictionary (in Python) or object (in JavaScript) in the
    `maze` global variable. The `for` loops loop over every possible x, y coordinate,
    setting each to `WALL` to create a completely filled-in maze. The call to `visit()`
    will carve out the hallways of the maze from this data structure by setting the
    spaces in it to `EMPTY`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Printing the Maze Data Structure
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To represent the maze as a data structure, the Python program uses a dictionary,
    and the JavaScript program uses an object. Within this structure, the keys are
    lists or arrays of two integers for the x- and y-coordinates, while the value
    is either the `WALL` or `EMPTY` single-character strings. Thus, we can access
    the wall or empty hallway space at the coordinates x, y in the maze as `maze[(x,
    y)]` in Python code and as `maze[[x, y]]` in JavaScript code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for `printMaze()` starts as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The JavaScript code for `printMaze()` starts as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `printMaze()` function prints the maze data structure it’s passed as the
    maze parameter on the screen. Optionally, if `markX` and `markY` integer arguments
    are passed, the `MARK` constant (which we set to `@`) appears at these x, y coordinates
    in the printed maze. To make sure the maze is printed in a monospace font, the
    JavaScript version writes the HTML tag `<code>` before printing the maze itself.
    Without this HTML tag, the maze will appear distorted in the browser.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Within the function, nested `for` loops loop over every space in the maze data
    structure. These `for` loops iterate over each y-coordinate from `0` up to, but
    not including, `HEIGHT`, and each x-coordinate from `0` up to, but not including,
    `WIDTH`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the inner `for` loop, if the current x, y coordinates match the position
    of the mark (the location where the algorithm is currently carving), the program
    displays the `@` in the `MARK` constant. The Python code does this as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The JavaScript code is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Otherwise, the program displays either the `WALL` or `EMPTY` constant’s character
    at this x, y coordinate in the `maze` data structure by printing `maze[(x, y)]`
    in Python and `maze[[x, y]]` in JavaScript. After the inner `for` loop is done
    looping over the x-coordinates, we print a newline at the end of the row in preparation
    for the next row.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Using the Recursive Backtracker Algorithm
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `visit()` function implements the recursive backtracker algorithm. The
    function has a list (in Python) or array (in JavaScript) that keeps track of the
    x, y coordinates that have already been visited by previous `visit()` function
    calls. It also in-place modifies the global `maze` variable that stores the maze
    data structure. The Python code for `visit()` begins as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The JavaScript code for `visit()` begins as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `visit()` function accepts x, y coordinates as arguments for the place in
    the maze the algorithm is visiting. Then the function changes the data structure
    in `maze` at this location to an empty space. To let the user see the progression
    of the maze generation, it calls `printMaze()`, passing the `x` and `y` arguments
    as the current position of the mark.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the recursive backtracker calls `visit()` with the coordinates of a previously
    unvisited neighboring space. The Python code continues as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The JavaScript code continues as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `while` loop continues to loop as long as unvisited neighbors remain for
    this location in the maze. We create a list or array of unvisited neighboring
    spaces in the `unvisitedNeighbors` variables. Four `if` statements check that
    the current x, y position is not on the border of the maze (so that we still have
    a neighboring space to check) and whether the neighboring space’s x, y coordinates
    don’t appear in the `hasVisited` list or array already.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'If all the neighbors have been visited, the function returns so that it can
    backtrack to an earlier space. The Python code continues on to check for the base
    case:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有相邻空间都已经被访问，函数将返回，以便可以回溯到较早的空间。Python代码继续检查基本情况：
- en: '**Python**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The JavaScript code does so as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下所示：
- en: '**JavaScript**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The base case for the recursive backtracking algorithm occurs when no unvisited
    neighbors remain to visit next. In this case, the function simply returns. The
    `visit()` function itself has no return value. Rather, the recursive function
    calls `visit()` to modify the maze data structure in the global `maze` variable
    as a side effect. When the original function call to `maze()` returns, the `maze`
    global variable contains the completely generated maze.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 递归回溯算法的基本情况是当没有未访问的相邻空间时发生。在这种情况下，函数简单地返回。`visit()`函数本身没有返回值。相反，递归函数调用`visit()`以副作用的方式修改全局`maze`变量中的迷宫数据结构。当对`maze()`的原始函数调用返回时，`maze`全局变量包含完全生成的迷宫。
- en: 'The Python code continues on to the recursive case like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码继续到这样的递归情况：
- en: '**Python**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The JavaScript code continues as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下继续：
- en: '**JavaScript**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `unvisitedNeighbors` list or array contains one or more of the `NORTH`,
    `SOUTH`, `WEST`, and `EAST` constants. We choose one of these directions for the
    next recursive call to `visit()`, and then set the `nextX` and `nextY` variables
    with the coordinates of the neighboring space in this direction.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`unvisitedNeighbors`列表或数组包含一个或多个`NORTH`、`SOUTH`、`WEST`和`EAST`常量。我们选择其中一个方向作为下一个递归调用`visit()`的方向，然后使用这个方向的相邻空间的坐标设置`nextX`和`nextY`变量。'
- en: After this, we add the x, y coordinates of `nextX` and `nextY` to the `hasVisited`
    list or array before making the recursive call for this neighboring space. In
    this way, the `visit()` function continues to visit neighboring spaces, carving
    out the maze hallways by setting locations in `maze` to `EMPTY`. The connecting
    hallway between the current space and neighboring space is also set to `EMPTY`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将`nextX`和`nextY`的x、y坐标添加到`hasVisited`列表或数组中，然后对这个相邻空间进行递归调用。这样，`visit()`函数将继续访问相邻空间，通过将`maze`中的位置设置为`EMPTY`来carve
    out迷宫走廊。当前空间和相邻空间之间的连接走廊也被设置为`EMPTY`。
- en: When no neighbors exist, the base case simply returns to an earlier location.
    In the `visit()` function, the execution jumps back to the start of the `while`
    loop. The code in the `while` loop again checks which neighboring spaces haven’t
    been visited and makes a recursive `visit()` call on one of them, or returns if
    all neighboring spaces have already been visited.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有相邻空间存在时，基本情况简单地返回到较早的位置。在`visit()`函数中，执行跳回到`while`循环的开始。`while`循环中的代码再次检查哪些相邻空间尚未被访问，并对其中一个进行递归`visit()`调用，或者如果所有相邻空间已经被访问，则返回。
- en: As the maze fills up with hallways and each space has been visited, the recursive
    calls will continue to return until the original `visit()` function call returns.
    At this point, the maze variable contains the completely generated maze.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 随着迷宫填满走廊并且每个空间都被访问，递归调用将继续返回，直到原始的`visit()`函数调用返回。此时，迷宫变量包含完全生成的迷宫。
- en: Starting the Chain of Recursive Calls
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始递归调用链
- en: 'The recursive `visit()` uses two global variables, `maze` and `hasVisited`.
    The `hasVisited` variable is a list or array containing the x, y coordinates of
    every space the algorithm has visited and begins with `(1, 1)` since that is the
    maze starting point. The Python code for this is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 递归`visit()`使用两个全局变量，`maze`和`hasVisited`。`hasVisited`变量是一个包含算法访问过的每个空间的x、y坐标的列表或数组，并且从`(1,
    1)`开始，因为那是迷宫的起点。这在Python代码中如下：
- en: '**Python**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The JavaScript code for this is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After setting up `hasVisited` to include the x, y coordinates of 1, 1 (the top-left
    corner of the maze), we call `visit()` with these coordinates. This function call
    will result in all the recursive function calls that generate the hallways of
    the maze. By the time this function call returns, `hasVisited` will contain every
    x, y coordinate of the maze, and `maze` will contain the completely generated
    maze.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置`hasVisited`以包括1, 1的x、y坐标（迷宫的左上角）之后，我们使用这些坐标调用`visit()`。这个函数调用将导致生成迷宫走廊的所有递归函数调用。当这个函数调用返回时，`hasVisited`将包含迷宫的每个x、y坐标，而`maze`将包含完全生成的迷宫。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: As you just learned, we can use recursion to not only solve mazes (by traversing
    them as tree data structures) but also generate them using the recursive backtracker
    algorithm. The algorithm “carves out” hallways in the maze, backtracking to earlier
    points when it encounters a dead end. Once the algorithm is forced to backtrack
    to the starting point, the maze is completely generated.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚学到的，我们不仅可以使用递归来解决迷宫问题（通过遍历它们作为树数据结构），还可以使用递归回溯算法来生成迷宫。该算法在迷宫中“carves out”走廊，在遇到死胡同时回溯到较早的点。一旦算法被迫回溯到起点，迷宫就完全生成了。
- en: We can represent a well-connected maze with no loops as a DAG—that is, a tree
    data structure. The recursive backtracker algorithm makes use of the idea that
    recursive algorithms are well suited to problems involving tree-like data structures
    and backtracking.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将没有循环的良好连接的迷宫表示为DAG——即树数据结构。递归回溯算法利用了递归算法适用于涉及树状数据结构和回溯的问题的思想。
- en: Further Reading
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Wikipedia has an entry on maze generation in general, with a section on the
    recursive backtracker algorithm, at [https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker](https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker).
    I’ve created a browser-based animation of the recursive backtracker algorithm
    that shows the “carving” of hallways in action at [https://scratch.mit.edu/projects/17358777](https://scratch.mit.edu/projects/17358777).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'If maze generation interests you, you should read *Mazes for Programmers: Code
    Your Own Twisty Little Passages* by Jamis Buck (Pragmatic Bookshelf, 2015).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sliding-Tile Solver
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: A *sliding-tile puzzle*, or *15-puzzle*, is a small puzzle game implemented
    as a set of 15 numbered sliding tiles on a 4 × 4 board. One tile is missing, allowing
    adjacent tiles to slide into the empty space on the board. The player’s goal is
    to move the tiles into numeric order, as in [Figure 12-1](#figure12-1). Some versions
    of this game have fragments of a picture on the tiles that create a whole image
    when the puzzle is complete.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![Image of two 4 × 4 grids of numbered tiles with one missing tile each. The
    first grid’s numbers are out of order. The second grid’s numbers are ordered 1–15
    from left to right.](image_fi/502024c12/f12001.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: Solving a numeric sliding-tile puzzle from its scrambled state
    (left) to its solved, ordered state (right)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, mathematicians have proven that even the hardest 15-puzzle can
    be solved in 80 moves.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Solving 15-Puzzles Recursively
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The algorithm that solves 15-puzzles is similar to the maze-solving algorithm.
    Each state of the board (that is, one arrangement of tiles) can be thought of
    as a maze intersection with four hallways to go down. In the case of 15-puzzles,
    sliding a tile in one of the four directions is like picking a hallway to follow
    to the next intersection.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Just as you can turn a maze into a DAG, you can convert a 15-puzzle into a tree
    graph, as in [Figure 12-2](#figure12-2). The board states are nodes with up to
    four edges (representing a direction to slide a tile) to other nodes (representing
    the resultant state). The root node is the starting state of the 15-puzzle. The
    solved-state node is the one in which the tiles are ordered correctly. The path
    from the root node to the solved state details the slides needed to solve the
    puzzle.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree graph in which each node is a 4 × 4 tile puzzle. The top node has two
    child nodes representing the two possible moves a player could make from that
    position, and each of those nodes has two child nodes representing all possible
    moves a player could make from those positions.](image_fi/502024c12/f12002.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: The task of solving a 15-puzzle can be represented as a graph
    with tile states as nodes and slides as edges.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Clever algorithms are available for solving 15-puzzles, but we could also just
    recursively explore the entire tree graph until we find a path from the root node
    to the solution node. This puzzle’s tree can be searched with a depth-first search
    (DFS) algorithm. However, unlike a well-connected maze, the 15-puzzle’s tree graph
    is not a DAG. Rather, the graph’s nodes are *undirected*, because you can traverse
    both directions of an edge by undoing the previous slide you made.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-3](#figure12-3) shows an example of the undirected edges between
    two nodes. Because it is possible to go back and forth between these two nodes
    forever, our 15-puzzle algorithm could encounter a stack overflow before it finds
    a solution.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Two tile puzzles. The tiles are positioned identically save for one, which
    has been slid downward in the second puzzle.](image_fi/502024c12/f12003.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3: The 15-puzzle has undirected edges (drawn without an arrowhead)
    between its nodes because slides can be undone by performing the opposite slide.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: To optimize our algorithm, we’ll avoid slides that undo the previous slide.
    However, this optimization alone won’t save the algorithm from a stack overflow.
    While it makes the *edges* in the tree graph directed, it doesn’t turn the puzzle-solver
    algorithm into a DAG, because it has cycles, or loops, from lower nodes to higher
    ones. These loops happen if you slide the tiles in a circular pattern, as in [Figure
    12-4](#figure12-4).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化我们的算法，我们将避免撤销上一次滑动的滑动。然而，仅凭这种优化无法使算法免受堆栈溢出的影响。虽然它使树图中的*边缘*变得有向，但它并不会将拼图求解算法转变为DAG，因为它具有从较低节点到较高节点的循环或循环。如果您以循环模式滑动瓷砖，就会发生这些循环，如[图12-4](#figure12-4)所示。
- en: '![Twelve tile puzzles connected by arrows that travel in a complete loop. In
    each subsequent puzzle, one tile is slid out of place until the state of the puzzle
    is the same as the starting puzzle’s state.](image_fi/502024c12/f12004.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![通过箭头连接的十二块瓷砖拼图，形成完整的循环。在每个后续拼图中，一块瓷砖被滑出原位，直到拼图的状态与起始拼图的状态相同。](image_fi/502024c12/f12004.png)'
- en: 'Figure 12-4: An example of a loop in the 15-puzzle’s graph'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-4：15拼图图中循环的一个例子
- en: Cycles in the graph mean that the later nodes at the bottom could loop back
    to a node at the top. Our solving algorithm could get “stuck” following this loop
    and never explore the branch that has the actual solution. In practice, this infinite
    loop would result in a stack overflow.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的循环意味着底部的后续节点可能会回到顶部的节点。我们的求解算法可能会在这个循环中“卡住”，永远不会探索具有实际解决方案的分支。在实践中，这个无限循环会导致堆栈溢出。
- en: We can still use recursion to solve a 15-puzzle. We just need to add our own
    base case for the maximum number of moves in order to avoid causing a stack overflow.
    Then, when the maximum number of slide moves is reached, the algorithm will begin
    backtracking to earlier nodes. If the 15-puzzle solver project can’t find a solution
    in every possible combination of 10 slides, it will try again using a maximum
    of 11 slides. If the puzzle can’t be solved in 11 moves, the project tries 12
    moves, and so on. This prevents the algorithm from getting stuck exploring the
    moves of an infinite loop instead of exploring possible solutions of fewer moves.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用递归来解决15拼图。我们只需要为最大移动次数添加自己的基本情况，以避免导致堆栈溢出。然后，当达到最大滑动次数时，算法将开始回溯到较早的节点。如果15拼图求解器项目无法在10次滑动的所有可能组合中找到解决方案，它将尝试使用最多11次滑动。如果拼图在11次移动中无法解决，项目将尝试12次移动，依此类推。这可以防止算法陷入探索无限循环移动而不是探索较少移动可能解决方案的困境。
- en: The Complete Sliding-Tile Solver Program
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的滑动瓷砖求解程序
- en: Let’s begin by taking a look at the complete source code for the sliding-tile
    puzzle solver program. The rest of this chapter explains each section of code
    individually.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下滑动瓷砖拼图求解程序的完整源代码。本章的其余部分将逐个解释代码的每个部分。
- en: 'Copy the Python version of the code to a file named *slidingTileSolver.py*:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码的Python版本复制到名为*slidingTileSolver.py*的文件中：
- en: '**Python**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Copy the JavaScript version of the code to a file named *slidingTileSolver.html*:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码的JavaScript版本复制到名为*slidingTileSolver.html*的文件中：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The program’s output looks like the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下所示：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that when JavaScript runs in a browser, the code must complete before it
    displays any output. Until then, it may appear to have frozen, and your browser
    might ask if you’d like to prematurely stop it. You can ignore this warning and
    let the program keep working until it has solved the puzzle.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当JavaScript在浏览器中运行时，代码必须在显示任何输出之前完成。在那之前，它可能会看起来已经冻结，您的浏览器可能会询问您是否想要提前停止它。您可以忽略这个警告，让程序继续工作，直到解决了拼图。
- en: The program’s recursive `attemptMove()` function solves sliding-tile puzzles
    by trying every possible combination of slides. The function is given a move to
    try. If this solves the puzzle, the function returns a Boolean `True` value. Otherwise,
    it calls `attemptMove()` with all the other possible moves it can make and returns
    a Boolean `False` value if none of them find a solution before exceeding the maximum
    number of moves. We’ll explore this function in more detail later.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的递归`attemptMove()`函数通过尝试每种可能的滑动组合来解决滑动瓷砖拼图。该函数给出一个要尝试的移动。如果这解决了拼图，函数将返回一个布尔值`True`。否则，它将调用`attemptMove()`以及它可以进行的所有其他可能移动，并在超过最大移动次数之前找不到解决方案时返回一个布尔值`False`。我们稍后将更详细地探讨这个函数。
- en: The data structure we use to represent a sliding-tile board is a list (in Python)
    or array (in JavaScript) of integers, with `0` representing the blank space. In
    our program, this data structure is often stored in a variable named `board`.
    The values at `board[y * SIZE + x]` match the tile at the x, y coordinates on
    the board, as depicted in [Figure 12-5](#figure12-5). For example, if the `SIZE`
    constant is `4`, the value at the x, y coordinates 3, 1 can be found at `board[1
    * 4 + 3]`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来表示滑动瓷砖板的数据结构是一个整数列表（在Python中）或数组（在JavaScript中），其中`0`表示空白空间。在我们的程序中，这个数据结构通常存储在一个名为`board`的变量中。`board[y
    * SIZE + x]`处的值与板上坐标x，y处的瓷砖匹配，如[图12-5](#figure12-5)所示。例如，如果`SIZE`常量为`4`，则在坐标3,
    1处的值可以在`board[1 * 4 + 3]`找到。
- en: This small calculation enables us to use a 1D array or list to store the values
    of a 2D tile board. This programming technique is useful not just in our project
    but for any 2D data structure that must be stored in an array or list, such as
    a 2D image stored as a stream of bytes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小计算使我们能够使用一维数组或列表来存储二维瓷砖板的值。这种编程技术不仅在我们的项目中有用，而且对于任何必须存储在数组或列表中的二维数据结构都很有用，比如以字节流存储的二维图像。
- en: '![Two sliding-tile puzzles. In the first, each tile and the blank space are
    represented by their x, y coordinates. In the second, the tiles and blank space
    are numbered from 0 to 15\. The coordinates correspond to the following numbered
    tiles: 0,0 corresponds to 0; 1,0 corresponds to 1; 2,0 corresponds to 2; 3,0 corresponds
    to 3; 0,1 corresponds to 4; 1,1 corresponds to 5; 2,1 corresponds to 6; 3,1 corresponds
    to 7; 0,2 corresponds to 8; 1,2 corresponds to 9; 2,2 corresponds to 10; 3,2 corresponds
    to 11; 0,3 corresponds to 12; 1,3 corresponds to 13; 2,3 corresponds to 14; 3,3
    (the blank space) corresponds to 15.](image_fi/502024c12/f12005.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-5: The x, y coordinates for each space on the board (left) and the
    corresponding data structure index (right)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some example data structures. The board with mixed-up tiles shown
    previously on the left side of [Figure 12-1](#figure12-1) would be represented
    by the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '`[15, 2, 1, 12, 8, 5, 6, 11, 4, 9, 10, 7, 3, 14, 13, 0]`'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The solved, ordered puzzle on the right side of [Figure 12-1](#figure12-1)
    would be represented by this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '`[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]`'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the functions in our program will expect board data structures that follow
    this format.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the 4 × 4 version of the sliding-tile puzzle has so many possible
    moves that it would take a normal laptop weeks to solve. You can change the `SIZE`
    constant from `4` to `3` to solve a simpler 3 × 3 version of the puzzle. The finished,
    ordered 3 × 3 puzzle’s data structure would look like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '`[1, 2, 3, 4, 5, 6, 7, 8, 0]`.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting Up the Program’s Constants
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the beginning of the source code, the program uses a few constants to make
    the code more readable. The Python code is as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The JavaScript code is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To have reproducible random numbers, the Python program sets the random number
    seed to `1`. The same seed value will always reproduce the same random puzzle,
    which is useful for debugging. You can change the seed value to any other integer
    to create different puzzles. JavaScript has no way to set its random seed value,
    and *slidingtilesolver.html* doesn’t have an equivalent feature.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The `SIZE` constant sets the size of the square board. You can change this size
    to anything, but 4 × 4 boards are standard, while 3 × 3 boards are useful for
    testing, because the program is quick to solve them. The `BLANK` constant is used
    in the puzzle data structure to represent the blank space and must be kept at
    `0`. The `UP`, `DOWN`, `LEFT`, and `RIGHT` constants are used to make the code
    readable, similar to the `NORTH`, `SOUTH`, `WEST`, and `EAST` constants in the
    maze-generator project in Chapter 11.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Representing the Sliding-Tile Puzzle as Data
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sliding-tile board’s data structure is just a list or array of integers.
    What makes it representative of an actual puzzle board is the way it’s used by
    the functions in the program. The `displayBoard()`, `getNewBoard()`, `findBlankSpace()`,
    and other functions in this program all deal with this data structure.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Board
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first function, `displayBoard()`, prints the board data structure on the
    screen. The Python code for the `displayBoard()` function is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The JavaScript code for the `displayBoard()` function is as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The pair of nested `for` loops iterate over every row and column on the board.
    The first `for` loop loops over the y-coordinates, and the second `for` loop loops
    over the x-coordinates. This is because the program needs to print all the columns
    of a single row before printing a newline character to move on to the next row.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement checks whether the tile at the current x, y coordinates is
    the blank tile. If it is, the program prints two underscores with a trailing space.
    Otherwise, the code in the `else` block prints the tile number with a trailing
    space. The trailing space is what separates the tile numbers from one another
    on the screen. If the tile number is a single digit, the `rjust()` or `padStart()`
    method will insert an extra space so that the tile number is aligned with the
    two-digit numbers on the screen.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句检查当前x、y坐标处的瓷砖是否为空白瓷砖。如果是，程序打印两个下划线并带有一个尾随空格。否则，`else`块中的代码打印带有尾随空格的瓷砖编号。尾随空格是屏幕上分隔瓷砖编号的内容。如果瓷砖编号是一个数字，`rjust()`或`padStart()`方法将插入一个额外的空格，以便瓷砖编号与屏幕上的两位数对齐。'
- en: 'For example, say the scrambled puzzle on the left side of [Figure 12-1](#figure12-1)
    is represented by this data structure:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设左侧的混乱拼图在[图12-1](#figure12-1)中由这个数据结构表示：
- en: '`[15, 2, 1, 12, 8, 5, 6, 11, 4, 9, 10, 7, 3, 14, 13, 0]`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`[15, 2, 1, 12, 8, 5, 6, 11, 4, 9, 10, 7, 3, 14, 13, 0]`'
- en: 'When the data structure is passed to `displayBoard()`, it prints the following
    text:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据结构传递给`displayBoard()`时，它会打印以下文本：
- en: '[PRE53]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Creating a New Board Data Structure
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的板数据结构
- en: 'Next, the `getNewBoard()` function returns a new board data structure with
    the tiles in their ordered, solved places. The Python code for the `getNewBoard()`
    function is as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`getNewBoard()`函数返回一个新的板数据结构，其中瓷砖放在它们有序的、解决的位置上。`getNewBoard()`函数的Python代码如下：
- en: '**Python**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The JavaScript code for the `getNewBoard()` function is as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNewBoard()`函数的JavaScript代码如下：'
- en: '**JavaScript**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE55]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `getNewBoard()` function returns a board data structure appropriate to the
    integer in the `SIZE` constant (either 3 × 3 or 4 × 4). The `for` loop generates
    this list or array with the integers from `1` up to, but not including, `SIZE`
    squared, with a `0` (the value stored in the `BLANK` constant) at the end to represent
    the blank space in the lower-right corner.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNewBoard()`函数返回适合于`SIZE`常量（3×3或4×4）中的整数的板数据结构。`for`循环生成这个列表或数组，其中包含从`1`到`SIZE`的平方，最后一个是`0`（存储在`BLANK`常量中的值），表示右下角的空白空间。'
- en: Finding the Coordinates of the Blank Space
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 找到空白空间的坐标
- en: 'Our program uses the `findBlankSpace()` function to find the x, y coordinates
    of the blank space on the board. The Python code is as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序使用`findBlankSpace()`函数来找到板上空白空间的x、y坐标。Python代码如下：
- en: '**Python**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE56]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The JavaScript code is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE57]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Like the `displayBoard()` function, the `findBlankSpace()` function has a pair
    of nested `for` loops. These `for` loops will loop over every position in the
    board data structure. When the `board[y * SIZE + x]` code finds the blank space,
    it returns the x- and y-coordinates as two integers in a Python list or JavaScript
    array.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 像`displayBoard()`函数一样，`findBlankSpace()`函数有一对嵌套的`for`循环。这些`for`循环将循环遍历板数据结构中的每个位置。当`board[y
    * SIZE + x]`代码找到空白空间时，它会以Python列表或JavaScript数组中的两个整数的形式返回x和y坐标。
- en: Making a Move
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行移动
- en: 'Next, the `makeMove()` function accepts two arguments: a board data structure
    and an `UP`, `DOWN`, `LEFT`, or `RIGHT` direction to slide a tile on that board.
    This code is fairly repetitive, so the short variable names `bx` and `by` are
    used to represent the x- and y-coordinates of the blank space.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`makeMove()`函数接受两个参数：一个板数据结构和一个`UP`、`DOWN`、`LEFT`或`RIGHT`方向，用于在该板上滑动一个瓷砖。这段代码相当重复，所以使用`bx`和`by`这样的简短变量名来表示空白空间的x和y坐标。
- en: 'To make a move, the board data structure swaps the value of the moved tile
    with the `0` of the blank tile. The Python code for the `makeMove()` function
    is as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行移动，板数据结构交换了移动瓷砖的值与空白瓷砖的`0`的值。`makeMove()`函数的Python代码如下：
- en: '**Python**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE58]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The JavaScript code for the `makeMove()` function is as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeMove()`函数的JavaScript代码如下：'
- en: '[PRE59]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `if` statements determine the index of the tile to move based on the `move`
    parameter. The function then “slides” a tile by swapping the `BLANK` value at
    `board[blankindex]` with the numbered tile at `board[tileIndex]`. The `makeMove()`
    function doesn’t return anything. Instead, it modifies the `board` data structure
    in place.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句根据`move`参数确定要移动的瓷砖的索引。然后，函数通过交换`board[blankindex]`处的`BLANK`值和`board[tileIndex]`处的编号瓷砖来“滑动”瓷砖。`makeMove()`函数不返回任何内容。相反，它直接修改了`board`数据结构。'
- en: Python has the `a, b = b, a` syntax to swap the value of two variables. For
    JavaScript, we need to envelop them in an array, such as `[a, b] = [b, a]` to
    perform the swap. We use this syntax at the end of the function to swap the values
    in `board[blankIndex]` and `board[tileIndex]` with each other.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Python有`a, b = b, a`的语法来交换两个变量的值。对于JavaScript，我们需要将它们包装在一个数组中，比如`[a, b] = [b,
    a]`来执行交换。我们在函数的最后使用这种语法来交换`board[blankIndex]`和`board[tileIndex]`中的值。
- en: Undoing a Move
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 撤消移动
- en: 'Next, as part of the backtracking in the recursive algorithm, our program needs
    to undo moves. This is as simple as making a move in the opposite direction as
    the initial move. The Python code for the `undoMove()` function is as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在递归算法的回溯部分，我们的程序需要撤消移动。这就像在与初始移动相反的方向上进行移动一样简单。`undoMove()`函数的Python代码如下：
- en: '**Python**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The JavaScript code for the `undoMove()` function is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`undoMove()`函数的JavaScript代码如下：'
- en: '**JavaScript**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE61]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We’ve already programmed the swapping logic into the `makeMove()` function,
    so `undoMove()` can just call that function for the direction opposite of the
    `move` argument. This way, a hypothetical `someMove` move made on a hypothetical
    `someBoard` data structure by the `makeMove(someBoard, someMove)` function call
    can be undone by calling `undoMove(someBoard, someMove)`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将交换逻辑编程到`makeMove()`函数中，所以`undoMove()`可以调用该函数来执行与`move`参数相反的方向。这样，通过`makeMove(someBoard,
    someMove)`函数调用在一个假设的`someBoard`数据结构上进行的假设的`someMove`移动可以通过调用`undoMove(someBoard,
    someMove)`来撤消。
- en: Setting Up a New Puzzle
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置一个新的谜题
- en: To create a new, scrambled puzzle, we cannot simply put the tiles in random
    places, because some configurations of tiles produce invalid, unsolvable puzzles.
    Instead, we need to start from a solved puzzle and make many random moves. Solving
    the puzzle becomes a matter of figuring out which slides will undo these random
    slides to get back to the original, ordered configuration.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: But it’s not always possible to make moves in each of the four directions. For
    example, if the blank space is in the bottom-right corner, as in [Figure 12-6](#figure12-6),
    tiles can slide only down or right because no tiles can slide left or up. Furthermore,
    if sliding the 7 tile in [Figure 12-6](#figure12-6) up was the previous move,
    then sliding it down is removed as a valid move because it would undo the previous
    move.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![Sliding-tile puzzle with a blank space in the lower-right corner. Arrows
    indicate the two possible moves: sliding the 7 tile down, and sliding the 13 tile
    to the right.](image_fi/502024c12/f12006.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-6: If the blank space is in the bottom-right corner, down and right
    are the only valid slide directions.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us, we need a `getValidMoves()` function that can tell us which slide
    directions are possible on a given board data structure:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The JavaScript code for this function is as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first thing the `getValidMoves()` function does is call `findBlankSpace()`
    and store the x, y coordinates of the blank space in the variables `blankx` and
    `blanky`. Next, the function sets up the `validMoves` variable with an empty Python
    list or empty JavaScript array to hold all the valid directions for a slide.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at [Figure 12-5](#figure12-5), a y-coordinate of `0` represents
    the top edge of the board. If `blanky`, the blank space’s y-coordinate, is not
    `0`, then we know the blank space is not on the top edge. If the previous move
    was also not `DOWN`, then *up* is a valid move, and the code adds `UP` to `validMoves`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the left edge has an x-coordinate of `0`, the bottom edge has a y-coordinate
    of `SIZE - 1`, and the right edge has an x-coordinate of `SIZE - 1`. Using the
    expression `SIZE - 1` ensures that this code works no matter whether the board
    is 3 × 3, 4 × 4, or any other size. The `getValidMoves()` function does these
    checks for all four directions and then returns `validMoves`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `getNewPuzzle()` function returns the data structure of a scrambled
    board for the program to solve. Tiles can’t simply be randomly placed on the board,
    because some configurations of tiles produce puzzles that are impossible to solve.
    To avoid this, the `getNewPuzzle()` function starts with an ordered, solved board
    and then applies a large number of random slides to it. Solving this puzzle is,
    in effect, figuring out the moves that undo these slides. The Python code for
    the `getNewPuzzle()` function is as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The JavaScript code is as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The call to `getNewBoard()` obtains a board data structure in the ordered, solved
    state. The `for` loop calls `getValidMoves()` to obtain a list of valid moves,
    given the current state of the board, and then calls `makeMove()` with a randomly
    selected move from the list. The `random.choice()` function in Python and the
    `Math.floor()` and `Math.random()` functions in JavaScript will handle the random
    selection from the `validMoves` list or array, no matter what combination of `UP`,
    `DOWN`, `LEFT`, and `RIGHT` values it contains.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: The `DIFFICULTY` constant determines how many random slides from `makeMove()`
    the `for` loop applies. The higher the integer in `DIFFICULTY`, the more scrambled
    the puzzle becomes. Even though this results in some moves that undo earlier moves
    by pure chance, such as sliding left and then immediately sliding right, with
    enough slides the function produces a thoroughly scrambled board. For testing
    purposes, `DIFFICULTY` is set to `40`, allowing the program to produce a solution
    in about a minute. For a more realistic 15-puzzle, you should change `DIFFICULTY`
    to `200`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: After the board data structure in `board` is created and scrambled, the `getNewPuzzle()`
    function returns it.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Recursively Solving the Sliding-Tile Puzzle
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the functions for creating and manipulating the puzzle data
    structure, let’s create the functions that solve the puzzle by recursively sliding
    the tiles in each possible direction and checking whether this produces a finished,
    ordered board.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: The `attemptMove()` function performs a single slide on a board data structure,
    then recursively calls itself once for each of the valid moves the board can make.
    Multiple base cases exist. If the board data structure is in a solved state, the
    function returns a Boolean `True` value; if the maximum number of moves has been
    reached, it returns a Boolean `False` value. Also, if a recursive call has returned
    `True`, then `attemptMove()` should return `True`, and if recursive calls for
    all the valid moves have returned `False`, then `attemptMove()` should return
    `False`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: The solve() Function
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `solve()` function takes a board data structure and maximum number of moves
    the algorithm should attempt before backtracking. Then it performs the first call
    to `attemptMove()`. If this first call to `attemptMove()` returns `True`, the
    code in `solve()` displays the series of steps that solves the puzzle. If it returns
    `False`, the code in `solve()` tells the user no solution was found with this
    maximum number of moves.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for `solve()` begins as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The JavaScript code for `solve()` begins as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `solve()` function has two parameters: `board` contains the data structure
    of the puzzle to solve, and `maxMoves` is the maximum number of moves the function
    should make to try to solve the puzzle. The `solutionMoves` list or array contains
    the sequence of `UP`, `DOWN`, `LEFT`, and `RIGHT` values that produce the solved
    state. The `attemptMove()` function modifies this list or array in place as it
    makes recursive calls. If the initial `attemptMove()` function finds a solution
    and returns `True`, `solutionMoves` contains the sequence of moves for the solution.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'The `solve()` function then makes the initial call to `attemptMove()`, and
    stores the `True` or `False` it returns in the solved variable. The rest of the
    `solve()` function handles these two cases:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The JavaScript code is as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If `attemptMove()` finds a solution, the program runs through all the moves
    gathered in the `solutionMoves` list or array and displays the board after each
    slide. This proves to the user that the moves collected by `attemptMove()` are
    the real solution to the puzzle. Finally, the `solve()` function itself returns
    `True`. If `attemptMove()` is unable to find a solution, the `solve()` function
    simply returns `False`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The attemptMove() Function
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a look at `attemptMove()`, the core recursive function behind our
    tile-solving algorithm. Remember the tree graph that a sliding-tile puzzle produces;
    calling `attemptMove()` for a certain direction is like traveling down that edge
    of this graph to the next node. A recursive `attemptMove()` call moves further
    down the tree. When this recursive `attemptMove()` call returns, it backtracks
    to a previous node. When `attemptMove()` has backtracked all the way to the root
    node, the program execution has returned to the `solve()` function.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for `attemptMove()` begins as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The JavaScript code for `attemptMove()` begins as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `attemptMove()` function has four parameters. The `board` parameter contains
    a tile puzzle board data structure to solve. The `movesMade` parameter contains
    a list or array that `attemptMove()` modifies in place, adding the `UP`, `DOWN`,
    `LEFT`, and `RIGHT` values that the recursive algorithm has made. If `attemptMove()`
    solves the puzzle, `movesMade` will contain the moves that led to the solution.
    This list or array is also what the `solutionMoves` variable in the `solve()`
    function refers to.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The `solve()` function uses its `maxMoves` variable as the `movesRemaining`
    parameter in the initial call to `attemptMove()`. Each recursive call passes `maxMoves
    - 1` for the next value of `maxMoves`, causing it to decrease as more recursive
    calls are made. When it becomes less than `0`, the `attemptMove()` function stops
    making additional recursive calls and returns `False`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `prevMove` parameter contains the `UP`, `DOWN`, `LEFT`, or `RIGHT`
    value that the previous call to `attemptMove()` made so that it doesn’t undo that
    move. For the initial call to `attemptMove()`, the `solve()` function passes Python’s
    `None` or JavaScript’s `null` value for this parameter, since no previous move
    exists.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: The beginning of the `attemptMove()` code checks for two base cases, returning
    `False` if `movesRemaining` has become less than `0`, and returning `True` if
    `board` is in the solved state. The `SOLVED_BOARD` constant contains a board in
    the solved state that we can compare to the data structure in `board`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of `attemptMove()` performs each of the valid moves it can do
    on this board. The Python code is as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The JavaScript code is as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `for` loop sets the move variable to each of the directions returned by
    `getValidMoves()`. For each move, we call `makeMove()` to modify the board data
    structure with the move and to add the move to the list or array in `movesMade`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code recursively calls `attemptMove()` to explore the range of all
    possible future moves within the depth set by `movesRemaining`. The board and
    `movesMade` variables are forwarded to this recursive call. The code sets the
    recursive call’s `movesRemaining` parameter to `movesRemaining - 1` so that it
    decreases by one. It also sets the `prevMode` parameter to `move` so that it doesn’t
    immediately undo the move just made.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: If the recursive call returns `True`, a solution exists and is recorded in the
    `movesMade` list or array. We call the `undoMove()` function so that `board` will
    contain the original puzzle after the execution returns to `solve()` and then
    return `True` to indicate a solution has been found.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for `attemptMove()` continues as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The JavaScript code is as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If `attemptMove()` returns `False`, no solution is found. In that case, we call
    `undoMove()` and remove the latest move from the `movesMade` list or array.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: All of this is done for each of the valid directions. If none of the calls to
    `attemptMove()` for these directions finds a solution before reaching the maximum
    number of moves, the `attemptMove()` function returns `False`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Solver
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `solve()` function is useful for kicking off the initial call to `attemptMove()`,
    but the program still needs to do some setup. The Python code for this is as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The JavaScript code for this setup is as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: First, the `SOLVED_BOARD` constant is set to an ordered, solved board as returned
    by `getNewBoard()`. This constant isn’t set at the top of the source code because
    the `getNewBoard()` function needs to be defined before it can be called.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Next, a random puzzle is returned from `getNewPuzzle()` and stored in the `puzzleBoard`
    variable. This variable contains the puzzle board data structure that will be
    solved. If you want to solve a specific 15-puzzle instead of a random one, you
    can replace the call to `getNewPuzzle()` with a list or array containing the puzzle
    you do want to solve.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'The board in `puzzleBoard` is displayed to the user, and the current time is
    stored in `startTime` so that the program can calculate the runtime of the algorithm.
    The Python code continues as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The JavaScript code is as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The program begins trying to solve the puzzle in `puzzleBoard` in a maximum
    of 10 moves. The infinite `while` loop calls `solve()`. If a solution is found,
    `solve()` prints the solution on the screen and returns `True`. In that case,
    the code here can break out of the infinite `while` loop and print the total runtime
    of the algorithm.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if `solve()` returns `False`, `maxMoves` is incremented by `1` and
    the loop calls `solve()` again. This lets the program try progressively longer
    combinations of moves to solve the puzzle. This pattern continues until `solve()`
    finally returns `True`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A 15-puzzle is a good example of adapting the principles of recursion to a real-world
    problem. Recursion can perform a depth-first search on the tree graph of states
    that a 15-puzzle produces to find the path to a solution state. However, a purely
    recursive algorithm won’t work, which was why we had to make certain adjustments.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: The problem arises because a 15-puzzle has a massive number of possible states
    and doesn’t form a DAG. The edges in this graph are undirected, and the graph
    contains loops, or cycles. Our solving algorithm needs to ensure that it doesn’t
    make moves that immediately undo the previous move, so that it traverses the graph
    in one direction. It also needs to have a maximum number of moves the algorithm
    is willing to make before it begins to backtrack; otherwise, the loops guarantee
    that the algorithm will eventually recurse too much and cause a stack overflow.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Recursion isn’t necessarily the best approach for solving sliding-tile puzzles.
    All but the easiest puzzles simply have too many combinations for a typical laptop
    to solve within a reasonable amount of time. However, I like the 15-puzzle as
    an exercise in recursion because it connects the theoretical ideas of DAGs and
    DFS into a real-world problem. While 15-puzzles were invented over a century ago,
    the advent of computers provides a rich tool for exploring techniques to solve
    these amusing toys.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Wikipedia entry for 15-puzzles at [https://en.wikipedia.org/wiki/15_puzzle](https://en.wikipedia.org/wiki/15_puzzle)
    details their history and mathematical background.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: You can find the Python source code for a playable version of the sliding-tile
    puzzle game in my book *The Big Book of Small Python Projects* (No Starch Press,
    2021) and online at [https://inventwithpython.com/bigbookpython/project68.html](https://inventwithpython.com/bigbookpython/project68.html).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fractal Art Maker
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 introduced you to programs that draw many well-known fractals with
    the `turtle` Python module, but you can also make your own fractal art with the
    project in this chapter. The Fractal Art Maker program uses Python’s `turtle`
    module to turn simple shapes into complex designs with minimal additional code.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The project in this chapter comes with nine example fractals, although you can
    also write new functions to create fractals of your design. Modify the example
    fractals to produce radically different artwork or write code from scratch to
    implement your own creative vision.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: The Built-in Fractals
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can direct your computer to create an unlimited number of fractals. [Figure
    13-1](#figure13-1) shows the nine fractals that come with the Fractal Art Maker
    program that we’ll use in this chapter. These are produced from functions that
    draw a simple square or equilateral triangle as the base shape, then introduce
    slight differences in their recursive configuration to produce completely different
    images.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '![Nine labeled turtle graphics screenshots. Four Corners: a square containing
    an intricate hexagonal pattern. Spiral Squares: a spiral created by overlapping
    gray and white squares. Double Spiral Squares: a spiral created by overlapping
    multiple sets of white and gray squares. Triangle Spiral: a spiral created by
    overlapping the outlines of triangles. Conway’s Game of Life: a white square partially
    filled in by smaller gray squares. Those smaller squares are partially filled
    in by smaller white-and-dark-gray squares. Sierpinski Triangle: a Sierpinski triangle,
    as seen in Chapters 1 and 9\. Wave: a wave created out of many smaller triangles
    and wave shapes. Horn: a gray-and-white-striped spiral horn shape. Snowflake:
    a snowflake shape.](image_fi/502024c13/f13001.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: The nine example fractals that come with the Fractal Art Maker
    program'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: You can produce all of these fractals by setting the `DRAW_FRACTAL` constant
    at the top of the program to an integer from `1` to `9` and then running the Fractal
    Art Maker program. You can also set `DRAW_FRACTAL` to `10` or `11` to draw the
    basic square and triangle shapes, respectively, that compose these fractals, as
    shown in [Figure 13-2](#figure13-2).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '![Two turtle graphics screenshots, one showing a square and the other showing
    the outline of an equilateral triangle.](image_fi/502024c13/f13002.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: The results of calling `drawFilledSquare()` (left) and `drawTriangleOutline()`
    (right) on their own'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'These shapes are fairly simple: a square filled with either white or gray,
    and a simple outline of a triangle. The `drawFractal()` function uses these basic
    shapes to create amazing fractals.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: The Fractal Art Maker Algorithm
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Fractal Art Maker’s algorithm has two major components: a shape-drawing
    function and the recursive `drawFractal()` function.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: The shape-drawing function draws a basic shape. The Fractal Art Maker program
    comes with the two shape-drawing functions shown previously in [Figure 13-2](#figure13-2),
    `drawFilledSquare()` and `drawTriangleOutline()`, but you can also create your
    own. We pass a shape-drawing function to the `drawFractal()` function as an argument,
    just as we passed the match functions to the file finder’s `walk()` function in
    Chapter 10.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'The `drawFractal()` function also has a parameter indicating changes to the
    size, position, and angle of the shapes between recursive calls to `drawFractal()`.
    We’ll cover these specific details later in this chapter, but let’s look at one
    example: fractal 7, which draws a wave-like image.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: The program produces the Wave fractal by calling the `drawTriangleOutline()`
    shape-drawing function, which creates a single triangle. The additional arguments
    to `drawFractal()` tell it to make three recursive calls to `drawFractal()`. [Figure
    13-3](#figure13-3) shows the triangle produced by the original call to `drawFractal()`
    and the triangles produced by the three recursive calls.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '![Two turtle graphics screenshots. The first shows the outline of an equilateral
    triangle. The second shows that same triangle outline, as well as three additional,
    smaller equilateral triangles: two above the first, and the third below it and
    rotated slightly to the left.](image_fi/502024c13/f13003.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: The triangle produced by the first call to `drawFractal()` (left)
    and the first set of three recursive calls (right)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: The first recursive call tells `drawFractal()` to call `drawTriangleOutline()`
    but with a triangle that is half the size and positioned to the top left of the
    previous triangle. The second recursive call produces a triangle to the top right
    of the previous triangle that is 30 percent of its size. The third recursive call
    produces a triangle below the previous triangle that is half its size and rotated
    15 degrees compared to it.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Each of these three recursive calls to `drawFractal()` makes three more recursive
    calls to `drawFractal()`, producing nine new triangles. The new triangles have
    the same changes to their size, position, and angle relative to their previous
    triangle. The top-left triangle is always half the size of the previous triangle,
    while the bottom triangle is always rotated 15 degrees more. [Figure 13-4](#figure13-4)
    shows the triangles produced by the first and second levels of recursion.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '![Two turtle graphics screenshots. The first shows the same four triangles
    shown in Figure 13-3\. The second shows three smaller triangles clustered in the
    same pattern around each of the three new triangles.](image_fi/502024c13/f13004.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: The first level of recursive calls to `drawFractal()` (left) and
    the nine new triangles of the second level of recursive calls (right)'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: The nine calls to `drawFractal()` that produce these nine new triangles each
    make three recursive calls to `drawFractal()`, producing 27 new triangles at the
    next level of recursion. As this pattern of recursion continues, eventually the
    triangles become so small that `drawFractal()` stops making new recursive calls.
    This is one of the base cases for the recursive `drawFractal()` function. The
    other occurs when the recursive depth reaches a specified level. Either way, these
    recursive calls produce the final Wave fractal in [Figure 13-5](#figure13-5).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics screenshot of the Wave fractal.](image_fi/502024c13/f13005.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: The final Wave fractal after each triangle recursively generates
    three more triangles'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: The nine example fractals in [Figure 13-1](#figure13-1) that come with the Fractal
    Art Maker are made with just two shape-drawing functions and a few changes to
    the arguments to `drawFractal()`. Let’s take a look at the Fractal Art Maker’s
    code to see how it accomplishes this.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: The Complete Fractal Art Maker Program
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enter the following code into a new file and save it as [fractalArtMaker.py](http://fractalArtMaker.py).
    This program relies on Python’s built-in `turtle` module, so no JavaScript code
    is used for this chapter’s project:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: When you run this program, it will show the first of nine fractal images from
    [Figure 13-1](#figure13-1). You can change the `DRAW_FRACTAL` constant at the
    beginning of the source code to any integer from `1` to `9` and run the program
    again to see a new fractal. After learning how the program works, you’ll also
    be able to create your own shape-drawing functions and call `drawFractal()` to
    produce fractals of your own design.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Constants and the Turtle Configuration
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first lines of the program cover basic setup steps for our turtle-based
    program:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The program imports the `turtle` module for drawing. It also imports the `math`
    module for the `math.sqrt()` function, which the Sierpiński Triangle fractal will
    use, and the `math.cos()` and `math.sin()` functions, for the Snowflake fractal.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: The `DRAW_FRACTAL` constant can be set to any integer from `1` to `9` to draw
    one of the nine built-in fractals the program produces. You can also set it to
    `10` or `11` to show the output of the square or triangle shape-drawing function,
    respectively.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: We also call some turtle functions to prepare for drawing. The `turtle.tracer(5000,
    0)` call speeds up the drawing of the fractal. The `5000` argument tells the `turtle`
    module to wait until 5,000 turtle drawing instructions have been processed before
    rendering the drawing on the screen, and the `0` argument tells it to pause for
    0 milliseconds after each drawing instruction. Otherwise, the `turtle` module
    would render the image after each drawing instruction, which significantly slows
    the program if we want only the final image.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: You can change this call to `turtle.tracer(1, 10)` if you want to slow the drawing
    and watch the lines as they’re produced. This can be useful when making your own
    fractals to debug any problems with the drawing.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: The `turtle.hideturtle()` call hides the triangle shape on the screen that represents
    the turtle’s current position and heading. (*Heading* is another term for *direction*.)
    We call this function so that the marker doesn’t appear in the final image.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Shape-Drawing Functions
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `drawFractal()` function uses a shape-drawing function passed to it to draw
    the individual parts of the fractal. This is usually a simple shape, such as a
    square or triangle. The beautiful complexity of the fractals emerges from `drawFractal()`
    recursively calling this function for each individual component of the whole fractal.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'The shape-drawing functions for the Fractal Art Maker have two parameters:
    `size` and `depth`. The `size` parameter is the length of the sides of the square
    or triangle it draws. The shape-drawing functions should always use arguments
    to `turtle.forward()` that are based on `size` so that the lengths will be proportionate
    to `size` at each level of recursion. Avoid code like `turtle.forward(100)` or
    `turtle.forward(200)`; instead, use code that is based on the `size` parameter,
    like `turtle.forward(size)` or `turtle.forward(size * 2)`. In Python’s `turtle`
    module, `turtle.forward(1)` moves the turtle by one *unit*, which is not necessarily
    the same as one pixel.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: The shape-drawing functions’ second parameter is the recursive depth of `drawFractal()`.
    The original call to `drawFractal()` has the `depth` parameter set to `0`. Recursive
    calls to `drawFractal()` use `depth + 1` as the `depth` parameter. In the Wave
    fractal, the first triangle in the center of the window has a depth argument of
    `0`. The three triangles created next have a depth of `1`. The nine triangles
    around those three triangles have a depth of `2`, and so on.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Your shape-drawing function can ignore this argument, but using it can cause
    interesting variations to the basic shape. For example, the `drawFilledSquare()`
    shape-drawing function uses `depth` to alternate between drawing white squares
    and gray squares. Keep this in mind if you’d like to create your own shape-drawing
    functions for the Fractal Art Maker program, as they must accept a `size` and
    `depth` argument.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: The drawFilledSquare() Function
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `drawFilledSquare()` function draws a filled-in square with sides of length
    `size`. To color the square, we use the `turtle` module’s `turtle.begin_fill()`
    and `turtle.end_fill()` functions to make the square either white or gray, with
    a black border, depending on whether the `depth` argument is even or odd. Because
    these squares are filled in, any squares drawn on top of them later will cover
    them.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Like all shape-drawing functions for the Fractal Art Maker program, `drawFilledSquare()`
    accepts a `size` and `depth` parameter:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `size` argument could be a floating-point number with a fractional part,
    which sometimes causes the `turtle` module to make slightly asymmetrical and uneven
    drawings. To prevent this, the first line of the function rounds `size` down to
    an integer.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'When the function draws the square, it assumes the turtle is in the center
    of the square. Thus, the turtle must first move to the top-right corner of the
    square, relative to its initial heading:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `drawFractal()` function always has the pen down and ready to draw when
    the shape-drawing function is called, so `drawFilledSquare()` must call `turtle.penup()
    to avoid drawing a line as it moves to the starting position. To find the starting
    position relative to the middle of the square, the turtle must first move half
    of the square’s length (that is, `size // 2`) forward, to the future right edge
    of the square. Next the turtle turns 90 degrees to face up and then moves `size
    // 2` units forward to the top-right corner. The turtle is now facing the wrong
    way, so it turns around 180 degrees and places the pen down so that it can begin
    drawing.`
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '`Note that *top-right* and *up* are relative to the direction the turtle is
    originally facing. This code works just as well if the turtle begins facing to
    the right at 0 degrees or has a heading of 90, 42, or any other number of degrees.
    When you create your own shape-drawing functions, stick to the relative turtle
    movement functions like `turtle.forward()`, `turtle.left()`, and `turtle.right()`
    instead of absolute turtle movement functions like `turtle.goto()`.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `depth` argument tells the function whether it should draw a white
    square or a gray one:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: If `depth` is even, the `depth % 2 == 0` condition is `True`, and the square’s
    *fill color* is white. Otherwise, the code sets the fill color to gray. Either
    way, the border of the square, determined by the *pen color*, is set to black.
    To change either of these colors, use strings of common color names, like `red`
    or `yellow`, or an HTML color code comprising a hash mark and six hexadecimal
    digits, like `#24FF24` for lime green or `#AD7100` for brown.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: The website [https://html-color.codes](https://html-color.codes) has charts
    for many HTML color codes. The fractals in this black-and-white book lack color,
    but your computer can render your own fractals in a bright range of colors!
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'With the colors set, we can finally draw the four lines of the actual square:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: To tell the `turtle` module that we intend to draw a filled-in shape and not
    just the outline, we call the `turtle.begin_fill()` function. Next is a `for`
    loop that draws a line of length `size` and turns the turtle 90 degrees to the
    right. The `for` loop repeats this four times to create the square. When the function
    finally calls `turtle.end_fill()`, the filled-in square appears on the screen.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: The drawTriangleOutline() Function
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second shape-drawing function draws the outline of an equilateral triangle
    whose sides have a length of `size`. The function draws the triangle oriented
    with one corner at the top and two corners at the bottom. [Figure 13-6](#figure13-6)
    illustrates the various dimensions of an equilateral triangle.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '![Annotated diagram of an equilateral triangle showing the following properties.
    Size: the length of one side. Angle: 60 degrees. Height: size times math.sqrt(3)
    / 2\. Also shows two-thirds of the height and one-third of the height.](image_fi/502024c13/f13006.png)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-6: The measurements of an equilateral triangle with sides the length
    of `size`'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin drawing, we must determine the triangle’s height based on the
    length of its sides. Geometry tells us that, for equilateral triangles with sides
    of length *L*, the height *h* of the triangle is *L* times the square root of
    3 divided by 2\. In our function, *L* corresponds to the `size` parameter, so
    our code sets the height variable as follows:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Geometry also tells us that the center of the triangle is one-third of the
    height from the bottom side and two-thirds of the height from the top point. This
    gives us the information we need to move the turtle to its starting position:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: To reach the top corner, we turn the turtle 90 degrees left to face up (relative
    to the turtle’s original heading right at 0 degrees) and then move forward a number
    of units equal to `height * (2/3)`. The turtle is still facing up, so to begin
    drawing the line on the right side, the turtle must turn 90 degrees right to face
    rightward, then an additional 60 degrees to face the bottom-right corner of the
    triangle. This is why we call `turtle.right(150)`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the turtle is ready to start drawing the triangle, so we lower
    the pen by calling `turtle.pendown()`. A `for` loop will handle drawing the three
    sides:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Drawing the actual triangle is a matter of moving forward by `size` units, and
    then turning 120 degrees to the right, three separate times. The third and final
    120-degree turn leaves the turtle facing its original direction. You can see these
    movements and turns in [Figure 13-7](#figure13-7).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of four equilateral triangles. Each triangle has one additional bolded
    line, representing the steps needed to draw the triangle and return the turtle
    to its original heading.](image_fi/502024c13/f13007.png)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-7: Drawing an equilateral triangle involves three forward movements
    and three 120-degree turns.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: The `drawTriangleOutline()` function draws only the outline and not a filled-in
    shape, so it doesn’t call `turtle.begin_fill()` and `turtle.end_fill()` as `drawFilledSquare()`
    does.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Using the Fractal Drawing Function
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have two sample drawing functions to work with, let’s examine the
    main function in the Fractal Art Maker project, `drawFractal()`. This function
    has three required parameters and one optional one: `shapeDrawFunction`, `size`,
    `specs`, and `maxDepth`.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: The `shapeDrawFunction` parameter expects a function, like `drawFilledSquare()`
    or `drawTriangleOutline()`. The `size` parameter expects the starting size passed
    to the drawing function. Often, a value between `100` and `500` is a good starting
    size, though this depends on the code in your shape-drawing function, and finding
    the right value may require experimentation.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: The `specs` parameter expects a list of dictionaries that specify how the recursive
    shapes should change their size, position, and angle as `drawFractal()` recursively
    calls itself. These specifications are described later in this section.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: To prevent `drawFractal()` from recursing until it causes a stack overflow,
    the `maxDepth` parameter holds the number of times `drawFractal()` should recursively
    call itself. By default, `maxDepth` has a value of `8`, but you can provide a
    different value if you want more or fewer recursive shapes.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: A fifth parameter, `depth`, is handled by `drawFractal()`’s recursive call to
    itself and defaults to `0`. You don’t need to specify it when you call `drawFractal()`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Function
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing the `drawFractal()` function does is check for its two base
    cases:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: If `depth` is greater than `maxDepth`, the function will stop the recursion
    and return. The other base case occurs if `size` is less than `1`, at which point
    the shapes being drawn would be too small to be seen on the screen and so the
    function should simply return.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'We keep track of the turtle’s original position and heading in three variables:
    `initialX`, `initialY`, and `initialHeading`. This way, no matter where the shape-drawing
    function leaves the turtle positioned or what direction it is headed, `drawFractal()`
    can revert the turtle back to the original position and heading for the next recursive
    call:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `turtle.xcor()` and `turtle.ycor()` functions return the absolute x- and
    y-coordinates of the turtle on the screen. The `turtle.heading()` function returns
    the direction in which the turtle is pointed in degrees.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'The next few lines call the shape-drawing function passed to the `shapeDrawFunction`
    parameter:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Because the value passed as the argument for the `shapeDrawFunction` parameter
    is a function, the code `shapeDrawFunction(size, depth)` calls this function with
    the values in `size` and `depth`. The pen is lowered before and raised after the
    `shapeDrawFunction()` call to ensure that the shape-drawing function can consistently
    expect the pen to be down when the drawing begins.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Using the Specifications Dictionary
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the call to `shapeDrawFunction()`, the rest of `drawFractal()`’s code
    is devoted to making recursive calls to `drawFractal()` based on the specification
    in the `specs` list’s dictionaries. For each dictionary, `drawFractal()` makes
    one recursive call to `drawFractal()`. If `specs` is a list with one dictionary,
    every call to `drawFractal() results in only one recursive call to `drawFractal()`.
    If `specs` is a list with three dictionaries, every call to `drawFractal()` results
    in three recursive calls to `drawFractal()`.`
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '`The dictionaries in the `specs` parameter provide specifications for each
    recursive call. Each of these dictionaries has the keys `sizeChange`, `xChange`,
    `yChange`, and `angleChange`. These dictate how the size of the fractal, the position
    of the turtle, and the heading of the turtle change for a recursive `drawFractal()`
    call. [Table 13-1](#table13-1) describes the four keys in a specification.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-1: Keys in the Specification Dictionaries'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Default value** | **Description** |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
- en: '| `sizeChange` | `1.0` | The next recursive shape’s size value is the current
    size multiplied by this value. |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
- en: '| `xChange` | `0.0` | The next recursive shape’s x-coordinate is the current
    x-coordinate plus the current size multiplied by this value. |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
- en: '| `yChange` | `0.0` | The next recursive shape’s y-coordinate is the current
    y-coordinate plus the current size multiplied by this value. |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
- en: '| `angleChange` | `0.0` | The next recursive shape’s starting angle is the
    current starting angle plus this value. |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
- en: 'Let’s take a look at the specification dictionary for the Four Corners fractal,
    which produces the top-left image shown previously in [Figure 13-1](#figure13-1).
    The call to `drawFractal()` for the Four Corners fractal passes the following
    list of dictionaries for the `specs` parameter:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `specs` list has four dictionaries, so each call to `drawFractal()` that
    draws a square will, in turn, recursively call `drawFractal()` four more times
    to draw four more squares. [Figure 13-8](#figure13-8) shows this progression of
    squares (which alternate between white and gray).
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: To determine the size of the next square to be drawn, the value for the `sizeChange`
    key is multiplied by the current `size` parameter. The first dictionary in the
    `specs` list has a `sizeChange` value of `0.5`, which makes the next recursive
    call have a size argument of `350 * 0.5`, or `175` units. This makes the next
    square half the size of the previous square. A `sizeChange` value of `2.0` would,
    for example, double the size of the next square. If the dictionary has no `sizeChange`
    key, the value defaults to `1.0` for no change to the size.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '![Six turtle graphics screenshots. The first shows a white square. The second
    shows four smaller gray squares covering each corner of the white square. The
    third shows four smaller white squares covering the corners of each of those smaller
    gray squares. This pattern continues in the subsequent three screenshots. As the
    squares begin to overlap, their outlines remain visible.](image_fi/502024c13/f13008.png)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-8: Each step of the Four Corners example from left to right, top
    to bottom. Each square recursively produces four more squares at its corners,
    with colors alternating between white and gray.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: To determine the x-coordinate of the next square, the first dictionary’s `xChange`
    value, `-0.5` in this case, is multiplied by the size. When `size` is `350`, this
    means the next square has an x-coordinate of `-175` units relative to the turtle’s
    current position. This `xChange` value and the `yChange` key’s value of `0.5`
    places the next square’s position a distance of 50 percent of the current square’s
    size, to the left and above the current square’s position. This happens to center
    it on the top-left corner of the current square.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the three other dictionaries in the `specs` list, you’ll notice
    they all have a `sizeChange` value of `0.5`. The difference between them is that
    their `xChange` and `yChange` values place them in the other three corners of
    the current square. As a result, the next four squares are drawn centered on the
    four corners of the current square.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: The dictionaries in the `specs` list for this example don’t have an `angleChange`
    value, so this value defaults to `0.0` degrees. A positive `angleChange` value
    indicates a counterclockwise rotation, while a negative value indicates a clockwise
    rotation.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Each dictionary represents a separate square to be drawn each time the recursive
    function is called. If we were to remove the first dictionary from the `specs`
    list, each `drawFractal()` call would produce only three squares, as in [Figure
    13-9](#figure13-9).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '![Six screenshots identical to those in Figure 13-8, except the pattern develops
    on only three corners of the original square.](image_fi/502024c13/f13009.png)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-9: The Four Corners fractal with the first dictionary removed from
    the `specs` list'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Specifications
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at how the code in `drawFractal()` actually does everything we’ve
    described:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `for` loop assigns an individual specification dictionary in the `specs`
    list to the loop variable `spec` on each iteration of the loop. The `get()` dictionary
    method calls pull the values for the `sizeChange`, `xChange`, `yChange`, and `angleChange`
    keys from this dictionary and assign them to the shorter-named `sizeCh`, `xCh`,
    `yCh`, and `angleCh` variables. The `get()` method substitutes a default value
    if the key doesn’t exist in the dictionary.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the turtle’s position and heading are reset to the values indicated when
    `drawFractal()` was first called. This ensures that the recursive calls from previous
    loop iterations don’t leave the turtle in some other place. Then the heading and
    position are changed according to the `angleCh`, `xCh`, and `yCh` variables:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The x-change and y-change positions are expressed relative to the turtle’s current
    heading. If the turtle’s heading is `0`, the turtle’s relative x-axis is the same
    as the actual x-axis on the screen. However, if the turtle’s heading is, say,
    `45`, the turtle’s relative x-axis is at a 45-degree tilt. Moving “right” along
    the turtle’s relative x-axis would then move at an up-right angle.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: This is why moving forward by `size * xCh` moves the turtle along its relative
    x-axis. If `xCh` is negative, `turtle.forward()` moves left along the turtle’s
    relative x-axis. The `turtle.left(90)` call points the turtle along the turtle’s
    relative y-axis, and `turtle.forward(size * yCh)` moves the turtle to the next
    shape’s starting position. However, the `turtle.left(90)` call changed the turtle’s
    heading, so `turtle.right(90)` is called to reset it back to its original direction.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-10](#figure13-10) shows how these four lines of code move the turtle
    to the right along its relative x-axis and up along its relative y-axis and leave
    it in the correct heading, no matter what its initial heading was.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '![Four turtle graphics screenshots of the same two perpendicular lines, each
    time rotated a different way.](image_fi/502024c13/f13010.png)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-10: In each of these four images, the turtle always moves 100 units
    “right” and “up” along the relative x-axis and y-axis of its initial heading.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, with the turtle in the correct position and heading for the next shape,
    we make the recursive call to `drawFractal()`:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `shapeDrawFunction`, `specs`, and `maxDepth` arguments are passed to the
    recursive `drawFractal()` call unchanged. However, `size * sizeCh` is passed for
    the next `size` parameter to reflect the change in the `size` of the recursive
    shape, and `depth + 1` is passed for the `depth` parameter to increment it for
    the next shape-drawing function call.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Example Fractals
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve covered how the shape-drawing functions and recursive `drawFractal()`
    function work, let’s look at the nine example fractals that come with the Fractal
    Art Maker. You can see these examples in [Figure 13-1](#figure13-1).
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Four Corners
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first fractal is *Four Corners*, which begins as a large square. As the
    function calls itself, the fractal’s specifications cause four smaller squares
    to be drawn in the four corners of the square:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The call to `drawFractal()` here limits the maximum depth to `5`, as any more
    tends to make the fractal so dense that the fine detail becomes hard to see. This
    fractal appears in [Figure 13-8](#figure13-8).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Spiral Squares
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Spiral Squares fractal*also starts as a large square, but it creates just
    one new square on each recursive call:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This square is slightly smaller and rotated by `7` degrees. The centers of all
    the squares are unchanged, so there’s no need to add `xChange` and `yChange` keys
    to the specification. The default maximum depth of `8` is too small to get an
    interesting fractal, so we increase it to `50` to produce a hypnotic spiral pattern.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: Double Spiral Squares
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Double Spiral Squares fractal* is similar to Spiral Squares, except each
    square creates two smaller squares. This creates an interesting fan effect, as
    the second square is drawn later and tends to cover up previously drawn squares:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The squares are created slightly higher or lower than their previous square
    and rotated either `10` or `-10` degrees.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Triangle Spiral
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Triangle Spiral* *fractal*, another variation of Spiral Squares, uses
    the `drawTriangleOutline()` shape-drawing function instead of `drawFilledSquare()`:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Unlike the Spiral Squares fractal, the Triangle Spiral fractal begins at the
    small `size` of `20` units and slightly increases in size for each level of recursion.
    The `sizeChange` key is greater than `1.0`, so the shapes are always increasing
    in size. This means the base case occurs when the recursion reaches a depth of
    `80`, because the base case of `size` becoming less than `1` is never reached.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Conway’s Game of Life Glider
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Conway’s Game of Life* is a famous example of cellular automata. The game’s
    simple rules cause interesting and wildly chaotic patterns to emerge on a 2D grid.
    One such pattern is a *Glider* consisting of five cells in a 3 × 3 space:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The Glider fractal here has additional Gliders drawn inside each of its five
    cells. The `third` variable helps precisely set the position of the recursive
    shapes in the 3 × 3 space.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: You can find a Python implementation of Conway’s Game of Life in my book *The
    Big Book of Small Python Projects* (No Starch Press, 2021) and online at [https://inventwithpython.com/bigbookpython/project13.html](https://inventwithpython.com/bigbookpython/project13.html).
    Tragically, John Conway, the mathematician and professor who developed Conway’s
    Game of Life, passed away of complications from COVID-19 in April 2020.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: Sierpiński Triangle
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We created the *Sierpiński Triangle* *fractal* in Chapter 9, but our Fractal
    Art Maker can re-create it as well by using the `drawTriangleOutline()` shape
    function. After all, a Sierpiński triangle is an equilateral triangle with three
    smaller equilateral triangles drawn in its interior:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The center of these smaller triangles is `size * math.sqrt(3) / 6` units from
    the center of the previous triangle. The three calls adjust the heading of the
    turtle to `0`, `120`, and `240` degrees before moving up on the turtle’s relative
    y-axis.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Wave
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We discussed the *Wave fractal* at the start of this chapter, and you can see
    it in [Figure 13-5](#figure13-5). This relatively simple fractal creates three
    smaller and distinct recursive triangles:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Horn
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Horn fractal* resembles a ram’s horn:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This simple fractal is made up of squares, each of which is slightly smaller,
    moved up, and rotated `11` degrees from the previous square. We increase the maximum
    recursion depth to `100` to extend the horn into a tight spiral.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Snowflake
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final fractal, *Snowflake*, is composed of squares laid out in a pentagon
    pattern. This is similar to the Four Corners fractal, but it uses five evenly
    spaced recursive squares instead of four:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This fractal uses the cosine and sine functions from trigonometry, implemented
    in Python’s `math.cos()` and `math.sin()` functions, to determine how to shift
    the squares along the x-axis and y-axis. A full circle has 360 degrees, so to
    evenly space out the five recursive squares in this circle, we place them at intervals
    of 0, 72, 144, 216, and 288 degrees. The `math.cos()` and `math.sin()` functions
    expect the angle argument to be in radians instead of degrees, so we must multiply
    these numbers by `math.pi / 180`.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that each square is surrounded by five other squares, which
    are surrounded by five other squares, and so on, to form a crystal-like fractal
    that resembles a snowflake.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Producing a Single Square or Triangle
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For completion, you can also set `DRAW_FRACTAL` to `10` or `11` to view what
    a single call to `drawFilledSquare()` and `drawTriangleOutline()` produce in the
    turtle window. These shapes are drawn with a size of `600`:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: After drawing the fractal or shape based on the value in `DRAW_FRACTAL`, the
    program calls `turtle.exitonclick()` so that the turtle window stays open until
    the user clicks it. Then the program terminates.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your Own Fractals
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create your own fractals by changing the specification passed to the
    `drawFractal()` function. Start by thinking about how many recursive calls you’d
    like each call to `drawFractal()` to generate, and how the size, position, and
    heading of the shapes should change. You can use the existing shape-drawing functions
    or create your own.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Figure 13-11](#figure13-11) shows the nine built-in fractals,
    except the square and triangle functions have been swapped. Some of these produce
    bland shapes, but others can result in unexpected beauty.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '![The six fractals from Figure 13-1 with all the squares and triangles swapped.](image_fi/502024c13/f13011.png)'
  id: totrans-619
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-11: The nine fractals that come with Fractal Art Maker, with the
    shape-drawing functions swapped'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fractal Art Maker projects demonstrate the endless possibilities of recursion.
    A simple recursive `drawFractal()` function, paired with a shape-drawing function,
    can create a large variety of detailed geometric art.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: At the core of Fractal Art Maker is the recursive `drawFractal()` function,
    which accepts another function as an argument. This second function draws a basic
    shape repeatedly by using the size, position, and heading given in the list of
    specification dictionaries.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: You can test an unlimited number of shape-drawing functions and specification
    settings. Let your creativity drive your fractal projects as you experiment with
    the code in this program.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are websites that allow you to create fractals. Interactive Fractal Tree
    at [https://www.visnos.com/demos/fractal](https://www.visnos.com/demos/fractal)
    has sliders to change a binary tree fractal’s angle and size parameters. Procedural
    Snowflake at [https://procedural-snowflake.glitch.me](https://procedural-snowflake.glitch.me)
    generates new snowflakes in your browser. Nico’s Fractal Machine at [https://sciencevsmagic.net/fractal](https://sciencevsmagic.net/fractal)
    creates animated drawings of fractals. You can find others by searching the web
    for *fractal maker* or *fractal generator online*.``  ``# 14
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: Droste Maker
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
- en: The *Droste effect* is a recursive art technique named after a 1904 illustration
    on a tin of Droste’s Cacao, a Dutch brand of cocoa. Shown in [Figure 14-1](#figure14-1),
    the tin features an image of a nurse holding a meal tray containing a tin of Droste
    cocoa, which itself bears the illustration.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll create a Droste Maker program that can generate similar
    recursive images from any photograph or drawing you have, whether it be a museum
    patron looking at an exhibit of themself, a cat in front of a computer monitor
    of a cat in front of a computer monitor, or something else entirely.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '![A tin of Droste cocoa from 1904\. The illustration on the tin features a
    nurse holding a tray with a steaming mug and a tin of Droste cocoa. The recursive
    illustration on this tin is the same nurse holding a tray with a steaming mug
    and a tin of Droste cocoa.](image_fi/502024c14/f14001.png)'
  id: totrans-631
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-1: The recursive illustration on a tin of Droste’s Cacao'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: Using a graphics program such as Microsoft Paint or Adobe Photoshop, you’ll
    prepare the image by covering an area of it with a pure magenta color, indicating
    where to place the recursive image. The Python program uses the Pillow image library
    to read this image data and produce a recursive image.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll cover how to install the Pillow library and how the Droste Maker
    algorithm works. Next, we’ll present the Python source code for the program with
    accompanying explanation of the code.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Pillow Python Library
  id: totrans-635
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter’s project requires the Pillow image library. This library allows
    your Python programs to create and modify image files including PNGs, JPEGs, and
    GIFs. It has several functions to perform resizing, copying, cropping, and other
    common actions on images.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: To install this library on Windows, open a command prompt window and run `py
    -m pip install --user pillow`. To install this library on macOS or Linux, open
    a Terminal window and run python3 `-m pip install --user pillow`. This command
    makes Python use the pip installer program to download the module from the official
    Python Package Index at [https://pypi.org](https://pypi.org).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: To verify that the installation worked, open a Python terminal and run `from
    PIL import Image`. (While the library’s name is Pillow, the Python module installed
    is named `PIL`, in capital letters.) If no error appears, the library was installed
    correctly.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation for Pillow can be found at [https://pillow.readthedocs.io](https://pillow.readthedocs.io).
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Painting Your Image
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to prepare an image by setting a portion of it to the RGB (red,
    green, blue) color value (255, 0, 255). Computer graphics often use magenta to
    mark which pixels of an image should be rendered as transparent. Our program will
    treat these magenta pixels like a green screen in video production, replacing
    them with a resized version of the initial image. Of course, this resized image
    will have its own smaller magenta area, which the program will replace with another
    resized image. The base case occurs when the final image has no more magenta pixels,
    at which point the algorithm is done.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-2](#figure14-2) shows the progression of images created as the resized
    image is recursively applied to the magenta pixels. In this example, a model stands
    in front of an art museum exhibit that has been replaced with magenta pixels,
    turning the photograph itself into the exhibit. You can download this base image
    from [https://inventwithpython.com/museum.png](https://inventwithpython.com/museum.png).'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Be sure you use only the pure (255, 0, 255) magenta color for painting the magenta
    area in your image. Some tools may have a fading effect that produces a more natural
    look. For example, Photoshop’s Brush tool will produce faded magenta pixels on
    the outline of the painted area, so you will need to use the Pencil tool instead,
    which paints using only the precise pure magenta color you’ve selected. If your
    graphics program doesn’t allow you to specify the precise RGB color for drawing,
    you can copy and paste the colors from the PNG image at [https://inventwithpython.com/magenta.png](https://inventwithpython.com/magenta.png).
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: The magenta area in the image can be of any size or shape; it does not have
    to be an exact, contiguous rectangle. You can see that in [Figure 14-2](#figure14-2),
    the museum visitor cuts into the magenta rectangle, placing them in front of the
    recursive image.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: If you make your own images with Droste Maker, you should use the PNG image
    file format instead of JPEG. JPEG images use *lossy* compression techniques to
    keep the file size small that introduce slight imperfections. These are usually
    imperceptible to the human eye and don’t affect overall image quality. However,
    this lossy compression will replace the pure (255, 0, 255) magenta pixels with
    slightly different shades of magenta. The *lossless* image compression of PNG
    images ensures this won’t happen.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '![Four images of a girl, seen from behind, looking at a work of art. In the
    first image, the work of art is covered by a monochrome rectangle. In the second
    image, the monochrome rectangle has been replaced by a resized version of the
    original image of the girl. In the third and fourth images, the monochrome rectangles
    have once again been replaced, creating the effect that the girl is looking at
    herself looking at herself.](image_fi/502024c14/f14002.png)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-2: Recursive applications of the image to the magenta pixels. If
    you are viewing the black-and-white image printed in this book, the magenta area
    is the rectangle in front of the museum visitor.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: The Complete Droste Maker Program
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the source code for *drostemaker.py*; because this program
    relies on the Python-only Pillow library, there is no JavaScript equivalent for
    this project in this book:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Before you run this program, place your image file in the same folder as *drostemaker.py*.
    The program will save the recursive image as *museum-recursive.png* and then open
    an image viewer to display it. If you want to run the program on your own image
    that you’ve added a magenta area to, replace `makeDroste('museum.png')` at the
    end of the source code with the name of your image file and `save('museum-recursive.png')`
    with the name you’d like to use to save the recursive image.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up
  id: totrans-652
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Droste Maker program has only one function, `makeDroste()`, which accepts
    a Pillow `Image` object or a string of an image’s filename. The function returns
    a Pillow `Image` object with any magenta pixels recursively replaced by a version
    of the same image:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The program begins by importing the `Image` class from the Pillow library (named
    `PIL` as a Python module). Within the `makeDroste()` function, we check whether
    the `baseImage` parameter is a string, and if so, we replace it with a Pillow
    `Image` object loaded from the corresponding image file.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check whether the `stopAfter` parameter is `0`. If it is, we’ve reached
    one of the algorithm’s base cases and the function returns the Pillow `Image`
    object of the base image:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The `stopAfter` parameter is `10` by default if the function call doesn’t provide
    one. The recursive call to `makeDroste()` later in this function passes `stopAfter
    - 1` as the argument for this parameter so that it decreases with each recursive
    call and approaches the base case of `0`.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: For example, passing `0` for `stopAfter` results in the function immediately
    returning a recursive image identical to the base image. Passing `1` for `stopAfter`
    replaces the magenta area with a recursive image once, makes one recursive call,
    reaches the base case, and immediately returns. Passing `2` for `stopAfter` causes
    two recursive calls, and so on.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: This parameter prevents the function from recursing until it causes a stack
    overflow in cases when the magenta area is particularly large. It also lets us
    pass a smaller argument than `10` to limit the number of recursive images placed
    in the base image. For example, the four images in [Figure 14-2](#figure14-2)
    were created by passing `0`, `1`, `2`, and `3` for the `stopAfter` parameter.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check the color mode of the base image. This can be either `RGB` for
    an image with red-green-blue pixels or `RGBA` for an image that has an alpha channel
    for its pixels. The *alpha value* tells a pixel’s level of transparency. Here’s
    the code:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The Droste Maker needs to know the color mode so that it can find magenta pixels.
    The values for each channel range from `0` to `255`, and magenta pixels have a
    maximum amount of red and blue but no green. Further, if an alpha channel exists,
    it would be set to `255` for a completely opaque color and `0` for a completely
    transparent one. The `magentaColor` variable is set to the correct tuple value
    for a magenta pixel depending on the image’s color mode given in `baseImage.mode`.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Magenta Area
  id: totrans-667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the program can recursively insert the image into the magenta area, it
    must find the boundaries of the magenta area in the image. This involves finding
    the leftmost, rightmost, topmost, and bottommost magenta pixels in the image.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: While the magenta area itself doesn’t need to be a perfect rectangle, the program
    needs to know the rectangular boundaries of the magenta in order to properly resize
    the image for insertion. For example, [Figure 14-3](#figure14-3) shows a base
    image of the *Mona Lisa* with the magenta area outlined in white. The magenta
    pixels are replaced to produce the recursive image.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '![Two images of the Mona Lisa. In the first, the woman’s face and torso have
    been replaced with a monochrome shape, and a white rectangle indicates the boundaries
    of that shape. In the second image, the monochrome area has been replaced by progressively
    smaller versions of the original image.](image_fi/502024c14/f14003.png)'
  id: totrans-670
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-3: The base image with a magenta area outlined in white (left) and
    the recursive image it produces (right)'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the resizing and placement of the resized image, the program retrieves
    the width and height of the base image from the `size` attribute of the Pillow
    `Image` object in `baseImage`. The following lines initialize four variables for
    the four edges of the magenta area—`magentaLeft`, `magentaRight`, `magentaTop`,
    and `magentaBottom`—to the `None` value:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'These edge variable values are replaced by integer `x` and `y` coordinates
    in the code that comes next:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: These nested `for` loops iterate the `x` and `y` variables over every possible
    x, y coordinate in the base image. We check whether the pixel at each coordinate
    is the pure magenta color stored in `magentaColor`, then update the `magentaLeft`
    variable if the coordinates of the magenta pixel are further left than currently
    recorded in `magentaLeft`, and so on for the other three directions.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'By the time the nested `for` loops are finished, `magentaLeft`, `magentaRight`,
    `magentaTop`, and `magentaBottom` will describe the boundaries of the magenta
    pixels in the base image. If the image has no magenta pixels, these variables
    will remain set to their initial `None` value:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: If `magentaLeft` (or really, any of the four variables) is still set to `None`
    after the nested `for` loops complete, no magenta pixels are in the image. This
    is a base case for our recursive algorithm because the magenta area becomes smaller
    and smaller with each recursive call to `makeDroste()`. At this point, the function
    returns the Pillow `Image` object in `baseImage`.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: Resizing the Base Image
  id: totrans-683
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to resize the base image to cover the entire magenta area and no more.
    [Figure 14-4](#figure14-4) shows the complete resized image overlayed transparently
    on the original base image. This resized image is cropped so that only the parts
    over magenta pixels are copied over to the final image.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '![Four images of a cat sitting in front of a computer monitor. In the first,
    the computer monitor’s screen is covered in a monochrome shade. In the second,
    the monochrome area has been replaced by a smaller version of the original image,
    but this version is transparent, making visible the places where it overlaps with
    the non-monochrome portions of the larger image. The third image is the completed
    recursive image.](image_fi/502024c14/f14004.png)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-4: The base image with the magenta area in the monitor (top), the
    resized image over the base image (middle), and the final recursive image that
    replaces only the magenta pixels (bottom)'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: We cannot simply resize the base image to the dimensions of the magenta area
    because it’s unlikely the two share the same *aspect ratio*, or proportion of
    the width divided by the height. Doing so results in a recursive image that looks
    stretched or squished, like [Figure 14-5](#figure14-5).
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we must make the resized image large enough to completely cover the
    magenta area but still retain the image’s original aspect ratio. This means either
    setting the width of the resized image to the width of the magenta area such that
    the height of the resized image is equal to or larger than the height of the magenta
    area, or setting the height of the resized image to the height of the magenta
    area such that the width of the resized image is equal to or larger than the width
    of the magenta area.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '![Version of the recursive image of the girl looking at herself in which subsequent
    appearances of the girl appear distorted.](image_fi/502024c14/f14005.png)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-5: Resizing the image to the dimensions of the magenta area can result
    in a different aspect ratio, causing it to look stretched or squished.'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the correct resizing dimensions, the program needs to determine
    the aspect ratio of both the base image and the magenta area:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'From `magentaRight` and `magentaLeft`, we can calculate the width of the magenta
    area. The `+ 1` accounts for a small, necessary adjustment: if the right side
    of the magenta area was the x-coordinate of 11 and the left side was 10, the width
    would be two pixels. This is correctly calculated by (`magentaRight - magentaLeft
    + 1`), not (`magentaRight - magentaLeft`).'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the aspect ratio is the width divided by the height, images with large
    aspect ratios are taller than they are wide, and those with small aspect ratios
    are wider than they are tall. An aspect ratio of 1.0 describes a perfect square.
    The next lines set the dimensions of the resized image after comparing the aspect
    ratios of the base image and the magenta area:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: If the base image’s aspect ratio is less than the magenta area’s aspect ratio,
    the resized image’s width should match the width of the magenta area. If the base
    image’s aspect ratio is greater, the resized image’s height should match the height
    of the magenta area. We then determine the other dimension by multiplying the
    base image’s height by the width ratio, or the base image’s width by the height
    ratio. This ensures that the resized image both completely covers the magenta
    area and remains proportional to its original aspect ratio.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: We call the `resize()` method once to produce a new Pillow `Image` object resized
    to match either the width of the base image or the height of the base image. The
    first argument is a (width, height) tuple for the new image’s size. The second
    argument is the `Image.NEAREST` constant from the Pillow library that tells the
    `resize()` method to use the nearest neighbor algorithm when resizing the image.
    This prevents the `resize()` method from blending the colors of the pixels to
    produce a smooth image.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want this, because it could blur the magenta pixels with neighboring
    non-magenta pixels in the resized image. Our `makeDroste()` function relies on
    detecting magenta pixels with the exact RGB color of (255, 0, 255) and would ignore
    these slightly off magenta pixels. The end result would be a pinkish outline around
    the magenta areas that would ruin our image. The nearest neighbor algorithm doesn’t
    do this blurring, leaving our magenta pixels exactly at the (255, 0, 255) magenta
    color.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: Recursively Placing the Image Within the Image
  id: totrans-700
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the base image has been resized, we can place the resized image over the
    base image. But the pixels from the resized image should be placed over only magenta
    pixels in the base image. The resized image will be placed such that the top-left
    corner of the resized image is at the top-left corner of the magenta area:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Two nested `for` loops iterate over every pixel in the magenta area. Remember
    that the magenta area does not have to be a perfect rectangle, so we check whether
    the pixel at the current coordinates is magenta. If so, we get the pixel color
    from the corresponding coordinates in the resized image and place it on the base
    image. After the two nested `for` loops have finished looping, the magenta pixels
    in the base image will have been replaced by pixels from the resized image.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the resized image itself could have magenta pixels, and if so, these
    will now become part of the base image, as in the top-right image of [Figure 14-2](#figure14-2).
    We’ll need to pass the modified base image to a recursive `makeDroste()` call:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This line is the recursive call in our recursive algorithm, and it’s the last
    line of code in the `makeDroste()` function. This recursion handles the new magenta
    area copied from the resized image. Note that the value passed for the `stopAfter`
    parameter is `stopAfter - 1`, ensuring that it comes closer to the base case of
    `0`.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the Droste Maker program begins by passing `′museum.png′` to `makeDroste()`
    to get the Pillow `Image` object of the recursive image. We save this as a new
    image file named *museum-recursive.png*and display the recursive image in a new
    window for the user to view:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: You can change these filenames to whichever image on your computer you’d like
    to use with the program.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: Does the `makeDroste()` function need to be implemented with recursion? Simply
    put, no. Notice that no tree-like structure is involved in the problem, and the
    algorithm does no backtracking, which is a sign that recursion may be an overengineered
    approach to this code.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter’s project was a program that produces recursive Droste effect images,
    just like the illustration on old tins of Droste’s Cacao. The program works by
    using pure magenta pixels with RGB values of (255, 0, 255) to mark the parts of
    the image that should be replaced by a smaller version. Since this smaller version
    will also have its own smaller magenta area, the replacements will repeat until
    the magenta area is gone to produce a recursive image.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: The base case for our recursive algorithm occurs when no more magenta pixels
    remain in the image to place the smaller recursive image in, or when the `stopAfter`
    counter reaches `0`. Otherwise, the recursive case passes the image to the `makeDroste()`
    function to continue to replace the magenta area with even smaller recursive images.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: You can modify your own photos to add magenta pixels and then run them through
    the Droste Maker. The museum patron looking at an exhibit of themself, the cat
    in front of a computer monitor of the cat in front of a computer monitor, and
    the faceless *Mona Lisa* images are just a few examples of the surreal possibilities
    you can create with this recursive program.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-718
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Wikipedia article for the Droste effect at [https://en.wikipedia.org/wiki/Droste_effect](https://en.wikipedia.org/wiki/Droste_effect)
    has examples of products other than Droste’s Cacao that use the Droste effect.
    Dutch artist M.C. Escher’s *Print Gallery* is a famous example of a scene that
    also contains itself, and you can learn more about it at [https://en.wikipedia.org/wiki/Print_Gallery_(M._C._Escher)](https://en.wikipedia.org/wiki/Print_Gallery_(M._C._Escher)).
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: In a video titled “The Neverending Story (and Droste Effect)” on the Numberphile
    YouTube channel, Dr. Clifford Stoll discusses recursion and the Droste’s Cacao
    box art at [https://youtu.be/EeuLDnOupCI](https://youtu.be/EeuLDnOupCI).
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19 of my book *Automate the Boring Stuff with Python*, 2nd edition (No
    Starch Press, 2019) provides a basic tutorial of the Pillow library at [https://automatetheboringstuff.com/2e/chapter19](https://automatetheboringstuff.com/2e/chapter19).``
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL

- en: Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分
- en: Projects
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 项目
- en: '10'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: File Finder
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 文件查找器
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, you’ll write your own recursive program to search for files
    according to custom needs. Your computer already has some file-searching commands
    and apps, but often they’re limited to retrieving files based on a partial filename.
    What if you need to make esoteric, highly specific searches? For example, what
    if you need to find all files that have an even number of bytes, or files with
    names that contain every vowel?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将编写自己的递归程序，根据自定义需求搜索文件。你的计算机已经有一些文件搜索命令和应用程序，但通常它们只能根据部分文件名检索文件。如果你需要进行奇特、高度特定的搜索怎么办？例如，如果你需要找到所有具有偶数字节的文件，或者文件名包含每个元音字母的文件？
- en: You likely will never need to do these searches specifically, but you’ll probably
    have odd search criteria someday. You’ll be out of luck if you can’t code this
    search yourself.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能永远不需要专门进行这些搜索，但是你可能会有奇怪的搜索条件。如果你不能自己编写这个搜索，你就会很倒霉。
- en: As you’ve learned, recursion is especially suited to problems that have a tree-like
    structure. The filesystem on your computer is like a tree, as you saw back in
    Figure 2-6. Each folder branches into subfolders, which in turn can branch into
    other subfolders. We’ll write a recursive function to navigate this tree.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所学到的，递归特别适用于具有树状结构的问题。你的计算机上的文件系统就像一棵树，就像你在图2-6中看到的那样。每个文件夹都分成子文件夹，这些子文件夹又可以分成其他子文件夹。我们将编写一个递归函数来遍历这棵树。
- en: The Complete File-Search Program
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的文件搜索程序
- en: 'Let’s begin by taking a look at the complete source code for the recursive
    file-search program. The rest of this chapter explains each section of code individually.
    Copy the source code for the file-search program to a file named *fileFinder.py*:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下递归文件搜索程序的完整源代码。本章的其余部分将逐个解释代码的每个部分。将文件搜索程序的源代码复制到名为*fileFinder.py*的文件中：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The file-search program’s main function is `walk()`, which “walks” across the
    entire span of files in a base folder and its subfolders. It calls one of two
    other functions that implement the custom search criteria it’s looking for. In
    the context of this program, we’ll call these *match functions*. A match function
    call returns `True` if the file matches the search criteria; otherwise, it returns
    `False`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 文件搜索程序的主要函数是`walk()`，它在基本文件夹及其子文件夹中“遍历”整个文件范围。它调用另外两个实现自定义搜索条件的函数中的一个。在这个程序的上下文中，我们将这些称为*匹配函数*。匹配函数调用返回`True`，如果文件符合搜索条件；否则，返回`False`。
- en: The job of the `walk()` function is to call the match function once for each
    file in the folders it walks across. Let’s take a look at the code in more detail.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk()`函数的工作是为它遍历的每个文件夹中的每个文件调用匹配函数。让我们更详细地看一下代码。'
- en: The Match Functions
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配函数
- en: 'In Python, you can pass functions themselves as arguments to a function call.
    In the following example, a `callTwice()` function calls its function argument
    twice, whether it’s `sayHello()` or `sayGoodbye()`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你可以将函数本身作为参数传递给函数调用。在下面的示例中，`callTwice()`函数调用其函数参数两次，无论是`sayHello()`还是`sayGoodbye()`：
- en: '**Python**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `callTwice()` function calls whichever function was passed to it as the
    `func` parameter. Notice that we leave out the parentheses from the function argument,
    writing `callTwice(sayHello)` instead of `callTwice(sayHello())`. This is because
    we are passing the `sayHello()` function itself, and not calling `sayHello()`
    and passing its return value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`callTwice()`函数调用作为`func`参数传递给它的任何函数。请注意，我们从函数参数中省略了括号，而是写成`callTwice(sayHello)`，而不是`callTwice(sayHello())`。这是因为我们传递的是`sayHello()`函数本身，而不是调用`sayHello()`并传递其返回值。'
- en: The `walk()` function accepts a match function argument for its search criteria.
    This lets us customize the behavior of the file search without modifying the code
    of the `walk()` function itself. We’ll take a look at `walk()` later. First, let’s
    look at the two sample match functions in the program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk()`函数接受一个匹配函数参数作为其搜索条件。这使我们能够自定义文件搜索的行为，而无需修改`walk()`函数本身的代码。我们稍后会看一下`walk()`。首先，让我们看一下程序中的两个示例匹配函数。'
- en: Finding the Files with an Even Number of Bytes
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找具有偶数字节的文件
- en: 'The first matching function finds files with an even byte size:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个匹配函数找到具有偶数字节大小的文件：
- en: '**Python**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We import the `os` module, which is used throughout the program to get information
    about the files on your computer through functions such as `getsize()`, `basename()`,
    and others. Then we create a match function named `hasEvenByteSize()`. All match
    functions take a single string argument named `fullFilePath`, and return either
    `True` or `False` to signify a match or miss.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`os`模块，该模块在整个程序中用于通过`getsize()`、`basename()`等函数获取有关计算机上文件的信息。然后我们创建一个名为`hasEvenByteSize()`的匹配函数。所有匹配函数都接受一个名为`fullFilePath`的字符串参数，并返回`True`或`False`来表示匹配或不匹配。
- en: 'The `os.path.getsize()` function determines the size of the file in `fullFilePath`
    in bytes. Then we use the `%` modulus operator to determine whether this number
    is even. If it’s even, the `return` statement returns `True`; if it’s odd, it
    returns `False`. For example, let’s consider the size of the Notepad application
    that comes with the Windows operating system (on macOS or Linux, try running this
    function on the */bin/ls* program):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.getsize()`函数确定`fullFilePath`中文件的大小（以字节为单位）。然后我们使用`%`模运算符来确定这个数字是否是偶数。如果是偶数，`return`语句返回`True`；如果是奇数，返回`False`。例如，让我们考虑Windows操作系统中附带的记事本应用程序的大小（在macOS或Linux上，尝试在*/bin/ls*程序上运行这个函数）：'
- en: '**Python**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `hasEvenByteSize()` match function can use any Python function to find more
    information about the `fullFilePath` file. This gives you the powerful capability
    to write code for any search criteria you want. As `walk()` calls the match function
    for each file in the folder and subfolders it walks across, the match function
    returns `True` or `False` for each one. This tells `walk()` whether the file is
    a match.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasEvenByteSize()`匹配函数可以使用任何Python函数来查找有关`fullFilePath`文件的更多信息。这使您能够为任何搜索条件编写代码。当`walk()`对文件夹和子文件夹中的每个文件调用匹配函数时，匹配函数会为每个文件返回`True`或`False`。这告诉`walk()`文件是否匹配。'
- en: Finding the Filenames That Contain Every Vowel
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找包含所有元音字母的文件名
- en: 'Let’s take a look at the next match function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看下一个匹配函数：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We call `os.path.basename()` to remove the folder names from the filepath. Python
    does case-sensitive string comparisons, which ensures that `hasEveryVowel()` doesn’t
    miss any vowels in the filename because they are uppercase. For example, calling
    `os.path.basename('C:/Windows/system32/notepad.exe')` returns the string `notepad.exe`.
    This string’s `lower()` method call returns a lowercase form of the string so
    that we have to check for only lowercase vowels in it. “Useful Python Standard
    Library Functions for Working with Files” later in this chapter explores some
    more functions for finding out information about files.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`os.path.basename()`来从文件路径中删除文件夹名称。Python对字符串进行区分大小写的比较，这确保了`hasEveryVowel()`不会因为文件名中的元音字母是大写而漏掉任何元音字母。例如，调用`os.path.basename('C:/Windows/system32/notepad.exe')`返回字符串`notepad.exe`。这个字符串的`lower()`方法调用返回字符串的小写形式，这样我们只需要检查其中的小写元音字母。本章后面的“用于处理文件的有用Python标准库函数”探讨了一些更多用于获取文件信息的函数。
- en: We use a `return` statement with a lengthy expression that evaluates to `True`
    if `name` contains `a`, `e`, `i`, `o`, or `u`, indicating the file matches the
    search criteria. Otherwise, the `return` statement returns `False`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个带有长表达式的`return`语句，如果`name`包含`a`、`e`、`i`、`o`或`u`，则表达式求值为`True`，表示文件符合搜索条件。否则，`return`语句返回`False`。
- en: The Recursive walk() Function
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归`walk()`函数
- en: While the match functions check whether a file matches the search criteria,
    the `walk()` function finds all the files to check. The recursive `walk()` function
    is passed the name of a base folder to search along with a match function to call
    for each file in the folder.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配函数检查文件是否符合搜索条件，而`walk()`函数找到所有要检查的文件。递归的`walk()`函数会传入一个要搜索的基础文件夹的名称，以及一个要对文件夹中的每个文件调用的匹配函数。
- en: 'The `walk()` function also recursively calls itself for each subfolder in the
    base folder it’s searching. These subfolders become the base folder in the recursive
    call. Let’s ask the three questions about this recursive function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk()`函数也会递归地对基础文件夹中的每个子文件夹进行调用。这些子文件夹成为递归调用中的基础文件夹。让我们对这个递归函数提出三个问题：'
- en: What is the base case? When the function has finished processing each file and
    subfolder in its given base folder.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基本情况？当函数完成对给定基础文件夹中的每个文件和子文件夹的处理时。
- en: What argument is passed to the recursive function call? The base folder to search
    and the match function to use for finding matched files. For each subfolder in
    this folder, a recursive call is made with the subfolder as the new folder argument.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归函数调用传递了什么参数？要搜索的基础文件夹和用于查找匹配文件的匹配函数。对于该文件夹中的每个子文件夹，都会使用子文件夹作为新的文件夹参数进行递归调用。
- en: How does this argument become closer to the base case? Eventually, the function
    either recursively calls itself on all the subfolders or encounters base folders
    that don’t have any subfolders.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数如何变得更接近基本情况？最终，函数要么在所有子文件夹上递归调用自身，要么遇到没有任何子文件夹的基础文件夹。
- en: '[Figure 10-1](#figure10-1) shows an example filesystem along with the recursive
    calls to `walk()`, which it makes with a base folder of `C:\`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-1](#figure10-1)显示了一个示例文件系统以及对`walk()`的递归调用，它以`C:\`为基础文件夹进行调用。'
- en: '![Graphic depicting each folder in a filesystem and the corresponding calls
    to the walk() function. The base folder, C:\, corresponds to “walk(‘C:\\’, hasEvenByteSize).”
    The folder “spam” corresponds to “walk(‘C:\\spam’, hasEvenByteSize).” Within “spam,”
    the folder “eggs” corresponds to “walk(‘C:\\eggs’, hasEvenByteSize),” and the
    folder “ham” corresponds “walk(‘C:\\spam\\ham’, hasEvenByteSize).” Within “eggs,”
    the folder “bacon” corresponds to “walk(‘C\\spam\\eggs\\bacon’, hasEvenByteSize).”](image_fi/502024c10/f10001.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图形描绘了文件系统中每个文件夹以及对`walk()`函数的相应调用。基础文件夹C:\对应于“walk(‘C:\\’, hasEvenByteSize)”。文件夹“spam”对应于“walk(‘C:\\spam’,
    hasEvenByteSize)”。在“spam”中，文件夹“eggs”对应于“walk(‘C:\\eggs’, hasEvenByteSize)”，文件夹“ham”对应于“walk(‘C:\\spam\\ham’,
    hasEvenByteSize)”。在“eggs”中，文件夹“bacon”对应于“walk(‘C\\spam\\eggs\\bacon’, hasEvenByteSize)”](image_fi/502024c10/f10001.png)'
- en: 'Figure 10-1: An example filesystem and the recursive `walk()` function calls
    over it'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1：一个示例文件系统和递归的`walk()`函数对其的调用
- en: 'Let’s take a look at the `walk()` function’s code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`walk()`函数的代码：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `walk()` function has two parameters: `folder` is a string of the base
    folder to search (we can pass `''.''` to refer to the current folder the Python
    program is run from), and `matchFunc` is a Python function that is passed a filename
    and returns `True` if the function says it is a search match. Otherwise, the function
    returns `False`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk()`函数有两个参数：`folder`是要搜索的基础文件夹的字符串（我们可以传入''.''来指代Python程序所在的当前文件夹），`matchFunc`是一个Python函数，它接受一个文件名并在函数说它是搜索匹配时返回`True`。否则，函数返回`False`。'
- en: 'The next part of the function examines the contents of `folder`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的下一部分检查`folder`的内容：
- en: '**Python**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `for` loop calls `os.listdir()` to return a list of the contents of the
    `folder` folder. This list includes all files and subfolders. For each file, we
    create the full, absolute path by joining the folder with the name of the file
    or folder. If the name refers to a file, the `os.path.isfile()` function call
    returns `True`, and we’ll check to see if the file is a search match:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环调用`os.listdir()`返回`folder`文件夹内容的列表。此列表包括所有文件和子文件夹。对于每个文件，我们通过将文件夹与文件或文件夹的名称连接起来创建完整的绝对路径。如果名称指的是文件，则`os.path.isfile()`函数调用返回`True`，我们将检查文件是否是搜索匹配项：'
- en: '**Python**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We call the match function, passing it the full absolute filepath of the `for`
    loop’s current file. Note that `matchFunc` is the name of one of `walk()`’s parameters.
    If `hasEvenByteSize()`, `hasEveryVowel()`, or another function is passed as the
    argument for the `matchFunc` parameter, then that is the function `walk()` calls.
    If `filepath` contains a file that is a match according to the matching algorithm,
    it’s added to the `matches` list:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用匹配函数，将`for`循环当前文件的完整绝对文件路径传递给它。请注意，`matchFunc`是`walk()`的一个参数的名称。如果`hasEvenByteSize()`，`hasEveryVowel()`或另一个函数作为`matchFunc`参数的参数传递，则`walk()`将调用该函数。如果`filepath`包含根据匹配算法匹配的文件，则将其添加到`matches`列表中：
- en: '**Python**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Otherwise, if the `for` loop’s file is a subfolder, the `os.path.isdir()` function
    call returns `True`. We then pass the subfolder to a recursive function call.
    The recursive call returns a list of all matching files in the subfolder (and
    its subfolders), which are then added to the `matches` list:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果`for`循环的文件是子文件夹，则`os.path.isdir()`函数调用返回`True`。然后我们将子文件夹传递给递归函数调用。递归调用返回子文件夹（及其子文件夹）中所有匹配文件的列表，然后将其添加到`matches`列表中：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After the `for` loop finishes, the `matches` list contains all the matching
    files in this folder (and in all its subfolders). This list becomes the return
    value for the `walk()` function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环完成后，`matches`列表包含此文件夹（及其所有子文件夹）中的所有匹配文件。此列表成为`walk()`函数的返回值。'
- en: Calling the walk() Function
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用walk()函数
- en: 'Now that we’ve implemented the `walk()` function and some match functions,
    we can run our custom file search. We pass the `''.''` string, a special directory
    name meaning *the current directory*, for the first argument to `walk()` so that
    it uses the folder the program was run from as the base folder to search:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了`walk()`函数和一些匹配函数，我们可以运行我们自定义的文件搜索。我们将`'.'`字符串作为`walk()`的第一个参数传递，这是一个特殊的目录名称，表示*当前目录*，以便它使用程序运行的文件夹作为基本文件夹进行搜索：
- en: '**Python**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of this program depends on what files are on your computer, but
    this demonstrates how you can write code for any search criteria you have. For
    example, the output could look like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序的输出取决于计算机上的文件，但这演示了您如何为任何搜索条件编写代码。例如，输出可能如下所示：
- en: '**Python**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Useful Python Standard Library Functions for Working with Files
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于处理文件的有用的Python标准库函数
- en: Let’s take a look at some functions that could help you as you write your own
    match functions. The standard library of modules that comes with Python features
    several useful functions for getting information about files. Many of these are
    in the `os` and `shutil` modules, so your program must run `import os` or `import
    shutil` before it can call these functions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些函数，这些函数在编写自己的匹配函数时可能会对您有所帮助。Python附带的标准库模块中有几个有用的函数，用于获取有关文件的信息。其中许多位于`os`和`shutil`模块中，因此您的程序必须在调用这些函数之前运行`import
    os`或`import shutil`。
- en: Finding Information About the File’s Name
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找有关文件名称的信息
- en: 'The full filepath passed to the match functions can be broken into the base
    name and directory name with the `os.path.basename()` and `os.path.dirname()`
    functions. You can also call `os.path.split()` to obtain these names as a tuple.
    Enter the following into Python’s interactive shell. On macOS or Linux, try using
    `/bin/ls` as the filename:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给匹配函数的完整文件路径可以使用`os.path.basename()`和`os.path.dirname()`函数分解为基本名称和目录名称。您还可以调用`os.path.split()`将这些名称作为元组获取。在Python的交互式shell中输入以下内容。在macOS或Linux上，尝试使用`/bin/ls`作为文件名：
- en: '**Python**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can use any of Python’s string methods on these string values to help evaluate
    the file against your search criteria, such as `lower()` in the `hasEveryVowel()`
    match function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这些字符串值上使用Python的任何字符串方法来帮助评估文件是否符合您的搜索条件，例如`hasEveryVowel()`匹配函数中的`lower()`。
- en: Finding Information About the File’s Timestamps
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找有关文件时间戳的信息
- en: 'Files have timestamps indicating when they were created, last modified, and
    last accessed. Python’s `os.path.getctime()`, `os.path.getmtime()`, and `os.path.getatime()`,
    respectively, return these timestamps as floating-point values indicating the
    number of seconds since the *Unix epoch*, midnight on January 1, 1970, in the
    Coordinated Universal Time (UTC) time zone. Enter the following into the interactive
    shell:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 文件具有指示它们创建时间、上次修改时间和上次访问时间的时间戳。Python的`os.path.getctime()`，`os.path.getmtime()`和`os.path.getatime()`分别将这些时间戳作为浮点值返回，指示自*Unix纪元*以来的秒数，即1970年1月1日协调世界时（UTC）时区的午夜。在交互式shell中输入以下内容：
- en: '**Python**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These float values are easy for programs to use since they’re just single numbers,
    but you’ll need functions from Python’s `time` module to make them simpler for
    humans to read. The `time.localtime()` function converts a Unix epoch timestamp
    into a `struct_time` object in the computer’s time zone. A `struct_time` object
    has several attributes whose names begin with `tm_` for obtaining date and time
    information. Enter the following into the interactive shell:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些浮点值对程序来说很容易使用，因为它们只是单个数字，但您需要使用Python的`time`模块中的函数使它们对人类更容易阅读。`time.localtime()`函数将Unix纪元时间戳转换为计算机所在时区的`struct_time`对象。`struct_time`对象具有几个属性，其名称以`tm_`开头，用于获取日期和时间信息。在交互式shell中输入以下内容：
- en: '**Python**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the `tm_mday` attribute is the day of the month, ranging from `1`
    to `31`. The `tm_wday` attribute is the day of the week, starting at `0` for Monday,
    `1` for Tuesday, and so on, up to `6` for Sunday.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`tm_mday`属性是月份的日期，范围是`1`到`31`。`tm_wday`属性是星期几，从星期一的`0`开始，星期二的`1`，依此类推，直到星期日的`6`。
- en: 'If you need a brief, human-readable string of the `time_struct` object, pass
    it to the `time.asctime()` function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要`time_struct`对象的简短、可读的字符串，请将其传递给`time.asctime()`函数：
- en: '**Python**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'While the `time.localtime()` function returns a `struct_time` object in the
    local time zone, the `time.gmtime()` function returns a `struct_time` object in
    the UTC or Greenwich Mean time zone. Enter the following into the interactive
    shell:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 而`time.localtime()`函数返回本地时区的`struct_time`对象，`time.gmtime()`函数返回UTC或格林威治标准时间时区的`struct_time`对象。将以下内容输入交互式shell：
- en: '**Python**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The interaction between these `os.path` functions (which return Unix epoch timestamps)
    and `time` functions (which return `struct_time` objects) can be confusing. [Figure
    10-2](#figure10-2) shows the chain of code starting from the filename string and
    ending with obtaining the individual parts of the timestamp.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`os.path`函数（返回Unix纪元时间戳）与`time`函数（返回`struct_time`对象）之间的交互可能会令人困惑。[图10-2](#figure10-2)显示了从文件名字符串开始的代码链，以获取时间戳的各个部分。
- en: '![Flowchart. Arrow points from “filename” to “os.path.getctime(), os.path.getmtime(),
    os.path.getatime()” to “time.localtime(), time.gmtime()” to “time.asctime(), .tm_year,
    .tm_mon, .tm_mday, .tm_wday, .tm_hour, .tm_min, .tm_sec.”](image_fi/502024c10/f10002.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![流程图。箭头从“文件名”指向“os.path.getctime()、os.path.getmtime()、os.path.getatime()”指向“time.localtime()、time.gmtime()”指向“time.asctime()、.tm_year、.tm_mon、.tm_mday、.tm_wday、.tm_hour、.tm_min、.tm_sec。”](image_fi/502024c10/f10002.png)'
- en: 'Figure 10-2: Going from the filename to the individual attributes of a timestamp'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2：从文件名到时间戳的各个属性
- en: Finally, the `time.time()` function returns the number of seconds since the
    Unix epoch to the current time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`time.time()`函数返回自Unix纪元以来到当前时间的秒数。
- en: Modifying Your Files
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改您的文件
- en: After the `walk()` function returns a list of files matching your search criteria,
    you may want to rename, delete, or perform another operation on them. The `shutil`
    and `os` modules in the Python standard library have functions to do this. Further,
    the `send2trash` third-party module can also send files to your operating system’s
    Recycle Bin, rather than permanently deleting them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk()`函数返回与您的搜索条件匹配的文件列表后，您可能希望对它们进行重命名、删除或执行其他操作。Python标准库中的`shutil`和`os`模块具有执行此操作的函数。此外，第三方模块`send2trash`也可以将文件发送到操作系统的回收站，而不是永久删除它们。'
- en: 'To move a file, call the `shutil.move()` function with two arguments. The first
    argument is the file to move, and the second is the folder to move it to. For
    example, you could call the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动文件，请使用`shutil.move()`函数并提供两个参数。第一个参数是要移动的文件，第二个是要将其移动到的文件夹。例如，您可以调用以下内容：
- en: '**Python**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `shutil.move()` function returns the string of the new filepath of the
    file. You can also specify a filename to move and rename the file at the same
    time:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutil.move()`函数返回文件的新文件路径字符串。您还可以指定文件名以同时移动和重命名文件：'
- en: '**Python**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the second argument lacks a folder, you can just specify a new name for
    the file to rename it in its current folder:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个参数缺少文件夹，您可以只指定一个新名称以在当前文件夹中重命名文件：
- en: '**Python**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the `shutil.move()` function both moves and renames files, similar
    to the way the Unix and macOS `mv` command both moves and renames files. There
    is no separate `shutil.rename()` function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`shutil.move()`函数既移动又重命名文件，类似于Unix和macOS的`mv`命令移动和重命名文件。没有单独的`shutil.rename()`函数。
- en: 'To copy a file, call the `shutil.copy()` function with two arguments. The first
    argument is the filename of the file to copy, and the second argument is the new
    name of the copy. For example, you could call the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制文件，请使用`shutil.copy()`函数并提供两个参数。第一个参数是要复制的文件的文件名，第二个参数是副本的新名称。例如，您可以调用以下内容：
- en: '**Python**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `shutil.copy()` function returns the name of the copy. To delete a file,
    call the `os.unlink()` function and pass it the name of the file to delete:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutil.copy()`函数返回副本的名称。要删除文件，请调用`os.unlink()`函数并将要删除的文件的名称传递给它：'
- en: '**Python**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The name *unlink* is used instead of *delete* because of the technical detail
    that it removes the filename linked to the file. But since most files have only
    one linked filename, this unlinking also deletes the file. It’s all right if you
    don’t understand these filesystem concepts; just know that `os.unlink()` deletes
    a file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*unlink*而不是*delete*的名称是因为它删除了与文件链接的文件名的技术细节。但由于大多数文件只有一个链接的文件名，这种取消链接也会删除文件。如果您不理解这些文件系统概念，也没关系，只需知道`os.unlink()`会删除文件。
- en: Calling `os.unlink()` permanently deletes the file, which can be dangerous if
    a bug in your program causes the function to delete the wrong file. Instead, you
    can use the `send2trash` module’s `send2trash()` function to put the file in your
    operating system’s Recycle Bin. To install this module, run `run python -m pip
    install --user send2trash` from the command prompt on Windows or run `run python3
    -m pip install` from the terminal on macOS or Linux. Once the module is installed,
    you’ll be able to import it with `import send2trash`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`os.unlink()`会永久删除文件，如果程序中的错误导致函数删除错误的文件，这可能是危险的。相反，您可以使用`send2trash`模块的`send2trash()`函数将文件放入操作系统的回收站。要安装此模块，请在Windows命令提示符上运行`run
    python -m pip install --user send2trash`，或在macOS或Linux终端上运行`run python3 -m pip
    install`。安装模块后，您将能够使用`import send2trash`导入它。
- en: 'Enter the following into the interactive shell:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容输入交互式shell：
- en: '**Python**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This example creates a blank file named *deleteme.txt*. After calling `send2trash.send2trash()`
    (the module and function share the same name), this file is removed to the Recycle
    Bin.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例创建一个名为*deleteme.txt*的空文件。调用`send2trash.send2trash()`（模块和函数同名），此文件将被移除到回收站。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter’s file-search project uses recursion to “walk” across the contents
    of a folder and all its subfolders. The file-finder program’s `walk()` function
    navigates these folders recursively, applying custom search criteria to every
    file in every subfolder. The search criteria are implemented as match functions,
    which are passed to the `walk()` function. This allows us to change the search
    criteria by writing new functions instead of modifying the code in `walk()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的文件搜索项目使用递归来“遍历”文件夹及其所有子文件夹的内容。文件查找程序的`walk()`函数递归地导航这些文件夹，将自定义搜索条件应用于每个子文件夹中的每个文件。搜索条件被实现为匹配函数，这些函数被传递给`walk()`函数。这使我们能够通过编写新函数而不是修改`walk()`中的代码来更改搜索条件。
- en: Our project had two match functions, for finding files with an even byte file
    size or containing every vowel in its name, but you can write your own functions
    to pass to `walk()`. This is the power behind programming; you can create features
    for your own needs that are not available in commercial apps.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目有两个匹配函数，用于查找文件大小为偶数字节或包含其名称中的每个元音字母，但您可以编写自己的函数传递给`walk()`。这就是编程的力量；您可以为自己的需求创建商业应用程序中不可用的功能。
- en: Further Reading
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The documentation for Python’s built-in `os.walk()` function (similar to the
    `walk()` function in the file-finder project) is at [https://docs.python.org/3/library/os.html#os.walk](https://docs.python.org/3/library/os.html#os.walk).
    You can also learn more about your computer’s filesystem and Python’s file functions
    in Chapter 9 of my book *Automate the Boring Stuff with Python*, 2nd edition (No
    Starch Press, 2019) at [https://automatetheboringstuff.com/2e/chapter9](https://automatetheboringstuff.com/2e/chapter9).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Python内置的`os.walk()`函数的文档（类似于文件查找器项目中的`walk()`函数）位于[https://docs.python.org/3/library/os.html#os.walk](https://docs.python.org/3/library/os.html#os.walk)。您还可以在我的书*Automate
    the Boring Stuff with Python*第9章中了解有关计算机文件系统和Python文件函数的更多信息，第2版（No Starch Press，2019）位于[https://automatetheboringstuff.com/2e/chapter9](https://automatetheboringstuff.com/2e/chapter9)。
- en: The `datetime` module in the Python standard library also has more ways to interact
    with timestamp data. You can learn more about it in Chapter 17 of *Automate the
    Boring Stuff with Python*, 2nd edition at [https://automatetheboringstuff.com/2e/chapter17](https://automatetheboringstuff.com/2e/chapter17).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中的`datetime`模块还有更多与时间戳数据交互的方法。您可以在*Automate the Boring Stuff with Python*第17章中了解更多信息，第2版位于[https://automatetheboringstuff.com/2e/chapter17](https://automatetheboringstuff.com/2e/chapter17)。
- en: '11'
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Maze Generator
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫生成器
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Chapter 4 described a recursive algorithm that solves mazes, but another recursive
    algorithm generates mazes. In this chapter, we’ll generate mazes in the same format
    as the maze-solver program in Chapter 4. So, whether you’re a fan of solving mazes
    or creating them, you’ll now have the power to apply programming to the task.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第4章描述了一个解决迷宫的递归算法，但另一个递归算法生成迷宫。在本章中，我们将以第4章中迷宫求解程序相同的格式生成迷宫。因此，无论您是迷宫的解决者还是创建者，现在您都有能力将编程应用于此任务。
- en: The algorithm works by visiting a starting space in the maze and then recursively
    visiting a neighboring space. The maze’s hallways are “carved out” of the maze
    as the algorithm continues to visit neighbors. If the algorithm reaches a dead
    end that has no neighboring spaces, it backtracks to earlier spaces until it finds
    an unvisited neighbor and continues visiting from there. By the time the algorithm
    backtracks to the starting space, the entire maze has been generated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法通过访问迷宫中的一个起始空间，然后递归地访问相邻的空间来工作。随着算法继续访问相邻空间，迷宫的走廊被“刻出”。如果算法到达没有相邻空间的死胡同，它会回溯到先前的空间，直到找到一个未访问的相邻空间，并继续从那里访问。当算法回溯到起始空间时，整个迷宫已经生成。
- en: The recursive backtracking algorithm we’ll use here produces mazes that tend
    to have long hallways (the maze spaces that connect branching intersections) and
    are fairly simple to solve. However, this algorithm is easier to implement than
    many other maze-generation algorithms, such as Kruskal’s algorithm or Wilson’s
    algorithm, so it serves as a good introduction to the topic.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用的递归回溯算法生成的迷宫倾向于具有长走廊（连接分支交叉点的迷宫空间）并且相当容易解决。但是，这种算法比许多其他迷宫生成算法（如Kruskal算法或Wilson算法）更容易实现，因此它是该主题的很好介绍。
- en: The Complete Maze-Generator Program
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的迷宫生成器程序
- en: Let’s begin by taking a look at the complete Python and JavaScript source code
    for the program, which uses the recursive backtracking algorithm for maze generation.
    The rest of this chapter explains each section of code individually.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下程序的完整Python和JavaScript源代码，该程序使用递归回溯算法生成迷宫。本章的其余部分将逐个解释代码的每个部分。
- en: 'Copy this Python code to a file named *mazeGenerator.py*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将此Python代码复制到名为*mazeGenerator.py*的文件中：
- en: '**Python**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Copy this JavaScript code to a file named *mazeGenerator.html*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将此JavaScript代码复制到名为*mazeGenerator.html*的文件中：
- en: '**JavaScript**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you run this program, it produces a large amount of text that will fill
    the terminal window or browser with each step of the maze’s construction. You’ll
    have to scroll back up to the top to view the entire output.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此程序时，它会产生大量文本，将填满终端窗口或浏览器，并显示迷宫构建的每一步。您将不得不向上滚动以查看整个输出。
- en: The maze data structure begins as a completely filled-in 2D space. The recursive
    backtracker algorithm is given a starting point in this maze and then visits a
    previously unvisited neighboring space, “carving out” any hallway space in the
    process. Then it recursively calls itself on a neighboring space it hasn’t visited
    before. If all the neighboring spaces have already been visited, the algorithm
    is at a dead end and backtracks to an earlier visited space to visit its unvisited
    neighbors. The program ends when the algorithm backtracks to its starting location.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫数据结构开始时是一个完全填满的二维空间。递归回溯算法在这个迷宫中给出一个起始点，然后访问一个先前未访问的相邻空间，在这个过程中“挖出”任何走廊空间。然后它在一个以前未访问过的相邻空间上递归调用自身。如果所有相邻空间都已经被访问过，算法就会陷入死胡同，并回溯到先前访问过的空间以访问它的未访问的邻居。当算法回溯到起始位置时，程序结束。
- en: You can see this algorithm in action by running the maze-generator program.
    As the maze is carved out, it displays the current x, y coordinates by using the
    `@` character. The process looks like [Figure 11-1](#figure11-1). Notice that
    the fifth image in the top-right corner has backtracked to an earlier space after
    reaching a dead end to explore a new neighboring direction from that space.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行迷宫生成器程序，您可以看到这个算法的运行过程。当迷宫被挖出时，它会使用`@`字符显示当前的x，y坐标。这个过程看起来像[图11-1](#figure11-1)。请注意，右上角的第五张图在到达死胡同后回溯到了一个先前的空间，以探索从那个空间的新邻居方向。
- en: '![Diagram showing a maze being created one line at a time. The line backtracks
    every time it encounters a dead end. It eventually fills the entire screen.](image_fi/502024c11/f11001.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![显示迷宫一行一行地创建的图表。每次遇到死胡同时，该行都会回溯。最终填满整个屏幕。](image_fi/502024c11/f11001.png)'
- en: 'Figure 11-1: The maze as it gets “carved out” by the recursive backtracking
    algorithm'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1：递归回溯算法“挖出”的迷宫
- en: Let’s take a look at the code in more detail.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下代码。
- en: Setting Up the Maze Generator’s Constants
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置迷宫生成器的常量
- en: 'The maze generator uses several constants, which we can change before running
    the program to alter the size and appearance of the maze. The Python code for
    these constants is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫生成器使用了几个常量，我们可以在运行程序之前更改这些常量以改变迷宫的大小和外观。这些常量的Python代码如下：
- en: '**Python**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The JavaScript code is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The constants `WIDTH` and `HEIGHT` dictate the size of the maze. They must be
    odd numbers, because our maze data structure requires walls between the visited
    spaces of the maze, leaving us with odd-numbered dimensions. To make sure the
    `WIDTH` and `HEIGHT` constants are set correctly, we use assertions to stop the
    program if the constants aren’t odd or are too small.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`WIDTH`和`HEIGHT`决定了迷宫的大小。它们必须是奇数，因为我们的迷宫数据结构要求迷宫的访问空间之间有墙壁，留下奇数维度。为了确保`WIDTH`和`HEIGHT`常量被正确设置，我们使用断言来阻止程序如果常量不是奇数或太小的话。
- en: The program relies on a random seed value to reproduce the same maze, given
    the same seed value. The Python version of this program lets us set this value
    by calling the `random.seed()` function. Unfortunately, JavaScript doesn’t have
    a way to set the seed value explicitly and will generate different mazes each
    time we run the program.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 程序依赖于一个随机种子值来根据相同的种子值重现相同的迷宫。这个程序的Python版本让我们通过调用`random.seed()`函数来设置这个值。不幸的是，JavaScript没有一种明确设置种子值的方法，每次运行程序都会生成不同的迷宫。
- en: 'The Python code continues by setting a few more constants:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码继续设置一些常量：
- en: '**Python**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The JavaScript code for these constants is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量的JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `EMPTY` and `WALL` constants affect how the maze is displayed on the screen.
    The `MARK` constant is used to point out the position of the algorithm in the
    maze as it runs. The `NORTH`, `SOUTH`, `EAST`, and `WEST` constants represent
    the directions that the mark can move through the maze and are used to make the
    code more readable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`EMPTY`和`WALL`常量影响了迷宫在屏幕上的显示方式。`MARK`常量用于指出算法在迷宫中的位置。`NORTH`，`SOUTH`，`EAST`和`WEST`常量表示标记可以通过迷宫的方向，并用于使代码更易读。'
- en: Creating the Maze Data Structure
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建迷宫数据结构
- en: The maze data structure is a Python dictionary or JavaScript object that has
    keys of Python tuples or JavaScript arrays of the x, y coordinates of every space
    in the maze. The value for these keys is a string in the `WALL` or `EMPTY` constant.
    This string notes whether this space is a blocking wall or a passable empty space
    in the maze.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫数据结构是一个Python字典或JavaScript对象，它的键是Python元组或JavaScript数组，表示迷宫中每个空间的x，y坐标。这些键的值是`WALL`或`EMPTY`常量的字符串。这个字符串表示这个空间是迷宫中的阻挡墙还是可通过的空白空间。
- en: 'For example, the maze in [Figure 11-2](#figure11-2) is represented by the following
    data structure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图11-2](#figure11-2)中的迷宫由以下数据结构表示：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Diagram of a grid whose x- and y-axes are numbered 0 through 6, assigning
    each cell in the grid a numerical x and y value.](image_fi/502024c11/f11002.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![一个网格的图表，其x轴和y轴从0到6编号，为网格中的每个单元格分配了数值x和y。](image_fi/502024c11/f11002.png)'
- en: 'Figure 11-2: An example maze that can be represented by a data structure'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2：一个可以用数据结构表示的示例迷宫
- en: 'The program must start with every space set to `WALL`. The recursive `visit()`
    function then carves out the hallways and intersections of the maze by setting
    spaces to `EMPTY`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 程序必须从每个空间设置为`WALL`开始。然后递归的`visit()`函数通过将空间设置为`EMPTY`来挖出迷宫的走廊和交叉点：
- en: '**Python**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The corresponding JavaScript code is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We create the blank dictionary (in Python) or object (in JavaScript) in the
    `maze` global variable. The `for` loops loop over every possible x, y coordinate,
    setting each to `WALL` to create a completely filled-in maze. The call to `visit()`
    will carve out the hallways of the maze from this data structure by setting the
    spaces in it to `EMPTY`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`maze`全局变量中创建空字典（在Python中）或对象（在JavaScript中）。`for`循环遍历每个可能的x，y坐标，将每个设置为`WALL`，以创建一个完全填充的迷宫。调用`visit()`将从这个数据结构中刻出迷宫的走廊，将其中的空间设置为`EMPTY`。
- en: Printing the Maze Data Structure
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印迷宫数据结构
- en: To represent the maze as a data structure, the Python program uses a dictionary,
    and the JavaScript program uses an object. Within this structure, the keys are
    lists or arrays of two integers for the x- and y-coordinates, while the value
    is either the `WALL` or `EMPTY` single-character strings. Thus, we can access
    the wall or empty hallway space at the coordinates x, y in the maze as `maze[(x,
    y)]` in Python code and as `maze[[x, y]]` in JavaScript code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示迷宫作为数据结构，Python程序使用字典，JavaScript程序使用对象。在这个结构中，键是包含两个整数的列表或数组，分别代表x和y坐标，而值要么是`WALL`要么是`EMPTY`单字符字符串。因此，我们可以在Python代码中通过`maze[(x,
    y)]`或在JavaScript代码中通过`maze[[x, y]]`访问迷宫中坐标x，y的墙壁或空走廊空间。
- en: 'The Python code for `printMaze()` starts as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`printMaze()`的Python代码如下开始：'
- en: '**Python**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The JavaScript code for `printMaze()` starts as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`printMaze()`的JavaScript代码如下开始：'
- en: '**JavaScript**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `printMaze()` function prints the maze data structure it’s passed as the
    maze parameter on the screen. Optionally, if `markX` and `markY` integer arguments
    are passed, the `MARK` constant (which we set to `@`) appears at these x, y coordinates
    in the printed maze. To make sure the maze is printed in a monospace font, the
    JavaScript version writes the HTML tag `<code>` before printing the maze itself.
    Without this HTML tag, the maze will appear distorted in the browser.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`printMaze()`函数在屏幕上打印作为迷宫参数传递的迷宫数据结构。可选地，如果传递了`markX`和`markY`整数参数，则在打印的迷宫中，`MARK`常量（我们设置为`@`）将出现在这些x，y坐标上。为了确保迷宫以等宽字体打印，JavaScript版本在打印迷宫本身之前写入HTML标签`<code>`。没有这个HTML标签，迷宫将在浏览器中显示扭曲。'
- en: Within the function, nested `for` loops loop over every space in the maze data
    structure. These `for` loops iterate over each y-coordinate from `0` up to, but
    not including, `HEIGHT`, and each x-coordinate from `0` up to, but not including,
    `WIDTH`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，嵌套的`for`循环遍历迷宫数据结构中的每个空间。这些`for`循环分别从`0`到`HEIGHT`的y坐标和从`0`到`WIDTH`的x坐标进行迭代。
- en: 'Inside the inner `for` loop, if the current x, y coordinates match the position
    of the mark (the location where the algorithm is currently carving), the program
    displays the `@` in the `MARK` constant. The Python code does this as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部的`for`循环中，如果当前的x，y坐标与标记的位置（算法当前正在刻划的位置）匹配，程序会在`MARK`常量中显示`@`。Python代码如下：
- en: '**Python**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The JavaScript code is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Otherwise, the program displays either the `WALL` or `EMPTY` constant’s character
    at this x, y coordinate in the `maze` data structure by printing `maze[(x, y)]`
    in Python and `maze[[x, y]]` in JavaScript. After the inner `for` loop is done
    looping over the x-coordinates, we print a newline at the end of the row in preparation
    for the next row.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，程序通过在`maze`数据结构中打印`maze[(x, y)]`（在Python中）或`maze[[x, y]]`（在JavaScript中）来显示`WALL`或`EMPTY`常量的字符。在内部的`for`循环完成对x坐标的迭代后，我们在行末打印一个换行符，为下一行做准备。
- en: Using the Recursive Backtracker Algorithm
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用递归回溯算法
- en: 'The `visit()` function implements the recursive backtracker algorithm. The
    function has a list (in Python) or array (in JavaScript) that keeps track of the
    x, y coordinates that have already been visited by previous `visit()` function
    calls. It also in-place modifies the global `maze` variable that stores the maze
    data structure. The Python code for `visit()` begins as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`visit()`函数实现了递归回溯算法。该函数有一个列表（在Python中）或数组（在JavaScript中），用于跟踪先前的`visit()`函数调用已经访问过的x，y坐标。它还就地修改了存储迷宫数据结构的全局`maze`变量。`visit()`的Python代码如下开始：'
- en: '**Python**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The JavaScript code for `visit()` begins as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`visit()`的JavaScript代码如下开始：'
- en: '**JavaScript**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `visit()` function accepts x, y coordinates as arguments for the place in
    the maze the algorithm is visiting. Then the function changes the data structure
    in `maze` at this location to an empty space. To let the user see the progression
    of the maze generation, it calls `printMaze()`, passing the `x` and `y` arguments
    as the current position of the mark.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`visit()`函数接受x，y坐标作为迷宫中算法正在访问的位置的参数。然后函数将`maze`中这个位置的数据结构更改为空格。为了让用户看到迷宫生成的进展，它调用`printMaze()`，将`x`和`y`参数作为标记的当前位置传递进去。'
- en: 'Next, the recursive backtracker calls `visit()` with the coordinates of a previously
    unvisited neighboring space. The Python code continues as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，递归回溯调用`visit()`，使用先前未访问的相邻空间的坐标。Python代码继续如下：
- en: '**Python**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The JavaScript code continues as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码继续如下：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `while` loop continues to loop as long as unvisited neighbors remain for
    this location in the maze. We create a list or array of unvisited neighboring
    spaces in the `unvisitedNeighbors` variables. Four `if` statements check that
    the current x, y position is not on the border of the maze (so that we still have
    a neighboring space to check) and whether the neighboring space’s x, y coordinates
    don’t appear in the `hasVisited` list or array already.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环会继续循环，只要迷宫中这个位置还有未访问的相邻空间。我们在`unvisitedNeighbors`变量中创建一个未访问的相邻空间的列表或数组。四个`if`语句检查当前的x，y位置是否不在迷宫的边界上（这样我们仍然有相邻的空间要检查），以及相邻空间的x，y坐标是否已经出现在`hasVisited`列表或数组中。'
- en: 'If all the neighbors have been visited, the function returns so that it can
    backtrack to an earlier space. The Python code continues on to check for the base
    case:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有相邻空间都已经被访问，函数将返回，以便可以回溯到较早的空间。Python代码继续检查基本情况：
- en: '**Python**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The JavaScript code does so as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下所示：
- en: '**JavaScript**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The base case for the recursive backtracking algorithm occurs when no unvisited
    neighbors remain to visit next. In this case, the function simply returns. The
    `visit()` function itself has no return value. Rather, the recursive function
    calls `visit()` to modify the maze data structure in the global `maze` variable
    as a side effect. When the original function call to `maze()` returns, the `maze`
    global variable contains the completely generated maze.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 递归回溯算法的基本情况是当没有未访问的相邻空间时发生。在这种情况下，函数简单地返回。`visit()`函数本身没有返回值。相反，递归函数调用`visit()`以副作用的方式修改全局`maze`变量中的迷宫数据结构。当对`maze()`的原始函数调用返回时，`maze`全局变量包含完全生成的迷宫。
- en: 'The Python code continues on to the recursive case like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码继续到这样的递归情况：
- en: '**Python**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The JavaScript code continues as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下继续：
- en: '**JavaScript**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `unvisitedNeighbors` list or array contains one or more of the `NORTH`,
    `SOUTH`, `WEST`, and `EAST` constants. We choose one of these directions for the
    next recursive call to `visit()`, and then set the `nextX` and `nextY` variables
    with the coordinates of the neighboring space in this direction.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`unvisitedNeighbors`列表或数组包含一个或多个`NORTH`、`SOUTH`、`WEST`和`EAST`常量。我们选择其中一个方向作为下一个递归调用`visit()`的方向，然后使用这个方向的相邻空间的坐标设置`nextX`和`nextY`变量。'
- en: After this, we add the x, y coordinates of `nextX` and `nextY` to the `hasVisited`
    list or array before making the recursive call for this neighboring space. In
    this way, the `visit()` function continues to visit neighboring spaces, carving
    out the maze hallways by setting locations in `maze` to `EMPTY`. The connecting
    hallway between the current space and neighboring space is also set to `EMPTY`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将`nextX`和`nextY`的x、y坐标添加到`hasVisited`列表或数组中，然后对这个相邻空间进行递归调用。这样，`visit()`函数将继续访问相邻空间，通过将`maze`中的位置设置为`EMPTY`来carve
    out迷宫走廊。当前空间和相邻空间之间的连接走廊也被设置为`EMPTY`。
- en: When no neighbors exist, the base case simply returns to an earlier location.
    In the `visit()` function, the execution jumps back to the start of the `while`
    loop. The code in the `while` loop again checks which neighboring spaces haven’t
    been visited and makes a recursive `visit()` call on one of them, or returns if
    all neighboring spaces have already been visited.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有相邻空间存在时，基本情况简单地返回到较早的位置。在`visit()`函数中，执行跳回到`while`循环的开始。`while`循环中的代码再次检查哪些相邻空间尚未被访问，并对其中一个进行递归`visit()`调用，或者如果所有相邻空间已经被访问，则返回。
- en: As the maze fills up with hallways and each space has been visited, the recursive
    calls will continue to return until the original `visit()` function call returns.
    At this point, the maze variable contains the completely generated maze.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 随着迷宫填满走廊并且每个空间都被访问，递归调用将继续返回，直到原始的`visit()`函数调用返回。此时，迷宫变量包含完全生成的迷宫。
- en: Starting the Chain of Recursive Calls
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始递归调用链
- en: 'The recursive `visit()` uses two global variables, `maze` and `hasVisited`.
    The `hasVisited` variable is a list or array containing the x, y coordinates of
    every space the algorithm has visited and begins with `(1, 1)` since that is the
    maze starting point. The Python code for this is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 递归`visit()`使用两个全局变量，`maze`和`hasVisited`。`hasVisited`变量是一个包含算法访问过的每个空间的x、y坐标的列表或数组，并且从`(1,
    1)`开始，因为那是迷宫的起点。这在Python代码中如下：
- en: '**Python**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The JavaScript code for this is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After setting up `hasVisited` to include the x, y coordinates of 1, 1 (the top-left
    corner of the maze), we call `visit()` with these coordinates. This function call
    will result in all the recursive function calls that generate the hallways of
    the maze. By the time this function call returns, `hasVisited` will contain every
    x, y coordinate of the maze, and `maze` will contain the completely generated
    maze.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置`hasVisited`以包括1, 1的x、y坐标（迷宫的左上角）之后，我们使用这些坐标调用`visit()`。这个函数调用将导致生成迷宫走廊的所有递归函数调用。当这个函数调用返回时，`hasVisited`将包含迷宫的每个x、y坐标，而`maze`将包含完全生成的迷宫。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: As you just learned, we can use recursion to not only solve mazes (by traversing
    them as tree data structures) but also generate them using the recursive backtracker
    algorithm. The algorithm “carves out” hallways in the maze, backtracking to earlier
    points when it encounters a dead end. Once the algorithm is forced to backtrack
    to the starting point, the maze is completely generated.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚学到的，我们不仅可以使用递归来解决迷宫问题（通过遍历它们作为树数据结构），还可以使用递归回溯算法来生成迷宫。该算法在迷宫中“carves out”走廊，在遇到死胡同时回溯到较早的点。一旦算法被迫回溯到起点，迷宫就完全生成了。
- en: We can represent a well-connected maze with no loops as a DAG—that is, a tree
    data structure. The recursive backtracker algorithm makes use of the idea that
    recursive algorithms are well suited to problems involving tree-like data structures
    and backtracking.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将没有循环的良好连接的迷宫表示为DAG——即树数据结构。递归回溯算法利用了递归算法适用于涉及树状数据结构和回溯的问题的思想。
- en: Further Reading
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Wikipedia has an entry on maze generation in general, with a section on the
    recursive backtracker algorithm, at [https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker](https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker).
    I’ve created a browser-based animation of the recursive backtracker algorithm
    that shows the “carving” of hallways in action at [https://scratch.mit.edu/projects/17358777](https://scratch.mit.edu/projects/17358777).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科通常有关于迷宫生成的条目，其中包括关于递归回溯算法的部分，网址为[https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker](https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker)。我创建了一个基于浏览器的递归回溯算法的动画，展示了走廊的“雕刻”过程，网址为[https://scratch.mit.edu/projects/17358777](https://scratch.mit.edu/projects/17358777)。
- en: 'If maze generation interests you, you should read *Mazes for Programmers: Code
    Your Own Twisty Little Passages* by Jamis Buck (Pragmatic Bookshelf, 2015).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对迷宫生成感兴趣，你应该阅读Jamis Buck的《程序员的迷宫：编写自己的曲折小通道》（Pragmatic Bookshelf，2015）。
- en: '12'
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Sliding-Tile Solver
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动瓷砖求解器
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: A *sliding-tile puzzle*, or *15-puzzle*, is a small puzzle game implemented
    as a set of 15 numbered sliding tiles on a 4 × 4 board. One tile is missing, allowing
    adjacent tiles to slide into the empty space on the board. The player’s goal is
    to move the tiles into numeric order, as in [Figure 12-1](#figure12-1). Some versions
    of this game have fragments of a picture on the tiles that create a whole image
    when the puzzle is complete.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*滑动瓷砖拼图*，或*15拼图*，是一个小拼图游戏，由一个4×4棋盘上的15个编号滑动瓷砖组成。一个瓷砖是缺失的，允许相邻的瓷砖滑入棋盘上的空白空间。玩家的目标是将瓷砖移动到数字顺序，就像[图12-1](#figure12-1)中一样。这个游戏的一些版本在瓷砖上有一个图片的碎片，当拼图完成时可以组成一个完整的图像。'
- en: '![Image of two 4 × 4 grids of numbered tiles with one missing tile each. The
    first grid’s numbers are out of order. The second grid’s numbers are ordered 1–15
    from left to right.](image_fi/502024c12/f12001.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![两个4×4编号瓷砖网格的图像，每个网格都缺少一个瓷砖。第一个网格的数字顺序错乱。第二个网格的数字从左到右按顺序排列为1-15。](image_fi/502024c12/f12001.png)'
- en: 'Figure 12-1: Solving a numeric sliding-tile puzzle from its scrambled state
    (left) to its solved, ordered state (right)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-1：从数字滑动瓷砖拼图的混乱状态（左）到解决的有序状态（右）的解决方案
- en: Incidentally, mathematicians have proven that even the hardest 15-puzzle can
    be solved in 80 moves.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，数学家已经证明，即使最难的15拼图也可以在80步内解决。
- en: Solving 15-Puzzles Recursively
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归解决15拼图
- en: The algorithm that solves 15-puzzles is similar to the maze-solving algorithm.
    Each state of the board (that is, one arrangement of tiles) can be thought of
    as a maze intersection with four hallways to go down. In the case of 15-puzzles,
    sliding a tile in one of the four directions is like picking a hallway to follow
    to the next intersection.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 解决15拼图的算法类似于解决迷宫的算法。棋盘的每个状态（即，瓷砖的一种排列）都可以被看作是一个迷宫交叉口，有四条走廊可以通向。在15拼图的情况下，将瓷砖沿着四个方向滑动就像选择一个走廊，通向下一个交叉口。
- en: Just as you can turn a maze into a DAG, you can convert a 15-puzzle into a tree
    graph, as in [Figure 12-2](#figure12-2). The board states are nodes with up to
    four edges (representing a direction to slide a tile) to other nodes (representing
    the resultant state). The root node is the starting state of the 15-puzzle. The
    solved-state node is the one in which the tiles are ordered correctly. The path
    from the root node to the solved state details the slides needed to solve the
    puzzle.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以将迷宫转化为DAG一样，你也可以将15拼图转化为树图，就像[图12-2](#figure12-2)一样。棋盘状态是节点，最多有四条边（代表滑动瓷砖的方向）通向其他节点（代表结果状态）。根节点是15拼图的起始状态。解决状态节点是瓷砖正确排列的状态。从根节点到解决状态的路径详细说明了解决拼图所需的滑动。
- en: '![Tree graph in which each node is a 4 × 4 tile puzzle. The top node has two
    child nodes representing the two possible moves a player could make from that
    position, and each of those nodes has two child nodes representing all possible
    moves a player could make from those positions.](image_fi/502024c12/f12002.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![树图，其中每个节点都是一个4×4瓷砖拼图。顶部节点有两个子节点，代表玩家可以从该位置进行的两个可能移动，每个节点都有两个子节点，代表玩家可以从这些位置进行的所有可能移动。](image_fi/502024c12/f12002.png)'
- en: 'Figure 12-2: The task of solving a 15-puzzle can be represented as a graph
    with tile states as nodes and slides as edges.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-2：解决15拼图的任务可以表示为一个图，其中瓷砖状态为节点，滑动为边。
- en: Clever algorithms are available for solving 15-puzzles, but we could also just
    recursively explore the entire tree graph until we find a path from the root node
    to the solution node. This puzzle’s tree can be searched with a depth-first search
    (DFS) algorithm. However, unlike a well-connected maze, the 15-puzzle’s tree graph
    is not a DAG. Rather, the graph’s nodes are *undirected*, because you can traverse
    both directions of an edge by undoing the previous slide you made.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些聪明的算法可以解决15拼图，但我们也可以递归地探索整个树图，直到找到从根节点到解决节点的路径。这个拼图的树可以用深度优先搜索（DFS）算法进行搜索。然而，与连接良好的迷宫不同，15拼图的树图不是DAG。相反，图的节点是*无向*的，因为你可以通过撤消之前做的滑动来遍历边的两个方向。
- en: '[Figure 12-3](#figure12-3) shows an example of the undirected edges between
    two nodes. Because it is possible to go back and forth between these two nodes
    forever, our 15-puzzle algorithm could encounter a stack overflow before it finds
    a solution.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-3](#figure12-3)显示了两个节点之间的无向边的示例。因为可以在这两个节点之间来回移动，我们的15拼图算法在找到解决方案之前可能会遇到堆栈溢出。'
- en: '![Two tile puzzles. The tiles are positioned identically save for one, which
    has been slid downward in the second puzzle.](image_fi/502024c12/f12003.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![两个瓷砖拼图。除了一个瓷砖在第二个拼图中向下滑动之外，其余瓷砖的位置完全相同。](image_fi/502024c12/f12003.png)'
- en: 'Figure 12-3: The 15-puzzle has undirected edges (drawn without an arrowhead)
    between its nodes because slides can be undone by performing the opposite slide.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-3：15拼图的节点之间有无向边（没有箭头头）因为滑动可以通过执行相反的滑动来撤消。
- en: To optimize our algorithm, we’ll avoid slides that undo the previous slide.
    However, this optimization alone won’t save the algorithm from a stack overflow.
    While it makes the *edges* in the tree graph directed, it doesn’t turn the puzzle-solver
    algorithm into a DAG, because it has cycles, or loops, from lower nodes to higher
    ones. These loops happen if you slide the tiles in a circular pattern, as in [Figure
    12-4](#figure12-4).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化我们的算法，我们将避免撤销上一次滑动的滑动。然而，仅凭这种优化无法使算法免受堆栈溢出的影响。虽然它使树图中的*边缘*变得有向，但它并不会将拼图求解算法转变为DAG，因为它具有从较低节点到较高节点的循环或循环。如果您以循环模式滑动瓷砖，就会发生这些循环，如[图12-4](#figure12-4)所示。
- en: '![Twelve tile puzzles connected by arrows that travel in a complete loop. In
    each subsequent puzzle, one tile is slid out of place until the state of the puzzle
    is the same as the starting puzzle’s state.](image_fi/502024c12/f12004.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![通过箭头连接的十二块瓷砖拼图，形成完整的循环。在每个后续拼图中，一块瓷砖被滑出原位，直到拼图的状态与起始拼图的状态相同。](image_fi/502024c12/f12004.png)'
- en: 'Figure 12-4: An example of a loop in the 15-puzzle’s graph'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-4：15拼图图中循环的一个例子
- en: Cycles in the graph mean that the later nodes at the bottom could loop back
    to a node at the top. Our solving algorithm could get “stuck” following this loop
    and never explore the branch that has the actual solution. In practice, this infinite
    loop would result in a stack overflow.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的循环意味着底部的后续节点可能会回到顶部的节点。我们的求解算法可能会在这个循环中“卡住”，永远不会探索具有实际解决方案的分支。在实践中，这个无限循环会导致堆栈溢出。
- en: We can still use recursion to solve a 15-puzzle. We just need to add our own
    base case for the maximum number of moves in order to avoid causing a stack overflow.
    Then, when the maximum number of slide moves is reached, the algorithm will begin
    backtracking to earlier nodes. If the 15-puzzle solver project can’t find a solution
    in every possible combination of 10 slides, it will try again using a maximum
    of 11 slides. If the puzzle can’t be solved in 11 moves, the project tries 12
    moves, and so on. This prevents the algorithm from getting stuck exploring the
    moves of an infinite loop instead of exploring possible solutions of fewer moves.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用递归来解决15拼图。我们只需要为最大移动次数添加自己的基本情况，以避免导致堆栈溢出。然后，当达到最大滑动次数时，算法将开始回溯到较早的节点。如果15拼图求解器项目无法在10次滑动的所有可能组合中找到解决方案，它将尝试使用最多11次滑动。如果拼图在11次移动中无法解决，项目将尝试12次移动，依此类推。这可以防止算法陷入探索无限循环移动而不是探索较少移动可能解决方案的困境。
- en: The Complete Sliding-Tile Solver Program
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的滑动瓷砖求解程序
- en: Let’s begin by taking a look at the complete source code for the sliding-tile
    puzzle solver program. The rest of this chapter explains each section of code
    individually.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下滑动瓷砖拼图求解程序的完整源代码。本章的其余部分将逐个解释代码的每个部分。
- en: 'Copy the Python version of the code to a file named *slidingTileSolver.py*:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码的Python版本复制到名为*slidingTileSolver.py*的文件中：
- en: '**Python**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Copy the JavaScript version of the code to a file named *slidingTileSolver.html*:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码的JavaScript版本复制到名为*slidingTileSolver.html*的文件中：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The program’s output looks like the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下所示：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that when JavaScript runs in a browser, the code must complete before it
    displays any output. Until then, it may appear to have frozen, and your browser
    might ask if you’d like to prematurely stop it. You can ignore this warning and
    let the program keep working until it has solved the puzzle.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当JavaScript在浏览器中运行时，代码必须在显示任何输出之前完成。在那之前，它可能会看起来已经冻结，您的浏览器可能会询问您是否想要提前停止它。您可以忽略这个警告，让程序继续工作，直到解决了拼图。
- en: The program’s recursive `attemptMove()` function solves sliding-tile puzzles
    by trying every possible combination of slides. The function is given a move to
    try. If this solves the puzzle, the function returns a Boolean `True` value. Otherwise,
    it calls `attemptMove()` with all the other possible moves it can make and returns
    a Boolean `False` value if none of them find a solution before exceeding the maximum
    number of moves. We’ll explore this function in more detail later.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的递归`attemptMove()`函数通过尝试每种可能的滑动组合来解决滑动瓷砖拼图。该函数给出一个要尝试的移动。如果这解决了拼图，函数将返回一个布尔值`True`。否则，它将调用`attemptMove()`以及它可以进行的所有其他可能移动，并在超过最大移动次数之前找不到解决方案时返回一个布尔值`False`。我们稍后将更详细地探讨这个函数。
- en: The data structure we use to represent a sliding-tile board is a list (in Python)
    or array (in JavaScript) of integers, with `0` representing the blank space. In
    our program, this data structure is often stored in a variable named `board`.
    The values at `board[y * SIZE + x]` match the tile at the x, y coordinates on
    the board, as depicted in [Figure 12-5](#figure12-5). For example, if the `SIZE`
    constant is `4`, the value at the x, y coordinates 3, 1 can be found at `board[1
    * 4 + 3]`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来表示滑动瓷砖板的数据结构是一个整数列表（在Python中）或数组（在JavaScript中），其中`0`表示空白空间。在我们的程序中，这个数据结构通常存储在一个名为`board`的变量中。`board[y
    * SIZE + x]`处的值与板上坐标x，y处的瓷砖匹配，如[图12-5](#figure12-5)所示。例如，如果`SIZE`常量为`4`，则在坐标3,
    1处的值可以在`board[1 * 4 + 3]`找到。
- en: This small calculation enables us to use a 1D array or list to store the values
    of a 2D tile board. This programming technique is useful not just in our project
    but for any 2D data structure that must be stored in an array or list, such as
    a 2D image stored as a stream of bytes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小计算使我们能够使用一维数组或列表来存储二维瓷砖板的值。这种编程技术不仅在我们的项目中有用，而且对于任何必须存储在数组或列表中的二维数据结构都很有用，比如以字节流存储的二维图像。
- en: '![Two sliding-tile puzzles. In the first, each tile and the blank space are
    represented by their x, y coordinates. In the second, the tiles and blank space
    are numbered from 0 to 15\. The coordinates correspond to the following numbered
    tiles: 0,0 corresponds to 0; 1,0 corresponds to 1; 2,0 corresponds to 2; 3,0 corresponds
    to 3; 0,1 corresponds to 4; 1,1 corresponds to 5; 2,1 corresponds to 6; 3,1 corresponds
    to 7; 0,2 corresponds to 8; 1,2 corresponds to 9; 2,2 corresponds to 10; 3,2 corresponds
    to 11; 0,3 corresponds to 12; 1,3 corresponds to 13; 2,3 corresponds to 14; 3,3
    (the blank space) corresponds to 15.](image_fi/502024c12/f12005.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![两个滑动瓷砖拼图。在第一个拼图中，每个瓷砖和空白空间都由它们的x、y坐标表示。在第二个拼图中，瓷砖和空白空间从0到15编号。坐标对应于以下编号的瓷砖：0,0对应于0；1,0对应于1；2,0对应于2；3,0对应于3；0,1对应于4；1,1对应于5；2,1对应于6；3,1对应于7；0,2对应于8；1,2对应于9；2,2对应于10；3,2对应于11；0,3对应于12；1,3对应于13；2,3对应于14；3,3（空白空间）对应于15。](image_fi/502024c12/f12005.png)'
- en: 'Figure 12-5: The x, y coordinates for each space on the board (left) and the
    corresponding data structure index (right)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-5：板上每个空间的x、y坐标（左）和相应的数据结构索引（右）
- en: 'Let’s look at some example data structures. The board with mixed-up tiles shown
    previously on the left side of [Figure 12-1](#figure12-1) would be represented
    by the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些示例数据结构。之前在[图12-1](#figure12-1)的左侧显示的混乱瓷砖的板将被表示为以下内容：
- en: '`[15, 2, 1, 12, 8, 5, 6, 11, 4, 9, 10, 7, 3, 14, 13, 0]`'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[15, 2, 1, 12, 8, 5, 6, 11, 4, 9, 10, 7, 3, 14, 13, 0]`'
- en: 'The solved, ordered puzzle on the right side of [Figure 12-1](#figure12-1)
    would be represented by this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图12-1](#figure12-1)的右侧，解决的有序拼图将被表示为：
- en: '`[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]`'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]`'
- en: All the functions in our program will expect board data structures that follow
    this format.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序中的所有函数都将期望遵循这种格式的板数据结构。
- en: 'Unfortunately, the 4 × 4 version of the sliding-tile puzzle has so many possible
    moves that it would take a normal laptop weeks to solve. You can change the `SIZE`
    constant from `4` to `3` to solve a simpler 3 × 3 version of the puzzle. The finished,
    ordered 3 × 3 puzzle’s data structure would look like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，4×4版本的滑动瓷砖拼图有太多可能的移动，普通笔记本电脑需要数周才能解决。您可以将`SIZE`常量从`4`更改为`3`，以解决一个更简单的3×3版本的拼图。完成的、有序的3×3拼图的数据结构将如下所示：
- en: '`[1, 2, 3, 4, 5, 6, 7, 8, 0]`.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[1, 2, 3, 4, 5, 6, 7, 8, 0]`。'
- en: Setting Up the Program’s Constants
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置程序的常量
- en: 'At the beginning of the source code, the program uses a few constants to make
    the code more readable. The Python code is as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码的开头，程序使用一些常量使代码更易读。Python代码如下：
- en: '**Python**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The JavaScript code is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To have reproducible random numbers, the Python program sets the random number
    seed to `1`. The same seed value will always reproduce the same random puzzle,
    which is useful for debugging. You can change the seed value to any other integer
    to create different puzzles. JavaScript has no way to set its random seed value,
    and *slidingtilesolver.html* doesn’t have an equivalent feature.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得可重现的随机数，Python程序将随机数种子设置为`1`。相同的种子值将始终产生相同的随机拼图，这对于调试很有用。您可以将种子值更改为任何其他整数以创建不同的拼图。JavaScript没有办法设置其随机种子值，*slidingtilesolver.html*也没有类似的功能。
- en: The `SIZE` constant sets the size of the square board. You can change this size
    to anything, but 4 × 4 boards are standard, while 3 × 3 boards are useful for
    testing, because the program is quick to solve them. The `BLANK` constant is used
    in the puzzle data structure to represent the blank space and must be kept at
    `0`. The `UP`, `DOWN`, `LEFT`, and `RIGHT` constants are used to make the code
    readable, similar to the `NORTH`, `SOUTH`, `WEST`, and `EAST` constants in the
    maze-generator project in Chapter 11.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIZE`常量设置了方形板的大小。您可以将此大小更改为任何值，但4×4板是标准的，而3×3板对于测试很有用，因为程序很快就能解决它们。`BLANK`常量在拼图数据结构中用于表示空白空间，必须保持为`0`。`UP`、`DOWN`、`LEFT`和`RIGHT`常量用于使代码可读，类似于第11章中迷宫生成器项目中的`NORTH`、`SOUTH`、`WEST`和`EAST`常量。'
- en: Representing the Sliding-Tile Puzzle as Data
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将滑动瓷砖拼图表示为数据
- en: The sliding-tile board’s data structure is just a list or array of integers.
    What makes it representative of an actual puzzle board is the way it’s used by
    the functions in the program. The `displayBoard()`, `getNewBoard()`, `findBlankSpace()`,
    and other functions in this program all deal with this data structure.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动瓷砖板的数据结构只是一个整数列表或数组。它代表实际拼图板的方式是程序中的函数如何使用它。该程序中的`displayBoard()`、`getNewBoard()`、`findBlankSpace()`和其他函数都处理这个数据结构。
- en: Displaying the Board
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示板
- en: 'The first function, `displayBoard()`, prints the board data structure on the
    screen. The Python code for the `displayBoard()` function is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`displayBoard()`在屏幕上打印板数据结构。`displayBoard()`函数的Python代码如下：
- en: '**Python**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The JavaScript code for the `displayBoard()` function is as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayBoard()`函数的JavaScript代码如下：'
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The pair of nested `for` loops iterate over every row and column on the board.
    The first `for` loop loops over the y-coordinates, and the second `for` loop loops
    over the x-coordinates. This is because the program needs to print all the columns
    of a single row before printing a newline character to move on to the next row.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的一对`for`循环遍历板上的每一行和每一列。第一个`for`循环遍历y坐标，第二个`for`循环遍历x坐标。这是因为程序需要在打印换行字符之前打印单行的所有列，以继续下一行。
- en: The `if` statement checks whether the tile at the current x, y coordinates is
    the blank tile. If it is, the program prints two underscores with a trailing space.
    Otherwise, the code in the `else` block prints the tile number with a trailing
    space. The trailing space is what separates the tile numbers from one another
    on the screen. If the tile number is a single digit, the `rjust()` or `padStart()`
    method will insert an extra space so that the tile number is aligned with the
    two-digit numbers on the screen.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句检查当前x、y坐标处的瓷砖是否为空白瓷砖。如果是，程序打印两个下划线并带有一个尾随空格。否则，`else`块中的代码打印带有尾随空格的瓷砖编号。尾随空格是屏幕上分隔瓷砖编号的内容。如果瓷砖编号是一个数字，`rjust()`或`padStart()`方法将插入一个额外的空格，以便瓷砖编号与屏幕上的两位数对齐。'
- en: 'For example, say the scrambled puzzle on the left side of [Figure 12-1](#figure12-1)
    is represented by this data structure:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设左侧的混乱拼图在[图12-1](#figure12-1)中由这个数据结构表示：
- en: '`[15, 2, 1, 12, 8, 5, 6, 11, 4, 9, 10, 7, 3, 14, 13, 0]`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`[15, 2, 1, 12, 8, 5, 6, 11, 4, 9, 10, 7, 3, 14, 13, 0]`'
- en: 'When the data structure is passed to `displayBoard()`, it prints the following
    text:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据结构传递给`displayBoard()`时，它会打印以下文本：
- en: '[PRE53]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Creating a New Board Data Structure
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的板数据结构
- en: 'Next, the `getNewBoard()` function returns a new board data structure with
    the tiles in their ordered, solved places. The Python code for the `getNewBoard()`
    function is as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`getNewBoard()`函数返回一个新的板数据结构，其中瓷砖放在它们有序的、解决的位置上。`getNewBoard()`函数的Python代码如下：
- en: '**Python**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The JavaScript code for the `getNewBoard()` function is as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNewBoard()`函数的JavaScript代码如下：'
- en: '**JavaScript**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE55]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `getNewBoard()` function returns a board data structure appropriate to the
    integer in the `SIZE` constant (either 3 × 3 or 4 × 4). The `for` loop generates
    this list or array with the integers from `1` up to, but not including, `SIZE`
    squared, with a `0` (the value stored in the `BLANK` constant) at the end to represent
    the blank space in the lower-right corner.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNewBoard()`函数返回适合于`SIZE`常量（3×3或4×4）中的整数的板数据结构。`for`循环生成这个列表或数组，其中包含从`1`到`SIZE`的平方，最后一个是`0`（存储在`BLANK`常量中的值），表示右下角的空白空间。'
- en: Finding the Coordinates of the Blank Space
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 找到空白空间的坐标
- en: 'Our program uses the `findBlankSpace()` function to find the x, y coordinates
    of the blank space on the board. The Python code is as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序使用`findBlankSpace()`函数来找到板上空白空间的x、y坐标。Python代码如下：
- en: '**Python**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE56]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The JavaScript code is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE57]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Like the `displayBoard()` function, the `findBlankSpace()` function has a pair
    of nested `for` loops. These `for` loops will loop over every position in the
    board data structure. When the `board[y * SIZE + x]` code finds the blank space,
    it returns the x- and y-coordinates as two integers in a Python list or JavaScript
    array.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 像`displayBoard()`函数一样，`findBlankSpace()`函数有一对嵌套的`for`循环。这些`for`循环将循环遍历板数据结构中的每个位置。当`board[y
    * SIZE + x]`代码找到空白空间时，它会以Python列表或JavaScript数组中的两个整数的形式返回x和y坐标。
- en: Making a Move
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行移动
- en: 'Next, the `makeMove()` function accepts two arguments: a board data structure
    and an `UP`, `DOWN`, `LEFT`, or `RIGHT` direction to slide a tile on that board.
    This code is fairly repetitive, so the short variable names `bx` and `by` are
    used to represent the x- and y-coordinates of the blank space.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`makeMove()`函数接受两个参数：一个板数据结构和一个`UP`、`DOWN`、`LEFT`或`RIGHT`方向，用于在该板上滑动一个瓷砖。这段代码相当重复，所以使用`bx`和`by`这样的简短变量名来表示空白空间的x和y坐标。
- en: 'To make a move, the board data structure swaps the value of the moved tile
    with the `0` of the blank tile. The Python code for the `makeMove()` function
    is as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行移动，板数据结构交换了移动瓷砖的值与空白瓷砖的`0`的值。`makeMove()`函数的Python代码如下：
- en: '**Python**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE58]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The JavaScript code for the `makeMove()` function is as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeMove()`函数的JavaScript代码如下：'
- en: '[PRE59]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `if` statements determine the index of the tile to move based on the `move`
    parameter. The function then “slides” a tile by swapping the `BLANK` value at
    `board[blankindex]` with the numbered tile at `board[tileIndex]`. The `makeMove()`
    function doesn’t return anything. Instead, it modifies the `board` data structure
    in place.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句根据`move`参数确定要移动的瓷砖的索引。然后，函数通过交换`board[blankindex]`处的`BLANK`值和`board[tileIndex]`处的编号瓷砖来“滑动”瓷砖。`makeMove()`函数不返回任何内容。相反，它直接修改了`board`数据结构。'
- en: Python has the `a, b = b, a` syntax to swap the value of two variables. For
    JavaScript, we need to envelop them in an array, such as `[a, b] = [b, a]` to
    perform the swap. We use this syntax at the end of the function to swap the values
    in `board[blankIndex]` and `board[tileIndex]` with each other.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Python有`a, b = b, a`的语法来交换两个变量的值。对于JavaScript，我们需要将它们包装在一个数组中，比如`[a, b] = [b,
    a]`来执行交换。我们在函数的最后使用这种语法来交换`board[blankIndex]`和`board[tileIndex]`中的值。
- en: Undoing a Move
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 撤消移动
- en: 'Next, as part of the backtracking in the recursive algorithm, our program needs
    to undo moves. This is as simple as making a move in the opposite direction as
    the initial move. The Python code for the `undoMove()` function is as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在递归算法的回溯部分，我们的程序需要撤消移动。这就像在与初始移动相反的方向上进行移动一样简单。`undoMove()`函数的Python代码如下：
- en: '**Python**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The JavaScript code for the `undoMove()` function is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`undoMove()`函数的JavaScript代码如下：'
- en: '**JavaScript**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE61]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We’ve already programmed the swapping logic into the `makeMove()` function,
    so `undoMove()` can just call that function for the direction opposite of the
    `move` argument. This way, a hypothetical `someMove` move made on a hypothetical
    `someBoard` data structure by the `makeMove(someBoard, someMove)` function call
    can be undone by calling `undoMove(someBoard, someMove)`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将交换逻辑编程到`makeMove()`函数中，所以`undoMove()`可以调用该函数来执行与`move`参数相反的方向。这样，通过`makeMove(someBoard,
    someMove)`函数调用在一个假设的`someBoard`数据结构上进行的假设的`someMove`移动可以通过调用`undoMove(someBoard,
    someMove)`来撤消。
- en: Setting Up a New Puzzle
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置一个新的谜题
- en: To create a new, scrambled puzzle, we cannot simply put the tiles in random
    places, because some configurations of tiles produce invalid, unsolvable puzzles.
    Instead, we need to start from a solved puzzle and make many random moves. Solving
    the puzzle becomes a matter of figuring out which slides will undo these random
    slides to get back to the original, ordered configuration.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的打乱的拼图，我们不能简单地将方块放在随机位置，因为一些方块的配置会产生无效的、无法解决的拼图。相反，我们需要从一个已解决的拼图开始，然后进行许多随机移动。解决这个拼图就变成了弄清楚哪些滑动可以撤消这些随机滑动，以恢复到原始的有序配置。
- en: But it’s not always possible to make moves in each of the four directions. For
    example, if the blank space is in the bottom-right corner, as in [Figure 12-6](#figure12-6),
    tiles can slide only down or right because no tiles can slide left or up. Furthermore,
    if sliding the 7 tile in [Figure 12-6](#figure12-6) up was the previous move,
    then sliding it down is removed as a valid move because it would undo the previous
    move.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 但并不总是可以在四个方向中的每个方向上进行移动。例如，如果空白区域在右下角，就像[图12-6](#figure12-6)中一样，方块只能向下或向右滑动，因为没有方块可以向左或向上滑动。此外，如果在[图12-6](#figure12-6)中向上滑动7号方块是上一个移动，那么向下滑动就会被移除作为有效的移动，因为它会撤消上一个移动。
- en: '![Sliding-tile puzzle with a blank space in the lower-right corner. Arrows
    indicate the two possible moves: sliding the 7 tile down, and sliding the 13 tile
    to the right.](image_fi/502024c12/f12006.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![带有右下角空白区域的滑动方块拼图。箭头指示了两种可能的移动方式：将7号方块向下滑动，将13号方块向右滑动。](image_fi/502024c12/f12006.png)'
- en: 'Figure 12-6: If the blank space is in the bottom-right corner, down and right
    are the only valid slide directions.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-6：如果空白区域在右下角，向下和向右是唯一有效的滑动方向。
- en: 'To help us, we need a `getValidMoves()` function that can tell us which slide
    directions are possible on a given board data structure:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们，我们需要一个`getValidMoves()`函数，它可以告诉我们在给定的板块数据结构上哪些滑动方向是可能的：
- en: '**Python**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE62]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The JavaScript code for this function is as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE63]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first thing the `getValidMoves()` function does is call `findBlankSpace()`
    and store the x, y coordinates of the blank space in the variables `blankx` and
    `blanky`. Next, the function sets up the `validMoves` variable with an empty Python
    list or empty JavaScript array to hold all the valid directions for a slide.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`getValidMoves()`函数的第一件事是调用`findBlankSpace()`并将空白区域的x、y坐标存储在变量`blankx`和`blanky`中。接下来，函数使用一个空的Python列表或空的JavaScript数组设置了`validMoves`变量，用于保存滑动的所有有效方向。'
- en: Looking back at [Figure 12-5](#figure12-5), a y-coordinate of `0` represents
    the top edge of the board. If `blanky`, the blank space’s y-coordinate, is not
    `0`, then we know the blank space is not on the top edge. If the previous move
    was also not `DOWN`, then *up* is a valid move, and the code adds `UP` to `validMoves`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[图12-5](#figure12-5)，y坐标为`0`表示板块的顶边缘。如果`blanky`，空白区域的y坐标，不是`0`，那么我们知道空白区域不在顶边缘。如果前一个移动也不是`DOWN`，那么*up*就是一个有效的移动，代码会将`UP`添加到`validMoves`中。
- en: Similarly, the left edge has an x-coordinate of `0`, the bottom edge has a y-coordinate
    of `SIZE - 1`, and the right edge has an x-coordinate of `SIZE - 1`. Using the
    expression `SIZE - 1` ensures that this code works no matter whether the board
    is 3 × 3, 4 × 4, or any other size. The `getValidMoves()` function does these
    checks for all four directions and then returns `validMoves`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，左边缘的x坐标为`0`，底边缘的y坐标为`SIZE - 1`，右边缘的x坐标为`SIZE - 1`。使用表达式`SIZE - 1`可以确保这段代码无论板块是3×3、4×4还是其他任何尺寸都能正常工作。`getValidMoves()`函数对所有四个方向进行这些检查，然后返回`validMoves`。
- en: 'Next, the `getNewPuzzle()` function returns the data structure of a scrambled
    board for the program to solve. Tiles can’t simply be randomly placed on the board,
    because some configurations of tiles produce puzzles that are impossible to solve.
    To avoid this, the `getNewPuzzle()` function starts with an ordered, solved board
    and then applies a large number of random slides to it. Solving this puzzle is,
    in effect, figuring out the moves that undo these slides. The Python code for
    the `getNewPuzzle()` function is as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`getNewPuzzle()`函数返回程序要解决的打乱板块的数据结构。不能简单地将方块随机放在板块上，因为一些方块的配置会产生无法解决的拼图。为了避免这种情况，`getNewPuzzle()`函数从有序的解决板块开始，然后对其应用大量的随机滑动。解决这个拼图实际上就是找出撤消这些滑动的移动。`getNewPuzzle()`函数的Python代码如下：
- en: '**Python**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE64]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The JavaScript code is as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下：
- en: '[PRE65]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The call to `getNewBoard()` obtains a board data structure in the ordered, solved
    state. The `for` loop calls `getValidMoves()` to obtain a list of valid moves,
    given the current state of the board, and then calls `makeMove()` with a randomly
    selected move from the list. The `random.choice()` function in Python and the
    `Math.floor()` and `Math.random()` functions in JavaScript will handle the random
    selection from the `validMoves` list or array, no matter what combination of `UP`,
    `DOWN`, `LEFT`, and `RIGHT` values it contains.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`getNewBoard()`获取了一个有序、解决状态的板块数据结构。`for`循环调用`getValidMoves()`来获取给定板块当前状态下的有效移动列表，然后从列表中随机选择一个移动调用`makeMove()`。无论`validMoves`列表或数组包含什么组合的`UP`、`DOWN`、`LEFT`和`RIGHT`值，Python中的`random.choice()`函数和JavaScript中的`Math.floor()`和`Math.random()`函数都会处理从`validMoves`中进行随机选择。
- en: The `DIFFICULTY` constant determines how many random slides from `makeMove()`
    the `for` loop applies. The higher the integer in `DIFFICULTY`, the more scrambled
    the puzzle becomes. Even though this results in some moves that undo earlier moves
    by pure chance, such as sliding left and then immediately sliding right, with
    enough slides the function produces a thoroughly scrambled board. For testing
    purposes, `DIFFICULTY` is set to `40`, allowing the program to produce a solution
    in about a minute. For a more realistic 15-puzzle, you should change `DIFFICULTY`
    to `200`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`DIFFICULTY`常量确定`for`循环从`makeMove()`中应用多少随机滑动。`DIFFICULTY`中的整数越高，拼图就会变得更加混乱。尽管这会导致一些纯粹偶然地撤销先前的移动的移动，例如向左滑动然后立即向右滑动，但是通过足够的滑动，函数会产生一个彻底混乱的棋盘。为了测试目的，`DIFFICULTY`设置为`40`，允许程序在大约一分钟内产生一个解决方案。对于一个更真实的15拼图，你应该将`DIFFICULTY`改为`200`。'
- en: After the board data structure in `board` is created and scrambled, the `getNewPuzzle()`
    function returns it.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和打乱`board`棋盘数据结构之后，`getNewPuzzle()`函数返回它。
- en: Recursively Solving the Sliding-Tile Puzzle
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归解决滑动拼图
- en: Now that we have the functions for creating and manipulating the puzzle data
    structure, let’s create the functions that solve the puzzle by recursively sliding
    the tiles in each possible direction and checking whether this produces a finished,
    ordered board.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了创建和操作拼图数据结构的函数，让我们创建通过递归滑动每个可能方向的拼图解决函数。
- en: The `attemptMove()` function performs a single slide on a board data structure,
    then recursively calls itself once for each of the valid moves the board can make.
    Multiple base cases exist. If the board data structure is in a solved state, the
    function returns a Boolean `True` value; if the maximum number of moves has been
    reached, it returns a Boolean `False` value. Also, if a recursive call has returned
    `True`, then `attemptMove()` should return `True`, and if recursive calls for
    all the valid moves have returned `False`, then `attemptMove()` should return
    `False`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`attemptMove()`函数在一个棋盘数据结构上执行单个滑动，然后递归调用自身，对棋盘可以进行的每个有效移动调用一次。存在多个基本情况。如果棋盘数据结构处于已解状态，则函数返回布尔值`True`；如果达到了最大移动次数，则返回布尔值`False`。此外，如果递归调用返回了`True`，那么`attemptMove()`应该返回`True`，如果所有有效移动的递归调用都返回了`False`，那么`attemptMove()`应该返回`False`。'
- en: The solve() Function
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: solve()函数
- en: The `solve()` function takes a board data structure and maximum number of moves
    the algorithm should attempt before backtracking. Then it performs the first call
    to `attemptMove()`. If this first call to `attemptMove()` returns `True`, the
    code in `solve()` displays the series of steps that solves the puzzle. If it returns
    `False`, the code in `solve()` tells the user no solution was found with this
    maximum number of moves.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve()`函数接受一个棋盘数据结构和算法在回溯之前应尝试的最大移动次数。然后它执行对`attemptMove()`的第一次调用。如果这第一次对`attemptMove()`的调用返回`True`，那么`solve()`中的代码会显示解决拼图的一系列步骤。如果返回`False`，那么`solve()`中的代码会告诉用户在这个最大移动次数下找不到解决方案。'
- en: 'The Python code for `solve()` begins as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`solve()`代码开始如下：
- en: '**Python**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE66]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The JavaScript code for `solve()` begins as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的`solve()`代码开始如下：
- en: '[PRE67]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `solve()` function has two parameters: `board` contains the data structure
    of the puzzle to solve, and `maxMoves` is the maximum number of moves the function
    should make to try to solve the puzzle. The `solutionMoves` list or array contains
    the sequence of `UP`, `DOWN`, `LEFT`, and `RIGHT` values that produce the solved
    state. The `attemptMove()` function modifies this list or array in place as it
    makes recursive calls. If the initial `attemptMove()` function finds a solution
    and returns `True`, `solutionMoves` contains the sequence of moves for the solution.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve()`函数有两个参数：`board`包含要解决的拼图的数据结构，`maxMoves`是函数应该尝试的最大移动次数。`solutionMoves`列表或数组包含产生解决状态的`UP`、`DOWN`、`LEFT`和`RIGHT`值的序列。`attemptMove()`函数在进行递归调用时会修改这个列表或数组。如果初始的`attemptMove()`函数找到解决方案并返回`True`，`solutionMoves`包含解决方案的移动序列。'
- en: 'The `solve()` function then makes the initial call to `attemptMove()`, and
    stores the `True` or `False` it returns in the solved variable. The rest of the
    `solve()` function handles these two cases:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`solve()`函数对`attemptMove()`进行初始调用，并将其返回的`True`或`False`存储在`solved`变量中。`solve()`函数的其余部分处理这两种情况：
- en: '**Python**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE68]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The JavaScript code is as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE69]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If `attemptMove()` finds a solution, the program runs through all the moves
    gathered in the `solutionMoves` list or array and displays the board after each
    slide. This proves to the user that the moves collected by `attemptMove()` are
    the real solution to the puzzle. Finally, the `solve()` function itself returns
    `True`. If `attemptMove()` is unable to find a solution, the `solve()` function
    simply returns `False`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`attemptMove()`找到解决方案，程序会运行`solutionMoves`列表或数组中收集的所有移动，并在每次滑动后显示棋盘。这向用户证明了`attemptMove()`收集的移动是拼图的真正解决方案。最后，`solve()`函数本身返回`True`。如果`attemptMove()`无法找到解决方案，`solve()`函数会简单地返回`False`。
- en: The attemptMove() Function
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: attemptMove()函数
- en: Let’s take a look at `attemptMove()`, the core recursive function behind our
    tile-solving algorithm. Remember the tree graph that a sliding-tile puzzle produces;
    calling `attemptMove()` for a certain direction is like traveling down that edge
    of this graph to the next node. A recursive `attemptMove()` call moves further
    down the tree. When this recursive `attemptMove()` call returns, it backtracks
    to a previous node. When `attemptMove()` has backtracked all the way to the root
    node, the program execution has returned to the `solve()` function.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`attemptMove()`，这是我们解决拼图的核心递归函数。记住滑动拼图产生的树图；调用`attemptMove()`来表示某个方向就像是沿着图的边缘前进到下一个节点。递归的`attemptMove()`调用会在树中进一步前进。当这个递归的`attemptMove()`调用返回时，它会回溯到先前的节点。当`attemptMove()`回溯到根节点时，程序执行已经返回到`solve()`函数。
- en: 'The Python code for `attemptMove()` begins as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码`attemptMove()`的开始如下：
- en: '**Python**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE70]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The JavaScript code for `attemptMove()` begins as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`attemptMove()`的JavaScript代码如下：'
- en: '**JavaScript**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE71]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `attemptMove()` function has four parameters. The `board` parameter contains
    a tile puzzle board data structure to solve. The `movesMade` parameter contains
    a list or array that `attemptMove()` modifies in place, adding the `UP`, `DOWN`,
    `LEFT`, and `RIGHT` values that the recursive algorithm has made. If `attemptMove()`
    solves the puzzle, `movesMade` will contain the moves that led to the solution.
    This list or array is also what the `solutionMoves` variable in the `solve()`
    function refers to.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`attemptMove()`函数有四个参数。`board`参数包含要解决的瓷砖拼图板数据结构。`movesMade`参数包含`attemptMove()`就地修改的列表或数组，添加了递归算法产生的`UP`、`DOWN`、`LEFT`和`RIGHT`值。如果`attemptMove()`解决了拼图，`movesMade`将包含导致解决方案的移动。这个列表或数组也是`solve()`函数中的`solutionMoves`变量所指的。'
- en: The `solve()` function uses its `maxMoves` variable as the `movesRemaining`
    parameter in the initial call to `attemptMove()`. Each recursive call passes `maxMoves
    - 1` for the next value of `maxMoves`, causing it to decrease as more recursive
    calls are made. When it becomes less than `0`, the `attemptMove()` function stops
    making additional recursive calls and returns `False`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve()`函数使用其`maxMoves`变量作为对`attemptMove()`的初始调用中的`movesRemaining`参数。每个递归调用传递`maxMoves
    - 1`作为`maxMoves`的下一个值，导致在进行更多递归调用时减少。当它变小于`0`时，`attemptMove()`函数停止进行额外的递归调用并返回`False`。'
- en: Finally, the `prevMove` parameter contains the `UP`, `DOWN`, `LEFT`, or `RIGHT`
    value that the previous call to `attemptMove()` made so that it doesn’t undo that
    move. For the initial call to `attemptMove()`, the `solve()` function passes Python’s
    `None` or JavaScript’s `null` value for this parameter, since no previous move
    exists.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`prevMove`参数包含前一次调用`attemptMove()`所做的`UP`、`DOWN`、`LEFT`或`RIGHT`值，以便它不会撤消该移动。对于对`attemptMove()`的初始调用，`solve()`函数传递Python的`None`或JavaScript的`null`值作为此参数，因为没有先前的移动存在。
- en: The beginning of the `attemptMove()` code checks for two base cases, returning
    `False` if `movesRemaining` has become less than `0`, and returning `True` if
    `board` is in the solved state. The `SOLVED_BOARD` constant contains a board in
    the solved state that we can compare to the data structure in `board`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`attemptMove()`代码的开始检查两个基本情况，如果`movesRemaining`变得小于`0`，则返回`False`，如果`board`处于解决状态，则返回`True`。`SOLVED_BOARD`常量包含一个处于解决状态的板，我们可以将其与`board`中的数据结构进行比较。'
- en: 'The next part of `attemptMove()` performs each of the valid moves it can do
    on this board. The Python code is as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`attemptMove()`的下一部分执行它在这个板上可以做的每个有效移动。Python代码如下：'
- en: '**Python**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE72]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The JavaScript code is as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE73]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `for` loop sets the move variable to each of the directions returned by
    `getValidMoves()`. For each move, we call `makeMove()` to modify the board data
    structure with the move and to add the move to the list or array in `movesMade`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环将移动变量设置为`getValidMoves()`返回的每个方向。对于每次移动，我们调用`makeMove()`来修改板数据结构并将移动添加到`movesMade`中的列表或数组中。'
- en: Next, the code recursively calls `attemptMove()` to explore the range of all
    possible future moves within the depth set by `movesRemaining`. The board and
    `movesMade` variables are forwarded to this recursive call. The code sets the
    recursive call’s `movesRemaining` parameter to `movesRemaining - 1` so that it
    decreases by one. It also sets the `prevMode` parameter to `move` so that it doesn’t
    immediately undo the move just made.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码递归调用`attemptMove()`来探索由`movesRemaining`设置的深度内所有可能的未来移动范围。将板和`movesMade`变量转发到这个递归调用。代码将递归调用的`movesRemaining`参数设置为`movesRemaining
    - 1`，使其减少一个。它还将`prevMode`参数设置为`move`，以便它不会立即撤消刚刚做出的移动。
- en: If the recursive call returns `True`, a solution exists and is recorded in the
    `movesMade` list or array. We call the `undoMove()` function so that `board` will
    contain the original puzzle after the execution returns to `solve()` and then
    return `True` to indicate a solution has been found.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果递归调用返回`True`，则存在解决方案，并记录在`movesMade`列表或数组中。我们调用`undoMove()`函数，以便在执行返回到`solve()`后，`board`将包含原始拼图，然后返回`True`以指示已找到解决方案。
- en: 'The Python code for `attemptMove()` continues as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码`attemptMove()`的继续如下：
- en: '**Python**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE74]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The JavaScript code is as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE75]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If `attemptMove()` returns `False`, no solution is found. In that case, we call
    `undoMove()` and remove the latest move from the `movesMade` list or array.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`attemptMove()`返回`False`，则找不到解决方案。在这种情况下，我们调用`undoMove()`并从`movesMade`列表或数组中删除最新的移动。
- en: All of this is done for each of the valid directions. If none of the calls to
    `attemptMove()` for these directions finds a solution before reaching the maximum
    number of moves, the `attemptMove()` function returns `False`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是针对每个有效方向完成的。如果对这些方向的`attemptMove()`调用在达到最大移动次数之前找到解决方案，则`attemptMove()`函数返回`False`。
- en: Starting the Solver
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始解算器
- en: 'The `solve()` function is useful for kicking off the initial call to `attemptMove()`,
    but the program still needs to do some setup. The Python code for this is as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve()`函数对于启动对`attemptMove()`的初始调用很有用，但程序仍然需要进行一些设置。此Python代码如下：'
- en: '**Python**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE76]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The JavaScript code for this setup is as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置的JavaScript代码如下：
- en: '**JavaScript**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE77]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: First, the `SOLVED_BOARD` constant is set to an ordered, solved board as returned
    by `getNewBoard()`. This constant isn’t set at the top of the source code because
    the `getNewBoard()` function needs to be defined before it can be called.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`SOLVED_BOARD`常量设置为由`getNewBoard()`返回的有序的解决板。这个常量不是在源代码的顶部设置的，因为需要在调用它之前定义`getNewBoard()`函数。
- en: Next, a random puzzle is returned from `getNewPuzzle()` and stored in the `puzzleBoard`
    variable. This variable contains the puzzle board data structure that will be
    solved. If you want to solve a specific 15-puzzle instead of a random one, you
    can replace the call to `getNewPuzzle()` with a list or array containing the puzzle
    you do want to solve.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从`getNewPuzzle()`返回一个随机拼图并存储在`puzzleBoard`变量中。这个变量包含将要解决的拼图板数据结构。如果您想解决特定的15拼图而不是随机的拼图，您可以用包含您想要解决的拼图的列表或数组替换对`getNewPuzzle()`的调用。
- en: 'The board in `puzzleBoard` is displayed to the user, and the current time is
    stored in `startTime` so that the program can calculate the runtime of the algorithm.
    The Python code continues as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`puzzleBoard`中的板被显示给用户，并且当前时间存储在`startTime`中，以便程序可以计算算法的运行时间。Python代码继续如下：'
- en: '**Python**'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE78]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The JavaScript code is as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码如下：
- en: '[PRE79]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The program begins trying to solve the puzzle in `puzzleBoard` in a maximum
    of 10 moves. The infinite `while` loop calls `solve()`. If a solution is found,
    `solve()` prints the solution on the screen and returns `True`. In that case,
    the code here can break out of the infinite `while` loop and print the total runtime
    of the algorithm.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 程序开始尝试在最多10步内解决`puzzleBoard`中的拼图。无限的`while`循环调用`solve()`。如果找到解决方案，`solve()`会在屏幕上打印解决方案并返回`True`。在这种情况下，这里的代码可以跳出无限的`while`循环并打印算法的总运行时间。
- en: Otherwise, if `solve()` returns `False`, `maxMoves` is incremented by `1` and
    the loop calls `solve()` again. This lets the program try progressively longer
    combinations of moves to solve the puzzle. This pattern continues until `solve()`
    finally returns `True`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果`solve()`返回`False`，则`maxMoves`增加`1`，循环再次调用`solve()`。这使程序尝试逐渐更长的移动组合来解决拼图。这种模式一直持续到`solve()`最终返回`True`。
- en: Summary
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: A 15-puzzle is a good example of adapting the principles of recursion to a real-world
    problem. Recursion can perform a depth-first search on the tree graph of states
    that a 15-puzzle produces to find the path to a solution state. However, a purely
    recursive algorithm won’t work, which was why we had to make certain adjustments.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 15拼图是将递归原则应用于现实问题的一个很好的例子。递归可以对15拼图产生的状态树图执行深度优先搜索，以找到通往解决方案状态的路径。然而，一个纯粹的递归算法是行不通的，这就是为什么我们不得不进行一些调整。
- en: The problem arises because a 15-puzzle has a massive number of possible states
    and doesn’t form a DAG. The edges in this graph are undirected, and the graph
    contains loops, or cycles. Our solving algorithm needs to ensure that it doesn’t
    make moves that immediately undo the previous move, so that it traverses the graph
    in one direction. It also needs to have a maximum number of moves the algorithm
    is willing to make before it begins to backtrack; otherwise, the loops guarantee
    that the algorithm will eventually recurse too much and cause a stack overflow.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于15拼图有大量可能的状态，并且不形成DAG。图中的边是无向的，并且图中包含循环。我们的解决算法需要确保它不会进行立即撤销上一步移动的移动，以便以一个方向遍历图。它还需要有算法愿意进行的最大移动次数，然后才开始回溯；否则，循环保证算法最终会递归太多并导致堆栈溢出。
- en: Recursion isn’t necessarily the best approach for solving sliding-tile puzzles.
    All but the easiest puzzles simply have too many combinations for a typical laptop
    to solve within a reasonable amount of time. However, I like the 15-puzzle as
    an exercise in recursion because it connects the theoretical ideas of DAGs and
    DFS into a real-world problem. While 15-puzzles were invented over a century ago,
    the advent of computers provides a rich tool for exploring techniques to solve
    these amusing toys.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 递归并不一定是解决滑块拼图的最佳方法。除了最简单的拼图之外，通常的笔记本电脑根本无法在合理的时间内解决太多的组合。然而，我喜欢15拼图作为递归练习，因为它将DAGs和DFS的理论思想与现实问题联系起来。虽然15拼图是一个多世纪前发明的，但计算机的出现为探索解决这些有趣玩具的技术提供了丰富的工具。
- en: Further Reading
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The Wikipedia entry for 15-puzzles at [https://en.wikipedia.org/wiki/15_puzzle](https://en.wikipedia.org/wiki/15_puzzle)
    details their history and mathematical background.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 15-puzzles的维基百科条目[https://en.wikipedia.org/wiki/15_puzzle](https://en.wikipedia.org/wiki/15_puzzle)详细介绍了它们的历史和数学背景。
- en: You can find the Python source code for a playable version of the sliding-tile
    puzzle game in my book *The Big Book of Small Python Projects* (No Starch Press,
    2021) and online at [https://inventwithpython.com/bigbookpython/project68.html](https://inventwithpython.com/bigbookpython/project68.html).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我的书《The Big Book of Small Python Projects》（No Starch Press，2021）中找到可玩的滑块拼图游戏的Python源代码，并在线查看[https://inventwithpython.com/bigbookpython/project68.html](https://inventwithpython.com/bigbookpython/project68.html)。
- en: '13'
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Fractal Art Maker
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 分形艺术制作者
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Chapter 9 introduced you to programs that draw many well-known fractals with
    the `turtle` Python module, but you can also make your own fractal art with the
    project in this chapter. The Fractal Art Maker program uses Python’s `turtle`
    module to turn simple shapes into complex designs with minimal additional code.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章向您介绍了使用`turtle` Python模块绘制许多著名分形的程序，但您也可以使用本章中的项目制作自己的分形艺术。分形艺术制作者程序使用Python的`turtle`模块将简单的形状转化为复杂的设计，只需很少的额外代码。
- en: The project in this chapter comes with nine example fractals, although you can
    also write new functions to create fractals of your design. Modify the example
    fractals to produce radically different artwork or write code from scratch to
    implement your own creative vision.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目带有九个示例分形，尽管您也可以编写新的函数来创建您自己设计的分形。修改示例分形以产生完全不同的艺术品，或者从头开始编写代码来实现您自己的创意愿景。
- en: The Built-in Fractals
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置分形
- en: You can direct your computer to create an unlimited number of fractals. [Figure
    13-1](#figure13-1) shows the nine fractals that come with the Fractal Art Maker
    program that we’ll use in this chapter. These are produced from functions that
    draw a simple square or equilateral triangle as the base shape, then introduce
    slight differences in their recursive configuration to produce completely different
    images.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指示计算机创建无限数量的分形。[图13-1](#figure13-1)显示了本章中将使用的分形艺术制作者程序中附带的九个分形。这些是通过绘制简单的正方形或等边三角形作为基本形状，然后在它们的递归配置中引入轻微差异来产生完全不同的图像。
- en: '![Nine labeled turtle graphics screenshots. Four Corners: a square containing
    an intricate hexagonal pattern. Spiral Squares: a spiral created by overlapping
    gray and white squares. Double Spiral Squares: a spiral created by overlapping
    multiple sets of white and gray squares. Triangle Spiral: a spiral created by
    overlapping the outlines of triangles. Conway’s Game of Life: a white square partially
    filled in by smaller gray squares. Those smaller squares are partially filled
    in by smaller white-and-dark-gray squares. Sierpinski Triangle: a Sierpinski triangle,
    as seen in Chapters 1 and 9\. Wave: a wave created out of many smaller triangles
    and wave shapes. Horn: a gray-and-white-striped spiral horn shape. Snowflake:
    a snowflake shape.](image_fi/502024c13/f13001.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![标有九个乌龟图形截图的标签。四个角：包含复杂六边形图案的正方形。螺旋方块：由重叠的灰色和白色正方形创建的螺旋。双螺旋方块：由多组白色和灰色正方形重叠创建的螺旋。三角形螺旋：由三角形轮廓重叠创建的螺旋。康威生命游戏：由较小的灰色正方形部分填充的白色正方形。这些较小的正方形部分填充有较小的白色和深灰色正方形。谢尔宾斯基三角形：谢尔宾斯基三角形，如第1章和第9章所见。波浪：由许多较小的三角形和波形形状创建的波浪。喇叭：灰色和白色条纹螺旋形状。雪花：雪花形状。](image_fi/502024c13/f13001.png)'
- en: 'Figure 13-1: The nine example fractals that come with the Fractal Art Maker
    program'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1：分形艺术制作者程序附带的九个示例分形
- en: You can produce all of these fractals by setting the `DRAW_FRACTAL` constant
    at the top of the program to an integer from `1` to `9` and then running the Fractal
    Art Maker program. You can also set `DRAW_FRACTAL` to `10` or `11` to draw the
    basic square and triangle shapes, respectively, that compose these fractals, as
    shown in [Figure 13-2](#figure13-2).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将程序顶部的`DRAW_FRACTAL`常量设置为从`1`到`9`的整数，然后运行分形艺术制作者程序来生成所有这些分形。您还可以将`DRAW_FRACTAL`设置为`10`或`11`，以分别绘制组成这些分形的基本正方形和三角形形状，如[图13-2](#figure13-2)所示。
- en: '![Two turtle graphics screenshots, one showing a square and the other showing
    the outline of an equilateral triangle.](image_fi/502024c13/f13002.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![两个乌龟图形截图，一个显示正方形，另一个显示等边三角形的轮廓。](image_fi/502024c13/f13002.png)'
- en: 'Figure 13-2: The results of calling `drawFilledSquare()` (left) and `drawTriangleOutline()`
    (right) on their own'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-2：调用`drawFilledSquare()`（左）和`drawTriangleOutline()`（右）的结果
- en: 'These shapes are fairly simple: a square filled with either white or gray,
    and a simple outline of a triangle. The `drawFractal()` function uses these basic
    shapes to create amazing fractals.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这些形状相当简单：一个填充有白色或灰色的正方形，以及一个简单的三角形轮廓。`drawFractal()`函数使用这些基本形状来创建令人惊叹的分形。
- en: The Fractal Art Maker Algorithm
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分形艺术制作者算法
- en: 'The Fractal Art Maker’s algorithm has two major components: a shape-drawing
    function and the recursive `drawFractal()` function.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 分形艺术制作者的算法有两个主要组成部分：一个形状绘制函数和递归的`drawFractal()`函数。
- en: The shape-drawing function draws a basic shape. The Fractal Art Maker program
    comes with the two shape-drawing functions shown previously in [Figure 13-2](#figure13-2),
    `drawFilledSquare()` and `drawTriangleOutline()`, but you can also create your
    own. We pass a shape-drawing function to the `drawFractal()` function as an argument,
    just as we passed the match functions to the file finder’s `walk()` function in
    Chapter 10.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 形状绘制函数绘制基本形状。分形艺术制作者程序配备了先前在[图13-2](#figure13-2)中显示的两个形状绘制函数，`drawFilledSquare()`和`drawTriangleOutline()`，但您也可以创建自己的形状绘制函数。我们将一个形状绘制函数作为参数传递给`drawFractal()`函数，就像我们在第10章中将匹配函数传递给文件查找器的`walk()`函数一样。
- en: 'The `drawFractal()` function also has a parameter indicating changes to the
    size, position, and angle of the shapes between recursive calls to `drawFractal()`.
    We’ll cover these specific details later in this chapter, but let’s look at one
    example: fractal 7, which draws a wave-like image.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawFractal()`函数还具有一个参数，指示在对`drawFractal()`进行递归调用之间对形状的大小、位置和角度进行更改。我们将在本章后面介绍这些具体细节，但让我们看一个例子：分形7，它绘制了一个波浪状的图像。'
- en: The program produces the Wave fractal by calling the `drawTriangleOutline()`
    shape-drawing function, which creates a single triangle. The additional arguments
    to `drawFractal()` tell it to make three recursive calls to `drawFractal()`. [Figure
    13-3](#figure13-3) shows the triangle produced by the original call to `drawFractal()`
    and the triangles produced by the three recursive calls.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序通过调用`drawTriangleOutline()`形状绘制函数来生成波形分形，该函数创建一个单独的三角形。对`drawFractal()`的额外参数告诉它进行三次递归调用`drawFractal()`。[图13-3](#figure13-3)显示了原始调用`drawFractal()`产生的三角形以及三次递归调用产生的三角形。
- en: '![Two turtle graphics screenshots. The first shows the outline of an equilateral
    triangle. The second shows that same triangle outline, as well as three additional,
    smaller equilateral triangles: two above the first, and the third below it and
    rotated slightly to the left.](image_fi/502024c13/f13003.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![两个乌龟图形截图。第一个显示等边三角形的轮廓。第二个显示相同的三角形轮廓，以及另外三个较小的等边三角形：两个在第一个上方，第三个在下方并稍微向左旋转。](image_fi/502024c13/f13003.png)'
- en: 'Figure 13-3: The triangle produced by the first call to `drawFractal()` (left)
    and the first set of three recursive calls (right)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-3：第一次调用`drawFractal()`产生的三角形（左）和第一组三次递归调用（右）
- en: The first recursive call tells `drawFractal()` to call `drawTriangleOutline()`
    but with a triangle that is half the size and positioned to the top left of the
    previous triangle. The second recursive call produces a triangle to the top right
    of the previous triangle that is 30 percent of its size. The third recursive call
    produces a triangle below the previous triangle that is half its size and rotated
    15 degrees compared to it.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个递归调用告诉`drawFractal()`调用`drawTriangleOutline()`，但三角形的大小是上一个三角形的一半，并且位于其上一个三角形的左上方。第二个递归调用产生了一个三角形，位于其上一个三角形的右上方，大小为其30％。第三个递归调用产生了一个三角形，位于其上一个三角形的下方，大小为其一半，并且相对于其旋转了15度。
- en: Each of these three recursive calls to `drawFractal()` makes three more recursive
    calls to `drawFractal()`, producing nine new triangles. The new triangles have
    the same changes to their size, position, and angle relative to their previous
    triangle. The top-left triangle is always half the size of the previous triangle,
    while the bottom triangle is always rotated 15 degrees more. [Figure 13-4](#figure13-4)
    shows the triangles produced by the first and second levels of recursion.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个对`drawFractal()`的递归调用中的每一个都会再次对`drawFractal()`进行三次递归调用，从而产生九个新的三角形。新的三角形与其上一个三角形相比，其大小、位置和角度都发生了相同的变化。左上角的三角形始终是上一个三角形的一半大小，而底部三角形始终旋转15度。[图13-4](#figure13-4)显示了递归的第一级和第二级产生的三角形。
- en: '![Two turtle graphics screenshots. The first shows the same four triangles
    shown in Figure 13-3\. The second shows three smaller triangles clustered in the
    same pattern around each of the three new triangles.](image_fi/502024c13/f13004.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![两个乌龟图形的截图。第一个显示与图13-3中相同的四个三角形。第二个显示围绕每个三角形的三个较小的三角形以相同的模式聚集。](image_fi/502024c13/f13004.png)'
- en: 'Figure 13-4: The first level of recursive calls to `drawFractal()` (left) and
    the nine new triangles of the second level of recursive calls (right)'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-4：对`drawFractal()`的递归调用的第一级（左）和第二级递归调用的九个新三角形（右）
- en: The nine calls to `drawFractal()` that produce these nine new triangles each
    make three recursive calls to `drawFractal()`, producing 27 new triangles at the
    next level of recursion. As this pattern of recursion continues, eventually the
    triangles become so small that `drawFractal()` stops making new recursive calls.
    This is one of the base cases for the recursive `drawFractal()` function. The
    other occurs when the recursive depth reaches a specified level. Either way, these
    recursive calls produce the final Wave fractal in [Figure 13-5](#figure13-5).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 对`drawFractal()`的这九个调用分别产生了九个新的三角形，每个调用再次对`drawFractal()`进行三次递归调用，从而在下一级递归中产生27个新的三角形。随着递归模式的继续，最终三角形变得如此小，以至于`drawFractal()`停止进行新的递归调用。这是递归`drawFractal()`函数的一个基本情况。另一个情况是当递归深度达到指定级别时。无论哪种情况，这些递归调用都会产生[图13-5](#figure13-5)中的最终Wave分形。
- en: '![Turtle graphics screenshot of the Wave fractal.](image_fi/502024c13/f13005.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![Wave分形的乌龟图形截图。](image_fi/502024c13/f13005.png)'
- en: 'Figure 13-5: The final Wave fractal after each triangle recursively generates
    three more triangles'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-5：每个三角形递归生成三个新三角形后的最终Wave分形
- en: The nine example fractals in [Figure 13-1](#figure13-1) that come with the Fractal
    Art Maker are made with just two shape-drawing functions and a few changes to
    the arguments to `drawFractal()`. Let’s take a look at the Fractal Art Maker’s
    code to see how it accomplishes this.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-1](#figure13-1)中的九个示例分形是使用两个形状绘制函数和对`drawFractal()`参数的一些更改制作的。让我们看看分形艺术制作者的代码，以了解它是如何实现的。'
- en: The Complete Fractal Art Maker Program
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的分形艺术制作程序
- en: 'Enter the following code into a new file and save it as [fractalArtMaker.py](http://fractalArtMaker.py).
    This program relies on Python’s built-in `turtle` module, so no JavaScript code
    is used for this chapter’s project:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码输入到一个新文件中，并将其保存为[fractalArtMaker.py](http://fractalArtMaker.py)。此程序依赖于Python内置的`turtle`模块，因此本章的项目不使用JavaScript代码：
- en: '**Python**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE80]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: When you run this program, it will show the first of nine fractal images from
    [Figure 13-1](#figure13-1). You can change the `DRAW_FRACTAL` constant at the
    beginning of the source code to any integer from `1` to `9` and run the program
    again to see a new fractal. After learning how the program works, you’ll also
    be able to create your own shape-drawing functions and call `drawFractal()` to
    produce fractals of your own design.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序时，它将显示来自[图13-1](#figure13-1)的九个分形图像中的第一个。您可以将`DRAW_FRACTAL`常量更改为源代码开头的任何整数，从`1`到`9`，然后再次运行程序以查看新的分形。在了解程序如何工作之后，您还可以创建自己的形状绘制函数，并调用`drawFractal()`来生成自己设计的分形。
- en: Setting Up Constants and the Turtle Configuration
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置常量和乌龟配置
- en: 'The first lines of the program cover basic setup steps for our turtle-based
    program:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一行涵盖了基于乌龟的程序的基本设置步骤：
- en: '**Python**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE81]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The program imports the `turtle` module for drawing. It also imports the `math`
    module for the `math.sqrt()` function, which the Sierpiński Triangle fractal will
    use, and the `math.cos()` and `math.sin()` functions, for the Snowflake fractal.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 程序导入了用于绘图的`turtle`模块。它还导入了`math`模块，用于`math.sqrt()`函数，Sierpiński Triangle分形将使用该函数，以及`math.cos()`和`math.sin()`函数，用于Snowflake分形。
- en: The `DRAW_FRACTAL` constant can be set to any integer from `1` to `9` to draw
    one of the nine built-in fractals the program produces. You can also set it to
    `10` or `11` to show the output of the square or triangle shape-drawing function,
    respectively.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`DRAW_FRACTAL`常量可以设置为从`1`到`9`的任何整数，以绘制程序生成的九个内置分形中的一个。您还可以将其设置为`10`或`11`，以分别显示正方形或三角形形状绘制函数的输出。'
- en: We also call some turtle functions to prepare for drawing. The `turtle.tracer(5000,
    0)` call speeds up the drawing of the fractal. The `5000` argument tells the `turtle`
    module to wait until 5,000 turtle drawing instructions have been processed before
    rendering the drawing on the screen, and the `0` argument tells it to pause for
    0 milliseconds after each drawing instruction. Otherwise, the `turtle` module
    would render the image after each drawing instruction, which significantly slows
    the program if we want only the final image.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还调用一些海龟函数来准备绘制。`turtle.tracer(5000, 0)`调用加快了分形的绘制速度。`5000`参数告诉`turtle`模块在渲染屏幕上的绘制之前等待处理5000个海龟绘制指令，`0`参数告诉它在每个绘制指令后暂停0毫秒。否则，如果我们只想要最终图像，`turtle`模块会在每个绘制指令后渲染图像，这会显著减慢程序。
- en: You can change this call to `turtle.tracer(1, 10)` if you want to slow the drawing
    and watch the lines as they’re produced. This can be useful when making your own
    fractals to debug any problems with the drawing.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要减慢绘制速度并观察生成的线条，你可以将这个调用改为`turtle.tracer(1, 10)`。在制作自己的分形图案时，这可能有助于调试绘制中的任何问题。
- en: The `turtle.hideturtle()` call hides the triangle shape on the screen that represents
    the turtle’s current position and heading. (*Heading* is another term for *direction*.)
    We call this function so that the marker doesn’t appear in the final image.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`turtle.hideturtle()`调用隐藏了屏幕上代表海龟当前位置和方向的三角形形状。我们调用这个函数是为了让标记不出现在最终图像中。'
- en: Working with the Shape-Drawing Functions
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用形状绘制函数
- en: The `drawFractal()` function uses a shape-drawing function passed to it to draw
    the individual parts of the fractal. This is usually a simple shape, such as a
    square or triangle. The beautiful complexity of the fractals emerges from `drawFractal()`
    recursively calling this function for each individual component of the whole fractal.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawFractal()`函数使用传递给它的形状绘制函数来绘制分形的各个部分。这通常是一个简单的形状，比如正方形或三角形。分形的美丽复杂性是由于`drawFractal()`递归调用这个函数来绘制整个分形的每个组件。'
- en: 'The shape-drawing functions for the Fractal Art Maker have two parameters:
    `size` and `depth`. The `size` parameter is the length of the sides of the square
    or triangle it draws. The shape-drawing functions should always use arguments
    to `turtle.forward()` that are based on `size` so that the lengths will be proportionate
    to `size` at each level of recursion. Avoid code like `turtle.forward(100)` or
    `turtle.forward(200)`; instead, use code that is based on the `size` parameter,
    like `turtle.forward(size)` or `turtle.forward(size * 2)`. In Python’s `turtle`
    module, `turtle.forward(1)` moves the turtle by one *unit*, which is not necessarily
    the same as one pixel.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Fractal Art Maker的形状绘制函数有两个参数：`size`和`depth`。`size`参数是它绘制的正方形或三角形的边长。形状绘制函数应该始终使用基于`size`的参数来调用`turtle.forward()`，以便长度在每个递归级别上与`size`成比例。避免像`turtle.forward(100)`或`turtle.forward(200)`这样的代码；而是使用基于`size`参数的代码，比如`turtle.forward(size)`或`turtle.forward(size
    * 2)`。在Python的`turtle`模块中，`turtle.forward(1)`将海龟移动一个*单位*，这不一定等同于一个像素。
- en: The shape-drawing functions’ second parameter is the recursive depth of `drawFractal()`.
    The original call to `drawFractal()` has the `depth` parameter set to `0`. Recursive
    calls to `drawFractal()` use `depth + 1` as the `depth` parameter. In the Wave
    fractal, the first triangle in the center of the window has a depth argument of
    `0`. The three triangles created next have a depth of `1`. The nine triangles
    around those three triangles have a depth of `2`, and so on.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 形状绘制函数的第二个参数是`drawFractal()`的递归深度。对`drawFractal()`的原始调用将`depth`参数设置为`0`。对`drawFractal()`的递归调用使用`depth
    + 1`作为`depth`参数。在Wave分形中，窗口中心的第一个三角形的深度参数为`0`。接下来创建的三个三角形的深度为`1`。围绕这三个三角形的九个三角形的深度为`2`，依此类推。
- en: Your shape-drawing function can ignore this argument, but using it can cause
    interesting variations to the basic shape. For example, the `drawFilledSquare()`
    shape-drawing function uses `depth` to alternate between drawing white squares
    and gray squares. Keep this in mind if you’d like to create your own shape-drawing
    functions for the Fractal Art Maker program, as they must accept a `size` and
    `depth` argument.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 你的形状绘制函数可以忽略这个参数，但使用它可以导致基本形状的有趣变化。例如，`drawFilledSquare()`形状绘制函数使用`depth`来在绘制白色正方形和灰色正方形之间进行交替。如果你想为Fractal
    Art Maker程序创建自己的形状绘制函数，请记住它们必须接受`size`和`depth`参数。
- en: The drawFilledSquare() Function
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: drawFilledSquare()函数
- en: The `drawFilledSquare()` function draws a filled-in square with sides of length
    `size`. To color the square, we use the `turtle` module’s `turtle.begin_fill()`
    and `turtle.end_fill()` functions to make the square either white or gray, with
    a black border, depending on whether the `depth` argument is even or odd. Because
    these squares are filled in, any squares drawn on top of them later will cover
    them.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawFilledSquare()`函数绘制了一个边长为`size`的填充正方形。为了给正方形上色，我们使用了`turtle`模块的`turtle.begin_fill()`和`turtle.end_fill()`函数，使正方形变成白色或灰色，带有黑色边框，具体取决于`depth`参数是偶数还是奇数。因为这些正方形是填充的，稍后绘制在它们上面的任何正方形都会覆盖它们。'
- en: 'Like all shape-drawing functions for the Fractal Art Maker program, `drawFilledSquare()`
    accepts a `size` and `depth` parameter:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Fractal Art Maker程序的所有形状绘制函数一样，`drawFilledSquare()`接受`size`和`depth`参数：
- en: '[PRE82]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `size` argument could be a floating-point number with a fractional part,
    which sometimes causes the `turtle` module to make slightly asymmetrical and uneven
    drawings. To prevent this, the first line of the function rounds `size` down to
    an integer.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`参数可以是带有小数部分的浮点数，这有时会导致`turtle`模块绘制略微不对称和不均匀的图案。为了防止这种情况，函数的第一行将`size`四舍五入为整数。'
- en: 'When the function draws the square, it assumes the turtle is in the center
    of the square. Thus, the turtle must first move to the top-right corner of the
    square, relative to its initial heading:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数绘制正方形时，它假设海龟位于正方形的中心。因此，海龟必须首先移动到正方形的右上角，相对于它的初始方向：
- en: '**Python**'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE83]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `drawFractal()` function always has the pen down and ready to draw when
    the shape-drawing function is called, so `drawFilledSquare()` must call `turtle.penup()
    to avoid drawing a line as it moves to the starting position. To find the starting
    position relative to the middle of the square, the turtle must first move half
    of the square’s length (that is, `size // 2`) forward, to the future right edge
    of the square. Next the turtle turns 90 degrees to face up and then moves `size
    // 2` units forward to the top-right corner. The turtle is now facing the wrong
    way, so it turns around 180 degrees and places the pen down so that it can begin
    drawing.`
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawFractal()`函数在调用形状绘制函数时总是将笔放下并准备绘制，因此`drawFilledSquare()`必须调用`turtle.penup()`以避免在移动到起始位置时绘制一条线。为了找到相对于正方形中心的起始位置，海龟必须先向前移动正方形长度的一半（即`size
    // 2`），到达正方形的未来右边缘。接下来，海龟向上转90度，然后向前移动`size // 2`个单位到达右上角。现在海龟面朝错误的方向，所以它向后转了180度，并放下笔，这样就可以开始绘制了。'
- en: '`Note that *top-right* and *up* are relative to the direction the turtle is
    originally facing. This code works just as well if the turtle begins facing to
    the right at 0 degrees or has a heading of 90, 42, or any other number of degrees.
    When you create your own shape-drawing functions, stick to the relative turtle
    movement functions like `turtle.forward()`, `turtle.left()`, and `turtle.right()`
    instead of absolute turtle movement functions like `turtle.goto()`.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`请注意，*top-right*和*up*是相对于海龟最初面对的方向。如果海龟开始面对0度向右，或者其朝向为90、42或任何其他角度，此代码同样有效。当您创建自己的形状绘制函数时，坚持使用相对海龟移动函数，如`turtle.forward()`、`turtle.left()`和`turtle.right()`，而不是绝对海龟移动函数，如`turtle.goto()`。'
- en: 'Next, the `depth` argument tells the function whether it should draw a white
    square or a gray one:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`depth`参数告诉函数它应该绘制白色正方形还是灰色正方形：
- en: '**Python**'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE84]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: If `depth` is even, the `depth % 2 == 0` condition is `True`, and the square’s
    *fill color* is white. Otherwise, the code sets the fill color to gray. Either
    way, the border of the square, determined by the *pen color*, is set to black.
    To change either of these colors, use strings of common color names, like `red`
    or `yellow`, or an HTML color code comprising a hash mark and six hexadecimal
    digits, like `#24FF24` for lime green or `#AD7100` for brown.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`depth`是偶数，则`depth % 2 == 0`条件为`True`，正方形的*填充颜色*为白色。否则，代码将填充颜色设置为灰色。无论哪种情况，由*笔颜色*确定的正方形边框都设置为黑色。要更改这两种颜色中的任何一种，请使用常见颜色名称的字符串，如`red`或`yellow`，或包含一个井号和六个十六进制数字的HTML颜色代码，如`#24FF24`表示酸橙绿，`#AD7100`表示棕色。
- en: The website [https://html-color.codes](https://html-color.codes) has charts
    for many HTML color codes. The fractals in this black-and-white book lack color,
    but your computer can render your own fractals in a bright range of colors!
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 网站[https://html-color.codes](https://html-color.codes)有许多HTML颜色代码的图表。这本黑白书中的分形缺乏颜色，但您的计算机可以以丰富的颜色范围呈现自己的分形！
- en: 'With the colors set, we can finally draw the four lines of the actual square:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色设置好后，我们最终可以绘制实际正方形的四条线：
- en: '**Python**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE85]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: To tell the `turtle` module that we intend to draw a filled-in shape and not
    just the outline, we call the `turtle.begin_fill()` function. Next is a `for`
    loop that draws a line of length `size` and turns the turtle 90 degrees to the
    right. The `for` loop repeats this four times to create the square. When the function
    finally calls `turtle.end_fill()`, the filled-in square appears on the screen.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉`turtle`模块我们打算绘制填充形状而不仅仅是轮廓，我们调用了`turtle.begin_fill()`函数。接下来是一个`for`循环，绘制长度为`size`的线并将海龟向右转90度。`for`循环重复四次，以创建正方形。当函数最终调用`turtle.end_fill()`时，填充的正方形出现在屏幕上。
- en: The drawTriangleOutline() Function
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: drawTriangleOutline()函数
- en: The second shape-drawing function draws the outline of an equilateral triangle
    whose sides have a length of `size`. The function draws the triangle oriented
    with one corner at the top and two corners at the bottom. [Figure 13-6](#figure13-6)
    illustrates the various dimensions of an equilateral triangle.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个形状绘制函数绘制了边长为`size`的等边三角形的轮廓。该函数绘制的三角形是以一个顶点在顶部，两个顶点在底部的方向。[图13-6](#figure13-6)说明了等边三角形的各种尺寸。
- en: '![Annotated diagram of an equilateral triangle showing the following properties.
    Size: the length of one side. Angle: 60 degrees. Height: size times math.sqrt(3)
    / 2\. Also shows two-thirds of the height and one-third of the height.](image_fi/502024c13/f13006.png)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![等边三角形的注解图，显示以下属性。大小：一边的长度。角度：60度。高度：大小乘以math.sqrt(3) / 2。还显示了高度的三分之二和三分之一。](image_fi/502024c13/f13006.png)'
- en: 'Figure 13-6: The measurements of an equilateral triangle with sides the length
    of `size`'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-6：边长为`size`的等边三角形的测量
- en: 'Before we begin drawing, we must determine the triangle’s height based on the
    length of its sides. Geometry tells us that, for equilateral triangles with sides
    of length *L*, the height *h* of the triangle is *L* times the square root of
    3 divided by 2\. In our function, *L* corresponds to the `size` parameter, so
    our code sets the height variable as follows:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始绘制之前，我们必须根据其边长确定三角形的高度。几何学告诉我们，对于边长为*L*的等边三角形，三角形的高度*h*为*L*乘以根号3除以2。在我们的函数中，*L*对应于`size`参数，因此我们的代码设置高度变量如下：
- en: '[PRE86]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Geometry also tells us that the center of the triangle is one-third of the
    height from the bottom side and two-thirds of the height from the top point. This
    gives us the information we need to move the turtle to its starting position:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 几何学还告诉我们，三角形的中心距离底边的高度为高度的三分之一，距离顶点的高度为高度的三分之二。这为我们提供了将海龟移动到起始位置所需的信息：
- en: '**Python**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE87]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: To reach the top corner, we turn the turtle 90 degrees left to face up (relative
    to the turtle’s original heading right at 0 degrees) and then move forward a number
    of units equal to `height * (2/3)`. The turtle is still facing up, so to begin
    drawing the line on the right side, the turtle must turn 90 degrees right to face
    rightward, then an additional 60 degrees to face the bottom-right corner of the
    triangle. This is why we call `turtle.right(150)`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 为了到达顶角，我们将乌龟左转90度面朝上（相对于乌龟原始朝向右转0度），然后向前移动`height * (2/3)`个单位。乌龟仍然面朝上，所以要开始在右侧绘制线条，乌龟必须右转90度面向右侧，然后再转60度面向三角形的右下角。这就是为什么我们调用`turtle.right(150)`。
- en: 'At this point, the turtle is ready to start drawing the triangle, so we lower
    the pen by calling `turtle.pendown()`. A `for` loop will handle drawing the three
    sides:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，乌龟已准备好开始绘制三角形，因此我们通过调用`turtle.pendown()`来放下画笔。`for`循环将处理绘制三条边：
- en: '**Python**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE88]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Drawing the actual triangle is a matter of moving forward by `size` units, and
    then turning 120 degrees to the right, three separate times. The third and final
    120-degree turn leaves the turtle facing its original direction. You can see these
    movements and turns in [Figure 13-7](#figure13-7).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制实际三角形是向前移动`size`单位，然后向右转120度，分别进行三次。第三次和最后一次120度转向使乌龟面对其原始方向。您可以在[图13-7](#figure13-7)中看到这些移动和转向。
- en: '![Diagram of four equilateral triangles. Each triangle has one additional bolded
    line, representing the steps needed to draw the triangle and return the turtle
    to its original heading.](image_fi/502024c13/f13007.png)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![四个等边三角形的图示。每个三角形有一条额外的加粗线，代表绘制三角形并将乌龟返回到其原始朝向所需的步骤。](image_fi/502024c13/f13007.png)'
- en: 'Figure 13-7: Drawing an equilateral triangle involves three forward movements
    and three 120-degree turns.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-7：绘制等边三角形涉及三次向前移动和三次120度转向。
- en: The `drawTriangleOutline()` function draws only the outline and not a filled-in
    shape, so it doesn’t call `turtle.begin_fill()` and `turtle.end_fill()` as `drawFilledSquare()`
    does.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawTriangleOutline()`函数只绘制轮廓而不是填充形状，因此不像`drawFilledSquare()`那样调用`turtle.begin_fill()`和`turtle.end_fill()`。'
- en: Using the Fractal Drawing Function
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分形绘图函数
- en: 'Now that we have two sample drawing functions to work with, let’s examine the
    main function in the Fractal Art Maker project, `drawFractal()`. This function
    has three required parameters and one optional one: `shapeDrawFunction`, `size`,
    `specs`, and `maxDepth`.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个样本绘图函数可以使用，让我们来看一下分形艺术制作项目中的主要函数`drawFractal()`。这个函数有三个必需参数和一个可选参数：`shapeDrawFunction`，`size`，`specs`和`maxDepth`。
- en: The `shapeDrawFunction` parameter expects a function, like `drawFilledSquare()`
    or `drawTriangleOutline()`. The `size` parameter expects the starting size passed
    to the drawing function. Often, a value between `100` and `500` is a good starting
    size, though this depends on the code in your shape-drawing function, and finding
    the right value may require experimentation.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`shapeDrawFunction`参数期望一个函数，比如`drawFilledSquare()`或`drawTriangleOutline()`。`size`参数期望传递给绘图函数的起始大小。通常，值在`100`到`500`之间是一个不错的起始大小，尽管这取决于您的形状绘制函数中的代码，并且找到合适的值可能需要进行实验。'
- en: The `specs` parameter expects a list of dictionaries that specify how the recursive
    shapes should change their size, position, and angle as `drawFractal()` recursively
    calls itself. These specifications are described later in this section.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`specs`参数期望一个字典列表，指定递归调用`drawFractal()`时递归形状应该如何改变大小、位置和角度。这些规格稍后在本节中描述。'
- en: To prevent `drawFractal()` from recursing until it causes a stack overflow,
    the `maxDepth` parameter holds the number of times `drawFractal()` should recursively
    call itself. By default, `maxDepth` has a value of `8`, but you can provide a
    different value if you want more or fewer recursive shapes.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止`drawFractal()`递归调用导致堆栈溢出，`maxDepth`参数保存了`drawFractal()`应该递归调用自身的次数。默认情况下，`maxDepth`的值为`8`，但如果需要更多或更少的递归形状，可以提供不同的值。
- en: A fifth parameter, `depth`, is handled by `drawFractal()`’s recursive call to
    itself and defaults to `0`. You don’t need to specify it when you call `drawFractal()`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个参数`depth`由`drawFractal()`的递归调用处理，并默认为`0`。调用`drawFractal()`时不需要指定它。
- en: Setting Up the Function
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置函数
- en: 'The first thing the `drawFractal()` function does is check for its two base
    cases:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawFractal()`函数的第一件事是检查其两个基本情况：'
- en: '**Python**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE89]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: If `depth` is greater than `maxDepth`, the function will stop the recursion
    and return. The other base case occurs if `size` is less than `1`, at which point
    the shapes being drawn would be too small to be seen on the screen and so the
    function should simply return.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`depth`大于`maxDepth`，函数将停止递归并返回。另一个基本情况是如果`size`小于`1`，此时绘制的形状将太小而无法在屏幕上看到，因此函数应该简单地返回。
- en: 'We keep track of the turtle’s original position and heading in three variables:
    `initialX`, `initialY`, and `initialHeading`. This way, no matter where the shape-drawing
    function leaves the turtle positioned or what direction it is headed, `drawFractal()`
    can revert the turtle back to the original position and heading for the next recursive
    call:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用三个变量`initialX`，`initialY`和`initialHeading`来跟踪乌龟的原始位置和朝向。这样，无论形状绘制函数将乌龟定位在何处或者朝向何方，`drawFractal()`都可以将乌龟恢复到原始位置和朝向，以便进行下一次递归调用：
- en: '**Python**'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE90]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `turtle.xcor()` and `turtle.ycor()` functions return the absolute x- and
    y-coordinates of the turtle on the screen. The `turtle.heading()` function returns
    the direction in which the turtle is pointed in degrees.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`turtle.xcor()`和`turtle.ycor()`函数返回乌龟在屏幕上的绝对x和y坐标。`turtle.heading()`函数返回乌龟指向的方向，单位为度。'
- en: 'The next few lines call the shape-drawing function passed to the `shapeDrawFunction`
    parameter:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行调用传递给`shapeDrawFunction`参数的形状绘制函数：
- en: '**Python**'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE91]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Because the value passed as the argument for the `shapeDrawFunction` parameter
    is a function, the code `shapeDrawFunction(size, depth)` calls this function with
    the values in `size` and `depth`. The pen is lowered before and raised after the
    `shapeDrawFunction()` call to ensure that the shape-drawing function can consistently
    expect the pen to be down when the drawing begins.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 由于作为`shapeDrawFunction`参数的值是一个函数，代码`shapeDrawFunction(size, depth)`调用此函数，并使用`size`和`depth`中的值。在`shapeDrawFunction()`调用之前和之后分别将笔降下和抬起，以确保形状绘制函数始终可以期望在绘制开始时笔是放下的。
- en: Using the Specifications Dictionary
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用规范字典
- en: After the call to `shapeDrawFunction()`, the rest of `drawFractal()`’s code
    is devoted to making recursive calls to `drawFractal()` based on the specification
    in the `specs` list’s dictionaries. For each dictionary, `drawFractal()` makes
    one recursive call to `drawFractal()`. If `specs` is a list with one dictionary,
    every call to `drawFractal() results in only one recursive call to `drawFractal()`.
    If `specs` is a list with three dictionaries, every call to `drawFractal()` results
    in three recursive calls to `drawFractal()`.`
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`shapeDrawFunction()`之后，`drawFractal()`的其余代码致力于根据`specs`列表中的规范进行递归调用`drawFractal()`。对于每个字典，`drawFractal()`都会对`drawFractal()`进行一次递归调用。如果`specs`是一个具有一个字典的列表，则每次调用`drawFractal()`都会导致对`drawFractal()`的一次递归调用。如果`specs`是一个具有三个字典的列表，则每次调用`drawFractal()`都会导致对`drawFractal()`的三次递归调用。
- en: '`The dictionaries in the `specs` parameter provide specifications for each
    recursive call. Each of these dictionaries has the keys `sizeChange`, `xChange`,
    `yChange`, and `angleChange`. These dictate how the size of the fractal, the position
    of the turtle, and the heading of the turtle change for a recursive `drawFractal()`
    call. [Table 13-1](#table13-1) describes the four keys in a specification.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`specs`参数中的字典为每个递归调用提供了规范。这些字典中的每一个都具有`sizeChange`、`xChange`、`yChange`和`angleChange`键。这些键规定了分形的大小、海龟的位置以及海龟的航向如何在递归的`drawFractal()`调用中改变。[表13-1](#table13-1)描述了规范中的四个键。'
- en: 'Table 13-1: Keys in the Specification Dictionaries'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 表13-1：规范字典中的键
- en: '| **Key** | **Default value** | **Description** |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| **键** | **默认值** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `sizeChange` | `1.0` | The next recursive shape’s size value is the current
    size multiplied by this value. |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| `sizeChange` | `1.0` | 下一个递归形状的大小值是当前大小乘以这个值。'
- en: '| `xChange` | `0.0` | The next recursive shape’s x-coordinate is the current
    x-coordinate plus the current size multiplied by this value. |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| `xChange` | `0.0` | 下一个递归形状的x坐标是当前x坐标加上当前大小乘以这个值。'
- en: '| `yChange` | `0.0` | The next recursive shape’s y-coordinate is the current
    y-coordinate plus the current size multiplied by this value. |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| `yChange` | `0.0` | 下一个递归形状的y坐标是当前y坐标加上当前大小乘以这个值。'
- en: '| `angleChange` | `0.0` | The next recursive shape’s starting angle is the
    current starting angle plus this value. |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| `angleChange` | `0.0` | 下一个递归形状的起始角度是当前起始角度加上这个值。'
- en: 'Let’s take a look at the specification dictionary for the Four Corners fractal,
    which produces the top-left image shown previously in [Figure 13-1](#figure13-1).
    The call to `drawFractal()` for the Four Corners fractal passes the following
    list of dictionaries for the `specs` parameter:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下四角分形的规范字典，它产生了之前在[图13-1](#figure13-1)中显示的左上角图像。对于四角分形的`drawFractal()`调用，传递了以下字典列表作为`specs`参数：
- en: '**Python**'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE92]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `specs` list has four dictionaries, so each call to `drawFractal()` that
    draws a square will, in turn, recursively call `drawFractal()` four more times
    to draw four more squares. [Figure 13-8](#figure13-8) shows this progression of
    squares (which alternate between white and gray).
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`specs`列表有四个字典，因此每次调用`drawFractal()`绘制一个正方形，都会递归调用`drawFractal()`四次，以绘制另外四个正方形。[图13-8](#figure13-8)显示了这些正方形的进展（在白色和灰色之间交替）。'
- en: To determine the size of the next square to be drawn, the value for the `sizeChange`
    key is multiplied by the current `size` parameter. The first dictionary in the
    `specs` list has a `sizeChange` value of `0.5`, which makes the next recursive
    call have a size argument of `350 * 0.5`, or `175` units. This makes the next
    square half the size of the previous square. A `sizeChange` value of `2.0` would,
    for example, double the size of the next square. If the dictionary has no `sizeChange`
    key, the value defaults to `1.0` for no change to the size.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定下一个要绘制的正方形的大小，`sizeChange`键的值乘以当前的`size`参数。`specs`列表中的第一个字典具有`sizeChange`值为`0.5`，这使得下一个递归调用具有大小参数为`350
    * 0.5`，即`175`个单位。这使得下一个正方形的大小是前一个正方形的一半。例如，`sizeChange`值为`2.0`会使下一个正方形的大小加倍。如果字典没有`sizeChange`键，则该值默认为`1.0`，表示大小不变。
- en: '![Six turtle graphics screenshots. The first shows a white square. The second
    shows four smaller gray squares covering each corner of the white square. The
    third shows four smaller white squares covering the corners of each of those smaller
    gray squares. This pattern continues in the subsequent three screenshots. As the
    squares begin to overlap, their outlines remain visible.](image_fi/502024c13/f13008.png)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
  zh: '![六个海龟图形截图。第一个显示一个白色正方形。第二个显示四个更小的灰色正方形覆盖白色正方形的每个角落。第三个显示四个更小的白色正方形覆盖这些更小的灰色正方形的每个角落。这种模式在随后的三个截图中继续。随着正方形开始重叠，它们的轮廓仍然可见。](image_fi/502024c13/f13008.png)'
- en: 'Figure 13-8: Each step of the Four Corners example from left to right, top
    to bottom. Each square recursively produces four more squares at its corners,
    with colors alternating between white and gray.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-8：四角示例的每一步从左到右，从上到下。每个正方形在其角落递归产生四个更小的正方形，颜色在白色和灰色之间交替。
- en: To determine the x-coordinate of the next square, the first dictionary’s `xChange`
    value, `-0.5` in this case, is multiplied by the size. When `size` is `350`, this
    means the next square has an x-coordinate of `-175` units relative to the turtle’s
    current position. This `xChange` value and the `yChange` key’s value of `0.5`
    places the next square’s position a distance of 50 percent of the current square’s
    size, to the left and above the current square’s position. This happens to center
    it on the top-left corner of the current square.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定下一个正方形的x坐标，首个字典的`xChange`值，在这种情况下是`-0.5`，乘以大小。当`size`为`350`时，这意味着下一个正方形相对于海龟当前位置有一个x坐标为`-175`单位。这个`xChange`值和`yChange`键的值为`0.5`，将下一个正方形的位置放置在当前正方形位置的左侧和上方50%的距离。这恰好将其居中在当前正方形的左上角。
- en: If you look at the three other dictionaries in the `specs` list, you’ll notice
    they all have a `sizeChange` value of `0.5`. The difference between them is that
    their `xChange` and `yChange` values place them in the other three corners of
    the current square. As a result, the next four squares are drawn centered on the
    four corners of the current square.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下`specs`列表中的其他三个字典，你会注意到它们的`sizeChange`值都是`0.5`。它们之间的区别在于它们的`xChange`和`yChange`值将它们放置在当前正方形的其他三个角落。因此，下一个四个正方形是在当前正方形的四个角上居中绘制的。
- en: The dictionaries in the `specs` list for this example don’t have an `angleChange`
    value, so this value defaults to `0.0` degrees. A positive `angleChange` value
    indicates a counterclockwise rotation, while a negative value indicates a clockwise
    rotation.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中`specs`列表中的字典没有`angleChange`值，因此这个值默认为`0.0`度。正的`angleChange`值表示逆时针旋转，而负值表示顺时针旋转。
- en: Each dictionary represents a separate square to be drawn each time the recursive
    function is called. If we were to remove the first dictionary from the `specs`
    list, each `drawFractal()` call would produce only three squares, as in [Figure
    13-9](#figure13-9).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字典代表每次递归函数调用时要绘制的一个单独的正方形。如果我们从`specs`列表中删除第一个字典，每个`drawFractal()`调用将只产生三个正方形，就像[图13-9](#figure13-9)中一样。
- en: '![Six screenshots identical to those in Figure 13-8, except the pattern develops
    on only three corners of the original square.](image_fi/502024c13/f13009.png)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![与图13-8中相同的六个截图，只是图案只在原始正方形的三个角上发展。](image_fi/502024c13/f13009.png)'
- en: 'Figure 13-9: The Four Corners fractal with the first dictionary removed from
    the `specs` list'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-9：从`specs`列表中删除第一个字典的四个角分形
- en: Applying the Specifications
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用规范
- en: 'Let’s look at how the code in `drawFractal()` actually does everything we’ve
    described:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`drawFractal()`中的代码实际上是如何做我们描述的一切的：
- en: '**Python**'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE93]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `for` loop assigns an individual specification dictionary in the `specs`
    list to the loop variable `spec` on each iteration of the loop. The `get()` dictionary
    method calls pull the values for the `sizeChange`, `xChange`, `yChange`, and `angleChange`
    keys from this dictionary and assign them to the shorter-named `sizeCh`, `xCh`,
    `yCh`, and `angleCh` variables. The `get()` method substitutes a default value
    if the key doesn’t exist in the dictionary.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环将`specs`列表中的单个规范字典分配给循环变量`spec`的每次迭代。`get()`字典方法调用从这个字典中提取`sizeChange`、`xChange`、`yChange`和`angleChange`键的值，并将它们分配给更短的名称`sizeCh`、`xCh`、`yCh`和`angleCh`变量。如果键在字典中不存在，`get()`方法会替换默认值。'
- en: 'Next, the turtle’s position and heading are reset to the values indicated when
    `drawFractal()` was first called. This ensures that the recursive calls from previous
    loop iterations don’t leave the turtle in some other place. Then the heading and
    position are changed according to the `angleCh`, `xCh`, and `yCh` variables:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，海龟的位置和朝向被重置为首次调用`drawFractal()`时指示的值。这确保了来自先前循环迭代的递归调用不会使海龟停留在其他位置。然后根据`angleCh`、`xCh`和`yCh`变量改变朝向和位置：
- en: '**Python**'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE94]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The x-change and y-change positions are expressed relative to the turtle’s current
    heading. If the turtle’s heading is `0`, the turtle’s relative x-axis is the same
    as the actual x-axis on the screen. However, if the turtle’s heading is, say,
    `45`, the turtle’s relative x-axis is at a 45-degree tilt. Moving “right” along
    the turtle’s relative x-axis would then move at an up-right angle.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: x-change和y-change位置是相对于海龟当前的朝向来表达的。如果海龟的朝向是`0`，海龟的相对x轴与屏幕上的实际x轴相同。然而，如果海龟的朝向是`45`，海龟的相对x轴就会倾斜45度。沿着海龟的相对x轴“向右”移动将以一个向上和向右的角度移动。
- en: This is why moving forward by `size * xCh` moves the turtle along its relative
    x-axis. If `xCh` is negative, `turtle.forward()` moves left along the turtle’s
    relative x-axis. The `turtle.left(90)` call points the turtle along the turtle’s
    relative y-axis, and `turtle.forward(size * yCh)` moves the turtle to the next
    shape’s starting position. However, the `turtle.left(90)` call changed the turtle’s
    heading, so `turtle.right(90)` is called to reset it back to its original direction.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么通过`size * xCh`向前移动会沿着其相对x轴移动。如果`xCh`为负，`turtle.forward()`会沿着海龟的相对x轴向左移动。`turtle.left(90)`调用将海龟指向其相对y轴，`turtle.forward(size
    * yCh)`将海龟移动到下一个形状的起始位置。然而，`turtle.left(90)`调用改变了海龟的朝向，所以调用`turtle.right(90)`将其重置回原始方向。
- en: '[Figure 13-10](#figure13-10) shows how these four lines of code move the turtle
    to the right along its relative x-axis and up along its relative y-axis and leave
    it in the correct heading, no matter what its initial heading was.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-10](#figure13-10)展示了这四行代码如何沿着海龟的相对x轴向右移动，沿着相对y轴向上移动，并且无论初始朝向如何，都将其保留在正确的朝向。'
- en: '![Four turtle graphics screenshots of the same two perpendicular lines, each
    time rotated a different way.](image_fi/502024c13/f13010.png)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
  zh: '![相同的两条垂直线的四个海龟图形截图，每次以不同的方式旋转。](image_fi/502024c13/f13010.png)'
- en: 'Figure 13-10: In each of these four images, the turtle always moves 100 units
    “right” and “up” along the relative x-axis and y-axis of its initial heading.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-10：在这四个图像中，海龟总是沿着其初始朝向的相对x轴和y轴移动100个单位“向右”和“向上”。
- en: 'Finally, with the turtle in the correct position and heading for the next shape,
    we make the recursive call to `drawFractal()`:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当乌龟处于正确的位置和朝向下一个形状时，我们对drawFractal()进行递归调用：
- en: '**Python**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE95]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `shapeDrawFunction`, `specs`, and `maxDepth` arguments are passed to the
    recursive `drawFractal()` call unchanged. However, `size * sizeCh` is passed for
    the next `size` parameter to reflect the change in the `size` of the recursive
    shape, and `depth + 1` is passed for the `depth` parameter to increment it for
    the next shape-drawing function call.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: shapeDrawFunction，specs和maxDepth参数未经修改地传递给递归drawFractal()调用。 但是，传递size * sizeCh作为下一个size参数以反映递归形状的size的变化，并且传递depth
    + 1作为depth参数以增加下一个形状绘制函数调用的深度。
- en: Creating the Example Fractals
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建示例分形
- en: Now that we’ve covered how the shape-drawing functions and recursive `drawFractal()`
    function work, let’s look at the nine example fractals that come with the Fractal
    Art Maker. You can see these examples in [Figure 13-1](#figure13-1).
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经介绍了形状绘制函数和递归drawFractal()函数的工作原理，让我们来看看随附Fractal Art Maker的九个示例分形。 您可以在[图13-1](#figure13-1)中看到这些示例。
- en: Four Corners
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Four Corners
- en: 'The first fractal is *Four Corners*, which begins as a large square. As the
    function calls itself, the fractal’s specifications cause four smaller squares
    to be drawn in the four corners of the square:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个分形是Four Corners，它开始作为一个大正方形。 随着函数调用自身，分形的规格导致在正方形的四个角落绘制四个较小的正方形：
- en: '**Python**'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE96]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The call to `drawFractal()` here limits the maximum depth to `5`, as any more
    tends to make the fractal so dense that the fine detail becomes hard to see. This
    fractal appears in [Figure 13-8](#figure13-8).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这里对drawFractal()的调用将最大深度限制为5，因为再多会使分形变得如此密集，以至于细节变得难以看清。 这个分形出现在[图13-8](#figure13-8)中。
- en: Spiral Squares
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 螺旋正方形
- en: 'The *Spiral Squares fractal*also starts as a large square, but it creates just
    one new square on each recursive call:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '*Spiral Squares fractal*也以一个大正方形开始，但每次递归调用时只创建一个新的正方形：'
- en: '**Python**'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE97]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This square is slightly smaller and rotated by `7` degrees. The centers of all
    the squares are unchanged, so there’s no need to add `xChange` and `yChange` keys
    to the specification. The default maximum depth of `8` is too small to get an
    interesting fractal, so we increase it to `50` to produce a hypnotic spiral pattern.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正方形稍小，并旋转了7度。 所有正方形的中心都没有改变，所以不需要向规范中添加xChange和yChange键。 默认的最大深度为8太小，无法得到有趣的分形，因此我们将其增加到50以产生催眠螺旋图案。
- en: Double Spiral Squares
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双螺旋正方形
- en: 'The *Double Spiral Squares fractal* is similar to Spiral Squares, except each
    square creates two smaller squares. This creates an interesting fan effect, as
    the second square is drawn later and tends to cover up previously drawn squares:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '*Double Spiral Squares fractal*类似于Spiral Squares，只是每个正方形创建两个较小的正方形。 这会产生有趣的扇形效果，因为第二个正方形稍后绘制，往往会覆盖先前绘制的正方形：'
- en: '**Python**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE98]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The squares are created slightly higher or lower than their previous square
    and rotated either `10` or `-10` degrees.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 正方形的创建略高于或低于其上一个正方形，并且旋转了10度或-10度。
- en: Triangle Spiral
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Triangle Spiral
- en: 'The *Triangle Spiral* *fractal*, another variation of Spiral Squares, uses
    the `drawTriangleOutline()` shape-drawing function instead of `drawFilledSquare()`:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '*Triangle Spiral* *fractal*，螺旋正方形的另一种变体，使用drawTriangleOutline()形状绘制函数而不是drawFilledSquare()：'
- en: '**Python**'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE99]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Unlike the Spiral Squares fractal, the Triangle Spiral fractal begins at the
    small `size` of `20` units and slightly increases in size for each level of recursion.
    The `sizeChange` key is greater than `1.0`, so the shapes are always increasing
    in size. This means the base case occurs when the recursion reaches a depth of
    `80`, because the base case of `size` becoming less than `1` is never reached.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 与螺旋正方形分形不同，Triangle Spiral分形从20个单位的小size开始，并在每个递归级别略微增加大小。 sizeChange键大于1.0，因此形状始终在增大。
    这意味着当递归达到深度80时，基本情况发生，因为size小于1的基本情况永远不会发生。
- en: Conway’s Game of Life Glider
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 康威的生命游戏Glider
- en: '*Conway’s Game of Life* is a famous example of cellular automata. The game’s
    simple rules cause interesting and wildly chaotic patterns to emerge on a 2D grid.
    One such pattern is a *Glider* consisting of five cells in a 3 × 3 space:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '*康威的生命游戏*是细胞自动机的著名例子。 游戏的简单规则导致在2D网格上出现有趣且极其混乱的图案。 其中一种图案是由5个单元格组成的3×3空间的*Glider*：'
- en: '**Python**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE100]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The Glider fractal here has additional Gliders drawn inside each of its five
    cells. The `third` variable helps precisely set the position of the recursive
    shapes in the 3 × 3 space.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的Glider分形在其五个单元格中各有额外的Glider绘制。 third变量有助于精确设置3×3空间中递归形状的位置。
- en: You can find a Python implementation of Conway’s Game of Life in my book *The
    Big Book of Small Python Projects* (No Starch Press, 2021) and online at [https://inventwithpython.com/bigbookpython/project13.html](https://inventwithpython.com/bigbookpython/project13.html).
    Tragically, John Conway, the mathematician and professor who developed Conway’s
    Game of Life, passed away of complications from COVID-19 in April 2020.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我的书《The Big Book of Small Python Projects》（No Starch Press，2021）中找到康威的生命游戏的Python实现，并在[https://inventwithpython.com/bigbookpython/project13.html](https://inventwithpython.com/bigbookpython/project13.html)上找到在线版本。
    不幸的是，数学家和教授约翰·康威于2020年4月因COVID-19并发症去世。
- en: Sierpiński Triangle
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谢尔宾斯基三角形
- en: 'We created the *Sierpiński Triangle* *fractal* in Chapter 9, but our Fractal
    Art Maker can re-create it as well by using the `drawTriangleOutline()` shape
    function. After all, a Sierpiński triangle is an equilateral triangle with three
    smaller equilateral triangles drawn in its interior:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第9章创建了Sierpiński Triangle分形，但是我们的Fractal Art Maker也可以使用drawTriangleOutline()形状函数重新创建它。
    毕竟，谢尔宾斯基三角形是一个内部绘制了三个较小的等边三角形的等边三角形：
- en: '**Python**'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE101]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The center of these smaller triangles is `size * math.sqrt(3) / 6` units from
    the center of the previous triangle. The three calls adjust the heading of the
    turtle to `0`, `120`, and `240` degrees before moving up on the turtle’s relative
    y-axis.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Wave
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We discussed the *Wave fractal* at the start of this chapter, and you can see
    it in [Figure 13-5](#figure13-5). This relatively simple fractal creates three
    smaller and distinct recursive triangles:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Horn
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Horn fractal* resembles a ram’s horn:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This simple fractal is made up of squares, each of which is slightly smaller,
    moved up, and rotated `11` degrees from the previous square. We increase the maximum
    recursion depth to `100` to extend the horn into a tight spiral.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Snowflake
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final fractal, *Snowflake*, is composed of squares laid out in a pentagon
    pattern. This is similar to the Four Corners fractal, but it uses five evenly
    spaced recursive squares instead of four:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This fractal uses the cosine and sine functions from trigonometry, implemented
    in Python’s `math.cos()` and `math.sin()` functions, to determine how to shift
    the squares along the x-axis and y-axis. A full circle has 360 degrees, so to
    evenly space out the five recursive squares in this circle, we place them at intervals
    of 0, 72, 144, 216, and 288 degrees. The `math.cos()` and `math.sin()` functions
    expect the angle argument to be in radians instead of degrees, so we must multiply
    these numbers by `math.pi / 180`.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that each square is surrounded by five other squares, which
    are surrounded by five other squares, and so on, to form a crystal-like fractal
    that resembles a snowflake.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Producing a Single Square or Triangle
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For completion, you can also set `DRAW_FRACTAL` to `10` or `11` to view what
    a single call to `drawFilledSquare()` and `drawTriangleOutline()` produce in the
    turtle window. These shapes are drawn with a size of `600`:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: After drawing the fractal or shape based on the value in `DRAW_FRACTAL`, the
    program calls `turtle.exitonclick()` so that the turtle window stays open until
    the user clicks it. Then the program terminates.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your Own Fractals
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create your own fractals by changing the specification passed to the
    `drawFractal()` function. Start by thinking about how many recursive calls you’d
    like each call to `drawFractal()` to generate, and how the size, position, and
    heading of the shapes should change. You can use the existing shape-drawing functions
    or create your own.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Figure 13-11](#figure13-11) shows the nine built-in fractals,
    except the square and triangle functions have been swapped. Some of these produce
    bland shapes, but others can result in unexpected beauty.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '![The six fractals from Figure 13-1 with all the squares and triangles swapped.](image_fi/502024c13/f13011.png)'
  id: totrans-619
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-11: The nine fractals that come with Fractal Art Maker, with the
    shape-drawing functions swapped'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fractal Art Maker projects demonstrate the endless possibilities of recursion.
    A simple recursive `drawFractal()` function, paired with a shape-drawing function,
    can create a large variety of detailed geometric art.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: At the core of Fractal Art Maker is the recursive `drawFractal()` function,
    which accepts another function as an argument. This second function draws a basic
    shape repeatedly by using the size, position, and heading given in the list of
    specification dictionaries.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: You can test an unlimited number of shape-drawing functions and specification
    settings. Let your creativity drive your fractal projects as you experiment with
    the code in this program.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are websites that allow you to create fractals. Interactive Fractal Tree
    at [https://www.visnos.com/demos/fractal](https://www.visnos.com/demos/fractal)
    has sliders to change a binary tree fractal’s angle and size parameters. Procedural
    Snowflake at [https://procedural-snowflake.glitch.me](https://procedural-snowflake.glitch.me)
    generates new snowflakes in your browser. Nico’s Fractal Machine at [https://sciencevsmagic.net/fractal](https://sciencevsmagic.net/fractal)
    creates animated drawings of fractals. You can find others by searching the web
    for *fractal maker* or *fractal generator online*.``  ``# 14
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些网站可以让您创建分形。交互式分形树在[https://www.visnos.com/demos/fractal](https://www.visnos.com/demos/fractal)上有滑块可以改变二叉树分形的角度和大小参数。[https://procedural-snowflake.glitch.me](https://procedural-snowflake.glitch.me)上的程序性雪花可以在您的浏览器中生成新的雪花。Nico的分形机在[https://sciencevsmagic.net/fractal](https://sciencevsmagic.net/fractal)上创建分形的动画图。您可以通过在网络上搜索*分形制造商*或*在线分形生成器*来找到其他网站。``  ``#
    14
- en: Droste Maker
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: Droste制造商
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: The *Droste effect* is a recursive art technique named after a 1904 illustration
    on a tin of Droste’s Cacao, a Dutch brand of cocoa. Shown in [Figure 14-1](#figure14-1),
    the tin features an image of a nurse holding a meal tray containing a tin of Droste
    cocoa, which itself bears the illustration.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '*Droste效应*是一种递归艺术技术，以荷兰品牌Droste可可的1904年插图命名。在[图14-1](#figure14-1)中，这个罐子上有一个护士拿着一个托盘，托盘上有一个Droste可可的罐子，罐子上有这个插图。'
- en: In this chapter we’ll create a Droste Maker program that can generate similar
    recursive images from any photograph or drawing you have, whether it be a museum
    patron looking at an exhibit of themself, a cat in front of a computer monitor
    of a cat in front of a computer monitor, or something else entirely.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个Droste制造商程序，可以从您拥有的任何照片或图纸生成类似的递归图像，无论是一个在博物馆观看自己展品的参观者，一只猫在另一只猫前面的计算机显示器，还是其他任何东西。
- en: '![A tin of Droste cocoa from 1904\. The illustration on the tin features a
    nurse holding a tray with a steaming mug and a tin of Droste cocoa. The recursive
    illustration on this tin is the same nurse holding a tray with a steaming mug
    and a tin of Droste cocoa.](image_fi/502024c14/f14001.png)'
  id: totrans-631
  prefs: []
  type: TYPE_IMG
  zh: '![1904年的Droste可可罐。罐子上的插图是一个护士拿着一个托盘，托盘上有一杯冒着热气的杯子和一个Droste可可罐。这个罐子上的递归插图是同一个护士拿着一个托盘，托盘上有一杯冒着热气的杯子和一个Droste可可罐。](image_fi/502024c14/f14001.png)'
- en: 'Figure 14-1: The recursive illustration on a tin of Droste’s Cacao'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '图14-1: Droste可可罐上的递归插图'
- en: Using a graphics program such as Microsoft Paint or Adobe Photoshop, you’ll
    prepare the image by covering an area of it with a pure magenta color, indicating
    where to place the recursive image. The Python program uses the Pillow image library
    to read this image data and produce a recursive image.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如Microsoft Paint或Adobe Photoshop之类的图形程序，您将通过用纯品红色覆盖图像的一部分来准备图像，指示递归图像的放置位置。Python程序使用Pillow图像库读取这些图像数据并生成递归图像。
- en: First, we’ll cover how to install the Pillow library and how the Droste Maker
    algorithm works. Next, we’ll present the Python source code for the program with
    accompanying explanation of the code.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍如何安装Pillow库以及Droste制造商算法的工作原理。接下来，我们将提供程序的Python源代码，并解释代码。
- en: Installing the Pillow Python Library
  id: totrans-635
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Pillow Python库
- en: This chapter’s project requires the Pillow image library. This library allows
    your Python programs to create and modify image files including PNGs, JPEGs, and
    GIFs. It has several functions to perform resizing, copying, cropping, and other
    common actions on images.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目需要Pillow图像库。这个库允许您的Python程序创建和修改图像文件，包括PNG、JPEG和GIF。它有几个函数可以执行调整大小、复制、裁剪和其他常见的图像操作。
- en: To install this library on Windows, open a command prompt window and run `py
    -m pip install --user pillow`. To install this library on macOS or Linux, open
    a Terminal window and run python3 `-m pip install --user pillow`. This command
    makes Python use the pip installer program to download the module from the official
    Python Package Index at [https://pypi.org](https://pypi.org).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows上安装此库，请打开命令提示窗口并运行`py -m pip install --user pillow`。要在macOS或Linux上安装此库，请打开终端窗口并运行python3
    `-m pip install --user pillow`。此命令使Python使用pip安装程序从[https://pypi.org](https://pypi.org)官方Python软件包索引下载模块。
- en: To verify that the installation worked, open a Python terminal and run `from
    PIL import Image`. (While the library’s name is Pillow, the Python module installed
    is named `PIL`, in capital letters.) If no error appears, the library was installed
    correctly.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证安装是否成功，请打开Python终端并运行`from PIL import Image`。（虽然库的名称是Pillow，但安装的Python模块名为`PIL`，大写字母。）如果没有出现错误，则库已正确安装。
- en: The official documentation for Pillow can be found at [https://pillow.readthedocs.io](https://pillow.readthedocs.io).
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow的官方文档可以在[https://pillow.readthedocs.io](https://pillow.readthedocs.io)找到。
- en: Painting Your Image
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制您的图像
- en: The next step is to prepare an image by setting a portion of it to the RGB (red,
    green, blue) color value (255, 0, 255). Computer graphics often use magenta to
    mark which pixels of an image should be rendered as transparent. Our program will
    treat these magenta pixels like a green screen in video production, replacing
    them with a resized version of the initial image. Of course, this resized image
    will have its own smaller magenta area, which the program will replace with another
    resized image. The base case occurs when the final image has no more magenta pixels,
    at which point the algorithm is done.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过将图像的一部分设置为RGB（红色、绿色、蓝色）颜色值（255, 0, 255）来准备图像。计算机图形通常使用品红色来标记图像的哪些像素应该被渲染为透明。我们的程序将把这些品红色像素视为视频制作中的绿屏，用初始图像的调整版本替换它们。当然，这个调整后的图像将有自己更小的品红区域，程序将用另一个调整后的图像替换它。当最终图像没有更多品红像素时，基本情况发生，此时算法完成。
- en: '[Figure 14-2](#figure14-2) shows the progression of images created as the resized
    image is recursively applied to the magenta pixels. In this example, a model stands
    in front of an art museum exhibit that has been replaced with magenta pixels,
    turning the photograph itself into the exhibit. You can download this base image
    from [https://inventwithpython.com/museum.png](https://inventwithpython.com/museum.png).'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-2](#figure14-2)显示了随着调整大小的图像递归应用到品红色像素而创建的图像的进展。在这个例子中，一个模特站在一个被品红色像素替换的艺术博物馆展品前，将照片本身变成了展品。你可以从[https://inventwithpython.com/museum.png](https://inventwithpython.com/museum.png)下载这个基础图像。'
- en: Be sure you use only the pure (255, 0, 255) magenta color for painting the magenta
    area in your image. Some tools may have a fading effect that produces a more natural
    look. For example, Photoshop’s Brush tool will produce faded magenta pixels on
    the outline of the painted area, so you will need to use the Pencil tool instead,
    which paints using only the precise pure magenta color you’ve selected. If your
    graphics program doesn’t allow you to specify the precise RGB color for drawing,
    you can copy and paste the colors from the PNG image at [https://inventwithpython.com/magenta.png](https://inventwithpython.com/magenta.png).
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在你的图像中只使用纯(255, 0, 255)品红色来绘制品红色区域。一些工具可能会产生淡化效果，产生更自然的外观。例如，Photoshop的画笔工具会在绘制区域的轮廓上产生淡化的品红色像素，所以你需要使用铅笔工具，它只使用你选择的精确纯品红色来绘制。如果你的图形程序不允许你指定绘制的精确RGB颜色，你可以从[https://inventwithpython.com/magenta.png](https://inventwithpython.com/magenta.png)的PNG图像中复制和粘贴颜色。
- en: The magenta area in the image can be of any size or shape; it does not have
    to be an exact, contiguous rectangle. You can see that in [Figure 14-2](#figure14-2),
    the museum visitor cuts into the magenta rectangle, placing them in front of the
    recursive image.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 图像中的品红色区域可以是任意大小或形状；它不必是一个精确的、连续的矩形。你可以在[图14-2](#figure14-2)中看到，博物馆参观者切入品红色矩形，将他们放在递归图像的前面。
- en: If you make your own images with Droste Maker, you should use the PNG image
    file format instead of JPEG. JPEG images use *lossy* compression techniques to
    keep the file size small that introduce slight imperfections. These are usually
    imperceptible to the human eye and don’t affect overall image quality. However,
    this lossy compression will replace the pure (255, 0, 255) magenta pixels with
    slightly different shades of magenta. The *lossless* image compression of PNG
    images ensures this won’t happen.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用Droste Maker制作自己的图像，你应该使用PNG图像文件格式而不是JPEG。JPEG图像使用*有损*压缩技术来保持文件大小小，引入了轻微的瑕疵。这些通常对人眼来说是不可察觉的，不会影响整体图像质量。然而，这种有损压缩会用稍微不同色调的品红色像素取代纯(255,
    0, 255)品红色。PNG图像的*无损*压缩确保这种情况不会发生。
- en: '![Four images of a girl, seen from behind, looking at a work of art. In the
    first image, the work of art is covered by a monochrome rectangle. In the second
    image, the monochrome rectangle has been replaced by a resized version of the
    original image of the girl. In the third and fourth images, the monochrome rectangles
    have once again been replaced, creating the effect that the girl is looking at
    herself looking at herself.](image_fi/502024c14/f14002.png)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
  zh: '![一个女孩的四张图像，从背后看着一件艺术品。在第一张图像中，艺术品被单色矩形覆盖。在第二张图像中，单色矩形被原始女孩图像的调整大小版本替换。在第三和第四张图像中，单色矩形再次被替换，产生了女孩看着自己看着自己的效果。](image_fi/502024c14/f14002.png)'
- en: 'Figure 14-2: Recursive applications of the image to the magenta pixels. If
    you are viewing the black-and-white image printed in this book, the magenta area
    is the rectangle in front of the museum visitor.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-2：图像递归应用到品红色像素。如果你在本书中查看黑白图像，品红色区域是博物馆参观者前面的矩形。
- en: The Complete Droste Maker Program
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的Droste Maker程序
- en: 'The following is the source code for *drostemaker.py*; because this program
    relies on the Python-only Pillow library, there is no JavaScript equivalent for
    this project in this book:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*drostemaker.py*的源代码；因为这个程序依赖于仅限于Python的Pillow库，所以在本书中这个项目没有JavaScript的等价物：
- en: '[PRE106]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Before you run this program, place your image file in the same folder as *drostemaker.py*.
    The program will save the recursive image as *museum-recursive.png* and then open
    an image viewer to display it. If you want to run the program on your own image
    that you’ve added a magenta area to, replace `makeDroste('museum.png')` at the
    end of the source code with the name of your image file and `save('museum-recursive.png')`
    with the name you’d like to use to save the recursive image.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这个程序之前，将你的图像文件放在与*drostemaker.py*相同的文件夹中。程序将递归图像保存为*museum-recursive.png*，然后打开一个图像查看器来显示它。如果你想在你自己添加了品红色区域的图像上运行程序，用你的图像文件的名称替换源代码末尾的`makeDroste('museum.png')`，用你想要用来保存递归图像的名称替换`save('museum-recursive.png')`。
- en: Setting Up
  id: totrans-652
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: 'The Droste Maker program has only one function, `makeDroste()`, which accepts
    a Pillow `Image` object or a string of an image’s filename. The function returns
    a Pillow `Image` object with any magenta pixels recursively replaced by a version
    of the same image:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: Droste Maker程序只有一个函数`makeDroste()`，它接受一个Pillow `Image`对象或一个图像文件名的字符串。该函数返回一个Pillow
    `Image`对象，其中任何品红色像素都被同一图像的版本递归地替换：
- en: '**Python**'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE107]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The program begins by importing the `Image` class from the Pillow library (named
    `PIL` as a Python module). Within the `makeDroste()` function, we check whether
    the `baseImage` parameter is a string, and if so, we replace it with a Pillow
    `Image` object loaded from the corresponding image file.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 程序开始时从Pillow库（作为Python模块命名为`PIL`）导入`Image`类。在`makeDroste()`函数内部，我们检查`baseImage`参数是否是一个字符串，如果是，我们将其替换为从相应图像文件加载的Pillow
    `Image`对象。
- en: 'Next, we check whether the `stopAfter` parameter is `0`. If it is, we’ve reached
    one of the algorithm’s base cases and the function returns the Pillow `Image`
    object of the base image:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查`stopAfter`参数是否为`0`。如果是，我们已经达到了算法的一个基本情况，函数将返回基础图像的Pillow `Image`对象：
- en: '**Python**'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE108]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The `stopAfter` parameter is `10` by default if the function call doesn’t provide
    one. The recursive call to `makeDroste()` later in this function passes `stopAfter
    - 1` as the argument for this parameter so that it decreases with each recursive
    call and approaches the base case of `0`.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数调用没有提供`stopAfter`，则`stopAfter`参数默认为`10`。在此函数中稍后对`makeDroste()`的递归调用将`stopAfter
    - 1`作为该参数的参数传递，以便它在每次递归调用时减少，并接近`0`的基本情况。
- en: For example, passing `0` for `stopAfter` results in the function immediately
    returning a recursive image identical to the base image. Passing `1` for `stopAfter`
    replaces the magenta area with a recursive image once, makes one recursive call,
    reaches the base case, and immediately returns. Passing `2` for `stopAfter` causes
    two recursive calls, and so on.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将`0`传递给`stopAfter`会导致函数立即返回与基本图像相同的递归图像。将`1`传递给`stopAfter`会替换品红区域为递归图像一次，进行一次递归调用，达到基本情况，并立即返回。将`2`传递给`stopAfter`会导致两次递归调用，依此类推。
- en: This parameter prevents the function from recursing until it causes a stack
    overflow in cases when the magenta area is particularly large. It also lets us
    pass a smaller argument than `10` to limit the number of recursive images placed
    in the base image. For example, the four images in [Figure 14-2](#figure14-2)
    were created by passing `0`, `1`, `2`, and `3` for the `stopAfter` parameter.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 该参数防止函数在品红区域特别大时递归，直到导致堆栈溢出。它还允许我们传递比`10`更小的参数，以限制放置在基本图像中的递归图像的数量。例如，通过为`stopAfter`参数传递`0`、`1`、`2`和`3`，可以创建[图14-2](#figure14-2)中的四幅图像。
- en: 'Next, we check the color mode of the base image. This can be either `RGB` for
    an image with red-green-blue pixels or `RGBA` for an image that has an alpha channel
    for its pixels. The *alpha value* tells a pixel’s level of transparency. Here’s
    the code:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查基本图像的颜色模式。这可以是`RGB`，表示具有红绿蓝像素的图像，或者`RGBA`，表示具有像素alpha通道的图像。*alpha值*表示像素的透明级别。以下是代码：
- en: '**Python**'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE109]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The Droste Maker needs to know the color mode so that it can find magenta pixels.
    The values for each channel range from `0` to `255`, and magenta pixels have a
    maximum amount of red and blue but no green. Further, if an alpha channel exists,
    it would be set to `255` for a completely opaque color and `0` for a completely
    transparent one. The `magentaColor` variable is set to the correct tuple value
    for a magenta pixel depending on the image’s color mode given in `baseImage.mode`.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: Droste Maker需要知道颜色模式，以便它可以找到品红像素。每个通道的值范围从`0`到`255`，品红像素具有最大量的红色和蓝色，但没有绿色。此外，如果存在alpha通道，对于完全不透明的颜色，它将设置为`255`，对于完全透明的颜色，它将设置为`0`。根据`baseImage.mode`中给出的图像颜色模式，`magentaColor`变量设置为品红像素的正确元组值。
- en: Finding the Magenta Area
  id: totrans-667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找品红区域
- en: Before the program can recursively insert the image into the magenta area, it
    must find the boundaries of the magenta area in the image. This involves finding
    the leftmost, rightmost, topmost, and bottommost magenta pixels in the image.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序可以递归地将图像插入品红区域之前，它必须找到图像中品红区域的边界。这涉及找到图像中最左、最右、最上和最下的品红像素。
- en: While the magenta area itself doesn’t need to be a perfect rectangle, the program
    needs to know the rectangular boundaries of the magenta in order to properly resize
    the image for insertion. For example, [Figure 14-3](#figure14-3) shows a base
    image of the *Mona Lisa* with the magenta area outlined in white. The magenta
    pixels are replaced to produce the recursive image.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然品红区域本身不需要是一个完美的矩形，但程序需要知道品红的矩形边界，以便正确调整图像以进行插入。例如，[图14-3](#figure14-3)显示了*蒙娜丽莎*的基本图像，其中品红区域用白色轮廓标出。品红像素被替换以生成递归图像。
- en: '![Two images of the Mona Lisa. In the first, the woman’s face and torso have
    been replaced with a monochrome shape, and a white rectangle indicates the boundaries
    of that shape. In the second image, the monochrome area has been replaced by progressively
    smaller versions of the original image.](image_fi/502024c14/f14003.png)'
  id: totrans-670
  prefs: []
  type: TYPE_IMG
  zh: '![蒙娜丽莎的两幅图像。在第一幅图像中，女人的脸和躯干被单色形状替换，白色矩形表示该形状的边界。在第二幅图像中，单色区域已被原始图像的逐渐缩小版本替换。](image_fi/502024c14/f14003.png)'
- en: 'Figure 14-3: The base image with a magenta area outlined in white (left) and
    the recursive image it produces (right)'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-3：带有白色轮廓的品红区域的基本图像（左）及其生成的递归图像（右）
- en: 'To calculate the resizing and placement of the resized image, the program retrieves
    the width and height of the base image from the `size` attribute of the Pillow
    `Image` object in `baseImage`. The following lines initialize four variables for
    the four edges of the magenta area—`magentaLeft`, `magentaRight`, `magentaTop`,
    and `magentaBottom`—to the `None` value:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算调整大小和调整后图像的放置位置，程序从`baseImage`中Pillow`Image`对象的`size`属性中检索基本图像的宽度和高度。以下行初始化了四个变量，用于品红区域的四个边缘——`magentaLeft`，`magentaRight`，`magentaTop`和`magentaBottom`——并将其值设置为`None`：
- en: '**Python**'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE110]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'These edge variable values are replaced by integer `x` and `y` coordinates
    in the code that comes next:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 这些边缘变量的值在接下来的代码中被整数`x`和`y`坐标替换：
- en: '**Python**'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE111]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: These nested `for` loops iterate the `x` and `y` variables over every possible
    x, y coordinate in the base image. We check whether the pixel at each coordinate
    is the pure magenta color stored in `magentaColor`, then update the `magentaLeft`
    variable if the coordinates of the magenta pixel are further left than currently
    recorded in `magentaLeft`, and so on for the other three directions.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 这些嵌套的`for`循环在基本图像的每个可能的x、y坐标上迭代`x`和`y`变量。我们检查每个坐标处的像素是否为存储在`magentaColor`中的纯品红色，然后更新`magentaLeft`变量，如果品红像素的坐标比`magentaLeft`中当前记录的更靠左，则对其他三个方向也是如此。
- en: 'By the time the nested `for` loops are finished, `magentaLeft`, `magentaRight`,
    `magentaTop`, and `magentaBottom` will describe the boundaries of the magenta
    pixels in the base image. If the image has no magenta pixels, these variables
    will remain set to their initial `None` value:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 当嵌套的`for`循环完成时，`magentaLeft`，`magentaRight`，`magentaTop`和`magentaBottom`将描述基本图像中品红像素的边界。如果图像没有品红像素，这些变量将保持设置为它们最初的`None`值：
- en: '**Python**'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE112]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: If `magentaLeft` (or really, any of the four variables) is still set to `None`
    after the nested `for` loops complete, no magenta pixels are in the image. This
    is a base case for our recursive algorithm because the magenta area becomes smaller
    and smaller with each recursive call to `makeDroste()`. At this point, the function
    returns the Pillow `Image` object in `baseImage`.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 如果嵌套的`for`循环完成后`magentaLeft`（或者实际上是这四个变量中的任何一个）仍然设置为`None`，则图像中没有品红像素。这是我们递归算法的基本情况，因为随着每次对`makeDroste()`的递归调用，品红区域会变得越来越小。此时，函数返回`baseImage`中的Pillow`Image`对象。
- en: Resizing the Base Image
  id: totrans-683
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整基本图像的大小
- en: We need to resize the base image to cover the entire magenta area and no more.
    [Figure 14-4](#figure14-4) shows the complete resized image overlayed transparently
    on the original base image. This resized image is cropped so that only the parts
    over magenta pixels are copied over to the final image.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将基本图像调整大小以完全覆盖品红区域，不多不少。[图14-4](#figure14-4)显示了完整的调整大小后的图像透明地叠加在原始基本图像上。这个调整大小后的图像被裁剪，以便只有覆盖品红像素的部分被复制到最终图像中。
- en: '![Four images of a cat sitting in front of a computer monitor. In the first,
    the computer monitor’s screen is covered in a monochrome shade. In the second,
    the monochrome area has been replaced by a smaller version of the original image,
    but this version is transparent, making visible the places where it overlaps with
    the non-monochrome portions of the larger image. The third image is the completed
    recursive image.](image_fi/502024c14/f14004.png)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
  zh: '![一只猫坐在计算机显示器前的四幅图像。在第一幅图像中，计算机显示器的屏幕被单色遮盖。在第二幅图像中，单色区域被原始图像的较小版本替换，但这个版本是透明的，可以看到它与较大图像的非单色部分重叠的地方。第三幅图像是完成的递归图像。](image_fi/502024c14/f14004.png)'
- en: 'Figure 14-4: The base image with the magenta area in the monitor (top), the
    resized image over the base image (middle), and the final recursive image that
    replaces only the magenta pixels (bottom)'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-4：带有显示器中品红区域的基本图像（顶部），覆盖在基本图像上的调整大小后的图像（中部），以及替换仅品红像素的最终递归图像（底部）
- en: We cannot simply resize the base image to the dimensions of the magenta area
    because it’s unlikely the two share the same *aspect ratio*, or proportion of
    the width divided by the height. Doing so results in a recursive image that looks
    stretched or squished, like [Figure 14-5](#figure14-5).
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地将基本图像调整大小到品红区域的尺寸，因为两者不太可能具有相同的*长宽比*，即宽度除以高度的比例。这样做会导致一个看起来被拉伸或压缩的递归图像，就像[图14-5](#figure14-5)一样。
- en: Instead, we must make the resized image large enough to completely cover the
    magenta area but still retain the image’s original aspect ratio. This means either
    setting the width of the resized image to the width of the magenta area such that
    the height of the resized image is equal to or larger than the height of the magenta
    area, or setting the height of the resized image to the height of the magenta
    area such that the width of the resized image is equal to or larger than the width
    of the magenta area.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们必须使调整大小后的图像足够大，以完全覆盖品红区域，但仍保留图像的原始长宽比。这意味着要么将调整大小后的图像的宽度设置为品红区域的宽度，使得调整大小后的图像的高度等于或大于品红区域的高度，要么将调整大小后的图像的高度设置为品红区域的高度，使得调整大小后的图像的宽度等于或大于品红区域的宽度。
- en: '![Version of the recursive image of the girl looking at herself in which subsequent
    appearances of the girl appear distorted.](image_fi/502024c14/f14005.png)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
  zh: '![女孩看着自己的递归图像的版本，其中女孩的后续出现看起来扭曲。](image_fi/502024c14/f14005.png)'
- en: 'Figure 14-5: Resizing the image to the dimensions of the magenta area can result
    in a different aspect ratio, causing it to look stretched or squished.'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-5：将图像调整大小到品红区域的尺寸可能会导致不同的长宽比，使其看起来被拉伸或压缩。
- en: 'To calculate the correct resizing dimensions, the program needs to determine
    the aspect ratio of both the base image and the magenta area:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算正确的调整尺寸，程序需要确定基本图像和品红区域的长宽比：
- en: '**Python**'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE113]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'From `magentaRight` and `magentaLeft`, we can calculate the width of the magenta
    area. The `+ 1` accounts for a small, necessary adjustment: if the right side
    of the magenta area was the x-coordinate of 11 and the left side was 10, the width
    would be two pixels. This is correctly calculated by (`magentaRight - magentaLeft
    + 1`), not (`magentaRight - magentaLeft`).'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 从`magentaRight`和`magentaLeft`，我们可以计算出品红区域的宽度。`+1`是为了一个小的必要调整：如果品红区域的右侧x坐标为11，左侧为10，宽度将为两个像素。这是通过(`magentaRight
    - magentaLeft + 1`)正确计算的，而不是(`magentaRight - magentaLeft`)。
- en: 'Because the aspect ratio is the width divided by the height, images with large
    aspect ratios are taller than they are wide, and those with small aspect ratios
    are wider than they are tall. An aspect ratio of 1.0 describes a perfect square.
    The next lines set the dimensions of the resized image after comparing the aspect
    ratios of the base image and the magenta area:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 因为长宽比是宽度除以高度，具有大长宽比的图像比宽度大，具有小长宽比的图像比高度大。长宽比为1.0描述了一个完美的正方形。接下来的行设置了基本图像和品红区域的长宽比后调整大小图像的尺寸：
- en: '[PRE114]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: If the base image’s aspect ratio is less than the magenta area’s aspect ratio,
    the resized image’s width should match the width of the magenta area. If the base
    image’s aspect ratio is greater, the resized image’s height should match the height
    of the magenta area. We then determine the other dimension by multiplying the
    base image’s height by the width ratio, or the base image’s width by the height
    ratio. This ensures that the resized image both completely covers the magenta
    area and remains proportional to its original aspect ratio.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基础图像的宽高比小于品红色区域的宽高比，则调整大小后的图像的宽度应与品红色区域的宽度匹配。如果基础图像的宽高比大，则调整大小后的图像的高度应与品红色区域的高度匹配。然后，我们通过将基础图像的高度乘以宽度比例或将基础图像的宽度乘以高度比例来确定另一个维度。这确保了调整大小后的图像既完全覆盖品红色区域，又保持与其原始宽高比的比例。
- en: We call the `resize()` method once to produce a new Pillow `Image` object resized
    to match either the width of the base image or the height of the base image. The
    first argument is a (width, height) tuple for the new image’s size. The second
    argument is the `Image.NEAREST` constant from the Pillow library that tells the
    `resize()` method to use the nearest neighbor algorithm when resizing the image.
    This prevents the `resize()` method from blending the colors of the pixels to
    produce a smooth image.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`resize()`方法一次，以生成一个新的Pillow`Image`对象，其大小与基础图像的宽度或高度匹配。第一个参数是一个(宽度，高度)元组，用于新图像的大小。第二个参数是Pillow库中的`Image.NEAREST`常量，告诉`resize()`方法在调整图像大小时使用最近邻算法。这可以防止`resize()`方法混合像素颜色以产生平滑的图像。
- en: We don’t want this, because it could blur the magenta pixels with neighboring
    non-magenta pixels in the resized image. Our `makeDroste()` function relies on
    detecting magenta pixels with the exact RGB color of (255, 0, 255) and would ignore
    these slightly off magenta pixels. The end result would be a pinkish outline around
    the magenta areas that would ruin our image. The nearest neighbor algorithm doesn’t
    do this blurring, leaving our magenta pixels exactly at the (255, 0, 255) magenta
    color.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望这样，因为这可能会使调整大小后的图像中的品红色像素与相邻的非品红色像素模糊在一起。我们的`makeDroste()`函数依赖于检测具有精确RGB颜色(255,
    0, 255)的品红色像素，并且会忽略这些略微偏离的品红色像素。最终结果将是品红色区域周围有一个粉红色的轮廓，这将破坏我们的图像。最近邻算法不会进行这种模糊处理，使我们的品红色像素恰好保持在(255,
    0, 255)的品红色。
- en: Recursively Placing the Image Within the Image
  id: totrans-700
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在图像中递归放置图像
- en: 'Once the base image has been resized, we can place the resized image over the
    base image. But the pixels from the resized image should be placed over only magenta
    pixels in the base image. The resized image will be placed such that the top-left
    corner of the resized image is at the top-left corner of the magenta area:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 基础图像调整大小后，我们可以将调整大小后的图像放置在基础图像上。但是，调整大小后的图像的像素应该只放置在基础图像中的品红色像素上。调整大小后的图像将被放置在这样一个位置，即调整大小后的图像的左上角位于品红色区域的左上角：
- en: '**Python**'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE115]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Two nested `for` loops iterate over every pixel in the magenta area. Remember
    that the magenta area does not have to be a perfect rectangle, so we check whether
    the pixel at the current coordinates is magenta. If so, we get the pixel color
    from the corresponding coordinates in the resized image and place it on the base
    image. After the two nested `for` loops have finished looping, the magenta pixels
    in the base image will have been replaced by pixels from the resized image.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 两个嵌套的`for`循环遍历品红色区域中的每个像素。请记住，品红色区域不一定是一个完美的矩形，因此我们要检查当前坐标处的像素是否为品红色。如果是，我们从调整大小后的图像中获取相应坐标处的像素颜色，并将其放置在基础图像上。两个嵌套的`for`循环完成循环后，基础图像中的品红色像素将被调整大小后的图像中的像素替换。
- en: 'However, the resized image itself could have magenta pixels, and if so, these
    will now become part of the base image, as in the top-right image of [Figure 14-2](#figure14-2).
    We’ll need to pass the modified base image to a recursive `makeDroste()` call:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，调整大小后的图像本身可能有品红色的像素，如果是这样，这些像素现在将成为基础图像的一部分，就像[图14-2](#figure14-2)的右上图中一样。我们需要将修改后的基础图像传递给递归的`makeDroste()`调用：
- en: '**Python**'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE116]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This line is the recursive call in our recursive algorithm, and it’s the last
    line of code in the `makeDroste()` function. This recursion handles the new magenta
    area copied from the resized image. Note that the value passed for the `stopAfter`
    parameter is `stopAfter - 1`, ensuring that it comes closer to the base case of
    `0`.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行是我们递归算法中的递归调用，也是`makeDroste()`函数中的最后一行代码。这种递归处理了从调整大小后的图像复制的新品红色区域。请注意，传递给`stopAfter`参数的值是`stopAfter
    - 1`，确保它更接近`0`的基本情况。
- en: 'Finally, the Droste Maker program begins by passing `′museum.png′` to `makeDroste()`
    to get the Pillow `Image` object of the recursive image. We save this as a new
    image file named *museum-recursive.png*and display the recursive image in a new
    window for the user to view:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Droste Maker程序通过将`′museum.png′`传递给`makeDroste()`来开始，以获得递归图像的Pillow`Image`对象。我们将其保存为一个名为*museum-recursive.png*的新图像文件，并在新窗口中显示递归图像供用户查看：
- en: '**Python**'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '[PRE117]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: You can change these filenames to whichever image on your computer you’d like
    to use with the program.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些文件名更改为计算机上您想要与程序一起使用的任何图像。
- en: Does the `makeDroste()` function need to be implemented with recursion? Simply
    put, no. Notice that no tree-like structure is involved in the problem, and the
    algorithm does no backtracking, which is a sign that recursion may be an overengineered
    approach to this code.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeDroste()`函数需要使用递归实现吗？简单地说，不需要。请注意，问题中没有涉及类似树状结构，并且算法不进行回溯，这表明递归可能是对这段代码过度设计的方法。'
- en: Summary
  id: totrans-714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter’s project was a program that produces recursive Droste effect images,
    just like the illustration on old tins of Droste’s Cacao. The program works by
    using pure magenta pixels with RGB values of (255, 0, 255) to mark the parts of
    the image that should be replaced by a smaller version. Since this smaller version
    will also have its own smaller magenta area, the replacements will repeat until
    the magenta area is gone to produce a recursive image.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目是一个程序，可以生成递归Droste效应图像，就像Droste的Cacao旧罐头上的插图一样。该程序通过使用纯品红像素（RGB值为（255,
    0, 255））来标记图像中应该被较小版本替换的部分来工作。由于这个较小的版本也将有自己较小的品红区域，替换将重复进行，直到品红区域消失以生成递归图像。
- en: The base case for our recursive algorithm occurs when no more magenta pixels
    remain in the image to place the smaller recursive image in, or when the `stopAfter`
    counter reaches `0`. Otherwise, the recursive case passes the image to the `makeDroste()`
    function to continue to replace the magenta area with even smaller recursive images.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 我们递归算法的基本情况是当图像中没有更多品红像素可以放置较小的递归图像，或者`stopAfter`计数器达到`0`时。否则，递归情况将图像传递给`makeDroste()`函数，以继续用更小的递归图像替换品红区域。
- en: You can modify your own photos to add magenta pixels and then run them through
    the Droste Maker. The museum patron looking at an exhibit of themself, the cat
    in front of a computer monitor of the cat in front of a computer monitor, and
    the faceless *Mona Lisa* images are just a few examples of the surreal possibilities
    you can create with this recursive program.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以修改自己的照片以添加品红像素，然后通过Droste Maker运行它们。在一个展览中观看自己的博物馆参观者，猫坐在猫前面的计算机显示器前，以及无面孔的《蒙娜丽莎》图像只是您可以用这个递归程序创造的超现实可能性的一些例子。
- en: Further Reading
  id: totrans-718
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The Wikipedia article for the Droste effect at [https://en.wikipedia.org/wiki/Droste_effect](https://en.wikipedia.org/wiki/Droste_effect)
    has examples of products other than Droste’s Cacao that use the Droste effect.
    Dutch artist M.C. Escher’s *Print Gallery* is a famous example of a scene that
    also contains itself, and you can learn more about it at [https://en.wikipedia.org/wiki/Print_Gallery_(M._C._Escher)](https://en.wikipedia.org/wiki/Print_Gallery_(M._C._Escher)).
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科关于Droste效应的文章[https://en.wikipedia.org/wiki/Droste_effect](https://en.wikipedia.org/wiki/Droste_effect)中有除Droste的Cacao之外使用Droste效应的产品的例子。荷兰艺术家M.C.
    Escher的作品《Print Gallery》是一个著名的场景，其中也包含了自身，您可以在[https://en.wikipedia.org/wiki/Print_Gallery_(M._C._Escher)](https://en.wikipedia.org/wiki/Print_Gallery_(M._C._Escher))了解更多信息。
- en: In a video titled “The Neverending Story (and Droste Effect)” on the Numberphile
    YouTube channel, Dr. Clifford Stoll discusses recursion and the Droste’s Cacao
    box art at [https://youtu.be/EeuLDnOupCI](https://youtu.be/EeuLDnOupCI).
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 在Numberphile YouTube频道上名为“The Neverending Story (and Droste Effect)”的视频中，Clifford
    Stoll博士讨论了递归和Droste的Cacao盒子艺术[https://youtu.be/EeuLDnOupCI](https://youtu.be/EeuLDnOupCI)。
- en: Chapter 19 of my book *Automate the Boring Stuff with Python*, 2nd edition (No
    Starch Press, 2019) provides a basic tutorial of the Pillow library at [https://automatetheboringstuff.com/2e/chapter19](https://automatetheboringstuff.com/2e/chapter19).``
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 我的书《Automate the Boring Stuff with Python》第二版（No Starch Press，2019）的第19章提供了Pillow库的基本教程[https://automatetheboringstuff.com/2e/chapter19](https://automatetheboringstuff.com/2e/chapter19)。

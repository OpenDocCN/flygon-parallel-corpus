- en: Why Relay and GraphQL?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, you learned about the architectural principles of
    Flux. In particular, you used the Redux library to implement concrete Flux concepts
    in a React application. Having a framework of patterns like Flux in place, to
    help you reason about how state changes and flows through your application, is
    a good thing. At the end of the chapter, you learned about the potential limitations
    in terms of scale.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to walk you through yet another approach to handling
    state in a React application. Like Redux, Relay is used with both web and mobile
    React applications. Relay relies on a language called **GraphQL** used to fetch
    resources and to mutate those resources.
  prefs: []
  type: TYPE_NORMAL
- en: The premise of Relay is that it can be scaled in ways that Redux and other approaches
    to handling state are limiting. It does this by eliminating them, and keeping
    the focus on the data requirements of the component.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter of this book, you'll work on a React Native implementation
    of the ever popular **Todo MVC** application.
  prefs: []
  type: TYPE_NORMAL
- en: Yet another approach?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was the exact question I had when I learned of Relay and GraphQL. Then
    I reminded myself that the beauty of React is that it's just the view abstraction
    of the UI; of course there are going to be many approaches to handling data. So,
    the real question is, what makes Relay better or worse than something like Redux?
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, you can think of Relay as an implementation of Flux architecture
    patterns, and you can think of GraphQL as the interface that describes how the
    Flux stores within Relay work. At a more practical level, the value of Relay is
    ease of implementation. For example, with Redux, you have a lot of implementation
    work to do, just to populate the stores with data. This gets verbose over time.
    It's this verbosity that makes Redux difficult to scale beyond a certain point.
  prefs: []
  type: TYPE_NORMAL
- en: It's not the individual data points that are difficult to scale. It's the aggregate
    effect of having lots of fetch requests that end up building very complicated
    stores. Relay changes this by allowing you to declare the data that a given component
    needs and letting Relay figure out the best way to fetch this data and synchronize
    it with the local store.
  prefs: []
  type: TYPE_NORMAL
- en: Is the Relay approach better than Redux and other approaches for handling data
    in React applications? In some respects, yes, it is. Is it perfect? Far from it.
    There is a learning curve involved, and not everyone is able to grok it. It's
    immutable, and parts of it are difficult to use. However, just knowing the premise
    of the Relay approach and seeing it in action is worth your while, even if you
    decide against it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's pick apart some vocabulary.
  prefs: []
  type: TYPE_NORMAL
- en: Verbose vernacular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before I start going into more depth on data dependencies and mutations, I
    think it makes sense for me to throw some general Relay and GraphQL terminology
    definitions out there:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Relay**: A library that manages application data fetching and data mutations
    and provides higher-order components that feed data into our application components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraphQL**: A query language used to specify data requirements and data mutations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data dependency**: An abstract concept that says a given React component
    depends on particular data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query**: A query is the part of a data dependency, expressed in GraphQL syntax
    and executed by an encapsulated Relay mechanism'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragment**: A part of a larger GraphQL query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container**: A Relay React component that passes fetched data into the application
    React component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutation**: A special type of GraphQL query that changes the state of some
    remote resource, and Relay has to figure out how to reflect this change in the
    frontend once it completes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's quickly talk about data dependencies and mutations so that we can look
    at some application code.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative data dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relay uses the term collocation to describe declarative data dependencies that
    live beside the component that uses the data. This means that you don't have to
    go digging around for action creator functions that actually get the component
    data that is scattered across several modules. With collocation, you can see exactly
    what the component needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get a taste of what this looks like. If you want to display the first
    and last name of a user, you need to tell Relay that your component needs this
    data. Then, you can rest assured that the data will always be there for your component.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You have two components here. First, there's the `User` component. This is the
    application component that actually renders the UI elements for the `first` and
    `last` name data. Note that this is just a plain old React component, rendering
    props that are passed to it. With the `UserContainer` component that you've created,
    Relay follows the container pattern that you learned about earlier in this book.
    It's in the `createFragmentContainer()` function that you specify the data dependencies
    that this component needs by passing a fragment of GraphQL syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, don't dwell on the Relay/GraphQL specifics just yet. The idea here
    is to simply illustrate that this is all the code that you need to write to get
    your component the data it needs. The rest is just bootstrapping the Relay query
    mechanism, which you'll see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating application state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relay mutations are the actions that cause side effects in your systems, because
    they change the state of some resource that your UI cares about. What's interesting
    about Relay mutations is that they care about side effects that happen to your
    data as a result of a change in the state of something. For example, if you change
    the name of a user, this will certainly impact a screen that displays the user
    details. But, it could also impact a listing screen that shows several users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what a mutation looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is how Relay is able to determine what might be affected as a side effect
    of performing this mutation. For example, the user might change, but also the
    `viewer.users` collection. You'll see more mutations in action in the following
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL backend and microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything I've covered so far about Relay is stuff that's in the browser. Relay
    needs to send it's GraphQL queries somewhere. For this, you need a GraphQL backend.
    You can implement this using Node.js and a handful of GraphQL libraries. You create
    what's called a schema, describing all the datatypes, queries, and mutations that
    will be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the browser, Relay helps you scale your applications by reducing data-flow
    complexity. You have a means to declare what data is needed, without worrying
    about how it is fetched. It's the schema in the backend that actually needs to
    resolve this data.
  prefs: []
  type: TYPE_NORMAL
- en: This is another scaling problem that GraphQL helps address. Modern web applications
    are composed out of microservices. These are smaller, self-contained API endpoints
    that serve some particular purpose that's smaller than an entire app (hence the
    term micro). It's the job of our application to stitch together these microservices
    and provide the frontend with meaningful data.
  prefs: []
  type: TYPE_NORMAL
- en: Again, you're faced with a scalability issue—how do you maintain a backend that's
    composed out of many microservices without introducing insurmountable complexity?
    This is something that GraphQL types excel at. In the following chapter, you'll
    begin the implementation of your Todo application with the backend GraphQL service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter was to quickly introduce you to the concepts of Relay
    and GraphQL prior to the final chapter of this book, where you're going to implement
    some Relay/GraphQL code.
  prefs: []
  type: TYPE_NORMAL
- en: Relay is yet another approach to the state management problem in React applications.
    It's different in the sense that it reduces the complexities associated with the
    data fetching code that we have to write with other approaches to Flux, such as
    Redux.
  prefs: []
  type: TYPE_NORMAL
- en: The two key aspects of Relay are declarative data dependencies and explicit
    mutation side effect handling. All of this is expressed through GraphQL syntax.
    In order to have a Relay application, you need a GraphQL backend where the data
    schema lives. Now, onto the final chapter, where you'll examine Relay/GraphQL
    concepts in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the difference between Relay and other Flux inspired libraries like Redux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no difference, Relay is just another Flux option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relay is meant for React Native apps, you should stick with Redux for web apps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relay helps scale your Flux architecture by allowing data dependency declarations
    and hiding all of the server communication complexity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Relay simplify the data requirements of React components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By collocating the data dependency queries, you can see exactly what data your
    components use without having to sift through code that does the fetching.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By fetching all of the application data upfront, Relay can then query locally
    for data that each of your components need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By abstracting network calls. GraphQL is optional, you can use straight HTTP
    if you want instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do your React components communicate with the server in a Relay based application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have to implement your own network communication logic. Relay just handles
    getting data to components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relay compiles the GraphQL queries that it finds in your components and handles
    all of the GraphQL server communication for you, including caching optimizations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visit the following link for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/relay/](https://facebook.github.io/relay/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

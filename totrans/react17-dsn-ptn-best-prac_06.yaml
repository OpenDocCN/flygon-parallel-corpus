- en: Exploring Popular Composition Patterns
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to learn how to make components communicate with each other effectively.
    React is powerful because it lets you build complex applications comprising small,
    testable, and maintainable components. Applying this paradigm, you can take control
    of every single part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go through some of the most popular composition patterns
    and tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How components communicate with each other using props and children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container and presentational patterns and how they can make our code more
    maintainable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What **higher-order components** (**HOCs**) are and how, thanks to them, we
    can structure our applications in a better way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the function of the child component pattern is and what its benefits are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code for this chapter in the book's GitHub Repository at [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter04)[.](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter04)
  prefs: []
  type: TYPE_NORMAL
- en: Communicating components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reusing functions is one of our goals as developers, and in the previous chapter,
    we saw how React makes it easy to create reusable components. **Reusable components**  can
    be shared  across  multiple domains of your application to avoid duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Small components with a clean interface  can  be composed together to create
    complex applications that are powerful and maintainable at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Composing React components is pretty straightforward; you just have to include
    them in the render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For example, you can create a  `Profile`  component by simply composing a  `Picture`
    component to display the profile image and a  `UserName`  component to display
    the name and the screen name of the user.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you can produce new parts of the user interface very quickly, writing
    only a few lines of code. Whenever you compose components, as in the  preceding  example,
    you share data between them using  props. Props are the way a parent component
    can pass its data down the tree to every component that needs it (or part of it).
  prefs: []
  type: TYPE_NORMAL
- en: When a component passes some props to another component, it is called the **owner,**
    irrespective of the parent-child relationship between them. For example, in the
    preceding snippet, `Profile` is not the direct parent of `Picture` (the `div`
    tag is), but `Profile` owns `Picture` because it passes down the props to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn about the `children` prop and how to use
    it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Using the children prop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a special prop that can be passed from the owners to the components
    defined inside their render—`children`.
  prefs: []
  type: TYPE_NORMAL
- en: In the React documentation, it is described as  **opaque**  because it is a
    property that does not tell you anything about the value it contains. Subcomponents
    defined inside the render of a parent component usually receive props that are
    passed as attributes of the component itself in JSX, or as a second parameter
    of the  `_jsx`  function. Components can also be defined with nested components
    inside them, and they  can  access those children using the `children` prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we have a  `Button`  component that has a `text` property representing
    the text of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The component can be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And this will render the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, suppose we want to use the same button with the same class name in multiple
    parts of our application, and we also want to be able to display more than a simple
    string. Our UI consists of buttons with text, buttons with text and icons, and
    buttons with text and labels.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, a good solution would be to add multiple parameters to `Button`
    or to create different versions of `Button`, each one with its single specialization,
    for example, `IconButton`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we should realize that `Button`  could just be a wrapper, and we are
    able to render any element inside it and use the  `children`  property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By passing the `children` prop, we are not limited to a simple single text property,
    but we  can  pass any element to `Button`, and it is rendered in place of the  `children`  property.
  prefs: []
  type: TYPE_NORMAL
- en: In this case,  any  element that we wrap inside the  `Button`  component will
    be rendered as a child of the `button` element with `btn` as the class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to render an image inside the button and some text
    wrapped into a `span` tag, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet gets rendered in the browser as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty convenient way to allow components to accept any  `children`  elements
    and wrap those elements inside a predefined parent.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can pass images, labels, and even other React components inside the  `Button`
    component, and they will be rendered as its children. As you can see in the preceding
    example, we defined the `children` property as an array, which means that we can
    pass any number  of  elements as the component's children.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass a single child, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's now explore the container and the presentational pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the container and presentational patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we saw how to take a coupled component and make it reusable
    step by step. Now we will see how to apply a similar pattern to our  components  to
    make them clearer and more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: React components  typically  contain a mix of  *logic*  and  *presentation.*
    By logic, we refer to anything that is unrelated to the UI, such as API calls,
    data manipulation, and event handlers. The presentation is the part inside `render`
    where we create the elements to be displayed on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In React, there are simple and powerful patterns, known as  **container** and
    **presentational**, which we can apply when creating components that help us to  separate  those
    two concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Creating well-defined boundaries between logic and presentation not only makes
    components more reusable, but also provides many other benefits, which you will
    learn about in this section. Again, one of the best ways to learn new concepts
    is by seeing practical examples, so let's delve into some code.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a component that uses geolocation APIs to get the position of
    the user and displays the latitude and longitude on the page in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a  `Geolocation.tsx`  file in our `components` folder and
    define the  `Geolocation`  component using a functional component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define our states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `useEffect` Hook to fire the request to the APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When the browser returns the data, we store the result into the state using
    the following function (place this function before the `useEffect` Hook):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we show the `latitude` and `longitude` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that, during the first `render`, `latitude` and `longitude`
    are  `null`  because we asked the browser for the coordinates when the component
    was mounted. In a real-world component, you might want to display a spinner until
    the data gets returned. To do that, you can use one of the conditional techniques
    we saw in  *Chapter 2, Cleaning Up Your Code.*
  prefs: []
  type: TYPE_NORMAL
- en: Now, this component does not have any problems, and it works as expected. Wouldn't
    it be nice to separate it from the part where the position gets requested and
    loaded to iterate faster on it?
  prefs: []
  type: TYPE_NORMAL
- en: We will use the container and presentational patterns to isolate the presentational
    part. In this pattern, every component is split into two smaller ones, each one
    with its clear responsibilities. The container knows everything about the logic
    of the component and is where the APIs are called. It also deals with data manipulation
    and event handling.
  prefs: []
  type: TYPE_NORMAL
- en: The presentational component is where the UI is defined, and it receives data
    in the form of props from the container. Since the presentational component is
    usually logic-free, we can create it as a functional, stateless component.
  prefs: []
  type: TYPE_NORMAL
- en: There are no rules that say that the presentational component must not have
    a state (for example, it could keep a UI state inside it). In this case, we need
    a component to display the latitude and longitude, so we are going to use a simple
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we should rename our  `Geolocation`  component to  `GeolocationContainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We will also change the filename from  `Geolocation.tsx`  to  `GeolocationContainer.tsx`.
  prefs: []
  type: TYPE_NORMAL
- en: This rule is not strict, but it is a best practice that's widely used in the
    React community to append `Container` to the end of the `Container` component
    name and give the original name to the presentational one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have to change the implementation of `render` and remove all the UI
    parts of it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding snippet, instead of creating the HTML  elements  inside
    the `return` of the container, we just use the presentational one (which we will
    create next), and we pass the state to it. The states are `latitude` and `longitude`,
    which are  `null`  by default, and they contain the real position of the user
    when the browser fires the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file, called  `Geolocation.tsx`, where we define the functional
    component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Functional components are an incredibly elegant way to define UIs. They are
    pure functions that, given a `state`, return the elements of it. In this case,
    our function receives `latitude` and `longitude` from the owner, and it returns
    the markup structure to display it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the components in the browser the first time, the browser will require
    your permission to allow it to know about your location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a4e9f236-5fa4-4679-b7ad-aaa48d69b873.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After you allow the browser to know your location, you will see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fe41afa4-9f4c-467b-8936-75ee2b89713d.png)'
  prefs: []
  type: TYPE_IMG
- en: Following the container and presentational pattern, we created a dumb reusable
    component that we can put in our Style Guide so that we can pass fake coordinates
    to it. If in some other parts of the application we need to display the same data
    structure, we do not have to create a new component; we just wrap this one into
    a new container that, for example, could load the latitude and longitude from
    a different endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, other developers in our team can improve the container that
    uses geolocation by adding some error-handling logic, without affecting its presentation.
    They can even build a temporary presentational component just to display and debug
    data and then replace it with the real presentational component when it is ready.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to work in parallel on the same component is a big win for teams,
    especially for those companies where building interfaces is an iterative process.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is simple but very powerful, and when applied to big applications,
    it can make a difference when it comes to the speed of development and the maintainability
    of the project. On the other hand, applying this pattern without a real reason
    can give us the opposite problem and make the  **code base**  less useful as it
    involves the  creation  of more files and components.
  prefs: []
  type: TYPE_NORMAL
- en: So, we should  think  carefully when we decide that a component has to be refactored
    following the container and presentational patterns. In general, the right path
    to follow is starting with a single component and splitting it only when the logic
    and the presentation become too coupled where they shouldn't be.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we began from a single component, and we realized that we could
    separate the API call from the markup. Deciding what to put in the container and
    what goes into the presentation is not always straightforward; the following points
    should help you make that decision:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the characteristics of container components:'
  prefs: []
  type: TYPE_NORMAL
- en: They are more concerned with behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They render their presentational components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They make API calls and manipulate data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They define event handlers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the characteristics of presentational components:'
  prefs: []
  type: TYPE_NORMAL
- en: They are more concerned with the visual representation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They render the HTML markup (or other components).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They receive data from the parents in the form of props.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are often written as stateless functional components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, these patterns form a really powerful tool that will help you
    to develop your web applications faster. Let's see what HOCs are in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HOCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Functional programming* section of  *Chapter 2, Cleaning Up Your Code*,
    we mentioned the concept of **h****igher-order functions**  (**HOFs**), which
    are functions that, given a function, enhance it with some extra behaviors, returning
    a new one. When we apply the idea of  HOFs to components, we call these **higher-order
    components** (or **HOCs** for brevity).
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s see what `HoC` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: HOCs are functions that take a component as input and return an enhanced one
    as the output.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a very simple example to understand what an enhanced component
    looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose, for whatever reason, you need to attach the same  `className`  property
    to every component. You could go and change all the `render` methods by adding
    the  `className`  property to each of them, or you could write an HOC such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the React community, it is very common to have the prefix `with` for HOCs.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code can be a little difficult to understand initially; let's
    go through it together.
  prefs: []
  type: TYPE_NORMAL
- en: We declare a  `withClassName`  function that takes a  `Component`  and returns
    another function. The returned function is a functional component that receives
    some props and renders the original component. The collected props are spread,
    and a  `className`  property with the `"my-class"`  value is passed to the functional
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why HOCs usually spread the props they receive on the component is
    because they tend to be transparent and only add the new behavior.
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty simple and not very useful, but it should give you a better understanding
    of what HOCs are and what they look like. Let's now see how we can use the  `withClassName`  HOC
    in our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we create a stateless  functional  component that receives the
    class name and applies it to a  `div` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the component directly, we pass it to an HOC, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping our components into the  `withClassName`  function, we ensure that
    it receives the  `className`  property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move on to something more exciting, and let''s create an HOC to
    detect the `InnerWidth`. First of all, we have to create a function that receives
    a `Component`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You may have spotted a pattern in the way HOCs are named. It is a common practice
    to prefix HOCs that provide some information to the components they enhance using
    the  `with`  pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you need to define the `innerWidth` state and the `handleResize` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add the effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the original component gets rendered in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you may note here, we are spreading the props as we saw before, but we are
    also passing the `innerWidth` state.
  prefs: []
  type: TYPE_NORMAL
- en: We are storing the  `innerWidth`  value as a state to achieve the original behavior,
    but we do not pollute the state of the component; we use props instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using props is always a good solution to enforce reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Now, using an HOC and getting the  `innerWidth` value is pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The new React Hooks can easily replace an HOC by creating custom Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a functional component that expects `innerWidth`  as a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We enhance it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we do not pollute any state, and we do not require the component
    to implement any function. This means that the component and the HOC are not coupled,
    and they can both be reused across the application.
  prefs: []
  type: TYPE_NORMAL
- en: Again, using props instead of state lets us make our component dumb so that
    we can use it in our Style Guide, ignoring any complex logic and just passing
    down the props.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, we could create a component for each of the different  `innerWidth`  sizes
    we support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Or consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, by using the HOCs we can pass a component and then return a
    new component with extra functionalities. Some of the most common HOCs are `connect`
    from Redux and `createFragmentContainer` from Relay.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding FunctionAsChild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a pattern that is gaining consensus within the React community, known
    as  `FunctionAsChild`. It is widely used in the popular  `react-motion` library,
    which we will see in  *Chapter 7, Writing Code for the Browser*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main concept is that, instead of passing a child in the form of a component,
    we define a function that can receive parameters from the parent. Let''s see what
    it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `FunctionAsChild`  is a component that has a `children` property
    defined as a function and, instead of being used as a JSX expression, it gets
    called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding component can be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It is as simple as it looks: the children function is fired in the `render`
    method of the parent, and it returns the  `Hello, World!`  text wrapped in a  `div`
    tag, which is displayed on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's delve into a more meaningful example where the parent component passes
    some parameters to the `children` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Name` component that expects a function as `children` and passes
    it the `World` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding component can be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The snippet renders  `Hello, World!`  again, but this time the name has been
    passed by the parent. It should be clear how this pattern works, so let's look
    at the advantages of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: The first benefit is that we can wrap components, passing the variables at runtime
    rather than fixed properties, as we do with HOCs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example is a  `Fetch`  component that loads  some data from an API endpoint
    and returns it to the  `children`  function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Secondly, composing components with this approach does not force `children`  to
    use some predefined prop names. Since the function receives variables, their names
    can be decided by the developers who use the component. That makes the `FunctionAsChild`
    solution more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, the wrapper is highly reusable because it does not make
    any assumptions about `children` it receives—it just expects a function. Due to
    this, the same `FunctionAsChild` component can be used in different parts of the
    application, serving various `children` components.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to compose our reusable components and make
    them communicate effectively. Props are a way to decouple components from each
    other and create a clean and well-defined interface.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we went through some of the most interesting composition patterns in React.
    The first one was the so-called container and the other was the presentational
    pattern. These patterns helped us to separate the logic from the presentation
    and create more specialized components with a single responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to deal with context without needing to couple our components
    to it, thanks to HOCs. Finally, we saw how we could compose components dynamically
    by following the `FunctionAsChild` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about GraphQL and how to create JWT tokens,
    perform a login, and create models with Sequelize.
  prefs: []
  type: TYPE_NORMAL

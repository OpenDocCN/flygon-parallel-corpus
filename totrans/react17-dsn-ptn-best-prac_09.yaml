- en: Writing Code for the Browser
  prefs: []
  type: TYPE_NORMAL
- en: There are some specific operations we can do when we work with React and the
    browser. For example, we can ask our users to enter some information using forms,
    and in this chapter, we will look at how we can apply different techniques to
    deal with forms. We can implement  **uncontrolled  components**  and let the fields
    keep their internal states, or we can use  controlled  ones, where we have full
    control over the state of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will also look at  how  events in React work and how the
    library implements some advanced techniques to give us a consistent interface
    across different browsers. We will look at some interesting solutions that the
    React team has implemented to make the event system very performant.
  prefs: []
  type: TYPE_NORMAL
- en: After events, we will jump into  refs  to look at how we can access the underlying
    DOM nodes in our React components. This represents a powerful feature, but it
    should be used carefully because it breaks some of the conventions that make React
    easy to work with.
  prefs: []
  type: TYPE_NORMAL
- en: After refs, we will look at  how  we can implement animations easily  with the
    React add-ons and third-party libraries such as  `react-motion`. Finally, we will
    learn how easy it is to work with **Scalable Vector Graphics** (**SVG**) in React,
    and how we can create dynamically configurable icons for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using different techniques to create forms with React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to DOM events and implementing custom handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way of performing imperative operations on DOM nodes using refs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating simple animations that work across different browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The React way of generating SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter in the book''s GitHub repository: [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and implementing forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to implement forms with React. As
    soon as we start building a real application with React, we need to interact with
    the users. If we want to ask for information from our users within the browser,
    forms are the most common solution. Due to the way the library works and its declarative
    nature, dealing with input fields and other form elements is non-trivial with
    React, but as soon as we understand its logic, it will become clear. In the next
    sections, we are going to learn how to use uncontrolled and controlled components.
  prefs: []
  type: TYPE_NORMAL
- en: Uncontrolled components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Uncontrolled components are like regular HTML form inputs for which you will
    not be able to manage the value yourself but instead, the DOM will take care of
    handling the value and you can get this value by using a React ref. Let's start
    with a basic example—displaying a  form  with an input field and a Submit button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we run the preceding snippet in the browser, we will see exactly what we
    expect—an input field in which we can write  something  and a clickable button.
    This is an example of an uncontrolled component, where we do not set the value
    of the input field, but we let the component manage its own internal state.
  prefs: []
  type: TYPE_NORMAL
- en: Most likely, we want to do something with the value of the element when the
    Submit button is clicked. For example, we may want to send the data to an API
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this easily by adding an  `onChange`  listener (we will talk more
    about event listeners later in this chapter). Let's look at what it means to add
    a listener.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create the `handleChange` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The event listener is receiving an event object, where the  target  represents
    the field that generated the event, and we are interested in its value. We start
    by just logging it because it is important to proceed with small steps, but we
    will store the value into the state soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we render the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we render the component inside the browser and type the word `React` into
    the form field, we will see something like the following inside the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `handleChange` listener is fired every time the value of the input changes.
    Therefore, our function is called once for each typed character. The next step
    is to store the value that's entered by the user and make it available when the
    user clicks the Submit button.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just have to change the implementation of the handler to store it in the
    state instead of logging it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Getting notified of when the form is submitted is very similar to listening
    to the change event of the input field; they are both events that are called by
    the browser when something happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the  `handleSubmit`  function, where we just log the value. In
    a real-world scenario, you could send the data to an API endpoint or pass it to
    another component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This handler is pretty straightforward; we just log the value currently stored
    in the state. We also want to overcome the default behavior of the browser when
    the form is submitted, to perform a custom action. This seems reasonable, and
    it works very well for a single field. The question now is, what if we have multiple
    fields? Suppose we have tens of different fields?
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a basic example, where we create each field and  handler  manually  and
    look at how we can improve it by applying different levels of optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new form with first and last name fields. We can reuse the
    `Uncontrolled` component and add some new states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We initialize the two fields inside the state and we define an event handler
    for each one of the fields as well. As you may have noticed, this does not scale
    very well when there are lots of fields, but it is important to understand the
    problem clearly  before moving to a more flexible solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we implement the new handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to change the submit handler a little bit so that it displays
    the first and the last name when it gets clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we render the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to go: if we run the preceding component in the browser, we will
    see two fields, and if we type  `Carlos`  into the first one and  `Santana`  into
    the second one, we will see the full name displayed in the browser console when
    the form is submitted.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, this works fine, and we can do some interesting things this way, but
    it does not handle complex scenarios without requiring us to write a lot of boilerplate
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can optimize it a little bit. Our goal is to use a single
    change  handler  so that we can add an arbitrary number of fields without creating
    new listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the component and let''s change our states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We may still want to initialize the values, and later in this section, we will
    look at how to provide prefilled values for the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the interesting bit is the way in which we can modify the  `onChange`  handler
    implementation to make it work  in different fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen previously, the `target` property of the event we receive represents
    the input field that has fired the event, so we can use the name of the field
    and its value as variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have to set the name for each field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We can now add as many fields as we want without creating additional
    handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Controlled components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A controlled component is a React component that controls the values of input
    elements in a form by using the component state.
  prefs: []
  type: TYPE_NORMAL
- en: Here we are going to  look  at how we can prefill the form fields with some
    values, which we may receive from the server or as props from the parent. To understand
    this concept  fully, we will start again from a very simple stateless function
    component, and we will improve it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example shows a predefined value inside the input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we run this component inside the browser, we realize that it shows the default
    value as expected, but it does not let us change the value or type anything else
    inside it.
  prefs: []
  type: TYPE_NORMAL
- en: The reason it does this is  that  in React, we declare what we want to see on
    the screen, and setting a fixed-value attribute always results in rendering that
    value, no matter what other actions are taken. This is unlikely to be a behavior
    we want in a real-world application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the console, we get the following error message. React itself is
    telling us that we are doing something wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we just want the input field to have a  default  value and we want
    to be able to change it by typing, we can use the  `defaultValue`  property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, the field is going to show `Hello React` when it is rendered,
    but then the user can type anything inside it and change its value. Now let''s
    add some states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The handlers are the same as the previous ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, we will use the `value` attributes of the input fields to set their
    initial values, as well as the updated one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first time the form is rendered, React uses the initial values from the
    state as the value of the input fields. When the user types something into the
    field, the `handleChange` function is called and the new value for the field is
    stored  in  the state.
  prefs: []
  type: TYPE_NORMAL
- en: When the state changes, React re-renders the component and uses it again to
    reflect the current values of the input fields. We now have full control over
    the values of the fields, and  we  call this pattern  **controlled components**.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to work with events, which are a fundamental
    part of React to handle data coming from forms.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Events**  work in a slightly different  way  across various browsers. React
    tries to abstract the way events work and give developers a consistent interface
    to deal with. This is a great feature of React because we can forget about the
    browsers we are targeting and write event handlers and functions that are vendor-agnostic.'
  prefs: []
  type: TYPE_NORMAL
- en: To offer this feature, React introduced the concept of the **synthetic event**.
    A synthetic event is an object that wraps the original event object provided by
    the browser, and it has the same properties, no matter where it is created.
  prefs: []
  type: TYPE_NORMAL
- en: To attach an event listener to a node and get the event object when the event
    is fired, we can use a simple convention that recalls the way events are attached
    to the DOM nodes. In fact, we can use the word  `on`  plus the camelCased event
    name (for example,  `onKeyDown`) to define the callback to be fired when the events
    happen. A popular convention is to name the event handler functions after the
    event name and prefix them using  `handle`  (for example,  `handleKeyDown`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen this pattern in action in the previous examples, where we were
    listening to the  `onChange`  event of the form fields. Let''s reiterate a basic
    event listener example to see how we can organize multiple events inside the same
    component in a nicer way. We are going to implement a simple button, and we start,
    as usual, by creating a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see here, we are doing a very simple thing: we just check the type
    of the event object we receive from React and the type of native event attached
    to it. We expect the first to return  `false`  and the second to return  `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should never need to access the  original  native event, but it is good
    to know you can do it if you need to. Finally, we define the button with the  `onClick`  attribute
    to which we attach our event listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we want to attach a second handler to the button that listens
    to the double-click event. One solution would be to create a new separate handler
    and attach it to the button using the `onDoubleClick` attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we always aim to write less boilerplate and avoid duplicating
    code. For that reason, a common practice is to write a  **single event handler**  for
    each component, which can  trigger  different actions according to the event type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is described in a collection of  patterns  by Michael Chan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://reactpatterns.com/#event-switch](http://reactpatterns.com/#event-switch).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the generic event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The generic event handler receives the event object and switches on the event
    type to fire the right action. This is particularly useful if we want to call
    a function on each event (for example, analytics) or if some events share the
    same logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we attach the new event listener to the `onClick` and `onDoubleClick`
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: From this point on, whenever we need to create a new event handler for the same
    component, instead of creating a new method and binding it, we can just add a
    new case to the switch.
  prefs: []
  type: TYPE_NORMAL
- en: A couple more interesting things to know about events in  React  are that synthetic
    events are reused and that there is a  **single global handler**. The first concept
    means that we cannot store a synthetic event and reuse it later because it becomes
    null right after the action. This technique is very good in terms of performance,
    but it can be problematic if we want to store the event inside the state of the
    component for some reason. To solve this problem, React gives us a  `persist`  method
    on the synthetic events, which we can call to make the event persistent so that
    we can store it and retrieve it later.
  prefs: []
  type: TYPE_NORMAL
- en: The second very interesting implementation detail is again about performance,
    and it is to do with the way React attaches the event handlers to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we use the `on` attribute, we are describing to  React  the behavior
    we want to achieve, but the library does not attach the actual event handler to
    the underlying DOM nodes.
  prefs: []
  type: TYPE_NORMAL
- en: What it does instead attaches a single event handler to the  root  element,
    which listens to all the events, thanks to  **event bubbling**. When an event
    we are interested in is fired by the browser, React calls the handler on the specific
    components on its behalf. This technique is called  **event delegation**  and
    is used for  memory  and speed optimization.
  prefs: []
  type: TYPE_NORMAL
- en: In our next section, we are going to explore React refs and see how we can take
    advantage of them.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring refs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the reasons people love  React  is that it is declarative. Being declarative
    means that you just describe what you want to be displayed on the screen at any
    point in time and React takes care of the communications with the browser. This
    feature makes React very easy to reason about and very powerful at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: However, there might be some cases where you need to access the underlying DOM
    nodes to perform some imperative operations. This should be avoided because, in
    most cases, there is a more React-compliant solution to achieve the same result,
    but it is important to know that we have the option to do it and to know how it
    works so that we can make the right decision.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to create a simple form with an input element and a button,
    and we want it to behave in such a way that when the button is clicked, the input
    field gets focused. What we want to do is call the  `focus`  method on the input
    node, the actual DOM instance of the input, inside the browser's window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a component called `Focus`; you need to import `useRef` and create
    an `inputRef` constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we implement the `handleClick` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are referencing the `current` attribute of `inputRef` and
    calling the `focus` method on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand where it comes from, you just have to check the implementation
    of `render`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here comes the core of the logic. We create a form with an input element inside
    it and we define a function on its `ref` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The callback we defined is called when the component gets mounted, and the element
    parameter represents the DOM instance of the input. It is important to know that,
    when the component gets unmounted, the same callback is called with a `null` parameter
    to free the memory.
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing in the callback is storing the reference of the element to
    be able to use it in the future (for example, when the `handleClick` method is
    fired). Then, we have the button with its event handler. Running the preceding
    code in a browser will show the form with the field and the button, and clicking
    on the button will focus the input field, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, in general, we should try to avoid using refs because
    they force the code to be more imperative, and they become harder to read and
    maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When  we  think about UIs and the browser, we must surely think about animations
    as well. Animated UIs are more pleasant for users, and they are a very important
    tool to show users that something has happened or is about to occur.
  prefs: []
  type: TYPE_NORMAL
- en: This section does not aim to be an exhaustive guide to creating animations and
    beautiful UIs; the goal here is to provide you with some basic information about
    the common solutions we can put in place to animate our React components.
  prefs: []
  type: TYPE_NORMAL
- en: For a UI library such as React, it is crucial to provide an easy way for developers
    to create and manage animations. React comes with an add-on, called  `react-addons-css-transition-group`,
    which is a component that helps us build animations in a declarative way. Again,
    being able to perform operations declaratively is incredibly powerful, and it
    makes the code much easier to reason about and share with the team.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to apply a simple fade-in effect to text with the React add-on,
    and then  we  will perform the same operation using  `react-motion`, a third-party
    library that makes creating complex animations even easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do to start building an animated component is to
    install the add-on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have done that, we can import the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we just wrap the component to which we want to apply the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are some props that need explaining.
  prefs: []
  type: TYPE_NORMAL
- en: First, we are declaring the `transitionName` prop. `ReactCSSTransitionGroup`  applies
    a class with the name of that property to the child element so that we can then
    use CSS transitions to create our animations.
  prefs: []
  type: TYPE_NORMAL
- en: With a single class, we cannot easily create a proper animation, and that is
    why the transition group applies multiple classes according to the state of the
    animation. In this case, with the  `transitionAppear`  prop, we are telling the
    component that we want to animate the children when they appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: So, what the library does is apply the  `fade-appear`  class (where  `fade`  is
    the value of the  `transitionName`  prop) to the component as soon as it gets
    rendered. On the next tick, the  `fade-appear-active` class is applied so that  we  can
    fire our animation from the initial state to the new one, using CSS.
  prefs: []
  type: TYPE_NORMAL
- en: We also have to set the  `transitionAppearTimeout`  property to tell  React  the
    length of the animation so that it doesn't remove elements from the DOM before
    animations are completed.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS to make an element fade-in is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the opacity of the element in the initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define our transition using the second class, which starts as soon
    as it gets applied to the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We are transitioning the opacity from  `0.01`  to  `1`  in  `500ms`  using the
    `ease-in` function. This is pretty easy, but we can create more complex animations,
    and we can also animate different states of the component. For example, the  `*-enter`  and  `*-enter-active`  classes
    are applied when a new element is added as a child of the transition group. A
    similar thing applies to  remove  elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our next section, we are going to check out the most popular library to
    create animations in React:  `react-motion`, which is maintained by Cheng Lou.
    It provides a very clean and easy-to-use API that gives us a very powerful tool
    to create any animations.'
  prefs: []
  type: TYPE_NORMAL
- en: React Motion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**React Motion** is an animation library for React applications that make it
    easy to create and implement realistic animations. As soon as the complexity of
    the animations grows, or when  we  need animations that depend on other animations,
    or when we need to apply some physics-based behavior to our components (which
    is a bit more advanced), we will realize that the transition group is not helping
    us enough, so we may consider using a third-party library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, we first have to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is successfully completed, we need to import the `Motion`
    component and the `spring` function. `Motion` is the component we will use to
    wrap the elements we want to animate, while the function is a utility that can
    interpolate a value from its initial state to the final one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of interesting things here. First, you may have noticed that
    this component uses the function as a child pattern (see  *Chapter 4,* *Exploring
    Popular Composition Patterns*), which is a pretty powerful technique to define
    children that receive values at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can see that the  `Motion`  component has two attributes: the first
    one is  `defaultStyle`, which represents the initial `style` attribute. Again,
    we set the opacity to  `0.0.1`  to hide the element and start the fade.'
  prefs: []
  type: TYPE_NORMAL
- en: The `style` attribute represents the final style instead, but we do not set
    the value directly; instead, we use the `spring` function so that the value is
    interpolated from the initial state to the final one.
  prefs: []
  type: TYPE_NORMAL
- en: On each iteration of the `spring` function, the child function receives the
    interpolated style for the given point in time and, just by applying the received
    object to the `style` attribute of the component, we can see the transition of
    the opacity.
  prefs: []
  type: TYPE_NORMAL
- en: This library can do some more cool stuff, but the first things to learn about
    are the basic concepts, and this example should clarify them.
  prefs: []
  type: TYPE_NORMAL
- en: It is also interesting to compare the two different approaches of the transition
    group and `react-motion` to be able to choose the right one for the project you
    are working on.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in our next section, we are going to see how we can work with SVG in
    React.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last but not least, one of the most interesting techniques we can  apply  in
    the browser to draw icons and graphs is  **Scalable Vector Graphics**  (**SVG**).
  prefs: []
  type: TYPE_NORMAL
- en: SVG is  great  because it is a declarative way of describing vectors and it
    fits perfectly with the purposes of React. We used to use icon fonts to create
    icons, but they have well-known problems, with the first being that they are not
    accessible. It is also pretty hard to position icon fonts with CSS, and they do
    not always look beautiful in all browsers. These are the reasons we should prefer
    SVG for our web applications.
  prefs: []
  type: TYPE_NORMAL
- en: From a React point of view, it does not make any difference if we output a  `div`  or
    an SVG element from the `render` method, and this is what makes it so powerful.
    We also tend to choose SVG because we can easily modify them at runtime using
    CSS and JavaScript, which makes them an excellent candidate for the functional
    approach of React.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we think about our components as a function of their props, we can easily
    imagine how we can create self-contained SVG icons that we can manipulate by passing
    different props to them. A common way to create SVG in a web app with React is
    to wrap our vectors into a React component and use the props to define their dynamic
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example where we draw a blue circle, thus creating
    a React component that wraps an SVG element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can easily use a stateless functional component that wraps
    the SVG markup, and it accepts the same props as SVG does.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can obviously use the full power of React and set some default parameters
    so that, if the circle icon is rendered without props, we still show something.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can define the default color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty powerful when we build UIs, especially in a team where we share
    our icon set and we want to have some default values in it, but we also want to
    let other teams decide their settings without having to recreate the same SVG
    shapes.
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases, we prefer to be more strict and fix some values to keep
    consistency. With React, this is a super simple task.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can wrap the base circle component into `RedCircle`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, the color is set by default and it cannot be changed, while the other
    props are transparently passed to the original circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows two circles, blue and red, that are generated
    by React using SVG:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/024940fd-bb15-47bd-8457-f738b7cd573a.png)'
  prefs: []
  type: TYPE_IMG
- en: We can apply this technique and create different variations of the circle, such
    as `SmallCircle` and `RightCircle`, and everything else we need to build our UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the different things we can do when we target
    the browser with React, from form creation to events, and animations to SVG. Also,
    we learned how to use the new `useRef` Hook. React gives us a declarative way
    to manage all the aspects we need to deal with when we create a web application.
  prefs: []
  type: TYPE_NORMAL
- en: In case we need it, React gives us access to the actual DOM nodes in a way that
    means we can perform imperative operations with them, which is useful if we need
    to integrate React with an existing imperative library.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be about CSS and inline styles, and it will clarify what
    it means to write CSS in JavaScript.
  prefs: []
  type: TYPE_NORMAL

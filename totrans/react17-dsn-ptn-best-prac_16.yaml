- en: Anti-Patterns to Be Avoided
  prefs: []
  type: TYPE_NORMAL
- en: In this book, you've learned how to apply best practices when writing a React
    application. In the first few chapters, we revisited the basic concepts to build
    a solid understanding, and then we took a leap into more advanced techniques in
    the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to build reusable components, make components communicate
    with each other, and optimize an application tree to get the best performance.
    However, developers make mistakes, and this chapter is all about the common anti-patterns
    we should avoid when using React.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at common errors will help you to avoid them and will aid your understanding
    of how React works and how to build applications in the React way. For each problem,
    we will see an example that shows how to reproduce and solve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the state using properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using indexes as a key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spreading properties on DOM elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter in the book''s GitHub repository: [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter13).'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the state using properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how initializing the state using properties received
    from the parent is usually an anti-pattern. I have used the word *usually*because,
    as we will see, once we have it clear in our mind what the problems with this
    approach are, we might still decide to use it.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best ways to learn something is by looking at the code, so we will
    start by creating a simple component with a  `+`  button to increment a counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component is implemented using a  class, as shown in the following snippet
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s set our `count` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the click handler is pretty straightforward – we just
    add `1` to the current `count` value and store the resulting value back in `state`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we render and describe the output, which is composed of the current
    value of the `count` state, and the button to increment it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s render this component, passing `1` as the `count` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It works as expected – each click on the  *+*  button increments the current
    value. So, what's the problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main errors, which are outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a duplicated source of truth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `count` property passed to the component changes, the state does not
    get updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we inspect the `Counter` element using the React DevTools, we notice that
    `Props` and `State` hold a similar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This makes it unclear which is the current and trustworthy  value to use inside
    the component and to display to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even worse, clicking  *+*  once makes the values diverge. An example of this
    divergence is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can assume that the second value represents the current count,
    but this is not explicit and can lead to unexpected behaviors, or wrong values
    down in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem centers on how the class is created and instantiated by React.
    The `useState` function of the component gets called only once when the component
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: In our  `Counter`  component, we read the value of the  `count`  property and
    we store it in the state. If the value of that property changes during the life
    cycle of the application (let's say it becomes  `10`), the  `Counter`  component
    will never use the new value, because it has already been initialized. This puts
    the component in an inconsistent state, which is not optimal and hard to debug.
  prefs: []
  type: TYPE_NORMAL
- en: What if we really want to use the prop's value to initialize the component,
    and we know for sure that the value does not change in the future?
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, it''s best practice to make it explicit and give the property
    a name that makes your intentions clear, such as `initialCount`. For example,
    let''s say we change the prop declaration of the `Counter` component in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use it like so, it is clear that the parent only has a way to initialize
    the counter, but any future values of the `initialCount` property will be ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In our next section, we are going to learn about keys.
  prefs: []
  type: TYPE_NORMAL
- en: Using indexes as a key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 10*,  *Improving the Performance of Your Applications*, which talks
    about performance and the reconciler, we saw how we can help React figure out
    the shortest path to update the DOM by using the  `key`  prop.
  prefs: []
  type: TYPE_NORMAL
- en: The key property uniquely identifies an element in the DOM, and React uses it
    to check whether the element is new or whether it has to be updated when the component
    properties or state change.
  prefs: []
  type: TYPE_NORMAL
- en: Using keys is always a good idea and if you don't do it, React gives a warning
    in the console (in development mode). However, it is not simply a matter of using
    a key; sometimes, the value that we decide to use as a key can make a difference.
    In fact, using the wrong key can give us unexpected behaviors in some instances.
    In this section, we will see one of those instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s again create a  `List`  component, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define our state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the click handler is slightly different from the previous
    one because in this case, we need to insert a new item at the top of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in `render`, we show the list and the `+` button to add the `baz`
    item at the top of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you run the component inside the browser, you will not see any problems;
    clicking the  `+`  button inserts a new item at the top of the list. But let's
    do an experiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change `render` in the following way, adding an input field near each
    item. We then use an input field because we can edit its content, making it easier
    to figure out the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we run this component again in the browser, copy the values of the items
    in the input fields, and then click  *+*, we will get  unexpected  behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, the items shift down while the input
    elements remain in the same position, in such a way that their value does not
    match the value of the items anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d059f66-fb4c-4ab6-a9bf-feae211546f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the component, clicking +, and checking the console should give us all
    the answers we need.
  prefs: []
  type: TYPE_NORMAL
- en: What we can see is that React, instead of inserting the new element on top,
    swaps the text of the two existing elements, and inserts the last item at the
    bottom as if it was new. The reason it does that is that we  are using the index
    of the `map` function as the key.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the index always starts from  `0`, even if we push a new item to the
    top of the list, so React thinks that we changed the values of the existing two,
    and added a new element at index  `2`. The behavior is the same as it would have
    been without using the key property at all.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very common pattern because we may think that providing any key is
    always the best solution, but it is not like that at all. The key has to be unique
    and stable, identifying one, and only one, item.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, we can, for example, use the value of the item if we
    expect it not to be repeated within the list, or create a unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Spreading properties on DOM elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a common practice that has recently been described as an anti-pattern
    by Dan Abramov;it also triggers a warning in the console when you do it in your
    React application.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a technique that is widely used in the community and I have personally
    seen it multiple times in real-world projects. We usually spread the properties
    to the elements to avoid writing every single one manually, which is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This works very well and it gets transpiled into the following code by Babel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: However, when we spread properties into a DOM element, we run the risk of adding
    unknown HTML attributes, which is bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is not related only to the spread operator; passing non-standard
    properties one by one leads to the same issues and warnings. Since the spread
    operator  hides  the single properties we are spreading, it is even harder to
    figure out what we are passing to the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the warning in the console, a basic operation we can do is render the
    following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The message we get looks like the following because the `foo` property is not
    valid for a `div` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, as we said, it is easy to figure out which attribute we are passing
    and remove it, but if we use the spread operator, as in the following example,
    we cannot control which properties are passed from the parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use the component in the following way, there are no issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This, however, is not the case if we do something such as the following. React
    complains because we are applying a non-standard attribute to the DOM element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: One solution we can use to solve this problem is to create a property called  `domProps`  that
    we can spread safely to the component because we are explicitly saying that it
    contains valid DOM properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can  change the  `Spread`  component in the following  way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen many times with React, it's always good practice to be explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing all the best practices is always a good thing, but sometimes being aware
    of anti-patterns helps us avoid taking the wrong path. Most importantly, learning
    the reasons why some techniques are considered bad practice helps us understand
    how React works, and how we can use it effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered four different ways of using components that can
    harm the performance and behavior of our web applications.
  prefs: []
  type: TYPE_NORMAL
- en: For each one of those, we used an example to reproduce the problem and supplied
    the changes to apply in order to fix the issue.
  prefs: []
  type: TYPE_NORMAL
- en: We learned why using properties to initialize the state can result in inconsistencies
    between the state and the properties. We also saw how using the wrong key attribute
    can produce bad effects on the reconciliation algorithm. Finally, we learned why
    spreading non-standard properties to DOM elements is considered an anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into deploying our React application to production.
  prefs: []
  type: TYPE_NORMAL

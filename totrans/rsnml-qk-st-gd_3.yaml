- en: Creating ReasonReact Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve set up our development environment, we''re ready to get started
    with ReasonReact—the future of ReactJS. Both ReasonML and ReasonReact were built
    by the same person who built ReactJS. ReasonReact is just Reason, much like how
    ReactJS is just JavaScript. Throughout the rest of this book, we will be working
    with an application that we will start building in this chapter. The following
    are screenshots of what we''ll have built by the end of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b88262e1-bf4b-4508-aa96-84b090a76664.png)'
  prefs: []
  type: TYPE_IMG
- en: To follow along, clone this book's GitHub repository and start from `Chapter03/start`.
    Throughout the rest of this book, each directory shares the same development environment
    as the one we set up at the end of [Chapter 2](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml),
    *Setting Up a Development Environm**ent*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We'll first explore ReasonReact, and at about halfway through this chapter,
    we'll shift to the `Chapter03/app-start` directory, where we'll start building
    an application with ReasonReact's built-in router.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore creating stateless and stateful ReasonReact components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an application that includes navigation and routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how so many of the ReactJS concepts you're already familiar with map nicely
    to ReasonReact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how ReasonReact can help us create more robust components thanks to Reason's
    type system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component creation basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by analyzing a simple stateless component. In `App.re`, let''s
    render a `<div />` element with some text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And in `Index.re`, render the component to a DOM element with an ID of `"root"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Due to Reason's module system, we do not need an `import` statement in `Index.re` nor
    an export statement in `App.re`. Every Reason file is a module, and every Reason
    module is globally available. Later in this book, we will see how a module's implementation
    details can be hidden so that users of your component only access things they
    are supposed to access.
  prefs: []
  type: TYPE_NORMAL
- en: Component templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In ReasonReact, all components are created with one of the following four functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReasonReact.statelessComponent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReasonReact.statelessComponentWithRetainedProps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReasonReact.reducerComponent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReasonReact.reducerComponentWithRetainedProps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of the four functions accepts a `string` and returns a `record` corresponding
    to a different component template. The `string` argument is only for debugging
    purposes. The component gets its name (`<App />`) from its filename (`App.re`).
    The fields the returned record contains are dependent on which of the functions
    was used. In the case of our previous example, we have the following fields that
    we can override:'
  prefs: []
  type: TYPE_NORMAL
- en: '`render`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`didMount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`willReceiveProps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shouldUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`willUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`didUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`willUnmount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aside from the `render` field, the rest are just familiar ReactJS life cycle
    events. To override a field, add that field within the `make` function's returned
    `record`. In the preceding example, the component template's `render` field was
    replaced with the custom `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `make` function accepts `props` as arguments, and returns a `record` of
    the same shape as the one that was initially created by one of the four component
    creation functions. The last argument to the `make` function must be the `children` prop.
    You may have noticed that `children` is prefixed with an `_` in the preceding
    example. If your component does not need a reference to the children prop, then
    prefixing the argument with an `_` prevents a compiler warning for the unused
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: It may not appear immediately obvious, but the `make` function's curly braces
    belong to the returned `record` literal. The `...component` expression spreads
    the contents of the original `record` in this new `record` so that individual
    fields can be overridden without having to explicitly set each field.
  prefs: []
  type: TYPE_NORMAL
- en: self
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `render` field holds a callback function that accepts an argument called
    `self`, and returns a value of type `ReasonReact.reactElement`. The three fields
    of the `self` record are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`state`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`send`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By choice, ReasonReact does not have the concept of JavaScript's `this`. Instead,
    `self` holds the necessary information and is provided to callbacks that need
    it. We'll see more of `self` when using stateful components.
  prefs: []
  type: TYPE_NORMAL
- en: Event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our render function, we can attach event listeners to DOM elements the same
    way that we would in ReactJS. For example, to listen for the click event, we add
    an `onClick` attribute and set its value to an event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, this callback function must accept exactly one argument (corresponding
    to a JavaScript DOM event) and mustreturn a type called `unit`.
  prefs: []
  type: TYPE_NORMAL
- en: unit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Reason, `unit` is a type that means "nothing." A function whose return type
    is `unit` cannot return anything other than `unit`. There is exactly one value
    of type `unit`: `()` (that is, a pair of empty parentheses, which is also called
    `unit`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, there are exactly two values of type `bool`: `true` and `false`.
    There are an infinite number of values of type `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](75c7a9ae-b7e6-4ba7-97d0-eaa5cad2967c.xhtml), *Introduction to
    ReasonML*, the idiomatic way to represent a nullable value in Reason is with the
    `option` type. The major difference between the `option` type and the `unit` type
    is that a value of type `option` could be nothing, or it could be some value where
    as a value of type `unit` is always `()`.
  prefs: []
  type: TYPE_NORMAL
- en: A function that accepts and/or returns `unit` likely causes side effects. For
    example, `Js.log` is a function that returns `unit`. The `onClick` event handler
    is also a function that returns `unit`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Random.bool` is an example of a function that accepts `unit` as its argument
    and returns a `bool`. The syntax for calling a function with `unit` is quite familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `onClick` needs a function that returns `unit`, the following will result
    in a type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The type error is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the error message, `This expression` refers to `42`.
  prefs: []
  type: TYPE_NORMAL
- en: JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reason comes with the JSX syntax. One difference in ReasonReact''s version
    of JSX is that we cannot do the following in ReasonReact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we need to convert the `string` to a `ReasonReact.reactElement` with
    the `ReasonReact.string` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this still doesn''t work. We need to also wrap the expression with
    `{ }` to help the parser differentiate between multiple possible children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re free to create an alias that is less verbose and use that instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When a custom component is invoked in JSX, its `make` function is called. The `<App
    />` syntax desugars to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When a component will receive new props, its `make` function will again be called
    with the new props as arguments. The `make` function is like a combination of
    ReactJS's `constructor` and ReactJS's `componentWillReceiveProps`.
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a few props to our `<App />` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling, we get a compiler error, because in `Index.re` we aren''t
    providing the required `greeting` and `name` props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`greeting` and `name` are **labelled arguments** of the `make` function, meaning
    that they can be provided in any order. To convert an argument to a labelled argument,
    prefix it with a tilde (`~`). Reason also supports optional arguments as well
    as arguments with defaults. Let''s give `greeting` a default value and make `name`
    optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since `name` is an optional argument, it's wrapped in an `option` type, and
    we can then pattern match on its value. Of course, this is just a long-winded
    way of providing `name` with a default argument of `""`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our example compiles even if `<App />` isn''t provided with any props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we then decide to remove the name prop, the compiler will tell us where we
    need to update the usage of `<App />`. This gives us the freedom to refactor our
    components without worrying about forgetting to update an area of our codebase.
    The compiler has our back!
  prefs: []
  type: TYPE_NORMAL
- en: Children
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last argument to the `make` function is always the `children` prop—it's
    mandatory. Just like other props, children can be any data structure. As long
    as the component allows it, we can use the render prop pattern that is popular
    in ReactJS. Importantly, ReasonReact always wraps children in an array, so we
    need to unwrap the array with the `...` syntax if we don't want this wrapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `App.re`, we''ll remove all props except for the required `children` prop.
    In the render function, we invoke children with our hardcoded greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And in `Index.re`, we add a function as a child of `<App />` that accepts the
    provided greeting and returns JSX (which is of type `ReasonReact.reactElement`).
    Notice the `...` syntax used to unwrap the array that all ReasonReact children
    are wrapped with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we forget the `...`, the compiler will kindly let us know:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We'll even get a similar compiler message if we don't include any children (that
    is, just `<App />`), since that translates into an empty array. This means that
    we're guaranteed that users of our component have to provide a function of type
    `string => ReasonReact.reactElement` as a child of `<App />` if it's going to
    type check.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also mandate that our component accepts other children types, for example,
    a tuple of two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Reason is able to infer that children must be a tuple of type `(string, string)`
    because of its use in `App.re`. For example, consider the following usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will result in a friendly compiler error because the `App` component requires
    its children to be a tuple but the `App` component's children is not a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is incredibly powerful. Since we get these guarantees at compile time,
    we don't have to worry about runtime checks on the shape of our component's children.
    Similarly, we are guaranteed that props type check at compile time. Refactoring
    components is much less stressful because the compiler guides us along the way.
    What's more, thanks to Reason's powerful type inference, we haven't had to explicitly
    annotate any types so far.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ReasonReact supports the familiar ReactJS life cycle events. We will get a
    closer look at some of the life cycle events as we build our app, but, for now,
    let''s see how we can implement ReactJS''s `componentDidMount` life cycle hook
    for `<App />`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Instead of `componentDidMount`, we use `didMount`. Again, `didMount` is just
    a field within a record returned by the component's `make` function. The type
    of `didMount` is `self => unit`, which is a function that accepts `self` and returns
    `unit`. Since it returns `unit`, it's likely that `didMount` causes a side effect,
    and in our example it does. Running this in the browser results in `mounted` logged
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Subscriptions helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make writing cleanup code more convenient and easier to remember, ReasonReact
    provides `self.onUnmount`, which can be used directly within a component''s `didMount`
    life cycle (or anywhere that has access to `self`). This allows you to write the
    cleanup code alongside its complement instead of separately, within `willUnmount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Stateful components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've only used the `ReasonReact.statelessComponent` template. To create
    a stateful component, we switch out the component template to `ReasonReact.reducerComponent`
    and override some additional fields within the record returned by its `make` function.
    As we'll soon see, we'll also need to declare custom type definitions for use
    in these additional fields. It's called `reducerComponent` because it has the
    concept of state, actions, and reducers built in—just like Redux, except state,
    actions, and reducers are local to the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple counter component with buttons to increment and decrement the current
    count is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The ReactJS Fragment syntax (`<>` and `</>`) is used here to wrap the `<button>`
    and `<span>` elements without adding an unnecessary DOM node.
  prefs: []
  type: TYPE_NORMAL
- en: State, action, and reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s break this down. At the top of the file, we see two type declarations,
    one for state and one for actions. The names `state` and `action` are a convention,
    but you can use any name you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as in Redux, events trigger actions that are sent to a reducer that then
    updates state. Next, the button''s click event triggers a `Decrement` action that
    gets sent to the component''s reducer via `self.send`. Remember, the render function
    is provided `self` as its argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `state` type declaration defines the shape of our state. In this case,
    our state is just an integer that holds the component''s current count. The component''s
    initial state is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`initialState` requires a function of type `unit => state`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When triggered by an action, the reducer function accepts that action as well
    as the current state, and returns a new state. Pattern matching is used on the
    current action, and `ReasonReact.Update` is used to return a new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To help keep your ReasonReact apps ready for the coming ReactJS Fiber release,
    ensure that everything in `reducer` is pure. One way to trigger side effects indirectly
    while keeping `reducer` pure is by using `ReasonReact.UpdateWithSideEffects`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value of `reducer` must be one of the following variant constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReasonReact.NoUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReasonReact.Update(state)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReasonReact.SideEffects(self => unit)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReasonReact.UpdateWithSideEffects(state, self => unit)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can trigger new actions from within our side effects, since we''re again
    provided with `self`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After incrementing, the `reducer` triggers a side-effect that triggers the `Decrement`
    action after one second.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine we now need our stateful component to display a message that
    congratulates the user when they get to a count of 10, and once the message is
    displayed, the user can close the message by clicking a close button. Thanks to
    our helpful compiler, we can follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the shape of `state`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the available `actions`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step through the compiler errors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `render` function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The compiler messages will remind us to update the component''s initial state
    and reducer. Since we now need to also keep track of whether or not to display
    a message, let''s change the shape of `state` to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For our actions, let''s combine `Increment` and `Decrement` into one constructor
    that accepts an `int`, and we''ll have a new constructor to toggle the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, instead of `Increment` and `Decrement`, we have `UpdateCount`, which holds
    an integer representing the amount to change the current count by.
  prefs: []
  type: TYPE_NORMAL
- en: 'After compiling, we see a friendly error letting us know that our previous
    action `Decrement` cannot be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `render` function, replace  `Increment`  with `UpdateCount(+1)` and
    `Decrement` with `UpdateCount(-1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling again, we''re informed that in our reducer, `Increment` does not
    belong to type `action`. Let''s update our reducer to handle both `UpdateCount`
    and `ToggleMessage`. If we were to forget a constructor, the compiler would let
    us know that the switch expression in the reducer is not exhaustive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There are few things to mention regarding the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: In `UpdateCount`, we're declaring a binding `count` that reflects the new count.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're using `...` to override just a portion of the state record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thanks to record punning support, we can write `{...state, count}` instead
    of `{...state, count: count}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateCount` is using `UpdateWithSideEffects` to trigger a `ToggleMessage`
    action when the count reaches 10; we could have instead done this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: I prefer using `UpdateWithSideEffects` so that `UpdateCount` only ever has to
    worry about its count field, and if some other field needs to get updated, `UpdateCount`
    can trigger the right action for that to happen, without needing to know how it
    needs to happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'After compiling here, we get an interesting compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The compiler sees `state` in `state.count` on line 18 (shown previously) as
    having type `int` instead of type `state`. This is because our render function
    is using `string_of_int(self.state)` instead of `string_of_int(self.state.count)`.
    After updating our render function to reflect this, we get another similar message
    complaining that type `int` and type `state` are incompatible. That's because
    our initial state is still returning `0` instead of a record of type `state`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After updating initial state, the code finally compiles successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re ready to update the render function to display a message when the
    count reaches 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Since `if/else` is an expression in Reason, we can use it within JSX to either
    render markup or `ReasonReact.null` (which has type `ReasonReact.reactElement`).
  prefs: []
  type: TYPE_NORMAL
- en: Instance variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although our example correctly shows the message when count reaches 10 for the
    first time, there is nothing preventing our `ToggleMessage` action from getting
    fired again within the `UpdateCount` case in the reducer. If a user gets to 10,
    then decrements and then increments, the message is toggled again. To ensure that
    `UpdateCount` only ever triggers the `ToggleMessage` action once, we can use an
    **instance variable** in state.
  prefs: []
  type: TYPE_NORMAL
- en: In ReactJS, every time something in state changes, the component gets re-rendered.
    In ReasonReact, instance variables never trigger a re-render, and can be correctly
    placed within a component's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an instance variable to keep track of whether the user has already
    seen the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Ref and mutable records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The difference between ReasonReact instance variables and normal state variables
    is the use of `ref`. Previously, we saw that `state.userHasSeenMessage` is of
    type `ref(bool)` instead of `bool`. That makes `state.userHasSeenMessage` an instance
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Since `ref` is just syntactic sugar for a record type with a mutable field,
    let's first discuss mutable record fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow a record field to be mutable, prefix the field''s name with `mutable`.
    Then, those fields can be updated in place using the `=` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the type declaration is already included in Reason''s standard library,
    so we can omit it, and the rest of the preceding code would still work, declaring
    it shadowed the original type declaration. We can prove this by shadowing the
    `ref` type with an immutable record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler fails with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to having a built-in type definition, `ref` also has some built-in
    functions. Namely, `ref` is used to create a record of type `ref`, and `^` is
    used to get the contents of a `ref`, and `:=` is used to set the contents of a
    ref:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go back to our ReasonReact example, and let''s use our new `userHasSeenMessage`
    instance variable. After updating the shape of our state, we need to also update
    the component''s initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our code again compiles, and we can update `reducer` to use this instance
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, the message is correctly displayed once and only once.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's use what we've learned so far as a foundation to build upon while creating
    an application with a navigation menu and client-side routing. On touch devices,
    users will be able to swipe to close the menu, and the menu will respond in real
    time to the user's touch. If the user swipes the menu when it's more than 50%
    closed and then releases, the menu will close; otherwise, it will remain open.
    The one exception is if the user swipes the menu closed with a high enough velocity;
    it will always close.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be working with this application throughout the rest of the book. To
    follow along, clone the GitHub repo and navigate to the directory representing
    the start of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a moment to see what we have to work with. You will see the following
    directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Our `bsconfig.json` is set up to place compiled `.bs.js` files within `lib/es6/src`, and
    we've configured webpack to look for `lib/es6/src/Index.bs.js` as an entry point.
  prefs: []
  type: TYPE_NORMAL
- en: Run `npm install` and then `npm start` to serve our app at `http://localhost:3000` with
    both bsb and webpack in watch mode.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, our app displays a blue navigation bar with a hamburger icon. Clicking
    on the icon opens a menu and clicking outside the menu closes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `App.re`, our state is currently a single field record that keeps track
    of the menu''s state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And our reducer takes care of updating the menu''s state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Although Reason supports record punning, it does not work for single field records,
    since Reason treats `{isOpen}` as a block instead of a record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our render function renders a `<div />` element with a conditional class name
    depending on the current state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`App.scss` uses the `overlay` class to display a dark overlay behind the navigation
    menu only when it''s open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `transition` property is defined for both  `.App:after`  and  `.App.overly:after`,
    the former includes a transition on the `transform` property with a `450ms` delay
    while the latter removes that transition. This has the effect of allowing a smooth
    transition even when the menu is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s inspect the binding to JavaScript''s `require` function at the top of `App.re`. Since
    we''re going to dive deeper into BuckleScript in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml),
    *BuckleScript, Belt, and Interoperability*, let''s defer discussing the details
    and just briefly see what this binding is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `external` keyword creates a new binding, similar to the `let` keyword.
    After binding to JavaScript''s `require` function, we can use it in Reason, as
    long as we''re using the BuckleScript compiler. We use it to require `App.scss`
    as well as a few images. Inspecting the compiled output at `lib/es6/src/App.bs.js`
    shows that the preceding Reason code compiles to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Webpack handles the rest from there.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the top-level `<div />` element has a click event handler that always
    closes the menu, any clicks on its children also fire that top-level click event
    handler. To allow the menu to open (or remain open), we need to call `event.stopPropagation()`
    on click events for some of its child elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ReasonReact, we can do this with the `ReactEvent` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReactEvent` module has submodules corresponding to each of ReactJS''s
    synthetic events:'
  prefs: []
  type: TYPE_NORMAL
- en: Clipboard events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mouse events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointer events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wheel events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Media events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transition events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on ReactJS's synthetic events, visit [https://reactjs.org/docs/events.html](https://reactjs.org/docs/events.html).
  prefs: []
  type: TYPE_NORMAL
- en: To get values such as `event.changedTouches.item(0).clientX` from a touch event,
    we use a combination of ReasonReact and BuckleScript.
  prefs: []
  type: TYPE_NORMAL
- en: Js.t Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BuckleScript allows us to access arbitrary JavaScript object fields using the
    `##` syntax. We can use syntax on any `Js.t` type, which is a Reason type for
    arbitrary JavaScript objects. We'll learn more about this and other interoperability
    features in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml), *BuckleScript,
    Belt, and Interoperability*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `ReactEvent.Touch.changedTouches(event)` returns a plain old JavaScript
    object, we can access its fields using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking in the compiled output, we see that it is what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We'll use this to add the touch feature to our menu so that users can swipe
    the menu closed and see the menu move as they swipe.
  prefs: []
  type: TYPE_NORMAL
- en: Adding actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding actions for `TouchStart`, `TouchMove`, and `TouchEnd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We'll need the touch event's `clientX` property only for `TouchStart` and `TouchMove`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the event listeners on the top-level `<div />` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In our reducer, let''s just log those `clientX` values for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: To figure out the overall direction of a user's swipe, we need the first and
    last `clientX` values for that swipe. The menu should move in proportion to the
    difference of the first and last `clientX` values, but only if the user is swiping
    in the direction that would close the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our state now includes a `touches` record that holds the value for the first
    and last `clientX` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Since we cannot nest record type definitions, we define the `touches` type separately
    and include it in `state`. You'll notice `state.touches.first` is of type `option(float)`
    because it's possible that the user isn't using a touch device or that the user
    hasn't yet interacted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the shape of our state requires us to also change the initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In the reducer, if the menu is open, we update `state.touches` with a fresh
    new record in the `TouchStart` case, but in the `TouchMove` case, we only update
    `state.touches.last`. If the menu is not currently open, `ReasonReact.NoUpdate` is
    returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We'll soon use this state to conditionally set an inline style on the `<nav
    />` element.
  prefs: []
  type: TYPE_NORMAL
- en: Inline styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In ReasonReact, we can add inline styles via `ReactDOMRe.Style.make`, which
    accepts CSS properties as optional labelled arguments. Since they are all optional,
    passing `unit` is necessary to call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying this to our `<nav />` element, we can conditionally add a style if
    we have both a first and last touch in state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `transform` property, we concatenate with `"0px"` instead of just
    `"px"` since the `float` type always includes a decimal point, but it''s possible
    that the user swipes a distance of exactly one hundred pixels, and `transform:
    translateX(100.px)` is not valid CSS, but `transform: translateX(100.0px)` is.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this on a touch device shows that we''re able to get the menu''s position
    to change based on the user''s swipe. Now, let''s focus on the `TouchEnd` case
    within the reducer. For now, let''s set the menu to remain open if the user swipes
    the menu less than half way closed, and close it otherwise. If `state.touches.last` is `None`,
    then the user did not swipe, and we don''t update `state`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we reset `state.touches` to a fresh new record with `{first: None,
    last: None}`, which results in an empty style prop on the `<nav />` element.'
  prefs: []
  type: TYPE_NORMAL
- en: This current implementation assumes that the width of the navigation is `300px`.
    Instead of assuming, we can use a React ref to get a reference to the DOM node,
    and then get its `clientWidth`.
  prefs: []
  type: TYPE_NORMAL
- en: React ref
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The React ref is just an instance variable of `state`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We attach the React ref on the `<nav />` element by setting the `ref` property
    to the result of `self.handle((ref, self) => ...)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Since a React ref could be `null` in JavaScript, we convert it to an option
    and pattern match on its value.
  prefs: []
  type: TYPE_NORMAL
- en: The type of the React ref depends on whether it is a DOM element or a React
    component. The former's type is `Dom.element`, and the latter's is `ReasonReact.reactRef`.
    To convert a `ReasonReact.reactRef` to a JavaScript object, use `ReasonReact.refToJsObj`
    instead of `ReactDOMRe.domElementToObj`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the reducer, we can use `state.width` instead of `300.0` as the menu's
    width. Since the `TouchStart` and `TouchMove` actions always update state when
    the menu is open, the `<App />` component is always re-rendered, which causes
    our React ref function to re-run, and we can be reasonably sure that the menu's
    width is always correct.
  prefs: []
  type: TYPE_NORMAL
- en: Velocity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the velocity of a user''s swipe, we''ll need to also store the current
    time along with the touch event''s `clientX`. Let''s bind to the browser''s `performance.now()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''ll make some room for the touch''s current time in the `touches` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In the reducer, we then change `Some(clientX)` to `Some((clientX, now()))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can calculate the velocity of a user''s swipe in the `TouchEnd` case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: A velocity of `-0.3` pixels per millisecond feels right to me, but feel free
    to use whatever feels right for you.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we can use pattern matching to destructure `(x, t)`, which creates
    two bindings in scope. Also, `x'` is a valid name for a binding in Reason and
    is commonly pronounced *x prime*. Lastly, notice how our state is shadowed to
    prevent writing duplicate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish the velocity feature, we update the `style` property in the render
    function to treat both `state.touches.first` and `state.touches.last` as tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Now, when open, the menu responds nicely to a touch—super cool!
  prefs: []
  type: TYPE_NORMAL
- en: Client-side routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ReasonReact comes with a built-in router found in the `ReasonReact.Router`
    module. It is quite unopinionated and therefore flexible. The public API has only
    four functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReasonReact.Router.watchUrl: (url => unit) => watcherID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReasonReact.Router.unwatchUrl: watcherID => unit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReasonReact.Router.push: string => unit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReasonReact.Router.dangerouslyGetInitialUrl: unit => url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `watchUrl` function starts watching the URL for changes. When changed, the
    `url => unit` callback is called. The `unwatchUrl` function stops watching the
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: The `push` function sets the URL, and the `dangerouslyGetInitialUrl` function
    gets a record of type `url`. The `dangerouslyGetInitialUrl` function is meant
    to be used only within the `didMount` lifecycle hook, alongside `watchUrl`, to
    prevent issues with stale information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `url` type is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We'll learn more about the `list` type constructor in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml),
    *BuckleScript, Belt, and Interoperability*. The `path` field in the `url` record
    is of type `list(string)`. If the value of `window.location.pathname` is `"/book/title/edit"`,
    the value of `url.path` will be `["book", "title", "edit"]`, which is a list of
    strings. The syntax makes it look like a JavaScript array, but there are some
    differences. Briefly, Reason lists are singly linked lists that are immutable
    and homogeneous, meaning all elements must be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: The `watcherID` type is an **abstract type**. We'll learn more about abstract
    types in [Chapter 6](a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml),  *CSS-in-JS
    (in Reason)*. The only way to get a value of type `watcherID` is as the return
    value of `ReasonReact.Router.watchUrl`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a router component that wraps our `<App />` component and provides
    it with a `currentRoute` prop. What follows was inspired by an example from Khoa
    Nguyen (`@thangngoc89`).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create placeholder components for `<Home />`, `<Page1 />`, `<Page2
    />`, and `<Page3 />`. Then, within `Router.re`, let''s create a type that represents
    a route along with a list of routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Each route has an `href`, `title`, and an associated `component`, which will
    be rendered within `<App />` if that route is the current route.
  prefs: []
  type: TYPE_NORMAL
- en: Current route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `Index.re`, let''s wrap `<App />` within a router component that provides
    the `currentRoute` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Router.re`, we define three components—`<WithRouter />`, `<Link />`, and
    `<NavLink />`—using the `module` syntax. Since each file is also a module, those
    three components are nested under the `Router` module, and in `Index.re` we need
    to tell the compiler to look for `<WithRouter />` within the `Router` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We've seen all of these concepts before. `<WithRouter />` is just a reducer
    component. The component's state is the same route type defined earlier and there
    is only one action to change the route. Once `<WithRouter />` is mounted, `ReasonReact.Router`
    begins watching the URL, and whenever it changes, the `ChangeRoute` action is
    triggered, which calls the reducer, which then updates state, which then re-renders
    `<App />` with an updated `currentRoute` prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that our menu closes whenever `<App />` receives a fresh `currentRoute`
    prop, we add a `willReceiveProps` lifecycle hook for `<App />`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Helper functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since `url.path` of `ReasonReact.Router` is a list of strings, and our `Router.route.href`
    is a string, we need a way to convert from string to a list of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We'll discuss Reason's pipe operator (`|>`) and JavaScript interoperability in
    [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml), *BuckleScript, Belt,
    and Interoperability*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a way to convert a `url` to a `route` for use in initial state,
    as well as within the callback function of `watchUrl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml), *BuckleScript, Belt,
    and Interoperability*, we will dive deeper into BuckleScript, Belt, and JavaScript
    interoperability. The `urlToRoute` function tries to find a `route` within the
    `routes` list whose `url.path` is structurally equal to `route.href` after it's
    converted to a list of strings.
  prefs: []
  type: TYPE_NORMAL
- en: If no such `route` exists, it returns the first `route` from the `routes` list,
    which is the one associated with the `<Home />` component. Otherwise, the matching
    `route` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<Link />` component is a simple stateless component that renders an anchor
    link. Note how the click handler prevents the default browser behavior and updates
    the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<NavLink />` component wraps the `<Link />` component, and is provided
    with the current route as a prop that it uses to conditionally set an `active`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve defined the router, we can rewrite our navigation menu links
    to use the `<NavLink />` component instead of the raw anchor link directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Wherever we want to display the current page''s title, we can simply access
    the `title` field on the current route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we can render a route''s associated component in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: It's important to emphasize that ReasonReact's router does not dictate what
    the callback of `watchUrl` should do. In our case, we trigger an action that updates
    the current route, which is just an arbitrary record. It's completely reasonable
    for the route type to be something entirely different. Also, there is no law that
    says the router should be the top-level component. There is a lot of room for
    creativity here and I'm personally excited to see what the community comes up
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how ReasonReact is a simpler, safer way to build React
    components. Having Reason's type system enforcing correct component usage at compile
    time is a huge win. Also, it makes refactoring safer, cheaper, and a much more
    pleasant experience. ReasonReact is *just* Reason, much like how ReactJS is *just*
    JavaScript. All of what we've done so far is just Reason and ReasonReact without
    any third-party libraries such as Redux or React Router.
  prefs: []
  type: TYPE_NORMAL
- en: As we'll see in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml), *BuckleScript,
    Belt, and Interoperability*, we also have the option to use existing JavaScript
    (and ReactJS) solutions within Reason. After getting more comfortable with BuckleScript,
    the Belt standard library, and JavaScript interoperability, we'll add route transitions.
  prefs: []
  type: TYPE_NORMAL

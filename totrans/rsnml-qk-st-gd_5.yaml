- en: Effective ML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've learned the basics of Reason. We've seen how having a sound type
    system can make refactoring a safer, less stressful endeavor. When changing an
    implementation detail, the type system helpfully alerts us to the other areas
    of the codebase that need to be updated. In this chapter, we'll learn how to hide
    implementation details to make refactoring even easier. By hiding implementation
    details, we guarantee that changing them won't affect other areas of your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also learn how the type system can help us enforce business rules in our
    application. Hiding implementation details also gives us a nice way to enforce
    business rules by guaranteeing that modules are not being misused by the user. We'll
    illustrate this point throughout much of this chapter using simple code examples
    that are included in this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: To follow along, start from `Chapter05/app-start`. These examples are isolated
    from the app we've been building.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can go to the GitHub repository for this book using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, all modules are global and all of a module''s types and bindings
    are exposed by default. As we''ll soon see, module signatures can be used to hide
    a module''s types and/or bindings from other modules. In this chapter, we''ll
    also learn about advanced type system features, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phantom types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphic variants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A module signature constrains a module in a similar way to how an interface
    can constrain a class in object-oriented programming. A module signature can require
    that a module implements certain types and bindings and can also be used to hide
    implementation details. Say that we had a module called `Foo` defined in `Foo.re`.
    Its signature can be defined in `Foo.rei`. Any type or binding listed in a module''s
    signature is exposed to other modules. Any type or binding listed in a module
    is hidden if a module signature exists and that type or binding isn''t present
    in the module signature. Given a binding `let foo = "foo";` in `Foo.re`, that
    binding can be both required and exposed by its module signature by including `let
    foo: string;` in `Foo.rei`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Foo.rei` requires `Foo.re` to have a `let` binding named `foo` of the
    `string `type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a module''s `.rei` file exists and is empty, then everything within the
    module is hidden, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A module''s signature requires the module to include any types and/or bindings
    listed in the signature, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following compilation error because the module signature
    requires a `bar` binding of the `string` type that isn''t defined in the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Module types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A module signature can also be defined using the `module type` keyword instead
    of using a separate `.rei` file. The module type must start with a capital letter.
    Once defined, a module can be constrained by a module type using the `module <Name>
    : <Type>` syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The same module type can be used for multiple modules, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can think of module signatures as interfaces in the object-oriented sense.
    The interface defines the properties and methods that a module must define. In
    Reason, however, module signatures also hide bindings and types. But perhaps one
    of the most useful features of module signatures is the ability to expose abstract
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Abstract types are type declarations that don''t have a definition. Let''s
    explore why this would be useful. In addition to bindings, module signatures can
    include types. In the following code, you''ll notice that the module signature
    of `Foo` includes a `person` type, and now `Foo` must include this `type` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `person` type is exposed in the same way as if there were no module signature
    defined. As you''d expect, if a signature is defined and the type is not listed,
    the type isn''t exposed to other modules. There is also the option to leave the
    type abstract. We only keep what''s left of the equals sign. Let''s look at the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `person` type is exposed to other modules, but no other modules can
    directly create or manipulate a value of the `person `type. The `person` type
    is required to be defined in `Foo`, but it can have any definition. This means
    that the `person` type can change over time, and no modules outside of `Foo` would
    ever know the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore abstract types further in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Using module signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine that we''re building an invoice-management system and we have
    an `Invoice` module that defines an `invoice` type along with a function that
    other modules can use to create values of that type. This arrangement is shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also suppose that we have another module that is responsible for sending
    emails to customers, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `Invoice.t` type is exposed, the invoice can be manipulated by `Email`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Despite the `Invoice.t` type being immutable, there is nothing preventing `Email`
    from shadowing the invoice binding with some altered fields. However, if we made
    the `Invoice.t` type abstract, this wouldn't be possible because `Email` wouldn't
    be able to manipulate the abstract type. None of the functions that the `Email`
    module has access to would work with an `Invoice.t` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compiling gives us the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we decide to allow other modules to add discounts to invoices, we would
    need to create a function and include it in the module signature of `Invoice`.
    Let''s suppose we want to only allow one discount per invoice and also restrict
    the discount amount to ten, fifteen, or twenty percent. We could implement this
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as long as the `Invoice` module''s public API (or module signature) doesn''t
    change, we''re free to refactor the `Invoice` module however we''d like without
    needing to worry about breaking code in other modules. To prove this point, let''s
    refactor `Invoice.t` to be a tuple instead of a record, as shown in the following
    code. As long as we don''t change the module signature, the `Email` module won''t
    need to change at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Also, thanks to the `Invoice.t` abstract type, we are guaranteed that an invoice
    can only be discounted once, and only by specified percentages. We could take
    this example further by requiring all changes to an invoice to be logged. Traditionally,
    this sort of requirement would be solved by adding a side effect after a database
    transaction because, in JavaScript, we wouldn't otherwise be sure that we would
    be logging all changes to an invoice. With module signatures, we have the option
    to solve these kinds of requirements in the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: Phantom types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at our previous implementation, it would be nice if we didn't have to
    check whether an invoice has been discounted at runtime. Is there a way we could
    check whether an invoice has been discounted at compile time instead? With phantom
    types, we can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Phantom types are types that have a type variable, but this type variable isn''t
    used in its definition. To better understand, let''s look again at the `option`
    type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `option` type has a type variable, `'a`, and the type variable is being
    used in its definition. As we've already learned, `option` is a polymorphic type
    because it has a type variable. On the other hand, a phantom type doesn't use
    the type variable in its definition. Let's see how this is useful with our invoice
    management example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the `Invoice` module''s signature to use a phantom type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The abstract `type t` is now `type t(''a)`. We also have two more abstract
    types, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Also, note that the `make` function now returns `t(undiscounted)` (instead of
    just `t`) and the `discount` function now accepts `t(undiscounted)` and returns `t(discounted)`.
    Remember that the abstract `t('a)` accepts a `type` variable, and that the `type`
    variable just so happens to be either the `discounted` type or the `undiscounted` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the implementation, we can now get rid of the runtime check we had previously,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this check is done at compile time since the `discount` function only
    accepts `undiscounted` invoices, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just one more way that a type system can help us focus more on logic
    and less on error handling. Previously, trying to discount an invoice twice would
    just return the original invoice unchanged. Let''s now try to discount an invoice
    twice in `Email.re` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, trying to discount an invoice twice will result in a lovely compile-time
    error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is absolutely beautiful. Suppose, however, that you''d like to be able
    to email any invoice—discounted or not. Does our use of phantom types cause a
    problem? How would we write a function that takes any invoice type? We''ll, remember
    that our invoice type is `Invoice.t(''a)` and if we want to accept any invoice,
    we keep the type parameter, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So we can have our cake and eat it too.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic variants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already briefly looked at polymorphic variants in the previous chapter.
    To recap, we learned about them when we used the `[@bs.unwrap]` decorator to bind
    to some existing JavaScript. The idea was that `[@bs.unwrap]` can be used to bind
    to an existing JavaScript function where its arguments can be of different types.
    For example, let''s say we want to bind to the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say this function should only accept arguments of the `string` type or
    `int` type and nothing else. We could bind to this example function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, our binding would then allow invalid argument types (such as `bool`).
    It would be better if our compiler could help us out by preventing invalid argument
    types. One way to do this is to use `[@bs.unwrap]` with a polymorphic variant.
    Our binding would then appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d use the binding like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we tried to pass an invalid argument type, the compiler would let us
    know, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The trade-off here is that we'll need to pass in arguments by wrapping them
    in the polymorphic variant constructors rather than directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right off the bat, you''ll notice the following two differences between normal
    variants and polymorphic variants:'
  prefs: []
  type: TYPE_NORMAL
- en: We did not need to explicitly declare a type for the polymorphic variant
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Polymorphic variants begin with a backtick character ([PRE29]
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: type validArgs =
  prefs: []
  type: TYPE_NORMAL
- en: '| Int(int)'
  prefs: []
  type: TYPE_NORMAL
- en: '| Str(string);'
  prefs: []
  type: TYPE_NORMAL
- en: '[@bs.val] external dynamic : validArgs => string = "";'
  prefs: []
  type: TYPE_NORMAL
- en: dynamic(Int(1));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with the preceding implementation is that `Int(1)` does not compile
    to a JavaScript number. Normal variants are compiled to an `array` and our `dynamic`
    function returns `undefined` instead of `"Number: 42"`. The function returns `undefined`
    because no cases on the switch statement were matched.'
  prefs: []
  type: TYPE_NORMAL
- en: With polymorphic variants, BuckleScript compiles `dynamic(`Int(42))` to `dynamic(42)` and
    the function works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced type system features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reason's type system is quite full-featured and has been refined over the last
    couple of decades. What we've seen so far is only an introduction to Reason's
    type system. In my opinion, you should become familiar with the basics before
    continuing to more advanced type system features. It's hard to appreciate things
    such as type safety without having experienced bugs that a sound type system would
    have prevented. It's hard to appreciate advanced type system features without
    getting slightly frustrated with what you've learned so far in this book. It's
    beyond the scope of this book to discuss advanced type system features in too
    much detail, but I want to make sure that those of you who are evaluating Reason
    as an option know that there's much more to its type system.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to phantom types and polymorphic variants, Reason has **generalized
    algebraic datatypes** (**GADTs**). Modules can be dynamically created using functors
    (that is, module functions that operate somewhere in between compile time and
    runtime). Reason also has classes and objects—the O in OCaml stands for objective.
    OCaml's predecessor was a language called Caml that first appeared in the mid
    1980s. What we've learned so far in this book is specifically useful in the context
    of typical React applications. Personally, I like that Reason is a language that
    I can grow into while being productive.
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself frustrated with the type system, then reach out to the
    experts on the Discord channel and someone will likely help you work through your
    problem. I'm constantly amazed at how helpful the community is. And don't forget,
    if you just want to move on, you can always drop into raw JavaScript if you need
    to and come back to the problem when you're ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the Reason Discord channel here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/reasonml](https://discord.gg/reasonml)'
  prefs: []
  type: TYPE_NORMAL
- en: It's also perfectly valid to not use the fancier features of Reason's type system.
    What we've learned so far provides a lot of value in terms of adding type safety
    to our React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we've seen how Reason can help us build safer, more maintainable codebases
    with the help of its type system. Variants allow us make invalid states unrepresentable.
    The type system helps make refactoring a less scary, less painful process. Module
    signatures can help us to enforce business rules in our application. Module signatures
    also serve as basic documentation that lists what a module exposes and gives you
    a basic idea of how the module is meant to be used based on exposed function names
    and their argument types, as well as exposed types.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml), *CSS-in-JS (in Reason)*,
    we'll look at how we can use Reason's type system to enforce valid CSS using a
    CSS-in-Reason library that wraps Emotion ([https://emotion.sh](https://emotion.sh)),
    called `bs-css`.
  prefs: []
  type: TYPE_NORMAL

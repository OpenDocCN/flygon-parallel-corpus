- en: CSS-in-JS (in Reason)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great things about React is that it lets us collocate a component's
    markup, behavior and styles in a single file. This collocation has cascading effects
    (no pun intended) on the developer experience, version control, and code quality
    over time. In this chapter, we'll briefly explore what CSS-in-JS is and how we
    can approach CSS-in-JS in Reason. Of course, it's perfectly valid to break a component
    up across separate files and/or use a more traditional CSS solution, if that's
    what you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be looking at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is CSS-in-JS?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `styled-components`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `bs-css`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is CSS-in-JS?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining CSS-in-JS is currently a polarizing topic in the JavaScript community.
    CSS-in-JS was born during the component age. The modern web is largely built with
    the component model. Pretty much all JavaScript frameworks have embraced it. As
    its adoption grew, more and more teams started working on various components of
    the same project. Imagine that you're working on a large app in a distributed
    team and each team is working on a component in parallel. Without having the team
    standardize CSS conventions, you're going to run into CSS scoping issues. Without
    some type of standardized CSS style guide, it's going to be easy for multiple
    teams to style a class name such that other unintended components are affected.
    Over time, a number of solutions emerged to solve this and other related problems
    with CSS at-scale.
  prefs: []
  type: TYPE_NORMAL
- en: A brief history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some CSS conventions that became popular include BEM, SMACSS, and OOCSS. Each
    of these solutions required developers to learn the convention and remember to
    apply it correctly; otherwise, frustrating scoping issues could still occur.
  prefs: []
  type: TYPE_NORMAL
- en: CSS modules became a safer option, where developers would import CSS into JavaScript
    modules and a build step would automatically scope that CSS locally to that JavaScript
    module. The CSS itself is still written in a normal CSS (or SASS) file.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS-in-JS went one step further and allowed you to write your CSS directly
    in your JavaScript module, automatically scoping that CSS locally to the component.
    This felt right for a lot of developers; others didn''t like it from the start.
    Some CSS-in-JS solutions, such as `styled-components`, allow developers to couple
    CSS together with components directly. Instead of `<header className="..." />`,
    you could have `<Header />`, where the `Header` component is defined using `styled-components`
    and its CSS, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There was a time when `styled-components` had performance issues, since the
    JavaScript bundle had to download, compile, and execute before the library could
    create style sheets dynamically in the DOM. These problems have now been largely
    solved thanks to server-side rendering support. So, are we able to do this in
    Reason? Let's see!
  prefs: []
  type: TYPE_NORMAL
- en: Using styled-components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most loved features of `styled-components` is the ability to dynamically
    create CSS based on a component's props. One reason to use this feature is to
    create alternate versions of a component. These alternate versions would then
    be encapsulated within the styled component itself. The following is an example
    of a `<Title />` where the text could be either centered or left-aligned and optionally
    underlined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The challenge in the context of Reason lies in creating a component via the
    `style-components` API that can work with props dynamically. Consider the following
    binding for the `styled.h1` function and our `<Title />` component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `h1` function accepts an array of strings as its first argument, and an
    array of expressions as its second argument. This is because that is the ES5 representation
    of ES6-tagged template literals. In the case of the `h1` function, the array of
    expressions are functions of the props passed to the React component.
  prefs: []
  type: TYPE_NORMAL
- en: We're using the `[@bs.variadic]` decorator to allow an arbitrary number of arguments.
    On the Reason side, we use an array, and on the JavaScript side the array is expanded
    as an arbitrary number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Using [@bs.variadic]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go off on a quick tangent to explore `[@bs.variadic]` a bit further.
    Let''s assume you''d like to bind to `Math.max()`, which can take one or more
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is a perfect case for `[@bs.variadic]`. We use an array on the Reason side
    to hold the arguments, and the array will be expanded to match the above syntax
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, we''re back to the `styled-components` example. We can use the `<Title
    />` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a styled ReasonReact component that renders an `h1` with
    some CSS. The CSS was defined previously within the `StyledComponents.Title` module.
    The `<Title />` component has two props—center and underline—both of which default
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this wouldn't be an elegant way to write styled components but it's
    functionally similar to the JavaScript version. Another option is to drop back
    into raw JavaScript to take advantage of the familiar tagged template literal
    syntax. Let's illustrate this example in `Title.re`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The usage would be similar, except that now the `<Title />` component is no
    longer a submodule of `StyledComponents`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Personally, I like the developer experience when using the `[%bs.raw]` version.
    I'd like to give Adam Coll (`@acoll1`) a big round of applause for coming up with
    both versions of the `styled-components` bindings. I'm also very excited to see
    what the community comes up with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now explore the community''s most popular CSS-in-JS solution: `bs-css`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using bs-css
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there is no official recommendation from the Reason team for a CSS-in-JS
    solution, many are currently using a library called `bs-css` that wraps the emotion
    CSS-in-JS library (version 9). The `bs-css` library provides a type-safe API for
    use in Reason. With this approach, we can have the compiler check our CSS as well.
    We'll get a feel for this library by converting our `App.scss`, which we created
    in [Chapter 3](21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml), *Creating ReasonReact
    Components*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow along, clone this book''s GitHub repository and start from `Chapter06/app-start` using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To get started with `bs-css`, we''ll include it as a dependency for both `package.json`
    and `bsconfig.json` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing `bs-css` via npm and configuring `bsconfig.json`, we''ll have
    access to the `Css` module provided by the library. It''s standard practice to
    define your own submodule called `Styles`, where we open the `Css` module and
    write all of our CSS-in-Reason there. Since we''ll be converting `App.scss`, we''ll
    declare a `Styles` submodule in `App.re`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s convert the following Sass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `Styles`, we declare a binding called `app` that will be used later
    in the `<App />` component''s `className` prop. We''ll bind to the result of a
    `bs-css` function called `style`. The `style` function takes in a list of CSS
    rules. Let''s explore the syntax using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a bit weird at first, but the more you use it, the nicer it feels. All
    CSS properties and all units are functions. The functions have types. If the types
    don''t match, the compiler will complain. Consider the following invalid CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This just silently fails in CSS, Sass, and even `styled-components`. With `bs-css`,
    we can at least prevent a lot of invalid CSS. The compiler will also inform us
    of any unused bindings, which can help us maintain CSS style sheets, and, as usual,
    we have full IntelliSense, which helps us learn the API as we go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Personally, I''m a big fan of nesting CSS via Sass, and I''m thrilled that
    we can do the same with `bs-css`. To nest the `:after` pseudo selector, we use
    the `after` function. To nest the `.overlay` selector, we use the `selector` function.
    Just like in Sass, we use the `&` symbol to reference the parent element, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note how we are using the polymorphic variant ``transition` for the transition
    strings. Transitions are not valid otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the rest of the conversion in the GitHub repository''s `Chapter06/app-end/src/App.re`
    file. Now all that''s left to do is apply the styles to the `<App />` component''s
    `className` prop, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After deleting `App.scss`, everything looks mostly the same. Awesome! The exception
    is the `nav > ul > li:after` selector. In previous chapters, we used the content
    property to render an image, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'According to `Css.rei`, the `contentRule` function accepts a string. Therefore,
    using the `url` function does not typecheck, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As an escape route, `bs-css` provides the `unsafe` function (as shown in the
    following code), which will bypass this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, while our webpack configuration previously pulled the preceding image
    in as a dependency, it no longer does this when using `bs-css`.
  prefs: []
  type: TYPE_NORMAL
- en: Trade-offs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using CSS-in-JS in Reason clearly is a trade-off. On the one hand, we can get
    type-safe, locally scoped CSS and we get to collocate our CSS with our components.
    On the other hand, the syntax is a bit more verbose and there may be some weird
    edge cases. It's perfectly valid to choose Sass over a CSS-in-JS solution as there
    is no clear winner here.
  prefs: []
  type: TYPE_NORMAL
- en: Other libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I encourage you to try other CSS-in-JS Reason libraries. And whenever you're
    looking for a Reason library, your first stop should be Redex (**Re**ason Package
    In**dex**).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find Redex (**Re**ason Package In**dex**) at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://redex.github.io/](https://redex.github.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: Another helpful resource is the Reason Discord channel. It's a good place to
    ask about the various CSS-in-JS solutions and their trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the Reason Discord channel at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/reasonml](https://discord.gg/reasonml)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS-in-JS is still fairly new, and there will be a lot of experimentation with
    it in the Reason community in the near future. In this chapter, we learned about
    some of the benefits and challenges of CSS-in-JS (in Reason). Where do you stand?
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](baf36f3b-7e4f-4a31-afae-1ef9ee48b17c.xhtml), *JSON in Reason*,
    we're going to learn about handling JSON in Reason and see how GraphQL can help
    reduce boilerplate code while achieving some pretty compelling guarantees.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 2. Resource Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。资源设计
- en: '[Chapter 1](ch01.html "Chapter 1. REST – Where It Begins"), *REST – Where It
    Begins*, covered the basics of REST as well as best practices while designing
    RESTful resources. This chapter continues the discussion with an understanding
    of request response patterns, how to deal with different representations of resources,
    what are the different strategies when versioning API, and how standard HTTP codes
    can be used with REST responses. Subsections of this chapter will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章，“REST - 起源”，介绍了REST的基础知识以及在设计RESTful资源时的最佳实践。本章将继续讨论请求响应模式的理解，如何处理资源的不同表示，API版本控制的不同策略，以及如何使用标准HTTP代码来处理REST响应。本章的子章节将涵盖以下主题：
- en: REST response patterns
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST响应模式
- en: Content negotiation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容协商
- en: Entity providers and different representations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体提供程序和不同的表示
- en: API versioning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API版本控制
- en: Response codes and REST patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应代码和REST模式
- en: We will also cover custom entity providers for serializing and de-serializing
    request and response entities as well as other approaches such as streaming and
    chunking.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍用于序列化和反序列化请求和响应实体的自定义实体提供程序，以及流式传输和分块等其他方法。
- en: REST response patterns
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST响应模式
- en: In the earlier chapter, we saw how we can work with domain-related data to create
    readable URIs, use HTTP methods for different CRUD functionality, and transfer
    data to and fro from the clients and server using standardized MIME types and
    HTTP response codes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们看到了如何使用与域相关的数据来创建可读的URI，使用不同的CRUD功能的HTTP方法，并使用标准化的MIME类型和HTTP响应代码在客户端和服务器之间传输数据。
- en: 'The following is a diagram that shows standard REST request/response patterns:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示标准REST请求/响应模式的图表：
- en: '![REST response patterns](img/7963OS_02_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![REST响应模式](img/7963OS_02_01.jpg)'
- en: As seen from the preceding diagram, the client makes a REST request, which consists
    of standard HTTP methods, MIME types, and the URI to target. The server processes
    the request and sends back a response, which comprises standard HTTP response
    codes and MIME types. We covered the HTTP methods and how to use JAX-RS annotations
    earlier. Also, we enumerated the best practices for designing Resource URIs. In
    this chapter, we will cover the commonly used HTTP response codes as well as how
    to handle the different MIME types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，客户端发出REST请求，其中包括标准的HTTP方法、MIME类型和目标URI。服务器处理请求并发送回一个响应，其中包括标准的HTTP响应代码和MIME类型。我们之前介绍了HTTP方法以及如何使用JAX-RS注释。还列举了设计资源URI的最佳实践。在本章中，我们将介绍常用的HTTP响应代码以及如何处理不同的MIME类型。
- en: Content negotiation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容协商
- en: Content negotiation means allowing different representations of a resource in
    the same URI so that clients can make a choice on what suits them best.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 内容协商意味着在同一URI中允许资源的不同表示，以便客户端可以选择最适合它们的表示。
- en: '|   | *"HTTP has provisions for several mechanisms for "content negotiation"
    - the process of selecting the best representation for a given response when there
    are multiple representations available."* |   |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|   | *“HTTP有几种机制来进行‘内容协商’-在有多个表示可用时选择给定响应的最佳表示的过程。”* |   |'
- en: '|   | --*RFC 2616, Fielding et al.* |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|   | --*RFC 2616, Fielding et al.* |'
- en: 'There are different patterns for content negotiation. These are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 内容协商有不同的模式。具体如下：
- en: Using HTTP headers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP头
- en: Using URL patterns
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用URL模式
- en: Content negotiation using HTTP headers
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTTP头进行内容协商
- en: When the client sends requests to create or update a resource, there is some
    form of payload that should be transferred from the client to the endpoint. Also,
    when a response is generated, a payload can be sent back to the client. These
    payloads are handled by HTTP request and response entities, which are sent as
    part of the HTTP messages body.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端发送请求以创建或更新资源时，应从客户端传输某种有效负载到端点。此外，生成响应时，有效负载可以发送回客户端。这些有效负载由HTTP请求和响应实体处理，这些实体作为HTTP消息正文的一部分发送。
- en: Entities are sent via a request, usually for HTTP `POST` and `PUT` methods,
    or they are returned in a response for the HTTP methods. The Content-Type HTTP
    header is used to indicate the MIME type of the entity being sent by the server.
    Common examples of content types are `"text/plain"`, `"application/xml"`, `"text/html"`,
    `"application/json"`, `"image/gif"`, and `"image/jpeg"`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实体通常通过请求发送，通常用于HTTP `POST` 和 `PUT` 方法，或者在HTTP方法的响应中返回。Content-Type HTTP头用于指示服务器发送的实体的MIME类型。常见的内容类型示例包括“text/plain”、“application/xml”、“text/html”、“application/json”、“image/gif”和“image/jpeg”。
- en: A client can make a request to the server and specify what media types it can
    handle and what is its order of preference as part of the `"Accept"` HTTP header.
    The client can also specify in what language it wants the response as part of
    the `"Accept-Language"` header to be. If no `Accept` header is present in the
    request, the server can send the representation it chooses.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以向服务器发出请求，并在“Accept”HTTP头的一部分中指定它可以处理的媒体类型以及其首选顺序。客户端还可以在“Accept-Language”头的一部分中指定它希望响应的语言。如果请求中没有`Accept`头，则服务器可以发送它选择的表示。
- en: 'The JAX-RS specification provides standard annotations to support content negotiation.
    These are `javax.ws.rs.Produces` and `javax.ws.rs.Consumes` annotations. The following
    snippet shows an example of the `@Produces` annotation in a resource method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS规范提供了标准注释来支持内容协商。这些是`javax.ws.rs.Produces`和`javax.ws.rs.Consumes`注释。以下代码段显示了资源方法中`@Produces`注释的示例：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `getCoffeeList()` method returns a list of coffees and is annotated with
    `@Produces(MediaType.APPLICATION_JSON)`. The `@Produces` annotation is used to
    specify which MIME types the resource can send back to the client and match it
    up to the client's `Accept` header.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCoffeeList()`方法返回咖啡列表，并用`@Produces(MediaType.APPLICATION_JSON)`进行注释。`@Produces`注释用于指定资源可以发送给客户端的MIME类型，并将其与客户端的`Accept`头进行匹配。'
- en: 'This method will produce a response as shown:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In a resource, if no methods are able to produce the MIME type requested by
    a client request, the JAX-RS runtime sends back an HTTP `406 Not Acceptable` error.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows a resource method annotated with the `@Consumes`
    annotation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `@Consumes` annotation specifies which media types the resource can consume.
    When a client makes a request, JAX-RS finds all the methods that will match the
    path, and it will then invoke the method based on the content type sent by the
    client.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: If a resource is unable to consume the MIME type of a client request, the JAX-RS
    runtime sends back an HTTP `415 ("Unsupported Media Type")` error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Multiple MIME types can be specified in the `@Produces` or `@Consumes` annotation
    as `@Produces(MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML)`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Along with the support for static content negotiation, JAX-RS also contains
    runtime content negotiation support using the `javax.ws.rs.core.Variant` class
    and the `javax.ws.rs.core.Request` objects. A `Variant` object in a JAX-RS specification
    is a combination of media types, content-language, and content encoding as well
    as ETags, last-modified headers, and other preconditions. The `Variant` object
    defines the resource representation that is supported by the server. The `Variant.VariantListBuilder`
    class is used to build a list of representation variants.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to create a list of resource representation
    variants:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code snippet calls the build method of the `VariantListBuilder` class.
    The `Request.selectVariant` method takes a list of `Variant` objects and chooses
    the one based on the client''s `Accept` header, as shown in the following snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Content negotiation based on URL patterns
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another approach for content negotiation adopted by some APIs is to send the
    resource representation based on the extension of a resource in the URL. For example,
    a client can ask for details using `http://foo.api.com/v2/library/books.xml` or
    `http://foo.api.com/v2/library/books.json`. The server has different methods,
    which can handle the two URIs. However, both of these are representations of the
    same resource.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see in the preceding snippet, there are two methods defined: `getBookInXML()`
    and `getBookInJSON()`, and the response is returned based on the path of the URL.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good practice to use the HTTP content negotiation `Accept` header. Using
    headers for content negotiation provides a clear separation of IT concerns from
    business. The other advantage with using the `Accept` header for content negotiation
    is that there is only one resource method for all the different representations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The following section covers how to serialize and de-serialize a resource to
    and from the different representations respectively using entity providers in
    JAX-RS.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Entity providers and different representations
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous examples, we passed literal parameters picked from a URI path
    fragment as well as from the request''s query parameters to the resource method.
    However, there are cases when we want to pass a payload in the request body, for
    example a `POST` request. JAX-RS provides two interfaces that can be used: one
    for handling the inbound entity representation-to-Java de-serialization known
    as `javax.ws.rs.ext.MessageBodyReader`, and the other one for handling the outbound
    entity Java-to-representation serialization known as `javax.ws.rs.ext.MessageBodyWriter`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`MessageBodyReader` de-serializes entities from the message body representation
    into Java classes. `MessageBodyWriter` serializes a Java class to a specific representation
    format.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the methods that need to be implemented:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '| Method of MessageBodyReader | Description |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| `isReadable()` | This is used to check if the `MessageBodyReader` class can
    support conversion from a stream to Java type |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| `readFrom()` | This is used to read a type from the `InputStream` class |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: As shown in the table, the `isReadable()` method of the `MessageBodyReader`
    implementation class is called to check if `MessageBodyReader` can handle the
    specified input. When the `readFrom()` method of the `MessageBodyReader` class
    is called, it can convert an input stream to a Java POJO.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如表所示，`MessageBodyReader`实现类的`isReadable()`方法用于检查`MessageBodyReader`是否能处理指定的输入。当调用`MessageBodyReader`类的`readFrom()`方法时，它可以将输入流转换为Java
    POJO。
- en: 'The following table shows the methods of `MessageBodyWriter` that must be implemented
    along with a short description of each of its methods:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了必须实现的`MessageBodyWriter`方法以及每个方法的简要描述：
- en: '| Method of MessageBodyWriter | Description |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| MessageBodyWriter方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `isWritable()` | This is used to check if the `MessageBodyWriter` class can
    support the conversion from the specified Java type |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `isWritable()` | 用于检查`MessageBodyWriter`类是否支持从指定的Java类型进行转换 |'
- en: '| `getSize()` | This is used to check the length of bytes if the size is known
    or -1 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `getSize()` | 用于检查字节的长度，如果大小已知则返回长度，否则返回-1 |'
- en: '| `writeTo()` | This is used to write from a type to the stream |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `writeTo()` | 用于从一种类型写入流 |'
- en: The `isWritable()` method of the `MessageBodyWriter` implementation class is
    called to check if the `MessageBodyWriter` class can handle the specified input.
    When the `writeTo()` method of `MessageBodyWriter` is called, it can convert a
    Java POJO to the output stream. The samples in the download bundle of this book
    show how to use `MessageBodyReader` and `MessageBodyWriter`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBodyWriter`实现类的`isWritable()`方法用于检查`MessageBodyWriter`类是否能处理指定的输入。当调用`MessageBodyWriter`的`writeTo()`方法时，它可以将Java
    POJO转换为输出流。本书的下载包中的示例展示了如何使用`MessageBodyReader`和`MessageBodyWriter`。'
- en: However, there are lightweight implementations such as the `StreamingOutput`
    and `ChunkingOutput` classes, and the following sections will cover how Jersey
    implementation of JAX-RS already has support for basic formats such as text, JSON,
    and XML.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些轻量级的实现，如`StreamingOutput`和`ChunkingOutput`类，接下来的部分将介绍JAX-RS的Jersey实现已经支持基本格式，如文本、JSON和XML。
- en: StreamingOutput
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StreamingOutput
- en: The `javax.ws.rs.core.StreamingOutput` class is a callback that can be implemented
    to send the entity in the response when the application wants to stream the output.
    The `StreamingOutput` class is a lightweight alternative to the `javax.ws.rs.ext.MessageBodyWriter`
    class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`javax.ws.rs.core.StreamingOutput`类是一个回调，可以在应用程序希望流式传输输出时实现以发送响应中的实体。`StreamingOutput`类是`javax.ws.rs.ext.MessageBodyWriter`类的轻量级替代品。'
- en: 'The following is a sample code that shows how to use `StreamingOutput` as part
    of the response:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例代码，展示了如何在响应的一部分中使用`StreamingOutput`：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As shown in the preceding snippet, the `write()` method of the `StreamingOutput`
    class has been overridden to write to the output stream. `StreamingOutput` is
    useful in case of streaming binary data in a streaming fashion. For more details,
    have a look at the samples code that are available as part of the download bundle.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的片段所示，`StreamingOutput`类的`write()`方法已被重写以写入输出流。`StreamingOutput`在以流的方式流式传输二进制数据时非常有用。要了解更多详情，请查看作为下载包的一部分提供的示例代码。
- en: ChunkedOutput
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ChunkedOutput
- en: With Jersey implementation of JAX-RS, the server can use the `org.glassfish.jersey.server.ChunkedOutput`
    class to immediately send a response to a client in chunks as soon as they become
    available, without waiting for the other chunks to become available too. The `size`
    object's value of -1 is sent in the `Content-Length` header of the response to
    indicate that the response will be chunked. On the client side, it will know that
    the response will be chunked, so it reads each chunk of the response separately
    and processes it and waits for more chunks to come on the same connection. The
    server keeps on sending response chunks until it closes the connection after sending
    the last chunk and the response processing is finished.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JAX-RS的Jersey实现，服务器可以使用`org.glassfish.jersey.server.ChunkedOutput`类在可用时立即以块的形式向客户端发送响应，而无需等待其他块也变为可用。`size`对象的值为-1将在响应的`Content-Length`头中发送，以指示响应将被分块。在客户端，它将知道响应将被分块，因此它将单独读取每个响应的块并处理它，并等待更多块在同一连接上到来。服务器将继续发送响应块，直到在发送最后一个块后关闭连接并完成响应处理。
- en: 'The following is an example code to show the use of `ChunkedOutput`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例代码，展示了如何使用`ChunkedOutput`：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As shown in the snippet, the `chunkExample` method returns a `ChunkedOutput`
    object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如片段所示，`chunkExample`方法返回一个`ChunkedOutput`对象。
- en: 'On the client side, `org.glassfish.jersey.client.ChunkedInput` can be used
    to receive messages in `"typed"` chunks. This data type is useful for consuming
    partial responses from large or continuous data input streams. The following snippet
    shows how the client can read from a `ChunkedInput` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，`org.glassfish.jersey.client.ChunkedInput`可用于接收以“类型化”块接收消息。这种数据类型对于从大型或连续数据输入流中消耗部分响应非常有用。以下片段显示了客户端如何从`ChunkedInput`类中读取：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Differences between ChunkedOutput and StreamingOutput**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**ChunkedOutput和StreamingOutput之间的区别**'
- en: '`ChunkedOutput` is an internal class provided by Jersey. It lets the server
    send *chunks* of data without closing the client connection. It uses a series
    of convenient calls to the `ChunkedOutput.write` methods that take POJO and media
    type input and then use the JAX-RS `MessageBodyWriter` class to convert the POJO
    to bytes. `ChunkedOutput` writes are non-blocking.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChunkedOutput`是Jersey提供的内部类。它允许服务器在不关闭客户端连接的情况下发送数据的*块*。它使用一系列方便的调用`ChunkedOutput.write`方法，该方法接受POJO和媒体类型输入，然后使用JAX-RS的`MessageBodyWriter`类将POJO转换为字节。`ChunkedOutput`的写入是非阻塞的。'
- en: '`StreamingOutput` is a low-level JAX-RS API that works with bytes directly.
    The server has to implement `StreamingOutput`, and its `write(OutputStream)` method
    will be invoked only once by JAX-RS runtime, and the call is blocking.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamingOutput`是一个低级别的JAX-RS API，直接使用字节。服务器必须实现`StreamingOutput`，并且其`write(OutputStream)`方法将被JAX-RS运行时调用一次，并且调用是阻塞的。'
- en: Jersey and JSON support
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jersey和JSON支持
- en: Jersey provides support for the following approaches when working with a JSON
    representation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Jersey在处理JSON表示时提供了以下支持方法。
- en: POJO-based JSON binding support
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于POJO的JSON绑定支持
- en: 'POJO-based JSON binding support is very generic and allows mapping from any
    Java object to JSON. This is done via a Jackson `org.codehaus.jackson.map.ObjectMapper`
    instance. For example, to read a JSON in a `Coffee` object, we use the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基于POJO的JSON绑定支持非常通用，允许从任何Java对象映射到JSON。这是通过Jackson的`org.codehaus.jackson.map.ObjectMapper`实例完成的。例如，要在`Coffee`对象中读取JSON，我们使用以下方式：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For more details, check [https://jersey.java.net/documentation/1.18/json.html](https://jersey.java.net/documentation/1.18/json.html).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请查看[https://jersey.java.net/documentation/1.18/json.html](https://jersey.java.net/documentation/1.18/json.html)。
- en: JAXB-based JSON binding support
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于JAXB的JSON绑定支持
- en: 'JAXB-based JSON binding support is useful if the resource can produce and consume
    XML or JSON. To implement this, you can annotate a simple POJO with `@XMLRootElement`,
    as shown in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源可以生成和消耗XML或JSON，则基于JAXB的JSON绑定支持非常有用。要实现这一点，可以使用`@XMLRootElement`注释一个简单的POJO，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using the preceding JAXB bean to produce the JSON data format from the resource
    method is then as simple as using the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的JAXB bean从资源方法生成JSON数据格式就像使用以下方式一样简单：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Produces` annotation will take care of converting into a JSON representation
    of the `Coffee` resource.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Produces`注解将负责将`Coffee`资源转换为JSON表示。'
- en: Low-level JSON parsing and processing support
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 低级JSON解析和处理支持
- en: 'This is best used to get fine-grained control over the JSON format using `JSONArray`
    and `JSONObject` to create the JSON representation. The advantage here is that
    the application developer will gain full control over the JSON format produced
    and consumed. The following is an example code to use `JSONArray`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这最适用于使用`JSONArray`和`JSONObject`获得对JSON格式的精细控制，以创建JSON表示。这里的优势在于应用程序开发人员将完全控制所生成和使用的JSON格式。以下是使用`JSONArray`的示例代码：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the other hand, dealing with the data model objects will probably be a bit
    more complex. For example, the following code shows how the pull parsing programming
    model works with JSONParser:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，处理数据模型对象可能会更加复杂。例如，以下代码显示了拉取解析编程模型如何与JSONParser一起工作：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The next section covers the topic of how to version the API so that it can evolve
    over a period of time as well as how to ensure the basic functionality of a client
    application does not break with API versioning changes on the server side.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍如何对API进行版本控制，以便它可以随着时间的推移而发展，并确保客户端应用程序的基本功能不会因服务器端API版本更改而中断。
- en: API versioning
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API版本控制
- en: For the evolution of the application, the URI design should have some constraints
    to identify the version. It is hard to foresee all the resources, which will change
    during the life of the application. The goal with API versioning is to define
    the resource endpoints and the addressing schemes and associate a version with
    them. The API developers must ensure the HTTP verbs' semantics and status codes
    should continue to work without human intervention as the version changes. Over
    the life span of the application, the version will evolve, and the APIs may need
    to be deprecated. Requests to older versions of the API can be redirected to the
    latest code path or there can be appropriate error codes that indicate the API
    is obsolete.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序的演变，URI设计应该有一些约束来识别版本。很难预见应用程序生命周期中将发生变化的所有资源。API版本控制的目标是定义资源端点和寻址方案，并将版本与其关联。API开发人员必须确保HTTP动词的语义和状态代码在版本更改时可以继续工作而无需人工干预。在应用程序的生命周期内，版本将会发展，API可能需要被弃用。对于API的旧版本的请求可以重定向到最新的代码路径，或者可以使用适当的错误代码来指示API已过时。
- en: 'There can be different approaches to version APIs. These are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有不同的方法来对API进行版本控制。这些方法如下：
- en: Specify the version in the URI itself
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URI本身中指定版本
- en: Specify the version in the request query parameter
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求查询参数中指定版本
- en: Specify the version in the `Accept` header
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Accept`标头中指定版本
- en: All of these could work fine. The next section covers the approaches in detail
    and highlights the advantages and disadvantages of each.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以正常工作。下一节将详细介绍方法并突出每种方法的优缺点。
- en: Version in the URI approach
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URI中的版本方法
- en: In this approach, the version is part of the URI for the resource exposed by
    the server.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，版本是服务器公开的资源的URI的一部分。
- en: 'For example, in the following URL, there is a "v2" version exposed as part
    of the path to the resource:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下URL中，作为资源路径的一部分公开了“v2”版本：
- en: '`http://api.foo.com/v2/coffees/1234`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://api.foo.com/v2/coffees/1234`'
- en: 'Additionally, API developers can provide a path, which defaults to the latest
    version of the API. Thus, the following request URIs should behave identically:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，API开发人员可以提供一个路径，默认为最新版本的API。因此，以下请求URI应该表现相同：
- en: '`http://api.foo.com/coffees/1234`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://api.foo.com/coffees/1234`'
- en: '`http://api.foo.com/v2/coffees/1234`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://api.foo.com/v2/coffees/1234`'
- en: 'This indicates v2 is the latest API version. If the clients point to the older
    versions, they should be informed to use the newer versions by using the following
    HTTP code for redirection:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示v2是最新的API版本。如果客户端指向旧版本，则应通知他们使用以下HTTP代码进行重定向以使用新版本：
- en: '`301 Moved permanently`: This indicates that the resource with a requested
    URI is moved permanently to another URI. This status code can be used to indicate
    an old or unsupported API version, informing the API client that a versioned resource
    URI has been replaced by a resource permalink.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`301 Moved permanently`：这表示具有请求的URI的资源已永久移动到另一个URI。此状态代码可用于指示旧的或不受支持的API版本，通知API客户端资源URI已被资源永久替换。'
- en: '`302 Found`: This indicates that the requested resource is temporarily located
    at another location, while the requested URI might still be supported.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`302 Found`：这表示所请求的资源暂时位于另一个位置，而所请求的URI可能仍然受支持。'
- en: Version as part of the request query parameter
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为请求查询参数的一部分的版本
- en: The other way to use API versioning could be to send the version in the request
    parameter. The resource method can choose the flow of code based on the version,
    which is sent with the request. For example, in the `http://api.foo.com/coffees/1234?version=v2`
    URL, v2 has been specified as part of the query parameter `?version=v2`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API版本的另一种方式是将版本发送到请求参数中。资源方法可以根据请求中发送的版本选择代码流程。例如，在`http://api.foo.com/coffees/1234?version=v2`
    URL中，v2已被指定为查询参数`?version=v2`的一部分。
- en: The disadvantage with this format is that the responses may not be cached. Additionally,
    the source code for the resource implementation will have different flows based
    on the version in the query parameter, which is not very intuitive or maintainable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式的缺点是响应可能无法被缓存。此外，资源实现的源代码将根据查询参数中的版本而有不同的流程，这并不直观或易于维护。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More details on the best practices of caching will be covered in [Chapter 4](ch04.html
    "Chapter 4. Designing for Performance"), *Designing for Performance*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有关缓存最佳实践的更多详细信息将在[第4章](ch04.html "第4章。性能设计")中进行介绍，*性能设计*。
- en: In contrast, if the URI contains the version, it is cleaner and more readable.
    Also, there could be a standardized lifespan for a version of URI, after which
    all the requests to older versions get redirected to the latest version.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果URI包含版本信息，那么它会更清晰、更易读。此外，URI的版本可能有一个标准的生命周期，在此之后，对于旧版本的所有请求都会重定向到最新版本。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Facebook, Twitter, and Stripe API all use versions as part of the URI. The Facebook
    API makes a version unusable two years after the date on which the subsequent
    version is released. If a client makes an unversioned call, the server will default
    to the oldest available version of the Facebook API.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook、Twitter和Stripe API都将版本作为URI的一部分。Facebook API在发布后两年内使版本不可用。如果客户端进行未版本化的调用，服务器将默认使用Facebook
    API的最早可用版本。
- en: The Twitter API provides six months to completely transition from v1.0 to v1.1.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter API提供了六个月的时间来完全从v1.0过渡到v1.1。
- en: More details on these APIs will be found in the [Appendix](apa.html "Appendix A. Appendix").
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些API的更多详细信息将在[附录](apa.html "附录A. 附录")中找到。
- en: Specifying the version in the Accept header
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`Accept`头中指定版本
- en: 'Some APIs prefer to put version as part of the `Accept` header. For example,
    take a look at the following code snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一些API更喜欢将版本作为`Accept`头的一部分。例如，看一下以下代码片段：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding snippet, `vnd` stands for vendor-specific MIME type. This removes
    the version for the URL and is preferred by some API developers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，`vnd`代表特定于供应商的MIME类型。这会移除URL的版本，并且受到一些API开发者的青睐。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The GitHub API recommends you send an `Accept` header explicitly, as shown:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub API建议您明确发送`Accept`头，如下所示：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For more details, check [https://developer.github.com/v3/media/](https://developer.github.com/v3/media/).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请查看[https://developer.github.com/v3/media/](https://developer.github.com/v3/media/)。
- en: The next section covers what the standard HTTP response codes that should be
    sent to the client are.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍应该发送给客户端的标准HTTP响应代码。
- en: Response codes and REST patterns
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应代码和REST模式
- en: 'HTTP provides standardized response codes that can be returned for every request.
    The following table summarizes the REST response patterns based on CRUD API. There
    are subtle differences based on the operation used as well as whether the content
    is sent or not as part of the response:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP提供了可以针对每个请求返回的标准化响应代码。以下表格总结了基于CRUD API的REST响应模式。根据使用的操作以及是否将内容作为响应的一部分发送，会有细微的差异：
- en: '| Group | Response code | Description |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 组 | 响应代码 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Success 2XX | `200 OK` | This can be used for the `create`, `update`, or
    `delete` operations with `PUT`, `POST`, or `DELETE`. This returns content as part
    of the response. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 成功 2XX | `200 OK` | 这可以用于使用`PUT`、`POST`或`DELETE`进行`create`、`update`或`delete`操作。这会作为响应的一部分返回内容。|'
- en: '|   | `201 Created` | This can be used when creating a resource with `PUT`.
    This must contain the `Location` header of the resource. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|   | `201 Created` | 这可以用于使用`PUT`创建资源时。它必须包含资源的`Location`头。|'
- en: '|   | `204 No Content` | This can be used for the `DELETE`, `POST`, or `PUT`
    operation. No content is returned as part of the response. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|   | `204 No Content` | 这可以用于`DELETE`、`POST`或`PUT`操作。响应中不返回任何内容。|'
- en: '|   | `202 Accepted` | This sends a response later as processing has not been
    completed as yet. This is used for asynchronous operations. This should also return
    a `Location` header, which can specify where the client can monitor for the request.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|   | `202 Accepted` | 这会在处理尚未完成时稍后发送响应。这用于异步操作。这还应返回一个`Location`头，可以指定客户端可以监视请求的位置。|'
- en: '| Redirectional 3XX | `301 Permanent` | This can be used to show that all requests
    are directed to a new location. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 重定向 3XX | `301 Permanent` | 这可以用于显示所有请求都被重定向到新位置。|'
- en: '|   | `302 Found` | This can be used to show the resource already exists and
    is valid. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|   | `302 Found` | 这可以用于显示资源已经存在且有效。|'
- en: '| Client Errors 4XX | `401 Unauthorized` | This is used to show the request
    can''t be processed based on the credentials. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 客户端错误 4XX | `401 Unauthorized` | 这用于显示基于凭据无法处理请求。|'
- en: '|   | `404 Not Found` | This is used to show the resource is not found. It
    is a good practice to return a `404 Not Found` error to the unauthenticated requests
    to prevent information leaks. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|   | `404 Not Found` | 这用于显示资源未找到。最好的做法是对未经认证的请求返回`404 Not Found`错误，以防止信息泄漏。|'
- en: '|   | `406 Not Acceptable` | This can be used when the resource cannot produce
    the MIME type specified by the client. This happens when the MIME type specified
    in the `Accept` header does not match any media type in the resource method/class
    annotated with `@Produces`. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|   | `406 Not Acceptable` | 这可以用于当资源无法生成客户端指定的MIME类型时。当`Accept`头中指定的MIME类型与使用`@Produces`注释的资源方法/类中的任何媒体类型不匹配时，就会发生这种情况。|'
- en: '|   | `415 Unsupported Media Type` | This can be used when the client sends
    a media type that cannot be consumed by the resource. This happens when the MIME
    type specified in the `Content-Type` header does not match any media type in the
    resource method/class annotated with `@Consumes`. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|   | `415不支持的媒体类型` | 当客户端发送无法被资源消耗的媒体类型时可以使用。当`Content-Type`标头中指定的MIME类型与`@Consumes`注释的资源方法/类中的任何媒体类型不匹配时会发生这种情况。|'
- en: '| Server Errors 5XX | `500 Internal Server error` | This internal server error
    is a generic message when no specific details are available. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 服务器错误5XX | `500内部服务器错误` | 当没有特定细节可用时，这是一个通用的内部服务器错误消息。|'
- en: '|   | `503 Service Unavailable` | This can be used when the server is under
    maintenance or too busy to handle requests. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|   | `503服务不可用` | 当服务器正在维护或太忙无法处理请求时可以使用。|'
- en: 'JAX-RS defines a `javax.ws.rs.core.Response` class, which has static methods
    to create an instance using `javax.ws.rs.core.Response.ResponseBuilder`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS定义了一个`javax.ws.rs.core.Response`类，该类具有使用`javax.ws.rs.core.Response.ResponseBuilder`创建实例的静态方法：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code snippet shows a method `addCoffee()`, which returns a `201
    Created` response using the `Response.created()` method. For more details on other
    response methods, check [https://jersey.java.net/apidocs/latest/jersey/javax/ws/rs/core/Response.html](https://jersey.java.net/apidocs/latest/jersey/javax/ws/rs/core/Response.html).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段显示了一个`addCoffee()`方法，该方法使用`Response.created()`方法返回`201已创建`响应。有关其他响应方法的更多详细信息，请查看[https://jersey.java.net/apidocs/latest/jersey/javax/ws/rs/core/Response.html](https://jersey.java.net/apidocs/latest/jersey/javax/ws/rs/core/Response.html)。
- en: Recommended reading
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐阅读
- en: '[https://jersey.java.net/documentation/latest/representations.html](https://jersey.java.net/documentation/latest/representations.html):
    Jersey documentation for content negotiation'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://jersey.java.net/documentation/latest/representations.html](https://jersey.java.net/documentation/latest/representations.html)：Jersey内容协商的文档'
- en: '[http://docs.jboss.org/resteasy/docs/2.2.1.GA/userguide/html/JAX-RS_Content_Negotiation.html](http://docs.jboss.org/resteasy/docs/2.2.1.GA/userguide/html/JAX-RS_Content_Negotiation.html):
    RESTEasy and URL-based content negotiation'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.jboss.org/resteasy/docs/2.2.1.GA/userguide/html/JAX-RS_Content_Negotiation.html](http://docs.jboss.org/resteasy/docs/2.2.1.GA/userguide/html/JAX-RS_Content_Negotiation.html)：RESTEasy和基于URL的内容协商'
- en: '[https://dev.twitter.com/docs/api/1.1/overview](https://dev.twitter.com/docs/api/1.1/overview):
    Twitter REST API and versioning strategy'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dev.twitter.com/docs/api/1.1/overview](https://dev.twitter.com/docs/api/1.1/overview)：Twitter
    REST API和版本控制策略'
- en: '[https://developers.facebook.com/docs/apps/versions](https://developers.facebook.com/docs/apps/versions):
    The Facebook API and versioning'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.facebook.com/docs/apps/versions](https://developers.facebook.com/docs/apps/versions)：Facebook
    API和版本控制'
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered topics such as content negotiation, API versioning, and REST response
    codes in this chapter. One of the primary takeaways from this chapter was to understand
    how important it is to support various representations of the same resource so
    that the client can choose the right one for their case. We covered differences
    between streaming and chunking output and how they can be used as lightweight
    options with custom entity providers such as `MessageBodyReader` and `MessageBodyWriter`.
    We saw case studies of companies that use versioning in their solutions as well
    as best practices and design principles scattered throughout the various topics.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了内容协商、API版本控制和REST响应代码等主题。本章的一个主要要点是要理解支持同一资源的各种表示形式有多么重要，以便客户端可以为其情况选择合适的表示形式。我们涵盖了流式传输和分块输出之间的差异，以及它们如何作为轻量级选项与自定义实体提供者（如`MessageBodyReader`和`MessageBodyWriter`）一起使用。我们看到了一些公司在其解决方案中使用版本控制的案例研究，以及在各种主题中散布的最佳实践和设计原则。
- en: The next chapter will cover advanced details such as security, traceability,
    and validation in REST programming models.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖REST编程模型中的高级细节，如安全性、可追溯性和验证。

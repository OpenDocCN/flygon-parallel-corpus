- en: Building a Typical Web API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first draft API will be a read-only version and will not support creating
    or updating items in the catalog as real-world applications do. Instead, we will
    concentrate on the API definition itself, and will worry about data storage later
    on. Of course, using file storage for data exposed to millions of users is anything
    but an option, so a database layer will be provided to our application further
    in the book, after we have looked into modern NoSQL database solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We will also cover the topic of content negotiation, a mechanism that allows
    consumers to specify the expected format of requested data. Finally, we will take
    a look at several ways to expose different versions of a service, in case it evolves
    in a backward-incompatible way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, in this chapter, you will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: How to specify a web API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement routes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to query your API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content negotiation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API versioning
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this chapter, you should be able to completely specify a RESTful API and
    will be almost ready to start implementing real-life Node.js RESTful services.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the API
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The very first thing a project usually starts with is a definition of the operations
    the API will expose. According to the REST principles, an operation is exposed
    by an HTTP method and a URI. The action performed by each operation should not
    contradict the natural meaning of its HTTP method. The following table specifies
    the operations of our API in detail:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **URI** | **Description** |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/category` | Retrieves all available categories in the catalog.
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/category/{category-id}/` | Retrieves all the items available under
    a specific category. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| `GET`  |  `/category/{category-id}/{item-id}`  | Retrieves an item by its
    ID under a specific category. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/category` | Creates a new category; if it exists, it will update
    it. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| `POST`  | `/category/{category-id}/`  | Creates a new item in a specified
    category. If the item exists, it will update it. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| `PUT`  |  `/category/{category-id}`  | Updates a category. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/category/{category-id}/{item-id}` | Updates an item in a specified
    category. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/category/{category-id}` | Deletes an existing category. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/category/{category-id}/{item-id}` | Deletes an item in a specified
    category. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: 'The second step is to choose an appropriate format for our catalog application''s
    data. JSON objects are natively supported by JavaScript. They are easy to extend
    during the evolution of an application and are consumable by almost any platform
    available. Thus, the JSON format seems to be our logical choice for us. Here is
    the JSON representation of an item, and category objects that will be used throughout
    this book:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So far, our API has defined a set of operations and the data format to be used.
    The next step is to implement a  module that will export functions serving each
    of the operations in the route.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, let's create a new Node.js Express project. Select a directory
    where your projects will be stored and from your shell Terminal, execute `express
    chapter3`. If you are using Windows, you will need to install the `express-generator`
    module before generating the project. The `express-generator` will create your
    an initial express project layout in the selected directory. This layout provides
    the default project structure for you, ensuring that your Express project follows
    the standard project structure. It makes your project easier to navigate.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to import the project into the Atom IDE. Right-click anywhere
    in the Projects tab and select Add project folder then select the directory Express
    generated for you.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, Express has done some background work for us and has created
    a starting point for our application: `app.js`. It has also created the `package.json`
    file for us. Let''s take a look at each of these files, starting with `package.json`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we created a blank Node.js Express project, we initially have dependencies
    only to the Express framework, some middleware modules such as `morgan`, `body-parser`,
    and `cookie-parser`, and the Jade template language. Jade is a straightforward
    template language used to produce HTML code inside templates. If you are interested
    in it, you can find out more about it at [http://www.jade-lang.com](http://www.jade-lang.com/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The current version of the Express framework at the time of writing is 4.16.1;
    to update it, execute `npm install express@4.16.1 --save` from the `chapter3`
    directory. This command will update the dependency of the application to the desired
    version. The `--save` option will update and save the new version of the dependency
    in the project's `package.json` file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: When you introduce new module dependencies, it is up to you to keep the `package.json`
    file up to date in order to maintain an accurate state of the modules your application
    depends on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: We will come to what middleware modules are a bit later in the chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will ignore the content of the `public` and `view` directories as
    it is not relevant to our RESTful service. They contain the auto-generated stylesheets
    and template files that might be helpful, if we decide to develop a web-based
    consumer of the services at a later stage.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already mentioned that the Express project created a starting point
    for our web application in `app.js`. Let''s take a deeper look at it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Obviously, the Express generator has done a lot for us as it has instantiated
    the Express framework and has assigned a complete development environment around
    it. It has done the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Configured the middleware to be used in our application, `body-parser`, the
    default router, as well as error handler middleware for our development environment
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injected a logger instance of the morgan middleware module
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configured the Jade template, as it has been selected as the default template
    for our application
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configured the default URI that our Express application will be listening to, `/`
    and `/users`, and created dummy handle functions for them
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will have to install all the modules used in `app.js` in order to start
    the generated application successfully. Also, make sure you update the dependencies
    of your `package.json` file using the `--save` option after installing them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The Express generator also created a starting script for the application. It
    is under the  `bin/www`directory of your project and looks like the following
    snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To start the application, execute `node bin/www`; this will execute the script
    above and will start the Node.js application. So requesting `http://localhost:3000`
    in your browser will result in calling the default `GET` handler, which gives
    a warm welcome response:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6edf1a93-d7b2-4d91-8d56-7c73ec1628d1.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Default welcome message from an Express application
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The generator created a dummy `routes/users.js`; it exposes a route linked
    to a dummy module available at the `/users` location. Requesting it will result
    in calling the `list` function of the user''s route, which outputs a static response:
    `respond with a resource`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application will not be using a template language and style sheets, so
    let''s get rid of the lines that set the views and view engine properties in the
    application configuration. In addition, we will be implementing our own routes.
    Thus, we don''t need the binding of the `/` and `/users` URIs for our app, neither
    do we need the `user` module; instead, we will utilize a `catalog` module and
    from a route:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So after this cleanup, our application looks a lot cleaner and we are ready
    to move forward.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Before doing that, though, there is one term that needs further explanation:
    middleware. It is a subset of chained functions called by the `Еxpress.js` routing
    layer before а user-defined handler is invoked. Middleware functions have full
    access to the `request` and `response` objects and can modify either of them.
    The middleware chain is always called in the exact order in which it has been
    defined, so it is vital for you to know exactly what a specific piece of middleware
    is doing. Once a middleware function finishes, it calls the next function in the
    chain by invoking its next argument as a function. After the complete chain gets
    executed, the user-defined request handler is called.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the basic rules that apply to the middleware chain:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'A middleware function has the following signature: `function (request, response, next)`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware functions are executed in the exact order in which they have been
    added to the application chain. This means that if you want your middleware function
    to be called before a specific route, you need to add it before declaring the
    route.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware functions use their third parameter, `next`, as a function to indicate
    that they have completed their work and to exit. When the `next()` parameter of
    the last function in the chain has been called, the chained execution is completed
    and the `request` and the `response` objects reach the defined handlers, in the
    state set by the middleware.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know what a middleware function is, let's clarify what the currently
    used middleware functions provide our application with. The `body-parser` middleware
    is the Express framework built in a parser. It parses the `request` body and populates
    the `request` object after the middleware execution finishes, that is, it provides
    JSON payload handling.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to move on and implement our user module that will be mapped
    to our URIs. The module will be named `modules/catalog.js`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The catalog module is built around the `catalog.json` file, stored in the `data`
    directory. The content of the source file is read synchronously using the File
    System module, `fs`, within the `readCatalogSync` function. The File System module
    provides multiple useful filesystem operations such as functions for creating,
    renaming, or deleting files or directories; truncating; linking; `chmod` functions;
    as well as synchronous and asynchronous file access for reading and writing data.
    In our sample application, we aim to use the most straightforward approach, so
    we implement functions that read the `catalog.json` file by utilizing the `readFileSync`
    function of the File System module. It returns the content of a file as a string,
    within a synchronous call. All other functions of the module are exported and
    can be used to query the content of the source file, based on different criteria.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'The catalog module exports the following functions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`findCategories`: This returns an array of JSON objects containing all the
    categories in the `catalog.json` file'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findItems (categoryId)`: This returns an array JSON objects representing all
    the items in a given category'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findItem(categoryId, itemId)`: This returns a JSON object representing a single
    item in a given category'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have three complete functions, let's see how to bind them to our
    Express application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Implementing routes
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Node.js terms, a route is a binding between a URI and function. The Express
    framework provides built-in support for routing. An `express` object instance
    contains functions named after each HTTP verb: `get`, `post`, `put`, and `delete`.
    They have the following syntax: `function(uri, handler);`. They are used to bind
    a handler function to a specific HTTP action executed over a URI. The handler
    function usually takes two arguments: `request` and `response`. Let''s see it
    with a simple `Hello route` application:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running this sample at localhost and accessing `http://localhost:3000/hello`
    will result in calling your handler function and it will respond saying `Hello
    route`, but routing can give you much more. It allows you to define a URI with
    parameters; for example, let''s use `/hello/:name` as a routing string. It tells
    the framework that the URI used consists of two parts: a static part (`hello`)
    and a variable part (the `name` parameter).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, when the routing string and the handler function are defined in
    line with the `get` function of an Express instance, a parameter collection is
    made available directly in the `request` argument of the handler function. To
    demonstrate this, let''s modify our previous example a bit:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in the preceding code snippet, we used a colon (`:`) to separate
    the parameter part of the URI from the static part. You can have multiple parameters
    in an Express route; for example, `/category/:category-id/items/:item-id`defines
    a route for displaying an item that belongs to a category, where the `category-id`
    and `item-id` are parameters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try it out. Requesting `http://localhost:3000/hello/friend` will
    result in the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is how we can provide parameterized URIs with Express. It is a nice feature,
    but it is often not enough. In web applications, we are used to providing additional
    parameters with `GET` parameters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the Express framework is not so good with `GET` parameters.
    Thus, we have to utilize the `url` module. It is built into Node.js to provide
    an easy way of using URL parsing. Let''s use our `hello` result with other parameters
    in the application again, but extend it in a way that it outputs `hello all` when
    `/hello` is requested and `hello friend` when the requested URI is `/hello?name=friend`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are a few things worth mentioning here. We used the `url` module's function
    `parse`. It takes a URL as its first argument and a Boolean as an optional second
    argument, which specifies whether the query string should be parsed or not. The
    `url.parse` function returns an associative object. We used `Object.keys` with
    it to transform the keys in these associative objects into an array so that we
    can check its length. This will help us check whether our URI has been called
    with `GET` parameters or not. In addition to the routing functions named after
    each HTTP verb, there is also a function named `all`. When used, it routes all
    the HTTP actions to the specified URI.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how routing and the `GET` parameters work within Node.js and
    the Express environment, we are ready to define a route for the `catalog` module
    and bind it in our application. The following is the route as defined in `routes/catalog.js`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'First, a `Router` instance is created from the Express module. Here is a table
    that nicely describes the routing we just implemented. This will be helpful later
    when we test our API:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP method** | **Route** | **Catalog''s module function** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/catalog` | `findCategories()` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/catalog/:categoryId` | `findItems(categoryId)`  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/catalog/:categoryId/:itemId` | `findItem(categoryId, itemId)`  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: Querying the API using test data
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need some test data in order to test our service, so let's use the `catalog.json`
    file in the `data` directory of our project. This data will allow us to test all
    our three functions, but to do that, we would need a client that can send REST
    requests against an endpoint. If you still haven't created a Postman project for
    testing your application, now is an appropriate time to create it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Requesting `/catalog` should return all the categories in the `test` file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbb3692b-d7fe-4b4d-8296-edaa181a5a7e.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: 'Thus, requesting `/catalog/1` should result in returning a list with all the
    items under the `Watches` category:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2930458-a2e5-4167-a9a6-e1302dc820ae.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 'Finally, requesting `http://localhost:3000/catalog/1/item-identifier-1` would
    display only the item identified by `item-identifier-1`, and requesting a nonexistent
    item would result in response with status code `404`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/136fe902-939f-4458-bcfb-a58d74b7ddba.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: Content negotiation
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the catalog service supports only the JSON format, and thus works only
    with the media type `application/json`. Let's assume our service has to offer
    data in different formats, for example, both JSON and XML. Then, the consumer
    needs to explicitly define the data format they need. The best way to carry out
    content negotiation in REST has been a very debatable subject for a long time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'In his famous discussion on implementing content negotiation correctly, Roy
    Fielding states the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: All important resources must have URIs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'However, that leaves a gap on how to expose the same resource in a different
    data format, so Roy continues with the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Agent-driven negotiation is far more effective, but there was a huge disagreement
    between myself and the chair of the HTTP working group and my original agent-driven
    design for HTTP/1.1 was effectively buried in committee. To do negotiation right,
    the client needs to be aware of all the alternatives and what it should use as
    a bookmark.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: While one can still choose to stick with a URI-driven negotiation by providing
    the desired format with custom `GET` parameters, the REST community has chosen
    to stick to Roy's suggestion for agent-driven negotiation. Now that it has been
    almost a decade since this argument was initiated, it has been proven that they
    took the right decision. Agent-driven negotiation makes use of the `Accept` HTTP
    header.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The `Accept` HTTP header specifies the media type of the resource that the consumer
    is willing to process. In addition to the `Accept` header, the consumer may also
    make use of the `Accept-Language` and `Accept-Encoding` headers to specify what
    language and encoding the results should be provided in. If the server fails to
    provide the results in the expected format, it can either return a default value
    or make use of `HTTP 406 Not acceptable` in order not to cause data confusion
    errors on the client side.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'The Node.js HTTP `response` object contains a method, `format`, that performs
    content negotiation based on the `Accept` HTTP header if set in the `request`
    object. It uses the built-in `request.accepts()` to select an appropriate handler
    for the request. If that is not found, the server invokes the default handler,
    which responds with `HTTP 406 Not acceptable`. Let''s create a demo on how to
    use the `format` method within one of our routes. For that purpose, let''s assume
    we have implemented a function within our `catalog` module, named `list_groups_in_xml`,
    that provides the group data in XML format:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is how you can implement content negotiation in a clear and straightforward
    way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: API versioning
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is an inevitable fact that all application APIs evolve. However, the evolution
    of public APIs with an unknown number of consumers, such as RESTful services,
    is a sensitive topic. As consumers may not be able to handle the modified data
    appropriately and there is no way of notifying all of them, we need to keep our
    APIs as backward-compatible as possible. One way to do so is to use different
    URIs for different versions of our application. Currently, our catalog API is
    available at `/catalog`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: When the time is right for a new version, for example, Version 2, we may need
    to keep the previous version available at another URI for backward-compatibility.
    Best practice is to encode the version number in the URI, such as `/v1/catalog`,
    and keep `/catalog` mapped to the latest version. Thus, requesting `/catalog`
    will cause a redirect to `/v2/catalog` and will make use of the HTTP `3xx` status
    codes to indicate the redirection to the latest version.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Another option for versioning would be to keep the URI of your API stable and
    rely on custom HTTP headers that will specify the version. But that's not very
    stable approach concerning backward-compatibility as it is much more natural to
    modify a URL of a request in an application rather than modify the headers that
    are sent within the request.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个版本控制的选项是保持API的URI稳定，并依赖自定义的HTTP标头来指定版本。但这并不是一个非常稳定的方法，因为与其在请求中修改发送的标头，不如在应用程序中修改请求的URL更自然。
- en: Self-test questions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'To get additional confidence, go through this set of statements and state whether
    they are true or false:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得额外的信心，请浏览这组陈述，并说明它们是真还是假：
- en: A REST-enabled endpoint must support all HTTP methods relevant to the REST principles
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST启用的端点必须支持与REST原则相关的所有HTTP方法。
- en: When content negotiation fails, due to an unsupported media type passed as a
    value of the accepts header, 301 is the appropriate status code.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当内容协商失败时，由于接受标头的值作为不支持的媒体类型，301是适当的状态代码。
- en: When using parameterized routes, the developer can specify the type of the parameter,
    for example, whether it is a numeric or a literal type.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用参数化路由时，开发人员可以指定参数的类型，例如，它是数字类型还是文字类型。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we dived into some more complex topics. Let's sum up what we
    covered. We started by specifying the operations of our web API and defined that
    an operation is a combination of a URI and HTTP action. Next, we implemented routes
    and bound them to an operation. Then, we requested each operation using the Postman
    REST client to request the URIs that we routed. In the content negotiation section,
    we handled the `Accept` HTTP header to provide the results in the format requested
    by consumers.  Finally, we covered the topic of API versions, which allow us to
    develop backward-compatible APIs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了一些更复杂的主题。让我们总结一下我们所涵盖的内容。我们首先指定了我们的Web API的操作，并定义了操作是URI和HTTP动作的组合。接下来，我们实现了路由并将它们绑定到一个操作。然后，我们使用Postman
    REST客户端请求每个操作以请求我们路由的URI。在内容协商部分，我们处理了`Accept` HTTP标头，以便按照消费者请求的格式提供结果。最后，我们涵盖了API版本的主题，这使我们能够开发向后兼容的API。
- en: We used old-fashioned filesystem storage for our data in this chapter. This
    is not suitable for a web application. Thus, we will look into modern, scalable,
    and reliable NoSQL storage in the next chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对我们的数据使用了老式的文件系统存储。这对于Web应用程序来说并不合适。因此，我们将在下一章中研究现代、可扩展和可靠的NoSQL存储。

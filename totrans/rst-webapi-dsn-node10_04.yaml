- en: Using NoSQL Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we implemented a sample application exposing a read-only
    service that provided catalog data. For the sake of simplicity, we introduced
    a performance bottleneck in this implementation by using file storage. This storage
    is not suitable for web applications. It relies on 33 physical files, preventing
    our application from servicing heavy loads, as file storage lacks multitenant
    support due to disc I/O operations. In other words, we definitely need to look
    for a better storage solution, which scales easily, when needed, following the
    demands of our REST-enabled application. NoSQL databases are now heavily used
    in web and in cloud environments, ensuring zero downtime and high availability.
    They have the following advantages over traditional transactional SQL databases:'
  prefs: []
  type: TYPE_NORMAL
- en: They **support schema versions**; that is, they can work with object representations
    rather than filling the object state based on definitions of one or several tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are **extensible**, because they store an actual object. Data evolution
    is supported implicitly, so all you need to do is call the operation that stores
    the modified object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are designed to be **highly distributed** and **scalable**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nearly all modern NoSQL solutions out there support clustering and can scale
    further, along with the load of your application. Additionally, most of them have
    REST-enabled interfaces over HTTP, which eases their usage over a load balancer
    in high-availability scenarios. Classical database drivers are usually not available
    for traditional client-side languages, such as JavaScript, because they require
    native libraries or drivers. However, the idea of NoSQL originated from using
    document data stores. Thus, most of them support the JSON format, which is native
    to JavaScript. Last but not least, most NoSQL solutions are open source and are
    available for free, with all the benefits that open source projects offer: community,
    examples, and freedom!'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at the MongoDB NoSQL database and the Mongoose
    module that interacts with it. We will see how to design and implement automated
    tests for the database models. Finally, at the end of the chapter, we will remove
    the file storage bottleneck and will move our application to an almost ready for
    production state.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB – a document store database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is an open source document database with built-in support for the JSON
    format. It provides a full index support, based on any of the available attributes
    in a document. It is ideal for high-availability scenarios due to its scalability
    features. MongoDB, available at [https://mms.mongodb.com](https://mms.mongodb.com/),
    is cloud-ready with its management services, **MongoDB Management Services** (**MMS**).
    They utilize and automate most development operations that need to be carried
    out to keep your cloud database in good shape, taking care of upgrades, further
    scaling, backups, recovery, performance, and security alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move forward and install MongoDB. Installers for Windows, Linux, macOS,
    and Solaris are available at [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads).
    Linux users can find MongoDB in all popular distribution repositories, while Windows
    users can make use of a user-friendly wizard which will guide you through the
    installation steps, where, for a typical installation, all you need to do is accept
    the license agreement and provide an installation path.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a successful installation, execute the following command to start MongoDB.
    If you want to specify a custom location for your data, you have to use the `--dbpath`
    argument. Optionally, you can start the MongoDB HTTP console via the `--rest`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The default port for communicating with MongoDB is `27017`, and its HTTP console
    is implicitly configured to use a port higher than the data port by a value of
    1,000\. Therefore, the default port of the console will be `28017`. The HTTP console
    provides useful information about the database, such as logs, health status, available
    databases, and so on. I strongly advise you to spend some time with it. The console
    can also be used as a RESTful health check service of the database, because it
    provides JSON-encoded information about the running database services and the
    last error that occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This REST interface can be used in a script or an application to automate altering
    notifications providing the current state of the database engine and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The log section of the console shows that your server is running successfully
    (if it is). Now we are ready to move further and see how to connect Node.js to
    MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Database modeling with Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mongoose** is a module that connects Node.js to MongoDB in an **object document
    mapper** (**ODM**) style. It offers the **Create, Read, Update, and Delete** (also
    known as **CRUD**) functionalities for documents stored in the database. Mongoose
    defines the structure of the used documents using schemas. The schema is the smallest
    unit of data definition in Mongoose. A model is built out of a schema definition.
    It is a constructor-like function that can be used to create or query documents.
    Documents are instances of a model and represent one-to-one mapping to the documents
    stored in MongoDB. The schema-model-document hierarchy provides a self-descriptive
    way of defining objects and allows easy data validation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by installing Mongoose with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the Mongoose module installed, our first step will be to define
    a schema that will represent an item in the catalog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet creates a schema definition of an item. Defining
    a schema is straightforward and is quite similar to JSON schema definition; you
    have to describe and attribute with its type and optionally provide additional
    properties for each key. In the case of the catalog application, we need to use
    the `itemId` as a unique index in order to avoid having two different items with
    the same ID. Thus, apart from defining its type as `String`, we also use the `index`
    attribute to describe that the value of the `itemId` field must be unique for
    each individual item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mongoose introduces the term **model**. A model is a constructor-like function
    compiled out of a schema definition. An instance of a model represents a document
    that can be saved to or read from the database. Creating a model instance is done
    by calling the `model` function of a `mongoose` instance and passing the schema
    that the model should use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A model also exposes functions for querying and data manipulations. Assuming
    that we have initialized a schema and created a model, storing a new item to MongoDB
    is as simple as creating a new `model` instance and invoking its `save` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how to use the model in order to query for documents representing a
    sports watch belonging to the `Watches` group named `Sports Watches`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The model also exposes a `findOne` function, a convenient way of finding an
    object by its unique index and then performing some data manipulation on it, that
    is, for delete or update operations. The following example deletes an item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Testing a Mongoose model with Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mocha is one of the most popular testing frameworks for JavaScript; its main
    goal is to provide an easy way to test asynchronous JavaScript code. Let''s install
    Mocha globally so that we can make it available to any Node.js application that
    we may develop in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need an assertion library that can be used together with Mocha.
    The assertion library provides functions for validating actual values, against
    expected ones, when they are not equal, the assertion library will cause test
    failure.  `Should.js` assertion library module is easy to use and it will be our
    choice, so let''s install it globally too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our testing modules installed, we need to specify our `testcase`
    file path in the `package.json` file. Let''s modify it by adding a `test` element
    pointing to Mocha and the `testcase` file in the script node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will tell the npm package manager to trigger Mocha when the `npm` test
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automation of Mongoose tests must not be affected by the current state of the
    database. To ensure that the results are predictable at each test run, we need
    to ensure that the database state is exactly as we would expect it. We will implement
    a module called `prepare.js` in the `test` directory. It will clear the database
    before each test run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will implement a Mocha test, which creates a new item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Executing the `npm test` now results in a call against the MongoDB database
    creating an item out of the passed JSON object. After insertion, the assert callback
    will be executing, ensuring that values passed to by Mongoose are the same as
    the returned ones from the database. Give it a try and break the test—simply change
    the expected value in the assert with an invalid one—you will see the test failing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user-defined model around a Mongoose model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After seeing how a model works, it is time to create a user-defined module
    that wraps all CRUD operations for the catalog. Since we intend to use that module
    in a RESTful web application, it seems logical to leave the schema definition
    and the model creation outside the module and have them provided as arguments
    of each module function. The same schema definition is used in the unit tests,
    ensuring stability of the module. Now let''s add an implementation for each CRUD
    function, starting with a `remove()` function. It looks up an item based on its
    `id` and deletes it from the database, if it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `saveItem()` function takes the request body payload as an argument. A
    valid update request will contain the new state of an `item` object, represented
    in JSON format. First, the `itemId` is parsed out of the JSON object. Next, lookup
    is done. If an item exists, it gets updated. Otherwise, a new one gets created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toItem()` function converts the JSON payload to a `CatalogItem` model
    instance, that is, an item document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to provide a means of querying data, so let''s implement
    a function that queries for all items in a category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to `findItemsByCategory`, the following is a function that finds an
    item by its ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there''s a function that lists all the catalog items stored in the
    database. It uses the Mongoose model `find` function that looks for all documents
    of the model, and uses its first arguments as a filter. We want a function that
    returns all existing documents; that''s why we provide an empty object. This will
    return all available items. The results are available in the `callback` function,
    which is the second argument of the model''s `find` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `catalog` module will be the foundation of our RESTful service. It is responsible
    for all data manipulation operations, as well as for different kinds of queries.
    It encapsulates all operations in a reusable way.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up a NoSQL database module to Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have automated tests for the model and a user-defined module which makes
    use of them. This ensures the stability of the module and makes it ready for wider
    adoption.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to build a new Express-based application and add a route, exposing
    the new module to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To sum up, we routed each function of the catalog data service module to an
    operation of a RESTful service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /catalog/item/:itemId`: This calls `catalog.findItemById()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /catalog`: This calls `catalog.saveItem()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /catalog`: This calls `catalog.saveItem()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE / catalog/item/:id`: This calls `catalog.remove()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /catalog/:category`: This calls `catalog.findItemsByCategory()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /catalog/`: This calls `catalog.findAllItems()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we have our operations exposed, we are ready to perform some more serious
    REST testing. Let''s start Postman and test the newly exposed endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/484b04fb-0f1b-4977-83e4-564dee530a13.png)'
  prefs: []
  type: TYPE_IMG
- en: Spend some time testing each operation thoroughly. This will help you gain confidence
    that the catalog data service module really works, and also will make you more
    comfortable with how HTTP responses are served and read. As a RESTful API developer,
    you should be able to read HTTP dumps, which show different request payloads and
    status codes, fluently.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How would you perform a query with Mongoose for a single value of a multivalued
    attribute?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a strategy for testing a Node.js module manipulating a NoSQL database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at MongoDB, a powerful document-oriented database.
    We utilized it and made use of Mocha to implement an automated test for the database
    layer. Now it is time to build a fully-fledged RESTful web service. In the next
    chapter, we will extend the user-defined module by including support for searching
    via document attributes, and add filtering and pagination capabilities that will
    finally evolve into full-fledged RESTful service implementation.
  prefs: []
  type: TYPE_NORMAL

- en: Consuming a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate some more advanced topics related to the consumption of our
    API, we will implement a really simple web client. It will help us cover those
    topics, and it can serve as a reference implementation for the catalog''s consumers.
    For this frontend client, we will use the famous JavaScript library, jQuery. Utilizing
    it will help us cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Consuming RESTful services with jQuery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content Delivery Network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting and identifying problems on the wire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side handling of different HTTP status codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming RESTful services with jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JQuery is a fast, light, and powerful JavaScript library; it eliminates DOM-related
    complexity by providing direct access to HTML elements once the DOM three has
    been loaded. To use jQuery within an HTML document, you have to import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<script type="text/javascript" src="img/jquery-3.3.1.min.js "></script>`'
  prefs: []
  type: TYPE_NORMAL
- en: Assume that somewhere within an HTML document, there is a button defined as `<input
    type="button" id="btnDelete" value="Delete"/>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To assign a function to the click event of this button with JQuery means we
    need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the jquery library in the HTML document
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assure that the DOM document of the HTML document is completely loaded
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the button using the identifier defined by the ID attribute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide a handler function as an argument to the `click` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `$('#identifier')` expression provides direct access to elements in DOM
    three, `$` states that an object is referenced, and the value within the bracket,
    prefix by `#` specifies its identifier. jQuery will have access to the element
    only after the entire document has been loaded; that's why elements should be
    accessed within `${document).ready()` block scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can access the value of a text input with an identifier `txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `$(document)`object is predefined in jQuery and represents the entire DOM
    document of the HTML page. In a similar way, jQuery predefines a function for
    AJAX-enabled communication, that is, for sending HTTP request to an HTTP endpoint.
    This function is named after **Asynchronous JavaScript + XML-** AJAX, which was
    the de facto standard that enabled a JavaScript application to communicate with
    HTTP-enabled backends. Nowadays, **JSON** is being widely used; however, naming
    conversion for AJAX is still used as a term for asynchronous communication, regardless
    of the data format; that is why the predefined function in jQuery is called `$.ajax(options,
    handlers)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send an http request with the `$.ajax` function, invoke it by providing
    the endpoint URL, http method for the request, and its content type; the result
    will be returned in a callback function. The following example shows how an item
    with identifier 3 is requested from our catalog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Posting data to an endpoint is rather similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Simply use the appropriate options `type` set to POST, and the `dateType` set
    to JSON. Those will specify that a POST request is to be sent to the endpoint
    in the JSON format. The payload of the object is provided as a value to the `data`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking a `delete` method is quite similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A basic understanding of how jQuery works is just about fine for the scope
    of this book. Now, let''s glue all this together and create two HTML pages; that
    way, we will handle creating, displaying, and deleting an item in our catalog,
    starting with the page that displays an item and allows its deletion. This page
    loads an item from the catalog using `GET` request, and then displays the item''s
    attributes in the HTML page in a table-like manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The page that handles creation is quite similar. However, it provides text
    inputs instead of span labels for an item''s fields, where the view page will
    display the data for the attributes of the loaded item. JQuery provides a simplified
    access model to the input controls, rather than DOM—simply access the input element
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s give that a try and load an existing item in the view page by opening
    our static page directly from the filesystem in a browser of your choice. It looks
    as if we have some kind of a problem, as nothing gets displayed. Enabling client-side
    debugging using the browser''s developer suite doesn''t give much more information
    either:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c54635c-5e0f-44c1-9111-0f58c85da144.png)'
  prefs: []
  type: TYPE_IMG
- en: It states that the content is partially blocked; however, it is not quite clear
    whether this is due to a backend-related error, or something has gone wrong on
    the client side. We will look at how to troubleshoot such problematic situations
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting and identifying problems on the wire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the interaction between the client and the server fails, and the reason
    for such failures often requires analysis; otherwise, their root cause stays unknown.
    We spotted that our client application does not load and thus doesn't display
    data for an existing item. Let's try to investigate the root cause for that by
    setting up an `http` tunnel between the client and the server. This will be a
    kind of MiM (man-in-the-middle)-based investigation, as we will listen to one
    port and redirect the incoming request to another, to see whether the server returns
    correct responses or its pipe gets broken somewhere in the middle. There are various
    TCP tunnels available out there; I have been using a simple open source one available
    on GitHub at [https://github.com/vakuum/tcptunnel](https://github.com/vakuum/tcptunnel).
    Its author also maintains a separate website where you can download prebuilt binaries
    for the most common operating system; they are available at [http://www.vakuumverpackt.de/tcptunnel/](http://www.vakuumverpackt.de/tcptunnel/).
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have built or downloaded a copy of the tunnel, start it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./tcptunnel --local-port=3001 --remote-port=3000 --remote-host=localhost --log`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will start the application listening on port 3001 and will forward each
    incoming request to location port 3000; the `--log` option specifies that all
    the data flow passing the tunnel should be logged in the console. Finally, modify
    HTML pages to use port 3001 instead of 3000, and let''s see what the tunnel would
    show us after firing new GET request for the item with id 3, this time on port
    `3001: http://localhost:3001/catalog/v2/item/3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3df9739-15a8-4bb8-90d2-4087c09b1d2d.png)'
  prefs: []
  type: TYPE_IMG
- en: Surprisingly, the tunnel shows that the server responds normally with `200 OK`
    and a relevant payload. So it seems as if the problem is not on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, since the error is obviously not on the server side, let''s try to investigate
    deeper what has happened on the client side. Nowadays, all popular browsers have
    so-called web developer tools. They provide access to `http` logs, dynamically-rendered
    code, the DOM three of the HTML document, and so on. Let''s invoke our RESTful
    GET operation with Mozillas Firefox and see what its web console will log about
    our request. Open the Mozilla Firefox menu and select `Web Developer`, and then
    select `Browser Console`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4eec8a4-25a7-4a10-85b7-d6482497eaf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Aha! Seems like we found it: `Cross-Origin Request Blocked: The Same Origin
    Policy disallows reading the remove resource at...`.'
  prefs: []
  type: TYPE_NORMAL
- en: This error is blocking the server-side response at client level. In the next
    section, we will see what this actually means.
  prefs: []
  type: TYPE_NORMAL
- en: Cross Origin Resource Sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-site HTTP requests are requests that refer to resources to be loaded from
    a domain different from the one that initially requested them. In our case, we
    started the client from our filesystem, and it requested resources from a network
    address. This is considered a potential **Cross-site scripting** request, which,
    according to the **W3C recommendation** at [http://w3.org/cors/TR/cors](http://w3.org/cors/TR/cors),
    should be carefully handled. This means that if an external resource is requested,
    the domain where it is requested from—its Origin—should be explicitly specified
    in a header, as long as an external resource loading is not allowed in general.
    This mechanism prevents Cross-Side Scripting (XSS) attacks, and it is based on
    HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following HTTP request headers specify how external resources should be
    handled on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Origin` defines where the request originated from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Access-Control-Request-Method` defines the HTTP method that was used to request
    the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Access-Control-Request-Header` defines any headers that will be allowed in
    combination with the external resource request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the server side,  the following headers indicate whether a response is eligible
    for a CORS-enabled client request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Access-Control-Allow-Origin`: This header either, if exists, specifies that
    the requester''s host is allowed by repeating it, or it could specify that all
    remote origins are allowed by returning a wildcard: ''*'''
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Access-Control-Allow-Methods`: This header specifies the HTTP methods that
    the server would allow from cross-side''s domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Access-Control-Allow-Headers`: This header specifies the HTTP headers that
    the server would allow from cross-side''s domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some more `Access-Control-*` headers that can be used for further
    granularity when incoming XSS requests are to be served, or not, based on credentials
    and request's max-age, but basically, the most important ones are for the allowed
    origin, allowed methods, and allowed headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a node module that handles `CORS` configuration at server side; it
    is installed by `npm install -g cors` and is easily enabled in our application
    via a middleware module. Simply use it in all the exposed routes by passing it
    to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the tunnel after you enabled the `cors` middleware to see that the server
    would now gracefully handle requests from different origins by serving the "Access-Control-Allow-Origin''
    header set to ''*''":'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2db6ec99-1e04-47b4-9594-6e62b00af25e.png)'
  prefs: []
  type: TYPE_IMG
- en: Content Delivery Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we imported the jQuery library into our client application, we directly
    referred to its optimized source from its vendor as `<script type="text/javascript"
    src="img/jquery-3.3.1.min.js "/>`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that for some reason this site goes down either temporarily or
    for good; this will make our application unusable, as the import wouldn't work.
  prefs: []
  type: TYPE_NORMAL
- en: Content Delivery Networks come to help in these cases. They serve as a repository
    for libraries or other static media content, assuring that the needed resources
    will be available without downtime, even when something goes wrong with their
    vendors. One of the most popular JavaScript CDNs is [https://cdnjs.com/](https://cdnjs.com/);
    it provides the most common JS libraries available out there. We will switch our
    clients to refer to the jquery library from this CDN rather than from its vendors'
    website at `<script type="text/javascript" src="img/jquery-3.3.1.min.js "/>`.
  prefs: []
  type: TYPE_NORMAL
- en: While there is hardly anything wrong with directly downloading your JS libraries
    and placing them in the static directory of your node.js project, it may lead
    to having local changes and fixes directly in your library dependencies. This
    can easily result in incompatible changes and can prevent your application from
    easily switching to newer versions in the future. As long as your dependencies
    are open source, you should strive to improve them by contributing fixes or reporting
    bugs rather than having fixes in your own local fork. Still, if you are unfortunate
    enough to run into a bug that you can easily fix, you can fork the library to
    resolve your problem faster. However, always consider contributing the fix back
    to the community. After it is accepted, switch back to the official version; otherwise,
    you will find yourself in a difficult situation the next time with another issue,
    and the community would track it much harder if reported from a forked version.
    That is the beauty of open source, and that is why you should always consider
    consuming JavaScript APIs' Content Delivery Networks. They will provide you with
    the stability and support you may need at any point in the life of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTP status codes on the client side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We spent quite some time addressing how RESTful services should represent each
    state, including erroneous ones, gracefully. A well-defined API should demand
    from its consumers to handle all its errors gracefully and to provide as much
    information per state as required, rather than just stating "An error has occurred".
    That is why it should look up the returned status code and clearly distinguish
    between client requests such as `400 Bad Request` or `415 Unsupported media types`
    caused by faulty payload, caused by wrong media types, or authentication-related
    errors, such as `401 Unauthorized`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The status code of an erroneous response is available in the `error` callback
    of the jQuery callback function and should be used to provide detailed information
    back to the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Unsuccessful requests are handled by the error callback function. It provides
    `jqXHR` - the `XmlHttpRequest` JavaScript*—*object as its first argument. It carries
    across all the request/response related information, such as status code and headers.
    Use it to determine what the requested server has returned so that your application
    can handle different errors more granularly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented a simple web-based client with the jQuery library.
    We utilized this client to demonstrate how the Cross-Origin Resource Sharing policy
    works, and we used a man in the middle means to troubleshoot issues on the wire.
    Finally, we looked at how errors should be handled on the client side. This chapter
    brings us one step closer to the end of our journey, as we got the first consumer
    of our service. In the next chapter, we will walk you through the final step before
    bringing a service to production—choosing its security model.
  prefs: []
  type: TYPE_NORMAL

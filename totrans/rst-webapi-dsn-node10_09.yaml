- en: Securing the Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once deployed in production, an application is exposed to a large number of
    requests. Inevitably, some of them will be malicious. This brings the requirement
    of granting explicit access permissions only to authenticated users, that is,
    authenticating a selected number of consumers to have access to your service.
    Most of the consumers will use the service only for data provisioning. However,
    a few will need to be able to provide new, or modify the existing, catalog data.
    To ensure that only appropriate consumers will be able to execute the `POST`,
    `PUT`, and `DELETE` requests, we will have to introduce the concept of authorization
    into our application, which will grant only explicitly selected users modification
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Data services may provide sensitive private information, such as email addresses;
    the HTTP protocol, being a text protocol, may not be secure enough. The information
    transmitted through it is subject to **man-in-the-middle** attacks, which can
    lead to data leakage. To prevent such cases, **Transport Layer Security **(**TLS**)
    should be used. The HTTPS protocol encrypts the transmitted data, ensuring that
    only appropriate consumers who have the right decryption key will be able to consume
    the data exposed by the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at how Node.js enables the following security
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passport-based basic authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passport-based third-party authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transport layer security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application considers a user authenticated when their identity has been successfully
    validated against a trusted store. Such trusted stores can either be any kind
    of specially maintained database, storing the credentials of the application (basic
    authentication), or a third-party service that checks a given identity against
    its own trusted store (third-party authentication).
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP basic authentication is one of the most popular and straightforward authentication
    mechanisms available out there. It relies on HTTP headers in the request, which
    provide the user''s credentials. Optionally, the server may reply with a header,
    forcing the clients to authenticate themselves. The following diagram shows a
    client-server interaction when basic authentication is carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80234492-f661-416f-8aeb-6aceb911f172.png)'
  prefs: []
  type: TYPE_IMG
- en: Whenever an HTTP request is sent to an endpoint secured by HTTP basic authentication,
    the server replies with an HTTP `401 Unauthorized` status code, and, optionally,
    with a `WWW-Authenticate` header. This header forces the client to send another
    request, containing the `Authorization` header, which specifies that the authentication
    method is `basic`. This request is followed by a base64-encoded key/value pair,
    providing the username and the password to authenticate with. Optionally, the
    server can specify a message to the client with the `realm` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute specifies that resources sharing the same `realm` value should
    support the same authentication means. In the preceding diagram, the `realm` message
    is `MyRealmName`. The client authenticates by sending the `Authentication` header
    with the value of `Basic YWRtaW46YWRtaW4`, specifying that `Basic` authentication
    is used, followed by the base64-encoded value. In the diagram, the literal `YWRtaW46YWRtaW4`
    decoded in base64 represents the `admin:admin` literal. In case such a username/password
    combination is successfully authenticated, the HTTP server will respond with the
    JSON payload of the requested items. If the authentication fails, the server will
    respond with the `401 Unauthorized` status code, but this time without including
    the `WWW-Authenticate` header.
  prefs: []
  type: TYPE_NORMAL
- en: Passport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are plenty of authentication methods to choose from nowadays. Perhaps
    the most popular methods are basic authentication, where each user has their own
    username and password, and third-party authentication, where users can identify
    themselves with their already-existing account for an external public service,
    such as personal social services such as LinkedIn, Facebook, and Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the most appropriate type of authentication for a web API depends mainly
    on its consumers. Apparently, an application consuming an API to fetch data is
    not likely to authenticate with a personal social account. This approach is more
    suitable when the API is used via a frontend directly by a human being.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a solution capable of switching between different authentication
    methods easily is a complex and time-consuming task. In fact, it can become hardly
    possible if not considered at the initial design phase of an application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Passport** is a piece of authentication middleware for Node.js, created especially
    for use-cases where the means of authentication should be easily switched from
    one to another. It has modular architecture that enables the usage of a specific
    authentication provider, called **strategy**. The strategy takes care of implementing
    a chosen authentication approach.'
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of authentication strategies to choose from, for example, a
    regular basic authentication strategy or social platform-based strategies for
    services such as Facebook, LinkedIn, and Twitter. Refer to the official Passport
    website, [http://www.passportjs.org/](http://www.passportjs.org/), for a complete
    list of the available strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Passport's basic authentication strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to look at how to utilize Passport's strategies; we will start
    with the basic authentication strategy; it is a logical choice now that we know
    how basic authentication works.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we will start by installing the relevant modules with the NPM package
    manager. We will need the `passport` module, which provides the base functionality
    that allows you to plug in different authentication strategies, and a concrete
    strategy for basic authentication, provided by the `passport-http` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to instantiate both the Passport middleware and the basic authentication
    strategy. `BasicStrategy` takes as an argument a callback function, which checks
    whether the provided username/password combination is valid. Finally, passport''s
    authenticate method is provided as a middleware function to the express route,
    assuring that unauthenticated requests will be rejected with an appropriate `401
    Unauthorized` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BasicStrategy` constructor takes a handler function as an argument. It
    gives us access to the username and password supplied by the client, and to the
    Passport middleware''s `done()` function, which notifies Passport with whether
    the user has been successfully authenticated. Invoke the `done()` function with
    `user` as an argument in order to grant authentication, or pass the `error` argument
    to it to revoke the authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally, use the `passort` `authenticate()` function in the router middleware
    to attach it to a specific HTTP method-handler function.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we specify that we don't want to store any authentication details
    in a session. This is because, when using basic authentication, there is no need
    to store any user information in a session, as each request contains the `Authorization`
    header that provides the login details.
  prefs: []
  type: TYPE_NORMAL
- en: Passport's OAuth Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth is an open standard for third party authorization, it defines a delegation
    protocol used fer authorizing against a third party authentication providers.
    OAuth uses special tokens, once issued,  identify the user instead of user credentials.
    Let's look closer at OAuth workflow, with a sample scenario. The main actors in
    the scenario are - a **user** interacting with a **web application,** which consumes
    a restful service from a **back-end** system  providing some kind of data. The
    web application delegates its authorization to a separate **third-party authorization
    server.**
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/850a429e-216a-4152-9434-422b7dbbb9fd.png)'
  prefs: []
  type: TYPE_IMG
- en: The user requests a web application which requires authentication to establish
    communication with the back-end service. This is the initial request thus the
    user is still not authenticated, so they get redirected to a login page asking
    for their credentials for the relevant third party account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a successful authentication an authorization code is issued by the authentication
    server to the web application. This authorization code is a composite combination
    between an issued client-id and a secret issued by the provider. They should be
    sent from a web application to the authentication server and is exchanged for
    an access token that has a limited lifetime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Web application uses the authentication token for authentication until it
    gets expired. Afterwards it has to request a new token using the authorization
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Passport.js hides the complexity behind this process with a separate strategy
    module automating the OAuth workflow. It is available in the `npm` repository
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Create an instance of the strategy and supply it with the urls for requesting
    tokens and for authenticating it together, it is your personal consumer key and
    a secret phrase of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Passport.js provides separate strategy wrapping different providers, like linkedin
    or github. They ensure that your application stays up to date with the token issuing
    URLs. Once you have made up your mind about the provider you want to support,
    you should check for specific strategies for them.
  prefs: []
  type: TYPE_NORMAL
- en: Passport's third-party authentication strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, almost everyone owns at least one personal public social media account,
    such as Twitter, Facebook, and LinkedIn. Recently, it has become really popular
    for websites to allow their visitors to authenticate themselves via one of their
    social accounts by just clicking on an icon to bind their social service account
    to a service-internal automatically generated account.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is very convenient for web users who are usually permanently logged
    into at least one of their accounts. If they are not currently logged in, clicking
    on an icon will redirect them to their social service login page, and, after a
    successful login, another redirection takes place, ensuring that the user gets
    the content they originally requested. When it comes to exposing data via a web
    API, this approach is not really an option.
  prefs: []
  type: TYPE_NORMAL
- en: Publicly exposed APIs cannot predict whether they are to be consumed by a human
    or by an application. Also, APIs aren't usually consumed directly by humans. Thus,
    third-party authentication is the only option when you, as API authors, are convinced
    that the exposed data will be directly available to the end users who have requested
    it manually through a frontend from an internet browser. Once they have successfully
    logged into their social account, a unique user identifier will be stored in a
    session, so your service will need to be able to handle such sessions appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable session support for storing user login information with Passport
    and Express, you have to initialize the Express session middleware before initializing
    Passport and its session middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, specify the user whose details Passport should serialize/deserialize
    into or out of the session. For that purpose, Passport provides the `serializeUser()`
    and `deserializeUser()` functions, which store complete user information in a
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The order of initializing the session handling of the Express and Passport middleware
    is important. The Express session should be passed to the application first and
    should be followed by the Passport session.
  prefs: []
  type: TYPE_NORMAL
- en: After enabling session support, you have to decide which third-party authentication
    strategy to rely on. Basically, third-party authentication is enabled via a plugin
    or application created by the third-party provider, for example, a social service
    site. We will briefly look at creating a LinkedIn application that allows authentication
    via the OAuth standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, this is done via a pair of public key and a secret (token) associated
    with the social media application. Creating a LinkedIn application is easy—you
    just have to log into [http://www.linkedin.com/secure/developer](http://www.linkedin.com/secure/developer)
    and fill out a brief application information form. You will be given a secret
    key and a token to enable the authentication. Perform the following steps to enable
    LinkedIn authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `linkedin-strategy` module—`npm install linkedin-strategy`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get an instance of the LinkedIn strategy and initialize it to the Passport
    middleware by the `use()` function after session support has been enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicitly specify that the LinkedIn strategy should be used as Passport for
    each individual route, ensuring that session handling is enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide a means for a user to log out by exposing a logout URI, making use
    of `request.logout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The given third-party URLs and service data are subject to change. You should
    always refer to the service policy when providing third-party authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the catalog data service uses basic authentication to protect its routes
    from unknown users; however, a catalog application should allow only few white-listed
    users to modify the items inside the catalog. To restrict access to the catalog,
    we will introduce the concept of authorization, that is, a subset of authenticated
    users, with appropriate permission allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Passport''s `done()` function is invoked to authenticate a successful
    login, it takes as an argument a `user` instance of the user that has been granted
    authentication. The `done()` function adds that user model instance to the `request`
    object, and, in this way, provides access to it via the `request.user` property,
    after successful authentication. We will make use of that property to implement
    a function performing the authorization check after successful authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP 403 Forbidden status code can be easily confused with 405 Not allowed.
    However, the 405 Not Allowed status code indicates that a specific HTTP verb is
    not supported by the requested resource, so it should be used only in that context.
  prefs: []
  type: TYPE_NORMAL
- en: The `authorize()` function will close the `response` stream, returning the `403
    Forbidden` status code, which indicates that the logged-in user is recognized
    but has insufficient permissions. This revokes access to the resource. This function
    has to be used in each route that carries out data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of how a `post` route implements authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After `authorize()` is invoked, we check whether the `response` object still
    allows writing to its output by checking the value of the closed property of the
    `response` object. It will return `true` once the end function of the `response`
    object has been called, which is exactly what the `authorize()` function does
    when the user lacks admin permissions. Thus, we can rely on the closed property
    in our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Transport layer security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Publicly available information in the web easily becomes the subject of different
    types of cyber attacks. Often it is not enough just to keep the so-called "bad
    guys" out. Sometimes, they won't bother gaining authentication at all and may
    prefer to carry out a **man-in-the-middle** (**MiM**) attack, pretending to be
    the final receiver of a message and sniffing the communication channel that transmits
    the data—or, even worse, altering the data while it flows.
  prefs: []
  type: TYPE_NORMAL
- en: Being a text-based protocol, HTTP transfers data in a human-readable format,
    which makes it an easy victim of MiM attacks. Unless transferred in an encrypted
    format, all the catalog data of our service is vulnerable to MiM attacks. In this
    section, we will switch our transport from an insecure HTTP protocol to the secure
    HTTPS protocol.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS is secured by asymmetric cryptography, also known as **public-key encryption**.
    It is based on a pair of keys that are mathematically related. The key used for
    encryption is called **public key**, and the key used for decryption is called
    **private key**. The idea is to freely provide the encryption key to partners
    who have to send encrypted messages and to perform decryption with the private
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical public-key encryption communication scenario between two parties,
    *A* and *B*, will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Party *A* composes a message, encrypts it with Party B's public key, and sends
    it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Party *B* decrypts the message with its own private key and processes it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Party *B* composes a response message, encrypts it with Party *A*'s public key,
    and then sends it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Party *A* decrypts the response message with its own private key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we know how public-key encryption works, let''s go through a sample
    of HTTPS client-server communication, as shown in this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46046c17-c975-4e14-aecc-b94764bc16a3.png)'
  prefs: []
  type: TYPE_IMG
- en: The client sends an initial request against an SSL-secured endpoint. The server
    responds to that request by sending its public key to be used for encrypting further
    incoming requests. Then, the client has to check the validity and verify the identity
    of the received key. After successful verification of the server's public key,
    the client has to send its own public key back to the server. Finally, after the
    key exchange procedure is complete, the two parties can start communicating securely.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS relies on trust; thus, it is vital to have a reliable way of checking
    whether a specific public key belongs to a specific server. Public keys are exchanged
    within an X.509 certificate, which has a hierarchical structure. This structure
    enables clients to check whether a given certificate has been generated from a
    trusted root certificate. Clients should trust only certificates that have been
    issued by a known **certificate authority** (**CA**).
  prefs: []
  type: TYPE_NORMAL
- en: Before switching our service to use the HTTPS transport, we need a public/private
    key pair. Since we are not a certificate authority, we will have to use OpenSSL
    tooling to generate test keys for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenSSL is available for download at [http://www.openssl.org/](http://www.openssl.org/),
    where source code distributions are available for all popular operating systems.
    OpenSSL can be installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary distribution is available for download for Windows, and Debian and Ubuntu
    users can make use of the packaged distribution by executing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Windows users will have to set an environment variable, OPENSSL_CNF, specifying
    the location of the `openssl.cnf` configuration file, typically located in the
    share directory in the installation archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s generate a test key/value pair with OpenSSL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: OpenSSL will prompt some details required for generating the certificate, such
    as country code, city, and fully qualified domain name. Afterward, it will generate
    a private key in the `catalog.pem` file and a public key certificate that will
    be valid for a year in the `catalog.crt` file. We will be using these newly generated
    files, so copy them into a new subdirectory, called `ssl`, in the catalog data
    service directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have everything needed to modify our service to use HTTPS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to switch and use the HTTPS module instead of HTTP and specify
    the port that we want to use to enable HTTPS communication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to read the private key from the `catalog.cem` file and the certificate
    from `catalog.crt` into an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we pass the array containing the key pair to the HTTPS instance when
    creating the server and start listening through the specified port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That's all you need to do to enable HTTPS for an Express-based application.
    Save your changes and give it a try by requesting `https://localhost:3443/catalog/v2`
    in a browser. You will be shown a warning message informing you that the server
    you are connecting to is using a certificate that is not issued by a trusted certificate
    authority. That's normal, as we generated the certificate on our own, and we are
    not a CA for sure, so just ignore that warning.
  prefs: []
  type: TYPE_NORMAL
- en: Before deploying a service on a production environment, you should always ensure
    that you use a server certificate issued by a trusted CA.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Is HTTP basic authentication secure against man-in-the-middle attacks?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the benefits of Transport Layer Security?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to protect exposed data by enabling a means
    of authentication and authorization. This is a critical aspect of any publicly
    available data service. In addition, you learned how to prevent man-in-the-middle
    attacks using the secured layer transport protocol between a service and its users.
    As a developer of such services, you should always consider the most appropriate
    security features that your application should support.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this was a useful experience! You gained enough knowledge and practical
    experience, which should have made you much more confident in understanding how
    RESTful APIs work and how they are designed and developed. I strongly encourage
    you to go through the code evolution chapter by chapter. You should be able to
    further refactor it, adopting it to your own coding style. Of course, some parts
    of it can be further optimized, as they repeat quite often. That is an intentional
    decision rather than good practice, as I wanted to emphasize their importance.
    You should always strive to improve your code-base, making it easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I would like to encourage you to always follow the development of the
    `Node.js` modules you use in your applications. Node.js has an extraordinary community
    that is eager to grow rapidly. There is always something exciting going on there,
    so ensure that you don't miss it. Good luck!
  prefs: []
  type: TYPE_NORMAL

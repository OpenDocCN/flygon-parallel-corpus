["```scala\n tar -xvzf spark-2.2.0-bin-hadoop2.7.tgz\n\n```", "```scala\n cd spark-2.2.0-bin-hadoop2.7\n\n```", "```scala\n export JAVA_HOME=/Library/Java/JavaVirtualMachines/\n                             jdk1.8.0_65.jdk/Contents/Home/\n\n```", "```scala\n export SPARK_HOME= /Users/myuser/spark-2.2.0-bin-\n                               hadoop2.7\n\n```", "```scala\n scala>\n\n```", "```scala\n ./bin/spark-shell\n\n```", "```scala\n ./bin/spark-shell --master local[n]\n\n```", "```scala\n ./bin/spark-shell --master spark://<IP>:<Port>\n\n```", "```scala\n ./bin/spark-shell --master yarn --deploy-mode client\n\n```", "```scala\n ./bin/spark-shell --master yarn --deploy-mode cluster\n\n```", "```scala\nclass RDD[T: ClassTag]\n\n```", "```scala\nscala> val rdd_one = sc.parallelize(Seq(1,2,3))\nrdd_one: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:24\n\nscala> rdd_one.take(10)\nres0: Array[Int] = Array(1, 2, 3)\n\n```", "```scala\nscala> val rdd_two = sc.textFile(\"wiki1.txt\")\nrdd_two: org.apache.spark.rdd.RDD[String] = wiki1.txt MapPartitionsRDD[8] at textFile at <console>:24\n\nscala> rdd_two.count\nres6: Long = 9\n\nscala> rdd_two.first\nres7: String = Apache Spark provides programmers with an application programming interface centered on a data structure called the resilient distributed dataset (RDD), a read-only multiset of data items distributed over a cluster of machines, that is maintained in a fault-tolerant way.\n\n```", "```scala\nscala> val rdd_one = sc.parallelize(Seq(1,2,3))\nrdd_one: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:24\n\nscala> rdd_one.take(10)\nres0: Array[Int] = Array(1, 2, 3)\n\nscala> val rdd_one_x2 = rdd_one.map(i => i * 2)\nrdd_one_x2: org.apache.spark.rdd.RDD[Int] = MapPartitionsRDD[9] at map at <console>:26\n\nscala> rdd_one_x2.take(10)\nres9: Array[Int] = Array(2, 4, 6)\n\n```", "```scala\n./bin/spark-shell\n\n```", "```scala\n./bin/spark-shell --help\nUsage: ./bin/spark-shell [options]\n\nOptions:\n --master MASTER_URL spark://host:port, mesos://host:port, yarn, or local.\n --deploy-mode DEPLOY_MODE Whether to launch the driver program locally (\"client\") or\n on one of the worker machines inside the cluster (\"cluster\")\n (Default: client).\n --class CLASS_NAME Your application's main class (for Java / Scala apps).\n --name NAME A name of your application.\n --jars JARS Comma-separated list of local jars to include on the driver\n and executor classpaths.\n --packages Comma-separated list of maven coordinates of jars to include\n on the driver and executor classpaths. Will search the local\n maven repo, then maven central and any additional remote\n repositories given by --repositories. The format for the\n coordinates should be groupId:artifactId:version.\n --exclude-packages Comma-separated list of groupId:artifactId, to exclude while\n resolving the dependencies provided in --packages to avoid\n dependency conflicts.\n --repositories Comma-separated list of additional remote repositories to\n search for the maven coordinates given with --packages.\n --py-files PY_FILES Comma-separated list of .zip, .egg, or .py files to place\n on the PYTHONPATH for Python apps.\n --files FILES Comma-separated list of files to be placed in the working\n directory of each executor.\n\n --conf PROP=VALUE Arbitrary Spark configuration property.\n --properties-file FILE Path to a file from which to load extra properties. If not\n specified, this will look for conf/spark-defaults.conf.\n\n --driver-memory MEM Memory for driver (e.g. 1000M, 2G) (Default: 1024M).\n --driver-Java-options Extra Java options to pass to the driver.\n --driver-library-path Extra library path entries to pass to the driver.\n --driver-class-path Extra class path entries to pass to the driver. Note that\n jars added with --jars are automatically included in the\n classpath.\n\n --executor-memory MEM Memory per executor (e.g. 1000M, 2G) (Default: 1G).\n\n --proxy-user NAME User to impersonate when submitting the application.\n This argument does not work with --principal / --keytab.\n\n --help, -h Show this help message and exit.\n --verbose, -v Print additional debug output.\n --version, Print the version of current Spark.\n\n Spark standalone with cluster deploy mode only:\n --driver-cores NUM Cores for driver (Default: 1).\n\n Spark standalone or Mesos with cluster deploy mode only:\n --supervise If given, restarts the driver on failure.\n --kill SUBMISSION_ID If given, kills the driver specified.\n --status SUBMISSION_ID If given, requests the status of the driver specified.\n\n Spark standalone and Mesos only:\n --total-executor-cores NUM Total cores for all executors.\n\n Spark standalone and YARN only:\n --executor-cores NUM Number of cores per executor. (Default: 1 in YARN mode,\n or all available cores on the worker in standalone mode)\n\n YARN-only:\n --driver-cores NUM Number of cores used by the driver, only in cluster mode\n (Default: 1).\n --queue QUEUE_NAME The YARN queue to submit to (Default: \"default\").\n --num-executors NUM Number of executors to launch (Default: 2).\n If dynamic allocation is enabled, the initial number of\n executors will be at least NUM.\n --archives ARCHIVES Comma separated list of archives to be extracted into the\n working directory of each executor.\n --principal PRINCIPAL Principal to be used to login to KDC, while running on\n secure HDFS.\n --keytab KEYTAB The full path to the file that contains the keytab for the\n principal specified above. This keytab will be copied to\n the node running the Application Master via the Secure\n Distributed Cache, for renewing the login tickets and the\n delegation tokens periodically.\n\n```", "```scala\nscala> :help\nAll commands can be abbreviated, e.g., :he instead of :help.\n:edit <id>|<line> edit history\n:help [command] print this summary or command-specific help\n:history [num] show the history (optional num is commands to show)\n:h? <string> search the history\n:imports [name name ...] show import history, identifying sources of names\n:implicits [-v] show the implicits in scope\n:javap <path|class> disassemble a file or class name\n:line <id>|<line> place line(s) at the end of history\n:load <path> interpret lines in a file\n:paste [-raw] [path] enter paste mode or paste a file\n:power enable power user mode\n:quit exit the interpreter\n:replay [options] reset the repl and replay all previous commands\n:require <path> add a jar to the classpath\n:reset [options] reset the repl to its initial state, forgetting all session entries\n:save <path> save replayable session to a file\n:sh <command line> run a shell command (result is implicitly => List[String])\n:settings <options> update compiler options, if possible; see reset\n:silent disable/enable automatic printing of results\n:type [-v] <expr> display the type of an expression without evaluating it\n:kind [-v] <expr> display the kind of expression's type\n:warnings show the suppressed warnings from the most recent line which had any\n\n```", "```scala\nscala> val rdd_one = sc.parallelize(Seq(1,2,3))\nrdd_one: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:24\n\nscala> rdd_one.take(10)\nres0: Array[Int] = Array(1, 2, 3)\n\n```", "```scala\nscala> :paste\n// Entering paste mode (ctrl-D to finish)\n\nval rdd_one = sc.parallelize(Seq(1,2,3))\nrdd_one.take(10)\n\n// Exiting paste mode, now interpreting.\nrdd_one: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[10] at parallelize at <console>:26\nres10: Array[Int] = Array(1, 2, 3)\n\n```", "```scala\nscala> val rdd_two = sc.textFile(\"wiki1.txt\")\nrdd_two: org.apache.spark.rdd.RDD[String] = wiki1.txt MapPartitionsRDD[8] at textFile at <console>:24\n\nscala> rdd_two.count\nres6: Long = 9\n\nscala> rdd_two.first\nres7: String = Apache Spark provides programmers with an application programming interface centered on a data structure called the resilient distributed dataset (RDD), a read-only multiset of data items distributed over a cluster of machines, that is maintained in a fault-tolerant way.\n\nscala> val rdd_three = rdd_two.map(line => line.length)\nres12: org.apache.spark.rdd.RDD[Int] = MapPartitionsRDD[11] at map at <console>:2\n\nscala> rdd_three.take(10)\nres13: Array[Int] = Array(271, 165, 146, 138, 231, 159, 159, 410, 281)\n\n```", "```scala\nflatMap() on a RDD of a text file to convert the lines in the text to a RDD containing the individual words. We also show map() called on the same RDD before flatMap() is called just to show the difference in behavior:\n```", "```scala\nscala> val rdd_two = sc.textFile(\"wiki1.txt\")\nrdd_two: org.apache.spark.rdd.RDD[String] = wiki1.txt MapPartitionsRDD[8] at textFile at <console>:24\n\nscala> rdd_two.count\nres6: Long = 9\n\nscala> rdd_two.first\nres7: String = Apache Spark provides programmers with an application programming interface centered on a data structure called the resilient distributed dataset (RDD), a read-only multiset of data items distributed over a cluster of machines, that is maintained in a fault-tolerant way.\n\nscala> val rdd_three = rdd_two.map(line => line.split(\" \"))\nrdd_three: org.apache.spark.rdd.RDD[Array[String]] = MapPartitionsRDD[16] at map at <console>:26\n\nscala> rdd_three.take(1)\nres18: Array[Array[String]] = Array(Array(Apache, Spark, provides, programmers, with, an, application, programming, interface, centered, on, a, data, structure, called, the, resilient, distributed, dataset, (RDD),, a, read-only, multiset, of, data, items, distributed, over, a, cluster, of, machines,, that, is, maintained, in, a, fault-tolerant, way.)\n\nscala> val rdd_three = rdd_two.flatMap(line => line.split(\" \"))\nrdd_three: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[17] at flatMap at <console>:26\n\nscala> rdd_three.take(10)\nres19: Array[String] = Array(Apache, Spark, provides, programmers, with, an, application, programming, interface, centered)\n\n```", "```scala\nSpark:\n```", "```scala\nscala> val rdd_two = sc.textFile(\"wiki1.txt\")\nrdd_two: org.apache.spark.rdd.RDD[String] = wiki1.txt MapPartitionsRDD[8] at textFile at <console>:24\n\nscala> rdd_two.count\nres6: Long = 9\n\nscala> rdd_two.first\nres7: String = Apache Spark provides programmers with an application programming interface centered on a data structure called the resilient distributed dataset (RDD), a read-only multiset of data items distributed over a cluster of machines, that is maintained in a fault-tolerant way.\n\nscala> val rdd_three = rdd_two.filter(line => line.contains(\"Spark\"))\nrdd_three: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[20] at filter at <console>:26\n\nscala>rdd_three.count\nres20: Long = 5\n\n```", "```scala\nscala> val rdd_two = sc.textFile(\"wiki1.txt\")\nrdd_two: org.apache.spark.rdd.RDD[String] = wiki1.txt MapPartitionsRDD[8] at textFile at <console>:24\n\nscala> rdd_two.partitions.length\nres21: Int = 2\n\nscala> val rdd_three = rdd_two.coalesce(1)\nrdd_three: org.apache.spark.rdd.RDD[String] = CoalescedRDD[21] at coalesce at <console>:26\n\nscala> rdd_three.partitions.length\nres22: Int = 1\n\n```", "```scala\nscala> val rdd_two = sc.textFile(\"wiki1.txt\")\nrdd_two: org.apache.spark.rdd.RDD[String] = wiki1.txt MapPartitionsRDD[8] at textFile at <console>:24\n\nscala> rdd_two.partitions.length\nres21: Int = 2\n\nscala> val rdd_three = rdd_two.repartition(5)\nrdd_three: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[25] at repartition at <console>:26\n\nscala> rdd_three.partitions.length\nres23: Int = 5\n\n```", "```scala\nscala> val rdd_one = sc.parallelize(Seq(1,2,3,4,5,6))\nrdd_one: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[26] at parallelize at <console>:24\n\nscala> rdd_one.take(10)\nres28: Array[Int] = Array(1, 2, 3, 4, 5, 6)\n\nscala> rdd_one.reduce((a,b) => a +b)\nres29: Int = 21\n\n```", "```scala\nscala> val rdd_one = sc.parallelize(Seq(1,2,3,4,5,6))\nrdd_one: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[26] at parallelize at <console>:24\n\nscala> rdd_one.count\nres24: Long = 6\n\n```", "```scala\nscala> rdd_two.collect\nres25: Array[String] = Array(Apache Spark provides programmers with an application programming interface centered on a data structure called the resilient distributed dataset (RDD), a read-only multiset of data items distributed over a cluster of machines, that is maintained in a fault-tolerant way., It was developed in response to limitations in the MapReduce cluster computing paradigm, which forces a particular linear dataflow structure on distributed programs., \"MapReduce programs read input data from disk, map a function across the data, reduce the results of the map, and store reduction results on disk. \", Spark's RDDs function as a working set for distributed programs that offers a (deliberately) restricted form of distributed shared memory., The availability of RDDs facilitates t...\n\n```", "```scala\npersist(newLevel: StorageLevel) \n\n```", "```scala\nscala> import org.apache.spark.storage.StorageLevel\nimport org.apache.spark.storage.StorageLevel\n\nscala> rdd_one.persist(StorageLevel.MEMORY_ONLY)\nres37: rdd_one.type = ParallelCollectionRDD[26] at parallelize at <console>:24\n\nscala> rdd_one.unpersist()\nres39: rdd_one.type = ParallelCollectionRDD[26] at parallelize at <console>:24\n\nscala> rdd_one.persist(StorageLevel.DISK_ONLY)\nres40: rdd_one.type = ParallelCollectionRDD[26] at parallelize at <console>:24\n\nscala> rdd_one.unpersist()\nres41: rdd_one.type = ParallelCollectionRDD[26] at parallelize at <console>:24\n\n```", "```scala\nscala> val rdd_one = sc.parallelize(Seq(1,2,3,4,5,6))\nrdd_one: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:24\n\nscala> rdd_one.count\nres0: Long = 6\n\nscala> rdd_one.cache\nres1: rdd_one.type = ParallelCollectionRDD[0] at parallelize at <console>:24\n\nscala> rdd_one.count\nres2: Long = 6\n\n```", "```scala\nsc.textFile(name, minPartitions=None, use_unicode=True)\n\n```", "```scala\nscala> val rdd_two = sc.textFile(\"wiki1.txt\")\nrdd_two: org.apache.spark.rdd.RDD[String] = wiki1.txt MapPartitionsRDD[8] at textFile at <console>:24\n\nscala> rdd_two.count\nres6: Long = 9\n\n```", "```scala\nsc.wholeTextFiles(path, minPartitions=None, use_unicode=True)\n\n```", "```scala\nscala> val rdd_whole = sc.wholeTextFiles(\"wiki1.txt\")\nrdd_whole: org.apache.spark.rdd.RDD[(String, String)] = wiki1.txt MapPartitionsRDD[37] at wholeTextFiles at <console>:25\n\nscala> rdd_whole.take(10)\nres56: Array[(String, String)] =\nArray((file:/Users/salla/spark-2.1.1-bin-hadoop2.7/wiki1.txt,Apache Spark provides programmers with an application programming interface centered on a data structure called the resilient distributed dataset (RDD), a read-only multiset of data \n\n```", "```scala\n sqlContext.load(path=None, source=None, schema=None, **options)\n\n```", "```scala\nval dbContent = sqlContext.load(source=\"jdbc\",  url=\"jdbc:mysql://localhost:3306/test\",  dbtable=\"test\",  partitionColumn=\"id\")\n\n```", "```scala\nscala> rdd_one.saveAsTextFile(\"out.txt\")\n\n```"]
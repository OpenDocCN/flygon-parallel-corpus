- en: The Go Programming Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into the more complex examples of using Go for security, it is
    important to have a solid foundation. This chapter provides an overview of the
    Go programming language so that you have the knowledge necessary to follow the
    subsequent examples.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is not an exhaustive treatise of the Go programming language, but
    will give you a solid overview of the major features. The goal of this chapter
    is to provide you with the information you need to understand and follow the source
    code if you have never used Go before. If you are already familiar with Go, this
    chapter should be a quick and easy review of things you already know, but perhaps
    you will learn a new piece of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter specifically covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Go language specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go playground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tour of Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notes about source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting help and documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go language specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The entire Go language specification can be found online at [https://golang.org/ref/spec](https://golang.org/ref/spec).
    Much of the information in this chapter comes from the specification, as this
    is the one true documentation of the language. The rest of the information here
    is short examples, tips, best practices, and other things that I have learned
    during my time with Go.
  prefs: []
  type: TYPE_NORMAL
- en: The Go playground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go playground is a website where you can write and execute Go code without
    having to install anything. In the playground, [https://play.golang.org](https://play.golang.org),
    you can test pieces of code to explore the language and fiddle with things to
    understand how the language works. It also allows you to share your snippet by
    creating a unique URL that stores your snippet. Sharing code through the playground
    can be much more helpful than a plaintext snippet, since it allows the reader
    to actually execute the code and tinker with the source if they have any questions
    about how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5514c8a-7253-4641-8b61-3e02ebcac15e.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows a simple program being run in the playground.
    There are buttons at the top to run, format, add import statements, and share
    the code with others.
  prefs: []
  type: TYPE_NORMAL
- en: A tour of Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another resource provided by the Go team is *A Tour of Go*. This website, [https://tour.golang.org](https://tour.golang.org),
    is built on top of the playground mentioned in the previous section. The tour
    was my first introduction to the language, and when I completed it, I felt well-equipped
    to start tackling projects in Go. It walks you through the language step by step
    along with working code examples so that you can run and modify the code to get
    familiar with the language. It is a practical way to introduce a newcomer to Go.
    If you have never used Go at all, I encourage you to check it out.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/155646d8-315b-4b13-aa31-c7be08feb713.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the first page of the tour. On the right-hand
    side, you will have a small embedded playground with the code sample relevant
    to the short lesson shown on the left-hand side. Each lesson comes with a short
    code example that you can run and tinker with.
  prefs: []
  type: TYPE_NORMAL
- en: Keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To emphasize how simple Go is, here is a breakdown of all its 25 keywords. You
    probably already know most of them if you are familiar with other programming
    languages. The keywords are grouped together to examine them according to their
    use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data types**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `var` | This defines a new variable |'
  prefs: []
  type: TYPE_TB
- en: '| `const` | This defines a constant value that does not change |'
  prefs: []
  type: TYPE_TB
- en: '| `type` | This defines a new data type |'
  prefs: []
  type: TYPE_TB
- en: '| `struct` | This defines a new structured data type that contains multiple
    variables |'
  prefs: []
  type: TYPE_TB
- en: '| `map` | This defines a new map or hash variable |'
  prefs: []
  type: TYPE_TB
- en: '| `interface` | This defines a new interface |'
  prefs: []
  type: TYPE_TB
- en: '**Functions**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `func` | This defines a new function |'
  prefs: []
  type: TYPE_TB
- en: '| `return` | This exits a function, optionally returning values |'
  prefs: []
  type: TYPE_TB
- en: '**Packages**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `import`  | This imports an external package in the current package |'
  prefs: []
  type: TYPE_TB
- en: '| `package` | This specifies what package a file belongs to |'
  prefs: []
  type: TYPE_TB
- en: '**Program flow**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `if` | This is used for branch execution based on a condition that is true
    |'
  prefs: []
  type: TYPE_TB
- en: '| `else` | This is used for a branch if a condition is not true |'
  prefs: []
  type: TYPE_TB
- en: '| `goto` | This is used to jump directly to a label; it is rarely used and
    not encouraged |'
  prefs: []
  type: TYPE_TB
- en: '**Switch statements**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `switch` | This is used to branch based off of a condition |'
  prefs: []
  type: TYPE_TB
- en: '| `case` | This defines the condition for the `switch` statement |'
  prefs: []
  type: TYPE_TB
- en: '| `default` | This defines default execution when no case is matched |'
  prefs: []
  type: TYPE_TB
- en: '| `fallthrough` | This is used to continue executing the next case |'
  prefs: []
  type: TYPE_TB
- en: '**Iteration**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `for` | The `for` loop can be used like in C, where you provide three expressions:
    the initializer, the condition, and the incrementer. In Go, there is no `while`
    loop and the `for` keyword takes on the role of both `for` and `while`. A `for`
    loop can be used just like a `while` loop if one expression, the condition, is
    passed. |'
  prefs: []
  type: TYPE_TB
- en: '| `range` | The `range` keyword is used with a `for` loop to iterate over a
    map or slice. |'
  prefs: []
  type: TYPE_TB
- en: '| `continue` | The `continue` keyword will skip any execution left in the current
    loop and jump directly to the next iteration. |'
  prefs: []
  type: TYPE_TB
- en: '| `break` | The `break` keyword will immediately exit the `for` loop completely,
    skipping any remaining iterations. |'
  prefs: []
  type: TYPE_TB
- en: '**Concurrency**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `go` | Goroutines are lightweight threads built in to the language. You simply
    put the `go` keyword in front of a call to a function and Go will execute that
    function call in a separate thread. |'
  prefs: []
  type: TYPE_TB
- en: '| `chan` | To communicate between threads, channels are used. Channels are
    used to send and receive specific data types. They are blocking by default. |'
  prefs: []
  type: TYPE_TB
- en: '| `select` | The `select` statements allow channels to be used in a nonblocking
    fashion. |'
  prefs: []
  type: TYPE_TB
- en: '**Convenience**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `defer` | The `defer` keyword is a relatively unique keyword that I have
    not previously encountered in other languages. It allows you to specify a function
    to be called later when the surrounding function returns. It is useful when you
    want to ensure some type of cleanup action whenever the current function ends,
    but you are not sure when or where it might return. A common use case is to defer
    a file closure. |'
  prefs: []
  type: TYPE_TB
- en: Notes about source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go source code files should have the `.go` extension. The source code of Go
    files is encoded in UTF-8 Unicode. This means that you can use any Unicode characters
    in your code, like hardcoding Japanese characters in a string.
  prefs: []
  type: TYPE_NORMAL
- en: Semicolons are optional at the end of a line and typically omitted. Semicolons
    are only required when separating multiple statements or expressions on a single
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Go does have a code formatting standard which can easily be adhered to by running
    `go fmt` on source code files. The code formatting should be followed, but it
    is not strictly enforced by the compiler the way Python requires exact formatting
    to execute properly.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comments follow a C++ style allowing the double slash and the slash-asterisk
    wrapped style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The built-in data types are named intuitively enough. Go comes with a set of
    integer and unsigned integer types with varying bit lengths. There are also floating
    point numbers, Booleans, and strings, which should come as no surprise.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few types like runes that are not common in other languages. This
    section covers all of the different types.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Boolean type represents a true or false value. Some languages don''t provide
    a `bool` type, and you have to use an integer or define your own enumeration,
    but Go conveniently comes with a predeclared `bool` type. The `true` and `false`
    constants are also predefined and used in all lowercase. Here is an example of
    creating a Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `bool` type is not unique to Go by any means, but one interesting piece
    of trivia about the Boolean type is that it's the only type named after a person.
    George Boole lived from 1815 to 1864 and wrote *The Laws of Thought*, where he
    described Boolean algebra, which is what all digital logic is based upon. The
    `bool` type is very simple in Go, but the history behind the name is very rich.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary numeric data types are integers and floating point numbers. Go also
    offers a complex number type, a byte type, and a rune. Here are the numeric data
    types available in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Generic numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These generic types can be used when you don't particularly care about whether
    a number is 32- or 64-bits. The largest available size will automatically be used,
    but will be compatible with 32- and 64-bit processors.
  prefs: []
  type: TYPE_NORMAL
- en: '`uint`: This is an unsigned integer of either 32 or 64 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: This is a signed integer with the same size as `uint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uintptr`: This is an unsigned integer to store a pointer value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These numeric types specify the bit length and whether it has a sign bit to
    determine positive or negative values. The bit length will determine the maximum
    range. Signed integers have the range reduced by one bit because the last bit
    is reserved for the sign.
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `uint` without a number generally chooses the largest size for your system,
    typically 64 bits. You can also specify one of the four specific `uint` sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uint8`: Unsigned 8-bit integer (0 to 255)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint16`: Unsigned 16-bit integer (0 to 65535)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint32` : Unsigned 32-bit integer (0 to 4294967295)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint64`: Unsigned 64-bit integer (0 to 18446744073709551615)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signed integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like unsigned integers, you can use `int` by itself to choose the best default
    size, or specify one of these four specific `int` sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int8`: 8-bit integer (-128 to 127)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int16`: 16-bit integer (-32768 to 32767)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int32`: 32-bit integer (-2147483648 to 2147483647)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int64`: 64-bit integer (-9223372036854775808 to 9223372036854775807)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating point numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The floating point type does not have a generic type, and must be one of these
    two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`float32`: IEEE-754 32-bit floating-point number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float64`: IEEE-754 64-bit floating-point number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other numeric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go also provides a complex number for advanced mathematical applications, and
    a few aliases for conveniences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`complex64`: Complex number with `float32` real and imaginary parts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`complex128`: Complex number with `float64` real and imaginary parts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte`: Alias for `uint8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rune`: Alias for `int32`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define numbers in the decimal, octal, or hexadecimal format. Decimal
    or base-ten numbers need no prefix. Octal or base-eight numbers should be prefixed
    with a zero. Hexadecimal or base-sixteen numbers should be prefixed with a zero
    and an x.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about the octal numeral system at [https://en.wikipedia.org/wiki/Octal](https://en.wikipedia.org/wiki/Octal),
    decimal at [https://en.wikipedia.org/wiki/Decimal](https://en.wikipedia.org/wiki/Decimal),
    and hexadecimal at [https://en.wikipedia.org/wiki/Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that numbers are stored as integers, and there are no differences between
    them except for how they are formatted in the source code for the human. Octal
    and hexadecimal can be useful when working with binary data. Here is a short example
    of how to define integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go comes with a `string` type as well as a `strings` package with a suite of
    useful functions such as `Contains()`, `Join()`, `Replace()`, `Split()`, `Trim()`,
    and `ToUpper()`. There is additionally a `strconv` package dedicated to converting
    various data types to and from strings. You can read more about the `strings`
    package at [https://golang.org/pkg/strings/](https://golang.org/pkg/strings/),
    and the `strconv` package at [https://golang.org/pkg/strconv/](https://golang.org/pkg/strconv/).
  prefs: []
  type: TYPE_NORMAL
- en: Double quotes are used for strings. Single quotes are used only for an individual
    character or runes, not strings. Strings can be defined using the long form or
    short form with the declare-and-assign operator. You can also use the [PRE3]
  prefs: []
  type: TYPE_NORMAL
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: // Long form assignment
  prefs: []
  type: TYPE_NORMAL
- en: var myText = "test string 1"
  prefs: []
  type: TYPE_NORMAL
- en: // Short form assignment
  prefs: []
  type: TYPE_NORMAL
- en: myText2 := "test string 2"
  prefs: []
  type: TYPE_NORMAL
- en: // Multiline string
  prefs: []
  type: TYPE_NORMAL
- en: myText3 := `long string
  prefs: []
  type: TYPE_NORMAL
- en: spanning multiple
  prefs: []
  type: TYPE_NORMAL
- en: lines`
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(myText)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(myText2)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(myText3)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: var myByteArray [128]byte
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: singleByte := myByteArray[4]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: make([]T, lengthAndCapacity)
  prefs: []
  type: TYPE_NORMAL
- en: make([]T, length, capacity)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: // Create a nil slice
  prefs: []
  type: TYPE_NORMAL
- en: var mySlice []byte
  prefs: []
  type: TYPE_NORMAL
- en: // Create a byte slice of length 8 and max capacity 128
  prefs: []
  type: TYPE_NORMAL
- en: mySlice = make([]byte, 8, 128)
  prefs: []
  type: TYPE_NORMAL
- en: // Maximum capacity of the slice
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("Capacity:", cap(mySlice))
  prefs: []
  type: TYPE_NORMAL
- en: // Current length of slice
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("Length:", len(mySlice))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: var mySlice []int // nil slice
  prefs: []
  type: TYPE_NORMAL
- en: // Appending works on nil slices.
  prefs: []
  type: TYPE_NORMAL
- en: // Since nil slices have zero capacity, and have
  prefs: []
  type: TYPE_NORMAL
- en: // no underlying array, it will create one.
  prefs: []
  type: TYPE_NORMAL
- en: mySlice = append(mySlice, 1, 2, 3, 4, 5)
  prefs: []
  type: TYPE_NORMAL
- en: // Individual elements can be accessed from a slice
  prefs: []
  type: TYPE_NORMAL
- en: // just like an array by using the square bracket operator.
  prefs: []
  type: TYPE_NORMAL
- en: firstElement := mySlice[0]
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("First element:", firstElement)
  prefs: []
  type: TYPE_NORMAL
- en: '// To get only the second and third element, use:'
  prefs: []
  type: TYPE_NORMAL
- en: subset := mySlice[1:4]
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(subset)
  prefs: []
  type: TYPE_NORMAL
- en: // To get the full contents of a slice except for the
  prefs: []
  type: TYPE_NORMAL
- en: '// first element, use:'
  prefs: []
  type: TYPE_NORMAL
- en: subset = mySlice[1:]
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(subset)
  prefs: []
  type: TYPE_NORMAL
- en: // To get the full contents of a slice except for the
  prefs: []
  type: TYPE_NORMAL
- en: '// last element, use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'subset = mySlice[0 : len(mySlice)-1]'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(subset)
  prefs: []
  type: TYPE_NORMAL
- en: // To copy a slice, use the copy() function.
  prefs: []
  type: TYPE_NORMAL
- en: // If you assign one slice to another with the equal operator,
  prefs: []
  type: TYPE_NORMAL
- en: // the slices will point at the same memory location,
  prefs: []
  type: TYPE_NORMAL
- en: // and changing one would change both slices.
  prefs: []
  type: TYPE_NORMAL
- en: slice1 := []int{1, 2, 3, 4}
  prefs: []
  type: TYPE_NORMAL
- en: slice2 := make([]int, 4)
  prefs: []
  type: TYPE_NORMAL
- en: // Create a unique copy in memory
  prefs: []
  type: TYPE_NORMAL
- en: copy(slice2, slice1)
  prefs: []
  type: TYPE_NORMAL
- en: // Changing one should not affect the other
  prefs: []
  type: TYPE_NORMAL
- en: slice2[3] = 99
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(slice1)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(slice2)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: // Define a Person type. Both fields public
  prefs: []
  type: TYPE_NORMAL
- en: type Person struct {
  prefs: []
  type: TYPE_NORMAL
- en: Name string
  prefs: []
  type: TYPE_NORMAL
- en: Age  int
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Create a Person object and store the pointer to it
  prefs: []
  type: TYPE_NORMAL
- en: 'nanodano := &Person{Name: "NanoDano", Age: 99}'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(nanodano)
  prefs: []
  type: TYPE_NORMAL
- en: // Structs can also be embedded within other structs.
  prefs: []
  type: TYPE_NORMAL
- en: // This replaces inheritance by simply storing the
  prefs: []
  type: TYPE_NORMAL
- en: // data type as another variable.
  prefs: []
  type: TYPE_NORMAL
- en: type Hacker struct {
  prefs: []
  type: TYPE_NORMAL
- en: Person           Person
  prefs: []
  type: TYPE_NORMAL
- en: FavoriteLanguage string
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(nanodano)
  prefs: []
  type: TYPE_NORMAL
- en: hacker := &Hacker{
  prefs: []
  type: TYPE_NORMAL
- en: 'Person:           *nanodano,'
  prefs: []
  type: TYPE_NORMAL
- en: 'FavoriteLanguage: "Go",'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(hacker)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(hacker.Person.Name)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(hacker)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs: []
  type: TYPE_NORMAL
- en: '"reflect"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: myInt := 42
  prefs: []
  type: TYPE_NORMAL
- en: intPointer := &myInt
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(reflect.TypeOf(intPointer))
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(intPointer)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(*intPointer)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: // Function with no parameters
  prefs: []
  type: TYPE_NORMAL
- en: func sayHello() {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("Hello.")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Function with one parameter
  prefs: []
  type: TYPE_NORMAL
- en: func greet(name string) {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("Hello, %s.\n", name)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Function with multiple params of same type
  prefs: []
  type: TYPE_NORMAL
- en: func greetCustom(name, greeting string) {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("%s, %s.\n", greeting, name)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Variadic parameters, unlimited parameters
  prefs: []
  type: TYPE_NORMAL
- en: func addAll(numbers ...int) int {
  prefs: []
  type: TYPE_NORMAL
- en: sum := 0
  prefs: []
  type: TYPE_NORMAL
- en: for _, number := range numbers {
  prefs: []
  type: TYPE_NORMAL
- en: sum += number
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return sum
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Function with multiple return values
  prefs: []
  type: TYPE_NORMAL
- en: // Multiple values encapsulated by parenthesis
  prefs: []
  type: TYPE_NORMAL
- en: func checkStatus() (int, error) {
  prefs: []
  type: TYPE_NORMAL
- en: return 200, nil
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Define a type as a function so it can be used
  prefs: []
  type: TYPE_NORMAL
- en: // as a return type
  prefs: []
  type: TYPE_NORMAL
- en: type greeterFunc func(string)
  prefs: []
  type: TYPE_NORMAL
- en: // Generate and return a function
  prefs: []
  type: TYPE_NORMAL
- en: func generateGreetFunc(greeting string) greeterFunc {
  prefs: []
  type: TYPE_NORMAL
- en: return func(name string) {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("%s, %s.\n", greeting, name)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: sayHello()
  prefs: []
  type: TYPE_NORMAL
- en: greet("NanoDano")
  prefs: []
  type: TYPE_NORMAL
- en: greetCustom("NanoDano", "Hi")
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(addAll(4, 5, 2, 3, 9))
  prefs: []
  type: TYPE_NORMAL
- en: russianGreet := generateGreetFunc("Привет")
  prefs: []
  type: TYPE_NORMAL
- en: russianGreet("NanoDano")
  prefs: []
  type: TYPE_NORMAL
- en: statusCode, err := checkStatus()
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(statusCode, err)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: type error interface {
  prefs: []
  type: TYPE_NORMAL
- en: Error() string
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: // Define a custom type that will
  prefs: []
  type: TYPE_NORMAL
- en: // be used to satisfy the error interface
  prefs: []
  type: TYPE_NORMAL
- en: type customError struct {
  prefs: []
  type: TYPE_NORMAL
- en: Message string
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Satisfy the error interface
  prefs: []
  type: TYPE_NORMAL
- en: // by implementing the Error() function
  prefs: []
  type: TYPE_NORMAL
- en: // which returns a string
  prefs: []
  type: TYPE_NORMAL
- en: func (e *customError) Error() string {
  prefs: []
  type: TYPE_NORMAL
- en: return e.Message
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Sample function to demonstrate
  prefs: []
  type: TYPE_NORMAL
- en: // how to use the custom error
  prefs: []
  type: TYPE_NORMAL
- en: func testFunction() error {
  prefs: []
  type: TYPE_NORMAL
- en: if true != false { // Mimic an error condition
  prefs: []
  type: TYPE_NORMAL
- en: return &customError{"Something went wrong."}
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return nil
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: err := testFunction()
  prefs: []
  type: TYPE_NORMAL
- en: if err != nil {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(err)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: type Reader interface {
  prefs: []
  type: TYPE_NORMAL
- en: Read(p []byte) (n int, err error)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: type Writer interface {
  prefs: []
  type: TYPE_NORMAL
- en: Write(p []byte) (n int, err error)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs: []
  type: TYPE_NORMAL
- en: '"reflect"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: // Nil maps will cause runtime panic if used
  prefs: []
  type: TYPE_NORMAL
- en: // without being initialized with make()
  prefs: []
  type: TYPE_NORMAL
- en: var intToStringMap map[int]string
  prefs: []
  type: TYPE_NORMAL
- en: var stringToIntMap map[string]int
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(reflect.TypeOf(intToStringMap))
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(reflect.TypeOf(stringToIntMap))
  prefs: []
  type: TYPE_NORMAL
- en: // Initialize a map using make
  prefs: []
  type: TYPE_NORMAL
- en: map1 := make(map[string]string)
  prefs: []
  type: TYPE_NORMAL
- en: map1["Key Example"] = "Value Example"
  prefs: []
  type: TYPE_NORMAL
- en: map1["Red"] = "FF0000"
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(map1)
  prefs: []
  type: TYPE_NORMAL
- en: // Initialize a map with literal values
  prefs: []
  type: TYPE_NORMAL
- en: map2 := map[int]bool{
  prefs: []
  type: TYPE_NORMAL
- en: '4:  false,'
  prefs: []
  type: TYPE_NORMAL
- en: '6:  false,'
  prefs: []
  type: TYPE_NORMAL
- en: '42: true,'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Access individual elements using the key
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(map1["Red"])
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(map2[42])
  prefs: []
  type: TYPE_NORMAL
- en: // Use range to iterate through maps
  prefs: []
  type: TYPE_NORMAL
- en: for key, value := range map2 {
  prefs: []
  type: TYPE_NORMAL
- en: 'fmt.Printf("%d: %t\n", key, value)'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"log"'
  prefs: []
  type: TYPE_NORMAL
- en: '"time"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: // Do some processing that takes a long time
  prefs: []
  type: TYPE_NORMAL
- en: // in a separate thread and signal when done
  prefs: []
  type: TYPE_NORMAL
- en: func process(doneChannel chan bool) {
  prefs: []
  type: TYPE_NORMAL
- en: time.Sleep(time.Second * 3)
  prefs: []
  type: TYPE_NORMAL
- en: doneChannel <- true
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: // Each channel can support one data type.
  prefs: []
  type: TYPE_NORMAL
- en: // Can also use custom types
  prefs: []
  type: TYPE_NORMAL
- en: var doneChannel chan bool
  prefs: []
  type: TYPE_NORMAL
- en: // Channels are nil until initialized with make
  prefs: []
  type: TYPE_NORMAL
- en: doneChannel = make(chan bool)
  prefs: []
  type: TYPE_NORMAL
- en: // Kick off a lengthy process that will
  prefs: []
  type: TYPE_NORMAL
- en: // signal when complete
  prefs: []
  type: TYPE_NORMAL
- en: go process(doneChannel)
  prefs: []
  type: TYPE_NORMAL
- en: // Get the first bool available in the channel
  prefs: []
  type: TYPE_NORMAL
- en: // This is a blocking operation so execution
  prefs: []
  type: TYPE_NORMAL
- en: // will not progress until value is received
  prefs: []
  type: TYPE_NORMAL
- en: tempBool := <-doneChannel
  prefs: []
  type: TYPE_NORMAL
- en: log.Println(tempBool)
  prefs: []
  type: TYPE_NORMAL
- en: // or to simply ignore the value but still wait
  prefs: []
  type: TYPE_NORMAL
- en: // <-doneChannel
  prefs: []
  type: TYPE_NORMAL
- en: // Start another process thread to run in background
  prefs: []
  type: TYPE_NORMAL
- en: // and signal when done
  prefs: []
  type: TYPE_NORMAL
- en: go process(doneChannel)
  prefs: []
  type: TYPE_NORMAL
- en: // Make channel non-blocking with select statement
  prefs: []
  type: TYPE_NORMAL
- en: // This gives you the ability to continue executing
  prefs: []
  type: TYPE_NORMAL
- en: // even if no message is waiting in the channel
  prefs: []
  type: TYPE_NORMAL
- en: var readyToExit = false
  prefs: []
  type: TYPE_NORMAL
- en: for !readyToExit {
  prefs: []
  type: TYPE_NORMAL
- en: select {
  prefs: []
  type: TYPE_NORMAL
- en: 'case done := <-doneChannel:'
  prefs: []
  type: TYPE_NORMAL
- en: log.Println("Done message received.", done)
  prefs: []
  type: TYPE_NORMAL
- en: readyToExit = true
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  prefs: []
  type: TYPE_NORMAL
- en: log.Println("No done signal yet. Waiting.")
  prefs: []
  type: TYPE_NORMAL
- en: time.Sleep(time.Millisecond * 500)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs: []
  type: TYPE_NORMAL
- en: '"math/rand"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: x := rand.Int()
  prefs: []
  type: TYPE_NORMAL
- en: if x < 100 {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("x is less than 100.")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if x < 1000 {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("x is less than 1000.")
  prefs: []
  type: TYPE_NORMAL
- en: '} else if x < 10000 {'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("x is less than 10,000.")
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("x is greater than 10,000")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("x:", x)
  prefs: []
  type: TYPE_NORMAL
- en: // You can put a statement before the condition
  prefs: []
  type: TYPE_NORMAL
- en: // The variable scope of n is limited
  prefs: []
  type: TYPE_NORMAL
- en: if n := rand.Int(); n > 1000 {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("n is greater than 1000.")
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("n:", n)
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("n is not greater than 1000.")
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("n:", n)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // n is no longer available past the if statement
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: // Basic for loop
  prefs: []
  type: TYPE_NORMAL
- en: for i := 0; i < 3; i++ {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("i:", i)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // For used as a while loop
  prefs: []
  type: TYPE_NORMAL
- en: n := 5
  prefs: []
  type: TYPE_NORMAL
- en: for n < 10 {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(n)
  prefs: []
  type: TYPE_NORMAL
- en: n++
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: intSlice := []int{2, 4, 6, 8}
  prefs: []
  type: TYPE_NORMAL
- en: for key, value := range intSlice {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(key, value)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: myMap := map[string]string{
  prefs: []
  type: TYPE_NORMAL
- en: '"d": "Donut",'
  prefs: []
  type: TYPE_NORMAL
- en: '"o": "Operator",'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Iterate over a map
  prefs: []
  type: TYPE_NORMAL
- en: for key, value := range myMap {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(key, value)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Iterate but only utilize keys
  prefs: []
  type: TYPE_NORMAL
- en: for key := range myMap {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(key)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Use underscore to ignore keys
  prefs: []
  type: TYPE_NORMAL
- en: for _, value := range myMap {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(value)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs: []
  type: TYPE_NORMAL
- en: '"math/rand"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: x := 42
  prefs: []
  type: TYPE_NORMAL
- en: switch x {
  prefs: []
  type: TYPE_NORMAL
- en: 'case 25:'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("X is 25")
  prefs: []
  type: TYPE_NORMAL
- en: 'case 42:'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("X is the magical 42")
  prefs: []
  type: TYPE_NORMAL
- en: // Fallthrough will continue to next case
  prefs: []
  type: TYPE_NORMAL
- en: fallthrough
  prefs: []
  type: TYPE_NORMAL
- en: 'case 100:'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("X is 100")
  prefs: []
  type: TYPE_NORMAL
- en: 'case 1000:'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("X is 1000")
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("X is something else.")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Like the if statement a statement
  prefs: []
  type: TYPE_NORMAL
- en: // can be put in front of the switched variable
  prefs: []
  type: TYPE_NORMAL
- en: switch r := rand.Int(); r {
  prefs: []
  type: TYPE_NORMAL
- en: 'case r % 2:'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("Random number r is even.")
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("Random number r is odd.")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // r is no longer available after the switch statement
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: goto customLabel
  prefs: []
  type: TYPE_NORMAL
- en: // Will never get executed because
  prefs: []
  type: TYPE_NORMAL
- en: // the goto statement will jump right
  prefs: []
  type: TYPE_NORMAL
- en: // past this line
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("Hello")
  prefs: []
  type: TYPE_NORMAL
- en: 'customLabel:'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("World")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"log"'
  prefs: []
  type: TYPE_NORMAL
- en: '"os"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: file, err := os.Create("test.txt")
  prefs: []
  type: TYPE_NORMAL
- en: if err != nil {
  prefs: []
  type: TYPE_NORMAL
- en: log.Fatal("Error creating file.")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: defer file.Close()
  prefs: []
  type: TYPE_NORMAL
- en: // It is important to defer after checking the errors.
  prefs: []
  type: TYPE_NORMAL
- en: // You can't call Close() on a nil object
  prefs: []
  type: TYPE_NORMAL
- en: // if the open failed.
  prefs: []
  type: TYPE_NORMAL
- en: // ...perform some other actions here...
  prefs: []
  type: TYPE_NORMAL
- en: // file.Close() will be called before final exit
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs: []
  type: TYPE_NORMAL
- en: '"log"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs: []
  type: TYPE_NORMAL
- en: '"reflect"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: type Person struct {
  prefs: []
  type: TYPE_NORMAL
- en: Name string
  prefs: []
  type: TYPE_NORMAL
- en: Age  int
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: type Doctor struct {
  prefs: []
  type: TYPE_NORMAL
- en: Person         Person
  prefs: []
  type: TYPE_NORMAL
- en: Specialization string
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: nanodano := Person{
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: "NanoDano",'
  prefs: []
  type: TYPE_NORMAL
- en: 'Age:  99,'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: drDano := Doctor{
  prefs: []
  type: TYPE_NORMAL
- en: 'Person:         nanodano,'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specialization: "Hacking",'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(reflect.TypeOf(nanodano))
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(nanodano)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(reflect.TypeOf(drDano))
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(drDano)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: type Person struct {
  prefs: []
  type: TYPE_NORMAL
- en: Name string
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func NewPerson() Person {
  prefs: []
  type: TYPE_NORMAL
- en: return Person{
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: "Anonymous",'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: p := NewPerson()
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(p)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: myObject.myMethod()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: type Person struct {
  prefs: []
  type: TYPE_NORMAL
- en: Name string
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Person function receiver
  prefs: []
  type: TYPE_NORMAL
- en: func (p Person) PrintInfo() {
  prefs: []
  type: TYPE_NORMAL
- en: 'fmt.Printf("Name: %s\n", p.Name)'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Person pointer receiver
  prefs: []
  type: TYPE_NORMAL
- en: // If you did not use the pointer receivers
  prefs: []
  type: TYPE_NORMAL
- en: // it would not modify the person object
  prefs: []
  type: TYPE_NORMAL
- en: // Try removing the asterisk here and seeing how the
  prefs: []
  type: TYPE_NORMAL
- en: // program changes behavior
  prefs: []
  type: TYPE_NORMAL
- en: func (p *Person) ChangeName(newName string) {
  prefs: []
  type: TYPE_NORMAL
- en: p.Name = newName
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'nanodano := Person{Name: "NanoDano"}'
  prefs: []
  type: TYPE_NORMAL
- en: nanodano.PrintInfo()
  prefs: []
  type: TYPE_NORMAL
- en: nanodano.ChangeName("Just Dano")
  prefs: []
  type: TYPE_NORMAL
- en: nanodano.PrintInfo()
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"log"'
  prefs: []
  type: TYPE_NORMAL
- en: '"time"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func countDown() {
  prefs: []
  type: TYPE_NORMAL
- en: for i := 5; i >= 0; i-- {
  prefs: []
  type: TYPE_NORMAL
- en: log.Println(i)
  prefs: []
  type: TYPE_NORMAL
- en: time.Sleep(time.Millisecond * 500)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: // Kick off a thread
  prefs: []
  type: TYPE_NORMAL
- en: go countDown()
  prefs: []
  type: TYPE_NORMAL
- en: // Since functions are first-class
  prefs: []
  type: TYPE_NORMAL
- en: // you can write an anonymous function
  prefs: []
  type: TYPE_NORMAL
- en: // for a goroutine
  prefs: []
  type: TYPE_NORMAL
- en: go func() {
  prefs: []
  type: TYPE_NORMAL
- en: time.Sleep(time.Second * 2)
  prefs: []
  type: TYPE_NORMAL
- en: log.Println("Delayed greetings!")
  prefs: []
  type: TYPE_NORMAL
- en: '}()'
  prefs: []
  type: TYPE_NORMAL
- en: // Use channels to signal when complete
  prefs: []
  type: TYPE_NORMAL
- en: // Or in this case just wait
  prefs: []
  type: TYPE_NORMAL
- en: time.Sleep(time.Second * 4)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Get fmt package information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: godoc fmt
  prefs: []
  type: TYPE_NORMAL
- en: Get source code for fmt package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: godoc -src fmt
  prefs: []
  type: TYPE_NORMAL
- en: Get specific function information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: godoc fmt Printf
  prefs: []
  type: TYPE_NORMAL
- en: Get source code for function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: godoc -src fmt Printf
  prefs: []
  type: TYPE_NORMAL
- en: Run HTTP server to view HTML documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: godoc -http=localhost:9999
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP option serves the same documentation that is available on [https://golang.org/](https://golang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter you should have a basic understanding of Go fundamentals
    such as what the keywords are, what they do, and what basic data types are available.
    You should also feel comfortable creating functions and custom data types.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is not to memorize all of the preceding information, but to be aware
    of what tools are available in the language. Use this chapter as a reference if
    necessary. You can find more information about the Go language specification at
    [https://golang.org/ref/spec](https://golang.org/ref/spec).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at working with files in Go. We will cover
    basics such as getting file information, seeing whether a file exists, truncating
    files, checking permissions, and creating new files. We will also cover the reader
    and writer interfaces, as well as a number of ways to read and write data. In
    addition to this, we will cover things such as archiving to ZIP or TAR files and
    compressing files with GZIP.
  prefs: []
  type: TYPE_NORMAL

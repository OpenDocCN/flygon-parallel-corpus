- en: Working with Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the defining features of Unix and Linux systems is how everything is
    treated as a file. Processes, files, directories, sockets, devices, and pipes
    are all treated as files. Given this fundamental feature of the operating system,
    learning how to manipulate files is a critical skill. This chapter provides several
    examples of the different ways to manipulate files.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will look at the basics, namely creating, truncating, deleting, opening,
    closing, renaming, and moving files. We will also look at how to get detailed
    attributes about a file, such as permissions and ownership, size, and symlink
    information.
  prefs: []
  type: TYPE_NORMAL
- en: A whole section in this chapter is dedicated to the different ways you can read
    from and write to files. There are multiple packages that contain useful functions;
    moreover, the reader and writer interfaces enable many different options, such
    as buffered readers and writers, direct read and writes, scanners, and helper
    functions for quick operations.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, examples are provided for archiving and unarchiving, compressing
    and uncompressing, creating temporary files and directories, and downloading files
    over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, this chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating empty files and truncating files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting detailed file information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming, moving, and deleting files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating permissions, ownership, and timestamps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symlinks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple ways of reading and writing files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporary files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading files over HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because files are such an integral part of the computing ecosystem, it is crucial
    to understand the options available in Go for working with files. This section
    covers some basic operations, such as opening, closing, creating, and deleting
    files. Additionally, it covers renaming and moving, seeing if files exist, modifying
    permissions, ownership, timestamps, and working with symbolic links. Most of these
    examples use a hard-coded filename of `test.txt`. Change this filename if you
    want to operate on a different file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an empty file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common tool used in Linux is the **touch** program. It's frequently used when
    you need to quickly create an empty file with a specific name. The following example
    replicates one of the common **touch** use case of creating an empty file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are limited uses to creating an empty file, but let''s consider one example.
    What if there was a service that wrote logs to a rotating set of files. Every
    day a new file is created with the current date, and the day''s logs are written
    to that file. The developer might have been smart and put very strict permissions
    on the log files so that only administrators can read them. But, what if they
    left loose permissions on the directory? What would happen if you created an empty
    file with the next day''s date? The service may only create a new log file if
    one does not exist, but if one does exist it will use it without checking the
    permissions. You could take advantage of this by creating an empty file that you
    have read permissions to. The file should be named the same way the service would
    name the log file. For example, if the service uses a format like this for logs:
    `logs-2018-01-30.txt`, you could create an empty file named `logs-2018-01-31.txt`
    and the next day, the service will write to that file since it already exists
    and you will have read permissions, as opposed to the service creating a new file
    with root only permissions if no file existed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code implementation of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Truncating a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Truncating a file is when you trim a file down to a maximum length. Truncating
    is often used to completely remove all contents of a file, but it can also be
    used to limit a file to a specific maximum size. One notable characteristic of
    `os.Truncate()` is that it will actually increase the length of a file if it is
    smaller than the specified truncate limit. It will fill any blank space with null
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Truncating a file has more practical uses than creating an empty file. When
    log files get too big, they can be truncated to save disk space. If you are attacking,
    you may want to truncate `.bash_history` and other log files to cover your tracks.
    Genuinely, malicious actors may truncate files just for the sake of destroying
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Getting the file info
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example will print out all the metadata available about a file.
    It includes the obvious attributes, namely name, size, permissions, last modified
    time, and whether it is a directory. The last data piece it contains is the `FileInfo.Sys()`
    interface. This contains information about the underlying source of the file,
    which is most commonly a filesystem on a hard disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Renaming a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard library provides a convenient function for moving a file. Renaming
    and moving are synonymous terms; if you want to move a file from one directory
    to another, use the `os.Rename()` function, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This following example is straightforward, and it demonstrates how to delete
    a file. The standard package provides `os.Remove()`, which expects a file path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Opening and closing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When opening a file, there are several options. When calling `os.Open()`, it
    just requires a filename and provides a read-only file. Another option is to use
    `os.OpenFile()`, which expects more options. You can specify whether you want
    a read-only or write-only file. You can also choose to read and write, append,
    create if does not exist, or truncate upon opening. Pass the desired options combined
    with the logical OR operator. Closing files is done by calling `Close()` on the
    file object. You can close a file explicitly or you can defer the call. Refer
    to [Chapter 2](1537b549-81fb-4988-b72b-33fbad866d5b.xhtml), *The Go Programming
    Language* for more details on the `defer` keyword. The following example does
    not use the `defer` keyword option, but later examples will:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Checking whether a file exists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking whether a file exists is a two-step process. First, `os.Stat()` must
    be called on the file to get `FileInfo`. If the file does not exist, then a `FileInfo`
    struct is not returned, but an error is returned. There are multiple errors that
    `os.Stat()` might return, so the error type must be inspected. The standard library
    provides a function called `os.IsNotExist()` that will inspect an error to see
    whether it was caused because a file does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will call `log.Fatal()` if the file does not exist, but
    you can handle the error gracefully and move on without exiting if desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Checking read and write permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the previous example, checking the read and write permissions is
    done by inspecting an error using a function called `os.IsPermission()`. This
    function will return true if the error passed was caused due to a permission problem,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Changing permissions, ownership, and timestamps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you own a file or have the right privileges, you can change the ownership,
    timestamp, and permissions. A set of functions are provided by the standard library.
    They are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.Chmod()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Chown()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Chtimes()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to use these functions to alter the
    metadata of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Hard links and symlinks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical file is just a pointer to a place on the hard disk, called an inode.
    A hard link creates a new pointer to the same place. A file will only be deleted
    from the disk after all links to it are removed. Hard links only work on the same
    filesystem. A hard link is what you might consider a "normal" link.
  prefs: []
  type: TYPE_NORMAL
- en: A symbolic link, or soft link, is a little different, it does not point directly
    to a place on the disk. Symlinks only reference other files by name. They can
    point to files on different filesystems. However, not all systems support symlinks.
  prefs: []
  type: TYPE_NORMAL
- en: Windows historically did not have good support for symlinks, but the examples
    were tested in Windows 10 Pro, and both hard links and symlinks work properly
    if you have administrator privileges. To execute a Go program from the command
    line as an administrator, first open Command Prompt as an administrator by right
    clicking on it and selecting Run as administrator. From there you can execute
    the program, and the symlinks and hard links will work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to create a hard link and a symbolically
    linked file, as well as determine if a file is a symlink and how to modify the
    symlink file metadata without altering the original file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Reading and writing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading and writing files can be done in numerous ways. Go provides interfaces
    that make it easy to write your own functions that work with files or any other
    reader/writer interface.
  prefs: []
  type: TYPE_NORMAL
- en: Between the `os`, `io`, and `ioutil` packages, you can find the right function
    for your needs. These examples cover a number of the options available.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example uses the `io.Copy()` function to copy the contents from
    one reader to another writer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Seeking positions in a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Seek()` function is useful for setting the file cursor in a specific location.
    By default, it starts at offset 0 and moves forward as you read bytes. You might
    want to reset the cursor back to the beginning of a file or jump directly to a
    specific location. The `Seek()` function allows you to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '`Seek()` takes two parameters. The first one is distance; you want to move
    the cursor in bytes. It can move forward with a positive integer, or backward
    in a file if a negative number is provided. The first parameter, the distance,
    is a relative value, not an absolute position in the file. The second parameter
    specifies where the relative point starts and is called `whence`. The `whence` parameter
    is the point of reference for the relative offset. It can either be `0`, `1`,
    or `2`, representing the beginning of the file, the current position, and the
    end of the file, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if `Seek(-1, 2)` was specified, it would set the file cursor
    one byte back from the end of the file. `Seek(2, 0)` would seek the second byte
    from the beginning of `file.Seek(5, 1)`, which would move the cursor forward 5
    bytes from its current position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Writing bytes to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can write using just the `os` package, which is needed already to open
    the file. Since all Go executables are statically linked binaries, every package
    you import increases the size of your executable. Other packages such as `io`,
    `ioutil`, and `bufio` provide some more help, but they are not necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Quickly writing to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ioutil` package has a useful function called `WriteFile()`, that will
    handle creating/opening, writing a slice of bytes, and closing. It is useful if
    you just need a quick way to dump a slice of bytes to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Buffered writer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `bufio` package lets you create a buffered writer so that you can work with
    a buffer in memory before writing it to disk. This is useful if you need to do
    a lot of manipulation on the data before writing it to disk to save time from
    disk IO. It is also useful if you only write one byte at a time and want to store
    a large number in a memory buffer before dumping it to file at once, otherwise
    you would be performing disk IO for every byte. This puts wear and tear on your
    disk as well as it slows down the process.
  prefs: []
  type: TYPE_NORMAL
- en: Buffered writers can be inspected to see how much unbuffered data it is currently
    storing and how much buffer space is remaining. A buffer can also be reset to
    undo any changes since the last flush. The buffers are also resizable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example opens a file named `test.txt` and creates a buffered
    writer that wraps the file object. A few bytes are written to the buffer and then
    a string is written. The in-memory buffer is then inspected before flushing the
    contents of the buffer to the file on disk. It also demonstrates how to reset
    a buffer, undoing any changes that have not been flushed, and how to inspect the
    space left in a buffer. Finally, it demonstrates how to resize the buffer to a
    specific size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Reading up to n bytes from a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `os.File` type comes with a couple of basic functions. One of them is `File.Read()`.
    `Read()`, which expects a byte slice to be passed as a parameter. Bytes are read
    from the file and placed in the byte slice. `Read()` will read as many bytes as
    it can or until the buffer fills up, and then it will stop reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple calls to `Read()` may be necessary before getting to the end of a
    file, depending on the size of the buffer provided and the size of the file. An
    `io.EOF` error is returned if the end of a file is reached during a call to `Read()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Reading exactly n bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, `File.Read()` will not return an error if a file only
    contains 10 bytes, but you provide a byte slice buffer with 500 bytes. There are
    some occasions where you want to ensure that the entire buffer is filled up. The
    `io.ReadFull()` function will return an error if the entire buffer is not filled
    up. If `io.ReadFull()` does not have any data to read, an EOF error is returned.
    If it reads some data, but then encounters an EOF, it will return an `ErrUnexpectedEOF` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Reading at least n bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another useful function provided by the `io` package is `io.ReadAtLeast()`.
    This will return an error if at least specific number of bytes are not. Similar
    to `io.ReadFull()`, an `EOF` error is returned if no data is found, and an `ErrUnexpectedEOF`
    error is returned if some data is read before encountering the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Reading all bytes of a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ioutil` package provides a function to read every byte in a file and return
    it as byte slice. This function is convenient because you do not have to define
    the byte slice before doing the read. The drawback is that a really large file
    will return a large slice that may be bigger than expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `io.ReadAll()` function expects a file that has already been opened with
    `os.Open()` or `Create()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Quickly reading whole files to memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the `io.ReadAll()` function in the previous example, `io.ReadFile()`
    will read all the bytes in a file and return a byte slice. The primary difference
    between the two is that `io.ReadFile()` expects a file path, not a file object
    that has already been opened. The `io.ReadFile()` function will take care of opening,
    reading, and closing the file. You just provide a filename and it provides the
    bytes. This is often the quickest and easiest method to load file data.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this method is very convenient, it has limitations; because it reads
    the entire file directly to memory, very large files may exhaust a system''s memory
    limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Buffered reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a buffered reader will store a memory buffer with some of the contents.
    A buffered reader also provides some more functions that are not available on
    the `os.File` or `io.Reader` types. The default buffer size is 4096 and the minimum
    size is 16\. Buffered readers provide a set of useful functions. Some of the functions
    available include, but are not limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Read()`: This is to read data into a byte slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Peek()`: This is to inspect the next bytes without moving the file cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadByte()`: This is to read a single byte'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnreadByte()`: This unreads the last byte read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadBytes()`: This reads bytes until the specified delimiter is reached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadString()`: This reads a string until the specified delimiter is reached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to use a buffered reader to get data
    from a file. First, it opens a file and then creates a buffered reader that wraps
    the file object. Once the buffered reader is ready, it shows how to use the preceding
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Reading with a scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scanner is part of the `bufio` package. It is useful for stepping through files
    at specific delimiters. Commonly, the newline character is used as the delimiter
    to break up a file by lines. In a CSV file, commas would be the delimiter. The
    `os.File` object can be wrapped in a `bufio.Scanner` object just like a buffered
    reader. We will call `Scan()` to read up to the next delimiter, and then, use
    `Text()` or `Bytes()` to get the data that was read.
  prefs: []
  type: TYPE_NORMAL
- en: The delimiter is not just a simple byte or character. There is actually a special
    function, which you have to implement, that will determine where the next delimiter
    is, how far forward to advance the pointer, and what data to return. If no custom
    `SplitFunc` type is provided, it defaults to `ScanLines`, which will split at
    every newline character. Other split functions included in `bufio` are `ScanRunes` and
    `ScanWords`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define your own split function, define a function that matches this fingerprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Returning (`0`, `nil`, `nil`) will tell the scanner to scan again, but with
    a bigger buffer because it wasn't enough data to reach the delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `bufio.Scanner` is created from the file, and then
    the file is scanned word by word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Archives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Archives are a file format that stores multiple files. Two of the most common
    archive formats are tar balls ZIP archives. The Go standard library has both the
    `tar` and `zip` packages. These examples use the ZIP format, but the tar format
    can easily be interchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Archive (ZIP) files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to create an archive with multiple files
    inside. The files in the example are hard-coded with only a few bytes, but should
    be easily adapted to suit other needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Extracting (unzip) archived files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to unarchive a ZIP format file. It will
    replicate the directory structure it finds inside the archive by creating directories
    if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Compression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go standard library also supports compression, which is different than archiving.
    Often, archiving and compressing are combined to package a large number of files
    in to a single compact file. The most common format is probably the `.tar.gz`
    file, which is a gzipped tar ball. Do not confuse zip and gzip as they are two
    different things.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go standard library has support for multiple compression algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bzip2**: bzip2 format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**flate**: DEFLATE (RFC 1951)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gzip**: gzip format (RFC 1952)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lzw**: Lempel-Ziv-Welch format from *A Technique for High-Performance Data
    Compression, Computer, 17(6) (June 1984), pp 8-19*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**zlib**: zlib format (RFC 1950)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about each package at [https://golang.org/pkg/compress/](https://golang.org/pkg/compress/).
    These examples use gzip compression, but it should be easy to interchange any
    of the above packages.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to compress a file using the `gzip`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Uncompressing a File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to uncompress a file using the `gzip`
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Before we wrap up this chapter about working with files, let's look at two more
    practical examples that may be useful. Temporary files and directories are useful
    when you don't want to create a permanent file, but need a file to work with.
    Additionally, a common way to obtain files is by downloading them over the internet.
    The next examples demonstrate these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating temporary files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ioutil` package provides two functions: `TempDir()` and `TempFile()`.
    It is the caller''s responsibility to delete the temporary items when done. The
    only benefit these functions provide is that you can pass it an empty string for
    the directory, and it will automatically create the item in the system''s default
    temporary folder (`/tmp` on Linux), since the `os.TempDir()` function will return
    the default system temporary directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Downloading a file over HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common task in modern computing is downloading a file over the HTTP protocol.
    The following example shows how to quickly download a specific URL to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other common tools that accomplish this task are `curl` and `wget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should be now familiar with some of the different
    ways to interact with files and feel comfortable performing basic operations.
    The goal is not to memorize all of these function names, but to be aware of what
    tools are available. This chapter can be used as a reference if you need sample
    code, but I encourage you to create a cookbook repository with snippets like these.
  prefs: []
  type: TYPE_NORMAL
- en: The useful file functions are spread across multiple packages. The `os` package
    contains only the basic operations for working with files such as opening, closing,
    and simple reads. The `io` package provides functions that can be used on reader
    and writer interfaces at a higher level than the `os` package. The `ioutil` package
    provides even higher-level convenience functions for working with files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the topic of forensics. It will cover things
    such as looking for anomalous files that are extremely large or recently modified.
    In addition to file forensics, we will cover some network forensic investigation
    topics, namely looking up hostnames, IPs, and MX records for a host. The forensics
    chapter also covers basic examples of steganography, showing how to hide data
    in images and how to find hidden data inside images.
  prefs: []
  type: TYPE_NORMAL

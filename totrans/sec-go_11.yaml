- en: Host Discovery and Enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Host discovery is the process of looking for hosts on a network. This is useful
    if you gained access to a machine on a private network, and you want to see which
    other machines are on the network and start to gather a picture of what the network
    looks like. You can also treat the entire internet as the network and look for
    certain types of hosts or just look for any hosts at all. Ping sweeps and port
    scanning are common techniques of identifying hosts. A common tool used for this
    purpose is nmap. In this chapter, we will cover basic port scanning with a TCP
    connect scan and banner grabbing, which are two of the most common use cases for
    nmap. We will also cover raw socket connections that can be used to manually interact
    and explore a server's ports.
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration is a similar idea, but refers to actively examining a specific machine
    to determine as much information as you can. This includes scanning a server's
    ports to see which one is open, grabbing banners to inspect services, making calls
    to various services to get version numbers and generally search for attack vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Host discovery and enumeration are critical steps to an effective penetration
    test because you cannot exploit a machine if you don't even know it exists. For
    example, if an attacker only knows how to find hosts using the `ping` command,
    then you can easily hide all of your hosts from the attacker by simply ignoring
    ping requests.
  prefs: []
  type: TYPE_NORMAL
- en: Host discovery and enumeration require active connections to a machine so that
    you will leave logs, possibly trigger alarms, and otherwise, get noticed. There
    are some ways to be sneaky, such as performing TCP SYN-only scans so that a complete
    TCP connection is never made, or using a proxy when connecting, which will not
    hide your presence, but will make it appear as if you are connecting from somewhere
    else. Using a proxy to hide your IP can be useful if the IP gets blocked, because
    you can simply switch to a new proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing is also covered in this chapter, although it is only touched on very
    briefly. Fuzzing warrants its own chapter and, in fact, whole books have been
    written about the topic. Fuzzing is more useful when reverse engineering or searching
    for vulnerabilities, but can be useful for getting information about a service.
    For example, a service may return no response, giving you no clues about its purpose,
    but if you fuzz it with bad data and it returns an error, you may learn what kind
    of input it is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will specifically cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: TCP and UDP sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Banner grabbing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding named hosts on a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing network services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP and UDP sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sockets are the building blocks of networking. Servers listen and clients dial
    using sockets to bind together and share information. The **Internet Protocol**
    (**IP**) layer specifies the address of a machine, but the **Transmission Control
    Protocol** (**TCP**) or the **User Datagram Protocol** (**UDP**) specify which
    port on the machine should be used.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between the two is the connection state. TCP keeps the connection
    alive and verifies that messages are received. UDP just sends a message off without
    receiving an acknowledgement from the remote host.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example server. The `tcp` argument for `net.Listen()` can be changed
    to `udp` if you want to change protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating a client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example creates a simple network client that will work with the server
    from the previous example. This example uses TCP but, like `net.Listen()`, you
    can simply swap `tcp` for `udp` in `net.Dial()` if you want to switch protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Port scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After finding a host on the network, perhaps after doing a ping sweep or monitoring
    the network traffic, you typically want to scan the ports and see which ports
    are open and accepting connections. You can learn a lot about a machine just by
    seeing what ports are open. You might be able to determine whether it is Windows
    or Linux or whether it is hosting an email server, a web server, a database server,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of port scans, but this example demonstrates the most basic
    and straightforward port scan example, which is a TCP connect scan. It connects
    like any typical client and sees whether the server accepts the request. It does
    not send or receive any data and immediately disconnects, logging if it was successful.
  prefs: []
  type: TYPE_NORMAL
- en: The following example scans the localhost machine only and limits the ports
    checked to the reserved ports 0-1024\. Database servers, such as MySQL, often
    listen on higher number ports such as `3306`, so remove you will want to adjust
    the port range or use a predefined list of common ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each TCP connect request is done in a separate goroutine, so they all will
    run concurrently and it finishes very quickly. The `net.DialTimeout()` function
    is used so that we can set the maximum duration of time we are willing to wait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Grabbing a banner from a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After identifying the ports that are open, you can try to read from the connection
    and see whether the service provides a banner or an initial message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example works like the previous, but instead of just connecting
    and disconnecting, it will connect and try to read an initial message from the
    server. If the server provides any data, it is printed, but if the server does
    not send any data, nothing is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating a TCP proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much like the HTTP proxy in [Chapter 9](f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml),
    *Web Applications*, a TCP level proxy can be useful for debugging, logging, analyzing
    traffic, and privacy. When doing port scans, host discovery, and enumeration,
    a proxy can be useful to hide your location and source IP address. You may want
    to hide where you are coming from, disguise who you are, or just use a throwaway
    IP in case you get blacklisted for performing the requests.
  prefs: []
  type: TYPE_NORMAL
- en: The following example will listen in on a local port, forward a request to a
    remote host, and then send the response of the remote server back to the client.
    It will also log any requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test out this proxy by running the server in the previous section and
    then setting up the proxy to forward to that server. When the echoing server and
    the proxy server are running, use the TCP client to connect to the proxy server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finding named hosts on a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have just gained access to a network, one of the first things you can
    do is to get an idea of what hosts are on the network. You can scan all IP addresses
    on a subnet and then do a DNS lookup to see if you can find any named hosts. Hostnames
    can have descriptive or informative names that give clues as to what a server
    may be running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pure Go resolver is default and can only block a goroutine instead of a
    system thread, making it a little more efficient. You can explicitly set the DNS
    resolver with an environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This example looks for every possible host on a subnet and tries to resolve
    a hostname for each IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Fuzzing a network service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fuzzing is when you send intentionally malformed, excessive, or random data
    to an application in an attempt to make it misbehave, crash, or reveal sensitive
    information. You can identify buffer overflow vulnerabilities, which can result
    in remote code execution. If you cause an application to crash or stop responding
    after you send it data of a certain size, it may be due to a buffer overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will just cause a denial of service by causing a service to use
    too much memory or tie up all the processing power. Regular expressions are notoriously
    slow and can be abused in the URL routing mechanisms of web applications to consume
    all the CPU with few requests.
  prefs: []
  type: TYPE_NORMAL
- en: Nonrandom, but malformed, data can be just as dangerous, if not more so. A properly
    malformed video file can cause VLC to crash and expose code execution. A properly
    malformed packet, with 1 byte altered, can lead to sensitive data being exposed,
    as in the Heartbleed OpenSSL vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: The following example will demonstrate a very basic TCP fuzzer. It sends random
    bytes of increasing length to a server. It starts with 1 byte and grows exponentially
    by a power of 2\. First, it sends 1 byte, then 2, 4, 8, 16, continuing until it
    returns an error or reaches the maximum configured limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tweak `maxFuzzBytes` to set the maximum size of data you want to send to the
    service. Be aware that it launches all the threads at once, so be careful about
    the load on the server. Look for anomalies in the responses or for a total crash
    from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having reading this chapter, you should now understand the basic concepts of
    host discovery and enumeration. You should be able to explain them at a high level
    and provide a basic example of each concept.
  prefs: []
  type: TYPE_NORMAL
- en: First, we discussed raw TCP sockets with an example of a simple server and client.
    These examples aren't incredibly useful by themselves, but they are the template
    for building tools that perform custom interactions with services. This will be
    helpful when trying to fingerprint an unidentified service.
  prefs: []
  type: TYPE_NORMAL
- en: You should now know how to run a simple port scan, and why you might want to
    run a port scan. You should understand how to use a TCP proxy and what benefits
    it offers. You should understand how banner grabbing works and why it is a useful
    method for gathering information.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous other forms of enumeration. With web applications, you can
    enumerate usernames, user ids, emails, and more. For example, if a website used
    the URL format [www.example.com/user_profile/1234](http://www.example.com/user_profile/1234) you
    can potentially start with the number 1, and increment by 1, crawling through
    every single user profile available on the site. Other forms include SNMP, DNS,
    LDAP, and SMB.
  prefs: []
  type: TYPE_NORMAL
- en: What other forms of enumeration can you think of? What kind of enumeration can
    you think of if you were already on a server with a low privilege user? What kind
    of information would you want to gather about a server once you had a shell?
  prefs: []
  type: TYPE_NORMAL
- en: You can gather a lot of information once you are on a server: username and groups,
    hostnames, network device info, mounted filesystems, what services are running,
    iptables settings, cron jobs, startup services, and more. Refer to [Chapter 13](470c944c-e4ca-4a39-95e4-6c78d831aa27.xhtml),
    *Post Exploitation,* for more information about what to do once you already have
    access to a machine.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at social engineering and how to gather intel
    from the web via JSON REST APIs, send phishing emails, and generate QR codes.
    We will also look at multiple examples of honeypots including a TCP honeypot and
    two methods of HTTP honeypots.
  prefs: []
  type: TYPE_NORMAL

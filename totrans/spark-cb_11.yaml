- en: Chapter 11. Graph Processing Using GraphX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover how we can do graph processing using GraphX, Spark's
    graph processing library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter is divided into the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental operations on graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PageRank
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding connected components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing neighborhood aggregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph analysis is much more commonplace in our life than we think. To take the
    most common example, when we ask a GPS to find the shortest route to a destination,
    it uses a graph-processing algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by understanding graphs. A graph is a representation of a set of
    vertices where some pairs of vertices are connected by edges. When these edges
    move from one direction to another, it's called a **directed graph** or **digraph**.
  prefs: []
  type: TYPE_NORMAL
- en: GraphX is the Spark API for graph processing. It provides a wrapper around an
    RDD called **resilient distributed property graph**. The property graph is a directed
    multigraph with properties attached to each vertex and edge.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of graphs—directed graphs (digraphs) and regular graphs.
    Directed graphs have edges that run in one direction, for example, from vertex
    A to vertex B. Twitter follower is a good example of a digraph. If John is David's
    Twitter follower, it does not mean that David is John's follower. On the other
    hand, Facebook is a good example of a regular graph. If John is David's Facebook
    friend, David is also John's Facebook friend.
  prefs: []
  type: TYPE_NORMAL
- en: A multigraph is a graph which is allowed to have multiple edges (also called
    **parallel edges**). Since every edge in GraphX has properties, each edge has
    its own identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, for distributed graph processing, there have been two types
    of systems:'
  prefs: []
  type: TYPE_NORMAL
- en: Data parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphX aims to combine the two together in one system. GraphX API enables users
    to view the data both as graphs and as collections (RDDs) without data movement.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental operations on graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create graphs and do basic operations on
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a starting example, we will have three vertices, each representing the city
    center of three cities in California—Santa Clara, Fremont, and San Francisco.
    The following is the distance between these cities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Source | Destination | Distance (miles) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Santa Clara, CA | Fremont, CA | 20 |'
  prefs: []
  type: TYPE_TB
- en: '| Fremont, CA | San Francisco, CA | 44 |'
  prefs: []
  type: TYPE_TB
- en: '| San Francisco, CA | Santa Clara, CA | 53 |'
  prefs: []
  type: TYPE_TB
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the GraphX-related classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the vertex data in an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the array of vertices into the RDD of vertices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the edge data in an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the data into the RDD of edges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Print all the vertices of the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Print all the edges of the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the edge triplets; a triplet is created by adding source and destination
    attributes to an edge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In-degree of a graph is the number of inward-directed edges it has. Print the
    in-degree of each vertex (as `VertexRDD[Int]`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using PageRank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PageRank measures the importance of each vertex in a graph. PageRank was started
    by Google's founders, who used the theory that the most important pages on the
    Internet are the pages with the most links leading to them. PageRank also looks
    at the importance of a page leading to the target page. So, if a given web page
    has incoming links from higher rank pages, it will be ranked higher.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to use Wikipedia page link data to calculate page rank. Wikipedia
    publishes its data in the form of a database dump. We are going to use link data
    from [http://haselgrove.id.au/wikipedia.htm](http://haselgrove.id.au/wikipedia.htm),
    which has the data in two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`links-simple-sorted.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`titles-sorted.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have put both of them on Amazon S3 at `s3n://com.infoobjects.wiki/links` and
    `s3n://com.infoobjects.wiki/nodes`. Since the data size is larger, it is recommended
    that you run it on either Amazon EC2 or your local cluster. Sandbox may be very
    slow.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can load the files to `hdfs` using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the GraphX related classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the edges from `hdfs` with 20 partitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, load the edges from Amazon S3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `links` file has links in the "sourcelink: link1 link2 …" format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flatten and convert it into an RDD of "link1,link2" format and then convert
    it into an RDD of `Edge` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the vertices from `hdfs` with 20 partitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, load the edges from Amazon S3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide an index to the vertices and then swap it to make it in the (index,
    title) format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `graph` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run PageRank and get the vertices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As ranks is in the (vertex ID, pagerank) format, swap it to make it in the
    (pagerank, vertex ID) format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Sort to get the highest ranked pages first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the highest ranked page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command gives the vertex id, which you still have to look up
    to see the actual title with rank. Let''s do a join:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Sort the joined RDD again after converting from the (vertex ID, (page rank,
    title)) format to the (page rank, (vertex ID, title)) format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Print the top five ranked pages
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the output should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Finding connected components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A connected component is a subgraph (a graph whose vertices are a subset of
    the vertex set of the original graph and whose edges are a subset of the edge
    set of the original graph) in which any two vertices are connected to each other
    by an edge or a series of edges.
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to understand it would be by taking a look at the road network graph
    of Hawaii. This state has numerous islands, which are not connected by roads.
    Within each island, most roads will be connected to each other. The goal of finding
    the connected components is to find these clusters.
  prefs: []
  type: TYPE_NORMAL
- en: The connected components algorithm labels each connected component of the graph
    with the ID of its lowest-numbered vertex.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will build a small graph here for the clusters we know and use connected
    components to segregate them. Let''s look at the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/3056_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| Follower | Followee |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| John | Pat |'
  prefs: []
  type: TYPE_TB
- en: '| Pat | Dave |'
  prefs: []
  type: TYPE_TB
- en: '| Gary | Chris |'
  prefs: []
  type: TYPE_TB
- en: '| Chris | Bill |'
  prefs: []
  type: TYPE_TB
- en: 'The preceding data is a simple one with six vertices and two clusters. Let''s
    put this data in the form of two files: `nodes.csv` and `edges.csv`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of `nodes.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the content of `edges.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We should expect a connected component algorithm to identify two clusters, the
    first one identified by (1,John) and the second by (4,Gary).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can load the files to `hdfs` using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Load the Spark shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the GraphX-related classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the edges from `hdfs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert the `edgesFile` RDD into the RDD of edges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the vertices from `hdfs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Map the vertices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `graph` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculate the connected components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the vertices for the connected components (which is a subgraph):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the `ccVertices`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the output, vertices 1,2,3 are pointing to 1, while 4,5,6
    are pointing to 4\. Both of these are the lowest-indexed vertices in their respective
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Performing neighborhood aggregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GraphX does most of the computation by isolating each vertex and its neighbors.
    It makes it easier to process the massive graph data on distributed systems. This
    makes the neighborhood operations very important. GraphX has a mechanism to do
    it at each neighborhood level in the form of the `aggregateMessages` method. It
    does it in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first step (first function of the method), messages are send to the destination
    vertex or source vertex (similar to the Map function in MapReduce).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second step (second function of the method), aggregation is done on these
    messages (similar to the Reduce function in MapReduce).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s build a small dataset of the followers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Follower | Followee |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| John | Barack |'
  prefs: []
  type: TYPE_TB
- en: '| Pat | Barack |'
  prefs: []
  type: TYPE_TB
- en: '| Gary | Barack |'
  prefs: []
  type: TYPE_TB
- en: '| Chris | Mitt |'
  prefs: []
  type: TYPE_TB
- en: '| Rob | Mitt |'
  prefs: []
  type: TYPE_TB
- en: 'Our goal is to find out how many followers each node has. Let''s load this
    data in the form of two files: `nodes.csv` and `edges.csv`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of `nodes.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the content of `edges.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can load the files to `hdfs` using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Load the Spark shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the GraphX related classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the edges from `hdfs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert the edges into the RDD of edges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the vertices from `hdfs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Map the vertices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `graph` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the neighborhood aggregation by sending messages to the followees with the
    number of followers from each follower, that is, 1 and then adding the number
    of followers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Print `followerCount` in the form of (followee, number of followers):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE

- en: Part I. JavaScript Quick Start
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part is a self-contained quick introduction to JavaScript. You can understand
    it without reading anything else in this book, and no other part of the book depends
    on its contents. However, the tips for how to read this book in [Tips for Reading
    This Book](pr02.html#how_to_read "Tips for Reading This Book") do apply.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1. Basic JavaScript
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter is about “Basic JavaScript,” a name I chose for a subset of JavaScript
    that is as concise as possible while still enabling you to be productive. When
    you are starting to learn JavaScript, I recommend that you program in it for a
    while before moving on to the rest of the language. That way, you don’t have to
    learn everything at once, which can be confusing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Background
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section gives a little background on JavaScript to help you understand
    why it is the way it is.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Versus ECMAScript
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ECMAScript* is the official name for JavaScript. A new name became necessary
    because there is a trademark on *Java* (held originally by Sun, now by Oracle).
    At the moment, Mozilla is one of the few companies allowed to officially use the
    name *JavaScript* because it received a license long ago. For common usage, the
    following rules apply:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '*JavaScript* means the programming language.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ECMAScript* is the name used by the language specification. Therefore, whenever
    referring to versions of the language, people say *ECMAScript*. The current version
    of JavaScript is ECMAScript 5; ECMAScript 6 is currently being developed.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Influences and Nature of the Language
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript’s creator, Brendan Eich, had no choice but to create the language
    very quickly (or other, worse technologies would have been adopted by Netscape).
    He borrowed from several programming languages: Java (syntax, primitive values
    versus objects), Scheme and AWK (first-class functions), Self (prototypal inheritance),
    and Perl and Python (strings, arrays, and regular expressions).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript did not have exception handling until ECMAScript 3, which explains
    why the language so often automatically converts values and so often fails silently:
    it initially couldn’t throw exceptions.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: On one hand, JavaScript has quirks and is missing quite a bit of functionality
    (block-scoped variables, modules, support for subclassing, etc.). On the other
    hand, it has several powerful features that allow you to work around these problems.
    In other languages, you learn language features. In JavaScript, you often learn
    patterns instead.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Given its influences, it is no surprise that JavaScript enables a programming
    style that is a mixture of functional programming (higher-order functions; built-in
    `map`, `reduce`, etc.) and object-oriented programming (objects, inheritance).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explains basic syntactic principles of JavaScript.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: An Overview of the Syntax
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A few examples of syntax:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note the two different uses of the equals sign:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: A single equals sign (`=`) is used to assign a value to a variable.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A triple equals sign (`===`) is used to compare two values (see [Equality Operators](ch01.html#basic_equality_operators
    "Equality Operators")).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements Versus Expressions
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand JavaScript’s syntax, you should know that it has two major syntactic
    categories: statements and expressions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Statements “do things.” A program is a sequence of statements. Here is an example
    of a statement, which declares (creates) a variable `foo`:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Expressions produce values. They are function arguments, the right side of
    an assignment, etc. Here’s an example of an expression:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The distinction between statements and expressions is best illustrated by the
    fact that JavaScript has two different ways to do `if-then-else`—either as a statement:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'or as an expression:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can use the latter as a function argument (but not the former):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, wherever JavaScript expects a statement, you can also use an expression;
    for example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The whole line is a statement (a so-called *expression statement*), but the
    function call `foo(7, 1)` is an expression.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Semicolons
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Semicolons are optional in JavaScript. However, I recommend always including
    them, because otherwise JavaScript can guess wrong about the end of a statement.
    The details are explained in [Automatic Semicolon Insertion](ch07.html#automatic_semicolon_insertion
    "Automatic Semicolon Insertion").
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Semicolons terminate statements, but not blocks. There is one case where you
    will see a semicolon after a block: a function expression is an expression that
    ends with a block. If such an expression comes last in a statement, it is followed
    by a semicolon:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Comments
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has two kinds of comments: single-line comments and multiline comments.
    Single-line comments start with `//` and are terminated by the end of the line:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Multiline comments are delimited by `/*` and `*/`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Variables and Assignment
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables in JavaScript are declared before they are used:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Assignment
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can declare a variable and assign a value at the same time:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also assign a value to an existing variable:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Compound Assignment Operators
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are compound assignment operators such as `+=`. The following two assignments
    are equivalent:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Identifiers and Variable Names
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Identifiers* are names that play various syntactic roles in JavaScript. For
    example, the name of a variable is an identifier. Identifiers are case sensitive.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly, the first character of an identifier can be any Unicode letter, a
    dollar sign (`$`), or an underscore (`_`). Subsequent characters can additionally
    be any Unicode digit. Thus, the following are all legal identifiers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following identifiers are *reserved words*—they are part of the syntax
    and can’t be used as variable names (including function names and parameter names):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '| `arguments` | `break` | `case` | `catch` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| `class` | `const` | `continue` | `debugger` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| `default` | `delete` | `do` | `else` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| `enum` | `export` | `extends` | `false` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| `finally` | `for` | `function` | `if` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| `implements` | `import` | `in` | `instanceof` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| `interface` | `let` | `new` | `null` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| `package` | `private` | `protected` | `public` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| `return` | `static` | `super` | `switch` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| `this` | `throw` | `true` | `try` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| `typeof` | `var` | `void` | `while` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: 'The following three identifiers are not reserved words, but you should treat
    them as if they were:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '| `Infinity` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| `NaN` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| `undefined` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: Lastly, you should also stay away from the names of standard global variables
    (see [Chapter 23](ch23.html "Chapter 23. Standard Global Variables")). You can
    use them for local variables without breaking anything, but your code still becomes
    confusing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Values
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has many values that we have come to expect from programming languages:
    booleans, numbers, strings, arrays, and so on. All values in JavaScript have *properties*.
    Each property has a *key* (or *name*) and a *value*. You can think of properties
    like fields of a record. You use the dot (`.`) operator to read a property:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For example, the string `''abc''` has the property `length`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding can also be written as:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The dot operator is also used to assign a value to a property:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And you can use it to invoke methods:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, we have invoked the method `toUpperCase()` on the
    value `'hello'`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Values Versus Objects
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript makes a somewhat arbitrary distinction between values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The *primitive values* are booleans, numbers, strings, `null`, and `undefined`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other values are *objects*.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A major difference between the two is how they are compared; each object has
    a unique identity and is only (strictly) equal to itself:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In contrast, all primitive values encoding the same value are considered the
    same:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The next two sections explain primitive values and objects in more detail.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Values
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are all of the primitive values (or *primitives* for short):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Booleans: `true`, `false` (see [Booleans](ch01.html#basic_booleans "Booleans"))'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Numbers: `1736`, `1.351` (see [Numbers](ch01.html#basic_numbers "Numbers"))'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strings: `''abc''`, `"abc"` (see [Strings](ch01.html#basic_strings "Strings"))'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two “nonvalues”: `undefined`, `null` (see [undefined and null](ch01.html#basic_undefined_null
    "undefined and null"))'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Primitives have the following characteristics:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Compared by value
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The “content” is compared:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Always immutable
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties can’t be changed, added, or removed:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: (Reading an unknown property always returns `undefined`.)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All nonprimitive values are *objects*. The most common kinds of objects are:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '*Plain objects*, which can be created by *object literals* (see [Single Objects](ch01.html#basic_single_objects
    "Single Objects")):'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding object has two properties: the value of property `firstName`
    is `''Jane''` and the value of property `lastName` is `''Doe''`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '*Arrays*, which can be created by *array literals* (see [Arrays](ch01.html#basic_arrays
    "Arrays")):'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding array has three elements that can be accessed via numeric indices.
    For example, the index of `'apple'` is 0.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '*Regular expressions*, which can be created by *regular expression literals*
    (see [Regular Expressions](ch01.html#basic_regexps "Regular Expressions")):'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Objects have the following characteristics:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Compared by reference
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Identities are compared; every value has its own identity:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Mutable by default
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'You can normally freely change, add, and remove properties (see [Single Objects](ch01.html#basic_single_objects
    "Single Objects")):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: undefined and null
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most programming languages have values denoting missing information. JavaScript
    has two such “nonvalues,” `undefined` and `null`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined` means “no value.” Uninitialized variables are `undefined`:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Missing parameters are `undefined`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you read a nonexistent property, you get `undefined`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`null` means “no object.” It is used as a nonvalue whenever an object is expected
    (parameters, last in a chain of objects, etc.).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`undefined` and `null` have no properties, not even standard methods such as
    `toString()`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Checking for undefined or null
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Functions normally allow you to indicate a missing value via either `undefined`
    or `null`. You can do the same via an explicit check:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also exploit the fact that both `undefined` and `null` are considered
    `false`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Warning
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`false`, `0`, `NaN`, and `''''` are also considered `false` (see [Truthy and
    Falsy](ch01.html#basic_truthy_falsy "Truthy and Falsy")).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Categorizing Values Using typeof and instanceof
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two operators for categorizing values: `typeof` is mainly used for
    primitive values, while `instanceof` is used for objects.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '`typeof` looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It returns a string describing the “type” of `value`. Here are some examples:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following table lists all results of `typeof`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '| Operand | Result |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `''undefined''` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| `null` | `''object''` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| Boolean value | `''boolean''` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| Number value | `''number''` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| String value | `''string''` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| Function | `''function''` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| All other normal values | `''object''` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| (Engine-created value) | JavaScript engines are allowed to create values
    for which `typeof` returns arbitrary strings (different from all results listed
    in this table). |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '`typeof null` returning `''object''` is a bug that can’t be fixed, because
    it would break existing code. It does not mean that `null` is an object.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '`instanceof` looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It returns `true` if `value` is an object that has been created by the constructor
    `Constr` (see [Constructors: Factories for Objects](ch01.html#basic_constructors
    "Constructors: Factories for Objects")). Here are some examples:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Booleans
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The primitive boolean type comprises the values `true` and `false`. The following
    operators produce booleans:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary logical operators: `&&` (And), `||` (Or)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prefix logical operator: `!` (Not)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comparison operators:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Equality operators: `===`, `!==`, `==`, `!=`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ordering operators (for strings and numbers): `>`, `>=`, `<`, `<=`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truthy and Falsy
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever JavaScript expects a boolean value (e.g., for the condition of an
    `if` statement), any value can be used. It will be interpreted as either `true`
    or `false`. The following values are interpreted as `false`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined`, `null`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boolean: `false`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Number: `-0`, `NaN`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String: `''''`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All other values (including all objects!) are considered `true`. Values interpreted
    as `false` are called *falsy*, and values interpreted as `true` are called *truthy*.
    `Boolean()`, called as a function, converts its parameter to a boolean. You can
    use it to test how a value is interpreted:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Binary Logical Operators
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Binary logical operators in JavaScript are *short-circuiting*. That is, if
    the first operand suffices for determining the result, the second operand is not
    evaluated. For example, in the following expressions, the function `foo()` is
    never called:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Furthermore, binary logical operators return either one of their operands—which
    may or may not be a boolean. A check for truthiness is used to determine which
    one:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: And (`&&`)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'If the first operand is falsy, return it. Otherwise, return the second operand:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Or (`||`)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'If the first operand is truthy, return it. Otherwise, return the second operand:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Equality Operators
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has two kinds of equality:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal, or “lenient,” (in)equality: `==` and `!=`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strict (in)equality: `===` and `!==`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal equality considers (too) many values to be equal (the details are explained
    in [Normal (Lenient) Equality (==, !=)](ch09.html#normal_equality "Normal (Lenient)
    Equality (==, !=)")), which can hide bugs. Therefore, always using strict equality
    is recommended.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All numbers in JavaScript are floating-point:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Special numbers include the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '`NaN` (“not a number”)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'An error value:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`Infinity`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Also mostly an error value:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`Infinity` is larger than any other number (except `NaN`). Similarly, `-Infinity`
    is smaller than any other number (except `NaN`). That makes these numbers useful
    as default values (e.g., when you are looking for a minimum or a maximum).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has the following arithmetic operators (see [Arithmetic Operators](ch11.html#arithmetic_operators
    "Arithmetic Operators")):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Addition: `number1 + number2`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subtraction: `number1 - number2`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiplication: `number1 * number2`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Division: `number1 / number2`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remainder: `number1 % number2`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Increment: `++variable`, `variable++`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decrement: `--variable`, `variable--`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Negate: `-value`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Convert to number: `+value`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The global object `Math` (see [Math](ch01.html#basic_math "Math")) provides
    more arithmetic operations, via functions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript also has operators for bitwise operations (e.g., bitwise And; see
    [Bitwise Operators](ch11.html#bitwise_operators "Bitwise Operators")).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strings can be created directly via string literals. Those literals are delimited
    by single or double quotes. The backslash (`\`) escapes characters and produces
    a few control characters. Here are some examples:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Single characters are accessed via square brackets:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The property `length` counts the number of characters in the string:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Like all primitives, strings are immutable; you need to create a new string
    if you want to change an existing one.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: String Operators
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings are concatenated via the plus (`+`) operator, which converts the other
    operand to a string if one of the operands is a string:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To concatenate strings in multiple steps, use the `+=` operator:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: String Methods
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings have many useful methods (see [String Prototype Methods](ch12.html#string_prototype_methods
    "String Prototype Methods")). Here are some examples:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Statements
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conditionals and loops in JavaScript are introduced in the following sections.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `if` statement has a `then` clause and an optional `else` clause that are
    executed depending on a boolean condition:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'I recommend always using braces (they denote blocks of zero or more statements).
    But you don’t have to do so if a clause is only a single statement (the same holds
    for the control flow statements `for` and `while`):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following is a `switch` statement. The value of `fruit` decides which `case`
    is executed:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The “operand” after `case` can be any expression; it is compared via `===` with
    the parameter of `switch`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `for` loop has the following format:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`init` is executed at the beginning of the loop. `condition` is checked before
    each loop iteration; if it becomes `false`, then the loop is terminated. `post_iteration`
    is executed after each loop iteration.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'This example prints all elements of the array `arr` on the console:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `while` loop continues looping over its body while its condition holds:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `do-while` loop continues looping over its body while its condition holds.
    As the condition follows the body, the body is always executed at least once:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In all loops:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '`break` leaves the loop.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`continue` starts a new loop iteration.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way of defining a function is via a *function declaration*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding code defines a function, `add`, that has two parameters, `param1`
    and `param2`, and returns the sum of both parameters. This is how you call that
    function:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Another way of defining `add()` is by assigning a *function expression* to
    a variable `add`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A function expression produces a value and can thus be used to directly pass
    functions as arguments to other functions:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Function Declarations Are Hoisted
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Function declarations are *hoisted*—moved in their entirety to the beginning
    of the current scope. That allows you to refer to functions that are declared
    later:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that while `var` declarations are also hoisted (see [Variables Are Hoisted](ch01.html#basic_var_hoisting
    "Variables Are Hoisted")), assignments performed by them are not:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The Special Variable arguments
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can call any function in JavaScript with an arbitrary amount of arguments;
    the language will never complain. It will, however, make all parameters available
    via the special variable `arguments`. `arguments` looks like an array, but has
    none of the array methods:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Too Many or Too Few Arguments
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s use the following function to explore how too many or too few parameters
    are handled in JavaScript (the function `toArray()` is shown in [Converting arguments
    to an Array](ch01.html#basic_toarray "Converting arguments to an Array")):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Additional parameters will be ignored (except by `arguments`):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Missing parameters will get the value `undefined`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Optional Parameters
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a common pattern for assigning default values to parameters:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In line (1), the `||` operator returns `x` if it is truthy (not `null`, `undefined`,
    etc.). Otherwise, it returns the second operand:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Enforcing an Arity
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to enforce an *arity* (a specific number of parameters), you can
    check `arguments.length`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Converting arguments to an Array
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arguments` is not an array, it is only *array-like* (see [Array-Like Objects
    and Generic Methods](ch17_split_001.html#array-like_objects "Array-Like Objects
    and Generic Methods")). It has a property `length`, and you can access its elements
    via indices in square brackets. You cannot, however, remove elements or invoke
    any of the array methods on it. Thus, you sometimes need to convert `arguments`
    to an array, which is what the following function does (it is explained in [Array-Like
    Objects and Generic Methods](ch17_split_001.html#array-like_objects "Array-Like
    Objects and Generic Methods")):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Exception Handling
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common way to handle exceptions (see [Chapter 14](ch14.html "Chapter 14. Exception
    Handling")) is as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `try` clause surrounds critical code, and the `catch` clause is executed
    if an exception is thrown inside the `try` clause. Using the preceding code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Strict Mode
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strict mode (see [Strict Mode](ch07.html#strict_mode "Strict Mode")) enables
    more warnings and makes JavaScript a cleaner language (nonstrict mode is sometimes
    called “sloppy mode”). To switch it on, type the following line first in a JavaScript
    file or a `<script>` tag:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can also enable strict mode per function:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Variable Scoping and Closures
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, you declare variables via `var` before using them:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can declare and initialize several variables with a single `var` statement:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'But I recommend using one statement per variable (the reason is explained in
    [Syntax](ch26.html#style_one_var_per_line "Syntax")). Thus, I would rewrite the
    previous statement to:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Because of hoisting (see [Variables Are Hoisted](ch01.html#basic_var_hoisting
    "Variables Are Hoisted")), it is usually best to declare variables at the beginning
    of a function.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Variables Are Function-Scoped
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The scope of a variable is always the complete function (as opposed to the
    current block). For example:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We can see that the variable `tmp` is not restricted to the block starting in
    line (1); it exists until the end of the function.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Variables Are Hoisted
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each variable declaration is *hoisted*: the declaration is moved to the beginning
    of the function, but assignments that it makes stay put. As an example, consider
    the variable declaration in line (1) in the following function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Internally, the preceding function is executed like this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Closures
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each function stays connected to the variables of the functions that surround
    it, even after it leaves the scope in which it was created. For example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The function starting in line (1) leaves the context in which it was created,
    but stays connected to a live version of `start`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: A *closure* is a function plus the connection to the variables of its surrounding
    scopes. Thus, what `createIncrementor()` returns is a closure.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'The IIFE Pattern: Introducing a New Scope'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you want to introduce a new variable scope—for example, to prevent
    a variable from becoming global. In JavaScript, you can’t use a block to do so;
    you must use a function. But there is a pattern for using a function in a block-like
    manner. It is called *IIFE* ([immediately invoked function expression](http://bit.ly/i-ife),
    pronounced “iffy”):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Be sure to type the preceding example exactly as shown (apart from the comments).
    An IIFE is a function expression that is called immediately after you define it.
    Inside the function, a new scope exists, preventing `tmp` from becoming global.
    Consult [Introducing a New Scope via an IIFE](ch16.html#iife "Introducing a New
    Scope via an IIFE") for details on IIFEs.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'IIFE use case: inadvertent sharing via closures'
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Closures keep their connections to outer variables, which is sometimes not
    what you want:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The value returned in line (1) is always the current value of `i`, not the
    value it had when the function was created. After the loop is finished, `i` has
    the value 5, which is why all functions in the array return that value. If you
    want the function in line (1) to receive a snapshot of the current value of `i`,
    you can use an IIFE:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Objects and Constructors
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section covers two basic object-oriented mechanisms of JavaScript: single
    objects and *constructors* (which are factories for objects, similar to classes
    in other languages).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Single Objects
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like all values, objects have properties. You could, in fact, consider an object
    to be a set of properties, where each property is a (key, value) pair. The key
    is a string, and the value is any JavaScript value.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, you can directly create plain objects, via *object literals*:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The preceding object has the properties `name` and `describe`. You can read
    (“get”) and write (“set”) properties:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Function-valued properties such as `describe` are called *methods*. They use
    `this` to refer to the object that was used to call them:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `in` operator checks whether a property exists:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'If you read a property that does not exist, you get the value `undefined`.
    Hence, the previous two checks could also be performed like this:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `delete` operator removes a property:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Arbitrary Property Keys
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A property key can be any string. So far, we have seen property keys in object
    literals and after the dot operator. However, you can use them that way only if
    they are identifiers (see [Identifiers and Variable Names](ch01.html#basic_identifiers_variable_names
    "Identifiers and Variable Names")). If you want to use other strings as keys,
    you have to quote them in an object literal and use square brackets to get and
    set the property:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Square brackets also allow you to compute the key of a property:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Extracting Methods
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you extract a method, it loses its connection with the object. On its own,
    the function is not a method anymore, and `this` has the value `undefined` (in
    strict mode).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s go back to the earlier object `jane`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We want to extract the method `describe` from `jane`, put it into a variable
    `func`, and call it. However, that doesn’t work:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The solution is to use the method `bind()` that all functions have. It creates
    a new function whose `this` always has the given value:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Functions Inside a Method
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every function has its own special variable `this`. This is inconvenient if
    you nest a function inside a method, because you can’t access the method’s `this`
    from the function. The following is an example where we call `forEach` with a
    function to iterate over an array:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Calling `logHiToFriends` produces an error:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let’s look at two ways of fixing this. First, we could store `this` in a different
    variable:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Or, `forEach` has a second parameter that allows you to provide a value for
    `this`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Function expressions are often used as arguments in function calls in JavaScript.
    Always be careful when you refer to `this` from one of those function expressions.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructors: Factories for Objects'
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Until now, you may think that JavaScript objects are *only* maps from strings
    to values, a notion suggested by JavaScript’s object literals, which look like
    the map/dictionary literals of other languages. However, JavaScript objects also
    support a feature that is truly object-oriented: inheritance. This section does
    not fully explain how JavaScript inheritance works, but it shows you a simple
    pattern to get you started. Consult [Chapter 17](ch17_split_000.html "Chapter 17. Objects
    and Inheritance") if you want to know more.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to being “real” functions and methods, functions play another role
    in JavaScript: they become *constructors*—factories for objects—if invoked via
    the `new` operator. Constructors are thus a rough analog to classes in other languages.
    By convention, the names of constructors start with capital letters. For example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We can see that a constructor has two parts. First, the function `Point` sets
    up the instance data. Second, the property `Point.prototype` contains an object
    with the methods. The former data is specific to each instance, while the latter
    data is shared among all instances.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Point`, we invoke it via the `new` operator:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '`p` is an instance of `Point`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Arrays
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are sequences of elements that can be accessed via integer indices starting
    at zero.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Array Literals
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Array literals are handy for creating arrays:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The preceding array has three elements: the strings `''a''`, `''b''`, and `''c''`.
    You can access them via integer indices:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `length` property indicates how many elements an array has. You can use
    it to append elements and to remove elements:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The `in` operator works for arrays, too:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Note that arrays are objects and can thus have object properties:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Array Methods
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arrays have many methods (see [Array Prototype Methods](ch18.html#array_prototype_methods
    "Array Prototype Methods")). Here are a few examples:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Iterating over Arrays
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several array methods for iterating over elements (see [Iteration
    (Nondestructive)](ch18.html#array_iteration_methods "Iteration (Nondestructive)")).
    The two most important ones are `forEach` and `map`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '`forEach` iterates over an array and hands the current element and its index
    to a function:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The preceding code produces the following output:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Note that the function in line (1) is free to ignore arguments. It could, for
    example, only have the parameter `elem`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第（1）行中的函数可以忽略参数。例如，它可能只有参数`elem`。
- en: '`map` creates a new array by applying a function to each element of an existing
    array:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`通过将函数应用于现有数组的每个元素来创建一个新数组：'
- en: '[PRE113]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Regular Expressions
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'JavaScript has built-in support for regular expressions ([Chapter 19](ch19.html
    "Chapter 19. Regular Expressions") refers to tutorials and explains in more detail
    how they work). They are delimited by slashes:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript内置支持正则表达式（[第19章](ch19.html "第19章.正则表达式")是教程，更详细地解释了它们的工作原理）。它们由斜杠分隔：
- en: '[PRE114]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Method test(): Is There a Match?'
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '方法test(): 是否有匹配项？'
- en: '[PRE115]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Method exec(): Match and Capture Groups'
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '方法exec(): 匹配和捕获组'
- en: '[PRE116]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The returned array contains the complete match at index 0, the capture of the
    first group at index 1, and so on. There is a way (discussed in [RegExp.prototype.exec:
    Capture Groups](ch19.html#RegExp.prototype.exec "RegExp.prototype.exec: Capture
    Groups")) to invoke this method repeatedly to get all matches.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '返回的数组包含索引0处的完整匹配项，索引1处的第一个组的捕获，依此类推。还有一种方法（在[RegExp.prototype.exec: Capture
    Groups](ch19.html#RegExp.prototype.exec "RegExp.prototype.exec: Capture Groups")中讨论）可以重复调用此方法以获取所有匹配项。'
- en: 'Method replace(): Search and Replace'
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '方法replace(): 搜索和替换'
- en: '[PRE117]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The first parameter of `replace` must be a regular expression with a `/g` flag;
    otherwise, only the first occurrence is replaced. There is also a way (as discussed
    in [String.prototype.replace: Search and Replace](ch19.html#String.prototype.replace
    "String.prototype.replace: Search and Replace")) to use a function to compute
    the replacement.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace`的第一个参数必须是带有`/g`标志的正则表达式；否则，只会替换第一个匹配项。还有一种方法（如在[String.prototype.replace:
    Search and Replace](ch19.html#String.prototype.replace "String.prototype.replace:
    Search and Replace")中讨论的）可以使用函数来计算替换。'
- en: Math
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学
- en: '`Math` (see [Chapter 21](ch21.html "Chapter 21. Math")) is an object with arithmetic
    functions. Here are some examples:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`（参见[第21章](ch21.html "第21章.Math")）是一个具有算术函数的对象。以下是一些示例：'
- en: '[PRE118]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Other Functionality of the Standard Library
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库的其他功能
- en: 'JavaScript’s standard library is relatively spartan, but there are more things
    you can use:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的标准库相对简陋，但还有更多可以使用的东西：
- en: '`Date` ([Chapter 20](ch20.html "Chapter 20. Dates"))'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`（[第20章](ch20.html "第20章.Dates")）'
- en: A constructor for dates whose main functionality is parsing and creating date
    strings and accessing the components of a date (year, hour, etc.).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 一个日期的构造函数，其主要功能是解析和创建日期字符串以及访问日期的组件（年、小时等）。
- en: '`JSON` ([Chapter 22](ch22.html "Chapter 22. JSON"))'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON`（[第22章](ch22.html "第22章.JSON")）'
- en: An object with functions for parsing and generating JSON data.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有解析和生成JSON数据功能的对象。
- en: '`console.*` methods (see [The Console API](ch23.html#console_api "The Console
    API"))'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.*` 方法（参见[控制台API](ch23.html#console_api "控制台API")）'
- en: These browser-specific methods are not part of the language proper, but some
    of them also work on Node.js.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特定于浏览器的方法不是语言本身的一部分，但其中一些也适用于Node.js。

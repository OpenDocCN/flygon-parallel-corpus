- en: Part I. JavaScript Quick Start
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part is a self-contained quick introduction to JavaScript. You can understand
    it without reading anything else in this book, and no other part of the book depends
    on its contents. However, the tips for how to read this book in [Tips for Reading
    This Book](pr02.html#how_to_read "Tips for Reading This Book") do apply.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1. Basic JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter is about “Basic JavaScript,” a name I chose for a subset of JavaScript
    that is as concise as possible while still enabling you to be productive. When
    you are starting to learn JavaScript, I recommend that you program in it for a
    while before moving on to the rest of the language. That way, you don’t have to
    learn everything at once, which can be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section gives a little background on JavaScript to help you understand
    why it is the way it is.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Versus ECMAScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ECMAScript* is the official name for JavaScript. A new name became necessary
    because there is a trademark on *Java* (held originally by Sun, now by Oracle).
    At the moment, Mozilla is one of the few companies allowed to officially use the
    name *JavaScript* because it received a license long ago. For common usage, the
    following rules apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '*JavaScript* means the programming language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ECMAScript* is the name used by the language specification. Therefore, whenever
    referring to versions of the language, people say *ECMAScript*. The current version
    of JavaScript is ECMAScript 5; ECMAScript 6 is currently being developed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Influences and Nature of the Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript’s creator, Brendan Eich, had no choice but to create the language
    very quickly (or other, worse technologies would have been adopted by Netscape).
    He borrowed from several programming languages: Java (syntax, primitive values
    versus objects), Scheme and AWK (first-class functions), Self (prototypal inheritance),
    and Perl and Python (strings, arrays, and regular expressions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript did not have exception handling until ECMAScript 3, which explains
    why the language so often automatically converts values and so often fails silently:
    it initially couldn’t throw exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: On one hand, JavaScript has quirks and is missing quite a bit of functionality
    (block-scoped variables, modules, support for subclassing, etc.). On the other
    hand, it has several powerful features that allow you to work around these problems.
    In other languages, you learn language features. In JavaScript, you often learn
    patterns instead.
  prefs: []
  type: TYPE_NORMAL
- en: Given its influences, it is no surprise that JavaScript enables a programming
    style that is a mixture of functional programming (higher-order functions; built-in
    `map`, `reduce`, etc.) and object-oriented programming (objects, inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explains basic syntactic principles of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: An Overview of the Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A few examples of syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the two different uses of the equals sign:'
  prefs: []
  type: TYPE_NORMAL
- en: A single equals sign (`=`) is used to assign a value to a variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A triple equals sign (`===`) is used to compare two values (see [Equality Operators](ch01.html#basic_equality_operators
    "Equality Operators")).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements Versus Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand JavaScript’s syntax, you should know that it has two major syntactic
    categories: statements and expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Statements “do things.” A program is a sequence of statements. Here is an example
    of a statement, which declares (creates) a variable `foo`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Expressions produce values. They are function arguments, the right side of
    an assignment, etc. Here’s an example of an expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The distinction between statements and expressions is best illustrated by the
    fact that JavaScript has two different ways to do `if-then-else`—either as a statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'or as an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the latter as a function argument (but not the former):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, wherever JavaScript expects a statement, you can also use an expression;
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The whole line is a statement (a so-called *expression statement*), but the
    function call `foo(7, 1)` is an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Semicolons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Semicolons are optional in JavaScript. However, I recommend always including
    them, because otherwise JavaScript can guess wrong about the end of a statement.
    The details are explained in [Automatic Semicolon Insertion](ch07.html#automatic_semicolon_insertion
    "Automatic Semicolon Insertion").
  prefs: []
  type: TYPE_NORMAL
- en: 'Semicolons terminate statements, but not blocks. There is one case where you
    will see a semicolon after a block: a function expression is an expression that
    ends with a block. If such an expression comes last in a statement, it is followed
    by a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has two kinds of comments: single-line comments and multiline comments.
    Single-line comments start with `//` and are terminated by the end of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiline comments are delimited by `/*` and `*/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Variables and Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables in JavaScript are declared before they are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can declare a variable and assign a value at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also assign a value to an existing variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Compound Assignment Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are compound assignment operators such as `+=`. The following two assignments
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Identifiers and Variable Names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Identifiers* are names that play various syntactic roles in JavaScript. For
    example, the name of a variable is an identifier. Identifiers are case sensitive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly, the first character of an identifier can be any Unicode letter, a
    dollar sign (`$`), or an underscore (`_`). Subsequent characters can additionally
    be any Unicode digit. Thus, the following are all legal identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following identifiers are *reserved words*—they are part of the syntax
    and can’t be used as variable names (including function names and parameter names):'
  prefs: []
  type: TYPE_NORMAL
- en: '| `arguments` | `break` | `case` | `catch` |'
  prefs: []
  type: TYPE_TB
- en: '| `class` | `const` | `continue` | `debugger` |'
  prefs: []
  type: TYPE_TB
- en: '| `default` | `delete` | `do` | `else` |'
  prefs: []
  type: TYPE_TB
- en: '| `enum` | `export` | `extends` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `finally` | `for` | `function` | `if` |'
  prefs: []
  type: TYPE_TB
- en: '| `implements` | `import` | `in` | `instanceof` |'
  prefs: []
  type: TYPE_TB
- en: '| `interface` | `let` | `new` | `null` |'
  prefs: []
  type: TYPE_TB
- en: '| `package` | `private` | `protected` | `public` |'
  prefs: []
  type: TYPE_TB
- en: '| `return` | `static` | `super` | `switch` |'
  prefs: []
  type: TYPE_TB
- en: '| `this` | `throw` | `true` | `try` |'
  prefs: []
  type: TYPE_TB
- en: '| `typeof` | `var` | `void` | `while` |'
  prefs: []
  type: TYPE_TB
- en: 'The following three identifiers are not reserved words, but you should treat
    them as if they were:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Infinity` |'
  prefs: []
  type: TYPE_TB
- en: '| `NaN` |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` |'
  prefs: []
  type: TYPE_TB
- en: Lastly, you should also stay away from the names of standard global variables
    (see [Chapter 23](ch23.html "Chapter 23. Standard Global Variables")). You can
    use them for local variables without breaking anything, but your code still becomes
    confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has many values that we have come to expect from programming languages:
    booleans, numbers, strings, arrays, and so on. All values in JavaScript have *properties*.
    Each property has a *key* (or *name*) and a *value*. You can think of properties
    like fields of a record. You use the dot (`.`) operator to read a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the string `''abc''` has the property `length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding can also be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The dot operator is also used to assign a value to a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can use it to invoke methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have invoked the method `toUpperCase()` on the
    value `'hello'`.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Values Versus Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript makes a somewhat arbitrary distinction between values:'
  prefs: []
  type: TYPE_NORMAL
- en: The *primitive values* are booleans, numbers, strings, `null`, and `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other values are *objects*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A major difference between the two is how they are compared; each object has
    a unique identity and is only (strictly) equal to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, all primitive values encoding the same value are considered the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The next two sections explain primitive values and objects in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are all of the primitive values (or *primitives* for short):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Booleans: `true`, `false` (see [Booleans](ch01.html#basic_booleans "Booleans"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Numbers: `1736`, `1.351` (see [Numbers](ch01.html#basic_numbers "Numbers"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strings: `''abc''`, `"abc"` (see [Strings](ch01.html#basic_strings "Strings"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two “nonvalues”: `undefined`, `null` (see [undefined and null](ch01.html#basic_undefined_null
    "undefined and null"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Primitives have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Compared by value
  prefs: []
  type: TYPE_NORMAL
- en: 'The “content” is compared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Always immutable
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties can’t be changed, added, or removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: (Reading an unknown property always returns `undefined`.)
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All nonprimitive values are *objects*. The most common kinds of objects are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Plain objects*, which can be created by *object literals* (see [Single Objects](ch01.html#basic_single_objects
    "Single Objects")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding object has two properties: the value of property `firstName`
    is `''Jane''` and the value of property `lastName` is `''Doe''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Arrays*, which can be created by *array literals* (see [Arrays](ch01.html#basic_arrays
    "Arrays")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding array has three elements that can be accessed via numeric indices.
    For example, the index of `'apple'` is 0.
  prefs: []
  type: TYPE_NORMAL
- en: '*Regular expressions*, which can be created by *regular expression literals*
    (see [Regular Expressions](ch01.html#basic_regexps "Regular Expressions")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Objects have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Compared by reference
  prefs: []
  type: TYPE_NORMAL
- en: 'Identities are compared; every value has its own identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Mutable by default
  prefs: []
  type: TYPE_NORMAL
- en: 'You can normally freely change, add, and remove properties (see [Single Objects](ch01.html#basic_single_objects
    "Single Objects")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: undefined and null
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most programming languages have values denoting missing information. JavaScript
    has two such “nonvalues,” `undefined` and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined` means “no value.” Uninitialized variables are `undefined`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Missing parameters are `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you read a nonexistent property, you get `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`null` means “no object.” It is used as a nonvalue whenever an object is expected
    (parameters, last in a chain of objects, etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`undefined` and `null` have no properties, not even standard methods such as
    `toString()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking for undefined or null
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Functions normally allow you to indicate a missing value via either `undefined`
    or `null`. You can do the same via an explicit check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also exploit the fact that both `undefined` and `null` are considered
    `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`false`, `0`, `NaN`, and `''''` are also considered `false` (see [Truthy and
    Falsy](ch01.html#basic_truthy_falsy "Truthy and Falsy")).'
  prefs: []
  type: TYPE_NORMAL
- en: Categorizing Values Using typeof and instanceof
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two operators for categorizing values: `typeof` is mainly used for
    primitive values, while `instanceof` is used for objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '`typeof` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns a string describing the “type” of `value`. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table lists all results of `typeof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operand | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `''undefined''` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `''object''` |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean value | `''boolean''` |'
  prefs: []
  type: TYPE_TB
- en: '| Number value | `''number''` |'
  prefs: []
  type: TYPE_TB
- en: '| String value | `''string''` |'
  prefs: []
  type: TYPE_TB
- en: '| Function | `''function''` |'
  prefs: []
  type: TYPE_TB
- en: '| All other normal values | `''object''` |'
  prefs: []
  type: TYPE_TB
- en: '| (Engine-created value) | JavaScript engines are allowed to create values
    for which `typeof` returns arbitrary strings (different from all results listed
    in this table). |'
  prefs: []
  type: TYPE_TB
- en: '`typeof null` returning `''object''` is a bug that can’t be fixed, because
    it would break existing code. It does not mean that `null` is an object.'
  prefs: []
  type: TYPE_NORMAL
- en: '`instanceof` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns `true` if `value` is an object that has been created by the constructor
    `Constr` (see [Constructors: Factories for Objects](ch01.html#basic_constructors
    "Constructors: Factories for Objects")). Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The primitive boolean type comprises the values `true` and `false`. The following
    operators produce booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary logical operators: `&&` (And), `||` (Or)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prefix logical operator: `!` (Not)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comparison operators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Equality operators: `===`, `!==`, `==`, `!=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ordering operators (for strings and numbers): `>`, `>=`, `<`, `<=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truthy and Falsy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever JavaScript expects a boolean value (e.g., for the condition of an
    `if` statement), any value can be used. It will be interpreted as either `true`
    or `false`. The following values are interpreted as `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined`, `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boolean: `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Number: `-0`, `NaN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String: `''''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All other values (including all objects!) are considered `true`. Values interpreted
    as `false` are called *falsy*, and values interpreted as `true` are called *truthy*.
    `Boolean()`, called as a function, converts its parameter to a boolean. You can
    use it to test how a value is interpreted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Binary Logical Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Binary logical operators in JavaScript are *short-circuiting*. That is, if
    the first operand suffices for determining the result, the second operand is not
    evaluated. For example, in the following expressions, the function `foo()` is
    never called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, binary logical operators return either one of their operands—which
    may or may not be a boolean. A check for truthiness is used to determine which
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: And (`&&`)
  prefs: []
  type: TYPE_NORMAL
- en: 'If the first operand is falsy, return it. Otherwise, return the second operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Or (`||`)
  prefs: []
  type: TYPE_NORMAL
- en: 'If the first operand is truthy, return it. Otherwise, return the second operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Equality Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has two kinds of equality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal, or “lenient,” (in)equality: `==` and `!=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strict (in)equality: `===` and `!==`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal equality considers (too) many values to be equal (the details are explained
    in [Normal (Lenient) Equality (==, !=)](ch09.html#normal_equality "Normal (Lenient)
    Equality (==, !=)")), which can hide bugs. Therefore, always using strict equality
    is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All numbers in JavaScript are floating-point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Special numbers include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NaN` (“not a number”)'
  prefs: []
  type: TYPE_NORMAL
- en: 'An error value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`Infinity`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also mostly an error value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`Infinity` is larger than any other number (except `NaN`). Similarly, `-Infinity`
    is smaller than any other number (except `NaN`). That makes these numbers useful
    as default values (e.g., when you are looking for a minimum or a maximum).'
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has the following arithmetic operators (see [Arithmetic Operators](ch11.html#arithmetic_operators
    "Arithmetic Operators")):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Addition: `number1 + number2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subtraction: `number1 - number2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiplication: `number1 * number2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Division: `number1 / number2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remainder: `number1 % number2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Increment: `++variable`, `variable++`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decrement: `--variable`, `variable--`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Negate: `-value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Convert to number: `+value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The global object `Math` (see [Math](ch01.html#basic_math "Math")) provides
    more arithmetic operations, via functions.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript also has operators for bitwise operations (e.g., bitwise And; see
    [Bitwise Operators](ch11.html#bitwise_operators "Bitwise Operators")).
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strings can be created directly via string literals. Those literals are delimited
    by single or double quotes. The backslash (`\`) escapes characters and produces
    a few control characters. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Single characters are accessed via square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The property `length` counts the number of characters in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Like all primitives, strings are immutable; you need to create a new string
    if you want to change an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: String Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings are concatenated via the plus (`+`) operator, which converts the other
    operand to a string if one of the operands is a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To concatenate strings in multiple steps, use the `+=` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: String Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings have many useful methods (see [String Prototype Methods](ch12.html#string_prototype_methods
    "String Prototype Methods")). Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conditionals and loops in JavaScript are introduced in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `if` statement has a `then` clause and an optional `else` clause that are
    executed depending on a boolean condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'I recommend always using braces (they denote blocks of zero or more statements).
    But you don’t have to do so if a clause is only a single statement (the same holds
    for the control flow statements `for` and `while`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a `switch` statement. The value of `fruit` decides which `case`
    is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The “operand” after `case` can be any expression; it is compared via `===` with
    the parameter of `switch`.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `for` loop has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`init` is executed at the beginning of the loop. `condition` is checked before
    each loop iteration; if it becomes `false`, then the loop is terminated. `post_iteration`
    is executed after each loop iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example prints all elements of the array `arr` on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` loop continues looping over its body while its condition holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `do-while` loop continues looping over its body while its condition holds.
    As the condition follows the body, the body is always executed at least once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In all loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '`break` leaves the loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`continue` starts a new loop iteration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way of defining a function is via a *function declaration*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines a function, `add`, that has two parameters, `param1`
    and `param2`, and returns the sum of both parameters. This is how you call that
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of defining `add()` is by assigning a *function expression* to
    a variable `add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'A function expression produces a value and can thus be used to directly pass
    functions as arguments to other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Function Declarations Are Hoisted
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Function declarations are *hoisted*—moved in their entirety to the beginning
    of the current scope. That allows you to refer to functions that are declared
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that while `var` declarations are also hoisted (see [Variables Are Hoisted](ch01.html#basic_var_hoisting
    "Variables Are Hoisted")), assignments performed by them are not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The Special Variable arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can call any function in JavaScript with an arbitrary amount of arguments;
    the language will never complain. It will, however, make all parameters available
    via the special variable `arguments`. `arguments` looks like an array, but has
    none of the array methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Too Many or Too Few Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s use the following function to explore how too many or too few parameters
    are handled in JavaScript (the function `toArray()` is shown in [Converting arguments
    to an Array](ch01.html#basic_toarray "Converting arguments to an Array")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional parameters will be ignored (except by `arguments`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Missing parameters will get the value `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Optional Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a common pattern for assigning default values to parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In line (1), the `||` operator returns `x` if it is truthy (not `null`, `undefined`,
    etc.). Otherwise, it returns the second operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Enforcing an Arity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to enforce an *arity* (a specific number of parameters), you can
    check `arguments.length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Converting arguments to an Array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arguments` is not an array, it is only *array-like* (see [Array-Like Objects
    and Generic Methods](ch17_split_001.html#array-like_objects "Array-Like Objects
    and Generic Methods")). It has a property `length`, and you can access its elements
    via indices in square brackets. You cannot, however, remove elements or invoke
    any of the array methods on it. Thus, you sometimes need to convert `arguments`
    to an array, which is what the following function does (it is explained in [Array-Like
    Objects and Generic Methods](ch17_split_001.html#array-like_objects "Array-Like
    Objects and Generic Methods")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Exception Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common way to handle exceptions (see [Chapter 14](ch14.html "Chapter 14. Exception
    Handling")) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `try` clause surrounds critical code, and the `catch` clause is executed
    if an exception is thrown inside the `try` clause. Using the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Strict Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strict mode (see [Strict Mode](ch07.html#strict_mode "Strict Mode")) enables
    more warnings and makes JavaScript a cleaner language (nonstrict mode is sometimes
    called “sloppy mode”). To switch it on, type the following line first in a JavaScript
    file or a `<script>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also enable strict mode per function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Variable Scoping and Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, you declare variables via `var` before using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'You can declare and initialize several variables with a single `var` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'But I recommend using one statement per variable (the reason is explained in
    [Syntax](ch26.html#style_one_var_per_line "Syntax")). Thus, I would rewrite the
    previous statement to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Because of hoisting (see [Variables Are Hoisted](ch01.html#basic_var_hoisting
    "Variables Are Hoisted")), it is usually best to declare variables at the beginning
    of a function.
  prefs: []
  type: TYPE_NORMAL
- en: Variables Are Function-Scoped
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The scope of a variable is always the complete function (as opposed to the
    current block). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the variable `tmp` is not restricted to the block starting in
    line (1); it exists until the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Variables Are Hoisted
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each variable declaration is *hoisted*: the declaration is moved to the beginning
    of the function, but assignments that it makes stay put. As an example, consider
    the variable declaration in line (1) in the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, the preceding function is executed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Closures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each function stays connected to the variables of the functions that surround
    it, even after it leaves the scope in which it was created. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The function starting in line (1) leaves the context in which it was created,
    but stays connected to a live version of `start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: A *closure* is a function plus the connection to the variables of its surrounding
    scopes. Thus, what `createIncrementor()` returns is a closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IIFE Pattern: Introducing a New Scope'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you want to introduce a new variable scope—for example, to prevent
    a variable from becoming global. In JavaScript, you can’t use a block to do so;
    you must use a function. But there is a pattern for using a function in a block-like
    manner. It is called *IIFE* ([immediately invoked function expression](http://bit.ly/i-ife),
    pronounced “iffy”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to type the preceding example exactly as shown (apart from the comments).
    An IIFE is a function expression that is called immediately after you define it.
    Inside the function, a new scope exists, preventing `tmp` from becoming global.
    Consult [Introducing a New Scope via an IIFE](ch16.html#iife "Introducing a New
    Scope via an IIFE") for details on IIFEs.
  prefs: []
  type: TYPE_NORMAL
- en: 'IIFE use case: inadvertent sharing via closures'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Closures keep their connections to outer variables, which is sometimes not
    what you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The value returned in line (1) is always the current value of `i`, not the
    value it had when the function was created. After the loop is finished, `i` has
    the value 5, which is why all functions in the array return that value. If you
    want the function in line (1) to receive a snapshot of the current value of `i`,
    you can use an IIFE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Objects and Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section covers two basic object-oriented mechanisms of JavaScript: single
    objects and *constructors* (which are factories for objects, similar to classes
    in other languages).'
  prefs: []
  type: TYPE_NORMAL
- en: Single Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like all values, objects have properties. You could, in fact, consider an object
    to be a set of properties, where each property is a (key, value) pair. The key
    is a string, and the value is any JavaScript value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, you can directly create plain objects, via *object literals*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding object has the properties `name` and `describe`. You can read
    (“get”) and write (“set”) properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Function-valued properties such as `describe` are called *methods*. They use
    `this` to refer to the object that was used to call them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The `in` operator checks whether a property exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'If you read a property that does not exist, you get the value `undefined`.
    Hence, the previous two checks could also be performed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The `delete` operator removes a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Arbitrary Property Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A property key can be any string. So far, we have seen property keys in object
    literals and after the dot operator. However, you can use them that way only if
    they are identifiers (see [Identifiers and Variable Names](ch01.html#basic_identifiers_variable_names
    "Identifiers and Variable Names")). If you want to use other strings as keys,
    you have to quote them in an object literal and use square brackets to get and
    set the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Square brackets also allow you to compute the key of a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Extracting Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you extract a method, it loses its connection with the object. On its own,
    the function is not a method anymore, and `this` has the value `undefined` (in
    strict mode).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s go back to the earlier object `jane`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to extract the method `describe` from `jane`, put it into a variable
    `func`, and call it. However, that doesn’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is to use the method `bind()` that all functions have. It creates
    a new function whose `this` always has the given value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Functions Inside a Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every function has its own special variable `this`. This is inconvenient if
    you nest a function inside a method, because you can’t access the method’s `this`
    from the function. The following is an example where we call `forEach` with a
    function to iterate over an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `logHiToFriends` produces an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at two ways of fixing this. First, we could store `this` in a different
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, `forEach` has a second parameter that allows you to provide a value for
    `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Function expressions are often used as arguments in function calls in JavaScript.
    Always be careful when you refer to `this` from one of those function expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructors: Factories for Objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Until now, you may think that JavaScript objects are *only* maps from strings
    to values, a notion suggested by JavaScript’s object literals, which look like
    the map/dictionary literals of other languages. However, JavaScript objects also
    support a feature that is truly object-oriented: inheritance. This section does
    not fully explain how JavaScript inheritance works, but it shows you a simple
    pattern to get you started. Consult [Chapter 17](ch17_split_000.html "Chapter 17. Objects
    and Inheritance") if you want to know more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to being “real” functions and methods, functions play another role
    in JavaScript: they become *constructors*—factories for objects—if invoked via
    the `new` operator. Constructors are thus a rough analog to classes in other languages.
    By convention, the names of constructors start with capital letters. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: We can see that a constructor has two parts. First, the function `Point` sets
    up the instance data. Second, the property `Point.prototype` contains an object
    with the methods. The former data is specific to each instance, while the latter
    data is shared among all instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Point`, we invoke it via the `new` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '`p` is an instance of `Point`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are sequences of elements that can be accessed via integer indices starting
    at zero.
  prefs: []
  type: TYPE_NORMAL
- en: Array Literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Array literals are handy for creating arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding array has three elements: the strings `''a''`, `''b''`, and `''c''`.
    You can access them via integer indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The `length` property indicates how many elements an array has. You can use
    it to append elements and to remove elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The `in` operator works for arrays, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that arrays are objects and can thus have object properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Array Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arrays have many methods (see [Array Prototype Methods](ch18.html#array_prototype_methods
    "Array Prototype Methods")). Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Iterating over Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several array methods for iterating over elements (see [Iteration
    (Nondestructive)](ch18.html#array_iteration_methods "Iteration (Nondestructive)")).
    The two most important ones are `forEach` and `map`.
  prefs: []
  type: TYPE_NORMAL
- en: '`forEach` iterates over an array and hands the current element and its index
    to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Note that the function in line (1) is free to ignore arguments. It could, for
    example, only have the parameter `elem`.
  prefs: []
  type: TYPE_NORMAL
- en: '`map` creates a new array by applying a function to each element of an existing
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Regular Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has built-in support for regular expressions ([Chapter 19](ch19.html
    "Chapter 19. Regular Expressions") refers to tutorials and explains in more detail
    how they work). They are delimited by slashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Method test(): Is There a Match?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Method exec(): Match and Capture Groups'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned array contains the complete match at index 0, the capture of the
    first group at index 1, and so on. There is a way (discussed in [RegExp.prototype.exec:
    Capture Groups](ch19.html#RegExp.prototype.exec "RegExp.prototype.exec: Capture
    Groups")) to invoke this method repeatedly to get all matches.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method replace(): Search and Replace'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter of `replace` must be a regular expression with a `/g` flag;
    otherwise, only the first occurrence is replaced. There is also a way (as discussed
    in [String.prototype.replace: Search and Replace](ch19.html#String.prototype.replace
    "String.prototype.replace: Search and Replace")) to use a function to compute
    the replacement.'
  prefs: []
  type: TYPE_NORMAL
- en: Math
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Math` (see [Chapter 21](ch21.html "Chapter 21. Math")) is an object with arithmetic
    functions. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Other Functionality of the Standard Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript’s standard library is relatively spartan, but there are more things
    you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Date` ([Chapter 20](ch20.html "Chapter 20. Dates"))'
  prefs: []
  type: TYPE_NORMAL
- en: A constructor for dates whose main functionality is parsing and creating date
    strings and accessing the components of a date (year, hour, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON` ([Chapter 22](ch22.html "Chapter 22. JSON"))'
  prefs: []
  type: TYPE_NORMAL
- en: An object with functions for parsing and generating JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.*` methods (see [The Console API](ch23.html#console_api "The Console
    API"))'
  prefs: []
  type: TYPE_NORMAL
- en: These browser-specific methods are not part of the language proper, but some
    of them also work on Node.js.
  prefs: []
  type: TYPE_NORMAL

- en: Part I. JavaScript Quick Start
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第I部分 JavaScript快速入门
- en: This part is a self-contained quick introduction to JavaScript. You can understand
    it without reading anything else in this book, and no other part of the book depends
    on its contents. However, the tips for how to read this book in [Tips for Reading
    This Book](pr02.html#how_to_read "Tips for Reading This Book") do apply.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分是JavaScript的一个独立快速介绍。你可以在不阅读本书中的其他内容的情况下理解它，本书的其他部分也不依赖于它的内容。然而，阅读本书的提示在[阅读本书的提示](pr02.html#how_to_read
    "阅读本书的提示")中适用。
- en: Chapter 1. Basic JavaScript
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章 基本JavaScript
- en: This chapter is about “Basic JavaScript,” a name I chose for a subset of JavaScript
    that is as concise as possible while still enabling you to be productive. When
    you are starting to learn JavaScript, I recommend that you program in it for a
    while before moving on to the rest of the language. That way, you don’t have to
    learn everything at once, which can be confusing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于“基本JavaScript”，这是我为JavaScript的一个子集选择的名称，尽可能简洁，同时仍然能让你高效地工作。当你开始学习JavaScript时，我建议你在学习其他语言之前先在其中编程一段时间。这样，你就不必一次学习所有内容，这可能会让人困惑。
- en: Background
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: This section gives a little background on JavaScript to help you understand
    why it is the way it is.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要介绍了JavaScript的背景，以帮助你理解它为什么是这样的。
- en: JavaScript Versus ECMAScript
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript与ECMAScript
- en: '*ECMAScript* is the official name for JavaScript. A new name became necessary
    because there is a trademark on *Java* (held originally by Sun, now by Oracle).
    At the moment, Mozilla is one of the few companies allowed to officially use the
    name *JavaScript* because it received a license long ago. For common usage, the
    following rules apply:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*ECMAScript*是JavaScript的官方名称。之所以需要一个新名称，是因为*Java*有商标（最初由Sun持有，现在由Oracle持有）。目前，Mozilla是少数几家被允许正式使用*JavaScript*名称的公司之一，因为它很久以前就获得了许可证。对于常见用法，以下规则适用：'
- en: '*JavaScript* means the programming language.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript*意味着编程语言。'
- en: '*ECMAScript* is the name used by the language specification. Therefore, whenever
    referring to versions of the language, people say *ECMAScript*. The current version
    of JavaScript is ECMAScript 5; ECMAScript 6 is currently being developed.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ECMAScript*是语言规范的官方名称。因此，每当提到语言的版本时，人们都说*ECMAScript*。JavaScript的当前版本是ECMAScript
    5；ECMAScript 6目前正在开发中。'
- en: Influences and Nature of the Language
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 影响和语言的性质
- en: 'JavaScript’s creator, Brendan Eich, had no choice but to create the language
    very quickly (or other, worse technologies would have been adopted by Netscape).
    He borrowed from several programming languages: Java (syntax, primitive values
    versus objects), Scheme and AWK (first-class functions), Self (prototypal inheritance),
    and Perl and Python (strings, arrays, and regular expressions).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的创造者Brendan Eich别无选择，只能很快地创建这种语言（否则，Netscape可能会采用其他更糟糕的技术）。他从几种编程语言中借鉴了一些东西：Java（语法，原始值与对象），Scheme和AWK（一级函数），Self（原型继承），以及Perl和Python（字符串，数组和正则表达式）。
- en: 'JavaScript did not have exception handling until ECMAScript 3, which explains
    why the language so often automatically converts values and so often fails silently:
    it initially couldn’t throw exceptions.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在ECMAScript 3之前没有异常处理，这就解释了为什么语言经常自动转换值并经常悄悄失败：最初它无法抛出异常。
- en: On one hand, JavaScript has quirks and is missing quite a bit of functionality
    (block-scoped variables, modules, support for subclassing, etc.). On the other
    hand, it has several powerful features that allow you to work around these problems.
    In other languages, you learn language features. In JavaScript, you often learn
    patterns instead.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，JavaScript有一些怪癖，缺少相当多的功能（块作用域变量，模块，支持子类等）。另一方面，它有几个强大的功能，可以让你解决这些问题。在其他语言中，你学习语言特性。在JavaScript中，你经常学习模式而不是语言特性。
- en: Given its influences, it is no surprise that JavaScript enables a programming
    style that is a mixture of functional programming (higher-order functions; built-in
    `map`, `reduce`, etc.) and object-oriented programming (objects, inheritance).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于它的影响，毫不奇怪JavaScript可以实现一种混合了函数式编程（高阶函数；内置的`map`，`reduce`等）和面向对象编程（对象，继承）的编程风格。
- en: Syntax
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法
- en: This section explains basic syntactic principles of JavaScript.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了JavaScript的基本语法原则。
- en: An Overview of the Syntax
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法概述
- en: 'A few examples of syntax:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语法的例子：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note the two different uses of the equals sign:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意等号的两种不同用法：
- en: A single equals sign (`=`) is used to assign a value to a variable.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个等号（`=`）用于将值赋给变量。
- en: A triple equals sign (`===`) is used to compare two values (see [Equality Operators](ch01.html#basic_equality_operators
    "Equality Operators")).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个等号（`===`）用于比较两个值（参见[相等运算符](ch01.html#basic_equality_operators "相等运算符")）。
- en: Statements Versus Expressions
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语句与表达式
- en: 'To understand JavaScript’s syntax, you should know that it has two major syntactic
    categories: statements and expressions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解JavaScript的语法，你应该知道它有两个主要的语法类别：语句和表达式：
- en: 'Statements “do things.” A program is a sequence of statements. Here is an example
    of a statement, which declares (creates) a variable `foo`:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句“做事情”。程序是一系列语句。这是一个语句的例子，它声明（创建）一个变量`foo`：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Expressions produce values. They are function arguments, the right side of
    an assignment, etc. Here’s an example of an expression:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式产生值。它们是函数参数，赋值的右侧等等。这是一个表达式的例子：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The distinction between statements and expressions is best illustrated by the
    fact that JavaScript has two different ways to do `if-then-else`—either as a statement:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 语句和表达式之间的区别最好通过JavaScript有两种不同的`if-then-else`的方式来说明——作为语句：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'or as an expression:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 或作为一个表达式：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can use the latter as a function argument (but not the former):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将后者用作函数参数（但不能使用前者）：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, wherever JavaScript expects a statement, you can also use an expression;
    for example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，无论JavaScript在哪里期望一个语句，你也可以使用一个表达式；例如：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The whole line is a statement (a so-called *expression statement*), but the
    function call `foo(7, 1)` is an expression.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 整行是一个语句（所谓的*表达式语句*），但函数调用`foo(7, 1)`是一个表达式。
- en: Semicolons
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分号
- en: Semicolons are optional in JavaScript. However, I recommend always including
    them, because otherwise JavaScript can guess wrong about the end of a statement.
    The details are explained in [Automatic Semicolon Insertion](ch07.html#automatic_semicolon_insertion
    "Automatic Semicolon Insertion").
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，分号是可选的。但是，我建议始终包括它们，因为否则JavaScript可能会错误猜测语句的结束。详细信息请参见[自动分号插入](ch07.html#automatic_semicolon_insertion
    "自动分号插入")。
- en: 'Semicolons terminate statements, but not blocks. There is one case where you
    will see a semicolon after a block: a function expression is an expression that
    ends with a block. If such an expression comes last in a statement, it is followed
    by a semicolon:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 分号终止语句，但不终止块。有一种情况下，您会在块后看到一个分号：函数表达式是以块结尾的表达式。如果这样的表达式出现在语句的最后，它后面会跟着一个分号：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Comments
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'JavaScript has two kinds of comments: single-line comments and multiline comments.
    Single-line comments start with `//` and are terminated by the end of the line:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有两种注释：单行注释和多行注释。单行注释以`//`开头，并在行尾终止：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Multiline comments are delimited by `/*` and `*/`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释由`/*`和`*/`界定：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Variables and Assignment
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和赋值
- en: 'Variables in JavaScript are declared before they are used:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，变量在使用之前被声明：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Assignment
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 赋值
- en: 'You can declare a variable and assign a value at the same time:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以声明一个变量并同时赋值：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also assign a value to an existing variable:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以给现有变量赋值：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Compound Assignment Operators
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复合赋值运算符
- en: 'There are compound assignment operators such as `+=`. The following two assignments
    are equivalent:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有复合赋值运算符，比如`+=`。以下两个赋值是等价的：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Identifiers and Variable Names
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标识符和变量名
- en: '*Identifiers* are names that play various syntactic roles in JavaScript. For
    example, the name of a variable is an identifier. Identifiers are case sensitive.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*标识符*是在JavaScript中扮演各种语法角色的名称。例如，变量的名称是标识符。标识符区分大小写。'
- en: 'Roughly, the first character of an identifier can be any Unicode letter, a
    dollar sign (`$`), or an underscore (`_`). Subsequent characters can additionally
    be any Unicode digit. Thus, the following are all legal identifiers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 大致而言，标识符的第一个字符可以是任何Unicode字母、美元符号（`$`）或下划线（`_`）。随后的字符还可以是任何Unicode数字。因此，以下都是合法的标识符：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following identifiers are *reserved words*—they are part of the syntax
    and can’t be used as variable names (including function names and parameter names):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标识符是*保留字*——它们是语法的一部分，不能用作变量名（包括函数名和参数名）：
- en: '| `arguments` | `break` | `case` | `catch` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `arguments` | `break` | `case` | `catch` |'
- en: '| `class` | `const` | `continue` | `debugger` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `class` | `const` | `continue` | `debugger` |'
- en: '| `default` | `delete` | `do` | `else` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `default` | `delete` | `do` | `else` |'
- en: '| `enum` | `export` | `extends` | `false` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `enum` | `export` | `extends` | `false` |'
- en: '| `finally` | `for` | `function` | `if` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `finally` | `for` | `function` | `if` |'
- en: '| `implements` | `import` | `in` | `instanceof` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `implements` | `import` | `in` | `instanceof` |'
- en: '| `interface` | `let` | `new` | `null` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `interface` | `let` | `new` | `null` |'
- en: '| `package` | `private` | `protected` | `public` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `package` | `private` | `protected` | `public` |'
- en: '| `return` | `static` | `super` | `switch` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `return` | `static` | `super` | `switch` |'
- en: '| `this` | `throw` | `true` | `try` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `this` | `throw` | `true` | `try` |'
- en: '| `typeof` | `var` | `void` | `while` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `typeof` | `var` | `void` | `while` |'
- en: 'The following three identifiers are not reserved words, but you should treat
    them as if they were:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个标识符不是保留字，但您应该将它们视为保留字：
- en: '| `Infinity` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `Infinity` |'
- en: '| `NaN` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `NaN` |'
- en: '| `undefined` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` |'
- en: Lastly, you should also stay away from the names of standard global variables
    (see [Chapter 23](ch23.html "Chapter 23. Standard Global Variables")). You can
    use them for local variables without breaking anything, but your code still becomes
    confusing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还应该避免使用标准全局变量的名称（参见[第23章](ch23.html "第23章。标准全局变量")）。您可以将它们用于局部变量而不会破坏任何东西，但您的代码仍然会变得混乱。
- en: Values
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值
- en: 'JavaScript has many values that we have come to expect from programming languages:
    booleans, numbers, strings, arrays, and so on. All values in JavaScript have *properties*.
    Each property has a *key* (or *name*) and a *value*. You can think of properties
    like fields of a record. You use the dot (`.`) operator to read a property:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有许多我们从编程语言中期望的值：布尔值、数字、字符串、数组等等。JavaScript中的所有值都有*属性*。每个属性都有一个*键*（或*名称*）和一个*值*。您可以将属性视为记录的字段。您可以使用点（`.`）运算符来读取属性：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For example, the string `''abc''` has the property `length`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，字符串`'abc'`具有属性`length`：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding can also be written as:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的也可以写成：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The dot operator is also used to assign a value to a property:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 点运算符也用于给属性赋值：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And you can use it to invoke methods:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以用它来调用方法：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, we have invoked the method `toUpperCase()` on the
    value `'hello'`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们已经在值`'hello'`上调用了方法`toUpperCase()`。
- en: Primitive Values Versus Objects
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始值与对象
- en: 'JavaScript makes a somewhat arbitrary distinction between values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在值之间做了一个相当武断的区分：
- en: The *primitive values* are booleans, numbers, strings, `null`, and `undefined`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原始值*是布尔值、数字、字符串、`null`和`undefined`。'
- en: All other values are *objects*.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他值都是*对象*。
- en: 'A major difference between the two is how they are compared; each object has
    a unique identity and is only (strictly) equal to itself:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的一个主要区别是它们的比较方式；每个对象都有唯一的标识，并且只有（严格）等于自身：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In contrast, all primitive values encoding the same value are considered the
    same:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，所有编码相同值的原始值都被视为相同：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The next two sections explain primitive values and objects in more detail.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两节将更详细地解释原始值和对象。
- en: Primitive Values
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始值
- en: 'The following are all of the primitive values (or *primitives* for short):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有原始值（或简称*原始值*）：
- en: 'Booleans: `true`, `false` (see [Booleans](ch01.html#basic_booleans "Booleans"))'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：`true`，`false`（参见[布尔值](ch01.html#basic_booleans "布尔值")）
- en: 'Numbers: `1736`, `1.351` (see [Numbers](ch01.html#basic_numbers "Numbers"))'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：`1736`，`1.351`（参见[数字](ch01.html#basic_numbers "数字")）
- en: 'Strings: `''abc''`, `"abc"` (see [Strings](ch01.html#basic_strings "Strings"))'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：`'abc'`，`"abc"`（参见[字符串](ch01.html#basic_strings "字符串")）
- en: 'Two “nonvalues”: `undefined`, `null` (see [undefined and null](ch01.html#basic_undefined_null
    "undefined and null"))'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个“非值”：`undefined`，`null`（参见[undefined和null](ch01.html#basic_undefined_null
    "undefined和null")）
- en: 'Primitives have the following characteristics:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 原始值具有以下特征：
- en: Compared by value
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 按值比较
- en: 'The “content” is compared:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: “内容”进行比较：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Always immutable
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 始终不可变
- en: 'Properties can’t be changed, added, or removed:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 属性无法更改，添加或删除：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: (Reading an unknown property always returns `undefined`.)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: （读取未知属性始终返回`undefined`。）
- en: Objects
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象
- en: 'All nonprimitive values are *objects*. The most common kinds of objects are:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有非原始值都是*对象*。最常见的对象类型是：
- en: '*Plain objects*, which can be created by *object literals* (see [Single Objects](ch01.html#basic_single_objects
    "Single Objects")):'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*普通对象*，可以通过*对象字面量*创建（参见[单个对象](ch01.html#basic_single_objects "单个对象")）：'
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding object has two properties: the value of property `firstName`
    is `''Jane''` and the value of property `lastName` is `''Doe''`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的对象有两个属性：属性`firstName`的值为`'Jane'`，属性`lastName`的值为`'Doe'`。
- en: '*Arrays*, which can be created by *array literals* (see [Arrays](ch01.html#basic_arrays
    "Arrays")):'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组*，可以通过*数组字面量*创建（参见[数组](ch01.html#basic_arrays "数组")）：'
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding array has three elements that can be accessed via numeric indices.
    For example, the index of `'apple'` is 0.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数组有三个元素，可以通过数字索引访问。例如，'apple'的索引是0。
- en: '*Regular expressions*, which can be created by *regular expression literals*
    (see [Regular Expressions](ch01.html#basic_regexps "Regular Expressions")):'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正则表达式*，可以通过*正则表达式字面量*创建（参见[正则表达式](ch01.html#basic_regexps "正则表达式")）：'
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Objects have the following characteristics:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对象具有以下特征：
- en: Compared by reference
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 按引用比较
- en: 'Identities are compared; every value has its own identity:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 进行身份比较；每个值都有自己的身份：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Mutable by default
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认可变
- en: 'You can normally freely change, add, and remove properties (see [Single Objects](ch01.html#basic_single_objects
    "Single Objects")):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以自由更改，添加和删除属性（参见[单个对象](ch01.html#basic_single_objects "单个对象")）：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: undefined and null
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: undefined和null
- en: 'Most programming languages have values denoting missing information. JavaScript
    has two such “nonvalues,” `undefined` and `null`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有表示缺少信息的值。JavaScript有两个这样的“非值”，`undefined`和`null`：
- en: '`undefined` means “no value.” Uninitialized variables are `undefined`:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`表示“没有值”。未初始化的变量是`undefined`：'
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Missing parameters are `undefined`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少参数是`undefined`：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you read a nonexistent property, you get `undefined`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读取不存在的属性，将得到`undefined`：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`null` means “no object.” It is used as a nonvalue whenever an object is expected
    (parameters, last in a chain of objects, etc.).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`表示“没有对象”。每当期望对象时（参数，对象链中的最后一个等），它被用作非值。'
- en: Warning
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '`undefined` and `null` have no properties, not even standard methods such as
    `toString()`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`和`null`没有属性，甚至没有标准方法，如`toString()`。'
- en: Checking for undefined or null
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查undefined或null
- en: 'Functions normally allow you to indicate a missing value via either `undefined`
    or `null`. You can do the same via an explicit check:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通常允许您通过`undefined`或`null`指示缺少值。您可以通过显式检查来做相同的事情：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also exploit the fact that both `undefined` and `null` are considered
    `false`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以利用`undefined`和`null`都被视为`false`的事实：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Warning
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '`false`, `0`, `NaN`, and `''''` are also considered `false` (see [Truthy and
    Falsy](ch01.html#basic_truthy_falsy "Truthy and Falsy")).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`false`，`0`，`NaN`和`''''`也被视为`false`（参见[真值和假值](ch01.html#basic_truthy_falsy
    "真值和假值")）。'
- en: Categorizing Values Using typeof and instanceof
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用typeof和instanceof对值进行分类
- en: 'There are two operators for categorizing values: `typeof` is mainly used for
    primitive values, while `instanceof` is used for objects.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个用于对值进行分类的运算符：`typeof`主要用于原始值，而`instanceof`用于对象。
- en: '`typeof` looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`看起来像这样：'
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It returns a string describing the “type” of `value`. Here are some examples:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回描述`value`“类型”的字符串。以下是一些示例：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following table lists all results of `typeof`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表列出了`typeof`的所有结果：
- en: '| Operand | Result |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: 操作数 | 结果
- en: '| --- | --- |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `undefined` | `''undefined''` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` | `''undefined''` |'
- en: '| `null` | `''object''` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `''object''` |'
- en: '| Boolean value | `''boolean''` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | `''boolean''` |'
- en: '| Number value | `''number''` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 数字值 | `''number''` |'
- en: '| String value | `''string''` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 字符串值 | `''string''` |'
- en: '| Function | `''function''` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | `''function''` |'
- en: '| All other normal values | `''object''` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 所有其他正常值 | `''object''` |'
- en: '| (Engine-created value) | JavaScript engines are allowed to create values
    for which `typeof` returns arbitrary strings (different from all results listed
    in this table). |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|（引擎创建的值）| JavaScript引擎允许创建值，其`typeof`返回任意字符串（与此表中列出的所有结果都不同）。'
- en: '`typeof null` returning `''object''` is a bug that can’t be fixed, because
    it would break existing code. It does not mean that `null` is an object.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof null`返回`''object''`是一个无法修复的错误，因为这会破坏现有的代码。这并不意味着`null`是一个对象。'
- en: '`instanceof` looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`看起来像这样：'
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It returns `true` if `value` is an object that has been created by the constructor
    `Constr` (see [Constructors: Factories for Objects](ch01.html#basic_constructors
    "Constructors: Factories for Objects")). Here are some examples:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`value`是由构造函数`Constr`创建的对象，则返回`true`（参见[构造函数：对象的工厂](ch01.html#basic_constructors
    "构造函数：对象的工厂")）。以下是一些示例：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Booleans
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'The primitive boolean type comprises the values `true` and `false`. The following
    operators produce booleans:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 原始布尔类型包括值`true`和`false`。以下运算符产生布尔值：
- en: 'Binary logical operators: `&&` (And), `||` (Or)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制逻辑运算符：`&&`（与），`||`（或）
- en: 'Prefix logical operator: `!` (Not)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀逻辑运算符：`!`（非）
- en: 'Comparison operators:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符：
- en: 'Equality operators: `===`, `!==`, `==`, `!=`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等运算符：`===`，`!==`，`==`，`!=`
- en: 'Ordering operators (for strings and numbers): `>`, `>=`, `<`, `<=`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序运算符（用于字符串和数字）：`>`, `>=`, `<`, `<=`
- en: Truthy and Falsy
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真值和假值
- en: 'Whenever JavaScript expects a boolean value (e.g., for the condition of an
    `if` statement), any value can be used. It will be interpreted as either `true`
    or `false`. The following values are interpreted as `false`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 每当JavaScript期望布尔值（例如`if`语句的条件）时，可以使用任何值。它将被解释为`true`或`false`。以下值被解释为`false`：
- en: '`undefined`, `null`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`，`null`'
- en: 'Boolean: `false`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：`false`
- en: 'Number: `-0`, `NaN`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：`-0`，`NaN`
- en: 'String: `''''`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：`''`
- en: 'All other values (including all objects!) are considered `true`. Values interpreted
    as `false` are called *falsy*, and values interpreted as `true` are called *truthy*.
    `Boolean()`, called as a function, converts its parameter to a boolean. You can
    use it to test how a value is interpreted:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他值（包括所有对象！）都被认为是`true`。被解释为`false`的值称为*假值*，被解释为`true`的值称为*真值*。`Boolean()`作为函数调用，将其参数转换为布尔值。您可以使用它来测试值的解释方式：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Binary Logical Operators
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制逻辑运算符
- en: 'Binary logical operators in JavaScript are *short-circuiting*. That is, if
    the first operand suffices for determining the result, the second operand is not
    evaluated. For example, in the following expressions, the function `foo()` is
    never called:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的二进制逻辑运算符是*短路*的。也就是说，如果第一个操作数足以确定结果，第二个操作数将不会被评估。例如，在以下表达式中，函数`foo()`永远不会被调用：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Furthermore, binary logical operators return either one of their operands—which
    may or may not be a boolean. A check for truthiness is used to determine which
    one:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，二进制逻辑运算符返回它们的操作数之一，这些操作数可能是布尔值也可能不是。使用真值检查来确定哪一个：
- en: And (`&&`)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 和(`&&`)
- en: 'If the first operand is falsy, return it. Otherwise, return the second operand:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数为假值，则返回它。否则，返回第二个操作数：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Or (`||`)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 或(`||`)
- en: 'If the first operand is truthy, return it. Otherwise, return the second operand:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数为真值，则返回它。否则，返回第二个操作数：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Equality Operators
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相等运算符
- en: 'JavaScript has two kinds of equality:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有两种相等性：
- en: 'Normal, or “lenient,” (in)equality: `==` and `!=`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通，或“宽松”，（不）相等：`==`和`!=`
- en: 'Strict (in)equality: `===` and `!==`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格（不）相等：`===`和`!==`
- en: Normal equality considers (too) many values to be equal (the details are explained
    in [Normal (Lenient) Equality (==, !=)](ch09.html#normal_equality "Normal (Lenient)
    Equality (==, !=)")), which can hide bugs. Therefore, always using strict equality
    is recommended.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 普通相等性认为太多的值是相等的（详细内容在[普通（宽松）相等性（==，！=）](ch09.html#normal_equality "Normal (Lenient)
    Equality (==, !=)")中有解释），这可能会隐藏错误。因此，建议始终使用严格相等性。
- en: Numbers
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'All numbers in JavaScript are floating-point:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的所有数字都是浮点数：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Special numbers include the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊数字包括以下内容：
- en: '`NaN` (“not a number”)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`（“不是一个数字”）'
- en: 'An error value:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个错误值：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`Infinity`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`'
- en: 'Also mostly an error value:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 也是大多数错误值：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`Infinity` is larger than any other number (except `NaN`). Similarly, `-Infinity`
    is smaller than any other number (except `NaN`). That makes these numbers useful
    as default values (e.g., when you are looking for a minimum or a maximum).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`大于任何其他数字（除了`NaN`）。同样，`-Infinity`小于任何其他数字（除了`NaN`）。这使得这些数字在作为默认值时非常有用（例如，当你正在寻找最小值或最大值时）。'
- en: Operators
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符
- en: 'JavaScript has the following arithmetic operators (see [Arithmetic Operators](ch11.html#arithmetic_operators
    "Arithmetic Operators")):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有以下算术运算符（参见[算术运算符](ch11.html#arithmetic_operators "Arithmetic Operators")）：
- en: 'Addition: `number1 + number2`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法：`number1 + number2`
- en: 'Subtraction: `number1 - number2`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减法：`number1 - number2`
- en: 'Multiplication: `number1 * number2`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法：`number1 * number2`
- en: 'Division: `number1 / number2`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除法：`number1 / number2`
- en: 'Remainder: `number1 % number2`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 余数：`number1 % number2`
- en: 'Increment: `++variable`, `variable++`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量：`++variable`, `variable++`
- en: 'Decrement: `--variable`, `variable--`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递减：`--variable`, `variable--`
- en: 'Negate: `-value`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否定：`-value`
- en: 'Convert to number: `+value`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换为数字：`+value`
- en: The global object `Math` (see [Math](ch01.html#basic_math "Math")) provides
    more arithmetic operations, via functions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 全局对象`Math`（参见[Math](ch01.html#basic_math "Math")）通过函数提供更多的算术运算。
- en: JavaScript also has operators for bitwise operations (e.g., bitwise And; see
    [Bitwise Operators](ch11.html#bitwise_operators "Bitwise Operators")).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还有位操作的运算符（例如，位与；参见[位运算符](ch11.html#bitwise_operators "Bitwise Operators")）。
- en: Strings
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Strings can be created directly via string literals. Those literals are delimited
    by single or double quotes. The backslash (`\`) escapes characters and produces
    a few control characters. Here are some examples:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以直接通过字符串字面量创建。这些字面量由单引号或双引号括起来。反斜杠(`\`)转义字符并产生一些控制字符。以下是一些例子：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Single characters are accessed via square brackets:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 单个字符通过方括号访问：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The property `length` counts the number of characters in the string:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`length`计算字符串中的字符数：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Like all primitives, strings are immutable; you need to create a new string
    if you want to change an existing one.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有原始值一样，字符串是不可变的；如果要更改现有字符串，需要创建一个新字符串。
- en: String Operators
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串运算符
- en: 'Strings are concatenated via the plus (`+`) operator, which converts the other
    operand to a string if one of the operands is a string:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串通过加号(`+`)操作符进行连接，如果其中一个操作数是字符串，则将另一个操作数转换为字符串：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To concatenate strings in multiple steps, use the `+=` operator:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多个步骤中连接字符串，使用`+=`操作符：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: String Methods
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串方法
- en: 'Strings have many useful methods (see [String Prototype Methods](ch12.html#string_prototype_methods
    "String Prototype Methods")). Here are some examples:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串有许多有用的方法（参见[字符串原型方法](ch12.html#string_prototype_methods "String Prototype
    Methods")）。以下是一些例子：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Statements
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句
- en: Conditionals and loops in JavaScript are introduced in the following sections.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的条件和循环在以下部分介绍。
- en: Conditionals
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件
- en: 'The `if` statement has a `then` clause and an optional `else` clause that are
    executed depending on a boolean condition:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句有一个`then`子句和一个可选的`else`子句，根据布尔条件执行：'
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'I recommend always using braces (they denote blocks of zero or more statements).
    But you don’t have to do so if a clause is only a single statement (the same holds
    for the control flow statements `for` and `while`):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议始终使用大括号（它们表示零个或多个语句的块）。但如果一个子句只是一个语句，你不必这样做（对于控制流语句`for`和`while`也是如此）：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following is a `switch` statement. The value of `fruit` decides which `case`
    is executed:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`switch`语句。`fruit`的值决定执行哪个`case`：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The “operand” after `case` can be any expression; it is compared via `===` with
    the parameter of `switch`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`后的“操作数”可以是任何表达式；它通过`===`与`switch`的参数进行比较。'
- en: Loops
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环
- en: 'The `for` loop has the following format:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的格式如下：'
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`init` is executed at the beginning of the loop. `condition` is checked before
    each loop iteration; if it becomes `false`, then the loop is terminated. `post_iteration`
    is executed after each loop iteration.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`在循环开始时执行。在每次循环迭代之前检查`condition`；如果变为`false`，则终止循环。`post_iteration`在每次循环迭代后执行。'
- en: 'This example prints all elements of the array `arr` on the console:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在控制台上打印数组`arr`的所有元素：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `while` loop continues looping over its body while its condition holds:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环在其条件成立时继续循环其主体：'
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `do-while` loop continues looping over its body while its condition holds.
    As the condition follows the body, the body is always executed at least once:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while`循环在其条件成立时继续循环其主体。由于条件跟随主体，因此主体始终至少执行一次：'
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In all loops:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有循环中：
- en: '`break` leaves the loop.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`离开循环。'
- en: '`continue` starts a new loop iteration.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue`开始新的循环迭代。'
- en: Functions
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'One way of defining a function is via a *function declaration*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数的一种方式是通过*函数声明*：
- en: '[PRE58]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding code defines a function, `add`, that has two parameters, `param1`
    and `param2`, and returns the sum of both parameters. This is how you call that
    function:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了一个函数`add`，它有两个参数`param1`和`param2`，并返回这两个参数的总和。这是如何调用该函数的：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Another way of defining `add()` is by assigning a *function expression* to
    a variable `add`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`add()`的另一种方式是通过将*函数表达式*分配给变量`add`：
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A function expression produces a value and can thus be used to directly pass
    functions as arguments to other functions:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式产生一个值，因此可以直接用于将函数作为参数传递给其他函数：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Function Declarations Are Hoisted
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数声明被提升
- en: 'Function declarations are *hoisted*—moved in their entirety to the beginning
    of the current scope. That allows you to refer to functions that are declared
    later:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明是*提升*的-完整地移动到当前范围的开头。这允许您引用稍后声明的函数：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that while `var` declarations are also hoisted (see [Variables Are Hoisted](ch01.html#basic_var_hoisting
    "Variables Are Hoisted")), assignments performed by them are not:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然`var`声明也被提升（参见[变量被提升](ch01.html#basic_var_hoisting "变量被提升")），但是它们执行的赋值不会：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The Special Variable arguments
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊变量参数
- en: 'You can call any function in JavaScript with an arbitrary amount of arguments;
    the language will never complain. It will, however, make all parameters available
    via the special variable `arguments`. `arguments` looks like an array, but has
    none of the array methods:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任意数量的参数调用JavaScript中的任何函数；语言永远不会抱怨。但是，它将使所有参数通过特殊变量`arguments`可用。`arguments`看起来像一个数组，但没有数组方法：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Too Many or Too Few Arguments
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数太多或太少
- en: 'Let’s use the following function to explore how too many or too few parameters
    are handled in JavaScript (the function `toArray()` is shown in [Converting arguments
    to an Array](ch01.html#basic_toarray "Converting arguments to an Array")):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下函数来探索JavaScript中如何处理太多或太少的参数（函数`toArray()`显示在[将参数转换为数组](ch01.html#basic_toarray
    "将参数转换为数组")中）：
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Additional parameters will be ignored (except by `arguments`):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 将忽略额外的参数（除了`arguments`）：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Missing parameters will get the value `undefined`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少参数将获得值`undefined`：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Optional Parameters
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选参数
- en: 'The following is a common pattern for assigning default values to parameters:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为参数分配默认值的常见模式：
- en: '[PRE68]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In line (1), the `||` operator returns `x` if it is truthy (not `null`, `undefined`,
    etc.). Otherwise, it returns the second operand:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（1）行，`||`运算符返回`x`，如果它是真值（不是`null`，`undefined`等）。否则，它将返回第二个操作数：
- en: '[PRE69]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Enforcing an Arity
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制参数个数
- en: 'If you want to enforce an *arity* (a specific number of parameters), you can
    check `arguments.length`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要强制执行*arity*（特定数量的参数），可以检查`arguments.length`：
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Converting arguments to an Array
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将参数转换为数组
- en: '`arguments` is not an array, it is only *array-like* (see [Array-Like Objects
    and Generic Methods](ch17_split_001.html#array-like_objects "Array-Like Objects
    and Generic Methods")). It has a property `length`, and you can access its elements
    via indices in square brackets. You cannot, however, remove elements or invoke
    any of the array methods on it. Thus, you sometimes need to convert `arguments`
    to an array, which is what the following function does (it is explained in [Array-Like
    Objects and Generic Methods](ch17_split_001.html#array-like_objects "Array-Like
    Objects and Generic Methods")):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`不是数组，它只是*类似数组*（参见[类似数组对象和通用方法](ch17_split_001.html#array-like_objects
    "类似数组对象和通用方法")）。它有一个`length`属性，您可以通过方括号中的索引访问其元素。但是，您无法删除元素或调用其中任何数组方法。因此，有时需要将`arguments`转换为数组，这就是以下函数所做的事情（它在[类似数组对象和通用方法](ch17_split_001.html#array-like_objects
    "类似数组对象和通用方法")中有解释）：'
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Exception Handling
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理
- en: 'The most common way to handle exceptions (see [Chapter 14](ch14.html "Chapter 14. Exception
    Handling")) is as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常的最常见方法（参见[第14章](ch14.html "第14章。异常处理")）如下：
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `try` clause surrounds critical code, and the `catch` clause is executed
    if an exception is thrown inside the `try` clause. Using the preceding code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`子句包围关键代码，如果在`try`子句内抛出异常，则执行`catch`子句。使用前面的代码：'
- en: '[PRE73]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Strict Mode
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格模式
- en: 'Strict mode (see [Strict Mode](ch07.html#strict_mode "Strict Mode")) enables
    more warnings and makes JavaScript a cleaner language (nonstrict mode is sometimes
    called “sloppy mode”). To switch it on, type the following line first in a JavaScript
    file or a `<script>` tag:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式（参见[严格模式](ch07.html#strict_mode "严格模式")）启用更多警告，并使JavaScript成为一种更干净的语言（非严格模式有时被称为“松散模式”）。要打开它，请首先在JavaScript文件或`<script>`标记中键入以下行：
- en: '[PRE74]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can also enable strict mode per function:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为每个函数启用严格模式：
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Variable Scoping and Closures
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量作用域和闭包
- en: 'In JavaScript, you declare variables via `var` before using them:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你在使用变量之前通过`var`声明变量：
- en: '[PRE76]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can declare and initialize several variables with a single `var` statement:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用单个`var`语句声明和初始化多个变量：
- en: '[PRE77]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'But I recommend using one statement per variable (the reason is explained in
    [Syntax](ch26.html#style_one_var_per_line "Syntax")). Thus, I would rewrite the
    previous statement to:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 但我建议每个变量使用一个语句（原因在[Syntax](ch26.html#style_one_var_per_line "Syntax")中有解释）。因此，我会重写上一个语句为：
- en: '[PRE78]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Because of hoisting (see [Variables Are Hoisted](ch01.html#basic_var_hoisting
    "Variables Are Hoisted")), it is usually best to declare variables at the beginning
    of a function.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于提升（参见[变量被提升](ch01.html#basic_var_hoisting "变量被提升")），通常最好在函数的开头声明变量。
- en: Variables Are Function-Scoped
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量是函数作用域的
- en: 'The scope of a variable is always the complete function (as opposed to the
    current block). For example:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域总是整个函数（而不是当前的块）。例如：
- en: '[PRE79]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We can see that the variable `tmp` is not restricted to the block starting in
    line (1); it exists until the end of the function.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到变量`tmp`不仅限于从第（1）行开始的块；它存在直到函数的结束。
- en: Variables Are Hoisted
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量被提升
- en: 'Each variable declaration is *hoisted*: the declaration is moved to the beginning
    of the function, but assignments that it makes stay put. As an example, consider
    the variable declaration in line (1) in the following function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量声明都是*提升*的：声明被移动到函数的开头，但它所做的赋值保持不变。例如，考虑下面函数中第（1）行的变量声明：
- en: '[PRE80]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Internally, the preceding function is executed like this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，前面的函数是这样执行的：
- en: '[PRE81]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Closures
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Each function stays connected to the variables of the functions that surround
    it, even after it leaves the scope in which it was created. For example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都与包围它的函数的变量保持连接，即使它离开了被创建的作用域。例如：
- en: '[PRE82]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The function starting in line (1) leaves the context in which it was created,
    but stays connected to a live version of `start`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 从第（1）行开始的函数离开了它被创建的上下文，但仍然连接到`start`的一个活动版本：
- en: '[PRE83]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: A *closure* is a function plus the connection to the variables of its surrounding
    scopes. Thus, what `createIncrementor()` returns is a closure.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*闭包*是一个函数加上与其周围作用域的变量的连接。因此，`createIncrementor()`返回的是一个闭包。'
- en: 'The IIFE Pattern: Introducing a New Scope'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IIFE模式：引入新的作用域
- en: 'Sometimes you want to introduce a new variable scope—for example, to prevent
    a variable from becoming global. In JavaScript, you can’t use a block to do so;
    you must use a function. But there is a pattern for using a function in a block-like
    manner. It is called *IIFE* ([immediately invoked function expression](http://bit.ly/i-ife),
    pronounced “iffy”):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你想引入一个新的变量作用域——例如，防止一个变量成为全局的。在JavaScript中，你不能使用块来做到这一点；你必须使用一个函数。但是有一种使用函数的块状方式的模式。它被称为*IIFE*（[立即调用函数表达式](http://bit.ly/i-ife)，发音为“iffy”）：
- en: '[PRE84]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Be sure to type the preceding example exactly as shown (apart from the comments).
    An IIFE is a function expression that is called immediately after you define it.
    Inside the function, a new scope exists, preventing `tmp` from becoming global.
    Consult [Introducing a New Scope via an IIFE](ch16.html#iife "Introducing a New
    Scope via an IIFE") for details on IIFEs.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 确保按照前面的示例精确地输入（除了注释）。IIFE是一个在定义后立即调用的函数表达式。在函数内部，存在一个新的作用域，防止`tmp`成为全局的。请参阅[IIFE引入新的作用域](ch16.html#iife
    "IIFE引入新的作用域")了解IIFE的详细信息。
- en: 'IIFE use case: inadvertent sharing via closures'
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IIFE的用例：通过闭包无意中共享
- en: 'Closures keep their connections to outer variables, which is sometimes not
    what you want:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包保持与外部变量的连接，有时这并不是你想要的：
- en: '[PRE85]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The value returned in line (1) is always the current value of `i`, not the
    value it had when the function was created. After the loop is finished, `i` has
    the value 5, which is why all functions in the array return that value. If you
    want the function in line (1) to receive a snapshot of the current value of `i`,
    you can use an IIFE:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 第（1）行返回的值始终是`i`的当前值，而不是函数创建时的值。循环结束后，`i`的值为5，这就是为什么数组中的所有函数都返回该值。如果你想让第（1）行的函数接收当前`i`值的快照，你可以使用IIFE：
- en: '[PRE86]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Objects and Constructors
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象和构造函数
- en: 'This section covers two basic object-oriented mechanisms of JavaScript: single
    objects and *constructors* (which are factories for objects, similar to classes
    in other languages).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了JavaScript的两种基本面向对象的机制：单个对象和*构造函数*（它们是对象的工厂，类似于其他语言中的类）。
- en: Single Objects
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单个对象
- en: Like all values, objects have properties. You could, in fact, consider an object
    to be a set of properties, where each property is a (key, value) pair. The key
    is a string, and the value is any JavaScript value.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有的值一样，对象都有属性。实际上，你可以把对象看作是一组属性，其中每个属性都是一个（键，值）对。键是一个字符串，值是任何JavaScript值。
- en: 'In JavaScript, you can directly create plain objects, via *object literals*:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你可以直接通过*对象字面量*创建普通对象：
- en: '[PRE87]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The preceding object has the properties `name` and `describe`. You can read
    (“get”) and write (“set”) properties:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的对象有属性`name`和`describe`。你可以读取（“获取”）和写入（“设置”）属性：
- en: '[PRE88]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Function-valued properties such as `describe` are called *methods*. They use
    `this` to refer to the object that was used to call them:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 像`describe`这样的函数值属性被称为*方法*。它们使用`this`来引用调用它们的对象：
- en: '[PRE89]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `in` operator checks whether a property exists:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符检查一个属性是否存在：'
- en: '[PRE90]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'If you read a property that does not exist, you get the value `undefined`.
    Hence, the previous two checks could also be performed like this:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读取一个不存在的属性，你会得到值`undefined`。因此，前面的两个检查也可以这样执行：
- en: '[PRE91]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `delete` operator removes a property:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`运算符移除一个属性：'
- en: '[PRE92]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Arbitrary Property Keys
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任意属性键
- en: 'A property key can be any string. So far, we have seen property keys in object
    literals and after the dot operator. However, you can use them that way only if
    they are identifiers (see [Identifiers and Variable Names](ch01.html#basic_identifiers_variable_names
    "Identifiers and Variable Names")). If you want to use other strings as keys,
    you have to quote them in an object literal and use square brackets to get and
    set the property:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 属性键可以是任何字符串。到目前为止，我们已经在对象文字和点运算符之后看到了属性键。但是，只有在它们是标识符时，才能以这种方式使用它们（参见[Identifiers
    and Variable Names](ch01.html#basic_identifiers_variable_names "Identifiers and
    Variable Names")）。如果要使用其他字符串作为键，必须在对象文字中对其进行引用，并使用方括号来获取和设置属性：
- en: '[PRE93]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Square brackets also allow you to compute the key of a property:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号还允许您计算属性的键：
- en: '[PRE94]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Extracting Methods
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取方法
- en: If you extract a method, it loses its connection with the object. On its own,
    the function is not a method anymore, and `this` has the value `undefined` (in
    strict mode).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提取一个方法，它将失去与对象的连接。单独使用时，该函数不再是一个方法，`this` 的值为 `undefined`（在严格模式下）。
- en: 'As an example, let’s go back to the earlier object `jane`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们回到之前的对象 `jane`：
- en: '[PRE95]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We want to extract the method `describe` from `jane`, put it into a variable
    `func`, and call it. However, that doesn’t work:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想从 `jane` 中提取方法 `describe`，将其放入变量 `func` 中，并调用它。但是，这样做不起作用：
- en: '[PRE96]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The solution is to use the method `bind()` that all functions have. It creates
    a new function whose `this` always has the given value:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用所有函数都具有的 `bind()` 方法。它创建一个新函数，其 `this` 始终具有给定值：
- en: '[PRE97]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Functions Inside a Method
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法内的函数
- en: 'Every function has its own special variable `this`. This is inconvenient if
    you nest a function inside a method, because you can’t access the method’s `this`
    from the function. The following is an example where we call `forEach` with a
    function to iterate over an array:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都有自己的特殊变量 `this`。如果在方法内部嵌套函数，这是不方便的，因为您无法从函数中访问方法的 `this`。以下是一个示例，我们调用 `forEach`
    以使用函数遍历数组：
- en: '[PRE98]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Calling `logHiToFriends` produces an error:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `logHiToFriends` 会产生一个错误：
- en: '[PRE99]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let’s look at two ways of fixing this. First, we could store `this` in a different
    variable:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看修复这个问题的两种方法。首先，我们可以将 `this` 存储在不同的变量中：
- en: '[PRE100]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Or, `forEach` has a second parameter that allows you to provide a value for
    `this`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，`forEach` 有一个第二个参数，允许您为 `this` 提供一个值：
- en: '[PRE101]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Function expressions are often used as arguments in function calls in JavaScript.
    Always be careful when you refer to `this` from one of those function expressions.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，函数表达式经常用作函数调用中的参数。当您从这些函数表达式之一引用 `this` 时，一定要小心。
- en: 'Constructors: Factories for Objects'
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数：对象的工厂
- en: 'Until now, you may think that JavaScript objects are *only* maps from strings
    to values, a notion suggested by JavaScript’s object literals, which look like
    the map/dictionary literals of other languages. However, JavaScript objects also
    support a feature that is truly object-oriented: inheritance. This section does
    not fully explain how JavaScript inheritance works, but it shows you a simple
    pattern to get you started. Consult [Chapter 17](ch17_split_000.html "Chapter 17. Objects
    and Inheritance") if you want to know more.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能认为 JavaScript 对象 *只* 是从字符串到值的映射，这是 JavaScript 对象文字所暗示的概念，它看起来像其他语言的映射/字典文字。但是，JavaScript
    对象还支持一项真正面向对象的功能：继承。本节并未完全解释 JavaScript 继承的工作原理，但它向您展示了一个简单的模式，以便您开始。如果您想了解更多，请参阅[第17章](ch17_split_000.html
    "第17章。对象和继承")。
- en: 'In addition to being “real” functions and methods, functions play another role
    in JavaScript: they become *constructors*—factories for objects—if invoked via
    the `new` operator. Constructors are thus a rough analog to classes in other languages.
    By convention, the names of constructors start with capital letters. For example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为“真正的”函数和方法外，函数在 JavaScript 中还扮演另一个角色：如果通过 `new` 运算符调用，它们将成为 *构造函数*——对象的工厂。因此，构造函数在其他语言中是类的粗略类比。按照惯例，构造函数的名称以大写字母开头。例如：
- en: '[PRE102]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We can see that a constructor has two parts. First, the function `Point` sets
    up the instance data. Second, the property `Point.prototype` contains an object
    with the methods. The former data is specific to each instance, while the latter
    data is shared among all instances.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到构造函数有两个部分。首先，函数 `Point` 设置实例数据。其次，属性 `Point.prototype` 包含一个具有方法的对象。前者数据对每个实例都是特定的，而后者数据在所有实例之间共享。
- en: 'To use `Point`, we invoke it via the `new` operator:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Point`，我们通过 `new` 运算符调用它：
- en: '[PRE103]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '`p` is an instance of `Point`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`p` 是 `Point` 的一个实例：'
- en: '[PRE104]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Arrays
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays are sequences of elements that can be accessed via integer indices starting
    at zero.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是可以通过从零开始的整数索引访问的元素序列。
- en: Array Literals
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组文字
- en: 'Array literals are handy for creating arrays:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 数组文字对于创建数组很方便：
- en: '[PRE105]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The preceding array has three elements: the strings `''a''`, `''b''`, and `''c''`.
    You can access them via integer indices:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数组有三个元素：字符串 `'a'`、`'b'` 和 `'c'`。您可以通过整数索引访问它们：
- en: '[PRE106]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `length` property indicates how many elements an array has. You can use
    it to append elements and to remove elements:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 属性指示数组有多少个元素。您可以使用它来追加元素和删除元素：'
- en: '[PRE107]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The `in` operator works for arrays, too:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 运算符也适用于数组：'
- en: '[PRE108]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Note that arrays are objects and can thus have object properties:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数组是对象，因此可以具有对象属性：
- en: '[PRE109]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Array Methods
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组方法
- en: 'Arrays have many methods (see [Array Prototype Methods](ch18.html#array_prototype_methods
    "Array Prototype Methods")). Here are a few examples:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有许多方法（参见[Array Prototype Methods](ch18.html#array_prototype_methods "Array
    Prototype Methods")）。以下是一些示例：
- en: '[PRE110]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Iterating over Arrays
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历数组
- en: There are several array methods for iterating over elements (see [Iteration
    (Nondestructive)](ch18.html#array_iteration_methods "Iteration (Nondestructive)")).
    The two most important ones are `forEach` and `map`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种用于遍历元素的数组方法（参见[Iteration (Nondestructive)](ch18.html#array_iteration_methods
    "Iteration (Nondestructive)")）。最重要的两个是 `forEach` 和 `map`。
- en: '`forEach` iterates over an array and hands the current element and its index
    to a function:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach` 遍历数组并将当前元素及其索引传递给函数：'
- en: '[PRE111]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The preceding code produces the following output:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生以下输出：
- en: '[PRE112]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Note that the function in line (1) is free to ignore arguments. It could, for
    example, only have the parameter `elem`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第（1）行中的函数可以忽略参数。例如，它可能只有参数`elem`。
- en: '`map` creates a new array by applying a function to each element of an existing
    array:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`通过将函数应用于现有数组的每个元素来创建一个新数组：'
- en: '[PRE113]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Regular Expressions
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'JavaScript has built-in support for regular expressions ([Chapter 19](ch19.html
    "Chapter 19. Regular Expressions") refers to tutorials and explains in more detail
    how they work). They are delimited by slashes:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript内置支持正则表达式（[第19章](ch19.html "第19章.正则表达式")是教程，更详细地解释了它们的工作原理）。它们由斜杠分隔：
- en: '[PRE114]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Method test(): Is There a Match?'
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '方法test(): 是否有匹配项？'
- en: '[PRE115]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Method exec(): Match and Capture Groups'
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '方法exec(): 匹配和捕获组'
- en: '[PRE116]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The returned array contains the complete match at index 0, the capture of the
    first group at index 1, and so on. There is a way (discussed in [RegExp.prototype.exec:
    Capture Groups](ch19.html#RegExp.prototype.exec "RegExp.prototype.exec: Capture
    Groups")) to invoke this method repeatedly to get all matches.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '返回的数组包含索引0处的完整匹配项，索引1处的第一个组的捕获，依此类推。还有一种方法（在[RegExp.prototype.exec: Capture
    Groups](ch19.html#RegExp.prototype.exec "RegExp.prototype.exec: Capture Groups")中讨论）可以重复调用此方法以获取所有匹配项。'
- en: 'Method replace(): Search and Replace'
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '方法replace(): 搜索和替换'
- en: '[PRE117]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The first parameter of `replace` must be a regular expression with a `/g` flag;
    otherwise, only the first occurrence is replaced. There is also a way (as discussed
    in [String.prototype.replace: Search and Replace](ch19.html#String.prototype.replace
    "String.prototype.replace: Search and Replace")) to use a function to compute
    the replacement.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace`的第一个参数必须是带有`/g`标志的正则表达式；否则，只会替换第一个匹配项。还有一种方法（如在[String.prototype.replace:
    Search and Replace](ch19.html#String.prototype.replace "String.prototype.replace:
    Search and Replace")中讨论的）可以使用函数来计算替换。'
- en: Math
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学
- en: '`Math` (see [Chapter 21](ch21.html "Chapter 21. Math")) is an object with arithmetic
    functions. Here are some examples:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`（参见[第21章](ch21.html "第21章.Math")）是一个具有算术函数的对象。以下是一些示例：'
- en: '[PRE118]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Other Functionality of the Standard Library
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库的其他功能
- en: 'JavaScript’s standard library is relatively spartan, but there are more things
    you can use:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的标准库相对简陋，但还有更多可以使用的东西：
- en: '`Date` ([Chapter 20](ch20.html "Chapter 20. Dates"))'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`（[第20章](ch20.html "第20章.Dates")）'
- en: A constructor for dates whose main functionality is parsing and creating date
    strings and accessing the components of a date (year, hour, etc.).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 一个日期的构造函数，其主要功能是解析和创建日期字符串以及访问日期的组件（年、小时等）。
- en: '`JSON` ([Chapter 22](ch22.html "Chapter 22. JSON"))'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON`（[第22章](ch22.html "第22章.JSON")）'
- en: An object with functions for parsing and generating JSON data.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有解析和生成JSON数据功能的对象。
- en: '`console.*` methods (see [The Console API](ch23.html#console_api "The Console
    API"))'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.*` 方法（参见[控制台API](ch23.html#console_api "控制台API")）'
- en: These browser-specific methods are not part of the language proper, but some
    of them also work on Node.js.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特定于浏览器的方法不是语言本身的一部分，但其中一些也适用于Node.js。

- en: Part III. JavaScript in Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part is a comprehensive reference of the JavaScript language.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. JavaScript’s Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript’s syntax is fairly straightforward. This chapter describes things
    to watch out for.
  prefs: []
  type: TYPE_NORMAL
- en: An Overview of the Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section gives you a quick impression of what JavaScript’s syntax looks
    like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are five fundamental kinds of values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Booleans:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Plain objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few examples of basic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the two different uses of the equals sign:'
  prefs: []
  type: TYPE_NORMAL
- en: A single equals sign (`=`) is used to assign a value to a variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A triple equals sign (`===`) is used to compare two values (see [Equality Operators](ch01.html#basic_equality_operators
    "Equality Operators")).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two kinds of comments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Single-line comments via `//` extend to the rest of the line. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiline comments via `/* */` can extend over arbitrary ranges of text. They
    cannot be nested. Here are two examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Expressions Versus Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section looks at an important syntactic distinction in JavaScript: the
    difference between expressions and statements.'
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An *expression* produces a value and can be written wherever a value is expected—for
    example, as an argument in a function call or at the right side of an assignment.
    Each of the following lines contains an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Roughly, a *statement* performs an action. Loops and `if` statements are examples
    of statements. A program is basically a sequence of statements.^([[6](#ftn.id370625)])
  prefs: []
  type: TYPE_NORMAL
- en: 'Wherever JavaScript expects a statement, you can also write an expression.
    Such a statement is called an *expression statement*. The reverse does not hold:
    you cannot write a statement where JavaScript expects an expression. For example,
    an `if` statement cannot become the argument of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statement versus conditional expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The difference between statements and expressions becomes clearer if we look
    at members of the two syntactic categories that are similar: the `if` statement
    and the conditional operator (an expression).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a similar kind of expression, the *conditional operator*. The preceding
    statements are equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code between the equals sign and the semicolon is an expression. The parentheses
    are not necessary, but I find the conditional operator easier to read if I put
    it in parens.
  prefs: []
  type: TYPE_NORMAL
- en: Using ambiguous expressions as statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Two kinds of expressions look like statements—they are ambiguous with regard
    to their syntactic category:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Object literals (expressions) look like blocks (statements):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding construct is either an object literal (details: [Object Literals](ch17_split_000.html#object_literals
    "Object Literals")) or a block followed by the label `foo:`, followed by the function
    call `bar(3, 5)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Named function expressions look like function declarations (statements):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding construct is either a named function expression or a function
    declaration. The former produces a function, the latter creates a variable and
    assigns a function to it (details on both kinds of function definition: [Defining
    Functions](ch15.html#defining_functions "Defining Functions")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to prevent ambiguity during parsing, JavaScript does not let you use
    object literals and function expressions as statements. That is, expression statements
    must not start with:'
  prefs: []
  type: TYPE_NORMAL
- en: A curly brace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keyword `function`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an expression starts with either of those tokens, it can only appear in an
    expression context. You can comply with that requirement by, for example, putting
    parentheses around the expression. Next, we’ll look at two examples where that
    is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating an object literal via eval()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`eval` parses its argument in statement context. You have to put parentheses
    around an object literal if you want `eval` to return an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Immediately invoking a function expression
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code is an *immediately invoked function expression* (IIFE),
    a function whose body is executed right away (you’ll learn what IIFEs are used
    for in [Introducing a New Scope via an IIFE](ch16.html#iife "Introducing a New
    Scope via an IIFE")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the parentheses, you get a syntax error, because JavaScript sees
    a function declaration, which can’t be anonymous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you add a name, you also get a syntax error, because function declarations
    can’t be immediately invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Whatever follows a function declaration must be a legal statement and `()` isn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Control Flow Statements and Blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For control flow statements, the body is a single statement. Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, any statement can always be replaced by a *block*, curly braces containing
    zero or more statements. Thus, you can also write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I prefer the latter form of control flow statement. Standardizing on it means
    that there is no difference between single-statement bodies and multistatement
    bodies. As a consequence, your code looks more consistent, and alternating between
    one statement and more than one statement is easier.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Using Semicolons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we examine how semicolons are used in JavaScript. The basic
    rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, statements are terminated by semicolons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exception is statements ending with blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semicolons are optional in JavaScript. Missing semicolons are added via so-called
    *automatic semicolon insertion* (ASI; see [Automatic Semicolon Insertion](ch07.html#automatic_semicolon_insertion
    "Automatic Semicolon Insertion")). However, that feature doesn’t always work as
    expected, which is why you should always include semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: No Semicolon After a Statement Ending with a Block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following statements are not terminated by semicolons if they end with
    a block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loops: `for`, `while` (but not `do-while`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Branching: `if`, `switch`, `try`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function declarations (but not function expressions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of `while` versus `do-while`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s an example of a function declaration versus a function expression.
    The latter is followed by a semicolon, because it appears inside a `var` declaration
    (which *is* terminated by a semicolon):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do add a semicolon after a block, you do not get a syntax error, because
    it is considered an empty statement (see the next section).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That’s most of what you need to know about semicolons. If you always add semicolons,
    you can probably get by without reading the remaining parts of this section.
  prefs: []
  type: TYPE_NORMAL
- en: The Empty Statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A semicolon on its own is an *empty statement* and does nothing. Empty statements
    can appear anywhere a statement is expected. They are useful in situations where
    a statement is demanded, but not needed. In such situations, blocks are usually
    also allowed. For example, the following two statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `processNextItem` is assumed to return the number of remaining
    items. The following program, consisting of three empty statements, is also syntactically
    correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Automatic Semicolon Insertion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal of automatic semicolon insertion (ASI) is to make semicolons optional
    at the end of a line. The image invoked by the term *automatic semicolon insertion*
    is that the JavaScript parser inserts semicolons for you (internally, things are
    usually handled differently).
  prefs: []
  type: TYPE_NORMAL
- en: 'Put another way, ASI helps the parser to determine when a statement ends. Normally,
    it ends with a semicolon. ASI dictates that a statement also ends if:'
  prefs: []
  type: TYPE_NORMAL
- en: A line terminator (e.g., a newline) is followed by an illegal token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A closing brace is encountered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end of the file has been reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: ASI via illegal token'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code contains a line terminator followed by an illegal token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The token `console` is illegal after `0` and triggers ASI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: ASI via closing brace'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following code, the statement inside the braces is not terminated by
    a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'ASI creates a syntactically correct version of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Pitfall: ASI can unexpectedly break up statements'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ASI is also triggered if there is a line terminator after the keyword `return`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'ASI turns the preceding into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That’s an empty return, followed by a block with the label `name` in front of
    the expression statement `'John'`. After the block, there is an empty statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: ASI might unexpectedly not be triggered'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes a statement in a new line starts with a token that is allowed as
    a continuation of the previous statement. Then ASI is not triggered, even though
    it seems like it should be. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The square brackets in the second line are interpreted as an index into the
    result returned by `func()`. The comma inside the brackets is interpreted as the
    comma operator (which returns `''ol''` in this case; see [The Comma Operator](ch09.html#comma_operator
    "The Comma Operator")). Thus, JavaScript sees the previous code as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Legal Identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Identifiers are used for naming things and appear in various syntactic roles
    in JavaScript. For example, the names of variables and unquoted property keys
    must be valid identifiers. Identifiers are case sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first character of an identifier is one of:'
  prefs: []
  type: TYPE_NORMAL
- en: Any Unicode letter, including Latin letters such as D, Greek letters such as
    λ, and Cyrillic letters such as Д
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dollar sign (`$`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Underscore (`_`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subsequent characters are:'
  prefs: []
  type: TYPE_NORMAL
- en: Any legal first character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any Unicode digit in the Unicode category “Decimal number (Nd)”; this includes
    European numerals such as 7 and Indic numerals such as ٣
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various other Unicode marks and punctuations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples of legal identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Even though this enables you to use a variety of human languages in JavaScript
    code, I recommend sticking with English, for both identifiers and comments. That
    ensures that your code is understandable by the largest possible group of people,
    which is important, given how much code can spread internationally these days.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following identifiers are *reserved words*—they are part of the syntax
    and can’t be used as variable names (including function names and parameter names):'
  prefs: []
  type: TYPE_NORMAL
- en: '| `arguments` | `break` | `case` | `catch` |'
  prefs: []
  type: TYPE_TB
- en: '| `class` | `const` | `continue` | `debugger` |'
  prefs: []
  type: TYPE_TB
- en: '| `default` | `delete` | `do` | `else` |'
  prefs: []
  type: TYPE_TB
- en: '| `enum` | `export` | `extends` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `finally` | `for` | `function` | `if` |'
  prefs: []
  type: TYPE_TB
- en: '| `implements` | `import` | `in` | `instanceof` |'
  prefs: []
  type: TYPE_TB
- en: '| `interface` | `let` | `new` | `null` |'
  prefs: []
  type: TYPE_TB
- en: '| `package` | `private` | `protected` | `public` |'
  prefs: []
  type: TYPE_TB
- en: '| `return` | `static` | `super` | `switch` |'
  prefs: []
  type: TYPE_TB
- en: '| `this` | `throw` | `true` | `try` |'
  prefs: []
  type: TYPE_TB
- en: '| `typeof` | `var` | `void` | `while` |'
  prefs: []
  type: TYPE_TB
- en: 'The following three identifiers are not reserved words, but you should treat
    them as if they were:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Infinity` |'
  prefs: []
  type: TYPE_TB
- en: '| `NaN` |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` |'
  prefs: []
  type: TYPE_TB
- en: Lastly, you should also stay away from the names of standard global variables
    (see [Chapter 23](ch23.html "Chapter 23. Standard Global Variables")). You can
    use them for local variables without breaking anything, but your code still becomes
    confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you *can* use reserved words as unquoted property keys (as of ECMAScript 5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You can look up the precise rules for identifiers in Mathias Bynens’s blog post
    [“Valid JavaScript variable names”](http://mathiasbynens.be/notes/javascript-identifiers).
  prefs: []
  type: TYPE_NORMAL
- en: Invoking Methods on Number Literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With method invocations, it is important to distinguish between the floating-point
    dot and the method invocation dot. Thus, you cannot write `1.toString()`; you
    must use one of the following alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Strict Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 5 has a *strict mode* that results in cleaner JavaScript, with fewer
    unsafe features, more warnings, and more logical behavior. The normal (nonstrict)
    mode is sometimes called “sloppy mode.”
  prefs: []
  type: TYPE_NORMAL
- en: Switching on Strict Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You switch strict mode on by typing the following line first in your JavaScript
    file or inside your `<script>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that JavaScript engines that don’t support ECMAScript 5 will simply ignore
    the preceding statement, as writing strings in this manner (as an expression statement;
    see [Statements](ch07.html#expression_statement "Statements")) normally does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also switch on strict mode per function. To do so, write your function
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is handy when you are working with a legacy code base where switching on
    strict mode everywhere may break things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strict Mode: Recommended, with Caveats'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In general, the changes enabled by strict mode are all for the better. Thus,
    it is highly recommended to use it for new code you write—simply switch it on
    at the beginning of a file. There are, however, two caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling strict mode for existing code may break it
  prefs: []
  type: TYPE_NORMAL
- en: The code may rely on a feature that is not available anymore, or it may rely
    on behavior that is different in sloppy mode than in strict mode. Don’t forget
    that you have the option to add single strict mode functions to files that are
    in sloppy mode.
  prefs: []
  type: TYPE_NORMAL
- en: Package with care
  prefs: []
  type: TYPE_NORMAL
- en: When you concatenate and/or minify files, you have to be careful that strict
    mode isn’t switched off where it should be switched on or vice versa. Both can
    break code.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections explain the strict mode features in more detail. You
    normally don’t need to know them, as you will mostly get more warnings for things
    that you shouldn’t do anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Variables Must Be Declared in Strict Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All variables must be explicitly declared in strict mode. This helps to prevent
    typos. In sloppy mode, assigning to an undeclared variable creates a global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In strict mode, assigning to an undeclared variable throws an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Functions in Strict Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strict mode limits function-related features.
  prefs: []
  type: TYPE_NORMAL
- en: Functions must be declared at the top level of a scope
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In strict mode, all functions must be declared at the top level of a scope
    (global scope or directly inside a function). That means that you can’t put a
    function declaration inside a block. If you do, you get a descriptive `SyntaxError`.
    For example, V8 tells you: “In strict mode code, functions can only be declared
    at top level or immediately within another function”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: That is something that isn’t useful anyway, because the function is created
    in the scope of the surrounding function, not “inside” the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to work around this limitation, you can create a function inside
    a block via a variable declaration and a function expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Stricter rules for function parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The rules for function parameters are less permissive: using the same parameter
    name twice is forbidden, as are local variables that have the same name as a parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: The arguments objects has fewer properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `arguments` object is simpler in strict mode: the properties `arguments.callee`
    and `arguments.caller` have been eliminated, you can’t assign to the variable
    `arguments`, and `arguments` does not track changes to parameters (if a parameter
    changes, the corresponding array element does not change with it). [Deprecated
    features of arguments](ch15.html#arguments_deprecated_features "Deprecated features
    of arguments") explains the details.'
  prefs: []
  type: TYPE_NORMAL
- en: this is undefined in nonmethod functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In sloppy mode, the value of `this` in nonmethod functions is the global object
    (`window` in browsers; see [The Global Object](ch16.html#global_object "The Global
    Object")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In strict mode, it is `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful for constructors. For example, the following constructor, `Point`,
    is in strict mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to strict mode, you get a warning when you accidentally forget `new` and
    call it as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In sloppy mode, you don’t get a warning, and global variables `x` and `y` are
    created. Consult [Tips for Implementing Constructors](ch17_split_001.html#constructor_tips
    "Tips for Implementing Constructors") for details.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and Deleting Immutable Properties Fails with an Exception in Strict
    Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Illegal manipulations of properties throw exceptions in strict mode. For example,
    attempting to set the value of a read-only property throws an exception, as does
    attempting to delete a nonconfigurable property. Here is an example of the former:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Unqualified Identifiers Can’t Be Deleted in Strict Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In sloppy mode, you can delete a global variable `foo` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In strict mode, you get a syntax error whenever you try to delete unqualified
    identifiers. You can still delete global variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: eval() Is Cleaner in Strict Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In strict mode, the `eval()` function becomes less quirky: variables declared
    in the evaluated string are not added to the scope surrounding `eval()` anymore.
    For details, consult [Evaluating Code Using eval()](ch23.html#eval "Evaluating
    Code Using eval()").'
  prefs: []
  type: TYPE_NORMAL
- en: Features That Are Forbidden in Strict Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two more JavaScript features are forbidden in strict mode:'
  prefs: []
  type: TYPE_NORMAL
- en: The `with` statement is not allowed anymore (see [The with Statement](ch13.html#with_statement
    "The with Statement")). You get a syntax error at compile time (when loading the
    code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No more octal numbers: in sloppy mode, an integer with a leading zero is interpreted
    as octal (base 8). For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In strict mode, you get a syntax error if you use this kind of literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#id370625)]) To keep things simple, I’m pretending that declarations
    are statements.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8. Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has most of the values that we have come to expect from programming
    languages: booleans, numbers, strings, arrays, and so on. All normal values in
    JavaScript have *properties*.^([[7](#ftn.id914993)]) Each property has a *key*
    (or *name*) and a *value*. You can think of properties like fields of a record.
    You use the dot (`.`) operator to access properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript’s Type System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter gives an overview of JavaScript’s type system.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript’s Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has only six types, according to [Chapter 8 of the ECMAScript language
    specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8):'
  prefs: []
  type: TYPE_NORMAL
- en: 'An ECMAScript language type corresponds to values that are directly manipulated
    by an ECMAScript programmer using the ECMAScript language. The ECMAScript language
    types are:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Undefined, Null
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean, String, Number, and
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, constructors technically don’t introduce new types, even though they
    are said to have instances.
  prefs: []
  type: TYPE_NORMAL
- en: Static Versus Dynamic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the context of language semantics and type systems, *static* usually means
    “at compile time” or “without running a program,” while *dynamic* means “at runtime.”
  prefs: []
  type: TYPE_NORMAL
- en: Static Typing Versus Dynamic Typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a statically typed language, variables, parameters, and members of objects
    (JavaScript calls them properties) have types that the compiler knows at compile
    time. The compiler can use that information to perform type checks and to optimize
    the compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even in statically typed languages, a variable also has a dynamic type, the
    type of the variable’s value at a given point at runtime. The dynamic type can
    differ from the static type. For example (Java):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The static type of `foo` is `Object`; its dynamic type is `String`.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is dynamically typed; types of variables are generally not known
    at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Static Type Checking Versus Dynamic Type Checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have type information, you can check whether a value used in an operation
    (calling a function, applying an operator, etc.) has the correct type. Statically
    type-checked languages perform this kind of check at compile time, while dynamically
    type-checked languages do so at runtime. A language can be both statically type-checked
    and dynamically type-checked. If a check fails, you usually get some kind of error
    or exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript performs a very limited kind of dynamic type checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Mostly, however, things silently fail or work. For example, if you access a
    property that does not exist, you get the value `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Coercion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript, the main way of dealing with a value whose type doesn’t fit
    is to *coerce* it to the correct type. *Coercion* means implicit type conversion.
    Most operands coerce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript’s built-in conversion mechanisms support only the types `Boolean`,
    `Number`, `String`, and `Object`. There is no standard way to convert an instance
    of one constructor to an instance of another constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The terms *strongly typed* and *weakly typed* do not have [generally meaningful
    definitions](http://bit.ly/1oO7t1p). They are used, but normally incorrectly.
    It is better to instead use *statically typed*, *statically type-checked*, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Values Versus Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript makes a somewhat arbitrary distinction between values:'
  prefs: []
  type: TYPE_NORMAL
- en: The *primitive values* are booleans, numbers, strings, `null`, and `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other values are *objects*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A major difference between the two is how they are compared; each object has
    a unique identity and is only (strictly) equal to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, all primitive values encoding the same value are considered the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The following two sections explain primitive values and objects in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are all of the *primitive values* (*primitives* for short):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Booleans: `true`, `false` (see [Chapter 10](ch10.html "Chapter 10. Booleans"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Numbers: `1736`, `1.351` (see [Chapter 11](ch11.html "Chapter 11. Numbers"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strings: `''abc''`, `"abc"` (see [Chapter 12](ch12.html "Chapter 12. Strings"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two “nonvalues”: `undefined`, `null` (see [undefined and null](ch08.html#undefined_null
    "undefined and null"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Primitives have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Compared by value
  prefs: []
  type: TYPE_NORMAL
- en: 'The “content” is compared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Always immutable
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties can’t be changed, added, or removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: (Reading an unknown property always returns `undefined`.)
  prefs: []
  type: TYPE_NORMAL
- en: A fixed set of types
  prefs: []
  type: TYPE_NORMAL
- en: You can’t define your own primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All nonprimitive values are *objects*. The most common kinds of objects are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Plain objects* (constructor `Object`) can be created by *object literals*
    (see [Chapter 17](ch17_split_000.html "Chapter 17. Objects and Inheritance")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding object has two properties: the value of property `firstName`
    is `''Jane''`, and the value of property `lastName` is `''Doe''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Arrays* (constructor `Array`) can be created by *array literals* (see [Chapter 18](ch18.html
    "Chapter 18. Arrays")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The preceding array has three elements that can be accessed via numeric indices.
    For example, the index of `'apple'` is 0.
  prefs: []
  type: TYPE_NORMAL
- en: '*Regular expressions* (constructor `RegExp`) can be created by *regular expression
    literals* (see [Chapter 19](ch19.html "Chapter 19. Regular Expressions")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Objects have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Compared by reference
  prefs: []
  type: TYPE_NORMAL
- en: 'Identities are compared; every object has its own identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Mutable by default
  prefs: []
  type: TYPE_NORMAL
- en: 'You can normally freely change, add, and remove properties (see [Dot Operator
    (.): Accessing Properties via Fixed Keys](ch17_split_000.html#dot_operator "Dot
    Operator (.): Accessing Properties via Fixed Keys")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: User-extensible
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructors (see [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances")) can be seen as implementations
    of custom types (similar to classes in other languages).'
  prefs: []
  type: TYPE_NORMAL
- en: undefined and null
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has two “nonvalues” that indicate missing information, `undefined`
    and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined` means “no value” (neither primitive nor object). Uninitialized
    variables, missing parameters, and missing properties have that nonvalue. And
    functions implicitly return it if nothing has been explicitly returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` means “no object.” It is used as a nonvalue where an object is expected
    (as a parameter, as a member in a chain of objects, etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined` and `null` are the only values for which any kind of property access
    results in an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`undefined` is also sometimes used as more of a metavalue that indicates nonexistence.
    In contrast, `null` indicates emptiness. For example, a JSON node visitor (see
    [Transforming Data via Node Visitors](ch22.html#node_visitors "Transforming Data
    via Node Visitors")) returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined` to remove an object property or array element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` to set the property or element to `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occurrences of undefined and null
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we review the various scenarios where `undefined` and `null` occur.
  prefs: []
  type: TYPE_NORMAL
- en: Occurrences of undefined
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Uninitialized variables are `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Missing parameters are `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If you read a nonexistent property, you get `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'And functions implicitly return `undefined` if nothing has been explicitly
    returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Occurrences of null
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`null` is the last element in the prototype chain (a chain of objects; see
    [Layer 2: The Prototype Relationship Between Objects](ch17_split_000.html#prototype_relationship
    "Layer 2: The Prototype Relationship Between Objects")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`null` is returned by `RegExp.prototype.exec()` if there was no match for the
    regular expression in the string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Checking for undefined or null
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following sections we review how to check for `undefined` and `null`
    individually, or to check if either exists.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for null
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You check for `null` via strict equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Checking for undefined
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strict equality (`===`) is the canonical way of checking for `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check for `undefined` via the `typeof` operator ([typeof: Categorizing
    Primitives](ch09.html#typeof "typeof: Categorizing Primitives")), but you should
    normally use the aforementioned approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking for either undefined or null
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most functions allow you to indicate a missing value via either `undefined`
    or `null`. One way of checking for both of them is via an explicit comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is to exploit the fact that both `undefined` and `null` are considered
    `false` (see [Truthy and Falsy Values](ch10.html#truthy_falsy "Truthy and Falsy
    Values")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`false`, `0`, `NaN`, and `''''` are also considered `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: The History of undefined and null
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A single nonvalue could play the roles of both `undefined` and `null`. Why does
    JavaScript have two such values? The reason is historical.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript adopted Java’s approach of partitioning values into primitives and
    objects. It also used Java’s value for “not an object,” `null`. Following the
    precedent set by C (but not Java), `null` becomes 0 if coerced to a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the first version of JavaScript did not have exception handling.
    Therefore, exceptional cases such as uninitialized variables and missing properties
    had to be indicated via a value. `null` would have been a good choice, but Brendan
    Eich wanted to avoid two things at the time:'
  prefs: []
  type: TYPE_NORMAL
- en: The value shouldn’t have the connotation of a reference, because it was about
    more than just objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value shouldn’t coerce to 0, because that makes errors harder to spot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a result, Eich added `undefined` as an additional nonvalue to the language.
    It coerces to `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Changing undefined
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`undefined` is a [property of the global object](http://bit.ly/1oO9pXM) (and
    thus a global variable; see [The Global Object](ch16.html#global_object "The Global
    Object")). Under ECMAScript 3, you had to take precautions when reading `undefined`,
    because it was easy to accidentally change its value. Under ECMAScript 5, that
    is not necessary, because `undefined` is read-only.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To protect against a changed `undefined`, two techniques were popular (they
    are still relevant for older JavaScript engines):'
  prefs: []
  type: TYPE_NORMAL
- en: Technique 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Shadow the global `undefined` (which may have the wrong value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `undefined` is guaranteed to have the right value, because
    it is a parameter whose value has not been provided by the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Technique 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare with `void 0`, which is always (the correct) `undefined` (see [The
    void Operator](ch09.html#void_operator "The void Operator")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper Objects for Primitives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The three primitive types boolean, number, and string have corresponding constructors:
    `Boolean`, `Number`, `String`. Their instances (so-called *wrapper objects*) contain
    (*wrap*) primitive values. The constructors can be used in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As constructors, they create objects that are largely incompatible with the
    primitive values that they wrap:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'As functions, they convert values to the corresponding primitive types (see
    [Functions for Converting to Boolean, Number, String, and Object](ch08.html#convert_to_primitive
    "Functions for Converting to Boolean, Number, String, and Object")). This is the
    recommended method of conversion:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s considered a best practice to avoid wrapper objects. You normally don’t
    need them, as there is nothing that objects can do that primitives can’t (with
    the exception of being mutated). (This is different from Java, from which JavaScript
    inherited the difference between primitives and objects!)
  prefs: []
  type: TYPE_NORMAL
- en: Wrapper Objects Are Different from Primitives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Primitive values such as `''abc''` are fundamentally different from wrapper
    instances such as `new String(''abc'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrapper instances are objects, and there is no way of comparing objects in
    JavaScript, not even via lenient equals `==` (see [Equality Operators: === Versus
    ==](ch09.html#equality_operators "Equality Operators: === Versus ==")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping and Unwrapping Primitives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one use case for wrapper objects: you want to add properties to a
    primitive value. Then you wrap the primitive and add properties to the wrapper
    object. You need to unwrap the value before you can work with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap a primitive by invoking a wrapper constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Unwrap a primitive by invoking the method `valueOf()`. All objects have this
    method (as discussed in [Conversion to Primitive](ch17_split_001.html#Object.prototype.valueOf
    "Conversion to Primitive")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting wrapper objects to primitives properly extracts numbers and strings,
    but not booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is explained in [Converting to Boolean](ch10.html#toboolean
    "Converting to Boolean").
  prefs: []
  type: TYPE_NORMAL
- en: Primitives Borrow Their Methods from Wrappers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Primitives don’t have their own methods and borrow them from wrappers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Sloppy mode and strict mode handle this borrowing differently. In sloppy mode,
    primitives are converted to wrappers on the fly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In strict mode, methods from the wrapper prototype are used transparently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Type Coercion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Type coercion* means the implicit conversion of a value of one type to a value
    of another type. Most of JavaScript’s operators, functions, and methods coerce
    operands and arguments to the types that they need. For example, the operands
    of the multiplication operator (`*`) are coerced to numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'As another example, if one of the operands is a string, the plus operator (`+`)
    converts the other one to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Type Coercion Can Hide Bugs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Therefore, JavaScript rarely complains about a value having the wrong type.
    For example, programs normally receive user input (from online forms or GUI widgets)
    as strings, even if the user has entered a number. If you treat a number-as-string
    like a number, you will not get a warning, just unexpected results. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In cases such as the preceding one, you should convert to the appropriate type
    early on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Functions for Converting to Boolean, Number, String, and Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following functions are the preferred way of converting a value to a boolean,
    number, string, or object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Boolean()` (see [Converting to Boolean](ch10.html#toboolean "Converting to
    Boolean"))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Converts a value to a boolean. The following values are converted to `false`;
    they are the so-called “falsy” values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined`, `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`, `NaN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other values are considered “truthy” and converted to `true` (including
    all objects!).
  prefs: []
  type: TYPE_NORMAL
- en: '`Number()` (see [Converting to Number](ch11.html#tonumber "Converting to Number"))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Converts a value to a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined` becomes `NaN`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` becomes `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false` becomes `0`, `true` becomes `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings are parsed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects are first converted to primitives (discussed shortly), which are then
    converted to numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String()` (see [Converting to String](ch12.html#tostring "Converting to String"))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Converts a value to a string. It has the obvious results for all primitives.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Objects are first converted to primitives (discussed shortly), which are then
    converted to strings.
  prefs: []
  type: TYPE_NORMAL
- en: '`Object()` (see [Converting Any Value to an Object](ch17_split_000.html#toobject
    "Converting Any Value to an Object"))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Converts objects to themselves, `undefined` and `null` to empty objects, and
    primitives to wrapped primitives. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Note that `Boolean()`, `Number()`, `String()`, and `Object()` are called as
    functions. You normally don’t use them as constructors. Then they create instances
    of themselves (see [Wrapper Objects for Primitives](ch08.html#wrapper_objects
    "Wrapper Objects for Primitives")).
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithm: ToPrimitive()—Converting a Value to a Primitive'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To convert a value to either a number or a string, it is first converted to
    an arbitrary primitive value, which is then converted to the final type (as discussed
    in [Functions for Converting to Boolean, Number, String, and Object](ch08.html#convert_to_primitive
    "Functions for Converting to Boolean, Number, String, and Object")).
  prefs: []
  type: TYPE_NORMAL
- en: 'The ECMAScript specification has an internal function, `ToPrimitive()` (which
    is not accessible from JavaScript), that performs this conversion. Understanding
    `ToPrimitive()` enables you to configure how objects are converted to numbers
    and strings. It has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional parameter `PreferredType` indicates the final type of the conversion:
    it is either `Number` or `String`, depending on whether the result of `ToPrimitive()`
    will be converted to a number or a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `PreferredType` is `Number`, then you perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If `input` is primitive, return it (there is nothing more to do).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, `input` is an object. Call `input.valueOf()`. If the result is primitive,
    return it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, call `input.toString()`. If the result is primitive, return it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, throw a `TypeError` (indicating the failure to convert `input` to
    a primitive).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `PreferredType` is `String`, steps 2 and 3 are swapped. The `PreferredType`
    can also be omitted; it is then considered to be `String` for dates and `Number`
    for all other values. This is how the operators `+` and `==` call `ToPrimitive()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples: ToPrimitive() in action'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The default implementation of `valueOf()` returns `this`, while the default
    implementation of `toString()` returns type information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, `Number()` skips `valueOf()` and converts the result of `toString()`
    to a number; that is, it converts `''[object Object]''` to `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The following object customizes `valueOf()`, which influences `Number()`, but
    doesn’t change anything for `String()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The following object customizes `toString()`. Because the result can be converted
    to a number, `Number()` can return a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#id914993)]) Technically, primitive values do not have their own properties,
    they borrow them from wrapper constructors. But that is something that goes on
    behind the scenes, so you don’t normally see it.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9. Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter gives an overview of operators.
  prefs: []
  type: TYPE_NORMAL
- en: Operators and Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All operators coerce (as discussed in [Type Coercion](ch08.html#type_coercion
    "Type Coercion")) their operands to appropriate types. Most operators only work
    with primitive values (e.g., arithmetic operators and comparison operators). That
    means that objects are converted to primitives before anything is done with them.
    One example where that is unfortunate is the plus operator, which many languages
    use for array concatenation. That’s not so with JavaScript, however, where this
    operator converts arrays to strings and appends them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no way to overload or customize operators in JavaScript, not even equality.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways to use the plain assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x = value`'
  prefs: []
  type: TYPE_NORMAL
- en: Assigns to a variable `x` that has previously been declared
  prefs: []
  type: TYPE_NORMAL
- en: '`var x = value`'
  prefs: []
  type: TYPE_NORMAL
- en: Combines a variable declaration with an assignment
  prefs: []
  type: TYPE_NORMAL
- en: '`obj.propKey = value`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a property
  prefs: []
  type: TYPE_NORMAL
- en: '`obj[''propKey''] = value`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a property
  prefs: []
  type: TYPE_NORMAL
- en: '`arr[index] = value`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets an array element^([[8](#ftn.id443353)])
  prefs: []
  type: TYPE_NORMAL
- en: 'An assignment is an expression that evaluates to the assigned value. That allows
    you to chain assignments. For example, the following statement assigns `0` to
    both `y` and `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Compound Assignment Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *compound assignment operator* is written as `op=`, where `op` is one of
    several binary operators and `=` is the assignment operator. The following two
    expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, a compound assignment operator `op=` applies `op` to both operands
    and assigns the result to the first operand. Let’s look at an example of using
    the plus operator (`+`) via compound assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are all compound assignment operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic operations (see [Arithmetic Operators](ch11.html#arithmetic_operators
    "Arithmetic Operators")): `*=`, `/=`, `%=`, `+=`, `-=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bitwise operations (see [Binary Bitwise Operators](ch11.html#binary_bitwise_operators
    "Binary Bitwise Operators")): `<<=`, `>>=`, `>>>=`, `&=`, `^=`, `|=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String concatenation (see [Concatenation: The Plus (+) Operator](ch12.html#string_plus
    "Concatenation: The Plus (+) Operator")): `+=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Equality Operators: === Versus =='
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has two ways of determining whether two values are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: Strict equality (`===`) and strict inequality (`!==`) consider only values that
    have the same type to be equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal (or “lenient”) equality (`==`) and inequality (`!=`) try to convert values
    of different types before comparing them as with strict (in)equality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lenient equality is problematic in two regards. First, how it performs conversion
    is confusing. Second, due to the operators being so forgiving, type errors can
    remain hidden longer.
  prefs: []
  type: TYPE_NORMAL
- en: Always use strict equality and avoid lenient equality. You only need to learn
    about the latter if you want to know why it should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Equality is not customizable. Operators can’t be overloaded in JavaScript, and
    you can’t customize how equality works. There are some operations where you often
    need to influence comparison—for example, `Array.prototype.sort()` (see [Sorting
    and Reversing Elements (Destructive)](ch18.html#Array.prototype.sort "Sorting
    and Reversing Elements (Destructive)")). That method optionally accepts a callback
    that performs all comparisons between array elements.
  prefs: []
  type: TYPE_NORMAL
- en: Strict Equality (===, !==)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Values with different types are never strictly equal. If both values have the
    same type, then the following assertions hold:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined === undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null === null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Two booleans, two strings: obvious results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two objects (including arrays and functions): `x === y` if and only if `x`
    and `y` are the same object; that is, if you want to compare different objects,
    you have to implement your own comparison algorithm:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything else: not strictly equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pitfall: NaN'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The special number value `NaN` (see [NaN](ch11.html#nan "NaN")) is not equal
    to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, you need to use other means to check for it, which are described in [Pitfall:
    checking whether a value is NaN](ch11.html#isNaN "Pitfall: checking whether a
    value is NaN").'
  prefs: []
  type: TYPE_NORMAL
- en: Strict inequality (!==)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A strict inequality comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to the negation of a strict equality comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Normal (Lenient) Equality (==, !=)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The algorithm for comparing via normal equality works as follows. If both operands
    have the same type (one of the six specification types—Undefined, Null, Boolean,
    Number, String, and Object), then compare them via strict equality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, if the operands are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined` and `null`, then they are considered leniently equal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: A string and a number, then convert the string to a number and compare both
    operands via strict equality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A boolean and a nonboolean, then convert the boolean to a number and compare
    leniently (again).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An object and a number or a string, then try to convert the object to a primitive
    (via the algorithm described in [Algorithm: ToPrimitive()—Converting a Value to
    a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting a Value
    to a Primitive")) and compare leniently (again).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise—if none of the aforementioned cases apply—the result of the lenient
    comparison is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Lenient inequality (!=)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An inequality comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to the negation of an equality comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Pitfall: lenient equality is different from conversion to boolean'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Step 3 means that equality and conversion to boolean (see [Converting to Boolean](ch10.html#toboolean
    "Converting to Boolean")) work differently. If converted to boolean, numbers greater
    than 1 become `true` (e.g., in `if` statements). But those numbers are not leniently
    equal to `true`. The comments explain how the results were computed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, while the empty string is equal to `false`, not all nonempty strings
    are equal to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Pitfall: lenient equality and strings'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some of the leniency can be useful, depending on what you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Other cases are problematic, due to how JavaScript converts strings to numbers
    (see [Converting to Number](ch11.html#tonumber "Converting to Number")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Pitfall: lenient equality and objects'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you compare an object to a nonobject, it is converted to a primitive, which
    leads to strange results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'However, two objects are only equal if they are they same object. That means
    that you can’t really compare two wrapper objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: There Are No Valid Use Cases for ==
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You sometimes read about valid use cases for lenient equality (`==`). This section
    lists them and points out better alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use case: checking for undefined or null'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following comparison ensures that `x` is neither `undefined` nor `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is a compact way of writing this check, it confuses beginners, and
    experts can’t be sure whether it is a typo or not. Thus, if you want to check
    whether `x` has a value, use the standard check for truthiness (covered in [Truthy
    and Falsy Values](ch10.html#truthy_falsy "Truthy and Falsy Values")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to be more precise, you should perform an explicit check for both
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Use case: working with numbers in strings'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you are not sure whether a value `x` is a number or a number-as-a-string,
    you can use checks such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding checks whether `x` is either `123` or `''123''`. Again, this
    is very compact, and again, it is better to be explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Use case: comparing wrapper instances with primitives'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Lenient equals lets you compare primitives with wrapped primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three reasons against this approach. First, lenient equality does
    not work between wrapped primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, you should avoid wrappers anyway. Third, if you do use them, it is
    better to be explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Ordering Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript knows the following ordering operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Less than (`<`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than or equal (`<=`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than (`>`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than or equal (`>=`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These operators work for numbers and for strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: For strings, they are not very useful, because they are case-sensitive and don’t
    handle features such as accents well (for details, see [Comparing Strings](ch12.html#comparing_strings
    "Comparing Strings")).
  prefs: []
  type: TYPE_NORMAL
- en: The Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You evaluate a comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'by taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that both operands are primitives. Objects `obj` are converted to primitives
    via the internal operation `ToPrimitive(obj, Number)` (refer to [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")), which calls `obj.valueOf()` and, possibly, `obj.toString()`
    to do so.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If both operands are strings, then compare them by lexicographically comparing
    the 16-bit code units (see [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript"))
    that represent the JavaScript characters of the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, convert both operands to numbers and compare them numerically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other ordering operators are handled similarly.
  prefs: []
  type: TYPE_NORMAL
- en: The Plus Operator (+)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Roughly, the plus operator examines its operands. If one of them is a string,
    the other is also converted to a string and both are concatenated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, both operands are converted to numbers (see [Converting to Number](ch11.html#tonumber
    "Converting to Number")) and added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'That means that the order in which you evaluate matters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You evaluate an addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'by taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that both operands are primitives. Objects `obj` are converted to primitives
    via the internal operation `ToPrimitive(obj)` (refer to [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")), which calls `obj.valueOf()` and, possibly, `obj.toString()`
    to do so. For dates, `obj.toString()` is called first.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If either operand is a string, then convert both to strings and return the concatenation
    of the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, convert both operands to numbers and return the sum of the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operators for Booleans and Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following operators only have operands of a single type and also produce
    results of that type. They are covered elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary logical operators (see [Binary Logical Operators: And (&&) and Or (||)](ch10.html#binary_logical_operators
    "Binary Logical Operators: And (&&) and Or (||)")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Logical Not (see [Logical Not (!)](ch10.html#logical_not "Logical Not (!)")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Number operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic operators (see [Arithmetic Operators](ch11.html#arithmetic_operators
    "Arithmetic Operators")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Bitwise operators (see [Bitwise Operators](ch11.html#bitwise_operators "Bitwise
    Operators")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Special Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we will review special operators, namely the conditional, comma, and `void`
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Conditional Operator ( ? : )'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The conditional operator is an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'If the condition is `true`, the result is `if_true`; otherwise, the result
    is `if_false`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The parentheses around the operator are not needed, but they make it easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: The Comma Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The comma operator evaluates both operands and returns the result of `right`.
    Roughly, it does for expressions what the semicolon does for statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstrates that the second operand becomes the result of the
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'This example demonstrates that both operands are evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: The comma operator is confusing. It’s better to not be clever and to write two
    separate statements whenever you can.
  prefs: []
  type: TYPE_NORMAL
- en: The void Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax for the `void` operator is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'which evaluates `expr` and returns `undefined`. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, if you implement `void` as a function, it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The `void` operator is associated closely with its operand, so use parentheses
    as necessary. For example, `void 4+7` binds as `(void 4)+7`.
  prefs: []
  type: TYPE_NORMAL
- en: What is void used for?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Under ECMAScript 5, `void` is rarely useful. Its main use cases are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void 0` as a synonym for `undefined`'
  prefs: []
  type: TYPE_NORMAL
- en: The latter can be changed, while the former will always have the correct value.
    However, `undefined` is reasonably safe from being changed under ECMAScript 5,
    which makes this use case less important (for details, see [Changing undefined](ch08.html#changing_undefined
    "Changing undefined")).
  prefs: []
  type: TYPE_NORMAL
- en: Discarding the result of an expression
  prefs: []
  type: TYPE_NORMAL
- en: 'In some situations, it is important to return `undefined` as opposed to the
    result of an expression. Then `void` can be used to discard that result. One such
    situation involves `javascript:` URLs, which should be avoided for links, but
    are useful for bookmarklets. When you visit one of those URLs, many browsers replace
    the current document with the result of evaluating the URL’s “content,” but only
    if the result isn’t `undefined`. Hence, if you want to open a new window without
    changing the currently displayed content, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Prefixing an IIFE
  prefs: []
  type: TYPE_NORMAL
- en: 'An IIFE must be parsed as an expression. One of several ways to ensure that
    is by prefixing it with `void` (see [IIFE Variation: Prefix Operators](ch16.html#iife_prefix
    "IIFE Variation: Prefix Operators")).^([[9](#ftn.id936155)])'
  prefs: []
  type: TYPE_NORMAL
- en: Why does JavaScript have a void operator?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'According to JavaScript creator Brendan Eich, he added it to the language to
    help with `javascript:` links (one of the aforementioned use cases):'
  prefs: []
  type: TYPE_NORMAL
- en: 'I added the `void` operator to JS before Netscape 2 shipped to make it easy
    to discard any non-undefined value in a javascript: URL.^([[10](#ftn.id872078)])'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Categorizing Values via typeof and instanceof
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to categorize a value, you unfortunately have to distinguish between
    primitives and objects (refer back to [Chapter 8](ch08.html "Chapter 8. Values"))
    in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: The `typeof` operator distinguishes primitives from objects and determines the
    types of primitives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `instanceof` operator determines whether an object is an instance of a given
    constructor. Consult [Chapter 17](ch17_split_000.html "Chapter 17. Objects and
    Inheritance") for more information on object-oriented programming in JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'typeof: Categorizing Primitives'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `typeof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'returns a string describing what kind of value `value` is. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '`typeof` is used to distinguish primitives and objects and to categorize primitives
    (which cannot be handled by `instanceof`). Unfortunately, the results of this
    operator are not completely logical and only loosely correspond to the types of
    the ECMAScript specification (which are explained in [JavaScript’s Types](ch08.html#javascript_types
    "JavaScript’s Types")):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operand | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined`, undeclared variable | `''undefined''` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `''object''` |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean value | `''boolean''` |'
  prefs: []
  type: TYPE_TB
- en: '| Number value | `''number''` |'
  prefs: []
  type: TYPE_TB
- en: '| String value | `''string''` |'
  prefs: []
  type: TYPE_TB
- en: '| Function | `''function''` |'
  prefs: []
  type: TYPE_TB
- en: '| All other normal values | `''object''` |'
  prefs: []
  type: TYPE_TB
- en: '| (Engine-created value) | JavaScript engines are allowed to create values
    for whom `typeof` returns arbitrary strings (different from all results listed
    in this table). |'
  prefs: []
  type: TYPE_TB
- en: 'Pitfall: typeof null'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unfortunately, `typeof null` is `''object''`. This is considered a bug (`null`
    is not a member of the internal type Object), but it can’t be fixed, because doing
    so would break existing code. You thus have to be wary of `null`. For example,
    the following function checks whether `value` is an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The history of typeof null
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The [first JavaScript engine](http://mzl.la/1oO9VF7) represented JavaScript
    values as 32-bit words. The lowest 3 bits of such a word were used as a type tag,
    to indicate whether the value was an object, an integer, a double, a string, or
    a boolean (as you can see, even this early engine already stored numbers as integers
    if possible).
  prefs: []
  type: TYPE_NORMAL
- en: The type tag for objects was 000\. In order to represent the value `null`, the
    engine used the machine language NULL pointer, a word where all bits are zero.
    `typeof` checked the type tag to determine the type of value, which is why it
    reported `null` to be an object.^([[11](#ftn.id894831)])
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a variable exists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'has two use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: It determines whether `x` is `undefined`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It determines whether the variable `x` exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are examples of both use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first use case, comparing directly with `undefined` is usually a better
    choice. However, it doesn’t work for the second use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'instanceof: Checking Whether an Object Is an Instance of a Given Constructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `instanceof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'determines whether `value` has been created by the constructor `Constr` or
    a subconstructor. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, `instanceof` is `false` for the nonvalues `undefined` and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'But it is also `false` for all other primitive values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: For details on `instanceof`, consult [The instanceof Operator](ch17_split_001.html#operator_instanceof
    "The instanceof Operator").
  prefs: []
  type: TYPE_NORMAL
- en: Object Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following three operators work on objects. They are explained elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new` (see [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances"))'
  prefs: []
  type: TYPE_NORMAL
- en: Invoke a constructor—for example, `new Point(3, 5)`
  prefs: []
  type: TYPE_NORMAL
- en: '`delete` (see [Deleting properties](ch17_split_000.html#operator_delete "Deleting
    properties"))'
  prefs: []
  type: TYPE_NORMAL
- en: Delete a property—for example, `delete obj.prop`
  prefs: []
  type: TYPE_NORMAL
- en: '`in` (see [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties"))'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether an object has a given property—for example, `'prop' in obj`
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[8](#id443353)]) Strictly speaking, setting an array element is a special
    case of setting a property.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[9](#id936155)]) Thanks to Brandon Benvie (@benvie), who told me about using
    `void` for IIFEs.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[10](#id872078)]) Source: [http://en.wikipedia.org/wiki/Bookmarklet](http://en.wikipedia.org/wiki/Bookmarklet)'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[11](#id894831)]) Thanks to Tom Schuster (@evilpies) for pointing me to the
    source code of the first JavaScript engine.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10. Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The primitive boolean type comprises the values `true` and `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Converting to Boolean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Values are converted to booleans as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Converted to boolean |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| A boolean | Same as input (nothing to convert) |'
  prefs: []
  type: TYPE_TB
- en: '| A number | `0`, `NaN` → `false` |'
  prefs: []
  type: TYPE_TB
- en: '|  | other numbers → `true` |'
  prefs: []
  type: TYPE_TB
- en: '| A string | `''''` → `false` |'
  prefs: []
  type: TYPE_TB
- en: '|  | other strings → `true` |'
  prefs: []
  type: TYPE_TB
- en: '| An object | `true` (always!) |'
  prefs: []
  type: TYPE_TB
- en: Manually Converting to Boolean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three ways any value can be converted to a boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Boolean(value)` | (Invoked as a function, not as a constructor) |'
  prefs: []
  type: TYPE_TB
- en: '| `value ? true : false` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `!!value` | A single “not” converts to negated boolean; use twice for the
    nonnegated conversion. |'
  prefs: []
  type: TYPE_TB
- en: 'I prefer `Boolean()`, because it is more descriptive. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Truthy and Falsy Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Wherever JavaScript expects a boolean, you can provide any kind of value and
    it is automatically converted to boolean. Thus, there are two sets of values in
    JavaScript: one set is converted to `false`, while the other set is converted
    to `true`. These sets are called *falsy values* and *truthy values*. Given the
    preceding table, the following are all falsy values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined`, `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boolean: `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Number: `0`, `NaN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String: `''''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All other values—including *all* objects, even empty objects, empty arrays,
    and `new Boolean(false)`—are truthy. Because `undefined` and `null` are falsy,
    you can use the `if` statement to check whether a variable `x` has a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The caveat is that the preceding check interprets all falsy values as “does
    not have a value,” not just `undefined` and `null`. But if you can live with that
    limitation, you get to use a compact and established pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: all objects are truthy'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All objects are truthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'That is different from how objects are converted to a number or string, where
    you can control the result by implementing the methods `valueOf()` and `toString()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'History: Why are objects always truthy?'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The conversion to boolean is different for historic reasons. For ECMAScript 1,
    it was decided to not enable objects to configure that conversion (e.g., via a
    `toBoolean()` method). The rationale was that the boolean operators `||` and `&&`
    preserve the values of their operands. Therefore, if you chain those operators,
    the same value may be checked multiple times for truthiness or falsiness. Such
    checks are cheap for primitives, but would be costly for objects if they were
    able to configure their conversion to boolean. ECMAScript 1 avoided that cost
    by making objects always truthy.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we cover the basics of the And (&&), Or (||), and Not (!) logical
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary Logical Operators: And (&&) and Or (||)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Binary logical operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: Value-preserving
  prefs: []
  type: TYPE_NORMAL
- en: 'They always return either one of the operands, unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Short-circuiting
  prefs: []
  type: TYPE_NORMAL
- en: 'The second operand is not evaluated if the first operand already determines
    the result. For example (the result of `console.log` is `undefined`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: That is uncommon behavior for operators. Normally, all operands are evaluated
    before an operator is invoked (just like for functions).
  prefs: []
  type: TYPE_NORMAL
- en: Logical And (&&)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the first operand can be converted to `false`, return it. Otherwise, return
    the second operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Logical Or (||)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the first operand can be converted to `true`, return it. Otherwise, return
    the second operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Pattern: providing a default value'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes there are situations where a value (a parameter, the result of a
    function, etc.) can be either a nonvalue (`undefined`, `null`) or an actual value.
    If you want to provide a default value for the former case, you can use the Or
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding expression evaluates to `theValue` if it is truthy and to `defaultValue`
    otherwise. The usual caveat applies: `defaultValue` will also be returned if `theValue`
    has a falsy value other than `undefined` and `null`. Let’s look at three examples
    of using that pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: a default for a parameter'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The parameter `text` of the function `saveText()` is optional and should be
    the empty string if it has been omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: This is the most common use of `||` as a default operator. Consult [Optional
    Parameters](ch15.html#optional_parameters "Optional Parameters") for more on optional
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: a default for a property'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The object `options` may or may not have the property `title`. If it is missing,
    the value `''Untitled''` should be used when setting the title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Example 3: a default for the result of a function'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The function `countOccurrences` counts how often `regex` matches inside `str`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that `match()` (see [String.prototype.match: Capture Groups
    or Return All Matching Substrings](ch19.html#String.prototype.match "String.prototype.match:
    Capture Groups or Return All Matching Substrings")) either returns an array or
    `null`. Thanks to `||`, a default value is used in the latter case. Therefore,
    you can safely access the property `length` in both cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Logical Not (!)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The logical not operator `!` converts its operand to boolean and then negates
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Equality Operators, Ordering Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following operators are covered elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Equality operators: `===`, `!==`, `==`, `!=` (see [Equality Operators: ===
    Versus ==](ch09.html#equality_operators "Equality Operators: === Versus =="))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ordering operators: `>`, `>=`, `<`, `<=` (see [Ordering Operators](ch09.html#ordering_operators
    "Ordering Operators"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Function Boolean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function `Boolean` can be invoked in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Boolean(value)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a normal function, it converts `value` to a primitive boolean (see [Converting
    to Boolean](ch10.html#toboolean "Converting to Boolean")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '`new Boolean(bool)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a constructor, it creates a new instance of `Boolean` (see [Wrapper Objects
    for Primitives](ch08.html#wrapper_objects "Wrapper Objects for Primitives")),
    an object that wraps `bool` (after converting it to a boolean). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: The former invocation is the common one.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11. Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has a single type for all numbers: it treats all of them as floating-point
    numbers. However, the dot is not displayed if there are no digits after the decimal
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, most JavaScript engines optimize and do distinguish between floating-point
    numbers and integers (details: [Integers in JavaScript](ch11.html#integers "Integers
    in JavaScript")). But that is something that programmers don’t see.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript numbers are `double` (64-bit) values, based on the IEEE Standard
    for Floating-Point Arithmetic (IEEE 754). That standard is used by many programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Number Literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A number literal can be an integer, floating point, or (integer) hexadecimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Exponent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An exponent, `eX`, is an abbreviation for “multiply with 10^X”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Invoking Methods on Literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With number literals, the dot for accessing a property must be distinguished
    from the decimal dot. This leaves you with the following options if you want to
    invoke `toString()` on the number literal `123`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Converting to Number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Values are converted to numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `NaN` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| A boolean | `false` → `0` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `true` → `1` |'
  prefs: []
  type: TYPE_TB
- en: '| A number | Same as input (nothing to convert) |'
  prefs: []
  type: TYPE_TB
- en: '| A string | Parse the number in the string (ignoring leading and trailing
    whitespace); the empty string is converted to 0. Example: `''3.141''` → `3.141`
    |'
  prefs: []
  type: TYPE_TB
- en: '| An object | Call `ToPrimitive(value, Number)` (see [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")) and convert the resulting primitive. |'
  prefs: []
  type: TYPE_TB
- en: When converting the empty string to a number, `NaN` would arguably be a better
    result. The result 0 was chosen to help with empty numeric input fields, in line
    with what other programming languages did in the mid-1990s.^([[12](#ftn.id995098)])
  prefs: []
  type: TYPE_NORMAL
- en: Manually Converting to Number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The two most common ways to convert any value to a number are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Number(value)` | (Invoked as a function, not as a constructor) |'
  prefs: []
  type: TYPE_TB
- en: '| `+value` |  |'
  prefs: []
  type: TYPE_TB
- en: 'I prefer `Number()`, because it is more descriptive. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: parseFloat()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The global function `parseFloat()` provides another way to convert values to
    numbers. However, `Number()` is usually a better choice, as we shall see in a
    moment. This code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: converts `str` to string, trims leading whitespace, and then parses the longest
    prefix that is a floating-point number. If no such prefix exists (e.g., in an
    empty string), `NaN` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing `parseFloat()` and `Number()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying `parseFloat()` to a nonstring is less efficient, because it coerces
    its argument to a string before parsing it. As a consequence, many values that
    `Number()` converts to actual numbers are converted to `NaN` by `parseFloat()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '`parseFloat()` parses the empty string as `NaN`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '`parseFloat()` parses until the last legal character, meaning you get a result
    where you may not want one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '`parseFloat()` ignores leading whitespace and stops before illegal characters
    (which include whitespace):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '`Number()` ignores both leading and trailing whitespace (but other illegal
    characters lead to `NaN`).'
  prefs: []
  type: TYPE_NORMAL
- en: Special Number Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has several special number values:'
  prefs: []
  type: TYPE_NORMAL
- en: Two error values, `NaN` and `Infinity`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two values for zero, `+0` and `-0`. JavaScript has two zeros, a positive zero
    and a negative zero, because the sign and the magnitude of a number are stored
    separately. In most of this book, I pretend that there is only a single zero,
    and you almost never see in JavaScript that there are two of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NaN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The error value `NaN` (an abbreviation for “not a number”) is, ironically,
    a number value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'It is produced by errors such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A number could not be parsed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'An operation failed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the operands is `NaN` (this ensures that, if an error occurs during
    a longer computation, you can see it in the final result):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Pitfall: checking whether a value is NaN'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`NaN` is the only value that is not equal to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Strict equality (`===`) is also used by `Array.prototype.indexOf`. You therefore
    can’t search for `NaN` in an array via that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to check whether a value is `NaN`, you have to use the global function
    `isNaN()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `isNaN` does not work properly with nonnumbers, because it first converts
    those to numbers. That conversion can produce `NaN` and then the function incorrectly
    returns `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, it is best to combine `isNaN` with a type check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can check whether the value is unequal to itself (as `NaN`
    is the only value with this trait). But that is less self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Note that this behavior is dictated by IEEE 754\. As noted in Section 7.11,
    “Details of comparison predicates”:^([[13](#ftn.id1001327)])
  prefs: []
  type: TYPE_NORMAL
- en: Every NaN shall compare unordered with everything, including itself.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Infinity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Infinity` is an error value indicating one of two problems: a number can’t
    be represented because its magnitude is too large, or a division by zero has happened.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Infinity` is larger than any other number (except `NaN`). Similarly, `-Infinity`
    is smaller than any other number (except `NaN`). That makes them useful as default
    values—for example, when you are looking for a minimum or maximum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Error: a number’s magnitude is too large'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'How large a number’s magnitude can become is determined by its internal representation
    (as discussed in [The Internal Representation of Numbers](ch11.html#number_representation
    "The Internal Representation of Numbers")), which is the arithmetic product of:'
  prefs: []
  type: TYPE_NORMAL
- en: A mantissa (a binary number 1.f[1]f[2]...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 to the power of an exponent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The exponent must be between (and excluding) −1023 and 1024\. If the exponent
    is too small, the number becomes 0\. If the exponent is too large, it becomes
    `Infinity`. 2^(1023) can still be represented, but 2^(1024) can’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Error: division by zero'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Dividing by zero produces `Infinity` as an error value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Computing with Infinity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You get the error result `NaN` if you try to “neutralize” one `Infinity` with
    another one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to go beyond `Infinity`, you still get `Infinity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Checking for Infinity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strict and lenient equality work fine for `Infinity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the global function `isFinite()` allows you to check whether
    a value is an actual number (neither infinite nor `NaN`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Two Zeros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because JavaScript’s numbers keep magnitude and sign separate, each nonnegative
    number has a negative, including `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rationale for this is that whenever you represent a number digitally, it
    can become so small that it is indistinguishable from 0, because the encoding
    is not precise enough to represent the difference. Then a signed zero allows you
    to record “from which direction” you approached zero; that is, what sign the number
    had before it was considered zero. Wikipedia nicely sums up the pros and cons
    of [signed zeros](http://en.wikipedia.org/wiki/Signed_zero):'
  prefs: []
  type: TYPE_NORMAL
- en: It is claimed that the inclusion of signed zero in IEEE 754 makes it much easier
    to achieve numerical accuracy in some critical problems, in particular when computing
    with complex elementary functions. On the other hand, the concept of signed zero
    runs contrary to the general assumption made in most mathematical fields (and
    in most mathematics courses) that negative zero is the same thing as zero. Representations
    that allow negative zero can be a source of errors in programs, as software developers
    do not realize (or may forget) that, while the two zero representations behave
    as equal under numeric comparisons, they are different bit patterns and yield
    different results in some operations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Best practice: pretend there’s only one zero'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: JavaScript goes to great lengths to hide the fact that there are two zeros.
    Given that it normally doesn’t matter that they are different, it is recommended
    that you play along with the illusion of the single zero. Let’s examine how that
    illusion is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, you normally write `0`, which means `+0`. But `-0` is also displayed
    as simply `0`. This is what you see when you use a browser command line or the
    Node.js REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'That is because the standard `toString()` method converts both zeros to the
    same `''0''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Equality doesn’t distinguish zeros, either. Not even `===`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.indexOf` uses `===` to search for elements, maintaining the
    illusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'The ordering operators also consider the zeros to be equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Distinguishing the two zeros
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'How *can* you actually observe that the two zeros are different? You can divide
    by zero (`-Infinity` and `+Infinity` *can* be distinguished by `===`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to perform the division by zero is via `Math.pow()` (see [Numerical
    Functions](ch21.html#Math.pow "Numerical Functions")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '`Math.atan2()` (see [Trigonometric Functions](ch21.html#Math.atan2 "Trigonometric
    Functions")) also reveals that the zeros are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'The canonical way of telling the two zeros apart is the division by zero. Therefore,
    a function for detecting negative zeros would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the function in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: The Internal Representation of Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript numbers have 64-bit precision, which is also called *double precision*
    (type `double` in some programming languages). The internal representation is
    based on the IEEE 754 standard. The 64 bits are distributed between a number’s
    sign, exponent, and fraction as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Sign | Exponent ∈ [−1023, 1024] | Fraction |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 bit | 11 bits | 52 bits |'
  prefs: []
  type: TYPE_TB
- en: '| Bit 63 | Bits 62–52 | Bits 51–0 |'
  prefs: []
  type: TYPE_TB
- en: 'The value of a number is computed by the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: (–1)^(sign) × %1.fraction × 2^(exponent)
  prefs: []
  type: TYPE_NORMAL
- en: 'The prefixed percentage sign (`%`) means that the number in the middle is written
    in binary notation: a 1, followed by a binary point, followed by a binary fraction—namely
    the binary digits of the fraction (a natural number). Here are some examples of
    this representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| +0 |  | (sign = 0, fraction = 0, exponent = −1023) |'
  prefs: []
  type: TYPE_TB
- en: '| –0 |  | (sign = 1, fraction = 0, exponent = −1023) |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | = (−1)⁰ × %1.0 × 2⁰ | (sign = 0, fraction = 0, exponent = 0) |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | = (−1)⁰ × %1.0 × 2¹ |  |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | = (−1)⁰ × %1.1 × 2¹ | (sign = 0, fraction = 2^(51), exponent = 0) |'
  prefs: []
  type: TYPE_TB
- en: '| 0.5 | = (−1)⁰ × %1.0 × 2^(−1) |  |'
  prefs: []
  type: TYPE_TB
- en: '| −1 | = (−1)¹ × %1.0 × 2⁰ |  |'
  prefs: []
  type: TYPE_TB
- en: 'The encodings of +0, −0, and 3 can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '±0: Given that the fraction is always prefixed by a 1, it’s impossible to represent
    0 with it. Hence, JavaScript encodes a zero via the fraction 0 and the special
    exponent −1023\. The sign can be either positive or negative, meaning that JavaScript
    has two zeros (see [Two Zeros](ch11.html#two_zeros "Two Zeros")).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3: Bit 51 is the most significant (highest) bit of the fraction. That bit is
    1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special Exponents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previously mentioned representation of numbers is called *normalized*.
    In that case, the exponent *e* is in the range −1023 < *e* < 1024 (excluding lower
    and upper bounds). −1023 and 1024 are special exponents:'
  prefs: []
  type: TYPE_NORMAL
- en: 1024 is used for error values such as `NaN` and `Infinity`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '−1023 is used for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero (if the fraction is 0, as just explained)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small numbers close to zero (if the fraction is not 0).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enable both applications, a different, so-called *denormalized*, representation
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: (–1)^(sign) × %0.fraction × 2^(–1022)
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare, the smallest (as in “closest to zero”) numbers in normalized representation
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: (–1)^(sign) × %1.fraction × 2^(–1022)
  prefs: []
  type: TYPE_NORMAL
- en: Denormalized numbers are smaller, because there is no leading digit 1.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Rounding Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript’s numbers are usually entered as decimal floating-point numbers,
    but they are internally represented as binary floating-point numbers. That leads
    to imprecision. To understand why, let’s forget JavaScript’s internal storage
    format and take a general look at what fractions can be well represented by decimal
    floating-point numbers and by binary floating-point numbers. In the decimal system,
    all fractions are a mantissa *m* divided by a power of 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](eq_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, in the denominator, there are only tens. That’s why ![](inleq_1102.png)
    cannot be expressed precisely as a decimal floating-point number—there is no way
    to get a 3 into the denominator. Binary floating-point numbers only have twos
    in the denominator. Let’s examine which decimal floating-point numbers can be
    represented well as binary and which can’t. If there are only twos in the denominator,
    the decimal number can be represented:'
  prefs: []
  type: TYPE_NORMAL
- en: 0.5[dec] = ![](inleq_1103.png) = ![](inleq_1104.png) = 0.1[bin]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0.75[dec] = ![](inleq_1105.png) = ![](inleq_1106.png) = 0.11[bin]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0.125[dec] = ![](inleq_1107.png) = ![](inleq_1108.png) = 0.001[bin]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other fractions cannot be represented precisely, because they have numbers
    other than 2 in the denominator (after prime factorization):'
  prefs: []
  type: TYPE_NORMAL
- en: 0.1[dec] = ![](inleq_1109.png) = ![](inleq_1110.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0.2[dec] = ![](inleq_1111.png) = ![](inleq_1112.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can’t normally see that JavaScript doesn’t store exactly 0.1 internally.
    But you can make it visible by multiplying it with a high enough power of 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you add two imprecisely represented numbers, the result is sometimes
    imprecise enough that the imprecision becomes visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to rounding errors, as a best practice you should not compare nonintegers
    directly. Instead, take an upper bound for rounding errors into consideration.
    Such an upper bound is called a [*machine epsilon*](http://en.wikipedia.org/wiki/Machine_epsilon).
    The standard epsilon value for double precision is 2^(−53):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '`epsEqu()` ensures correct results where a normal comparison would be inadequate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Integers in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, JavaScript has only floating-point numbers. Integers appear
    internally in two ways. First, most JavaScript engines store a small enough number
    without a decimal fraction as an integer (with, for example, 31 bits) and maintain
    that representation as long as possible. They have to switch back to a floating-point
    representation if a number’s magnitude grows too large or if a decimal fraction
    appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, the ECMAScript specification has integer operators: namely, all of
    the bitwise operators. Those operators convert their operands to 32-bit integers
    and return 32-bit integers. For the specification, *integer* only means that the
    numbers don’t have a decimal fraction, and *32-bit* means that they are within
    a certain range. For engines, *32-bit integer* means that an actual integer (non-floating-point)
    representation can usually be introduced or maintained.'
  prefs: []
  type: TYPE_NORMAL
- en: Ranges of Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Internally, the following ranges of integers are important in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Safe integers (see [Safe Integers](ch11.html#safe_integers "Safe Integers")),
    the largest practically usable range of integers that JavaScript supports:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 53 bits plus a sign, range (−2^(53), 2^(53))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Array indices (see [Array Indices](ch18.html#array_indices "Array Indices")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32 bits, unsigned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maximum length: 2^(32)−1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Range of indices: [0, 2^(32)−1) (excluding the maximum length!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bitwise operands (see [Bitwise Operators](ch11.html#bitwise_operators "Bitwise
    Operators")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unsigned right shift operator (`>>>`): 32 bits, unsigned, range [0, 2^(32))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All other bitwise operators: 32 bits, including a sign, range [−2^(31), 2^(31))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Char codes,” UTF-16 code units as numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepted by `String.fromCharCode()` (see [String Constructor Method](ch12.html#String.fromCharCode
    "String Constructor Method"))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returned by `String.prototype.charCodeAt()` (see [Extract Substrings](ch12.html#String.prototype.charCodeAt
    "Extract Substrings"))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16 bits, unsigned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing Integers as Floating-Point Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript can only handle integer values up to a magnitude of 53 bits (the
    52 bits of the fraction plus 1 indirect bit, via the exponent; see [The Internal
    Representation of Numbers](ch11.html#number_representation "The Internal Representation
    of Numbers") for details).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table explains how JavaScript represents 53-bit integers as floating-point
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Bits | Range | Encoding |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 bit | 0 | (See [The Internal Representation of Numbers](ch11.html#number_representation
    "The Internal Representation of Numbers").) |'
  prefs: []
  type: TYPE_TB
- en: '| 1 bit | 1 | %1 × 2⁰ |'
  prefs: []
  type: TYPE_TB
- en: '| 2 bits | 2–3 | %1.f[51] × 2¹ |'
  prefs: []
  type: TYPE_TB
- en: '| 3 bits | 4–7 = 2²–(2³−1) | %1.f[51]f[50] × 2² |'
  prefs: []
  type: TYPE_TB
- en: '| 4 bits | 2³–(2⁴−1) | %1.f[51]f[50]f[49] × 2³ |'
  prefs: []
  type: TYPE_TB
- en: '| ⋯ | ⋯ | ⋯ |'
  prefs: []
  type: TYPE_TB
- en: '| 53 bits | 2^(52)–(2^(53)−1) | %1.f[51]⋯f[0] × 2^(52) |'
  prefs: []
  type: TYPE_TB
- en: 'There is no fixed sequence of bits that represents the integer. Instead, the
    mantissa %1.f is shifted by the exponent, so that the leading digit 1 is in the
    right place. In a way, the exponent counts the number of digits of the fraction
    that are in active use (the remaining digits are 0). That means that for 2 bits,
    we use one digit of the fraction and for 53 bits, we use all digits of the fraction.
    Additionally, we can represent 2^(53) as %1.0 × 2^(53), but we get problems with
    higher numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Bits | Range | Encoding |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 54 bits | 2^(53)–(2^(54)−1) | %1.f[51]⋯f[0]0 × 2^(53) |'
  prefs: []
  type: TYPE_TB
- en: '| 55 bits | 2^(54)–(2^(55)−1) | %1.f[51]⋯f[0]00 × 2^(54) |'
  prefs: []
  type: TYPE_TB
- en: '| ⋯ |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'For 54 bits, the least significant digit is always 0, for 55 bits the two least
    significant digits are always 0, and so on. That means that for 54 bits, we can
    only represent every second number, for 55 bits only every fourth number, and
    so on. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Best practice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you work with integers of up to 53 bits magnitude, you are fine. Unfortunately,
    you’ll often encounter 64-bit unsigned integers in programming (Twitter IDs, databases,
    etc.). These must be stored in strings in JavaScript. If you want to perform arithmetic
    with such integers, you need special libraries. There are plans to bring larger
    integers to JavaScript, but that will take a while.
  prefs: []
  type: TYPE_NORMAL
- en: Safe Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript can only safely represent integers *i* in the range −2^(53) < *i*
    < 2^(53). This section examines what that means and what the consequences are.
    It is based on an [email by Mark S. Miller to the es-discuss mailing list](http://mzl.la/1oOaCOO).
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of a safe integer centers on how mathematical integers are represented
    in JavaScript. In the range (−2^(53), 2^(53)) (excluding the lower and upper bounds),
    JavaScript integers are *safe*: there is a one-to-one mapping between mathematical
    integers and their representations in JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond this range, JavaScript integers are *unsafe*: two or more mathematical
    integers are represented as the same JavaScript integer. For example, starting
    at 2^(53), JavaScript can represent only every second mathematical integer (the
    previous section explains why). Therefore, a safe JavaScript integer is one that
    unambiguously represents a single mathematical integer.'
  prefs: []
  type: TYPE_NORMAL
- en: Definitions in ECMAScript 6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ECMAScript 6 will provide the following constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'It will also provide a function for determining whether an integer is safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: For a given value `n`, this function first checks whether `n` is a number and
    an integer. If both checks succeed, `n` is safe if it is greater than or equal
    to `MIN_SAFE_INTEGER` and less than or equal to `MAX_SAFE_INTEGER`.
  prefs: []
  type: TYPE_NORMAL
- en: Safe results of arithmetic computations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'How can we make sure that results of arithmetic computations are correct? For
    example, the following result is clearly not correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two safe operands, but an unsafe result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'The following result is also incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the result is safe, but one of the operands isn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the result of applying an integer operator `op` is guaranteed to
    be correct only if all operands and the result are safe. More formally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: implies that `a op b` is a correct result.
  prefs: []
  type: TYPE_NORMAL
- en: Converting to Integer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, all numbers are floating point. Integers are floating-point
    numbers without a fraction. Converting a number `n` to an integer means finding
    the integer that is “closest” to `n` (where the meaning of “closest” depends on
    how you convert). You have several options for performing this conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Math` functions `Math.floor()`, `Math.ceil()`, and `Math.round()` (see
    [Integers via Math.floor(), Math.ceil(), and Math.round()](ch11.html#integers_via_math
    "Integers via Math.floor(), Math.ceil(), and Math.round()"))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The custom function `ToInteger()` (see [Integers via the Custom Function ToInteger()](ch11.html#ToInteger
    "Integers via the Custom Function ToInteger()"))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Binary bitwise operators (see [32-bit Integers via Bitwise Operators](ch11.html#integers_via_bitwise_operators
    "32-bit Integers via Bitwise Operators"))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The global function `parseInt()` (see [Integers via parseInt()](ch11.html#parseInt
    "Integers via parseInt()"))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Spoiler: #1 is usually the best choice, #2 and #3 have niche applications,
    and #4 is OK for parsing strings, but not for converting numbers to integers.'
  prefs: []
  type: TYPE_NORMAL
- en: Integers via Math.floor(), Math.ceil(), and Math.round()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following three functions are usually the best way of converting a number
    to an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.floor()` converts its argument to the closest lower integer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '`Math.ceil()` converts its argument to the closest higher integer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '`Math.round()` converts its argument to the closest integer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of rounding `-3.5` may be surprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, `Math.round(x)` is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Integers via the Custom Function ToInteger()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another good option for converting any value to an integer is the internal
    ECMAScript operation `ToInteger()`, which removes the fraction of a floating-point
    number. If it was accessible in JavaScript, it would work like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'The ECMAScript specification defines the result of `ToInteger(number)` as:'
  prefs: []
  type: TYPE_NORMAL
- en: sign(number) × floor(abs(number))
  prefs: []
  type: TYPE_NORMAL
- en: 'For what it does, this formula is relatively complicated because `floor` seeks
    the closest *larger* integer; if you want to remove the fraction of a negative
    integer, you have to seek the closest smaller integer. The following code implements
    the operation in JavaScript. We avoid the `sign` operation by using `ceil` if
    the number is negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 32-bit Integers via Bitwise Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Binary bitwise operators (see [Binary Bitwise Operators](ch11.html#binary_bitwise_operators
    "Binary Bitwise Operators")) convert (at least) one of their operands to a 32-bit
    integer that is then manipulated to produce a result that is also a 32-bit integer.
    Therefore, if you choose the other operand appropriately, you get a fast way to
    convert an arbitrary number to a 32-bit integer (that is either signed or unsigned).
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise Or (|)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If the mask, the second operand, is 0, you don’t change any bits and the result
    is the first operand, coerced to a signed 32-bit integer. This is the canonical
    way to execute this kind of coercion and is used, for example, by asm.js (refer
    back to [Is JavaScript Fast Enough?](ch02.html#asm.js "Is JavaScript Fast Enough?")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '`ToInt32()` removes the fraction and applies modulo 2^(32):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Shift operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The same trick that worked for bitwise Or also works for shift operators: if
    you shift by zero bits, the result of a shift operation is the first operand,
    coerced to a 32-bit integer. Here are some examples of implementing operations
    of the ECMAScript specification via shift operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is `ToUint32()` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Should I use bitwise operators to coerce to integer?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You have to decide for yourself if the slight increase in efficiency is worth
    your code being harder to understand. Also note that bitwise operators artificially
    limit themselves to 32 bits, which is often neither necessary nor useful. Using
    one of the `Math` functions, possibly in addition to `Math.abs()`, is a more self-explanatory
    and arguably better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Integers via parseInt()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `parseInt()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: parses the string `str` (nonstrings are coerced) as an integer. The function
    ignores leading whitespace and considers as many consecutive legal digits as it
    can find.
  prefs: []
  type: TYPE_NORMAL
- en: The radix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The range of the radix is 2 ≤ `radix` ≤ 36. It determines the base of the number
    to be parsed. If the radix is greater than 10, letters are used as digits (case-insensitively),
    in addition to 0–9.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `radix` is missing, then it is assumed to be 10, except if `str` begins
    with “0x” or “0X,” in which case `radix` is set to 16 (hexadecimal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'If `radix` is already 16, then the hexadecimal prefix is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'So far I have described the behavior of `parseInt()` according to the ECMAScript
    specification. Additionally, some engines set the radix to 8 if `str` starts with
    a zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Thus, it is best to always explicitly state the radix, to always call `parseInt()`
    with two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t use `parseInt()` to convert a number to an integer. The last example
    gives us hope that we might be able to use `parseInt()` for converting numbers
    to integers. Alas, here is an example where the conversion is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The argument is first converted to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '`parseInt` doesn’t consider “e” to be an integer digit and thus stops parsing
    after the 1\. Here’s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`parseInt()` shouldn’t be used to convert numbers to integers: coercion to
    string is an unnecessary detour and even then, the result is not always correct.'
  prefs: []
  type: TYPE_NORMAL
- en: '`parseInt()` *is* useful for parsing strings, but you have to be aware that
    it stops at the first illegal digit. Parsing strings via `Number()` (see [The
    Function Number](ch11.html#function_number "The Function Number")) is less forgiving,
    but may produce nonintegers.'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following operators are available for numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`number1 + number2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Numerical addition, unless either of the operands is a string. Then both operands
    are converted to strings and concatenated (see [The Plus Operator (+)](ch09.html#plus_operator
    "The Plus Operator (+)")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '`number1 - number2`'
  prefs: []
  type: TYPE_NORMAL
- en: Subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: '`number1 * number2`'
  prefs: []
  type: TYPE_NORMAL
- en: Multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: '`number1 / number2`'
  prefs: []
  type: TYPE_NORMAL
- en: Division.
  prefs: []
  type: TYPE_NORMAL
- en: '`number1 % number2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remainder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This operation is not modulo. It returns a value whose sign is the same as the
    first operand (more details in a moment).
  prefs: []
  type: TYPE_NORMAL
- en: '`-number`'
  prefs: []
  type: TYPE_NORMAL
- en: Negates its argument.
  prefs: []
  type: TYPE_NORMAL
- en: '`+number`'
  prefs: []
  type: TYPE_NORMAL
- en: Leaves its argument as is; nonnumbers are converted to a number.
  prefs: []
  type: TYPE_NORMAL
- en: '`++variable`, `--variable`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the current value of the variable after incrementing (or decrementing)
    it by 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '`variable++`, `variable--`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Increments (or decrements) the value of the variable by 1 and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'Mnemonic: increment (++) and decrement (--) operators'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The position of the operand can help you remember whether it is returned before
    or after incrementing (or decrementing) it. If the operand comes before the increment
    operator, it is returned before incrementing it. If the operand comes after the
    operator, it is incremented and then returned. (The decrement operator works similarly.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: The Remainder Operator (%) Is Not Modulo'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the remainder operator always has the sign of the first operand
    (for modulo, it is the sign of the second operand):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'That means that the following function does not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct version is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Bitwise Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has several bitwise operators that work with 32-bit integers. That
    is, they convert their operands to 32-bit integers and produce a result that is
    a 32-bit integer. Use cases for these operators include processing binary protocols,
    special algorithms, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Background Knowledge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section explains a few concepts that will help you understand bitwise operators.
  prefs: []
  type: TYPE_NORMAL
- en: Binary complements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Two common ways of computing a binary complement (or inverse) of a binary number
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Ones’ complement
  prefs: []
  type: TYPE_NORMAL
- en: 'You compute the ones’ complement `~x` of a number `x` by inverting each of
    the 32 digits. Let’s illustrate the ones’ complement via four-digit numbers. The
    ones’ complement of `1100` is `0011`. Adding a number to its ones’ complement
    results in a number whose digits are all 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Twos’ complement
  prefs: []
  type: TYPE_NORMAL
- en: 'The twos’ complement `-x` of a number `x` is the ones’ complement plus one.
    Adding a number to its twos’ complement results in `0` (ignoring overflow beyond
    the most significant digit). Here’s an example using four-digit numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: Signed 32-bit integers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '32-bit integers don’t have an explicit sign, but you can still encode negative
    numbers. For example, −1 can be encoded as the twos’ complement of 1: adding 1
    to the result yields 0 (within 32 bits). The boundary between positive and negative
    numbers is fluid; 4294967295 (2^(32)−1) and −1 are the same integer here. But
    you have to decide on a sign when you convert such an integer from or to a JavaScript
    number, which has an explicit sign as opposed to an implicit one. Therefore, *signed
    32-bit integers* are partitioned into two groups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Highest bit is 0: number is zero or positive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Highest bit is 1: number is negative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The highest bit is often called the *sign bit*. Accordingly, 4294967295, interpreted
    as a signed 32-bit integer, becomes −1 when converted to a JavaScript number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '`ToInt32()` is explained in [32-bit Integers via Bitwise Operators](ch11.html#integers_via_bitwise_operators
    "32-bit Integers via Bitwise Operators").'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only the unsigned right shift operator (`>>>`) works with unsigned 32-bit integers;
    all other bitwise operators work with signed 32-bit integers.
  prefs: []
  type: TYPE_NORMAL
- en: Inputting and outputting binary numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following examples, we work with binary numbers via the following two
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parseInt(str, 2)` (see [Integers via parseInt()](ch11.html#parseInt "Integers
    via parseInt()")) parses a string `str` in binary notation (base 2). For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '`num.toString(2)` (see [Number.prototype.toString(radix?)](ch11.html#Number.prototype.toString
    "Number.prototype.toString(radix?)")) converts the number `num` to a string in
    binary notation. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Bitwise Not Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`~number` computes the ones’ complement of `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Binary Bitwise Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has three binary bitwise operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`number1 & number2` (bitwise And):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '`number1 | number2` (bitwise Or):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '`number1 ^ number2` (bitwise Xor; eXclusive Or):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways to intuitively understand binary bitwise operators:'
  prefs: []
  type: TYPE_NORMAL
- en: One boolean operation per bit
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following formulas, `n[i]` means bit `i` of number `n` interpreted as
    a boolean (0 is `false`, 1 is `true`). For example, `2[0]` is `false`; `2[1]`
    is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'And: `result[i] = number1[i] && number2[i]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or: `result[i] = number1[i] || number2[i]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xor: `result[i] = number1[i] ^^ number2[i]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The operator `^^` does not exist. If it did, it would work like this (the result
    is `true` if exactly one of the operands is `true`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Changing bits of `number1` via `number2`
  prefs: []
  type: TYPE_NORMAL
- en: 'And: Keeps only those bits of `number1` that are set in `number2`. This operation
    is also called *masking*, with `number2` being the *mask*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or: Sets all bits of `number1` that are set in `number2` and keeps all other
    bits unchanged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xor: Inverts all bits of `number1` that are set in `number2` and keeps all
    other bits unchanged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise Shift Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has three bitwise shift operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`number << digitCount` (left shift):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '`number >> digitCount` (signed right shift):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The 32-bit binary number is interpreted as signed (see the preceding section).
    When shifting right, the sign is preserved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: We have right-shifted –2\. The result, –1, is equivalent to a 32-bit integer
    whose digits are all 1 (the twos’ complement of 1). In other words, a signed right
    shift by one digit divides both negative and positive integers by two.
  prefs: []
  type: TYPE_NORMAL
- en: 'number >>> digitCount` (unsigned right shift):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this operator shifts in zeros from the left.
  prefs: []
  type: TYPE_NORMAL
- en: The Function Number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function `Number` can be invoked in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Number(value)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a normal function, it converts `value` to a primitive number (see [Converting
    to Number](ch11.html#tonumber "Converting to Number")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '`new Number(num)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a constructor, it creates a new instance of `Number` (see [Wrapper Objects
    for Primitives](ch08.html#wrapper_objects "Wrapper Objects for Primitives")),
    an object that wraps `num` (after converting it to a number). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: The former invocation is the common one.
  prefs: []
  type: TYPE_NORMAL
- en: Number Constructor Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The object `Number` has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Number.MAX_VALUE`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The largest positive number that can be represented. Internally, all digits
    of its fraction are ones and the exponent is maximal, at 1023\. If you try to
    increment the exponent by multiplying it by two, the result is the error value
    `Infinity` (see [Infinity](ch11.html#infinity "Infinity")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '`Number.MIN_VALUE`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The smallest representable positive number (greater than zero, a tiny fraction):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '`Number.NaN`'
  prefs: []
  type: TYPE_NORMAL
- en: The same value as the global `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Number.NEGATIVE_INFINITY`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same value as `-Infinity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '`Number.POSITIVE_INFINITY`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same value as `Infinity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Number Prototype Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All methods of primitive numbers are stored in `Number.prototype` (see [Primitives
    Borrow Their Methods from Wrappers](ch08.html#primitive_methods_via_wrappers "Primitives
    Borrow Their Methods from Wrappers")).
  prefs: []
  type: TYPE_NORMAL
- en: Number.prototype.toFixed(fractionDigits?)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Number.prototype.toFixed(fractionDigits?)` returns an exponent-free representation
    of the number, rounded to `fractionDigits` digits. If the parameter is omitted,
    the value 0 is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'If the number is greater than or equal to 10^(21), then this method works the
    same as `toString()`. You get a number in exponential notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Number.prototype.toPrecision(precision?)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Number.prototype.toPrecision(precision?)` prunes the mantissa to `precision`
    digits before using a conversion algorithm similar to `toString()`. If no precision
    is given, `toString()` is used directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: You need the exponential notation to display 1234 with a precision of three
    digits.
  prefs: []
  type: TYPE_NORMAL
- en: Number.prototype.toString(radix?)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For `Number.prototype.toString(radix?)`, the parameter `radix` indicates the
    base of the system in which the number is to be displayed. The most common radices
    are 10 (decimal), 2 (binary), and 16 (hexadecimal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'The radix must be at least 2 and at most 36\. Any radix greater than 10 leads
    to alphabetical characters being used as digits, which explains the maximum 36,
    as the Latin alphabet has 26 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'The global function `parseInt` (see [Integers via parseInt()](ch11.html#parseInt
    "Integers via parseInt()")) allows you to convert such notations back to a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: Decimal exponential notation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For the radix 10, `toString()` uses exponential notation (with a single digit
    before the decimal point) in two cases. First, if there are more than 21 digits
    before the decimal point of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, if a number starts with `0.` followed by more than five zeros and a
    non-zero digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: In all other cases, a fixed notation is used.
  prefs: []
  type: TYPE_NORMAL
- en: Number.prototype.toExponential(fractionDigits?)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Number.prototype.toExponential(fractionDigits?)` forces a number to be expressed
    in exponential notation. `fractionDigits` is a number between 0 and 20 that determines
    how many digits should be shown after the decimal point. If it is omitted, then
    as many significant digits are included as necessary to uniquely specify the number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we force more precision when `toString()` would also use exponential
    notation. Results are mixed, because we reach the limits of the precision that
    can be achieved when converting binary numbers to a decimal notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the magnitude of the number is not large enough for an exponent
    being displayed by `toString()`. However, `toExponential()` does display an exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we get exponential notation when the fraction is not small
    enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Functions for Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following functions operate on numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isFinite(number)`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether `number` is an actual number (neither `Infinity` nor `NaN`).
    For details, see [Checking for Infinity](ch11.html#isFinite "Checking for Infinity").
  prefs: []
  type: TYPE_NORMAL
- en: '`isNaN(number)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns `true` if `number` is `NaN`. For details, see [Pitfall: checking whether
    a value is NaN](ch11.html#isNaN "Pitfall: checking whether a value is NaN").'
  prefs: []
  type: TYPE_NORMAL
- en: '`parseFloat(str)`'
  prefs: []
  type: TYPE_NORMAL
- en: Turns `str` into a floating-point number. For details, see [parseFloat()](ch11.html#parseFloat
    "parseFloat()").
  prefs: []
  type: TYPE_NORMAL
- en: '`parseInt(str, radix?)`'
  prefs: []
  type: TYPE_NORMAL
- en: Parses `str` as an integer whose base is `radix` (2–36). For details, see [Integers
    via parseInt()](ch11.html#parseInt "Integers via parseInt()").
  prefs: []
  type: TYPE_NORMAL
- en: Sources for This Chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I referred to the following sources while writing this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“IEEE Standard 754 Floating Point Numbers”](http://bit.ly/1oOc43P) by Steve
    Hollasch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Data Types and Scaling (Fixed-Point Blockset)”](http://bit.ly/1oOc83t) in
    the MATLAB documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“IEEE floating point”](http://en.wikipedia.org/wiki/IEEE_754) on Wikipedia'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[12](#id995098)]) Source: Brendan Eich, [http://bit.ly/1lKzQeC](http://bit.ly/1lKzQeC).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[13](#id1001327)]) Béla Varga (@netzzwerg) pointed out that IEEE 754 specifies
    NaN as not equal to itself.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12. Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strings are immutable sequences of JavaScript characters. Each such character
    is a 16-bit UTF-16 code unit. That means that a single Unicode character is represented
    by either one or two JavaScript characters. You mainly need to worry about the
    two-character case whenever you are counting characters or splitting strings (see
    [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript")).
  prefs: []
  type: TYPE_NORMAL
- en: String Literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both single and double quotes can be used to delimit string literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, you are free to use either kind of quote. There are several considerations,
    though:'
  prefs: []
  type: TYPE_NORMAL
- en: The most common style in the community is to use double quotes for HTML and
    single quotes for JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, double quotes are used exclusively for strings in some languages
    (e.g., C and Java). Therefore, it may make sense to use them in a multilanguage
    code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For JSON (discussed in [Chapter 22](ch22.html "Chapter 22. JSON")), you must
    use double quotes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your code will look cleaner if you quote consistently. But sometimes, a different
    quote means that you don’t have to escape, which can justify your being less consistent
    (e.g., you may normally use single quotes, but temporarily switch to double quotes
    to write the last one of the preceding examples).
  prefs: []
  type: TYPE_NORMAL
- en: Escaping in String Literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most characters in string literals simply represent themselves. The backslash
    is used for *escaping* and enables several special features:'
  prefs: []
  type: TYPE_NORMAL
- en: Line continuations
  prefs: []
  type: TYPE_NORMAL
- en: 'You can spread a string over multiple lines by escaping the end of the line
    (the line-terminating character, the *line terminator*) with a backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative is to use the plus operator to concatenate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: Character escape sequences
  prefs: []
  type: TYPE_NORMAL
- en: 'These sequences start with a backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Control characters: `\b` is a backspace, `\f` is a form feed, `\n` is a line
    feed (newline), `\r` is a carriage return, `\t` is a horizontal tab, and `\v`
    is a vertical tab.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Escaped characters that represent themselves: `\''` is a single quote, `\"`
    is a double quote, and `\\` is a backslash. All characters except `b f n r t v
    x u` and decimal digits represent themselves, too. Here are two examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: NUL character (Unicode code point 0)
  prefs: []
  type: TYPE_NORMAL
- en: This character is represented by `\0`.
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal escape sequences
  prefs: []
  type: TYPE_NORMAL
- en: '`\xHH` (`HH` are two hexadecimal digits) specifies a character via an ASCII
    code. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: Unicode escape sequences
  prefs: []
  type: TYPE_NORMAL
- en: '`\uHHHH` (`HHHH` are four hexadecimal digits) specifies a UTF-16 code unit
    (see [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript")). Here are two
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: Character Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two operations that return the *n*th character of a string.^([[14](#ftn.id925641)])
    Note that JavaScript does not have a special data type for characters; these operations
    return strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Some older browsers don’t support the array-like access to characters via square
    brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Converting to String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Values are converted to a string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `''undefined''` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `''null''` |'
  prefs: []
  type: TYPE_TB
- en: '| A boolean | `false` → `''false''` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `true` → `''true''` |'
  prefs: []
  type: TYPE_TB
- en: '| A number | The number as a string (e.g., `3.141` → `''3.141''`) |'
  prefs: []
  type: TYPE_TB
- en: '| A string | Same as input (nothing to convert) |'
  prefs: []
  type: TYPE_TB
- en: '| An object | Call `ToPrimitive(value, String)` (see [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")) and convert the resulting primitive. |'
  prefs: []
  type: TYPE_TB
- en: Manually Converting to String
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The three most common ways to convert any value to a string are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `String(value)` | (Invoked as a function, not as a constructor) |'
  prefs: []
  type: TYPE_TB
- en: '| `''''+value` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `value.toString()` | (Does not work for `undefined` and `null`!) |'
  prefs: []
  type: TYPE_TB
- en: 'I prefer `String()`, because it is more descriptive. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that for displaying data, `JSON.stringify()` ([JSON.stringify(value, replacer?,
    space?)](ch22.html#JSON.stringify "JSON.stringify(value, replacer?, space?)"))
    often works better than the canonical conversion to string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, you have to be aware of the limitations of `JSON.stringify()`—it
    doesn’t always show everything. For example, it hides properties whose values
    it can’t handle (functions and more!). On the plus side, its output can be parsed
    by `eval()` and it can display deeply nested data as nicely formatted trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: conversion is not invertible'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given how often JavaScript automatically converts, it is a shame that the conversion
    isn’t always invertible, especially with regard to booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: For `undefined` and `null`, we face similar problems.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways of comparing strings. First, you can use the comparison
    operators: `<`, `>`, `===`, `<=`, `>=`. They have the following drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'They’re case-sensitive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'They don’t handle umlauts and accents well:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, you can use `String.prototype.localeCompare(other)`, which tends to
    fare better, but isn’t always supported (consult [Search and Compare](ch12.html#String.prototype.localeCompare
    "Search and Compare") for details). The following is an interaction in Firefox’s
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: A result less than zero means that the receiver is “smaller” than the argument.
    A result greater than zero means that the receiver is “larger” than the argument.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two main approaches for concatenating strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concatenation: The Plus (+) Operator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The operator `+` does string concatenation as soon as one of its operands is
    a string. If you want to collect string pieces in a variable, the compound assignment
    operator `+=` is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenation: Joining an Array of String Fragments'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It may seem that the previous approach creates a new string whenever a piece
    is added to `str`. Older JavaScript engines do it that way, which means that you
    can improve the performance of string concatenation by collecting all the pieces
    in an array first and joining them as a last step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: However, newer engines optimize string concatenation via `+` and use a similar
    method internally. Therefore, the plus operator is faster on those engines.
  prefs: []
  type: TYPE_NORMAL
- en: The Function String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function `String` can be invoked in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String(value)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a normal function, it converts `value` to a primitive string (see [Converting
    to String](ch12.html#tostring "Converting to String")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '`new String(str)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a constructor, it creates a new instance of `String` (see [Wrapper Objects
    for Primitives](ch08.html#wrapper_objects "Wrapper Objects for Primitives")),
    an object that wraps `str` (nonstrings are coerced to string). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: The former invocation is the common one.
  prefs: []
  type: TYPE_NORMAL
- en: String Constructor Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`String.fromCharCode(codeUnit1, codeUnit2, ...)` produces a string whose characters
    are the UTF-16 code units specified by the 16-bit unsigned integers `codeUnit1`,
    `codeUnit2`, and so on. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to turn an array of numbers into a string, you can do so via `apply()`
    (see [func.apply(thisValue, argArray)](ch15.html#functional_apply "func.apply(thisValue,
    argArray)")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: The inverse of `String.fromCharCode()` is `String.prototype.charCodeAt()`.
  prefs: []
  type: TYPE_NORMAL
- en: String Instance Property length
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `length` property indicates the number of JavaScript characters in the
    string and is immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: String Prototype Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All methods of primitive strings are stored in `String.prototype` (refer back
    to [Primitives Borrow Their Methods from Wrappers](ch08.html#primitive_methods_via_wrappers
    "Primitives Borrow Their Methods from Wrappers")). Next, I describe how they work
    for primitive strings, not for instances of `String`.
  prefs: []
  type: TYPE_NORMAL
- en: Extract Substrings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods extract substrings from the receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.charAt(pos)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a string with the character at position `pos`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two expressions return the same result, but some older JavaScript
    engines support only `charAt()` for accessing characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '`String.prototype.charCodeAt(pos)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the code (a 16-bit unsigned integer) of the JavaScript character (a
    UTF-16 code unit; see [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript"))
    at position `pos`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you create an array of character codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: The inverse of `charCodeAt()` is `String.fromCharCode()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.slice(start, end?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the substring starting at position `start` up to and excluding position
    `end`. Both of the two parameters can be negative, and then the `length` of the
    string is added to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '`String.prototype.substring(start, end?)`'
  prefs: []
  type: TYPE_NORMAL
- en: Should be avoided in favor of `slice()`, which is similar, but can handle negative
    positions and is implemented more consistently across browsers.
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.split(separator?, limit?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracts the substrings of the receiver that are delimited by `separator` and
    returns them in an array. The method has two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`separator`: Either a string or a regular expression. If missing, the complete
    string is returned, wrapped in an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit`: If given, the returned array contains at most `limit` elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is a group, then the matches are also returned as array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `''''` (empty string) as a separator to produce an array with the characters
    of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: Transform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the previous section was about extracting substrings, this section is
    about transforming a given string into a new one. These methods are typically
    used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the original string is discarded after it has been (nondestructively)
    transformed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.trim()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Removes all whitespace from the beginning and the end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '`String.prototype.concat(str1?, str2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the concatenation of the receiver and `str1`, `str2`, etc.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '`String.prototype.toLowerCase()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creates a new string with all of the original string’s characters converted
    to lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '`String.prototype.toLocaleLowerCase()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Works the same as `toLowerCase()`, but respects the rules of the current locale.
    According to the ECMAScript spec: “There will only be a difference in the few
    cases (such as Turkish) where the rules for that language conflict with the regular
    Unicode case mappings.”'
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.toUpperCase()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creates a new string with all of the original string’s characters converted
    to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '`String.prototype.toLocaleUpperCase()`'
  prefs: []
  type: TYPE_NORMAL
- en: Works the same as `toUpperCase()`, but respects the rules of the current locale.
  prefs: []
  type: TYPE_NORMAL
- en: Search and Compare
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods are used for searching and comparing strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.indexOf(searchString, position?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches for `searchString` starting at `position` (the default is 0). It returns
    the position where `searchString` has been found or –1 if it can’t be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that when it comes to finding text inside a string, a regular expression
    works just as well. For example, the following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '`String.prototype.lastIndexOf(searchString, position?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches for `searchString`, starting at `position` (the default is the end),
    backward. It returns the position where `searchString` has been found or –1 if
    it can’t be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '`String.prototype.localeCompare(other)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performs a locale-sensitive comparison of the string with `other`. It returns
    a number:'
  prefs: []
  type: TYPE_NORMAL
- en: < 0 if the string comes before `other`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: = 0 if the string is equivalent to `other`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 if the string comes after `other`
  prefs:
  - PREF_UL
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all JavaScript engines implement this method properly. Some just base it
    on the comparison operators. However, the ECMAScript Internationalization API
    (see [The ECMAScript Internationalization API](ch30.html#i18n_api "The ECMAScript
    Internationalization API")) does provide a Unicode-aware implementation. That
    is, if that API is available in an engine, `localeCompare()` will work.
  prefs: []
  type: TYPE_NORMAL
- en: If it is supported, `localeCompare()` is a better choice for comparing strings
    than the comparison operators. Consult [Comparing Strings](ch12.html#comparing_strings
    "Comparing Strings") for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Test, Match, and Replace with Regular Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods work with regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.search(regexp)` (more thoroughly explained in [String.prototype.search:
    At What Index Is There a Match?](ch19.html#String.prototype.search "String.prototype.search:
    At What Index Is There a Match?"))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the first index at which `regexp` matches in the receiver (or –1 if
    it doesn’t):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '`String.prototype.match(regexp)` (more thoroughly explained in [String.prototype.match:
    Capture Groups or Return All Matching Substrings](ch19.html#String.prototype.match
    "String.prototype.match: Capture Groups or Return All Matching Substrings"))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Matches the given regular expression against the receiver. It returns a match
    object for the first match if the flag `/g` of `regexp` is not set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: 'If the flag `/g` is set, then all complete matches (group 0) are returned in
    an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '`String.prototype.replace(search, replacement)` (more thoroughly explained
    in [String.prototype.replace: Search and Replace](ch19.html#String.prototype.replace
    "String.prototype.replace: Search and Replace"))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches for `search` and replaces it with `replacement`. `search` can be a
    string or a regular expression, and `replacement` can be a string or a function.
    Unless you use a regular expression as `search` whose flag `/g` is set, only the
    first occurrence will be replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: 'A dollar sign (`$`) in a replacement string allows you to refer to the complete
    match or a captured group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also compute a replacement via a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[14](#id925641)]) Strictly speaking, a JavaScript string consists of a sequence
    of UTF-16 code units. That is, JavaScript characters are Unicode code units (see
    [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript")).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13. Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter covers JavaScript’s statements: variable declarations, loops,
    conditionals, and others.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and Assigning Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`var` is used to *declare* a variable, which creates the variable and enables
    you to work with it. The equals operator (`=`) is used to assign a value to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '`var` also lets you combine the preceding two statements into a single one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can also combine multiple `var` statements into one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 'Read more about how variables work in [Chapter 16](ch16.html "Chapter 16. Variables:
    Scopes, Environments, and Closures").'
  prefs: []
  type: TYPE_NORMAL
- en: The Bodies of Loops and Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compound statements such as loops and conditionals have one or more “bodies”
    embedded—for example, the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'For the body `«statement»`, you have a choice. You can either use a single
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 'or you can use a block (which counts as a single statement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: You need to use a block if you want the body to comprise multiple statements.
    Unless the complete compound statement can be written in a single line, I recommend
    using a block.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explores JavaScript’s loop statements.
  prefs: []
  type: TYPE_NORMAL
- en: Mechanisms to Be Used with Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following mechanisms can be used with all loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '`break ⟦«label»⟧`'
  prefs: []
  type: TYPE_NORMAL
- en: Exit from a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '`continue ⟦«label»⟧`'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the current loop iteration, and immediately continue with the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Labels
  prefs: []
  type: TYPE_NORMAL
- en: 'A label is an identifier followed by a colon. In front of a loop, a label allows
    you to break or continue that loop even from a loop nested inside of it. In front
    of a block, you can break out of that block. In both cases, the name of the label
    becomes an argument of `break` or `continue`. Here’s an example of breaking out
    of a block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: while
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'executes `statement` as long as `condition` holds. If `condition` is always
    `true`, you get an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we remove all elements of an array and log them to
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: do-while
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `do-while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'executes `statement` at least once and then as long as `condition` holds. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: for
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '`init` is executed once before the loop, which continues as long as `condition`
    is `true`. You can use `var` in `init` to declare variables, but the scope of
    those variables is always the complete surrounding function. `post_iteration`
    is executed after each iteration of the loop. Taking all of this into consideration,
    the preceding loop is equivalent to the following `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example is the traditional way of iterating over arrays (other
    possibilities are described in [Best Practices: Iterating over Arrays](ch18.html#array_iteration
    "Best Practices: Iterating over Arrays")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: 'A `for` loop becomes infinite if you omit all parts of the head:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: for-in
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `for-in` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'iterates over all property keys of `object`, including inherited ones. However,
    properties that are marked as not enumerable are ignored (see [Property Attributes
    and Property Descriptors](ch17_split_000.html#property_attributes "Property Attributes
    and Property Descriptors")). The following rules apply to `for-in` loops:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `var` to declare variables, but the scope of those variables is
    always the complete surrounding function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties can be deleted during iteration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Best practice: don’t use for-in for arrays'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Don’t use `for-in` to iterate over arrays. First, it iterates over indices,
    not over values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, it also iterates over all (nonindex) property keys. The following example
    illustrates what happens when you add a property `foo` to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, you are better off with a normal `for` loop or the array method `forEach()`
    (see [Best Practices: Iterating over Arrays](ch18.html#array_iteration "Best Practices:
    Iterating over Arrays")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Best practice: be careful with for-in for objects'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `for-in` loop iterates over *all* (enumerable) properties, including inherited
    ones. That may not be what you want. Let’s use the following constructor to illustrate
    the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: 'Instances of `Person` inherit the property `describe` from `Person.prototype`,
    which is seen by `for-in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, the best way to use `for-in` is to skip inherited properties via
    `hasOwnProperty()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one last caveat: `person` may have a property `hasOwnProperty`, which
    would prevent the check from working. To be safe, you have to refer to the generic
    method (see [Generic Methods: Borrowing Methods from Prototypes](ch17_split_001.html#generic_method
    "Generic Methods: Borrowing Methods from Prototypes")) `Object.prototype.hasOwnProperty`
    directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other, more comfortable, means for iterating over property keys,
    which are described in [Best Practices: Iterating over Own Properties](ch17_split_000.html#object_iteration
    "Best Practices: Iterating over Own Properties").'
  prefs: []
  type: TYPE_NORMAL
- en: for each-in
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This loop exists only on Firefox. Don’t use it.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section covers JavaScript’s conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: if-then-else
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In an `if-then-else` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '`then_branch` and `else_branch` can be either single statements or blocks of
    statements (see [The Bodies of Loops and Conditionals](ch13.html#loops_conditionals_bodies
    "The Bodies of Loops and Conditionals")).'
  prefs: []
  type: TYPE_NORMAL
- en: Chaining if statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can chain several `if` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the preceding example, all the `else` branches are single statements
    (`if` statements). Programming languages that only allow blocks for `else` branches
    need some kind of `else-if` branch for chaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: dangling else'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `else` branch of the following example is called *dangling*, because it
    is not clear to which of the two `if` statements it belongs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a simple rule: use braces. The preceding snippet is equivalent to the
    following code (where it is obvious who the `else` belongs to):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: switch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: evaluates `expression` and then jumps to the `case` clause whose label matches
    the result. If no label matches, `switch` jumps to the `default` clause if it
    exists or does nothing otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The “operand” after `case` can be any expression; it is compared via `===` with
    the parameter of `switch`.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t finish a clause with a terminating statement, execution continues
    into the next clause. The most frequently used terminating statement is `break`.
    But `return` and `throw` also work, even though they normally leave more than
    just the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates that you don’t need to `break` if you use
    `throw` or `return`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, there is no `default` clause. Therefore, nothing happens if
    `fruit` matches none of the `case` labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, there are multiple `case` labels in a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: 'This example demonstrates that the value after `case` can be an arbitrary expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `switch` statement looks for a match for its parameter `true`
    by going through the `case` clauses. If one of the `case` expressions evaluates
    to `true`, the corresponding `case` body is executed. Therefore, the preceding
    code is equivalent to the following `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: You normally should prefer the latter solution; it is more self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: The with Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explains how the `with` statement works in JavaScript and why its
    use is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax and Semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax of the `with` statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns the properties of `object` into local variables for `statement`. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: 'Its intended use is to avoid redundancy when accessing an object several times.
    The following is an example of code with redundancies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '`with` makes this shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: The with Statement Is Deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The use of the `with` statement is generally discouraged (the next section
    explains why). For example, it is forbidden in strict mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: Techniques for avoiding the with statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Avoid code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, use a temporary variable with a short name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t want to expose the temporary variable `b` to the current scope,
    you can use an IIFE (see [Introducing a New Scope via an IIFE](ch16.html#iife
    "Introducing a New Scope via an IIFE")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: 'You also have the option of making the object that you want to access a parameter
    of the IIFE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: The Rationale for the Deprecation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand why `with` is deprecated, look at the following example and notice
    how the function’s argument completely changes how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'If `opts` has a property `msg`, then the statement in line (1) doesn’t access
    the parameter `msg` anymore. It accesses the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three problems that the `with` statement causes:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance suffers
  prefs: []
  type: TYPE_NORMAL
- en: Variable lookup becomes slower, because an object is temporarily inserted into
    the scope chain.
  prefs: []
  type: TYPE_NORMAL
- en: Code becomes less predictable
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot determine what an identifier refers to by looking at its syntactic
    surroundings (its lexical context). According to [Brendan Eich](http://bit.ly/1jCrTKj),
    that was the actual reason why `with` was deprecated, not performance considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`with` violates lexical scope, making program analysis (e.g. for security)
    hard to infeasible.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Minifiers (described in [Chapter 32](ch32.html "Chapter 32. More Tools")) can’t
    shorten variable names
  prefs: []
  type: TYPE_NORMAL
- en: Inside a `with` statement, you can’t statically determine whether a name refers
    to a variable or a property. Only variables can be renamed by minifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of `with` making code brittle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: You can prevent the function call in line (3) from working, even if you don’t
    have access to the array `myData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How? By adding a property `values` to `Array.prototype`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: Now the code in line (2) calls `someArray.values.someMethod()` instead of `values.someMethod()`.
    The reason is that, inside the `with` statement, `values` now refers to `someArray.values`
    and not the local variable from line (1) anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not just a thought experiment: the array method `values()` was added
    to Firefox and broke the TYPO3 content management system. [Brandon Benvie figured
    out what went wrong](http://mzl.la/1jCrXti).'
  prefs: []
  type: TYPE_NORMAL
- en: The debugger Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax for the `debugger` statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: If a debugger is active, this statement functions as a breakpoint; if not, it
    has no observable effect.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14. Exception Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter describes how JavaScript’s exception handling works. It begins
    with a general explanation of what exception handling is.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Exception Handling?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In exception handling, you often group statements that are tightly coupled.
    If, while you are executing those statements, one of them causes an error, then
    it makes no sense to continue with the remaining statements. Instead, you try
    to recover from the error as gracefully as you can. This is loosely reminiscent
    of transactions (but without the atomicity).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at code without exception handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: 'What is the best way to react to an error in `openFile()` at (2)? Clearly,
    the statement (1) should not be executed anymore. But we wouldn’t want to abort
    `extractAllEntries()`, either. Instead, it is enough to skip the current file
    and continue with the next one. To do that, we add exception handling to the previous
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two aspects to exception handling:'
  prefs: []
  type: TYPE_NORMAL
- en: If there is a problem that can’t be handled meaningfully where it occurs, throw
    an exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find a place where errors can be handled: catch exceptions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At (1), the following constructs are active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: The `throw` statement at (1) walks up that tree and leaves all constructs until
    it encounters an active `try` statement. It then invokes that statement’s `catch`
    block and passes it the exception value.
  prefs: []
  type: TYPE_NORMAL
- en: Exception Handling in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exception handling in JavaScript works like in most programming languages:
    a `try` statement groups statements and lets you intercept exceptions in those
    statements.'
  prefs: []
  type: TYPE_NORMAL
- en: throw
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax of `throw` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: 'Any JavaScript value can be thrown. For simplicity’s sake, many JavaScript
    programs just throw strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t do this. JavaScript has special constructors for exception objects (see
    [Error Constructors](ch14.html#error_constructors "Error Constructors")). Use
    those or subclass them (see [Chapter 28](ch28.html "Chapter 28. Subclassing Built-ins")).
    Their advantage is that JavaScript automatically adds a stack trace (on most engines)
    and that they have room for additional context-specific properties. The simplest
    solution is to use the built-in constructor `Error()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: try-catch-finally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax of `try-catch-finally` looks as follows. `try` is mandatory, and
    at least one of `catch` and `finally` must be there, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`catch` catches any exception that is thrown in `try_statements`, whether directly
    or in functions they invoke. Tip: If you want to distinguish between different
    kinds of exceptions, you can use the `constructor` property to switch over the
    exceptions’ constructors (see [Use cases for the constructor property](ch17_split_001.html#switch_constructor
    "Use cases for the constructor property")).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finally` is always executed, no matter what happens in `try_statements` (or
    in functions they invoke). Use it for clean-up operations that should always be
    performed, no matter what happens in `try_statements`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: If one of the `try_statements` is a `return`, then the `try` block is executed
    afterward (immediately before leaving the function or method; see the examples
    that follow).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any value can be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '`finally` is always executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '`finally` is executed *after* a `return` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value is queued before executing `finally`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'By the time statement (1) is executed, the value of `count` has already been
    queued for returning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: Error Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ECMAScript standardizes the following error constructors. The descriptions
    are quoted from the ECMAScript 5 specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Error` is a generic constructor for errors. All other error constructors mentioned
    here are subconstructors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EvalError` “is not currently used within this specification. This object remains
    for compatibility with previous editions of this specification.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RangeError` “indicates a numeric value has exceeded the allowable range.”
    For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '`ReferenceError` “indicates that an invalid reference value has been detected.”
    Usually, this is an unknown variable. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '`SyntaxError` “indicates that a parsing error has occurred”—for example, while
    parsing code via `eval()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '`TypeError` “indicates the actual type of an operand is different than the
    expected type.” For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '`URIError` “indicates that one of the global URI handling functions was used
    in a way that is incompatible with its definition.” For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the properties of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`message`'
  prefs: []
  type: TYPE_NORMAL
- en: The error message.
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the error.
  prefs: []
  type: TYPE_NORMAL
- en: '`stack`'
  prefs: []
  type: TYPE_NORMAL
- en: A stack trace. This is nonstandard, but is available on many platforms—for example,
    Chrome, Node.js, and Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Stack Traces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The usual sources of errors are either external (wrong input, missing file,
    etc.) or internal (a bug in the program). Especially in the latter case, you will
    get unexpected exceptions and need to debug. Often you don’t have a debugger running.
    For “manual” debugging, two pieces of information are helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data: What values do variables have?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execution: In what line did the exception happen, and what function calls were
    active?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can put some of the first item (data) into either the message or the properties
    of an exception object. The second item (execution) is supported on many JavaScript
    engines via *stack traces*, snapshots of the call stack when the exception objects
    were created. The following example prints a stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: Implementing Your Own Error Constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want stack traces, you need the services of the built-in error constructors.
    You can use an existing constructor and attach your own data to it. Or you can
    create a subconstructor, whose instances can be distinguished from those of other
    error constructors via `instanceof`. Alas, doing so (for built-in constructors)
    is complicated; see [Chapter 28](ch28.html "Chapter 28. Subclassing Built-ins")
    to learn how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15. Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions are values that can be called. One way of defining a function is
    called a *function declaration*. For example, the following code defines the function
    `id` that has a single parameter, `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: 'The `return` statement returns a value from `id`. You can call a function by
    mentioning its name, followed by arguments in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t return anything from a function, `undefined` is returned (implicitly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: This section showed just one way of defining and one way of calling a function.
    Others are described later.
  prefs: []
  type: TYPE_NORMAL
- en: The Three Roles of Functions in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have defined a function as just shown, it can play several roles:'
  prefs: []
  type: TYPE_NORMAL
- en: Nonmethod function (“normal function”)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can call a function directly. Then it works as a normal function. Here’s
    an example invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: By convention, the names of normal functions start with lowercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor
  prefs: []
  type: TYPE_NORMAL
- en: 'You can invoke a function via the `new` operator. Then it becomes a constructor,
    a factory for objects. Here’s an example invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: By convention, the names of constructors start with uppercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: Method
  prefs: []
  type: TYPE_NORMAL
- en: 'You can store a function in a property of an object, which turns it into a
    *method* that you can invoke via that object. Here’s an example invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: By convention, the names of methods start with lowercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: Nonmethod functions are explained in this chapter; constructors and methods
    are explained in [Chapter 17](ch17_split_000.html "Chapter 17. Objects and Inheritance").
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminology: “Parameter” Versus “Argument”'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The terms *parameter* and *argument* are often used interchangeably, because
    the context usually makes it clear what the intended meaning is. The following
    is a rule of thumb for distinguishing them.
  prefs: []
  type: TYPE_NORMAL
- en: '*Parameters* are used to define a function. They are also called formal parameters
    and formal arguments. In the following example, `param1` and `param2` are parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '*Arguments* are used to invoke a function. They are also called actual parameters
    and actual arguments. In the following example, `3` and `7` are arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: Defining Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section describes three ways to create a function:'
  prefs: []
  type: TYPE_NORMAL
- en: Via a function expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via a function declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via the constructor `Function()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All functions are objects, instances of `Function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, functions get their methods from `Function.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: Function Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function expression produces a value—a function object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code assigned the result of a function expression to the variable
    `add` and called it via that variable. The value produced by a function expression
    can be assigned to a variable (as shown in the last example), passed as an argument
    to another function, and more. Because normal function expressions don’t have
    a name, they are also called *anonymous function expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: Named function expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can give a function expression a name. *Named function expressions* allow
    a function expression to refer to itself, which is useful for self-recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The name of a named function expression is only accessible inside the function
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: Function Declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding looks like a function expression, but it is a statement (see
    [Expressions Versus Statements](ch07.html#expr_vs_stmt "Expressions Versus Statements")).
    It is roughly equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: In other words, a function declaration declares a new variable, creates a function
    object, and assigns it to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: The Function Constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The constructor `Function()` evaluates JavaScript code stored in strings. For
    example, the following code is equivalent to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: However, this way of defining a function is slow and keeps code in strings (inaccessible
    to tools). Therefore, it is much better to use a function expression or a function
    declaration if possible. [Evaluating Code Using new Function()](ch23.html#function_constructor
    "Evaluating Code Using new Function()") explains `Function()` in more detail;
    it works similarly to `eval()`.
  prefs: []
  type: TYPE_NORMAL
- en: Hoisting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Hoisting* means “moving to the beginning of a scope.” Function declarations
    are hoisted completely, variable declarations only partially.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function declarations are completely hoisted. That allows you to call a function
    before it has been declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason the preceding code works is that JavaScript engines move the declaration
    of `foo` to the beginning of the scope. They execute the code as if it looked
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '`var` declarations are hoisted, too, but only the declarations, not assignments
    made with them. Therefore, using a `var` declaration and a function expression
    similarly to the previous example results in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the variable declaration is hoisted. The engine executes the preceding
    code as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: The Name of a Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most JavaScript engines support the nonstandard property `name` for function
    objects. Function declarations have it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of anonymous function expressions is the empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: 'Named function expressions, however, do have a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: The name of a function is useful for debugging. Some people always give their
    function expressions names for that reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which Is Better: A Function Declaration or a Function Expression?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Should you prefer a function declaration like the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: Or the equivalent combination of a `var` declaration plus a function expression?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: 'They are basically the same, but function declarations have two advantages
    over function expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: They are hoisted (see [Hoisting](ch15.html#function_hoisting "Hoisting")), so
    you can call them before they appear in the source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have a name (see [The Name of a Function](ch15.html#function_names "The
    Name of a Function")). However, JavaScript engines are getting better at inferring
    the names of anonymous function expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More Control over Function Calls: call(), apply(), and bind()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`call()`, `apply()`, and `bind()` are methods that all functions have (remember
    that functions are objects and therefore have methods). They can supply a value
    for `this` when invoking a method and thus are mainly interesting in an object-oriented
    context (see [Calling Functions While Setting this: call(), apply(), and bind()](ch17_split_000.html#oop_call_apply_bind
    "Calling Functions While Setting this: call(), apply(), and bind()")). This section
    explains two use cases for nonmethods.'
  prefs: []
  type: TYPE_NORMAL
- en: func.apply(thisValue, argArray)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method uses the elements of `argArray` as arguments while calling the
    function `func`; that is, the following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '`thisValue` is the value that `this` has while executing `func`. It is not
    needed in a non-object-oriented setting and is thus `null` here.'
  prefs: []
  type: TYPE_NORMAL
- en: '`apply()` is useful whenever a function accepts multiple arguments in an array-like
    manner, but not an array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to `apply()`, we can use `Math.max()` (see [Other Functions](ch21.html#Math_max
    "Other Functions")) to determine the maximum element of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: func.bind(thisValue, arg1, ..., argN)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This performs *partial function application*—a new function is created that
    calls `func` with `this` set to `thisValue` and the following arguments: first
    `arg1` until `argN`, and then the actual arguments of the new function. `thisValue`
    is not needed in the following non-object-oriented setting, which is why it is
    `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use `bind()` to create a new function `plus1()` that is like `add()`,
    but only requires the parameter `y`, because `x` is always 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, we have created a new function that is equivalent to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: Handling Missing or Extra Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript does not enforce a function’s arity: you can call it with any number
    of actual parameters, independent of what formal parameters have been defined.
    Hence, the number of actual parameters and formal parameters can differ in two
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: More actual parameters than formal parameters
  prefs: []
  type: TYPE_NORMAL
- en: The extra parameters are ignored but can be retrieved via the special array-like
    variable `arguments` (discussed momentarily).
  prefs: []
  type: TYPE_NORMAL
- en: Fewer actual parameters than formal parameters
  prefs: []
  type: TYPE_NORMAL
- en: The missing formal parameters all have the value `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Parameters by Index: The Special Variable arguments'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The special variable `arguments` exists only inside functions (including methods).
    It is an array-like object that holds all of the actual parameters of the current
    function call. The following code uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '`arguments` has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: It is array-like, but not an array. On one hand, it has a property `length`,
    and individual parameters can be read and written by index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, `arguments` is not an array, it is only similar to one. It
    has none of the array methods (`slice()`, `forEach()`, etc.). Thankfully, you
    can borrow array methods or convert `arguments` to an array, as explained in [Array-Like
    Objects and Generic Methods](ch17_split_001.html#array-like_objects "Array-Like
    Objects and Generic Methods").
  prefs: []
  type: TYPE_NORMAL
- en: 'It is an object, so all object methods and operators are available. For example,
    you can use the `in` operator ([Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")) to check whether `arguments` “has” a
    given index:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `hasOwnProperty()` ([Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")) in a similar manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: Deprecated features of arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strict mode drops several of the more unusual features of `arguments`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.callee` refers to the current function. It is mainly used to do
    self-recursion in anonymous functions, and is not allowed in strict mode. As a
    workaround, use a named function expression (see [Named function expressions](ch15.html#named_function_expression
    "Named function expressions")), which can refer to itself via its name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In nonstrict mode, `arguments` stays up-to-date if you change a parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'But this kind of updating is not done in strict mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: Strict mode forbids assigning to the variable `arguments` (e.g., via `arguments++`).
    Assigning to elements and properties is still allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mandatory Parameters, Enforcing a Minimum Arity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three ways to find out whether a parameter is missing. First, you
    can check if it is `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, you can interpret the parameter as a boolean. Then `undefined` is considered
    `false`. However, there is a caveat: several other values are also considered
    `false` (see [Truthy and Falsy Values](ch10.html#truthy_falsy "Truthy and Falsy
    Values")), so the check cannot distinguish between, say, `0` and a missing parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, you can also check the length of `arguments` to enforce a minimum arity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'The last approach differs from the other ones:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two approaches don’t distinguish between `foo()` and `foo(undefined)`.
    In both cases, an exception is thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third approach throws an exception for `foo()` and sets `optional` to `undefined`
    for `foo(undefined)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a parameter is optional, it means that you give it a default value if it
    is missing. Similarly to mandatory parameters, there are four alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, check for `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, interpret `optional` as a boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, you can use the Or operator `||` (see [Logical Or (||)](ch10.html#logical_or
    "Logical Or (||)")), which returns the left operand, if it isn’t falsy. Otherwise,
    it returns the right operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: 'Fourth, you can check a function’s arity via `arguments.length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the last approach differs from the other ones:'
  prefs: []
  type: TYPE_NORMAL
- en: The first three approaches don’t distinguish between `bar(1, 2)` and `bar(1,
    2, undefined)`. In both cases, `optional` is `'default value'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth approach sets `optional` to `'default value'` for `bar(1, 2)` and
    leaves it `undefined` (i.e., unchanged) for `bar(1, 2, undefined)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another possibility is to hand in optional parameters as *named parameters*,
    as properties of an object literal (see [Named Parameters](ch15.html#named_parameters
    "Named Parameters")).
  prefs: []
  type: TYPE_NORMAL
- en: Simulating Pass-by-Reference Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript, you cannot pass parameters by reference; that is, if you pass
    a variable to a function, its value is copied and handed to the function (pass
    by value). Therefore, the function can’t change the variable. If you need to do
    so, you must wrap the value of the variable in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstates a function that increments a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: 'Pitfall: Unexpected Optional Parameters'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you hand a function `c` as a parameter to another function `f`, then you
    have to be aware of two signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: The signature that `f` expects its parameter to have. `f` might provide several
    parameters, and `c` can decide how many (if any) of them to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual signature of `c`. For example, it might support optional parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the two diverge, then you can get unexpected results: `c` could have optional
    parameters that you don’t know about and that would interpret additional arguments
    provided by `f` incorrectly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the array method `map()` (see [Transformation Methods](ch18.html#Array.prototype.map
    "Transformation Methods")) whose parameter is normally a function with a single
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: 'One function that you could pass as an argument is `parseInt()` (see [Integers
    via parseInt()](ch11.html#parseInt "Integers via parseInt()")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: 'You may (incorrectly) think that `map()` provides only a single argument and
    that `parseInt()` accepts only a single argument. Then you would be surprised
    by the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '`map()` expects a function with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: 'But `parseInt()` has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, `map()` not only fills in `string` (via `element`), but also `radix`
    (via `index`). That means that the values of the preceding array are produced
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: 'To sum up, be careful with functions and methods whose signature you are not
    sure about. If you use them, it often makes sense to be explicit about what parameters
    are received and what parameters are passed on. That is achieved via a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: Named Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When calling a function (or method) in a programming language, you must map
    the actual parameters (specified by the caller) to the formal parameters (of a
    function definition). There are two common ways to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Positional parameters* are mapped by position. The first actual parameter
    is mapped to the first formal parameter, the second actual to the second formal,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Named parameters* use *names* (labels) to perform the mapping. Names are associated
    with formal parameters in a function definition and label actual parameters in
    a function call. It does not matter in which order named parameters appear, as
    long as they are correctly labeled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Named parameters have two main benefits: they provide descriptions for arguments
    in function calls and they work well for optional parameters. I’ll first explain
    the benefits and then show you how to simulate named parameters in JavaScript
    via object literals.'
  prefs: []
  type: TYPE_NORMAL
- en: Named Parameters as Descriptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As soon as a function has more than one parameter, you might get confused about
    what each parameter is used for. For example, let’s say you have a function, `selectEntries()`,
    that returns entries from a database. Given the following function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: 'what do these two numbers mean? Python supports named parameters, and they
    make it easy to figure out what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: Optional Named Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Optional positional parameters work well only if they are omitted at the end.
    Anywhere else, you have to insert placeholders such as `null` so that the remaining
    parameters have correct positions. With optional named parameters, that is not
    an issue. You can easily omit any of them. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: Simulating Named Parameters in JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript does not have native support for named parameters like Python and
    many other languages. But there is a reasonably elegant simulation: name parameters
    via an object literal, passed as a single actual parameter. When you use this
    technique, an invocation of `selectEntries()` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: 'The function receives an object with the properties `start`, `end`, and `step`.
    You can omit any of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: 'You could implement `selectEntries()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also combine positional parameters with named parameters. It is customary
    for the latter to come last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript, the pattern for named parameters shown here is sometimes called
    *options* or *option object* (e.g., by the jQuery documentation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 16. Variables: Scopes, Environments, and Closures'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter first explains how to use variables and then goes into detail on
    how they work (environments, closures, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, you declare a variable via a `var` statement before you use
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also combine a declaration with an assignment, to immediately initialize
    a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of an uninitialized variable is `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: 'Background: Static Versus Dynamic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two angles from which you can examine the workings of a program:'
  prefs: []
  type: TYPE_NORMAL
- en: Statically (or lexically)
  prefs: []
  type: TYPE_NORMAL
- en: 'You examine the program as it exists in source code, without running it. Given
    the following code, we can make the static assertion that function `g` is nested
    inside function `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: The adjective *lexical* is used synonymously with *static*, because both pertain
    to the *lexicon* (the words, the source) of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically
  prefs: []
  type: TYPE_NORMAL
- en: 'You examine what happens while executing the program (“at runtime”). Given
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: when we call `f()`, it calls `g()`. During runtime, `g` being called by `f`
    represents a dynamic relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Background: The Scope of a Variable'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the rest of this chapter, you should understand the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: The scope of a variable
  prefs: []
  type: TYPE_NORMAL
- en: 'The scope of a variable are the locations where it is accessible. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: Here, the *direct scope* of `x` is the function `foo()`.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical scoping
  prefs: []
  type: TYPE_NORMAL
- en: Variables in JavaScript are *lexically scoped*, so the static structure of a
    program determines the scope of a variable (it is not influenced by, say, where
    a function is called from).
  prefs: []
  type: TYPE_NORMAL
- en: Nested scopes
  prefs: []
  type: TYPE_NORMAL
- en: 'If scopes are nested within the direct scope of a variable, then the variable
    is accessible in all of those scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: The direct scope of `arg` is `foo()`, but it is also accessible in the nested
    scope `bar()`. With regard to nesting, `foo()` is the *outer scope* and `bar()`
    is the *inner scope*.
  prefs: []
  type: TYPE_NORMAL
- en: Shadowing
  prefs: []
  type: TYPE_NORMAL
- en: 'If a scope declares a variable that has the same name as one in a surrounding
    scope, access to the outer variable is blocked in the inner scope and all scopes
    nested inside it. Changes to the inner variable do not affect the outer variable,
    which is accessible again after the inner scope is left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: Inside the function `f()`, the global `x` is shadowed by a local `x`.
  prefs: []
  type: TYPE_NORMAL
- en: Variables Are Function-Scoped
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most mainstream languages are *block-scoped*: variables “live inside” the innermost
    surrounding code block. Here is an example from Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the variable `foo` is accessible only inside the block
    that directly surrounds it. If we try to access it after the end of the block,
    we get a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, JavaScript’s variables are *function-scoped*: only functions introduce
    new scopes; blocks are ignored when it comes to scoping. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: Put another way, `foo` is accessible within all of `main()`, not just inside
    the block.
  prefs: []
  type: TYPE_NORMAL
- en: Variable Declarations Are Hoisted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript *hoists* all variable declarations, it moves them to the beginning
    of their direct scopes. This makes it clear what happens if a variable is accessed
    before it has been declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the variable `bar` already exists in the first line of `f()`,
    but it does not have a value yet; that is, the declaration has been hoisted, but
    not the assignment. JavaScript executes `f()` as if its code were:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: 'If you declare a variable that has already been declared, nothing happens (the
    variable’s value is unchanged):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: Each function declaration is also hoisted, but in a slightly different manner.
    The complete function is hoisted, not just the creation of the variable in which
    it is stored (see [Hoisting](ch15.html#function_hoisting "Hoisting")).
  prefs: []
  type: TYPE_NORMAL
- en: 'Best practice: be aware of hoisting, but don’t be scared of it'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some JavaScript style guides recommend that you only put variable declarations
    at the beginning of a function, in order to avoid being tricked by hoisting. If
    your function is relatively small (which it should be anyway), then you can afford
    to relax that rule a bit and declare variables close to where they are used (e.g.,
    inside a `for` loop). That better encapsulates pieces of code. Obviously, you
    should be aware that that encapsulation is only conceptual, because function-wide
    hoisting still happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: Assigning to an Undeclared Variable Makes It Global'
  prefs: []
  type: TYPE_NORMAL
- en: 'In sloppy mode, assigning to a variable that hasn’t been declared via `var`
    creates a global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: 'Thankfully, strict mode throws an exception when that happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: Introducing a New Scope via an IIFE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You typically introduce a new scope to restrict the lifetime of a variable.
    One example where you may want to do so is the “then” part of an `if` statement:
    it is executed only if the condition holds; and if it exclusively uses helper
    variables, we don’t want them to “leak out” into the surrounding scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to introduce a new scope for the `then` block, you can define a
    function and immediately invoke it. This is a workaround, a simulation of block
    scoping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a common pattern in JavaScript. Ben Alman suggested it be called [*immediately
    invoked function expression*](http://bit.ly/i-ife) (IIFE, pronounced “iffy”).
    In general, an IIFE looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some things to note about an IIFE:'
  prefs: []
  type: TYPE_NORMAL
- en: It is immediately invoked
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses following the closing brace of the function immediately invoke
    it. That means its body is executed right away.
  prefs: []
  type: TYPE_NORMAL
- en: It must be an expression
  prefs: []
  type: TYPE_NORMAL
- en: If a statement starts with the keyword `function`, the parser expects it to
    be a function declaration (see [Expressions Versus Statements](ch07.html#expr_vs_stmt
    "Expressions Versus Statements")). But a function declaration cannot be immediately
    invoked. Thus, we tell the parser that the keyword `function` is the beginning
    of a function expression by starting the statement with an open parenthesis. Inside
    parentheses, there can only be expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The trailing semicolon is required
  prefs: []
  type: TYPE_NORMAL
- en: 'If you forget it between two IIFEs, then your code won’t work anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is interpreted as a function call—the first IIFE (including
    the parentheses) is the function to be called, and the second IIFE is the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An IIFE incurs costs (both cognitively and performance-wise), so it rarely makes
    sense to use it inside an `if` statement. The preceding example was chosen for
    didactic reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'IIFE Variation: Prefix Operators'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also enforce the expression context via prefix operators. For example,
    you can do so via the logical Not operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: 'or via the `void` operator (see [The void Operator](ch09.html#void_operator
    "The void Operator")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of using prefix operators is that forgetting the terminating semicolon
    does not cause trouble.
  prefs: []
  type: TYPE_NORMAL
- en: 'IIFE Variation: Already Inside Expression Context'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that enforcing the expression context for an IIFE is not necessary, if
    you are already in the expression context. Then you need no parentheses or prefix
    operators. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, there are two different variables that have the name
    `File`. On one hand, there is the function that is only directly accessible inside
    the IIFE. On the other hand, there is the variable that is declared in the first
    line. It is assigned the value that is returned in the IIFE.
  prefs: []
  type: TYPE_NORMAL
- en: 'IIFE Variation: An IIFE with Parameters'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use parameters to define variables for the inside of the IIFE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: 'This is similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: IIFE Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An IIFE enables you to attach private data to a function. Then you don’t have
    to declare a global variable and can tightly package the function with its state.
    You avoid polluting the global namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: 'Other applications of IIFEs are mentioned elsewhere in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoiding global variables; hiding variables from global scope (see [Best Practice:
    Avoid Creating Global Variables](ch16.html#avoid_global_variables "Best Practice:
    Avoid Creating Global Variables"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating fresh environments; avoiding sharing (see [Pitfall: Inadvertently
    Sharing an Environment](ch16.html#inadvertently_sharing_environments "Pitfall:
    Inadvertently Sharing an Environment"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping global data private to all of a constructor (see [Keeping global data
    private to all of a constructor](ch17_split_001.html#private_data_complete_constructor
    "Keeping global data private to all of a constructor"))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching global data to a singleton object (see [Attaching private global data
    to a singleton object](ch17_split_001.html#private_data_singleton "Attaching private
    global data to a singleton object"))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching global data to a method (see [Attaching global data to a method](ch17_split_001.html#private_data_method
    "Attaching global data to a method"))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scope containing all of a program is called *global scope* or *program
    scope*. This is the scope you are in when entering a script (be it a `<script>`
    tag in a web page or be it a *.js* file). Inside the global scope, you can create
    a nested scope by defining a function. Inside such a function, you can again nest
    scopes. Each scope has access to its own variables and to the variables in the
    scopes that surround it. As the global scope surrounds all other scopes, its variables
    can be accessed everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: 'Best Practice: Avoid Creating Global Variables'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Global variables have two disadvantages. First, pieces of software that rely
    on global variables are subject to side effects; they are less robust, behave
    less predictably, and are less reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, all of the JavaScript on a web page shares the same global variables:
    your code, built-ins, analytics code, social media buttons, and so on. That means
    that name clashes can become a problem. That is why it is best to hide as many
    variables from the global scope as possible. For example, don’t do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `tmp` becomes global, because its declaration is executed in global
    scope. But it is only used locally. Hence, we can use an IIFE (see [Introducing
    a New Scope via an IIFE](ch16.html#iife "Introducing a New Scope via an IIFE"))
    to hide it inside a nested scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: Module Systems Lead to Fewer Globals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thankfully, module systems (see [Module Systems](ch31.html#module_systems "Module
    Systems")) mostly eliminate the problem of global variables, because modules don’t
    interface via the global scope and because each module has its own scope for module-global
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: The Global Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ECMAScript specification uses the internal data structure *environment*
    to store variables (see [Environments: Managing Variables](ch16.html#environments
    "Environments: Managing Variables")). The language has the somewhat unusual feature
    of making the environment for global variables accessible via an object, the so-called
    *global object*. The global object can be used to create, read, and change global
    variables. In global scope, `this` points to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the global object has prototypes. If you want to list all of its
    (own and inherited) properties, you need a function such as `getAllPropertyNames()`
    from [Listing All Property Keys](ch17_split_000.html#getAllPropertyNames "Listing
    All Property Keys"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript creator Brendan Eich considers the global object one of his [“biggest
    regrets”](http://mzl.la/1oOeCif). It affects performance negatively, makes the
    implementation of variable scoping more complicated, and leads to less modular
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Platform Considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Browsers and Node.js have global variables for referring to the global object.
    Unfortunately, they are different:'
  prefs: []
  type: TYPE_NORMAL
- en: Browsers include `window`, which is standardized as part of the Document Object
    Model (DOM), not as part of ECMAScript 5\. There is one global object per frame
    or window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js contains `global`, which is a Node.js-specific variable. Each module
    has its own scope in which `this` points to an object with that scopes variables.
    Accordingly, `this` and `global` are different inside modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On both platforms, `this` refers to the global object, but only when you are
    in global scope. That is almost never the case on Node.js. If you want to access
    the global object in a cross-platform manner, you can use a pattern such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: From now on, I use `window` to refer to the global object, but in cross-platform
    code, you should use the preceding pattern and `glob` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases for window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section describes use cases for accessing global variables via `window`.
    But the general rule is: avoid doing that as much as you can.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use case: marking global variables'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The prefix `window` is a visual clue that code is referring to a global variable
    and not to a local one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this makes your code brittle. It ceases to work as soon as you move
    `foo` from global scope to another surrounding scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, it is better to refer to `foo` as a variable, not as a property of `window`.
    If you want to make it obvious that `foo` is a global or global-like variable,
    you can add a name prefix such as `g_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: 'Use case: built-ins'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I prefer not to refer to built-in global variables via `window`. They are well-known
    names, so you gain little from an indicator that they are global. And the prefixed
    `window` adds clutter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: 'Use case: style checkers'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you are working with a style checking tool such as JSLint and JSHint, using
    `window` means that you don’t get an error when referring to a global variable
    that is not declared in the current file. However, both tools provide ways to
    tell them about such variables and prevent such errors (search for “global variable”
    in their documentation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Use case: checking whether a global variable exists'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s not a frequent use case, but shims and polyfills especially (see [Shims
    Versus Polyfills](ch30.html#shim_vs_polyfill "Shims Versus Polyfills")) need to
    check whether a global variable `someVariable` exists. In that case, `window`
    helps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a safe way of performing this check. The following statement throws
    an exception if `someVariable` has not been declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two additional ways in which you can check via `window`; they are
    roughly equivalent, but a little more explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: 'The general way of checking whether a variable exists (and has a value) is
    via `typeof` (see [typeof: Categorizing Primitives](ch09.html#typeof "typeof:
    Categorizing Primitives")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: 'Use case: creating things in global scope'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`window` lets you add things to the global scope (even if you are in a nested
    scope), and it lets you do so conditionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: It is normally best to add things to the global scope via `var`, while you are
    in the global scope. However, `window` provides a clean way of making additions
    conditionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Environments: Managing Variables'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Environments are an advanced topic. They are a detail of JavaScript’s internals.
    Read this section if you want to get a deeper understanding of how variables work.
  prefs: []
  type: TYPE_NORMAL
- en: Variables come into existence when program execution enters their scope. Then
    they need storage space. The data structure that provides that storage space is
    called an *environment* in JavaScript. It maps variable names to values. Its structure
    is very similar to that of JavaScript objects. Environments sometimes live on
    after you leave their scope. Therefore, they are stored on a heap, not on a stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are passed on in two ways. There are two dimensions to them, if you
    will:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic dimension: invoking functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time a function is invoked, it needs new storage for its parameters and
    variables. After it is finished, that storage can usually be reclaimed. As an
    example, take the following implementation of the faculty function. It calls itself
    recursively several times and each time, it needs fresh storage for `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: 'Lexical (static) dimension: staying connected to your surrounding scopes'
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter how often a function is called, it always needs access to both its
    own (fresh) local variables and the variables of the surrounding scopes. For example,
    the following function, `doNTimes`, has a helper function, `doNTimesRec`, inside
    it. When `doNTimesRec` calls itself several times, a new environment is created
    each time. However, `doNTimesRec` also stays connected to the single environment
    of `doNTimes` during those calls (similar to all functions sharing a single global
    environment). `doNTimesRec` needs that connection to access `action` in line (1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: 'These two dimensions are handled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic dimension: stack of execution contexts'
  prefs: []
  type: TYPE_NORMAL
- en: Each time a function is invoked, a new *environment* is created to map identifiers
    (of parameters and variables) to values. To handle recursion, *execution contexts*—references
    to environments—are managed in a stack. That stack mirrors the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lexical dimension: chain of environments'
  prefs: []
  type: TYPE_NORMAL
- en: To support this dimension, a function records the scope it was created in via
    the internal property `[[Scope]]`. When a function is called, an environment is
    created for the new scope that is entered. That environment has a field called
    `outer` that points to the outer scope’s environment and is set up via `[[Scope]]`.
    Therefore, there is always a chain of environments, starting with the currently
    active environment, continuing with its outer environment, and so on. Every chain
    ends with the global environment (the scope of all initially invoked functions).
    The field `outer` of the global environment is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve an identifier, the complete environment chain is traversed, starting
    with the active environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '![The dynamic dimension of variables is handled via a stack of execution contexts,
    and the static dimension is handled by chaining environments. The active execution
    contexts, environments, and functions are highlighted. Step 1 shows those data
    structures before the function call myFunction(abc). Step 2 shows them during
    the function call.](images/spjs_2001.png)Figure 16-1. The dynamic dimension of
    variables is handled via a stack of execution contexts, and the static dimension
    is handled by chaining environments. The active execution contexts, environments,
    and functions are highlighted. Step 1 shows those data structures before the function
    call myFunction(*abc*). Step 2 shows them during the function call.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-1](ch16.html#figenv_intro "Figure 16-1. The dynamic dimension of
    variables is handled via a stack of execution contexts, and the static dimension
    is handled by chaining environments. The active execution contexts, environments,
    and functions are highlighted. Step 1 shows those data structures before the function
    call myFunction(abc). Step 2 shows them during the function call.") illustrates
    what happens when the preceding code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`myFunction` and `myFloat` have been stored in the global environment (#0).
    Note that the `function` object referred to by `myFunction` points to its scope
    (the global scope) via the internal property `[[Scope]]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the execution of `myFunction('abc')`, a new environment (#1) is created
    that holds the parameter and the local variable. It refers to its outer environment
    via `outer` (which is initialized from `myFunction.[[Scope]]`). Thanks to the
    outer environment, `myFunction` can access `myFloat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Closures: Functions Stay Connected to Their Birth Scopes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a function leaves the scope in which it was created, it stays connected
    to the variables of that scope (and of the surrounding scopes). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: 'The function returned by `createInc()` does not lose its connection to `startValue`—the
    variable provides the function with state that persists across function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: A *closure* is a function plus the connection to the scope in which the function
    was created. The name stems from the fact that a closure “closes over” the free
    variables of a function. A variable is free if it is not declared within the function—that
    is, if it comes “from outside.”
  prefs: []
  type: TYPE_NORMAL
- en: Handling Closures via Environments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is an advanced section that goes deeper into how closures work. You should
    be familiar with environments (review [Environments: Managing Variables](ch16.html#environments
    "Environments: Managing Variables")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A closure is an example of an environment surviving after execution has left
    its scope. To illustrate how closures work, let’s examine the previous interaction
    with `createInc()` and split it up into four steps (during each step, the active
    execution context and its environment are highlighted; if a function is active,
    it is highlighted, too):'
  prefs: []
  type: TYPE_NORMAL
- en: This step takes place before the interaction, and after the evaluation of the
    function declaration of `createInc`. An entry for `createInc` has been added to
    the global environment (#0) and points to a function object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image with no caption](images/spjs_20in01.png)'
  prefs: []
  type: TYPE_IMG
- en: This step occurs during the execution of the function call `createInc(5)`. A
    fresh environment (#1) for `createInc` is created and pushed onto the stack. Its
    outer environment is the global environment (the same as `createInc.[[Scope]]`).
    The environment holds the parameter `startValue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image with no caption](images/spjs_20in02.png)'
  prefs: []
  type: TYPE_IMG
- en: This step happens after the assignment to `inc`. After we returned from `createInc`,
    the execution context pointing to its environment was removed from the stack,
    but the environment still exists on the heap, because `inc.[[Scope]]` refers to
    it. `inc` is a closure (function plus birth environment).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image with no caption](images/spjs_20in03.png)'
  prefs: []
  type: TYPE_IMG
- en: This step takes place during the execution of `inc(1)`. A new environment (#1)
    has been created and an execution context pointing to it has been pushed onto
    the stack. Its outer environment is the `[[Scope]]` of `inc`. The outer environment
    gives `inc` access to `startValue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image with no caption](images/spjs_20in04.png)'
  prefs: []
  type: TYPE_IMG
- en: This step happens after the execution of `inc(1)`. No reference (execution context,
    `outer` field, or `[[Scope]]`) points to `inc`’s environment, anymore. It is therefore
    not needed and can be removed from the heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image with no caption](images/spjs_20in03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Pitfall: Inadvertently Sharing an Environment'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes the behavior of functions you create is influenced by a variable
    in the current scope. In JavaScript, that can be problematic, because each function
    should work with the value that the variable had when the function was created.
    However, due to functions being closures, the function will always work with the
    *current* value of the variable. In `for` loops, that can prevent things from
    working properly. An example will make things clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '`f` returns an array with three functions in it. All of these functions can
    still access the environment of `f` and thus `i`. In fact, they share the same
    environment. Alas, after the loop is finished, `i` has the value 3 in that environment.
    Therefore, all functions return `3`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not what we want. To fix things, we need to make a snapshot of the
    index `i` before creating a function that uses it. In other words, we want to
    package each function with the value that `i` had at the time of the function’s
    creation. We therefore take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new environment for each function in the returned array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store (a copy of) the current value of *i* in that environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Only functions create environments, so we use an IIFE (see [Introducing a New
    Scope via an IIFE](ch16.html#iife "Introducing a New Scope via an IIFE")) to accomplish
    step 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: Note that the example has real-world relevance, because similar scenarios arise
    when you add event handlers to DOM elements via loops.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17. Objects and Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several layers to object-oriented programming (OOP) in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Layer 1: Object-orientation with single objects (covered in [Layer 1: Single
    Objects](ch17_split_000.html#single_objects "Layer 1: Single Objects"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Layer 2: Prototype chains of objects (described in [Layer 2: The Prototype
    Relationship Between Objects](ch17_split_000.html#prototype_relationship "Layer
    2: The Prototype Relationship Between Objects"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Layer 3: Constructors as factories for instances, similar to classes in other
    languages (discussed in [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Layer 4: Subclassing, creating new constructors by inheriting from existing
    ones (covered in [Layer 4: Inheritance Between Constructors](ch17_split_001.html#constructor_inheritance
    "Layer 4: Inheritance Between Constructors"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each new layer only depends on prior ones, enabling you to learn JavaScript
    OOP incrementally. Layers 1 and 2 form a simple core that you can refer back to
    whenever you are getting confused by the more complicated layers 3 and 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Layer 1: Single Objects'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Roughly, all objects in JavaScript are maps (dictionaries) from strings to values.
    A (key, value) entry in an object is called a *property*. The key of a property
    is always a text string. The value of a property can be any JavaScript value,
    including a function. *Methods* are properties whose values are functions.
  prefs: []
  type: TYPE_NORMAL
- en: Kinds of Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three kinds of properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Properties (or named data properties)
  prefs: []
  type: TYPE_NORMAL
- en: Normal properties in an object—that is, mappings from string keys to values.
    Named data properties include methods. This is by far the most common kind of
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Accessors (or named accessor properties)
  prefs: []
  type: TYPE_NORMAL
- en: Special methods whose invocations look like reading or writing properties. Normal
    properties are storage locations for property values; accessors allow you to compute
    the values of properties. They are virtual properties, if you will. See [Accessors
    (Getters and Setters)](ch17_split_000.html#getters_setters "Accessors (Getters
    and Setters)") for details.
  prefs: []
  type: TYPE_NORMAL
- en: Internal properties
  prefs: []
  type: TYPE_NORMAL
- en: Exist only in the ECMAScript language specification. They are not directly accessible
    from JavaScript, but there might be indirect ways of accessing them. The specification
    writes the keys of internal properties in brackets. For example, `[[Prototype]]`
    holds the prototype of an object and is readable via `Object.getPrototypeOf()`.
  prefs: []
  type: TYPE_NORMAL
- en: Object Literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript’s *object literals* allow you to directly create *plain objects*
    (direct instances of `Object`). The following code uses an object literal to assign
    an object to the variable `jane`. The object has the two properties: `name` and
    `describe`. `describe` is a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: Use `this` in methods to refer to the current object (also called the *receiver*
    of a method invocation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ECMAScript 5 allows a trailing comma (after the last property) in an object
    literal. Alas, not all older browsers support it. A trailing comma is useful,
    because you can rearrange properties without having to worry which property is
    last.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may get the impression that objects are *only* maps from strings to values.
    But they are more than that: they are real general-purpose objects. For example,
    you can use inheritance between objects (see [Layer 2: The Prototype Relationship
    Between Objects](ch17_split_000.html#prototype_relationship "Layer 2: The Prototype
    Relationship Between Objects")), and you can protect objects from being changed.
    The ability to directly create objects is one of JavaScript’s standout features:
    you can start with concrete objects (no classes needed!) and introduce abstractions
    later. For example, *constructors*, which are factories for objects (as discussed
    in [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances")), are roughly similar to classes
    in other languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dot Operator (.): Accessing Properties via Fixed Keys'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dot operator provides a compact syntax for accessing properties. The property
    keys must be identifiers (consult [Legal Identifiers](ch07.html#identifiers "Legal
    Identifiers")). If you want to read or write properties with arbitrary names,
    you need to use the bracket operator (see [Bracket Operator ([]): Accessing Properties
    via Computed Keys](ch17_split_000.html#bracket_operator "Bracket Operator ([]):
    Accessing Properties via Computed Keys")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples in this section work with the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: Getting properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The dot operator lets you “get” a property (read its value). Here are some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting a property that doesn’t exist returns `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: Calling methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The dot operator is also used to call methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: Setting properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use the assignment operator (`=`) to set the value of a property referred
    to via the dot notation. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: If a property doesn’t exist yet, setting it automatically creates it. If a property
    already exists, setting it changes its value.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `delete` operator lets you completely remove a property (the whole key-value
    pair) from an object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: 'If you merely set a property to `undefined`, the property still exists and
    the object still contains its key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: 'If you delete the property, its key is gone, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '`delete` affects only the direct (“own,” noninherited) properties of an object.
    Its prototypes are not touched (see [Deleting an inherited property](ch17_split_000.html#delete_inherited_property
    "Deleting an inherited property")).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the `delete` operator sparingly. Most modern JavaScript engines optimize
    the performance of instances created by constructors if their “shape” doesn’t
    change (roughly: no properties are removed or added). Deleting a property prevents
    that optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: The return value of delete
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`delete` returns `false` if the property is an own property, but cannot be
    deleted. It returns `true` in all other cases. Following are some examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a preparation, we create one property that can be deleted and another one
    that can’t be deleted ([Getting and Defining Properties via Descriptors](ch17_split_000.html#functions_for_property_descriptors
    "Getting and Defining Properties via Descriptors") explains `Object.defineProperty()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '`delete` returns `false` for own properties that can’t be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '`delete` returns `true` in all other cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '`delete` returns `true` even if it doesn’t change anything (inherited properties
    are never removed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: Unusual Property Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While you can’t use reserved words (such as `var` and `function`) as variable
    names, you can use them as property keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: 'Numbers can be used as property keys in object literals, but they are interpreted
    as strings. The dot operator can only access properties whose keys are identifiers.
    Therefore, you need the bracket operator (shown in the following example) to access
    properties whose keys are numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: 'Object literals also allow you to use arbitrary strings (that are neither identifiers
    nor numbers) as property keys, but you must quote them. Again, you need the bracket
    operator to access the property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: 'Bracket Operator ([]): Accessing Properties via Computed Keys'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the dot operator works with fixed property keys, the bracket operator
    allows you to refer to a property via an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Getting properties via the bracket operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The bracket operator lets you compute the key of a property, via an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: 'That also allows you to access properties whose keys are not identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the bracket operator coerces its interior to string. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: Calling methods via the bracket operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Calling methods works as you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: Setting properties via the bracket operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Setting properties works analogously to the dot operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: Deleting properties via the bracket operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Deleting properties also works similarly to the dot operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: Converting Any Value to an Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s not a frequent use case, but sometimes you need to convert an arbitrary
    value to an object. `Object()`, used as a function (not as a constructor), provides
    that service. It produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (Called with no parameters) | `{}` |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `{}` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `{}` |'
  prefs: []
  type: TYPE_TB
- en: '| A boolean `bool` | `new Boolean(bool)` |'
  prefs: []
  type: TYPE_TB
- en: '| A number `num` | `new Number(num)` |'
  prefs: []
  type: TYPE_TB
- en: '| A string `str` | `new String(str)` |'
  prefs: []
  type: TYPE_TB
- en: '| An object `obj` | `obj` (unchanged, nothing to convert) |'
  prefs: []
  type: TYPE_TB
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: 'Tthe following function checks whether `value` is an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the preceding function creates an object if `value` isn’t an object.
    You can implement the same function without doing that, via `typeof` (see [Pitfall:
    typeof null](ch09.html#isobject_typeof "Pitfall: typeof null")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also invoke `Object` as a constructor, which produces the same results
    as calling it as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Avoid the constructor; an empty object literal is almost always a better choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: this as an Implicit Parameter of Functions and Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you call a function, `this` is always an (implicit) parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: Normal functions in sloppy mode
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though normal functions have no use for `this`, it still exists as a special
    variable whose value is always the global object (`window` in browsers; see [The
    Global Object](ch16.html#global_object "The Global Object")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: Normal functions in strict mode
  prefs: []
  type: TYPE_NORMAL
- en: '`this` is always `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: Methods
  prefs: []
  type: TYPE_NORMAL
- en: '`this` refers to the object on which the method has been invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: In the case of methods, the value of `this` is called the *receiver* of the
    method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling Functions While Setting this: call(), apply(), and bind()'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember that functions are also objects. Thus, each function has methods of
    its own. Three of them are introduced in this section and help with calling functions.
    These three methods are used in the following sections to work around some of
    the pitfalls of calling functions. The upcoming examples all refer to the following
    object, `jane`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: Function.prototype.call(thisValue, arg1?, arg2?, ...)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first parameter is the value that `this` will have inside the invoked function;
    the remaining parameters are handed over as arguments to the invoked function.
    The following three invocations are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: For the second invocation, you need to repeat `jane`, because `call()` doesn’t
    know how you got the function that it is invoked on.
  prefs: []
  type: TYPE_NORMAL
- en: Function.prototype.apply(thisValue, argArray)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first parameter is the value that `this` will have inside the invoked function;
    the second parameter is an array that provides the arguments for the invocation.
    The following three invocations are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: For the second invocation, you need to repeat `jane`, because `apply()` doesn’t
    know how you got the function that it is invoked on.
  prefs: []
  type: TYPE_NORMAL
- en: '[apply() for Constructors](ch17_split_000.html#apply_constructors "apply()
    for Constructors") explains how to use `apply()` with constructors.'
  prefs: []
  type: TYPE_NORMAL
- en: Function.prototype.bind(thisValue, arg1?, ..., argN?)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method performs *partial function application*—meaning it creates a new
    function that calls the receiver of `bind()` in the following manner: the value
    of `this` is `thisValue` and the arguments start with `arg1` until `argN`, followed
    by the arguments of the new function. In other words, the new function appends
    its arguments to `arg1, ..., argN` when it calls the original function. Let’s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: 'The array method `slice` is used to convert `arguments` to an array, which
    is necessary for logging it (this operation is explained in [Array-Like Objects
    and Generic Methods](ch17_split_001.html#array-like_objects "Array-Like Objects
    and Generic Methods")). `bound` is a new function. Here’s the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: 'The following three invocations of `sayHelloTo` are all equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: apply() for Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s pretend that JavaScript has a triple dot operator (`...`) that turns
    arrays into actual parameters. Such an operator would allow you to use `Math.max()`
    (see [Other Functions](ch21.html#Math_max "Other Functions")) with arrays. In
    that case, the following two expressions would be equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: 'For functions, you can achieve the effect of the triple dot operator via `apply()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: 'The triple dot operator would also make sense for constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: Alas, here `apply()` does not work, because it helps only with function or method
    calls, not with constructor invocations.
  prefs: []
  type: TYPE_NORMAL
- en: Manually simulating an apply() for constructors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can simulate `apply()` in two steps.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass the arguments to `Date` via a method call (they are not in an array—yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses `bind()` to create a constructor without parameters
    and invokes it via `new`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `apply()` to hand an array to `bind()`. Because `bind()` is a method call,
    we can use `apply()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding array still has one element too many, `null`. We can use `concat()`
    to prepend it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: A library method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The preceding manual workaround is inspired by a [library method](http://mzl.la/1oOf7sK)
    published by Mozilla. The following is a slightly edited version of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the method in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: An alternative approach
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An alternative to the previous approach is to create an uninitialized instance
    via `Object.create()` and then call the constructor (as a function) via `apply()`.
    That means that you are effectively reimplementing the `new` operator (some checks
    are omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code does not work for most built-in constructors, which always
    produce new instances when called as functions. In other words, the step in line
    (1) doesn’t set up `inst` as desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: Losing this When Extracting a Method'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you extract a method from an object, it becomes a true function again. Its
    connection with the object is severed, and it usually doesn’t work properly anymore.
    Take, for example, the following object, `counter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting `inc` and calling it (as a function!) fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the explanation: we have called the value of `counter.inc` as a function.
    Hence, `this` is the global object and we have performed `window.count++`. `window.count`
    does not exist and is `undefined`. Applying the `++` operator to it sets it to
    `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: How to get a warning
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If method `inc()` is in strict mode, you get a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that when we call the strict mode function `func2`, `this` is
    `undefined`, resulting in an error.
  prefs: []
  type: TYPE_NORMAL
- en: How to properly extract a method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Thanks to `bind()`, we can make sure that `inc` doesn’t lose the connection
    with `counter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: Callbacks and extracted methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In JavaScript, there are many functions and methods that accept callbacks.
    Examples in browsers are `setTimeout()` and event handling. If we pass in `counter.inc`
    as a callback, it is also invoked as a function, resulting in the same problem
    just described. To illustrate this phenomenon, let’s use a simple callback-invoking
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `counter.count` via `callIt` triggers a warning (due to strict mode):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we fix things via `bind()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each call to `bind()` creates a new function. That has consequences when you’re
    registering and unregistering callbacks (e.g., for event handling). You need to
    store the value you registered somewhere and use it for unregistering, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: Functions Inside Methods Shadow this'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You often nest function definitions in JavaScript, because functions can be
    parameters (e.g., callbacks) and because they can be created in place, via function
    expressions. This poses a problem when a method contains a normal function and
    you want to access the former’s `this` inside the latter, because the method’s
    `this` is shadowed by the normal function’s `this` (which doesn’t even have any
    use for its own `this`). In the following example, the function at (1) tries to
    access the method’s `this` at (2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, this fails, because the function at (1) has its own `this`, which
    is `undefined` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: There are three ways to work around this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Workaround 1: that = this'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We assign `this` to a variable that won’t be shadowed inside the nested function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: 'Workaround 2: bind()'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use `bind()` to give the callback a fixed value for `this`—namely, the
    method’s `this` (line (1)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: 'Workaround 3: a thisValue for forEach()'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A workaround that is specific to `forEach()` (see [Examination Methods](ch18.html#Array_prototype_forEach
    "Examination Methods")) is to provide a second parameter after the callback that
    becomes the `this` of the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: 'Layer 2: The Prototype Relationship Between Objects'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prototype relationship between two objects is about inheritance: every
    object can have another object as its prototype. Then the former object inherits
    all of its prototype’s properties. An object specifies its prototype via the internal
    property `[[Prototype]]`. Every object has this property, but it can be `null`.
    The chain of objects connected by the `[[Prototype]]` property is called the *prototype
    chain* ([Figure 17-1](ch17_split_000.html#figoo_proto_chain "Figure 17-1. A prototype
    chain.")).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A prototype chain.](images/spjs_2101.png)Figure 17-1. A prototype chain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how prototype-based (or *prototypal*) inheritance works, let’s look
    at an example (with invented syntax for specifying the `[[Prototype]]` property):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: The object `obj` inherits the property `describe` from `proto`. It also has
    a so-called *own* (noninherited, direct) property, `name`.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`obj` inherits the property `describe`; you can access it as if the object
    itself had that property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever you access a property via `obj`, JavaScript starts the search for
    it in that object and continues with its prototype, the prototype’s prototype,
    and so on. That’s why we can access `proto.describe` via `obj.describe`. The prototype
    chain behaves as if it were a single object. That illusion is maintained when
    you call a method: the value of `this` is always the object where the search for
    the method began, not where the method was found. That allows the method to access
    all of the properties of the prototype chain. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: Inside `describe()`, `this` is `obj`, which allows the method to access `obj.name`.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a prototype chain, a property in an object *overrides* a property with the
    same key in a “later” object: the former property is found first. It hides the
    latter property, which can’t be accessed anymore. As an example, let’s override
    the method `proto.describe()` in `obj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: That is similar to how overriding of methods works in class-based languages.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing Data Between Objects via a Prototype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prototypes are great for sharing data between objects: several objects get
    the same prototype, which holds all shared properties. Let’s look at an example.
    The objects `jane` and `tarzan` both contain the same method, `describe()`. That
    is something that we would like to avoid by using sharing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: Both objects are persons. Their `name` property is different, but we could have
    them share the method `describe`. We do that by creating a common prototype called
    `PersonProto` and putting `describe` into it ([Figure 17-2](ch17_split_000.html#figoo_person_shared
    "Figure 17-2. The objects jane and tarzan share the prototype PersonProto and
    thus the property describe.")).
  prefs: []
  type: TYPE_NORMAL
- en: '![The objects jane and tarzan share the prototype PersonProto and thus the
    property describe.](images/spjs_2102.png)Figure 17-2. The objects jane and tarzan
    share the prototype PersonProto and thus the property describe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates objects `jane` and `tarzan` that share the prototype
    `PersonProto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a common pattern: the data resides in the first object of a prototype
    chain, while methods reside in later objects. JavaScript’s flavor of prototypal
    inheritance is designed to support this pattern: setting a property affects only
    the first object in a prototype chain, whereas getting a property considers the
    complete chain (see [Setting and Deleting Affects Only Own Properties](ch17_split_000.html#setting_properties_proto_chain
    "Setting and Deleting Affects Only Own Properties")).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting and Setting the Prototype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have pretended that you can access the internal property `[[Prototype]]`
    from JavaScript. But the language does not let you do that. Instead, there are
    functions for reading the prototype and for creating a new object with a given
    prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new object with a given prototype
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: 'creates an object whose prototype is `proto`. Optionally, properties can be
    added via descriptors (which are explained in [Property Descriptors](ch17_split_000.html#property_descriptors
    "Property Descriptors")). In the following example, object `jane` gets the prototype
    `PersonProto` and a mutable property `name` whose value is `''Jane''` (as specified
    via a property descriptor):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: 'But you frequently just create an empty object and then manually add properties,
    because descriptors are verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: Reading the prototype of an object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: 'returns the prototype of `obj`. Continuing the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: Checking whether one object a prototype of another one
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: 'checks whether the receiver of the method is a (direct or indirect) prototype
    of `obj`. In other words: are the receiver and `obj` in the same prototype chain,
    and does `obj` come before the receiver? For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: Finding the object where a property is defined
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following function iterates over the property chain of an object `obj`.
    It returns the first object that has an own property with the key `propKey`, or
    `null` if there is no such object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we called the method `Object.prototype.hasOwnProperty`
    generically (see [Generic Methods: Borrowing Methods from Prototypes](ch17_split_001.html#generic_method
    "Generic Methods: Borrowing Methods from Prototypes")).'
  prefs: []
  type: TYPE_NORMAL
- en: The Special Property __proto__
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some JavaScript engines have a special property for getting and setting the
    prototype of an object: `__proto__`. It brings direct access to `[[Prototype]]`
    to the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several things you need to know about `__proto__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__proto__` is pronounced “dunder proto,” an abbreviation of “double underscore
    proto.” That pronunciation has been borrowed from the Python programming language
    (as [suggested by Ned Batchelder](http://bit.ly/1fwlzN8) in 2006). Special variables
    with double underscores are quite frequent in Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__proto__` is not part of the ECMAScript 5 standard. Therefore, you must not
    use it if you want your code to conform to that standard and run reliably across
    current JavaScript engines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, more and more engines are adding support for `__proto__` and it will
    be part of ECMAScript 6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following expression checks whether an engine supports `__proto__` as a
    special property:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: Setting and Deleting Affects Only Own Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only getting a property considers the complete prototype chain of an object.
    Setting and deleting ignores inheritance and affects only own properties.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a property
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Setting a property creates an own property, even if there is an inherited property
    with that key. For example, given the following source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '`obj` inherits `foo` from `proto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting `foo` has the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we have created an own property and not changed `proto.foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: The rationale is that prototype properties are meant to be shared by several
    objects. This approach allows us to nondestructively “change” them—only the current
    object is affected.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an inherited property
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can only delete own properties. Let’s again set up an object, `obj`, with
    a prototype, `proto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting the inherited property `foo` has no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: For more information on the `delete` operator, consult [Deleting properties](ch17_split_000.html#operator_delete
    "Deleting properties").
  prefs: []
  type: TYPE_NORMAL
- en: Changing properties anywhere in the prototype chain
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you want to change an inherited property, you first have to find the object
    that owns it (see [Finding the object where a property is defined](ch17_split_000.html#code_getDefiningObject
    "Finding the object where a property is defined")) and then perform the change
    on that object. For example, let’s delete the property `foo` from the previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: Iteration and Detection of Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Operations for iterating over and detecting properties are influenced by:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance (own properties versus inherited properties)
  prefs: []
  type: TYPE_NORMAL
- en: An own property of an object is stored directly in that object. An inherited
    property is stored in one of its prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerability (enumerable properties versus nonenumerable properties)
  prefs: []
  type: TYPE_NORMAL
- en: 'The enumerability of a property is an *attribute* (see [Property Attributes
    and Property Descriptors](ch17_split_000.html#property_attributes "Property Attributes
    and Property Descriptors")), a flag that can be `true` or `false`. Enumerability
    rarely matters and can normally be ignored (see [Enumerability: Best Practices](ch17_split_001.html#enumerability_best_practices
    "Enumerability: Best Practices")).'
  prefs: []
  type: TYPE_NORMAL
- en: You can list own property keys, list all enumerable property keys, and check
    whether a property exists. The following subsections show how.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Own Property Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can either list all own property keys, or only enumerable ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.getOwnPropertyNames(obj)` returns the keys of all own properties of
    `obj`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.keys(obj)` returns the keys of all enumerable own properties of `obj`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that properties are normally enumerable (see [Enumerability: Best Practices](ch17_split_001.html#enumerability_best_practices
    "Enumerability: Best Practices")), so you can use `Object.keys()`, especially
    for objects that you have created.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing All Property Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to list all properties (both own and inherited ones) of an object,
    then you have two options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1 is to use the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: to iterate over the keys of all enumerable properties of `object`. See [for-in](ch13.html#for-in
    "for-in") for a more thorough description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 2 is to implement a function yourself that iterates over all properties
    (not just enumerable ones). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: Checking Whether a Property Exists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can check whether an object has a property, or whether a property exists
    directly inside an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`propKey in obj`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if `obj` has a property whose key is `propKey`. Inherited properties
    are included in this test.
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.prototype.hasOwnProperty(propKey)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if the receiver (`this`) has an own (noninherited) property whose
    key is `propKey`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Avoid invoking `hasOwnProperty()` directly on an object, as it may be overridden
    (e.g., by an own property whose key is `hasOwnProperty`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, it is better to call it generically (see [Generic Methods: Borrowing
    Methods from Prototypes](ch17_split_001.html#generic_method "Generic Methods:
    Borrowing Methods from Prototypes")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following examples are based on these definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.defineProperties()` is explained in [Getting and Defining Properties
    via Descriptors](ch17_split_000.html#functions_for_property_descriptors "Getting
    and Defining Properties via Descriptors"), but it should be fairly obvious how
    it works: `proto` has the own properties `protoEnumTrue` and `protoEnumFalse`
    and `obj` has the own properties `objEnumTrue` and `objEnumFalse` (and inherits
    all of `proto`’s properties).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that objects (such as `proto` in the preceding example) normally have
    at least the prototype `Object.prototype` (where standard methods such as `toString()`
    and `hasOwnProperty()` are defined):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: The effects of enumerability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Among property-related operations, enumberability only influences the `for-in`
    loop and `Object.keys()` (it also influences `JSON.stringify()`, see [JSON.stringify(value,
    replacer?, space?)](ch22.html#JSON.stringify "JSON.stringify(value, replacer?,
    space?)")).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for-in` loop iterates over the keys of all enumerable properties, including
    inherited ones (note that none of the nonenumerable properties of `Object.prototype`
    show up):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.keys()` returns the keys of all own (noninherited) enumerable properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the keys of all own properties, you need to use `Object.getOwnPropertyNames()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: The effects of inheritance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Only the `for-in` loop (see the previous example) and the `in` operator consider
    inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: Computing the number of own properties of an object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Objects don’t have a method such as `length` or `size`, so you have to use
    the following workaround:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: 'Best Practices: Iterating over Own Properties'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To iterate over property keys:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Combine `for-in` with `hasOwnProperty()`, in the manner described in [for-in](ch13.html#for-in
    "for-in"). This works even on older JavaScript engines. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine `Object.keys()` or `Object.getOwnPropertyNames()` with `forEach()`
    array iteration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: 'To iterate over property values or over (key, value) pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate over the keys, and use each key to retrieve the corresponding value.
    Other languages make this simpler, but not JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessors (Getters and Setters)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 5 lets you write methods whose invocations look like you are getting
    or setting a property. That means that a property is virtual and not storage space.
    You could, for example, forbid setting a property and always compute the value
    returned when reading it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Accessors via an Object Literal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example uses an object literal to define a setter and a getter
    for property `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: Defining Accessors via Property Descriptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternate way to specify getters and setters is via property descriptors
    (see [Property Descriptors](ch17_split_000.html#property_descriptors "Property
    Descriptors")). The following code defines the same object as the preceding literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: Accessors and Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Getters and setters are inherited from prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: Property Attributes and Property Descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Property attributes and property descriptors are an advanced topic. You normally
    don’t need to know how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at the internal structure of properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Property attributes* are the atomic building blocks of properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *property descriptor* is a data structure for working programmatically with
    attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of a property’s state, both its data and its metadata, is stored in *attributes*.
    They are fields that a property has, much like an object has properties. Attribute
    keys are often written in double brackets. Attributes matter for normal properties
    and for accessors (getters and setters).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following attributes are specific to normal properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[Value]]` holds the property’s value, its data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[Writable]]` holds a boolean indicating whether the value of a property can
    be changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following attributes are specific to accessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[Get]]` holds the getter, a function that is called when a property is read.
    The function computes the result of the read access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[Set]]` holds the setter, a function that is called when a property is set
    to a value. The function receives that value as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All properties have the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[Enumerable]]` holds a boolean. Making a property nonenumerable hides it
    from some operations (see [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[Configurable]]` holds a boolean. If it is `false`, you cannot delete a property,
    change any of its attributes (except `[[Value]]`), or convert it from a data property
    to an accessor property or vice versa. In other words, `[[Configurable]]` controls
    the writability of a property’s metadata. There is one exception to this rule—JavaScript
    allows you to change an unconfigurable property from writable to read-only, for
    [historic reasons](http://bit.ly/1fwlIQI); the property `length` of arrays has
    always been writable and unconfigurable. Without this exception, you wouldn’t
    be able to freeze (see [Freezing](ch17_split_001.html#freezing_objects "Freezing"))
    arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you don’t specify attributes, the following defaults are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute key | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `[[Value]]` | `undefined` |'
  prefs: []
  type: TYPE_TB
- en: '| `[[Get]]` | `undefined` |'
  prefs: []
  type: TYPE_TB
- en: '| `[[Set]]` | `undefined` |'
  prefs: []
  type: TYPE_TB
- en: '| `[[Writable]]` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `[[Enumerable]]` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `[[Configurable]]` | `false` |'
  prefs: []
  type: TYPE_TB
- en: These defaults are important when you are creating properties via property descriptors
    (see the following section).
  prefs: []
  type: TYPE_NORMAL
- en: Property Descriptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A property descriptor is a data structure for working programmatically with
    attributes. It is an object that encodes the attributes of a property. Each of
    a descriptor’s properties corresponds to an attribute. For example, the following
    is the descriptor of a read-only property whose value is 123:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: 'You can achieve the same goal, immutability, via accessors. Then the descriptor
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: Getting and Defining Properties via Descriptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Property descriptors are used for two kinds of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting a property
  prefs: []
  type: TYPE_NORMAL
- en: All attributes of a property are returned as a descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a property
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining a property means something different depending on whether a property
    already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a property does not exist, create a new property whose attributes are as
    specified by the descriptor. If an attribute has no corresponding property in
    the descriptor, then use the default value. The defaults are dictated by what
    the attribute names mean. They are the opposite of the values that are used when
    creating a property via assignment (then the property is writable, enumerable,
    and configurable). For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: I usually don’t rely on the defaults and explicitly state all attributes, to
    be completely clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a property already exists, update the attributes of the property as specified
    by the descriptor. If an attribute has no corresponding property in the descriptor,
    then don’t change it. Here is an example (continued from the previous one):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: 'The following operations allow you to get and set a property’s attributes via
    property descriptors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.getOwnPropertyDescriptor(obj, propKey)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the descriptor of the own (noninherited) property of `obj` whose key
    is `propKey`. If there is no such property, `undefined` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.defineProperty(obj, propKey, propDesc)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create or change a property of `obj` whose key is `propKey` and whose attributes
    are specified via `propDesc`. Return the modified object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.defineProperties(obj, propDescObj)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The batch version of `Object.defineProperty()`. Each property of `propDescObj`
    holds a property descriptor. The keys of the properties and their values tell
    `Object.defineProperties` what properties to create or change on `obj`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.create(proto, propDescObj?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create an object whose prototype is `proto`. Then, if the optional parameter
    `propDescObj` has been specified, add properties to it—in the same manner as `Object.defineProperties`.
    Finally, return the result. For example, the following code snippet produces the
    same result as the previous snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: Copying an Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create an identical copy of an object, you need to get two things right:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The copy must have the same prototype (see [Layer 2: The Prototype Relationship
    Between Objects](ch17_split_000.html#prototype_relationship "Layer 2: The Prototype
    Relationship Between Objects")) as the original.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The copy must have the same properties, with the same attributes as the original.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following function performs such a copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties are copied from `orig` to `copy` via this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Get an array with the keys of all own properties of `source`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over those keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve a property descriptor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use that property descriptor to create an own property in `target`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this function is very similar to the function [`_.extend()`](http://underscorejs.org/#extend)
    in the Underscore.js library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties: Definition Versus Assignment'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following two operations are very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a property via `defineProperty()` and `defineProperties()` (see [Getting
    and Defining Properties via Descriptors](ch17_split_000.html#functions_for_property_descriptors
    "Getting and Defining Properties via Descriptors")).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning to a property via `=`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are, however, a few subtle differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Defining a property* means creating a new own property or updating the attributes
    of an existing own property. In both cases, the prototype chain is completely
    ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Assigning to a property* `prop` means changing an existing property. The process
    is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `prop` is a setter (own or inherited), call that setter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, if `prop` is read-only (own or inherited), throw an exception (in
    strict mode) or do nothing (in sloppy mode). The next section explains this (slightly
    unexpected) phenomenon in more detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, if `prop` is own (and writable), change the value of that property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, there either is no property `prop`, or it is inherited and writable.
    In both cases, define an own property `prop` that is writable, configurable, and
    enumerable. In the latter case, we have just overridden an inherited property
    (nondestructively changed it). In the former case, a missing property has been
    defined automatically. This kind of autodefining is problematic, because typos
    in assignments can be hard to detect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inherited Read-Only Properties Can’t Be Assigned To
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If an object, `obj`, inherits a property, `foo`, from a prototype and `foo`
    is not writable, then you can’t assign to `obj.foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '`obj` inherits the read-only property `foo` from `proto`. In sloppy mode, setting
    the property has no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: 'In strict mode, you get an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: This fits with the idea that assignment changes inherited properties, but nondestructively.
    If an inherited property is read-only, you want to forbid all changes, even nondestructive
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can circumvent this protection by defining an own property (see
    the previous subsection for the difference between definition and assignment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: 'Enumerability: Best Practices'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The general rule is that properties created by the system are nonenumerable,
    while properties created by users are enumerable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: 'This is especially true for the methods of the built-in instance prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: The main purpose of enumerability is to tell the `for-in` loop which properties
    it should ignore. As we have seen just now when we looked at instances of built-in
    constructors, everything not created by the user is hidden from `for-in`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only operations affected by enumerability are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `for-in` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.keys()` ([Listing Own Property Keys](ch17_split_000.html#Object.keys
    "Listing Own Property Keys"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON.stringify()` ([JSON.stringify(value, replacer?, space?)](ch22.html#JSON.stringify
    "JSON.stringify(value, replacer?, space?)"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some best practices to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For your own code, you can usually ignore enumerability and should avoid the
    `for-in` loop ([Best Practices: Iterating over Arrays](ch18.html#array_iteration
    "Best Practices: Iterating over Arrays")).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You normally shouldn’t add properties to built-in prototypes and objects. But
    if you do, you should make them nonenumerable to avoid breaking existing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three levels of protecting an object, listed here from weakest to
    strongest:'
  prefs: []
  type: TYPE_NORMAL
- en: Preventing extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sealing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freezing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing Extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Preventing extensions via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: 'makes it impossible to add properties to `obj`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: 'Now adding a property fails silently in sloppy mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: 'and throws an error in strict mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: 'You can still delete properties, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: 'You check whether an object is extensible via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: Sealing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sealing via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: prevents extensions and makes all properties “unconfigurable.” The latter means
    that the attributes (see [Property Attributes and Property Descriptors](ch17_split_000.html#property_attributes
    "Property Attributes and Property Descriptors")) of properties can’t be changed
    anymore. For example, read-only properties stay read-only forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates that sealing makes all properties unconfigurable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: 'You can still change the property `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: 'but you can’t change its attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: 'You check whether an object is sealed via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: Freezing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Freezing is performed via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: 'It makes all properties nonwritable and seals `obj`. In other words, `obj`
    is not extensible and all properties are read-only, and there is no way to change
    that. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, you get silent failures in sloppy mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: 'And you get errors in strict mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: 'You check whether an object is frozen via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: 'Pitfall: Protection Is Shallow'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Protecting an object is *shallow*: it affects the own properties, but not the
    values of those properties. For example, consider the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though you have frozen `obj`, it is not completely immutable—you can change
    the (mutable) value of property `bar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, `obj` has the prototype `Object.prototype`, which is also mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Layer 3: Constructors—Factories for Instances'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *constructor function* (short: *constructor*) helps with producing objects
    that are similar in some way. It is a normal function, but it is named, set up,
    and invoked differently. This section explains how constructors work. They correspond
    to classes in other languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen an example of two objects that are similar (in [Sharing
    Data Between Objects via a Prototype](ch17_split_000.html#sharing_via_prototype
    "Sharing Data Between Objects via a Prototype")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: 'The objects `jane` and `tarzan` are both considered “persons” and share the
    prototype object `PersonProto`. Let’s turn that prototype into a constructor `Person`
    that creates objects like `jane` and `tarzan`. The objects a constructor creates
    are called its *instances*. Such instances have the same structure as `jane` and
    `tarzan`, consisting of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Data is instance-specific and stored in the own properties of the instance objects
    (`jane` and `tarzan` in the preceding example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Behavior is shared by all instances—they have a common prototype object with
    methods (`PersonProto` in the preceding example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A constructor is a function that is invoked via the `new` operator. By convention,
    the names of constructors start with uppercase letters, while the names of normal
    functions and methods start with lowercase letters. The function itself sets up
    part 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: 'The object in `Person.prototype` becomes the prototype of all instances of
    `Person`. It contributes part 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create and use an instance of `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that `Person` is a normal function. It only becomes a constructor
    when it is invoked via `new`. The `new` operator performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First the behavior is set up: a new object is created whose prototype is `Person.`
    `prototype`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then the data is set up: `Person` receives that object as the implicit parameter
    `this` and adds instance properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 17-3](ch17_split_001.html#figoo_person_instance "Figure 17-3. jane
    is an instance of the constructor Person; its prototype is the object Person.prototype.")
    shows what the instance `jane` looks like. The property `constructor` of `Person.prototype`
    points back to the constructor and is explained in [The constructor Property of
    Instances](ch17_split_001.html#constructor_property "The constructor Property
    of Instances").'
  prefs: []
  type: TYPE_NORMAL
- en: '![jane is an instance of the constructor Person; its prototype is the object
    Person.prototype.](images/spjs_2103.png)Figure 17-3. jane is an instance of the
    constructor Person; its prototype is the object Person.prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `instanceof` operator allows us to check whether an object is an instance
    of a given constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: The new Operator Implemented in JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you were to manually implement the `new` operator, it would look roughly
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: In line (1), you can see that the prototype of an instance created by a constructor
    `Constr` is `Constr.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line (2) reveals another feature of the `new` operator: you can return an arbitrary
    object from a constructor and it becomes the result of the `new` operator. This
    is useful if you want a constructor to return an instance of a subconstructor
    (an example is given in [Returning arbitrary objects from a constructor](ch17_split_001.html#constructor_arbitrary_objects
    "Returning arbitrary objects from a constructor")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminology: The Two Prototypes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unfortunately, the term *prototype* is used ambiguously in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototype 1: The prototype relationship'
  prefs: []
  type: TYPE_NORMAL
- en: 'An object can be the prototype of another object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `proto` is the prototype of `obj`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototype 2: The value of the property `prototype`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each constructor `C` has a `prototype` property that refers to an object. That
    object becomes the prototype of all instances of `C`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually the context makes it clear which of the two prototypes is meant. Should
    disambiguation be necessary, then we are stuck with *prototype* to describe the
    relationship between objects, because that name has made it into the standard
    library via `getPrototypeOf` and `isPrototypeOf`. We thus need to find a different
    name for the object referenced by the `prototype` property. One possibility is
    *constructor prototype*, but that is problematic because constructors have prototypes,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: Thus, *instance prototype* is the best option.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor Property of Instances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, each function `C` contains an instance prototype object `C.prototype`
    whose property `constructor` points back to `C`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `constructor` property is inherited from the prototype by each
    instance, you can use it to get the constructor of an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: Use cases for the constructor property
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Switching over an object’s constructor
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following `catch` clause, we take different actions, depending on the
    constructor of the caught exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach detects only direct instances of a given constructor. In contrast,
    `instanceof` detects both direct instances and instances of all subconstructors.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the name of an object’s constructor
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all JavaScript engines support the property `name` for functions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating similar objects
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you create a new object, `y`, that has the same constructor as
    an existing object, `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: 'This trick is handy for a method that must work for instances of subconstructors
    and wants to create a new instance that is similar to `this`. Then you can’t use
    a fixed constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: Referring to a superconstructor
  prefs: []
  type: TYPE_NORMAL
- en: 'Some inheritance libraries assign the superprototype to a property of a subconstructor.
    For example, the YUI framework provides subclassing via [`Y.extend`](http://yuilibrary.com/yui/docs/yui/yui-extend.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: The call in line (1) works, because `extend` sets `Sub.superclass` to `Super.prototype`.
    Thanks to the `constructor` property, you can call the superconstructor as a method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `instanceof` operator (see [The instanceof Operator](ch17_split_001.html#operator_instanceof
    "The instanceof Operator")) does not rely on the property `constructor`.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Make sure that for each constructor `C`, the following assertion holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, every function `f` already has a property `prototype` that is set
    up correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: 'You should thus avoid replacing this object and only add properties to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do replace it, you should manually assign the correct value to `constructor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: Note that nothing crucial in JavaScript depends on the `constructor` property;
    but it is good style to set it up, because it enables the techniques mentioned
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The instanceof Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `instanceof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: 'determines whether `value` has been created by the constructor `Constr` or
    a subconstructor. It does so by checking whether `Constr.prototype` is in the
    prototype chain of `value`. Therefore, the following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, `instanceof` is always `false` for primitive values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `instanceof` throws an exception if its right side isn’t a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: 'Pitfall: objects that are not instances of Object'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Almost all objects are instances of `Object`, because `Object.prototype` is
    in their prototype chain. But there are also objects where that is not the case.
    Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: 'The former object is explained in more detail in [The dict Pattern: Objects
    Without Prototypes Are Better Maps](ch17_split_001.html#dict_pattern "The dict
    Pattern: Objects Without Prototypes Are Better Maps"). The latter object is where
    most prototype chains end (and they must end somewhere). Neither object has a
    prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: 'But `typeof` correctly classifies them as objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: This pitfall is not a deal-breaker for most use cases for `instanceof`, but
    you have to be aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: crossing realms (frames or windows)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In web browsers, each frame and window has its own *realm* with separate global
    variables. That prevents `instanceof` from working for objects that cross realms.
    To see why, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: 'If `myvar` is an array from a different realm, then its prototype is the `Array.prototype`
    from that realm. Therefore, `instanceof` will not find the `Array.prototype` of
    the current realm in the prototype chain of `myvar` and will return `false`. ECMAScript 5
    has the function `Array.isArray()`, which always works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, this is also an issue with non-built-in constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from using `Array.isArray()`, there are several things you can do to
    work around this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid objects crossing realms. Browsers have the [`postMessage()`](http://mzl.la/1fwmNrL)
    method, which can copy an object to another realm instead of passing a reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check the name of the constructor of an instance (only works on engines that
    support the property `name` for functions):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a prototype property to mark instances as belonging to a type `T`. There
    are several ways in which you can do so. The checks for whether `value` is an
    instance of `T` look as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value.isT()`: The prototype of `T` instances must return `true` from this
    method; a common superconstructor should return the default value, `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''T'' in value`: You must tag the prototype of `T` instances with a property
    whose key is `''T''` (or something more unique).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value.TYPE_NAME === ''T''`: Every relevant prototype must have a `TYPE_NAME`
    property with an appropriate value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips for Implementing Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section gives a few tips for implementing constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protection against forgetting new: strict mode'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you forget `new` when you use a constructor, you are calling it as a function
    instead of as a constructor. In sloppy mode, you don’t get an instance and global
    variables are created. Unfortunately, all of this happens without a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: 'In strict mode, you get an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: Returning arbitrary objects from a constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In many object-oriented languages, constructors can produce only direct instances.
    For example, consider Java: let’s say you want to implement a class `Expression`
    that has the subclasses `Addition` and `Multiplication`. Parsing produces direct
    instances of the latter two classes. You can’t implement it as a constructor of
    `Expression`, because that constructor can produce only direct instances of `Expression`.
    As a workaround, static factory methods are used in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, you can simply return whatever object you need from a constructor.
    Thus, the JavaScript version of the preceding code would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: 'That is good news: JavaScript constructors don’t lock you in, so you can always
    change your mind as to whether a constructor should return a direct instance or
    something else.'
  prefs: []
  type: TYPE_NORMAL
- en: Data in Prototype Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explains that in most cases, you should not put data in prototype
    properties. There are, however, a few exceptions to that rule.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Prototype Properties with Initial Values for Instance Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prototypes contain properties that are shared by several objects. Hence, they
    work well for methods. Additionally, with a technique that is described next,
    you can also use them to provide initial values for instance properties. I’ll
    later explain why that is not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'A constructor usually sets instance properties to initial values. If one such
    value is a default, then you don’t need to create an instance property. You only
    need a prototype property with the same key whose value is the default. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: The parameter `data` is optional. If it is missing, the instance does not get
    a property `data`, but inherits `Names.prototype.data` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach mostly works: you can create an instance `n` of `Names`. Getting
    `n.data` reads `Names.prototype.data`. Setting `n.data` creates a new own property
    in `n` and preserves the shared default value in the prototype. We only have a
    problem if we *change* the default value (instead of replacing it with a new value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `push()` changed the array in `Names.prototype.data`.
    Since that array is shared by all instances without an own property `data`, `n2.data`’s
    initial value has changed, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Best practice: don’t share default values'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given what we’ve just discussed, it is better to not share default values and
    to always create new ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, the problem of modifying a shared default value does not arise if
    that value is immutable (as all primitives are; see [Primitive Values](ch08.html#primitive_values
    "Primitive Values")). But for consistency’s sake, it’s best to stick to a single
    way of setting up properties. I also prefer to maintain the usual separation of
    concerns (see [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances")): the constructor sets up the
    instance properties, and the prototype contains the methods.'
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 6 will make this even more of a best practice, because constructor
    parameters can have default values and you can define prototype methods via classes,
    but not prototype properties with data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating instance properties on demand
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Occasionally, creating a property value is an expensive operation (computationally
    or storage-wise). In that case, you can create an instance property on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: 'We can’t add the property `data` to the instance via assignment, because JavaScript
    would complain about a missing setter (which it does when it only finds a getter).
    Therefore, we add it via `Object.defineProperty()`. Consult [Properties: Definition
    Versus Assignment](ch17_split_000.html#definition_vs_assignment "Properties: Definition
    Versus Assignment") to review the differences between defining and assigning.
    In line (1), we are ensuring that the property `constructor` is set up properly
    (see [The constructor Property of Instances](ch17_split_001.html#constructor_property
    "The constructor Property of Instances")).'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, that is quite a bit of work, so you have to be sure it is worth it.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Nonpolymorphic Prototype Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the same property (same key, same semantics, generally different values),
    exists in several prototypes, it is called *polymorphic*. Then the result of reading
    the property via an instance is dynamically determined via that instance’s prototype.
    Prototype properties that are not used polymorphically can be replaced by variables
    (which better reflects their nonpolymorphic nature).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can store a constant in a prototype property and access it
    via `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: 'This constant is not polymorphic. Therefore, you can just as well access it
    via a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: Polymorphic Prototype Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an example of polymorphic prototype properties with immutable data.
    Tagging instances of a constructor via prototype properties enables you to tell
    them apart from instances of a different constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the polymorphic “tag” `TYPE_NAME`, you can distinguish the instances
    of `ConstrA` and `ConstrB` even when they cross realms (then `instanceof` does
    not work; see [Pitfall: crossing realms (frames or windows)](ch17_split_001.html#cross-realm_instanceof
    "Pitfall: crossing realms (frames or windows)")).'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Data Private
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript does not have dedicated means for managing private data for an object.
    This section will describe three techniques for working around that limitation:'
  prefs: []
  type: TYPE_NORMAL
- en: Private data in the environment of a constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private data in properties with marked keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private data in properties with reified keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, I will explain how to keep global data private via IIFEs.
  prefs: []
  type: TYPE_NORMAL
- en: Private Data in the Environment of a Constructor (Crockford Privacy Pattern)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a constructor is invoked, two things are created: the constructor’s instance
    and an environment (see [Environments: Managing Variables](ch16.html#environments
    "Environments: Managing Variables")). The instance is to be initialized by the
    constructor. The environment holds the constructor’s parameters and local variables.
    Every function (which includes methods) created inside the constructor will retain
    a reference to the environment—the environment in which it was created. Thanks
    to that reference, it will always have access to the environment, even after the
    constructor is finished. This combination of function and environment is called
    a *closure* ([Closures: Functions Stay Connected to Their Birth Scopes](ch16.html#closures
    "Closures: Functions Stay Connected to Their Birth Scopes")). The constructor’s
    environment is thus data storage that is independent of the instance and related
    to it only because the two are created at the same time. To properly connect them,
    we must have functions that live in both worlds. Using [Douglas Crockford’s terminology](http://www.crockford.com/javascript/private.html),
    an instance can have three kinds of values associated with it (see [Figure 17-4](ch17_split_001.html#figprivate_data
    "Figure 17-4. When a constructor Constr is invoked, two data structures are created:
    an environment for parameters and local variables and an instance to be initialized.")):'
  prefs: []
  type: TYPE_NORMAL
- en: Public properties
  prefs: []
  type: TYPE_NORMAL
- en: Values stored in properties (either in the instance or in its prototype) are
    publicly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Private values
  prefs: []
  type: TYPE_NORMAL
- en: Data and functions stored in the environment are *private*—only accessible to
    the constructor and to the functions it created.
  prefs: []
  type: TYPE_NORMAL
- en: Privileged methods
  prefs: []
  type: TYPE_NORMAL
- en: Private functions can access public properties, but public methods in the prototype
    can’t access private data. We thus need *privileged* methods—public methods in
    the instance. Privileged methods are public and can be called by everyone, but
    they also have access to private values, because they were created in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '![When a constructor Constr is invoked, two data structures are created: an
    environment for parameters and local variables and an instance to be initialized.](images/spjs_2104.png)Figure 17-4. When
    a constructor Constr is invoked, two data structures are created: an environment
    for parameters and local variables and an instance to be initialized.'
  prefs: []
  type: TYPE_NORMAL
- en: The following sections explain each kind of value in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Public properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Remember that given a constructor `Constr`, there are two kinds of properties
    that are *public*, accessible to everyone. First, *prototype properties* are stored
    in `Constr.prototype` and shared by all instances. Prototype properties are usually
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, *instance properties* are unique to each instance. They are added in
    the constructor and usually hold data (not methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: Private values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The constructor’s environment consists of the parameters and local variables.
    They are accessible only from inside the constructor and thus private to the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: Privileged methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Private data is so safe from outside access that prototype methods can’t access
    it. But then how else would you use it after leaving the constructor? The answer
    is *privileged methods*: functions created in the constructor are added as instance
    methods. That means that, on one hand, they can access private data; on the other
    hand, they are public and therefore seen by prototype methods. In other words,
    they serve as mediators between private data and the public (including prototype
    methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: An example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following is an implementation of a `StringBuilder`, using the Crockford
    privacy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: The pros and cons of the Crockford privacy pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are some points to consider when you are using the Crockford privacy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s not very elegant
  prefs: []
  type: TYPE_NORMAL
- en: Mediating access to private data via privileged methods introduces an unnecessary
    indirection. Privileged methods and private functions both destroy the separation
    of concerns between the constructor (setting up instance data) and the instance
    prototype (methods).
  prefs: []
  type: TYPE_NORMAL
- en: It’s completely secure
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to access the environment’s data from outside, which makes this
    solution secure if you need that (e.g., for security-critical code). On the other
    hand, private data not being accessible to the outside can also be an inconvenience.
    Sometimes you want to unit-test private functionality. And some temporary quick
    fixes depend on the ability to access private data. This kind of quick fix cannot
    be predicted, so no matter how good your design is, the need can arise.
  prefs: []
  type: TYPE_NORMAL
- en: It may be slower
  prefs: []
  type: TYPE_NORMAL
- en: Accessing properties in the prototype chain is highly optimized in current JavaScript
    engines. Accessing values in the closure may be slower. But these things change
    constantly, so you’ll have to measure should this really matter for your code.
  prefs: []
  type: TYPE_NORMAL
- en: It consumes more memory
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the environment around and putting privileged methods in instances costs
    memory. Again, be sure it really matters for your code and measure.
  prefs: []
  type: TYPE_NORMAL
- en: Private Data in Properties with Marked Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For most non-security-critical applications, privacy is more like a hint to
    clients of an API: “You don’t need to see this.” That’s the key benefit of encapsulation—hiding
    complexity. Even though more is going on under the hood, you only need to understand
    the public part of an API. The idea of a naming convention is to let clients know
    about privacy by marking the key of a property. A prefixed underscore is often
    used for this purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite the previous `StringBuilder` example so that the buffer is kept
    in a property `_buffer`, which is private, but by convention only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some pros and cons of privacy via marked property keys:'
  prefs: []
  type: TYPE_NORMAL
- en: It offers a more natural coding style
  prefs: []
  type: TYPE_NORMAL
- en: Being able to access private and public data in the same manner is more elegant
    than using environments for privacy.
  prefs: []
  type: TYPE_NORMAL
- en: It pollutes the namespace of properties
  prefs: []
  type: TYPE_NORMAL
- en: Properties with marked keys can be seen everywhere. The more people use IDEs,
    the more it will be a nuisance that they are shown alongside public properties,
    in places where they should be hidden. IDEs could, in theory, adapt by recognizing
    naming conventions and by hiding private properties where possible.
  prefs: []
  type: TYPE_NORMAL
- en: Private properties can be accessed from “outside”
  prefs: []
  type: TYPE_NORMAL
- en: That can be useful for unit tests and quick fixes. Additionally, subconstructors
    and helper functions (so-called “friend functions”) can profit from easier access
    to private data. The environment approach doesn’t offer this kind of flexibility;
    private data can be accessed only from within the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: It can lead to key clashes
  prefs: []
  type: TYPE_NORMAL
- en: Keys of private properties can clash. This is already an issue for subconstructors,
    but it is even more problematic if you work with multiple inheritance (as enabled
    by some libraries). With the environment approach, there are never any clashes.
  prefs: []
  type: TYPE_NORMAL
- en: Private Data in Properties with Reified Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One problem with a naming convention for private properties is that keys might
    clash (e.g., a key from a constructor with a key from a subconstructor, or a key
    from a mixin with a key from a constructor). You can make such clashes less likely
    by using longer keys, that, for example, include the name of the constructor.
    Then, in the previous case, the private property `_buffer` would be called `_StringBuilder_buffer`.
    If such a key is too long for your taste, you have the option of *reifying it*,
    of storing it in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: 'We now access the private data via `this[KEY_BUFFER]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: We have wrapped an IIFE around `StringBuilder` so that the constant `KEY_BUFFER`
    stays local and doesn’t pollute the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reified property keys enable you to use UUIDs (universally unique identifiers)
    in keys. For example, via Robert Kieffer’s [node-uuid](https://github.com/broofa/node-uuid):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: '`KEY_BUFFER` has a different value each time the code runs. It may, for example,
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: Long keys with UUIDs make key clashes virtually impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Global Data Private via IIFEs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This subsection explains how to keep global data private to singleton objects,
    constructors, and methods, via IIFEs (see [Introducing a New Scope via an IIFE](ch16.html#iife
    "Introducing a New Scope via an IIFE")). Those IIFEs create new environments (refer
    back to [Environments: Managing Variables](ch16.html#environments "Environments:
    Managing Variables")), which is where you put the private data.'
  prefs: []
  type: TYPE_NORMAL
- en: Attaching private global data to a singleton object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t need a constructor to associate an object with private data in an
    environment. The following example shows how to use an IIFE for the same purpose,
    by wrapping it around a singleton object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: Keeping global data private to all of a constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some global data is relevant only for a constructor and the prototype methods.
    By wrapping an IIFE around both, you can hide it from public view. [Private Data
    in Properties with Reified Keys](ch17_split_001.html#private_data_reified_keys
    "Private Data in Properties with Reified Keys") gave an example: the constructor
    `StringBuilder` and its prototype methods use the constant `KEY_BUFFER`, which
    contains a property key. That constant is stored in the environment of an IIFE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you are using a module system (see [Chapter 31](ch31.html "Chapter 31. Module
    Systems and Package Managers")), you can achieve the same effect with cleaner
    code by putting the constructor plus methods in a module.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching global data to a method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes you only need global data for a single method. You can keep it private
    by putting it in the environment of an IIFE that you wrap around the method. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: 'Layer 4: Inheritance Between Constructors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we examine how constructors can be inherited from: given a
    constructor `Super`, how can we write a new constructor, `Sub`, that has all the
    features of `Super` plus some features of its own? Unfortunately, JavaScript does
    not have a built-in mechanism for performing this task. Hence, we’ll have to do
    some manual work.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-5](ch17_split_001.html#figoo_subclassing_idea "Figure 17-5. Sub
    should inherit from Super: it should have all of Super’s prototype properties
    and all of Super’s instance properties in addition to its own. Note that methodB
    overrides Super’s methodB.") illustrates the idea: the subconstructor `Sub` should
    have all of the properties of `Super` (both prototype properties and instance
    properties) in addition to its own. Thus, we have a rough idea of what `Sub` should
    look like, but don’t know how to get there. There are several things we need to
    figure out, which I’ll explain next:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting instance properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting prototype properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensuring that `instanceof` works: if `sub` is an instance of `Sub`, we also
    want `sub instanceof Super` to be true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding a method to adapt one of `Super`’s methods in `Sub`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Making supercalls: if we have overridden one of `Super`’s methods, we may need
    to call the original method from `Sub`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Sub should inherit from Super: it should have all of Super’s prototype properties
    and all of Super’s instance properties in addition to its own. Note that methodB
    overrides Super’s methodB.](images/spjs_2105.png)Figure 17-5. Sub should inherit
    from Super: it should have all of Super’s prototype properties and all of Super’s
    instance properties in addition to its own. Note that methodB overrides Super’s
    methodB.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting Instance Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instance properties are set up in the constructor itself, so inheriting the
    superconstructor’s instance properties involves calling that constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: When `Sub` is invoked via `new`, its implicit parameter `this` refers to a fresh
    instance. It first passes that instance on to `Super` (1), which adds its instance
    properties. Afterward, `Sub` sets up its own instance properties (2,3). The trick
    is not to invoke `Super` via `new`, because that would create a fresh superinstance.
    Instead, we call `Super` as a function and hand in the current (sub)instance as
    the value of `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting Prototype Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shared properties such as methods are kept in the instance prototype. Thus,
    we need to find a way for `Sub.prototype` to inherit all of `Super.prototype`’s
    properties. The solution is to give `Sub.prototype` the prototype `Super.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: Confused by the two kinds of prototypes?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Yes, JavaScript terminology is confusing here. If you feel lost, consult [Terminology:
    The Two Prototypes](ch17_split_001.html#two_prototypes "Terminology: The Two Prototypes"),
    which explains how they differ.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code that achieves that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.create()` produces a fresh object whose prototype is `Super.prototype`.
    Afterward, we add `Sub`’s methods. As explained in [The constructor Property of
    Instances](ch17_split_001.html#constructor_property "The constructor Property
    of Instances"), we also need to set up the property `constructor`, because we
    have replaced the original instance prototype where it had the correct value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-6](ch17_split_001.html#figoo_sub_constructor "Figure 17-6. The constructor
    Sub inherits the constructor Super by calling it and by making Sub.prototype a
    prototypee of Super.prototype.") shows how `Sub` and `Super` are related now.
    `Sub`’s structure does resemble what I have sketched in [Figure 17-5](ch17_split_001.html#figoo_subclassing_idea
    "Figure 17-5. Sub should inherit from Super: it should have all of Super’s prototype
    properties and all of Super’s instance properties in addition to its own. Note
    that methodB overrides Super’s methodB."). The diagram does not show the instance
    properties, which are set up by the function call mentioned in the diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The constructor Sub inherits the constructor Super by calling it and by making
    Sub.prototype a prototypee of Super.prototype.](images/spjs_2106.png)Figure 17-6. The
    constructor Sub inherits the constructor Super by calling it and by making Sub.prototype
    a prototypee of Super.prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring That instanceof Works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '“Ensuring that `instanceof` works” means that every instance of `Sub` must
    also be an instance of `Super`. [Figure 17-7](ch17_split_001.html#figoo_sub_instance
    "Figure 17-7. subInstance has been created by the constructor Sub. It has the
    two prototypes Sub.prototype and Super.prototype.") shows what the prototype chain
    of `subInstance`, an instance of `Sub`, looks like: its first prototype is `Sub.prototype`,
    and its second prototype is `Super.prototype`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![subInstance has been created by the constructor Sub. It has the two prototypes
    Sub.prototype and Super.prototype.](images/spjs_2107.png)Figure 17-7. subInstance
    has been created by the constructor Sub. It has the two prototypes Sub.prototype
    and Super.prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with an easier question: is `subInstance` an instance of `Sub`?
    Yes, it is, because the following two assertions are equivalent (the latter can
    be considered the definition of the former):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned before, `Sub.prototype` is one of the prototypes of `subInstance`,
    so both assertions are true. Similarly, `subInstance` is also an instance of `Super`,
    because the following two assertions hold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: Overriding a Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We override a method in `Super.prototype` by adding a method with the same
    name to `Sub.prototype`. `methodB` is an example and in [Figure 17-7](ch17_split_001.html#figoo_sub_instance
    "Figure 17-7. subInstance has been created by the constructor Sub. It has the
    two prototypes Sub.prototype and Super.prototype."), we can see why it works:
    the search for `methodB` begins in `subInstance` and finds `Sub.prototype.methodB`
    before `Super.prototype.methodB`.'
  prefs: []
  type: TYPE_NORMAL
- en: Making a Supercall
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand supercalls, you need to know the term *home object*. The home
    object of a method is the object that owns the property whose value is the method.
    For example, the home object of `Sub.prototype.methodB` is `Sub.prototype`. Supercalling
    a method `foo` involves three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start your search “after” (in the prototype of) the home object of the current
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for a method whose name is `foo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke that method with the current `this`. The rationale is that the supermethod
    must work with the same instance as the current method; it must be able to access
    the same instance properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Therefore, the code of the submethod looks as follows. It supercalls itself,
    it calls the method it has overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: 'One way of reading the supercall at (1) is as follows: refer to the supermethod
    directly and call it with the current `this`. However, if we split it into three
    parts, we find the aforementioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Super.prototype`: Start your search in `Super.prototype`, the prototype of
    `Sub.prototype` (the home object of the current method `Sub.prototype.methodB`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`methodB`: Look for a method with the name `methodB`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`call(this, ...)`: Call the method found in the previous step, and maintain
    the current `this`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoiding Hardcoding the Name of the Superconstructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Until now, we have always referred to supermethods and superconstructors by
    mentioning the superconstructor name. This kind of hardcoding makes your code
    less flexible. You can avoid it by assigning the superprototype to a property
    of `Sub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: 'Then calling the superconstructor and a supermethod looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting up `Sub._super` is usually handled by a utility function that also
    connects the subprototype to the superprototype. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the helper function `copyOwnPropertiesFrom()`, which is shown
    and explained in [Copying an Object](ch17_split_000.html#code_copyOwnPropertiesFrom
    "Copying an Object").
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read “subclasses” as a verb: `SubC` *subclasses* `SuperC`. Such a utility function
    can take some of the pain out of creating a subconstructor: there are fewer things
    to do manually, and the name of the superconstructor is never mentioned redundantly.
    The following example demonstrates how it simplifies code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Constructor Inheritance in Use'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a concrete example, let’s assume that the constructor `Person` already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: 'We now want to create the constructor `Employee` as a subconstructor of `Person`.
    We do so manually, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: 'The utility function `subclasses()` from the previous section makes the code
    of `Employee` slightly simpler and avoids hardcoding the superconstructor `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: The Inheritance Hierarchy of Built-in Constructors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Built-in constructors use the same subclassing approach described in this section.
    For example, `Array` is a subconstructor of `Object`. Therefore, the prototype
    chain of an instance of `Array` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: 'Antipattern: The Prototype Is an Instance of the Superconstructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before ECMAScript 5 and `Object.create()`, an often-used solution was to create
    the subprototype by invoking the superconstructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: This is not recommended under ECMAScript 5\. The prototype will have all of
    `Super`’s instance properties, which it has no use for. Therefore, it is better
    to use the aforementioned pattern (involving `Object.create()`).
  prefs: []
  type: TYPE_NORMAL
- en: Methods of All Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Almost all objects have `Object.prototype` in their prototype chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: The following subsections describe the methods that `Object.prototype` provides
    for its prototypees.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion to Primitive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following two methods are used to convert an object to a primitive value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.prototype.toString()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a string representation of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.prototype.valueOf()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the preferred way of converting an object to a number. The default
    implementation returns `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: '`valueOf` is overridden by wrapper constructors to return the wrapped primitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: 'The conversion to number and string (whether implicit or explicit) builds on
    the conversion to primitive (for details, see [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")). That is why you can use the aforementioned two methods
    to configure those conversions. `valueOf()` is preferred by the conversion to
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: '`toString()` is preferred by the conversion to string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: The conversion to boolean is not configurable; objects are always considered
    to be `true` (see [Converting to Boolean](ch10.html#toboolean "Converting to Boolean")).
  prefs: []
  type: TYPE_NORMAL
- en: Object.prototype.toLocaleString()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method returns a locale-specific string representation of an object. The
    default implementation calls `toString()`. Most engines don’t go beyond this support
    for this method. However, the ECMAScript Internationalization API (see [The ECMAScript
    Internationalization API](ch30.html#i18n_api "The ECMAScript Internationalization
    API")), which is supported by many modern engines, overrides it for several built-in
    constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypal Inheritance and Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods help with prototypal inheritance and properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.prototype.isPrototypeOf(obj)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns `true` if the receiver is part of the prototype chain of `obj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.prototype.hasOwnProperty(key)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if `this` owns a property whose key is `key`. “Own” means that
    the property exists in the object itself and not in one of its prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You normally should invoke this method generically (not directly), especially
    on objects whose properties you don’t know statically. Why and how is explained
    in [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.prototype.propertyIsEnumerable(propKey)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns `true` if the receiver has a property with the key `propKey` that is
    enumerable and `false` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: 'Generic Methods: Borrowing Methods from Prototypes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes instance prototypes have methods that are useful for more objects
    than those that inherit from them. This section explains how to use the methods
    of a prototype without inheriting from it. For example, the instance prototype
    `Wine.prototype` has the method `incAge()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: 'The interaction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `incAge()` works for any object that has the property `age`. How
    can we invoke it on an object that is not an instance of `Wine`? Let’s look at
    the preceding method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: 'There are actually two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chablis` is the receiver of the method call, passed to `incAge` via `this`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1` is an argument, passed to `incAge` via `years`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can’t replace the former with an arbitrary object—the receiver must be an
    instance of `Wine`. Otherwise, the method `incAge` is not found. But the preceding
    method call is equivalent to (refer back to [Calling Functions While Setting this:
    call(), apply(), and bind()](ch17_split_000.html#oop_call_apply_bind "Calling
    Functions While Setting this: call(), apply(), and bind()")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding pattern, we can make an object the receiver (first argument
    of `call`) that is not an instance of `Wine`, because the receiver isn’t used
    to find the method `Wine.prototype.incAge`. In the following example, we apply
    the method `incAge()` to the object `john`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: A function that can be used in this manner is called a *generic method*; it
    must be prepared for `this` not being an instance of “its” constructor. Thus,
    not all methods are generic; the ECMAScript language specification explicitly
    states which ones are (see [A List of All Generic Methods](ch17_split_001.html#list_of_generic_methods
    "A List of All Generic Methods")).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Object.prototype and Array.prototype via Literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calling a method generically is quite verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make this shorter by accessing `hasOwnProperty` via an instance of
    `Object`, as created by an empty object literal `{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of this pattern is that it is less verbose. But it is also less
    self-explanatory. Performance should not be an issue (at least long term), as
    engines can statically determine that the literals should not create objects.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of Calling Methods Generically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are a few examples of generic methods in use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `apply()`(see [Function.prototype.apply(thisValue, argArray)](ch17_split_000.html#oop_apply
    "Function.prototype.apply(thisValue, argArray)")) to push an array (instead of
    individual elements; see [Adding and Removing Elements (Destructive)](ch18.html#Array.prototype.push
    "Adding and Removing Elements (Destructive)")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: This example is about turning an array into arguments, not about borrowing a
    method from another constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the array method `join()` to a string (which is not an array):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: Apply the array method `map()` to a string:^([[15](ch17_split_001.html#ftn.id1038112)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `map()` generically is more efficient than using `split('''')`, which
    creates an intermediate array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply a string method to nonstrings. `toUpperCase()` converts the receiver
    to a string and uppercases the result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: 'Using generic array methods on plain objects gives you insight into how they
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke an array method on a fake array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: 'See how an array method transforms an object that it treats like an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: Array-Like Objects and Generic Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some objects in JavaScript that feel like an array, but actually
    aren’t. That means that while they have indexed access and a `length` property,
    they don’t have any of the array methods (`forEach()`, `push`, `concat()`, etc.).
    This is unfortunate, but as we will see, generic array methods enable a workaround.
    Examples of array-like objects include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The special variable `arguments` (see [All Parameters by Index: The Special
    Variable arguments](ch15.html#arguments_variable "All Parameters by Index: The
    Special Variable arguments")), which is an important array-like object, because
    it is such a fundamental part of JavaScript. `arguments` looks like an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: 'But none of the array methods are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s because `arrayLike` is not an instance of `Array` (and `Array.prototype`
    is not in the prototype chain):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: 'Browser DOM node lists, which are returned by `document.getElementsBy*()` (e.g.,
    `getElementsByTagName()`), `document.forms`, and so on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings, which are array-like, too:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: 'The term *array-like* can also be seen as a contract between generic array
    methods and objects. The objects have to fulfill certain requirements; otherwise,
    the methods won’t work on them. The requirements are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of an array-like object must be accessible via square brackets
    and integer indices starting at 0\. All methods need read access, and some methods
    additionally need write access. Note that all objects support this kind of indexing:
    an index in brackets is converted to a string and used as a key to look up a property
    value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: An array-like object must have a `length` property whose value is the number
    of its elements. Some methods require `length` to be mutable (for example, `reverse()`).
    Values whose lengths are immutable (for example, strings) cannot be used with
    those methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns for working with array-like objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following patterns are useful for working with array-like objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Turn an array-like object into an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `slice()` (see [Concatenating, Slicing, Joining (Nondestructive)](ch18.html#Array.prototype.slice
    "Concatenating, Slicing, Joining (Nondestructive)")) without any arguments creates
    a copy of an array-like receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: 'To iterate over all elements of an array-like object, you can use a simple
    `for` loop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: 'But you can also borrow `Array.prototype.forEach()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, the interaction looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: A List of All Generic Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following list includes all methods that are generic, as mentioned in the
    ECMAScript language specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype` (see [Array Prototype Methods](ch18.html#array_prototype_methods
    "Array Prototype Methods")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`every`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`join`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastIndexOf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduceRight`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reverse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shift`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slice`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`some`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splice`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toLocaleString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unshift`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype` (see [Date Prototype Methods](ch20.html#date_prototype_methods
    "Date Prototype Methods"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toJSON`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.prototype` (see [Methods of All Objects](ch17_split_001.html#methods_of_all_objects
    "Methods of All Objects"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (All `Object` methods are automatically generic—they have to work for all objects.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype` (see [String Prototype Methods](ch12.html#string_prototype_methods
    "String Prototype Methods"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charAt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charCodeAt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastIndexOf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localeCompare`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`match`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slice`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`substring`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toLocaleLowerCase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toLocaleUpperCase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toLowerCase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toUpperCase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trim`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pitfalls: Using an Object as a Map'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since JavaScript has no built-in data structure for maps, objects are often
    used as maps from strings to values. Alas, that is more error-prone than it seems.
    This section explains three pitfalls that are involved in this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall 1: Inheritance Affects Reading Properties'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The operations that read properties can be partitioned into two kinds:'
  prefs: []
  type: TYPE_NORMAL
- en: Some operations consider the whole prototype chain and see inherited properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other operations access only the *own* (noninherited) properties of an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You need to choose carefully between these kinds of operations when you read
    the entries of an object-as-map. To see why, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: '`obj` is an object with one own property whose prototype is `proto`, which
    also has one own property. `proto` has the prototype `Object.prototype`, like
    all objects that are created by object literals. Thus, `obj` inherits properties
    from both `proto` and `Object.` `prototype`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want `obj` to be interpreted as a map with the single entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: That is, we want to ignore inherited properties and only consider own properties.
    Let’s see which read operations interpret `obj` in this manner and which don’t.
    Note that for objects-as-maps, we normally want to use arbitrary property keys,
    stored in variables. That rules out dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a property exists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `in` operator checks whether an object has a property with a given key,
    but it considers inherited properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: 'We need the check to ignore inherited properties. `hasOwnProperty()` does what
    we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: Collecting property keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What operations can we use to find all of the keys of `obj`, while honoring
    our interpretation of it as a map? `for-in` looks like it might work. But, alas,
    it doesn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: It considers inherited enumerable properties. The reason that no properties
    of `Object.prototype` show up here is that all of them are nonenumerable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, `Object.keys()` lists only own properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: This method returns only enumerable own properties; `ownProp` has been added
    via assignment and is thus enumerable by default. If you want to list all own
    properties, you need to use `Object.getOwnPropertyNames()`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a property value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For reading the value of a property, we can only choose between the dot operator
    and the bracket operator. We can’t use the former, because we have arbitrary keys,
    stored in variables. That leaves us with the bracket operator, which considers
    inherited properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not what we want. There is no built-in operation for reading only own
    properties, but you can easily implement one yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: 'With that function, the inherited property `toString` is ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: 'Pitfall 2: Overriding Affects Invoking Methods'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function `getOwnProperty()` invoked the method `hasOwnProperty()` on `obj`.
    Normally, that is fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you add a property to `obj` whose key is `hasOwnProperty`, then
    that property overrides the method `Object.prototype.hasOwnProperty()` and `getOwnProperty()`
    ceases to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: 'You can fix this problem by directly referring to `hasOwnProperty()`. This
    avoids going through `obj` to find it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: 'We have called `hasOwnProperty()` generically (see [Generic Methods: Borrowing
    Methods from Prototypes](ch17_split_001.html#generic_method "Generic Methods:
    Borrowing Methods from Prototypes")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall 3: The Special Property __proto__'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In many JavaScript engines, the property `__proto__` (see [The Special Property
    __proto__](ch17_split_000.html#proto "The Special Property __proto__")) is special:
    getting it retrieves the prototype of an object, and setting it changes the prototype
    of an object. This is why the object can’t store map data in a property whose
    key is `''__proto__''`. If you want to allow the map key `''__proto__''`, you
    must escape it before using it as a property key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: We also need to escape the escaped version of `'__proto__'` (etc.) to avoid
    clashes; that is, if we escape the key `'__proto__'` as `'__proto__%'`, then we
    also need to escape the key `'__proto__%'` so that it doesn’t replace a `'__proto__'`
    entry. That’s what happens in line (1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark S. Miller mentions the real-world implications of this pitfall in [an
    email](http://mzl.la/1fwnd1l):'
  prefs: []
  type: TYPE_NORMAL
- en: Think this exercise is academic and doesn’t arise in real systems? As observed
    at a support thread, until recently, on all non-IE browsers, if you typed “__proto__”
    at the beginning of a new Google Doc, your Google Doc would hang. This was tracked
    down to such a buggy use of an object as a string map.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The dict Pattern: Objects Without Prototypes Are Better Maps'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You create an object without a prototype like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: Such an object is a better map (dictionary) than a normal object, which is why
    this pattern is sometimes called the *dict pattern* (*dict* for *dictionary*).
    Let’s first examine normal objects and then find out why prototype-less objects
    are better maps.
  prefs: []
  type: TYPE_NORMAL
- en: Normal objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Usually, each object you create in JavaScript has at least `Object.prototype`
    in its prototype chain. The prototype of `Object.prototype` is `null`, so that’s
    where most prototype chains end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: Prototype-less objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Prototype-less objects have two advantages as maps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inherited properties (pitfall #1) are not an issue anymore, simply because
    there are none. Therefore, you can now freely use the `in` operator to detect
    whether a property exists and brackets to read properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soon, `__proto__` will be disabled. In ECMAScript 6, the special property `__proto__`
    will be disabled if `Object.prototype` is not in the prototype chain of an object.
    You can expect JavaScript engines to slowly migrate to this behavior, but it is
    not yet very common.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only disadvantage is that you’ll lose the services provided by `Object.prototype`.
    For example, a dict object can’t be automatically converted to a string anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: But that is not a real disadvantage, because it isn’t safe to directly invoke
    methods on a dict object anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use the dict pattern for quick hacks and as a foundation for libraries. In (nonlibrary)
    production code, a library is preferable, because you can be sure to avoid all
    pitfalls. The next section lists a few such libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Best Practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many applications for using objects as maps. If all property keys
    are known statically (at development time), then you just need to make sure that
    you ignore inheritance and look only at own properties. If arbitrary keys can
    be used, you should turn to a library to avoid the pitfalls mentioned in this
    section. Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[StringMap.js](http://bit.ly/1fwnp0E) by Google’s [es-lab](http://code.google.com/p/es-lab/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[stringmap.js](https://github.com/olov/stringmap) by Olov Lassus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cheat Sheet: Working with Objects'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section is a quick reference with pointers to more thorough explanations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object literals (see [Object Literals](ch17_split_000.html#object_literals
    "Object Literals")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: 'Dot operator (.) (see [Dot Operator (.): Accessing Properties via Fixed Keys](ch17_split_000.html#dot_operator
    "Dot Operator (.): Accessing Properties via Fixed Keys")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: 'Bracket operator ([]) (see [Bracket Operator ([]): Accessing Properties via
    Computed Keys](ch17_split_000.html#bracket_operator "Bracket Operator ([]): Accessing
    Properties via Computed Keys")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting and setting the prototype (see [Getting and Setting the Prototype](ch17_split_000.html#get_set_prototype
    "Getting and Setting the Prototype")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: 'Iteration and detection of properties (see [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting and defining properties via descriptors (see [Getting and Defining
    Properties via Descriptors](ch17_split_000.html#functions_for_property_descriptors
    "Getting and Defining Properties via Descriptors")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: 'Protecting objects (see [Protecting Objects](ch17_split_001.html#protecting_objects
    "Protecting Objects")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: 'Methods of all objects (see [Methods of All Objects](ch17_split_001.html#methods_of_all_objects
    "Methods of All Objects")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[15](ch17_split_001.html#id1038112)]) Using `map()` in this manner is a tip
    by Brandon Benvie (@benvie).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18. Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array is a map from indices (natural numbers, starting at zero) to arbitrary
    values. The values (the range of the map) are called the array’s *elements*. The
    most convenient way of creating an array is via an array literal. Such a literal
    enumerates the array elements; an element’s position implicitly specifies its
    index.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will first cover basic array mechanisms, such as indexed
    access and the `length` property, and then go over array methods.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section provides a quick overview of arrays. Details are explained later.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first example, we create an array `arr` via an array literal (see [Creating
    Arrays](ch18.html#creating_arrays "Creating Arrays")) and access elements (see
    [Array Indices](ch18.html#array_indices "Array Indices")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the array property `length` (see [length](ch18.html#array_length
    "length")) to remove and append elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: 'The array method `push()` provides another way of appending an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: Arrays Are Maps, Not Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ECMAScript standard specifies arrays as maps (dictionaries) from indices
    to values. In other words, arrays may not be contiguous and can have holes in
    them. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding array has a hole: there is no element at index 1\. [Holes in
    Arrays](ch18.html#array_holes "Holes in Arrays") explains holes in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that most JavaScript engines optimize arrays without holes internally and
    store them contiguously.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays Can Also Have Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arrays are still objects and can have object properties. Those are not considered
    part of the actual array; that is, they are not considered array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: Creating Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You create an array via an array literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: 'Trailing commas in arrays are ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: The Array Constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to use the constructor `Array`: you can create an empty
    array with a given length or an array whose elements are the given values. For
    this constructor, `new` is optional: invoking it as a normal function (without
    `new`) does the same as invoking it as a constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an empty array with a given length
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An empty array with a given length has only holes in it! Thus, it rarely makes
    sense to use this version of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: Some engines may preallocate contiguous memory when you call `Array()` in this
    manner, which may slightly improve performance. However, be sure that the increased
    verbosity and redundancy is worth it!
  prefs: []
  type: TYPE_NORMAL
- en: Initializing an array with elements (avoid!)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This way of invoking `Array` is similar to an array literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that you can’t create arrays with a single number in them, because
    that is interpreted as creating an array whose `length` is the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: Multidimensional Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need multiple dimensions for elements, you must nest arrays. When you
    create such nested arrays, the innermost arrays can grow as needed. But if you
    want direct access to elements, you need to at least create the outer arrays.
    In the following example, I create a three-by-three matrix for Tic-tac-toe. The
    matrix is completely filled with data (as opposed to letting rows grow as needed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: 'I wanted the example to demonstrate the general case. Obviously, if a matrix
    is so small and has fixed dimensions, you can set it up via an array literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: Array Indices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you are working with array indices, you must keep in mind the following
    limits:'
  prefs: []
  type: TYPE_NORMAL
- en: Indices are numbers *i* in the range 0 ≤ `i` < 2^(32)−1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum length is 2^(32)−1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Indices that are out of range are treated as normal property keys (strings!).
    They don’t show up as array elements and they don’t influence the property `length`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: The in Operator and Indices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `in` operator detects whether an object has a property with a given key.
    But it can also be used to determine whether a given element index exists in an
    array. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: Deleting Array Elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to deleting properties, the `delete` operator also deletes array
    elements. Deleting elements creates holes (the `length` property is not updated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also delete trailing array elements by decreasing an array’s length
    (see [length](ch18.html#array_length "length") for details). To remove elements
    without creating holes (i.e., the indices of subsequent elements are decremented),
    you use `Array.prototype.splice()` (see [Adding and Removing Elements (Destructive)](ch18.html#Array.prototype.push
    "Adding and Removing Elements (Destructive)")). In this example, we remove two
    elements at index 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: Array Indices in Detail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is an advanced section. You normally don’t need to know the details explained
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '*Array indices are not what they seem.* Until now, I have pretended that array
    indices are numbers. And that is how JavaScript engines implement arrays, internally.
    However, the ECMAScript specification sees indices differently. Paraphrasing [Section
    15.4](http://bit.ly/1fwoCFg):'
  prefs: []
  type: TYPE_NORMAL
- en: A property key `P` (a string) is an *array index* if and only if `ToString``(ToUint32(P))`
    is equal to `P` and `ToUint32(P)` is not equal to 2^(32)−1\. What this means is
    explained momentarily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array property whose key is an array index is called an *element*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words, in the world of the spec all values in brackets are converted
    to strings and interpreted as property keys, even numbers. The following interaction
    demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: 'To be an array index, a property key `P` (a string!) must be equal to the result
    of the following computation:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert `P` to a number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the number to a 32-bit unsigned integer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the integer to a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That means that an array index must be a stringified integer *i* in the 32-bit
    range 0 ≤ *i* < 2^(32)−1\. The upper limit has been explicitly excluded in the
    spec (as quoted previously). It is reserved for the maximum length. To see how
    this definition works, let’s use the function `ToUint32()` from [32-bit Integers
    via Bitwise Operators](ch11.html#integers_via_bitwise_operators "32-bit Integers
    via Bitwise Operators").
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a string that doesn’t contain a number is always converted to 0, which,
    after stringification, is not equal to the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, a stringified integer that is out of range is also converted to a completely
    different integer, which is not equal to the string, after stringification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, stringified noninteger numbers are converted to integers, which are,
    again, different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the specification also enforces that array indices don’t have exponents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: 'And that they don’t have leading zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: length
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic function of the `length` property is to track the highest index in
    an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, `length` does not count the number of elements, so you’d have to write
    your own function for doing so. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: 'To count elements (nonholes), we have used the fact that `forEach` skips holes.
    Here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: Manually Increasing the Length of an Array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Manually increasing the length of an array has remarkably little effect on
    an array; it only creates holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: The last result has two commas at the end, because a trailing comma is optional
    and thus always ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we just did did not add any elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `length` property does act as a pointer indicating where to insert
    new elements. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, setting the initial length of an array via the `Array` constructor creates
    an array that is completely empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: Decreasing the Length of an Array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you decrease the length of an array, all elements at the new length and
    above are deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: Clearing an array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you set an array’s length to 0, then it becomes empty. That allows you to
    clear an array for someone else. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, however, that this approach can be slow, because each array element is
    explicitly deleted. Ironically, creating a new empty array is often faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: Clearing shared arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You need to be aware of the fact that setting an array’s length to zero affects
    everybody who shares the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, assigning an empty array doesn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: The Maximum Length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The maximum array length is 2^(32)−1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: Holes in Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are maps from indices to values. That means that arrays can have *holes*,
    indices smaller than the length that are missing in the array. Reading an element
    at one of those indices returns `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is recommended that you avoid holes in arrays. JavaScript handles them inconsistently
    (i.e., some methods ignore them, other don’t). Thankfully, you normally don’t
    need to know how holes are handled: they are rarely useful and affect performance
    negatively.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Holes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create holes by assigning to array indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create holes by omitting values in array literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You need two trailing commas to create a trailing hole, because the last comma
    is always ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: Sparse Arrays Versus Dense Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section examines the differences between a hole and `undefined` as an element.
    Given that reading a hole returns `undefined`, both are very similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array with holes is called *sparse*. An array without holes is called *dense*.
    Dense arrays are contiguous and have an element at each index—starting at zero,
    and ending at `length` − 1\. Let’s compare the following two arrays, a sparse
    array and a dense array. The two are very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: 'A hole is almost like having the element `undefined` at the same index. Both
    arrays have the same length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: 'But the sparse array does not have an element at index 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: 'Iteration via `for` is the same for both arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: 'Iteration via `forEach` skips the holes, but not the undefined elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: Which Operations Ignore Holes, and Which Consider Them?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some operations involving arrays ignore holes, while others consider them. This
    sections explains the details.
  prefs: []
  type: TYPE_NORMAL
- en: Array iteration methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`forEach()` skips holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: '`every()` also skips holes (similarly: `some()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: '`map()` skips, but preserves holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: '`filter()` eliminates holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: Other array methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`join()` converts holes, `undefined`s, and `null`s to empty strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: '`sort()` preserves holes while sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `for-in` loop correctly lists property keys (which are a superset of array
    indices):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: Function.prototype.apply()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`apply()` turns each hole into an argument whose value is `undefined`. The
    following interaction demonstrates this: function `f()` returns its arguments
    as an array. When we pass `apply()` an array with three holes in order to invoke
    `f()`, the latter receives three `undefined` arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: 'That means that we can use `apply()` to create an array with `undefined`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`apply()` translates holes to `undefined`s in empty arrays, but it can’t be
    used to plug holes in arbitrary arrays (which may or may not contain holes). Take,
    for example, the arbitrary array `[2]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: The array does not contain any holes, so `apply()` should return the same array.
    Instead, it returns an empty array with length 2 (all it contains are two holes).
    That is because `Array()` interprets single numbers as array lengths, not as array
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Holes from Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have seen, `filter()` removes holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a custom function to convert holes to `undefined`s in arbitrary arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: Array Constructor Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Array.isArray(obj)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns `true` if `obj` is an array. It correctly handles objects that cross
    *realms* (windows or frames)—as opposed to `instanceof` (see [Pitfall: crossing
    realms (frames or windows)](ch17_split_001.html#cross-realm_instanceof "Pitfall:
    crossing realms (frames or windows)")).'
  prefs: []
  type: TYPE_NORMAL
- en: Array Prototype Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following sections, array prototype methods are grouped by functionality.
    For each of the subsections, I mention whether the methods are *destructive* (they
    change the arrays that they are invoked on) or *nondestructive* (they don’t modify
    their receivers; such methods often return new arrays).
  prefs: []
  type: TYPE_NORMAL
- en: Adding and Removing Elements (Destructive)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the methods in this section are destructive:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.shift()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Removes the element at index 0 and returns it. The indices of subsequent elements
    are decremented by 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.unshift(elem1?, elem2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepends the given elements to the array. It returns the new length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.pop()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Removes the last element of the array and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.push(elem1?, elem2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adds the given elements to the end of the array. It returns the new length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: '`apply()` (see [Function.prototype.apply(thisValue, argArray)](ch17_split_000.html#oop_apply
    "Function.prototype.apply(thisValue, argArray)")) enables you to destructively
    append an array `arr2` to another array `arr1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.splice(start, deleteCount?, elem1?, elem2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting at `start`, removes `deleteCount` elements and inserts the elements
    given. In other words, you are replacing the `deleteCount` elements at position
    `start` with `elem1`, `elem2`, and so on. The method returns the elements that
    have been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: 'Special parameter values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start` can be negative, in which case it is added to the length to determine
    the start index. Thus, `-1` refers the last element, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteCount` is optional. If it is omitted (along with all subsequent arguments),
    then all elements at and after index `start` are removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we remove all elements after and including the second-to-last
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: Sorting and Reversing Elements (Destructive)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These methods are also destructive:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.reverse()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reverses the order of the elements in the array and returns a reference to
    the original (modified) array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.sort(compareFunction?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorts the array and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that sorting compares values by converting them to strings, which
    means that numbers are not sorted numerically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: 'You can fix this by providing the optional parameter `compareFunction`, which
    controls how sorting is done. It has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: 'This function compares `a` and `b` and returns:'
  prefs: []
  type: TYPE_NORMAL
- en: An integer less than zero (e.g., `-1`) if `a` is less than `b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero if `a` is equal to `b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer greater than zero (e.g., `1`) if `a` is greater than `b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For numbers, you can simply return `a-b`, but that can cause numeric overflow.
    To prevent that from happening, you need more verbose code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: 'I don’t like nested conditional operators. But in this case, the code is so
    much less verbose that I’m tempted to recommend it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: Comparing Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For strings, you can use `String.prototype.localeCompare` (see [Comparing Strings](ch12.html#comparing_strings
    "Comparing Strings")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: Comparing Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The parameter `compareFunction` is also useful for sorting objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: 'With `compareNames` as the compare function, `arr` is sorted by `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: Concatenating, Slicing, Joining (Nondestructive)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following methods perform various nondestructive operations on arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.concat(arr1?, arr2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creates a new array that contains all the elements of the receiver, followed
    by all the elements of the array `arr1`, and so on. If one of the parameters is
    not an array, then it is added to the result as an element (for example, the first
    argument, `''c''`, here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: 'The array that `concat()` is invoked on is not changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.slice(begin?, end?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copies array elements into a new array, starting at `begin`, until and excluding
    the element at `end`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: 'If `end` is missing, the array length is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: 'If both indices are missing, the array is copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: 'If either of the indices is negative, the array length is added to it. Thus,
    `-1` refers to the last element, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.join(separator?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creates a string by applying `toString()` to all array elements and putting
    the string in `separator` between the results. If `separator` is omitted, `'',''`
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: '`join()` converts `undefined` and `null` to empty strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: 'Holes in arrays are also converted to empty strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: Searching for Values (Nondestructive)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following methods search for values in arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.indexOf(searchValue, startIndex?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches the array for `searchValue`, starting at `startIndex`. It returns
    the index of the first occurrence or –1 if nothing is found. If `startIndex` is
    negative, the array length is added to it; if it is missing, the whole array is
    searched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: 'Strict equality (seev[Equality Operators: === Versus ==](ch09.html#equality_operators
    "Equality Operators: === Versus ==")) is used for the search, which means that
    `indexOf()` can’t find `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.lastIndexOf(searchElement, startIndex?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches the array for `searchElement`, starting at `startIndex`, backward.
    It returns the index of the first occurrence or –1 if nothing is found. If `startIndex`
    is negative, the array length is added to it; if it is missing, the whole array
    is searched. Strict equality (see [Equality Operators: === Versus ==](ch09.html#equality_operators
    "Equality Operators: === Versus ==")) is used for the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: Iteration (Nondestructive)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iteration methods use a function to iterate over an array. I distinguish three
    kinds of iteration methods, all of which are nondestructive: *examination methods*
    mainly observe the content of an array; *transformation methods* derive a new
    array from the receiver; and *reduction methods* compute a result based on the
    receiver’s elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Examination Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each method described in this section looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a method takes the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`callback` is its first parameter, a function that it calls. Depending on the
    examination method, the callback returns a boolean or nothing. It has the following
    signature:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: '`element` is an array element for `callback` to process, `index` is the element’s
    index, and `array` is the array that `examinationMethod` has been invoked on.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thisValue` allows you to configure the value of `this` inside `callback`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And now for the examination methods whose signatures I have just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.forEach(callback, thisValue?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterates over the elements of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.every(callback, thisValue?)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if the callback returns `true` for every element. It stops iteration
    as soon as the callback returns `false`. Note that not returning a value leads
    to an implicit return of `undefined`, which `every()` interprets as `false`. `every()`
    works like the universal quantifier (“for all”).
  prefs: []
  type: TYPE_NORMAL
- en: 'This example checks whether every number in the array is even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: 'If the array is empty, the result is `true` (and `callback` is not called):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.some(callback, thisValue?)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if the callback returns `true` for at least one element. It stops
    iteration as soon as the callback returns `true`. Note that not returning a value
    leads to an implicit return of `undefined`, which `some` interprets as `false`.
    `some()` works like the existential quantifier (“there exists”).
  prefs: []
  type: TYPE_NORMAL
- en: 'This example checks whether there is an even number in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: 'If the array is empty, the result is `false` (and `callback` is not called):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: 'One potential pitfall of `forEach()` is that it does not support `break` or
    something similar to prematurely abort the loop. If you need to do that, you can
    use `some()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: '`some()` returns `true` if a break happened, and `false` otherwise. This allows
    you to react differently depending on whether iterating finished successfully
    (something that is slightly tricky with `for` loops).'
  prefs: []
  type: TYPE_NORMAL
- en: Transformation Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transformation methods take an input array and produce an output array, while
    the callback controls how the output is produced. The callback has the same signature
    as for examination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two transformation methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.map(callback, thisValue?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each output array element is the result of applying `callback` to an input
    element. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.filter(callback, thisValue?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output array contains only those input elements for which `callback` returns
    `true`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: Reduction Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For reducing, the callback has a different signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter `previousValue` is the value previously returned by the callback.
    When the callback is first called, there are two possibilities (the descriptions
    are for `Array.prototype.reduce()`; differences with `reduceRight()` are mentioned
    in parentheses):'
  prefs: []
  type: TYPE_NORMAL
- en: 'An explicit `initialValue` has been provided. Then `previousValue` is `initialValue`,
    and `currentElement` is the first array element (`reduceRight`: the last array
    element).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No explicit `initialValue` has been provided. Then `previousValue` is the first
    array element, and `currentElement` is the second array element (`reduceRight`:
    the last array element and second-to-last array element).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two reduction methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.reduce(callback, initialValue?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterates from left to right and invokes the callback as previously sketched.
    The result of the method is the last value returned by the callback. This example
    computes the sum of all array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: 'If you invoke `reduce` on an array with a single element, that element is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: 'If you invoke `reduce` on an empty array, you must specify `initialValue`,
    otherwise you get an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.reduceRight(callback, initialValue?)`'
  prefs: []
  type: TYPE_NORMAL
- en: Works the same as `reduce()`, but iterates from right to left.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many functional programming languages, `reduce` is known as `fold` or `foldl`
    (left fold) and `reduceRight` is known as `foldr` (right fold).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to look at the `reduce` method is that it implements an n-ary operator
    `OP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP[1≤i≤n]` x[i]'
  prefs: []
  type: TYPE_NORMAL
- en: 'via a series of applications of a binary operator `op2`:'
  prefs: []
  type: TYPE_NORMAL
- en: (...(x[1] `op2` x[2]) `op2` ...) `op2` x[n]
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s what happened in the previous code example: we implemented an n-ary
    sum operator for arrays via JavaScript’s binary plus operator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s examine the two iteration directions via the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, `reduce()` iterates from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: 'And `reduceRight()` iterates from right to left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: 'Pitfall: Array-Like Objects'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some objects in JavaScript look like an array, but they aren’t one. That usually
    means that they have indexed access and a `length` property, but none of the array
    methods. Examples include the special variable `arguments`, DOM node lists, and
    strings. [Array-Like Objects and Generic Methods](ch17_split_001.html#array-like_objects
    "Array-Like Objects and Generic Methods") gives tips for working with array-like
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Best Practices: Iterating over Arrays'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To iterate over an array `arr`, you have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `for` loop (see [for](ch13.html#for_loop "for")):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the array iteration methods (see [Iteration (Nondestructive)](ch18.html#array_iteration_methods
    "Iteration (Nondestructive)")). For example, `forEach()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: Do not use the `for-in` loop (see [for-in](ch13.html#for-in "for-in")) to iterate
    over arrays. It iterates over indices, not over values. And it includes the keys
    of normal properties while doing so, including inherited ones.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19. Regular Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter gives an overview of the JavaScript API for regular expressions.
    It assumes that you are roughly familiar with how they work. If you are not, there
    are many good tutorials on the Web. Two examples are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Regular-Expressions.info](http://www.regular-expressions.info/) by Jan Goyvaerts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JavaScript Regular Expression Enlightenment](http://bit.ly/1fwoQMs) by Cody
    Lindley'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular Expression Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The terms used here closely reflect the grammar in the ECMAScript specification.
    I sometimes deviate to make things easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Atoms: General'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax for general atoms is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Special characters
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the following characters have special meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: 'You can escape them by prefixing a backslash. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional special characters are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside a character class `[...]`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside a group that starts with a question mark `(?...)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: The angle brackets are used only by the XRegExp library (see [Chapter 30](ch30.html
    "Chapter 30. Libraries")), to name groups.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern characters
  prefs: []
  type: TYPE_NORMAL
- en: All characters except the aforementioned special ones match themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '`.` (dot)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Matches any JavaScript character (UTF-16 code unit) except line terminators
    (newline, carriage return, etc.). To really match any character, use `[\s\S]`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: Character escapes (match single characters)
  prefs: []
  type: TYPE_NORMAL
- en: Specific control characters include `\f` (form feed), `\n` (line feed, newline),
    `\r` (carriage return), `\t` (horizontal tab), and `\v` (vertical tab).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\0` matches the NUL character (`\u0000`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any control character: `\cA` – `\cZ`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unicode character escapes: `\u0000` – `\xFFFF` (Unicode code units; see [Chapter 24](ch24.html
    "Chapter 24. Unicode and JavaScript")).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hexadecimal character escapes: `\x00` – `\xFF`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character class escapes (match one of a set of characters)
  prefs: []
  type: TYPE_NORMAL
- en: 'Digits: `\d` matches any digit (same as `[0-9]`); `\D` matches any nondigit
    (same as `[^0-9]`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alphanumeric characters: `\w` matches any Latin alphanumeric character plus
    underscore (same as `[A-Za-z0-9_]`); `\W` matches all characters not matched by
    `\w`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whitespace: `\s` matches whitespace characters (space, tab, line feed, carriage
    return, form feed, all Unicode spaces, etc.); `\S` matches all nonwhitespace characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Atoms: Character Classes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax for character classes is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[«charSpecs»]` matches any single character that matches at least one of the
    `charSpecs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[^«charSpecs»]` matches any single character that does not match any of the
    `charSpecs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following constructs are all character specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source characters match themselves. Most characters are source characters (even
    many characters that are special elsewhere). Only three characters are not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: As usual, you escape via a backslash. If you want to match a dash without escaping
    it, it must be the first character after the opening bracket or the right side
    of a range, as described shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class escapes: Any of the character escapes and character class escapes listed
    previously are allowed. There is one additional escape:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Backspace (`\b`): Outside a character class, `\b` matches word boundaries.
    Inside a character class, it matches the control character *backspace*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges comprise a source character or a class escape, followed by a dash (`-`),
    followed by a source character or a class escape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate using character classes, this example parses a date formatted
    in the ISO 8601 standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: 'Atoms: Groups'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax for groups is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(«pattern»)` is a capturing group. Whatever is matched by `pattern` can be
    accessed via backreferences or as the result of a match operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(?:«pattern»)` is a noncapturing group. `pattern` is still matched against
    the input, but not saved as a capture. Therefore, the group does not have a number
    you can refer to (e.g., via a backreference).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\1`, `\2`, and so on are known as *backreferences*; they refer back to a previously
    matched group. The number after the backslash can be any integer greater than
    or equal to 1, but the first digit must not be 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, a backreference guarantees the same amount of a’s before and
    after the dash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: 'This example uses a backreference to match an HTML tag (obviously, you should
    normally use a proper parser to process HTML):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: Quantifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any atom (including character classes and groups) can be followed by a quantifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`?` means match never or once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` means match zero or more times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+` means match one or more times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n}` means match exactly `n` times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n,}` means match `n` or more times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n,m}` means match at least `n`, at most `m`, times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, quantifiers are *greedy*; that is, they match as much as possible.
    You can get *reluctant* matching (as little as possible) by suffixing any of the
    preceding quantifiers (including the ranges in curly braces) with a question mark
    (`?`). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, `.*?` is a useful pattern for matching everything until the next occurrence
    of the following atom. For example, the following is a more compact version of
    the regular expression for HTML tags just shown (which used `[^<]*` instead of
    `.*?`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: Assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assertions, shown in the following list, are checks about the current position
    in the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `^` | Matches only at the beginning of the input. |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | Matches only at the end of the input. |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Matches only at a word boundary. Don’t confuse with `[\b]`, which
    matches a backspace. |'
  prefs: []
  type: TYPE_TB
- en: '| `\B` | Matches only if not at a word boundary. |'
  prefs: []
  type: TYPE_TB
- en: '| `(?=«pattern»)` | Positive lookahead: Matches only if `pattern` matches what
    comes next. `pattern` is used only to look ahead, but otherwise ignored. |'
  prefs: []
  type: TYPE_TB
- en: '| `(?!«pattern»)` | Negative lookahead: Matches only if `pattern` does not
    match what comes next. `pattern` is used only to look ahead, but otherwise ignored.
    |'
  prefs: []
  type: TYPE_TB
- en: 'This example matches a word boundary via `\b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: 'This example matches the inside of a word via `\B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lookbehind is not supported. [Manually Implementing Lookbehind](ch19.html#regexp-look-behind
    "Manually Implementing Lookbehind") explains how to implement it manually.
  prefs: []
  type: TYPE_NORMAL
- en: Disjunction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A disjunction operator (`|`) separates two alternatives; either of the alternatives
    must match for the disjunction to match. The alternatives are atoms (optionally
    including quantifiers).
  prefs: []
  type: TYPE_NORMAL
- en: 'The operator binds very weakly, so you have to be careful that the alternatives
    don’t extend too far. For example, the following regular expression matches all
    strings that either start with `aa` or end with `bb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the disjunction binds more weakly than even `^` and `$` and
    the two alternatives are `^aa` and `bb$`. If you want to match the two strings
    `''aa''` and `''bb''`, you need parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if you want to match the strings `''aab''` and `''abb''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: Unicode and Regular Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript’s regular expressions have only very limited support for Unicode.
    Especially when it comes to code points in the astral planes, you have to be careful.
    [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript") explains the details.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Regular Expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a regular expression via either a literal or a constructor and
    configure how it works via flags.
  prefs: []
  type: TYPE_NORMAL
- en: Literal Versus Constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to create a regular expression: you can use a literal or
    the constructor `RegExp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Literal | `/xyz/i` | Compiled at load time |'
  prefs: []
  type: TYPE_TB
- en: '| Constructor (second argument is optional) | `new RegExp(''xyz'', ''i'')`
    | Compiled at runtime |'
  prefs: []
  type: TYPE_TB
- en: 'A literal and a constructor differ in when they are compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The literal is compiled at load time. The following code will cause an exception
    when it is evaluated:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor compiles the regular expression when it is called. The following
    code will not cause an exception, but calling `foo()` will:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: Thus, you should normally use literals, but you need the constructor if you
    want to dynamically assemble a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Flags are a suffix of regular expression literals and a parameter of regular
    expression constructors; they modify the matching behavior of regular expressions.
    The following flags exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Short name | Long name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `g` | `global` | The given regular expression is matched multiple times.
    Influences several methods, especially `replace()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `i` | `ignoreCase` | Case is ignored when trying to match the given regular
    expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `m` | `multiline` | In multiline mode, the begin operator `^` and the end
    operator `$` match each line, instead of the complete input string. |'
  prefs: []
  type: TYPE_TB
- en: The short name is used for literal prefixes and constructor parameters (see
    examples in the next section). The long name is used for properties of a regular
    expression that indicate what flags were set during its creation.
  prefs: []
  type: TYPE_NORMAL
- en: Instance Properties of Regular Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regular expressions have the following instance properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flags: boolean values indicating what flags are set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`global`: Is flag `/g` set?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignoreCase`: Is flag `/i` set?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiline`: Is flag `/m` set?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data for matching multiple times (flag `/g` is set):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastIndex` is the index where to continue the search next time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of accessing the instance properties for flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: Examples of Creating Regular Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we create the same regular expression first with a literal,
    then with a constructor, and use the `test()` method to determine whether it matches
    a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create a regular expression that ignores case (flag `/i`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: 'RegExp.prototype.test: Is There a Match?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `test()` method checks whether a regular expression, `regex`, matches a
    string, `str`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: '`test()` operates differently depending on whether the flag `/g` is set or
    not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the flag `/g` is not set, then the method checks whether there is a match
    somewhere in `str`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: 'If the flag `/g` is set, then the method returns `true` as many times as there
    are matches for `regex` in `str`. The property `regex.lastIndex` contains the
    index after the last match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: 'String.prototype.search: At What Index Is There a Match?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `search()` method looks for a match with `regex` within `str`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: If there is a match, the index where it was found is returned. Otherwise, the
    result is `-1`. The properties `global` and `lastIndex` of `regex` are ignored
    as the search is performed (and `lastIndex` is not changed).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: 'If the argument of `search()` is not a regular expression, it is converted
    to one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: 'RegExp.prototype.exec: Capture Groups'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following method call captures groups while matching `regex` against `str`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: 'If there was no match, `matchData` is `null`. Otherwise, `matchData` is a *match
    result*, an array with two additional properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Array elements
  prefs: []
  type: TYPE_NORMAL
- en: Element 0 is the match for the complete regular expression (group 0, if you
    will).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element *n* > 1 is the capture of group *n*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs: []
  type: TYPE_NORMAL
- en: '`input` is the complete input string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index` is the index where the match was found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First Match (Flag /g Not Set)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the flag `/g` is not set, only the first match is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: All Matches (Flag /g Set)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the flag `/g` is set, all matches are returned if you invoke `exec()` repeatedly.
    The return value `null` signals that there are no more matches. The property `lastIndex`
    indicates where matching will continue next time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we loop over matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: 'and we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: 'String.prototype.match: Capture Groups or Return All Matching Substrings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following method call matches `regex` against `str`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: 'If the flag `/g` of `regex` is not set, this method works like `RegExp.prototype.exec()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: 'If the flag is set, then the method returns an array with all matching substrings
    in `str` (i.e., group 0 of every match) or `null` if there is no match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: 'String.prototype.replace: Search and Replace'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `replace()` method searches a string, `str`, for matches with `search`
    and replaces them with `replacement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several ways in which the two parameters can be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '`search`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Either a string or a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: 'String: To be found literally in the input string. Be warned that only the
    first occurrence of a string is replaced. If you want to replace multiple occurrences,
    you must use a regular expression with a `/g` flag. This is unexpected and a major
    pitfall.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regular expression: To be matched against the input string. Warning: Use the
    `global` flag, otherwise only one attempt is made to match the regular expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replacement`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Either a string or a function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'String: Describes how to replace what has been found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function: Computes a replacement and is given matching information via parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacement Is a String
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If `replacement` is a string, its content is used verbatim to replace the match.
    The only exception is the special character dollar sign (`$`), which starts so-called
    *replacement directives*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Groups: `$n` inserts group n from the match. `n` must be at least 1 (`$0` has
    no special meaning).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The matching substring:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`` (backtick) inserts the text before the match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$&` inserts the complete match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$''` (apostrophe) inserts the text after the match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$$` inserts a single `$`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This example refers to the matching substring and its prefix and suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: 'This example refers to a group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: Replacement Is a Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If `replacement` is a function, it computes the string that is to replace the
    match. This function has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: '`completeMatch` is the same as `$&` previously, `offset` indicates where the
    match was found, and `inputStr` is what is being matched against. Thus, you can
    use the special variable `arguments` to access groups (group 1 via `arguments[1]`,
    and so on). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: Problems with the Flag /g
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regular expressions whose `/g` flag is set are problematic if a method invoked
    on them must be invoked multiple times to return all results. That’s the case
    for two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RegExp.prototype.test()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegExp.prototype.exec()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then JavaScript abuses the regular expression as an iterator, as a pointer
    into the sequence of results. That causes problems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 1: `/g` regular expressions can’t be inlined'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding loop is infinite, because a new regular expression is created
    for each loop iteration, which restarts the iteration over the results. Therefore,
    the code must be rewritten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the preceding function will again result in an infinite loop. The correct
    version is (why `lastIndex` is set to 0 is explained shortly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s a best practice not to inline anyway (then you can give regular expressions
    descriptive names). But you have to be aware that you can’t do it, not even in
    quick hacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: `/g` regular expressions as parameters'
  prefs: []
  type: TYPE_NORMAL
- en: Code that wants to invoke `test()` and `exec()` multiple times must be careful
    with a regular expression handed to it as a parameter. Its flag `/g` must active
    and, to be safe, its `lastIndex` should be set to zero (an explanation is offered
    in the next example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 3: Shared `/g` regular expressions (e.g., constants)'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you are referring to a regular expression that has not been freshly
    created, you should set its `lastIndex` property to zero, before using it as an
    iterator (an explanation is offered in the next example). As iteration depends
    on `lastIndex`, such a regular expression can’t be used in more than one iteration
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates problem 2\. It is a naive implementation
    of a function that counts how many matches there are for the regular expression
    `regex` in the string `str`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of using this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: 'The first problem is that this function goes into an infinite loop if the regular
    expression’s `/g` flag is not set. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: 'The second problem is that the function doesn’t work correctly if `regex.lastIndex`
    isn’t 0, because that property indicates where to start the search. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: 'The following implementation fixes the two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: 'A simpler alternative is to use `match()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s one possible pitfall: `str.match()` returns `null` if the `/g` flag
    is set and there are no matches. We avoid that pitfall in the preceding code by
    using `[]` if the result of `match()` isn’t truthy.'
  prefs: []
  type: TYPE_NORMAL
- en: Tips and Tricks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section gives a few tips and tricks for working with regular expressions
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Quoting Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, when you assemble a regular expression manually, you want to use
    a given string verbatim. That means that none of the special characters (e.g.,
    `*`, `[`) should be interpreted as such—all of them need to be escaped. JavaScript
    has no built-in means for this kind of quoting, but you can program your own function,
    `quoteText`, that would work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a function is especially handy if you need to do a search and replace
    with multiple occurrences. Then the value to search for must be a regular expression
    with the `global` flag set. With `quoteText()`, you can use arbitrary strings.
    The function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: All special characters are escaped, because you may want to quote several characters
    inside parentheses or square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: Without an Assertion (e.g., ^, $), a Regular Expression Is Found Anywhere'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don’t use assertions such as `^` and `$`, most regular expression methods
    find a pattern anywhere. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: Matching Everything or Nothing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s a rare use case, but sometimes you need a regular expression that matches
    everything or nothing. For example, a function may have a parameter with a regular
    expression that is used for filtering. If that parameter is missing, you give
    it a default value, a regular expression that matches everything.
  prefs: []
  type: TYPE_NORMAL
- en: Matching everything
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The empty regular expression matches everything. We can create an instance
    of `RegExp` based on that regular expression like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the empty regular expression literal would be `//`, which is interpreted
    as a comment by JavaScript. Therefore, the following is the closest you can get
    via a literal: `/(?:)/` (empty noncapturing group). The group matches everything,
    while not capturing anything, which the group from influencing the result returned
    by `exec()`. Even JavaScript itself uses the preceding representation when displaying
    an empty regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: Matching nothing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The empty regular expression has an inverse—the regular expression that matches
    nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: Manually Implementing Lookbehind
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lookbehind is an assertion. Similar to lookahead, a pattern is used to check
    something about the current position in the input, but otherwise ignored. In contrast
    to lookahead, the match for the pattern has to *end* at the current position (not
    start at it).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function replaces each occurrence of the string `''NAME''` with
    the value of the parameter `name`, but only if the occurrence is not preceded
    by a quote. We handle the quote by “manually” checking the character before the
    current match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative is to include the characters that may escape in the regular
    expression. Then you have to temporarily add a prefix to the string you are searching
    in; otherwise, you’d miss matches at the beginning of that string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: Regular Expression Cheat Sheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Atoms (see [Atoms: General](ch19.html#regex_atoms_general "Atoms: General")):'
  prefs: []
  type: TYPE_NORMAL
- en: '`.` (dot) matches everything except line terminators (e.g., newlines). Use
    `[\s\S]` to really match everything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Character class escapes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\d` matches digits (`[0-9]`); `\D` matches nondigits (`[^0-9]`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\w` matches Latin alphanumeric characters plus underscore (`[A-Za-z0-9_]`);
    `\W` matches all other characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s` matches all whitespace characters (space, tab, line feed, etc.); `\S`
    matches all nonwhitespace characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Character class (set of characters): `[...]` and `[^...]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source characters: `[abc]` (all characters except `\ ] -` match themselves)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Character class escapes (see previous): `[\d\w]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ranges: `[A-Za-z0-9]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Groups:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Capturing group: `(...)`; backreference: `\1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Noncapturing group: `(?:...)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quantifiers (see [Quantifiers](ch19.html#regexp_quantifiers "Quantifiers")):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Greedy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`? * +`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n} {n,} {n,m}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reluctant: Put a `?` after any of the greedy quantifiers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assertions (see [Assertions](ch19.html#regexp_assertions "Assertions")):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginning of input, end of input: `^ $`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At a word boundary, not at a word boundary: `\b \B`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Positive lookahead: `(?=...)` (pattern must come next, but is otherwise ignored)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Negative lookahead: `(?!...)` (pattern must not come next, but is otherwise
    ignored)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disjunction: `|`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a regular expression (see [Creating a Regular Expression](ch19.html#creating_regexps
    "Creating a Regular Expression")):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Literal: `/xyz/i` (compiled at load time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constructor: `new RegExp(''xzy'', ''i'')` (compiled at runtime)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flags (see [Flags](ch19.html#regexp_flags "Flags")):'
  prefs: []
  type: TYPE_NORMAL
- en: 'global: `/g` (influences several regular expression methods)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ignoreCase: `/i`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'multiline: `/m` (`^` and `$` match per line, as opposed to the complete input)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`regex.test(str)`: Is there a match (see [RegExp.prototype.test: Is There a
    Match?](ch19.html#RegExp.prototype.test "RegExp.prototype.test: Is There a Match?"))?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/g` is not set: Is there a match somewhere?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/g` is set: Return `true` as many times as there are matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str.search(regex)`: At what index is there a match (see [String.prototype.search:
    At What Index Is There a Match?](ch19.html#String.prototype.search "String.prototype.search:
    At What Index Is There a Match?"))?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regex.exec(str)`: Capture groups (see the section [RegExp.prototype.exec:
    Capture Groups](ch19.html#RegExp.prototype.exec "RegExp.prototype.exec: Capture
    Groups"))?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/g` is not set: Capture groups of first match only (invoked once)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/g` is set: Capture groups of all matches (invoked repeatedly; returns `null`
    if there are no more matches)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str.match(regex)`: Capture groups or return all matching substrings (see [String.prototype.match:
    Capture Groups or Return All Matching Substrings](ch19.html#String.prototype.match
    "String.prototype.match: Capture Groups or Return All Matching Substrings"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/g` is not set: Capture groups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/g` is set: Return all matching substrings in an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str.replace(search, replacement)`: Search and replace (see [String.prototype.replace:
    Search and Replace](ch19.html#String.prototype.replace "String.prototype.replace:
    Search and Replace"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search`: String or regular expression (use the latter, set `/g`!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replacement`: String (with `$1`, etc.) or function (`arguments[1]` is group
    1, etc.) that returns a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For tips on using the flag `/g`, see [Problems with the Flag /g](ch19.html#tips_flag_g
    "Problems with the Flag /g").
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mathias Bynens (@mathias) and Juan Ignacio Dopazo (@juandopazo) recommended
    using `match()` and `test()` for counting occurrences, and Šime Vidas (@simevidas)
    warned me about being careful with `match()` if there are no matches. The pitfall
    of the global flag causing infinite loops comes from a [talk by Andrea Giammarchi](http://bit.ly/1fwpdXv)
    (@webreflection). Claude Pache told me to escape more characters in `quoteText()`.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 20. Dates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript’s `Date` constructor helps with parsing, managing, and displaying
    dates. This chapter describes how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The date API uses the term *UTC* (Coordinated Universal Time). For most purposes,
    UTC is a synonym for GMT (Greenwich Mean Time) and roughly means the time zone
    of London, UK.
  prefs: []
  type: TYPE_NORMAL
- en: The Date Constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four ways of invoking the constructor of `Date`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new Date(year, month, date?, hours?, minutes?, seconds?, milliseconds?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructs a new date from the given data. The time is interpreted relative
    to the current time zone. `Date.UTC()` provides similar functionality, but relative
    to UTC. The parameters have the following ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '`year`: For 0 ≤ `year` ≤ 99, 1900 is added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`month`: 0–11 (0 is January, 1 is February, etc.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date`: 1–31'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hours`: 0–23'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minutes`: 0–59'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seconds`: 0–59'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`milliseconds`: 0–999'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: As an aside, JavaScript has inherited the slightly weird convention of interpreting
    0 as January, 1 as February, and so on, from Java.
  prefs: []
  type: TYPE_NORMAL
- en: '`new Date(dateTimeStr)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a date time string that is converted into a number, with which `new
    Date(number)` is invoked. [Date Time Formats](ch20.html#date_time_formats "Date
    Time Formats") explains the date time formats. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: Illegal date time strings lead to `NaN` being passed to `new Date(number)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`new Date(timeValue)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creates a date as specified in the number of milliseconds since 1 January 1970
    00:00:00 UTC. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: 'The inverse of this constructor is the `getTime()` method, which returns the
    milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `NaN` as an argument, which produces a special instance of `Date`,
    an “invalid date”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE930]'
  prefs: []
  type: TYPE_PRE
- en: '`new Date()`'
  prefs: []
  type: TYPE_NORMAL
- en: Creates an object for the current date and time; it works the same as `new Date(Date.now())`.
  prefs: []
  type: TYPE_NORMAL
- en: Date Constructor Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The constructor `Date` has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.now()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the current date and time in milliseconds (since 1 January 1970, 00:00:00
    UTC). It produces the same result as `new Date().getTime()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.parse(dateTimeString)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Converts `dateTimeString` to milliseconds since 1 January 1970, 00:00:00 UTC.
    [Date Time Formats](ch20.html#date_time_formats "Date Time Formats") explains
    the format of `dateTimeString`. The result can be used to invoke `new Date(number)`.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE931]'
  prefs: []
  type: TYPE_PRE
- en: 'If it can’t parse a string, this method returns `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE932]'
  prefs: []
  type: TYPE_PRE
- en: '`Date.UTC(year, month, date?, hours?, minutes?, seconds?, milliseconds?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Converts the given data to milliseconds since 1 January 1970 00:00:00 UTC.
    It differs from the `Date` constructor with the same arguments in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It returns a number, not a new date object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It interprets the arguments as UTC, rather than as local time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date Prototype Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section covers the methods of `Date.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: Time Unit Getters and Setters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Time unit getters and setters are available with the following signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Local time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.get«Unit»()` returns `Unit`, according to local time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.set«Unit»(number)` sets `Unit`, according to local time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Universal time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.getUTC«Unit»()` returns `Unit`, according to universal time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.setUTC«Unit»(number)` sets `Unit`, according to universal time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unit` is one of the following words:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FullYear`: Usually four digits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Month`: Month (0–11)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date`: Day of the month (1–31)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Day` (getter only): Day of the week (0–6); 0 is Sunday'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hours`: Hour (0–23)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Minutes`: Minutes (0–59)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Seconds`: Seconds (0–59)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Milliseconds`: Milliseconds (0–999)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE933]'
  prefs: []
  type: TYPE_PRE
- en: Various Getters and Setters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods enable you to get and set the time in milliseconds since
    1 January 1970 and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.getTime()` returns the milliseconds since 1 January 1970 00:00:00
    UTC (see [Time Values: Dates as Milliseconds Since 1970-01-01](ch20.html#date_milliseconds
    "Time Values: Dates as Milliseconds Since 1970-01-01")).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.setTime(timeValue)` sets the date as specified in milliseconds
    since 1 January 1970 00:00:00 UTC (see [Time Values: Dates as Milliseconds Since
    1970-01-01](ch20.html#date_milliseconds "Time Values: Dates as Milliseconds Since
    1970-01-01")).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.valueOf()` is the same as `getTime()`. This method is called
    when a date is converted to a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.getTimezoneOffset()` returns the difference between local time
    and UTC time in minutes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The unit `Year` has been deprecated in favor of `FullYear`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.getYear()` is deprecated; use `getFullYear()` instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.setYear(number)` is deprecated; use `setFullYear()` instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert a Date to a String
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that conversion to a string is highly implementation-dependent. The following
    date is used to compute the output in the following examples (in Firefox, which
    had the most complete support when this book was written):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE934]'
  prefs: []
  type: TYPE_PRE
- en: Time (human-readable)
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toTimeString()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE935]'
  prefs: []
  type: TYPE_PRE
- en: The time, in the current time zone.
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toLocaleTimeString()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE936]'
  prefs: []
  type: TYPE_PRE
- en: The time in a locale-specific format. This method is provided by the ECMAScript
    Internationalization API (see [The ECMAScript Internationalization API](ch30.html#i18n_api
    "The ECMAScript Internationalization API")) and does not make much sense without
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Date (human-readable)
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toDateString()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE937]'
  prefs: []
  type: TYPE_PRE
- en: The date.
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toLocaleDateString()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE938]'
  prefs: []
  type: TYPE_PRE
- en: The date, in a locale-specific format. This method is provided by the ECMAScript
    Internationalization API (see [The ECMAScript Internationalization API](ch30.html#i18n_api
    "The ECMAScript Internationalization API")) and does not make much sense without
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Date and time (human-readable)
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toString()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE939]'
  prefs: []
  type: TYPE_PRE
- en: 'Date and time, in the current time zone. For any `Date` instance that has no
    milliseconds (i.e., the second is full), the following expression is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE940]'
  prefs: []
  type: TYPE_PRE
- en: '`Date.prototype.toLocaleString()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE941]'
  prefs: []
  type: TYPE_PRE
- en: Date and time in a locale-specific format. This method is provided by the ECMAScript
    Internationalization API (see [The ECMAScript Internationalization API](ch30.html#i18n_api
    "The ECMAScript Internationalization API")) and does not make much sense without
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toUTCString()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE942]'
  prefs: []
  type: TYPE_PRE
- en: Date and time, in UTC.
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toGMTString()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated; use `toUTCString()` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Date and time (machine-readable)
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toISOString()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE943]'
  prefs: []
  type: TYPE_PRE
- en: All internal properties show up in the returned string. The format is in accordance
    with [Date Time Formats](ch20.html#date_time_formats "Date Time Formats"); the
    time zone is always `Z`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toJSON()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method internally calls `toISOString()`. It is used by `JSON.stringify()`
    (see [JSON.stringify(value, replacer?, space?)](ch22.html#JSON.stringify "JSON.stringify(value,
    replacer?, space?)")) to convert date objects to JSON strings.
  prefs: []
  type: TYPE_NORMAL
- en: Date Time Formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section describes formats for expressing points in time as strings. There
    are many ways of doing so: indicating just the date, including a time of day,
    omitting the time zone, specifying the time zone, and more. In its support for
    date time formats, ECMAScript 5 closely follows the standard ISO 8601 Extended
    Format. JavaScript engines implement the ECMAScript specification relatively completely,
    but there are still some variations, so you have to be vigilant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The longest date time format is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE944]'
  prefs: []
  type: TYPE_PRE
- en: 'Each part stands for several decimal digits of date time data. For example,
    `YYYY` means that the format starts with a four-digit year. The following subsections
    explain what each part means. Formats are relevant for the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.parse()` can parse the formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new Date()` can parse the formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toISOString()` creates a string in the aforementioned “full”
    format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE945]'
  prefs: []
  type: TYPE_PRE
- en: Date Formats (No Time)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following date formats are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE946]'
  prefs: []
  type: TYPE_PRE
- en: 'They include the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`YYYY` refers to year (Gregorian calendar).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MM` refers to month, from 01 to 12.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DD` refers to day, from 01 to 31.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE947]'
  prefs: []
  type: TYPE_PRE
- en: Time Formats (No Date)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following time formats are available. As you can see, time zone information
    `Z` is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE948]'
  prefs: []
  type: TYPE_PRE
- en: 'They include the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T` is the prefix of the time part of a format (a literal `T`, not a digit).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HH` refers to hour, from 00 to 23\. You can use 24 as a value for `HH` (which
    refers to hour 00 of the following day), but then all remaining parts must be
    0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mm` indicates the minute, from 00 to 59.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ss` indicates the second, from 00 to 59.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sss` indicates the millisecond, from 000 to 999.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Z` refers to time zone, either of the following two:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “`Z`” for UTC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “`+`” or “`-`” followed by a time “`hh:mm`”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some JavaScript engines allow you to specify only a time (others require a
    date):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE949]'
  prefs: []
  type: TYPE_PRE
- en: Date Time Formats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Date formats and time formats can also be combined. In date time formats, you
    can use a date or a date and a time (or, in some engines, just the time). For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE950]'
  prefs: []
  type: TYPE_PRE
- en: 'Time Values: Dates as Milliseconds Since 1970-01-01'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What the date API calls `time` is called a *time value* by the ECMAScript specification.
    It is a primitive number that encodes a date as milliseconds since 1 January 1970
    00:00:00 UTC. Each date object stores its state as a time value, in the internal
    property `[[PrimitiveValue]]` (the same property that instances of the wrapper
    constructors `Boolean`, `Number`, and `String` use to store their wrapped primitive
    values).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Leap seconds are ignored in time values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods work with time values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new Date(timeValue)` uses a time value to create a date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.parse(dateTimeString)` parses a string with a date time string and returns
    a time value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.now()` returns the current date time as a time value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.UTC(year, month, date?, hours?, minutes?, seconds?, milliseconds?)` interprets
    the parameters relative to UTC and returns a time value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.getTime()` returns the time value stored in the receiver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.setTime(timeValue)` changes the date as specified via a time
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.valueOf()` returns the time value stored in the receiver. This
    method determines how dates are converted to primitives, as explained in the next
    subsection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The range of JavaScript integers (53 bits plus a sign) is large enough that
    a time span can be represented that starts at approximately 285,616 years before
    1970 and ends at approximately 285,616 years after 1970.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of converting dates to time values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE951]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Date` constructor enables you to convert times values to dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE952]'
  prefs: []
  type: TYPE_PRE
- en: Converting a Date to a Number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A date is converted to a number via `Date.prototype.valueOf()`, which returns
    a time value. This allows you to compare dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE953]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also perform arithmetic, but beware that leap seconds are ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE954]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the plus operator (`+`) to add a date to another date or a number results
    in a string, because the default for the conversion to primitive is to convert
    dates to strings (consult [The Plus Operator (+)](ch09.html#plus_operator "The
    Plus Operator (+)") for an explanation of how the plus operator works):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE955]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 21. Math
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Math` object is used as a namespace for several math functions. This chapter
    provides an overview.
  prefs: []
  type: TYPE_NORMAL
- en: Math Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The properties of `Math` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.E`'
  prefs: []
  type: TYPE_NORMAL
- en: Euler’s constant (e)
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.LN2`'
  prefs: []
  type: TYPE_NORMAL
- en: Natural logarithm of 2
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.LN10`'
  prefs: []
  type: TYPE_NORMAL
- en: Natural logarithm of 10
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.LOG2E`'
  prefs: []
  type: TYPE_NORMAL
- en: Base 2 logarithm of e
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.LOG10E`'
  prefs: []
  type: TYPE_NORMAL
- en: Base 10 logarithm of e
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.PI`'
  prefs: []
  type: TYPE_NORMAL
- en: The ratio of the circumference of a circle to its diameter (3.14159 ...), π
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.SQRT1_2`'
  prefs: []
  type: TYPE_NORMAL
- en: The square root of one-half, ![](inleq_2101.png)
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.SQRT2`'
  prefs: []
  type: TYPE_NORMAL
- en: The square root of two, ![](inleq_2102.png)
  prefs: []
  type: TYPE_NORMAL
- en: Numerical Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The numerical functions of `Math` include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.abs(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the absolute value of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.ceil(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the smallest integer ≥ `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE956]'
  prefs: []
  type: TYPE_PRE
- en: For more on converting floating-point numbers to integers, see [Converting to
    Integer](ch11.html#converting_to_integer "Converting to Integer").
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.exp(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns e^x where e is Euler’s constant (`Math.E`). This is the inverse of `Math.log()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.floor(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the largest integer ≤ `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE957]'
  prefs: []
  type: TYPE_PRE
- en: For more on converting floating-point numbers to integers, see [Converting to
    Integer](ch11.html#converting_to_integer "Converting to Integer").
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.log(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the natural (base is Euler’s constant) logarithm ln(`x`) of `x`. This
    is the inverse of `Math.exp()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.pow(x, y)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns x^y, `x` raised to the power of `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE958]'
  prefs: []
  type: TYPE_PRE
- en: '`Math.round(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns `x` rounded to the nearest integer (the greater one if it is between
    two integers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE959]'
  prefs: []
  type: TYPE_PRE
- en: For more on converting floating-point numbers to integers, see [Converting to
    Integer](ch11.html#converting_to_integer "Converting to Integer").
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.sqrt(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns ![](inleq_2103.png), the square root of `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE960]'
  prefs: []
  type: TYPE_PRE
- en: Trigonometric Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The trigonometric methods accept and return angles as radians. The following
    functions show you how you could implement conversions, should you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From degrees to radians:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE961]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE962]'
  prefs: []
  type: TYPE_PRE
- en: 'From radians to degrees:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE963]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE964]'
  prefs: []
  type: TYPE_PRE
- en: 'The trigonometric methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.acos(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the arc cosine of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.asin(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the arc sine of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.atan(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the arc tangent of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.atan2(y, x)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the arc tangent of the quotient ![](inleq_2104.png).
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.cos(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the cosine of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.sin(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the sine of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.tan(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the tangent of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: Other Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the remaining `Math` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min(x1?, x2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the smallest number among the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE965]'
  prefs: []
  type: TYPE_PRE
- en: 'Use it on arrays via `apply()` (see [func.apply(thisValue, argArray)](ch15.html#functional_apply
    "func.apply(thisValue, argArray)")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE966]'
  prefs: []
  type: TYPE_PRE
- en: '`max(x1?, x2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the largest number among the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE967]'
  prefs: []
  type: TYPE_PRE
- en: 'Use it on arrays via `apply()` (see [func.apply(thisValue, argArray)](ch15.html#functional_apply
    "func.apply(thisValue, argArray)")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE968]'
  prefs: []
  type: TYPE_PRE
- en: '`Math.random()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a pseudorandom number `r`, 0 ≤ `r` < 1. The following function uses
    `Math.random()` to compute a random integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE969]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 22. JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON (JavaScript Object Notation) is a plain-text format for data storage. It
    has become quite popular as a data interchange format for web services, for configuration
    files, and more. ECMAScript 5 has an API for converting from a string in JSON
    format to a JavaScript value (*parsing*) and vice versa (*stringifying*).
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explains what JSON is and how it was created.
  prefs: []
  type: TYPE_NORMAL
- en: Data Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JSON stores data as plain text. Its grammar is a subset of the grammar of JavaScript
    expressions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE970]'
  prefs: []
  type: TYPE_PRE
- en: 'JSON uses the following constructs from JavaScript expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: Compound
  prefs: []
  type: TYPE_NORMAL
- en: Objects of JSON data and arrays of JSON data
  prefs: []
  type: TYPE_NORMAL
- en: Atomic
  prefs: []
  type: TYPE_NORMAL
- en: Strings, numbers, booleans, and `null`
  prefs: []
  type: TYPE_NORMAL
- en: 'It adheres to these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings must always be double-quoted; string literals such as `'mystr'` are
    illegal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property keys must be double-quoted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Douglas Crockford discovered JSON in 2001\. He gave it a name and put up a
    specification at [http://json.org](http://json.org):'
  prefs: []
  type: TYPE_NORMAL
- en: I discovered JSON. I do not claim to have invented JSON, because it already
    existed in nature. What I did was I found it, I named it, I described how it was
    useful. I don’t claim to be the first person to have discovered it; I know that
    there are other people who discovered it at least a year before I did. The earliest
    occurrence I’ve found was, there was someone at Netscape who was using JavaScript
    array literals for doing data communication as early as 1996, which was at least
    five years before I stumbled onto the idea.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Initially, Crockford wanted JSON to have the name *JavaScript Markup Language*,
    but the acronym JSML was already taken by the [JSpeech Markup Language](http://www.w3.org/TR/jsml/).
  prefs: []
  type: TYPE_NORMAL
- en: The JSON specification has been translated to many human languages, and there
    are now libraries for many programming languages that support parsing and generating
    JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Grammar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Douglas Crockford created a JSON business card with a logo on the front (see
    [Figure 22-1](ch22.html#figjson_business_card_front_25 "Figure 22-1. The front
    side of the JSON business card shows a logo (source: Eric Miraglia).")) and the
    full grammar on the back (see [Figure 22-2](ch22.html#figjson_business_card_back_25
    "Figure 22-2. The back side of the JSON business card contains the complete grammar
    (source: Eric Miraglia).")). That makes it visually obvious how positively simple
    JSON is.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The front side of the JSON business card shows a logo (source: Eric Miraglia).](images/spjs_2601.png.jpg)Figure 22-1. The
    front side of the JSON business card shows a logo (source: [Eric Miraglia](http://www.flickr.com/photos/equanimity/3762360637/)).![The
    back side of the JSON business card contains the complete grammar (source: Eric
    Miraglia).](images/spjs_2602.png.jpg)Figure 22-2. The back side of the JSON business
    card contains the complete grammar (source: [Eric Miraglia](http://www.flickr.com/photos/equanimity/3763158824/)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The grammar can be transcribed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: '`{` `}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{` members `}`'
  prefs: []
  type: TYPE_NORMAL
- en: members
  prefs: []
  type: TYPE_NORMAL
- en: pair
  prefs: []
  type: TYPE_NORMAL
- en: pair `,` members
  prefs: []
  type: TYPE_NORMAL
- en: pair
  prefs: []
  type: TYPE_NORMAL
- en: string `:` value
  prefs: []
  type: TYPE_NORMAL
- en: array
  prefs: []
  type: TYPE_NORMAL
- en: '`[` `]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`[` elements `]`'
  prefs: []
  type: TYPE_NORMAL
- en: elements
  prefs: []
  type: TYPE_NORMAL
- en: value
  prefs: []
  type: TYPE_NORMAL
- en: value `,` elements
  prefs: []
  type: TYPE_NORMAL
- en: value
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: number
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: array
  prefs: []
  type: TYPE_NORMAL
- en: '`true`'
  prefs: []
  type: TYPE_NORMAL
- en: '`false`'
  prefs: []
  type: TYPE_NORMAL
- en: '`null`'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '`""`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"` chars `"`'
  prefs: []
  type: TYPE_NORMAL
- en: chars
  prefs: []
  type: TYPE_NORMAL
- en: char
  prefs: []
  type: TYPE_NORMAL
- en: char chars
  prefs: []
  type: TYPE_NORMAL
- en: char
  prefs: []
  type: TYPE_NORMAL
- en: any-Unicode-character-except-"-or-\-or-control-character
  prefs: []
  type: TYPE_NORMAL
- en: '`\" \\ \/ \b \f \n \r \t`'
  prefs: []
  type: TYPE_NORMAL
- en: '`\u` four-hex-digits'
  prefs: []
  type: TYPE_NORMAL
- en: number
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: int frac
  prefs: []
  type: TYPE_NORMAL
- en: int exp
  prefs: []
  type: TYPE_NORMAL
- en: int frac exp
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: digit
  prefs: []
  type: TYPE_NORMAL
- en: digit1-9 digits
  prefs: []
  type: TYPE_NORMAL
- en: '`-` digit'
  prefs: []
  type: TYPE_NORMAL
- en: '`-` digit1-9 digits'
  prefs: []
  type: TYPE_NORMAL
- en: frac
  prefs: []
  type: TYPE_NORMAL
- en: '`.` digits'
  prefs: []
  type: TYPE_NORMAL
- en: exp
  prefs: []
  type: TYPE_NORMAL
- en: e digits
  prefs: []
  type: TYPE_NORMAL
- en: digits
  prefs: []
  type: TYPE_NORMAL
- en: digit
  prefs: []
  type: TYPE_NORMAL
- en: digit digits
  prefs: []
  type: TYPE_NORMAL
- en: e
  prefs: []
  type: TYPE_NORMAL
- en: '`e e+ e-`'
  prefs: []
  type: TYPE_NORMAL
- en: '`E E+ E-`'
  prefs: []
  type: TYPE_NORMAL
- en: The global variable `JSON` serves as a namespace for functions that produce
    and parse strings with JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: JSON.stringify(value, replacer?, space?)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`JSON.stringify(value, replacer?, space?)` translates the JavaScript value
    `value` to a string in JSON format. It has two optional arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The optional parameter `replacer` is used to change the `value` before stringifying
    it. It can be:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *node visitor* (see [Transforming Data via Node Visitors](ch22.html#node_visitors
    "Transforming Data via Node Visitors")) that transforms the tree of values before
    it is stringified. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE971]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the replacer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE972]'
  prefs: []
  type: TYPE_PRE
- en: 'A whitelist of property keys that hides all properties (of nonarray objects)
    whose keys are not in the list. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE973]'
  prefs: []
  type: TYPE_PRE
- en: 'The whitelist has no effect on arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE974]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional parameter `space` influences the formatting of the output. Without
    this parameter, the result of `stringify` is a single line of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE975]'
  prefs: []
  type: TYPE_PRE
- en: 'With it, newlines are inserted and each level of nesting via arrays and objects
    increases indentation. There are two ways to specify how to indent:'
  prefs: []
  type: TYPE_NORMAL
- en: A number
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply the number by the level of indentation and indent the line by as many
    spaces. Numbers smaller than 0 are interpreted as 0; numbers larger than 10 are
    interpreted as 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE976]'
  prefs: []
  type: TYPE_PRE
- en: A string
  prefs: []
  type: TYPE_NORMAL
- en: 'To indent, repeat the given string once for each level of indentation. Only
    the first 10 characters of the string are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE977]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the following invocation of `JSON.stringify()` prints an object
    as a nicely formatted tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE978]'
  prefs: []
  type: TYPE_PRE
- en: Data Ignored by JSON.stringify()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In objects, `JSON.stringify()` only considers enumerable own properties (see
    [Property Attributes and Property Descriptors](ch17_split_000.html#property_attributes
    "Property Attributes and Property Descriptors")). The following example demonstrates
    the nonenumerable own property `obj.foo` being ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE979]'
  prefs: []
  type: TYPE_PRE
- en: 'How `JSON.stringify()` handles values that are not supported by JSON (such
    as functions and `undefined`) depends on where it encounters them. An unsupported
    value itself leads to `stringify()` returning `undefined` instead of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE980]'
  prefs: []
  type: TYPE_PRE
- en: 'Properties whose values are unsupported are simply ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE981]'
  prefs: []
  type: TYPE_PRE
- en: 'Unsupported values in arrays are stringified as `null`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE982]'
  prefs: []
  type: TYPE_PRE
- en: The toJSON() Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If `JSON.stringify()` encounters an object that has a `toJSON` method, it uses
    that method to obtain a value to be stringified. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE983]'
  prefs: []
  type: TYPE_PRE
- en: 'Dates already have a `toJSON` method that produces an ISO 8601 date string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE984]'
  prefs: []
  type: TYPE_PRE
- en: 'The full signature of a `toJSON` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE985]'
  prefs: []
  type: TYPE_PRE
- en: 'The `key` parameter allows you to stringify differently, depending on context.
    It is always a string and indicates where your object was found in the parent
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: Root position
  prefs: []
  type: TYPE_NORMAL
- en: The empty string
  prefs: []
  type: TYPE_NORMAL
- en: Property value
  prefs: []
  type: TYPE_NORMAL
- en: The property key
  prefs: []
  type: TYPE_NORMAL
- en: Array element
  prefs: []
  type: TYPE_NORMAL
- en: The element’s index as a string
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll demonstrate `toJSON()` via the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE986]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use `JSON.stringify()`, each occurrence of `obj` is replaced with `0`.
    The `toJSON()` method is notified that `obj` was encountered at the property key
    `''foo''` and at the array index 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE987]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in `toJSON()` methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Boolean.prototype.toJSON()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.prototype.toJSON()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.toJSON()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toJSON()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON.parse(text, reviver?)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`JSON.parse(text, reviver?)` parses the JSON data in `text` and returns a JavaScript
    value. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE988]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional parameter `reviver` is a *node visitor* (see [Transforming Data
    via Node Visitors](ch22.html#node_visitors "Transforming Data via Node Visitors"))
    and can be used to transform the parsed data. In this example, we are translating
    date strings to date objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE989]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE990]'
  prefs: []
  type: TYPE_PRE
- en: Transforming Data via Node Visitors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both `JSON.stringify()` and `JSON.parse()` let you transform JavaScript data
    by passing in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON.stringify()` lets you change the JavaScript data before turning it into
    JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON.parse()` parses JSON and then lets you post-process the resulting JavaScript
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JavaScript data is a tree whose compound nodes are arrays and objects and
    whose leaves are primitive values (booleans, numbers, strings, `null`). Let’s
    use the name *node visitor* for the transformation function that you pass in.
    The methods iterate over the tree and call the visitor for each node. It then
    has the option to replace or delete the node. The node visitor has the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE991]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`this`'
  prefs: []
  type: TYPE_NORMAL
- en: The parent of the current node.
  prefs: []
  type: TYPE_NORMAL
- en: '`key`'
  prefs: []
  type: TYPE_NORMAL
- en: A key where the current node is located inside its parent. `key` is always a
    string.
  prefs: []
  type: TYPE_NORMAL
- en: '`value`'
  prefs: []
  type: TYPE_NORMAL
- en: The current node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The root node `root` has no parent. When `root` is visited, a pseudoparent
    is created for it and the parameters have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`this` is `{ '''': root }`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key` is `''''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` is `root`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The node visitor has three options for returning a value:'
  prefs: []
  type: TYPE_NORMAL
- en: Return `value` as it is. Then no change is performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a different value. Then the current node is replaced with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return `undefined`. Then the node is removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is an example of a node visitor. It logs what values have been
    passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE992]'
  prefs: []
  type: TYPE_PRE
- en: Let’s use this function to examine how the JSON methods iterate over JavaScript
    data.
  prefs: []
  type: TYPE_NORMAL
- en: JSON.stringify()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The special root node comes first, in a prefix iteration (parent before children).
    The first node that is visited is always the pseudoroot. The last line that is
    displayed after each call is the string returned by `stringify()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE993]'
  prefs: []
  type: TYPE_PRE
- en: JSON.parse()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The leaves come first, in a postfix iteration (children before parent). The
    last node that is visited is always the pseudoroot. The last line that is displayed
    after each call is the JavaScript value returned by `parse()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE994]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 23. Standard Global Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter is a reference for the global variables standardized by the ECMAScript
    specification. Web browsers have more global variables, which are [listed on MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window).
    All global variables are (own or inherited) properties of the global object (`window`
    in browsers; see [The Global Object](ch16.html#global_object "The Global Object")).
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For details on the following constructors, see the sections indicated in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array` ([The Array Constructor](ch18.html#array_constructor "The Array Constructor"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean` ([Wrapper Objects for Primitives](ch08.html#wrapper_objects "Wrapper
    Objects for Primitives"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date` ([The Date Constructor](ch20.html#date_constructors "The Date Constructor"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Function` ([Evaluating Code Using new Function()](ch23.html#function_constructor
    "Evaluating Code Using new Function()"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number` ([Wrapper Objects for Primitives](ch08.html#wrapper_objects "Wrapper
    Objects for Primitives"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object` ([Converting Any Value to an Object](ch17_split_000.html#toobject
    "Converting Any Value to an Object"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegExp` ([Creating a Regular Expression](ch19.html#creating_regexps "Creating
    a Regular Expression"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String` ([Wrapper Objects for Primitives](ch08.html#wrapper_objects "Wrapper
    Objects for Primitives"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For details on these constructors, see [Error Constructors](ch14.html#error_constructors
    "Error Constructors"):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EvalError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RangeError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReferenceError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SyntaxError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypeError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URIError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonconstructor Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several global functions are not constructors. They are listed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding and Decoding Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following functions handle several ways of URI encoding and decoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '`encodeURI(uri)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Percent-encodes special characters in `uri`. Special characters are all Unicode
    characters except for the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| URI characters: | `; , / ? : @ & = + $ #` |'
  prefs: []
  type: TYPE_TB
- en: '| Not encoded either: | `a-z A-Z 0-9 - _ . ! ~ * '' ( )` |'
  prefs: []
  type: TYPE_TB
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE995]'
  prefs: []
  type: TYPE_PRE
- en: '`encodeURIComponent(uriComponent)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Percent-encodes all characters in `uriComponent`, except for:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Not encoded: | `a-z A-Z 0-9 - _ . ! ~ * '' ( )` |'
  prefs: []
  type: TYPE_TB
- en: 'In contrast to `encodeURI`, characters that are significant in URLs and filenames
    are encoded, too. You can thus use this function to turn any text into a legal
    filename or URL path segment. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE996]'
  prefs: []
  type: TYPE_PRE
- en: '`decodeURI(encodedURI)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decodes a percent-encoded URI that has been produced by `encodeURI`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE997]'
  prefs: []
  type: TYPE_PRE
- en: '`encodeURI` does not encode URI characters and `decodeURI` does not decode
    them, even if they have been correctly encoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE998]'
  prefs: []
  type: TYPE_PRE
- en: '`decodeURIComponent(encodedURIComponent)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decodes a percent-encoded URI component that has been produced by `encodeURIComponent`.
    In contrast to `decodeURI`, all percent-encoded characters are decoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE999]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are deprecated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`escape(str)` percent-encodes `str`. It is deprecated because it does not handle
    non-ASCII characters properly. Use `encodeURIComponent()` instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unescape(str)` percent-decodes `str`. It is deprecated because it does not
    handle non-ASCII characters properly. Use `decodeURIComponent()` instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Categorizing and Parsing Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods help with categorizing and parsing numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isFinite(number)` ([Checking for Infinity](ch11.html#isFinite "Checking for
    Infinity"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isNaN(value)` ([Pitfall: checking whether a value is NaN](ch11.html#isNaN
    "Pitfall: checking whether a value is NaN"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseFloat(string)` ([parseFloat()](ch11.html#parseFloat "parseFloat()"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseInt(string, radix)` ([Integers via parseInt()](ch11.html#parseInt "Integers
    via parseInt()"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically Evaluating JavaScript Code via eval() and new Function()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section examines how one can dynamically evaluate code in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating Code Using eval()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1000]'
  prefs: []
  type: TYPE_PRE
- en: 'evaluates the JavaScript code in `str`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1001]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `eval()` parses in statement context (see [Expressions Versus Statements](ch07.html#expr_vs_stmt
    "Expressions Versus Statements")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1002]'
  prefs: []
  type: TYPE_PRE
- en: Use eval() in strict mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For `eval()`, you really should use strict mode (see [Strict Mode](ch07.html#strict_mode
    "Strict Mode")). In sloppy mode, evaluated code can create local variables in
    the surrounding scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1003]'
  prefs: []
  type: TYPE_PRE
- en: 'That can’t happen in strict mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1004]'
  prefs: []
  type: TYPE_PRE
- en: However, even in strict mode, evaluated code still has read and write access
    to variables in surrounding scopes. To prevent such access, you need to call `eval()`
    indirectly.
  prefs: []
  type: TYPE_NORMAL
- en: Indirect eval() evaluates in global scope
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two ways to invoke `eval()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Directly](http://ecma-international.org/ecma-262/5.1/#sec-15.1.2.1.1). Via
    a direct call to a function whose name is “eval.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indirectly. In some other way (via `call()`, as a method of `window`, by storing
    it under a different name and calling it there, etc.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we have already seen, direct `eval()` executes code in the current scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1005]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, indirect `eval()` executes it in global scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1006]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanation of (1): When you refer to a variable via its name, the initial
    result is a so-called [*reference*](http://ecma-international.org/ecma-262/5.1/#sec-8.7),
    a data structure with two main fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`base` points to the *environment*, the data structure in which the variable’s
    value is stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`referencedName` is the name of the variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During an `eval()` function call, the function call operator (the parentheses)
    encounters a reference to `eval` and can determine the name of the function to
    be called. Therefore, such a function call triggers a direct `eval()`. You can,
    however, force an indirect `eval()` by not giving the call operator a reference.
    That is achieved by retrieving the value of the reference before applying the
    operator. The comma operator does that for us in line (1). This operator evaluates
    the first operand and returns the result of evaluating the second operand. The
    evaluation always produces values, which means that references are resolved and
    function names are lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indirectly evaluated code is always sloppy. That is a consequence of the code
    being evaluated independently of its current surroundings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1007]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating Code Using new Function()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The constructor `Function()` has the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1008]'
  prefs: []
  type: TYPE_PRE
- en: 'It creates a function whose zero or more parameters have the names `param1`,
    `parem2`, and so on, and whose body is `funcBody`; that is, the created function
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1009]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use `new Function()` to create a function `f` that returns the sum of
    its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1010]'
  prefs: []
  type: TYPE_PRE
- en: Similar to indirect `eval()`, `new Function()` creates functions whose scope
    is global:^([[16](#ftn.id1065911)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1011]'
  prefs: []
  type: TYPE_PRE
- en: 'Such functions are also sloppy by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1012]'
  prefs: []
  type: TYPE_PRE
- en: eval() Versus new Function()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally, it is better to use `new Function()` than `eval()` in order to evaluate
    code: the function parameters provide a clear interface to the evaluated code
    and you don’t need the slightly awkward syntax of indirect `eval()` to ensure
    that the evaluated code can access only global variables (in addition to its own).'
  prefs: []
  type: TYPE_NORMAL
- en: Best Practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should avoid `eval()` and `new Function()`. Dynamically evaluating code
    is slow and a potential security risk. It also prevents most tools (such as IDEs)
    that use static analysis from considering the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, there are better alternatives. For example, Brendan Eich recently [tweeted](http://bit.ly/1fwpWrB)
    an antipattern used by programmers who want to access a property whose name is
    stored in a variable `propName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1013]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea makes sense: the dot operator only supports fixed, statically provided
    property keys. In this case, the property key is only known at runtime, which
    is why `eval()` is needed in order to use that operator. Luckily, JavaScript also
    has the bracket operator, which does accept dynamic property keys. Therefore,
    the following is a better version of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1014]'
  prefs: []
  type: TYPE_PRE
- en: You also shouldn’t use `eval()` or `new Function()` to parse JSON data. That
    is unsafe. Either rely on ECMAScript 5’s built-in support for JSON (see [Chapter 22](ch22.html
    "Chapter 22. JSON")) or use a library.
  prefs: []
  type: TYPE_NORMAL
- en: Legitimate use cases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are a few legitimate, albeit advanced, use cases for `eval()` and `new
    Function()`: configuration data with functions (which JSON does not allow), template
    libraries, interpreters, command lines, and module systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This was a relatively high-level overview of dynamically evaluating code in
    JavaScript. If you want to dig deeper, you can take a look at the article [“Global
    eval. What are the options?”](http://perfectionkills.com/global-eval-what-are-the-options/)
    by kangax.
  prefs: []
  type: TYPE_NORMAL
- en: The Console API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most JavaScript engines, there is a global object, `console`, with methods
    for logging and debugging. That object is not part of the language proper, but
    has become a de facto standard. Since their main purpose is debugging, the `console`
    methods will most frequently be used during development and rarely in deployed
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This section provides an overview of the console API. It documents the status
    quo as of Chrome 32, Firebug 1.12, Firefox 25, Internet Explorer 11, Node.js 0.10.22,
    and Safari 7.0.
  prefs: []
  type: TYPE_NORMAL
- en: How Standardized Is the Console API Across Engines?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The implementations of the console API vary greatly and are constantly changing.
    If you want authoritative documentation, you have two options. First, you can
    look at standard-like overviews of the API:'
  prefs: []
  type: TYPE_NORMAL
- en: Firebug first implemented the console API, and the [documentation](http://bit.ly/1fwq1vk)
    in its wiki is the closest thing to a standard there currently is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, Brian Kardell and Paul Irish are working on a [specification](http://bit.ly/1fwq7mX)
    for the API, which should lead to more consistent behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, you can look at the documentation of various engines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chrome](https://developers.google.com/chrome-developer-tools/docs/console-api/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Firebug](https://getfirebug.com/wiki/index.php/Console_API)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Firefox](https://developer.mozilla.org/en-US/docs/Web/API/console)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Internet Explorer](http://msdn.microsoft.com/en-us/library/ie/hh772183.aspx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Node.js](http://nodejs.org/api/stdio.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Safari](http://bit.ly/1fwq9er)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a bug in Internet Explorer 9\. In that browser, the `console` object
    exists only if the developer tools were open at least once. That means that you
    get a `ReferenceError` if you refer to `console` and the tools weren’t open before.
    As a workaround, you can check whether `console` exists and create a dummy implementation
    if it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console API includes the following logging methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.clear()`'
  prefs: []
  type: TYPE_NORMAL
- en: Clear the console.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.debug(object1, object2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: Prefer `console.log()`, which does the same as this method.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.error(object1, object2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: Log the parameters to the console. In browsers, the logged content may be marked
    by an “error” icon and/or include a stack trace or a link to the code.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.exception(errorObject, object1?, ...])` [Firebug-only]'
  prefs: []
  type: TYPE_NORMAL
- en: Log `object1` etc. and show an interactive stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.info(object1?, object2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: Log the parameters to the console. In browsers, the logged content may be marked
    by an “info” icon and/or include a stack trace or a link to the code.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(object1?, object2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log the parameters to the console. If the first parameter is a `printf`-style
    format string, use it to print the remaining parameters. For example (Node.js
    REPL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1015]'
  prefs: []
  type: TYPE_PRE
- en: The only dependable cross-platform formatting directive is `%s`. Node.js supports
    `%j` to format data as JSON; browsers tend to support directives that log something
    interactive to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.trace()`'
  prefs: []
  type: TYPE_NORMAL
- en: Logs a stack trace (which is interactive in many browsers).
  prefs: []
  type: TYPE_NORMAL
- en: '`console.warn(object1?, object2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: Log the parameters to the console. In browsers, the logged content may be marked
    by a “warning” icon and/or include a stack trace or a link to the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Support on various platforms is indicated in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `clear` | ✓ | ✓ |  | ✓ |  | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `debug` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `error` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| *`exception`* |  | ✓ |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `info` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `log` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `trace` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `warn` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '`exception` has been typeset in italics, because it is supported only on a
    single platform.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking and Counting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console API includes the following checking and counting methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.assert(expr, obj?)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `expr` is `false`, log `obj` to the console and throw an exception. If it
    is `true`, do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.count(label?)`'
  prefs: []
  type: TYPE_NORMAL
- en: Count how many times the line with this statement is executed with this label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Support on various platforms is indicated in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `assert` | ✓ | ✓ |  | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | ✓ | ✓ |  | ✓ |  | ✓ |'
  prefs: []
  type: TYPE_TB
- en: Formatted Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console API includes the following methods for formatted logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.dir(object)`'
  prefs: []
  type: TYPE_NORMAL
- en: Print a representation of the object to the console. In browsers, that representation
    can be explored interactively.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.dirxml(object)`'
  prefs: []
  type: TYPE_NORMAL
- en: Print the XML source tree of an HTML or XML element.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.group(object1?, object2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: Log the objects to the console and open a nested block that contains all future
    logged content. Close the block by calling `console.groupEnd()`. The block is
    initially expanded, but can be collapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.groupCollapsed(object1?, object2?, ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: Works like `console.group()`, but the block is initially collapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.groupEnd()`'
  prefs: []
  type: TYPE_NORMAL
- en: Close a group that has been opened by `console.group()` or `console.group` `Collapsed()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.table(data, columns?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print an array as a table, one element per row. The optional parameter `columns`
    specifies which properties/array indices are shown in the columns. If that parameter
    is missing, all property keys are used as table columns. Missing properties and
    array elements show up as `undefined` in columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1016]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting table is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (index) | firstName | lastName | age |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | “Jane” | “Bond” | undefined |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | “Lars” | “Croft” | 72 |'
  prefs: []
  type: TYPE_TB
- en: 'Support on various platforms is indicated in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dir` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `dirxml` | ✓ | ✓ |  | ✓ |  | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `group` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `groupCollapsed` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `groupEnd` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `table` | ✓ | ✓ |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: Profiling and Timing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console API includes the following methods for profiling and timing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.markTimeline(label)` [Safari-only]'
  prefs: []
  type: TYPE_NORMAL
- en: The same as `console.timeStamp`.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.profile(title?)`'
  prefs: []
  type: TYPE_NORMAL
- en: Turn on profiling. The optional `title` is used for the profile report.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.profileEnd()`'
  prefs: []
  type: TYPE_NORMAL
- en: Stop profiling and print the profile report.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.time(label)`'
  prefs: []
  type: TYPE_NORMAL
- en: Start a timer whose label is `label`.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.timeEnd(label)`'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the timer whose label is `label` and print the time that has elapsed since
    starting it.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.timeStamp(label?)`'
  prefs: []
  type: TYPE_NORMAL
- en: Log a timestamp with the given `label`. May be logged to the console or a timeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Support on various platforms is indicated in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *`markTimeline`* |  |  |  |  |  | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `profile` | ✓ | ✓ | (devtools) | ✓ |  | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `profileEnd` | ✓ | ✓ | (devtools) | ✓ |  | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `time` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `timeEnd` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `timeStamp` | ✓ | ✓ |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '`markTimeline` has been typeset in italics, because it is supported only on
    a single platform. The (devtools) designation means that the developer tools must
    be open in order for the method to work.^([[17](#ftn.id1069062)])'
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces and Special Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following global variables serve as namespaces for functions. For details,
    see the material indicated in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON`'
  prefs: []
  type: TYPE_NORMAL
- en: JSON API functionality ([Chapter 22](ch22.html "Chapter 22. JSON"))
  prefs: []
  type: TYPE_NORMAL
- en: '`Math`'
  prefs: []
  type: TYPE_NORMAL
- en: Math API functionality ([Chapter 21](ch21.html "Chapter 21. Math"))
  prefs: []
  type: TYPE_NORMAL
- en: '`Object`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Metaprogramming functionality ([Cheat Sheet: Working with Objects](ch17_split_001.html#oop_cheat_sheet
    "Cheat Sheet: Working with Objects"))'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following global variables contain special values. For more on them, review
    the material indicated in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A value expressing that something does not exist ([undefined and null](ch08.html#undefined_null
    "undefined and null")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1017]'
  prefs: []
  type: TYPE_PRE
- en: '`NaN`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A value expressing that something is “not a number” ([NaN](ch11.html#nan "NaN")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1018]'
  prefs: []
  type: TYPE_PRE
- en: '`Infinity`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A value denoting numeric infinity ∞ ([Infinity](ch11.html#infinity "Infinity")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1019]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[16](#id1065911)]) Mariusz Nowak (@medikoo) told me that code evaluated by
    `Function` is sloppy by default, everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[17](#id1069062)]) Thanks to Matthias Reuter (@gweax) and Philipp Kyeck (@pkyeck),
    who contributed to this section.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 24. Unicode and JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter is a brief introduction to Unicode and how it is handled in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode History
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unicode was started in 1987, by Joe Becker (Xerox), Lee Collins (Apple), and
    Mark Davis (Apple). The idea was to create a universal character set, as there
    were many incompatible standards for encoding plain text at that time: numerous
    variations of 8-bit ASCII, Big Five (Traditional Chinese), GB 2312 (Simplified
    Chinese), and more. Before Unicode, no standard for multilingual plain text existed,
    but there were rich-text systems (such as Apple’s WorldScript) that allowed you
    to combine multiple encodings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first Unicode draft proposal was published in 1988\. Work continued afterward
    and the working group expanded. The [*Unicode Consortium*](http://www.unicode.org/consortium/consort.html)
    was incorporated on January 3, 1991:'
  prefs: []
  type: TYPE_NORMAL
- en: The Unicode Consortium is a non-profit corporation devoted to developing, maintaining,
    and promoting software internationalization standards and data, particularly the
    Unicode Standard [...]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The first volume of the Unicode 1.0 standard was published in October 1991,
    and the second in June 1992.
  prefs: []
  type: TYPE_NORMAL
- en: Important Unicode Concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea of a character may seem a simple one, but there are many aspects to
    it. That’s why Unicode is such a complex standard. The following are important
    basic concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Characters and graphemes
  prefs: []
  type: TYPE_NORMAL
- en: These two terms mean something quite similar. Characters are digital entities,
    while graphemes are atomic units of written languages (alphabetic letters, typographic
    ligatures, Chinese characters, punctuation marks, etc.). Programmers think in
    characters, but users think in graphemes. Sometimes several characters are used
    to represent a single grapheme. For example, we can produce the single grapheme
    ô by combining the character *o* and the character ^ (the circumflex accent).
  prefs: []
  type: TYPE_NORMAL
- en: Glyph
  prefs: []
  type: TYPE_NORMAL
- en: This is a concrete way of displaying a grapheme. Sometimes, the same grapheme
    is displayed differently, depending on its context or other factors. For example,
    the graphemes *f* and *i* can be presented as a glyph *f* and a glyph *i*, connected
    by a ligature glyph, or without a ligature.
  prefs: []
  type: TYPE_NORMAL
- en: Code points
  prefs: []
  type: TYPE_NORMAL
- en: Unicode represents the characters it supports via numbers called *code points*.
    The hexadecimal range of code points is 0x0 to 0x10FFFF (17 times 16 bits).
  prefs: []
  type: TYPE_NORMAL
- en: Code units
  prefs: []
  type: TYPE_NORMAL
- en: To store or transmit code points, we encode them as *code units*, pieces of
    data with a fixed length. The length is measured in bits and determined by an
    encoding scheme, of which Unicode has several—for example, UTF-8 and UTF-16\.
    The number in the name indicates the length of the code unit, in bits. If a code
    point is too large to fit into a single code unit, it must be broken up into multiple
    units; that is, the number of code units needed to represent a single code point
    can vary.
  prefs: []
  type: TYPE_NORMAL
- en: BOM (byte order mark)
  prefs: []
  type: TYPE_NORMAL
- en: 'If a code unit is larger than a single byte, byte ordering matters. The BOM
    is a single pseudocharacter (possibly encoded as multiple code units) at the beginning
    of a text that indicates whether the code units are *big endian* (most significant
    bytes come first) or *little endian* (least significant bytes come first). The
    default for texts without a BOM is big endian. The BOM also indicates the encoding
    that is used; it is different for UTF-8, UTF-16, and so on. Additionally, it serves
    as a marker for Unicode if web browsers have no other information regarding the
    encoding of a text. However, the BOM is not used very often, for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 is by far the most popular Unicode encoding and does not need a BOM, because
    there is only one way of ordering bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several character encodings specify a fixed byte ordering. Then a BOM must not
    be used. Examples include UTF-16BE (UTF-16 big endian), UTF-16LE, UTF-32BE, and
    UTF-32LE. This is a safer way of handling byte ordering, because metadata and
    data stay separate and can’t be mixed up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normalization
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the same grapheme can be represented in several ways. For example,
    the grapheme ö can be represented as a single code point or as an *o* followed
    by a combining character ¨ (diaeresis, double dot). Normalization is about translating
    a text to a canonical representation; equivalent code points and sequences of
    code points are all translated to the same code point (or sequence of code points).
    That is useful for text processing (e.g., to search for text). Unicode specifies
    several normalizations.
  prefs: []
  type: TYPE_NORMAL
- en: Character properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Unicode character is assigned several properties by the specification,
    some of which are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Name*. An English name, composed of uppercase letters A–Z, digits 0–9, hyphen
    (-), and <space>. Two examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “λ” has the name “GREEK SMALL LETTER LAMBDA.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “!” has the name “EXCLAMATION MARK.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*General category*](http://bit.ly/1fwsjL9). Partitions characters into categories
    such as letter, uppercase letter, number, and punctuation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Age*. With what version of Unicode was the character introduced (1.0, 1.1.,
    2.0, etc.)?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deprecated*. Is the use of the character discouraged?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*And many more*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code Points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The range of the code points was initially 16 bits. With Unicode version 2.0
    (July 1996), it was expanded: it is now divided into 17 *planes*, numbered from
    0 to 16\. Each plane comprises 16 bits (in hexadecimal notation: 0x0000–0xFFFF).
    Thus, in the hexadecimal ranges that follow, digits beyond the four bottom ones
    contain the number of the plane.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plane 0, Basic Multilingual Plane (BMP): 0x0000–0xFFFF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plane 1, Supplementary Multilingual Plane (SMP): 0x10000–0x1FFFF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plane 2, Supplementary Ideographic Plane (SIP): 0x20000–0x2FFFF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planes 3–13, Unassigned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plane 14, Supplementary Special-Purpose Plane (SSP): 0xE0000–0xEFFFF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Planes 15–16, Supplementary Private Use Area (S PUA A/B): 0x0F0000–0x10FFFF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planes 1–16 are called *supplementary planes* or *astral planes*.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode Encodings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*UTF-32* (Unicode Transformation Format 32) is a format with 32-bit code units.
    Any code point can be encoded by a single code unit, making this the only fixed-length
    encoding; for other encodings, the number of units needed to encode a point varies.'
  prefs: []
  type: TYPE_NORMAL
- en: '*UTF-16* is a format with 16-bit code units that needs one to two units to
    represent a code point. BMP code points can be represented by single code units.
    Higher code points are 20 bit (16 times 16 bits), after 0x10000 (the range of
    the BMP) is subtracted. These bits are encoded as two code units (a so-called
    *surrogate pair*):'
  prefs: []
  type: TYPE_NORMAL
- en: Leading surrogate
  prefs: []
  type: TYPE_NORMAL
- en: 'Most significant 10 bits: stored in the range 0xD800–0xDBFF. Also called *high-surrogate
    code unit*.'
  prefs: []
  type: TYPE_NORMAL
- en: Trailing surrogate
  prefs: []
  type: TYPE_NORMAL
- en: 'Least significant 10 bits: stored in the range 0xDC00–0xDFFF. Also called *low-surrogate
    code unit*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table (adapted from Unicode Standard 6.2.0, Table 3-5) visualizes
    how the bits are distributed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code point | UTF-16 code unit(s) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| xxxxxxxxxxxxxxxx (16 bits) | xxxxxxxxxxxxxxxx |'
  prefs: []
  type: TYPE_TB
- en: '| pppppxxxxxxyyyyyyyyyy (21 bits = 5+6+10 bits) | 110110qqqqxxxxxx 110111yyyyyyyyyy
    (qqqq = ppppp − 1) |'
  prefs: []
  type: TYPE_TB
- en: 'To enable this encoding scheme, the BMP has a hole with unused code points
    whose range is 0xD800–0xDFFF. Therefore, the ranges of leading surrogates, trailing
    surrogates, and BMP code points are disjoint, making decoding robust in the face
    of errors. The following function encodes a code point as UTF-16 (later we’ll
    see an example of using it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1020]'
  prefs: []
  type: TYPE_PRE
- en: '*UCS-2*, a deprecated format, uses 16-bit code units to represent (only!) the
    code points of the BMP. When the range of Unicode code points expanded beyond
    16 bits, UTF-16 replaced UCS-2.'
  prefs: []
  type: TYPE_NORMAL
- en: '*UTF-8* has 8-bit code units. It builds a bridge between the legacy ASCII encoding
    and Unicode. ASCII has only 128 characters, whose numbers are the same as the
    first 128 Unicode code points. UTF-8 is backward compatible, because all ASCII
    codes are valid code units. In other words, a single code unit in the range 0–127
    encodes a single code point in the same range. Such code units are marked by their
    highest bit being zero. If, on the other hand, the highest bit is one, then more
    units will follow, to provide the additional bits for the higher code points.
    That leads to the following encoding scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '0000–007F: 0xxxxxxx (7 bits, stored in 1 byte)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0080–07FF: 110xxxxx, 10xxxxxx (5+6 bits = 11 bits, stored in 2 bytes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0800–FFFF: 1110xxxx, 10xxxxxx, 10xxxxxx (4+6+6 bits = 16 bits, stored in 3
    bytes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '10000–1FFFFF: 11110xxx, 10xxxxxx, 10xxxxxx, 10xxxxxx (3+6+6+6 bits = 21 bits,
    stored in 4 bytes). The highest code point is 10FFFF, so UTF-8 has some extra
    room.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the highest bit is not 0, then the number of ones before the zero indicates
    how many code units there are in a sequence. All code units after the initial
    one have the bit prefix 10\. Therefore, the ranges of initial code units and subsequent
    code units are disjoint, which helps with recovering from encoding errors.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 has become the most popular Unicode format. Initially, its popularity
    was due to its backward compatibility with ASCII. Later, it gained traction because
    of its broad and consistent support across operating systems, programming environments,
    and applications.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Source Code and Unicode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways in which JavaScript handles Unicode source code: internally
    (during parsing) and externally (while loading a file).'
  prefs: []
  type: TYPE_NORMAL
- en: Source Code Internally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Internally, JavaScript source code is treated as a sequence of UTF-16 code
    units. According to [Section 6](http://ecma-international.org/ecma-262/5.1/#sec-6)
    of the EMCAScript specification:'
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript source text is represented as a sequence of characters in the Unicode
    character encoding, version 3.0 or later. [...] ECMAScript source text is assumed
    to be a sequence of 16-bit code units for the purposes of this specification.
    [...] If an actual source text is encoded in a form other than 16-bit code units,
    it must be processed as if it was first converted to UTF-16.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In identifiers, string literals, and regular expression literals, any code
    unit can also be expressed via a Unicode escape sequence `\uHHHH`, where `HHHH`
    are four hexadecimal digits. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1021]'
  prefs: []
  type: TYPE_PRE
- en: That means that you can use Unicode characters in literals and variable names,
    without leaving the ASCII range in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In string literals, an additional kind of escape is available: *hexadecimal
    escape sequences* with two-digit hexadecimal numbers that represent code units
    in the range 0x00–0xFF. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1022]'
  prefs: []
  type: TYPE_PRE
- en: Source Code Externally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While UTF-16 is used internally, JavaScript source code is usually not stored
    in that format. When a web browser loads a source file via a `<script>` tag, it
    determines the encoding [as follows](http://bit.ly/1fwstC9):'
  prefs: []
  type: TYPE_NORMAL
- en: If the file starts with a BOM, the encoding is a UTF variant, depending on what
    BOM is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, if the file is loaded via HTTP(S), then the `Content-Type` header
    can specify an encoding, via the `charset` parameter. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1023]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The correct *media type* (formerly known as *MIME type*) for JavaScript files
    is `application/javascript`. However, older browsers (e.g., Internet Explorer
    8 and earlier) work most reliably with `text/javascript`. Unfortunately, the [default
    value](http://bit.ly/1fwsvKe) for the attribute `type` of `<script>` tags is `text/javascript`.
    At least you can omit that attribute for JavaScript; there is no benefit in including
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if the `<script>` tag has the attribute `charset`, then that encoding
    is used. Even though the attribute `type` holds a valid media type, that type
    must not have the parameter `charset` (like in the aforementioned `Content-Type`
    header). That ensures that the values of `charset` and `type` don’t clash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, the encoding of the document is used, in which the `<script>` tag
    resides. For example, this is the beginning of an HTML5 document, where a `<meta>`
    tag declares that the document is encoded as UTF-8:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1024]'
  prefs: []
  type: TYPE_PRE
- en: It is highly recommended that you always specify an encoding. If you don’t,
    a locale-specific [default encoding](http://bit.ly/1oODGWp) is used. In other
    words, people will see the file differently in different countries. Only the lowest
    7 bits are relatively stable across locales.
  prefs: []
  type: TYPE_NORMAL
- en: 'My recommendations can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For your own application, you can use Unicode. But you must specify the encoding
    of the app’s HTML page as UTF-8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For libraries, it’s safest to release code that is ASCII (7 bit).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some minification tools can translate source with Unicode code points beyond
    7 bit to source that is “7-bit clean.” They do so by replacing non-ASCII characters
    with Unicode escapes. For example, the following invocation of [UglifyJS](https://github.com/mishoo/UglifyJS2)
    translates the file *test.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1025]'
  prefs: []
  type: TYPE_PRE
- en: 'The file *test.js* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1026]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of UglifyJS looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1027]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following negative example. For a while, the library D3.js was
    published in UTF-8\. That caused an [error](https://github.com/mbostock/d3/issues/1195)
    when it was loaded from a page whose encoding was not UTF-8, because the code
    contained statements such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1028]'
  prefs: []
  type: TYPE_PRE
- en: 'The identifiers π and ε were not decoded correctly and not recognized as valid
    variable names. Additionally, some string literals with code points beyond 7 bit
    weren’t decoded correctly either. As a workaround, you could load the code by
    adding the appropriate `charset` attribute to the `<script>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1029]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript Strings and Unicode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JavaScript string is a sequence of UTF-16 code units. According to the ECMAScript
    specification, [Section 8.4](http://ecma-international.org/ecma-262/5.1/#sec-8.4):'
  prefs: []
  type: TYPE_NORMAL
- en: When a String contains actual textual data, each element is considered to be
    a single UTF-16 code unit.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Escape Sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned before, you can use Unicode escape sequences and hexadecimal escape
    sequences in string literals. For example, you can produce the character ö by
    combining an *o* with a diaeresis (code point 0x0308):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1030]'
  prefs: []
  type: TYPE_PRE
- en: This works in JavaScript command lines, such as web browser consoles and the
    Node.js REPL. You can also insert this kind of string into the DOM of a web page.
  prefs: []
  type: TYPE_NORMAL
- en: Refering to Astral Plane Characters via Escapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many nice Unicode symbol tables on the Web. Take a look at Tim Whitlock’s
    [“Emoji Unicode Tables”](http://apps.timwhitlock.info/emoji/tables/unicode) and
    be amazed by how many symbols there are in modern Unicode fonts. None of the symbols
    in the table are images; they are all font glyphs. Let’s assume you want to display
    a Unicode character via JavaScript that is in an astral plane (obviously, there
    is a risk when doing so: not all fonts support all such characters). For example,
    consider a cow, code point 0x1F404: ![](images/spjs_24in01.png.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can copy the character and paste it directly into your Unicode-encoded
    JavaScript source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/spjs_24in02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'JavaScript engines will decode the source (which is most often in UTF-8) and
    create a string with two UTF-16 code units. Alternatively, you can compute the
    two code units yourself and use Unicode escape sequences. There are web apps that
    perform this computation, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[UTF Converter](http://macchiato.com/unicode/convert.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“JavaScript escapes”](http://mothereff.in/js-escapes) by Mathias Bynens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The previously defined function `toUTF16` performs it, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1031]'
  prefs: []
  type: TYPE_PRE
- en: 'The UTF-16 surrogate pair (0xD83D, 0xDC04) does indeed encode the cow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/spjs_24in03.png)'
  prefs: []
  type: TYPE_IMG
- en: Counting Characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a string contains a surrogate pair (two code units encoding a single code
    point), then the `length` property doesn’t count graphemes anymore. It counts
    code units:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/spjs_24in04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This can be fixed via libraries, such as Mathias Bynens’s [Punycode.js](https://github.com/bestiejs/punycode.js),
    which is bundled with Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1032]'
  prefs: []
  type: TYPE_PRE
- en: Unicode Normalization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to search in strings or compare them, then you need to normalize—for
    example, via the library [unorm](https://github.com/walling/unorm) (by Bjarke
    Walling).
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Regular Expressions and Unicode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Support for Unicode in JavaScript’s regular expressions (see [Chapter 19](ch19.html
    "Chapter 19. Regular Expressions")) is very limited. For example, there is no
    way to match Unicode categories such as “uppercase letter.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Line terminators influence matching. A line terminator is one of four characters,
    specified in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code unit | Name | Character escape sequence |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| \u000A | Line feed | `\n` |'
  prefs: []
  type: TYPE_TB
- en: '| \u000D | Carriage return | `\r` |'
  prefs: []
  type: TYPE_TB
- en: '| \u2028 | Line separator |  |'
  prefs: []
  type: TYPE_TB
- en: '| \u2029 | Paragraph separator |  |'
  prefs: []
  type: TYPE_TB
- en: 'The following regular expression constructs are based on Unicode:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\s \S` (whitespace, nonwhitespace) have Unicode-based definitions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1033]'
  prefs: []
  type: TYPE_PRE
- en: '`.` (dot) matches all code units (not code points!) except line terminators.
    See the next section to learn how to match any code point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiline mode `/m`: In multiline mode, the assertion `^` matches at the beginning
    of the input and after line terminators. The assertion `$` matches before line
    terminators and at the end of the input. In nonmultiline mode, they match only
    at the beginning or the end of the input, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other important character classes have definitions that are based on ASCII,
    not on Unicode:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\d \D` (digits, nondigits): A digit is equivalent to `[0-9]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\w \W` (word characters, nonword characters): A word character is equivalent
    to `[A-Za-z0-9_]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\b \B` (at word breaks, inside words): Words are sequences of word characters
    (`[A-Za-z0-9_]`). For example, in the string `''über''`, the character class escape
    `\b` sees the character *b* as starting a word:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1034]'
  prefs: []
  type: TYPE_PRE
- en: Matching Any Code Unit and Any Code Point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To match any code unit, you can use `[\s\S]`; see [Atoms: General](ch19.html#regex_atoms_general
    "Atoms: General").'
  prefs: []
  type: TYPE_NORMAL
- en: To match any code point, you need to use:^([[18](#ftn.id1072129)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1035]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding pattern works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1036]'
  prefs: []
  type: TYPE_PRE
- en: As all of these ranges are disjoint, the pattern will correctly match code points
    in well-formed UTF-16 strings.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A few libraries help with handling Unicode in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Regenerate](https://github.com/mathiasbynens/regenerate) helps with generating
    ranges like the preceding one, for matching any code unit. It is meant to be used
    as part of a build tool, but also works dynamically, for trying out things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[XRegExp](http://xregexp.com) is a regular expression library that has an [official
    add-on](http://xregexp.com/plugins/#unicode) for matching Unicode categories,
    scripts, blocks, and properties via one of the following three constructs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1037]'
  prefs: []
  type: TYPE_PRE
- en: For example, `\p{Letter}` matches letters in various alphabets while `\p{^Letter}`
    and `\P{Letter}` both match all other code points. [Chapter 30](ch30.html "Chapter 30. Libraries")
    contains a brief overview of XRegExp.
  prefs: []
  type: TYPE_NORMAL
- en: The ECMAScript Internationalization API (see [The ECMAScript Internationalization
    API](ch30.html#i18n_api "The ECMAScript Internationalization API")) provides Unicode-aware
    collation (sorting and searching of strings) and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommended Reading and Chapter Sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on Unicode, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Wikipedia has several good entries on [Unicode](http://en.wikipedia.org/wiki/Unicode)
    and its terminology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Unicode.org](http://www.unicode.org/), the official website of the Unicode
    Consortium, and its [FAQ](http://www.unicode.org/faq/) are also good resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joel Spolsky’s introductory article [“The Absolute Minimum Every Software Developer
    Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)”](http://www.joelonsoftware.com/articles/Unicode.html)
    is helpful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For information on Unicode support in JavaScript, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“JavaScript’s internal character encoding: UCS-2 or UTF-16?”](http://mathiasbynens.be/notes/javascript-encoding)
    by Mathias Bynens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“JavaScript, Regex, and Unicode”](http://bit.ly/1oOE0oh) by Steven Levithan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acknowledgments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following people contributed to this chapter: Mathias Bynens (@mathias),
    Anne van Kesteren ‏(@annevk), and Calvin Metcalf ‏(@CWMma).'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[18](#id1072129)]) Strictly speaking, any [Unicode scalar value](http://www.unicode.org/glossary/#unicode_scalar_value).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 25. New in ECMAScript 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter lists features that are available only in ECMAScript 5\. Should
    you have to work with older JavaScript engines, you should avoid these features
    or enable some of them via a library (how is described later). Note that normally,
    this book assumes that you are working with modern engines, which fully support
    ECMAScript 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ECMAScript 5 specification contains the following description of its scope:'
  prefs: []
  type: TYPE_NORMAL
- en: The fifth edition of ECMAScript (published as ECMA-262 5th edition)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: codifies de facto interpretations of the language specification that have become
    common among browser implementations and
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: adds support for new features that have emerged since the publication of the
    third edition. Such features include
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: accessor properties,
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: reflective creation and inspection of objects,
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: program control of property attributes,
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: additional array manipulation functions,
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: support for the JSON object encoding format, and
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a strict mode that provides enhanced error checking and program security.
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: New Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new features included in ECMAScript 5 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Strict mode (see [Strict Mode](ch07.html#strict_mode "Strict Mode"))
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting the following line first in a file or a function switches on the so-called
    *strict mode* that makes JavaScript a cleaner language by forbidding some features,
    performing more checks, and throwing more exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1038]'
  prefs: []
  type: TYPE_PRE
- en: Accessors (see [Accessors (Getters and Setters)](ch17_split_000.html#getters_setters
    "Accessors (Getters and Setters)"))
  prefs: []
  type: TYPE_NORMAL
- en: 'Getters and setters allow you to implement the getting and setting of a property
    via methods. For example, the following object `obj` contains a getter for the
    property `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1039]'
  prefs: []
  type: TYPE_PRE
- en: Syntactic Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ECMAScript 5 includes the following syntactic changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Reserved words as property keys
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use reserved words (such as `new` and `function`) after the dot operator
    and as unquoted property keys in object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1040]'
  prefs: []
  type: TYPE_PRE
- en: Legal trailing commas
  prefs: []
  type: TYPE_NORMAL
- en: Trailing commas in object literals and array literals are legal.
  prefs: []
  type: TYPE_NORMAL
- en: Multiline string literals
  prefs: []
  type: TYPE_NORMAL
- en: String literals can span multiple lines if you escape the end of the line via
    a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: New Functionality in the Standard Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 5 brought several additions to JavaScript’s standard library. This
    section lists them by category.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Getting and setting prototypes (see [Getting and Setting the Prototype](ch17_split_000.html#get_set_prototype
    "Getting and Setting the Prototype")):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.create()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.getPrototypeOf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing property attributes via property descriptors (see [Property Descriptors](ch17_split_000.html#property_descriptors
    "Property Descriptors")):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.defineProperty()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.defineProperties()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.create()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.getOwnPropertyDescriptor()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Listing properties (see [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.keys()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.getOwnPropertyNames()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Protecting objects (see [Protecting Objects](ch17_split_001.html#protecting_objects
    "Protecting Objects")):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.preventExtensions()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.isExtensible()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.seal()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.isSealed()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.freeze()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.isFrozen()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New `Function` method (see [Function.prototype.bind(thisValue, arg1?, ...,
    argN?)](ch17_split_000.html#Function.prototype.bind "Function.prototype.bind(thisValue,
    arg1?, ..., argN?)")):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Function.prototype.bind()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings (see [Chapter 12](ch12.html "Chapter 12. Strings")):'
  prefs: []
  type: TYPE_NORMAL
- en: New method `String.prototype.trim()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access characters via the bracket operator `[...]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New `Array` methods (see [Array Prototype Methods](ch18.html#array_prototype_methods
    "Array Prototype Methods")):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.isArray()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.every()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.filter()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.forEach()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.indexOf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.lastIndexOf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.map()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.reduce()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.some()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New `Date` methods (see [Date Prototype Methods](ch20.html#date_prototype_methods
    "Date Prototype Methods")):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.now()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toISOString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Support for JSON (see [Chapter 22](ch22.html "Chapter 22. JSON")):'
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON.parse()` (see [JSON.parse(text, reviver?)](ch22.html#JSON.parse "JSON.parse(text,
    reviver?)"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON.stringify()` (see [JSON.stringify(value, replacer?, space?)](ch22.html#JSON.stringify
    "JSON.stringify(value, replacer?, space?)"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some built-in objects have special `toJSON()` methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean.prototype.toJSON()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.prototype.toJSON()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.toJSON()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toJSON()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips for Working with Legacy Browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following resources will be useful if you need to work with legacy browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: A [compatibility table](http://kangax.github.io/es5-compat-table/) by Juriy
    Zaytsev (“kangax”) shows how much of ECMAScript 5 is supported by various versions
    of various browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[es5-shim](https://github.com/kriskowal/es5-shim/) brings most (but not all)
    of ECMAScript 5’s functionality to browsers that support only ECMAScript 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

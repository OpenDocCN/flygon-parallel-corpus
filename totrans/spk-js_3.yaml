- en: Part III. JavaScript in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分。深入JavaScript
- en: This part is a comprehensive reference of the JavaScript language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分是JavaScript语言的全面参考。
- en: Chapter 7. JavaScript’s Syntax
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章。JavaScript的语法
- en: JavaScript’s syntax is fairly straightforward. This chapter describes things
    to watch out for.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的语法相当简单。本章描述了需要注意的事项。
- en: An Overview of the Syntax
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法概述
- en: This section gives you a quick impression of what JavaScript’s syntax looks
    like.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本节让你快速了解JavaScript的语法是什么样子的。
- en: 'The following are five fundamental kinds of values:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是五种基本类型的值：
- en: 'Booleans:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Numbers:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Strings:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Plain objects:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通对象：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Arrays:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here are a few examples of basic syntax:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些基本语法的例子：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note the two different uses of the equals sign:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意等号的两种不同用法：
- en: A single equals sign (`=`) is used to assign a value to a variable.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个等号（`=`）用于将一个值赋给一个变量。
- en: A triple equals sign (`===`) is used to compare two values (see [Equality Operators](ch01.html#basic_equality_operators
    "Equality Operators")).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个等号（`===`）用于比较两个值（参见[相等运算符](ch01.html#basic_equality_operators "相等运算符")）。
- en: Comments
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'There are two kinds of comments:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种注释：
- en: 'Single-line comments via `//` extend to the rest of the line. Here’s an example:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`//`进行单行注释，延伸到行的其余部分。这是一个例子：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Multiline comments via `/* */` can extend over arbitrary ranges of text. They
    cannot be nested. Here are two examples:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`/* */`进行多行注释，可以延伸到任意范围的文本。它们不能嵌套。以下是两个例子：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Expressions Versus Statements
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式与语句
- en: 'This section looks at an important syntactic distinction in JavaScript: the
    difference between expressions and statements.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了JavaScript中一个重要的语法区别：表达式和语句之间的区别。
- en: Expressions
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式
- en: 'An *expression* produces a value and can be written wherever a value is expected—for
    example, as an argument in a function call or at the right side of an assignment.
    Each of the following lines contains an expression:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式*产生一个值，并且可以在期望值的任何地方编写，例如，在函数调用的参数中或赋值的右侧。以下每一行都包含一个表达式：'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Statements
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语句
- en: Roughly, a *statement* performs an action. Loops and `if` statements are examples
    of statements. A program is basically a sequence of statements.^([[6](#ftn.id370625)])
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，*语句*执行一个动作。循环和`if`语句是语句的例子。程序基本上是一系列语句。^([[6](#ftn.id370625)])
- en: 'Wherever JavaScript expects a statement, you can also write an expression.
    Such a statement is called an *expression statement*. The reverse does not hold:
    you cannot write a statement where JavaScript expects an expression. For example,
    an `if` statement cannot become the argument of a function.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无论在哪里，JavaScript都期望一个语句，你也可以写一个表达式。这样的语句称为*表达式语句*。反之则不成立：你不能在JavaScript期望表达式的地方写一个语句。例如，`if`语句不能成为函数的参数。
- en: Conditional statement versus conditional expressions
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件语句与条件表达式
- en: 'The difference between statements and expressions becomes clearer if we look
    at members of the two syntactic categories that are similar: the `if` statement
    and the conditional operator (an expression).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下两个语法类别的成员，即`if`语句和条件运算符（一个表达式），那么语句和表达式之间的区别就变得更加清晰了。
- en: 'The following is an example of an `if` statement:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`if`语句的例子：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There is a similar kind of expression, the *conditional operator*. The preceding
    statements are equivalent to the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种类似的表达式，*条件运算符*。前面的语句等同于以下代码：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code between the equals sign and the semicolon is an expression. The parentheses
    are not necessary, but I find the conditional operator easier to read if I put
    it in parens.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 等号和分号之间的代码是一个表达式。括号不是必需的，但我发现如果我把它放在括号中，条件运算符更容易阅读。
- en: Using ambiguous expressions as statements
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用模棱两可的表达式作为语句
- en: 'Two kinds of expressions look like statements—they are ambiguous with regard
    to their syntactic category:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 两种表达式看起来像语句——它们在语法类别上是模棱两可的：
- en: 'Object literals (expressions) look like blocks (statements):'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象文字（表达式）看起来像块（语句）：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding construct is either an object literal (details: [Object Literals](ch17_split_000.html#object_literals
    "Object Literals")) or a block followed by the label `foo:`, followed by the function
    call `bar(3, 5)`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结构要么是一个对象文字（详细信息：[对象文字](ch17_split_000.html#object_literals "对象文字")），要么是一个块，后面跟着标签`foo:`，再跟着函数调用`bar(3,
    5)`。
- en: 'Named function expressions look like function declarations (statements):'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名函数表达式看起来像函数声明（语句）：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding construct is either a named function expression or a function
    declaration. The former produces a function, the latter creates a variable and
    assigns a function to it (details on both kinds of function definition: [Defining
    Functions](ch15.html#defining_functions "Defining Functions")).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结构要么是一个命名的函数表达式，要么是一个函数声明。前者产生一个函数，后者创建一个变量并将一个函数赋给它（有关两种函数定义的详细信息：[定义函数](ch15.html#defining_functions
    "定义函数")）。
- en: 'In order to prevent ambiguity during parsing, JavaScript does not let you use
    object literals and function expressions as statements. That is, expression statements
    must not start with:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在解析过程中避免歧义，JavaScript不允许你将对象文字和函数表达式用作语句。也就是说，表达式语句不能以以下内容开头：
- en: A curly brace
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号
- en: The keyword `function`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`function`
- en: If an expression starts with either of those tokens, it can only appear in an
    expression context. You can comply with that requirement by, for example, putting
    parentheses around the expression. Next, we’ll look at two examples where that
    is necessary.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个表达式以这两个标记中的任何一个开头，它只能出现在表达式上下文中。例如，你可以通过在表达式周围放置括号来满足这个要求。接下来，我们将看两个必要的例子。
- en: Evaluating an object literal via eval()
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过eval()评估对象文字
- en: '`eval` parses its argument in statement context. You have to put parentheses
    around an object literal if you want `eval` to return an object:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`在语句上下文中解析其参数。如果你想要`eval`返回一个对象，你必须在对象文字周围放括号：'
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Immediately invoking a function expression
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 立即调用函数表达式
- en: 'The following code is an *immediately invoked function expression* (IIFE),
    a function whose body is executed right away (you’ll learn what IIFEs are used
    for in [Introducing a New Scope via an IIFE](ch16.html#iife "Introducing a New
    Scope via an IIFE")):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个“立即调用的函数表达式”（IIFE），一个函数的主体会立即执行（您将在[通过IIFE引入新作用域](ch16.html#iife "通过IIFE引入新作用域")中了解到IIFE的用途）：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you omit the parentheses, you get a syntax error, because JavaScript sees
    a function declaration, which can’t be anonymous:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略括号，您将得到语法错误，因为JavaScript看到一个函数声明，它不能是匿名的：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you add a name, you also get a syntax error, because function declarations
    can’t be immediately invoked:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加名称，您也会得到语法错误，因为函数声明不能立即调用：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Whatever follows a function declaration must be a legal statement and `()` isn’t.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明后面必须是一个合法的语句，而`()`不是。
- en: Control Flow Statements and Blocks
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制流语句和块
- en: 'For control flow statements, the body is a single statement. Here are two examples:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于控制流语句，主体是一个单语句。以下是两个示例：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, any statement can always be replaced by a *block*, curly braces containing
    zero or more statements. Thus, you can also write:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任何语句都可以被*块*替换，即包含零个或多个语句的花括号。因此，您也可以这样写：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I prefer the latter form of control flow statement. Standardizing on it means
    that there is no difference between single-statement bodies and multistatement
    bodies. As a consequence, your code looks more consistent, and alternating between
    one statement and more than one statement is easier.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢后一种控制流语句形式。对其进行标准化意味着单语句主体和多语句主体之间没有区别。因此，您的代码看起来更一致，并且在单语句和多于一条语句之间切换更容易。
- en: Rules for Using Semicolons
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分号的规则
- en: 'In this section, we examine how semicolons are used in JavaScript. The basic
    rules are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论JavaScript中分号的使用。基本规则是：
- en: Normally, statements are terminated by semicolons.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，语句以分号终止。
- en: The exception is statements ending with blocks.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例外是以块结束的语句。
- en: Semicolons are optional in JavaScript. Missing semicolons are added via so-called
    *automatic semicolon insertion* (ASI; see [Automatic Semicolon Insertion](ch07.html#automatic_semicolon_insertion
    "Automatic Semicolon Insertion")). However, that feature doesn’t always work as
    expected, which is why you should always include semicolons.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中分号是可选的。缺少分号会通过所谓的“自动分号插入”（ASI）添加（请参阅[自动分号插入](ch07.html#automatic_semicolon_insertion
    "自动分号插入")）。然而，该功能并不总是按预期工作，这就是为什么您应该始终包括分号的原因。
- en: No Semicolon After a Statement Ending with a Block
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语句结束于块之后没有分号
- en: 'The following statements are not terminated by semicolons if they end with
    a block:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以块结束，以下语句不会以分号终止：
- en: 'Loops: `for`, `while` (but not `do-while`)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环：`for`，`while`（但不包括`do-while`）
- en: 'Branching: `if`, `switch`, `try`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支：`if`，`switch`，`try`
- en: Function declarations (but not function expressions)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明（但不是函数表达式）
- en: 'Here’s an example of `while` versus `do-while`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`while`与`do-while`的示例：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And here’s an example of a function declaration versus a function expression.
    The latter is followed by a semicolon, because it appears inside a `var` declaration
    (which *is* terminated by a semicolon):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是函数声明与函数表达式的示例。后者后面跟着一个分号，因为它出现在`var`声明内（它*以*分号结束）：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you do add a semicolon after a block, you do not get a syntax error, because
    it is considered an empty statement (see the next section).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在块后添加分号，您不会得到语法错误，因为它被视为一个空语句（请参阅下一节）。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: That’s most of what you need to know about semicolons. If you always add semicolons,
    you can probably get by without reading the remaining parts of this section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要了解的关于分号的大部分内容。如果您始终添加分号，您可能可以不阅读本节其余部分。
- en: The Empty Statement
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空语句
- en: 'A semicolon on its own is an *empty statement* and does nothing. Empty statements
    can appear anywhere a statement is expected. They are useful in situations where
    a statement is demanded, but not needed. In such situations, blocks are usually
    also allowed. For example, the following two statements are equivalent:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 分号本身是一个“空语句”，什么也不做。空语句可以出现在需要语句的任何地方。它们在需要语句但不需要语句的情况下很有用。在这种情况下，通常也允许块。例如，以下两个语句是等价的：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The function `processNextItem` is assumed to return the number of remaining
    items. The following program, consisting of three empty statements, is also syntactically
    correct:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`processNextItem`被假定返回剩余项目的数量。以下程序由三个空语句组成，也是语法上正确的：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Automatic Semicolon Insertion
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动分号插入
- en: The goal of automatic semicolon insertion (ASI) is to make semicolons optional
    at the end of a line. The image invoked by the term *automatic semicolon insertion*
    is that the JavaScript parser inserts semicolons for you (internally, things are
    usually handled differently).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 自动分号插入（ASI）的目标是使分号在行末变为可选。术语“自动分号插入”所引发的图像是JavaScript解析器为您插入分号（在内部，通常处理方式不同）。
- en: 'Put another way, ASI helps the parser to determine when a statement ends. Normally,
    it ends with a semicolon. ASI dictates that a statement also ends if:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，ASI帮助解析器确定语句何时结束。通常，它以分号结束。ASI规定，如果：
- en: A line terminator (e.g., a newline) is followed by an illegal token.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行终止符（例如换行符）后面跟着一个非法标记。
- en: A closing brace is encountered.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到右括号。
- en: The end of the file has been reached.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已到达文件末尾。
- en: 'Example: ASI via illegal token'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例：通过非法标记进行ASI
- en: 'The following code contains a line terminator followed by an illegal token:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码包含了一个行终止符后面跟着一个非法标记：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The token `console` is illegal after `0` and triggers ASI:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`0`之后的`console`标记是非法的，并触发ASI：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Example: ASI via closing brace'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例：通过右括号进行ASI
- en: 'In the following code, the statement inside the braces is not terminated by
    a semicolon:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，大括号内的语句未以分号终止：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'ASI creates a syntactically correct version of the preceding code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ASI创建了前述代码的语法上正确的版本：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Pitfall: ASI can unexpectedly break up statements'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：ASI可能会意外地中断语句
- en: 'ASI is also triggered if there is a line terminator after the keyword `return`.
    For example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在关键字`return`后有行终止符，ASI也会被触发。例如：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'ASI turns the preceding into:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ASI将前面的转换为：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That’s an empty return, followed by a block with the label `name` in front of
    the expression statement `'John'`. After the block, there is an empty statement.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个空的返回，紧接着是一个带有标签`name`的块，位于表达式语句`'John'`之前。在块之后，有一个空语句。
- en: 'Pitfall: ASI might unexpectedly not be triggered'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：ASI可能意外地不会被触发
- en: 'Sometimes a statement in a new line starts with a token that is allowed as
    a continuation of the previous statement. Then ASI is not triggered, even though
    it seems like it should be. For example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，新行中的语句以允许作为前一语句的延续的标记开头。然后，尽管看起来应该被触发，但ASI不会被触发。例如：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The square brackets in the second line are interpreted as an index into the
    result returned by `func()`. The comma inside the brackets is interpreted as the
    comma operator (which returns `''ol''` in this case; see [The Comma Operator](ch09.html#comma_operator
    "The Comma Operator")). Thus, JavaScript sees the previous code as:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行中的方括号被解释为对`func()`返回结果的索引。方括号内的逗号被解释为逗号运算符（在这种情况下返回`'ol'`；参见[逗号运算符](ch09.html#comma_operator
    "逗号运算符")）。因此，JavaScript将前面的代码视为：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Legal Identifiers
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合法标识符
- en: Identifiers are used for naming things and appear in various syntactic roles
    in JavaScript. For example, the names of variables and unquoted property keys
    must be valid identifiers. Identifiers are case sensitive.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符用于命名事物，并在JavaScript中的各种句法角色中出现。例如，变量的名称和未引用的属性键的名称必须是有效的标识符。标识符区分大小写。
- en: 'The first character of an identifier is one of:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符的第一个字符是：
- en: Any Unicode letter, including Latin letters such as D, Greek letters such as
    λ, and Cyrillic letters such as Д
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何Unicode字母，包括拉丁字母如D，希腊字母如λ，和西里尔字母如Д
- en: Dollar sign (`$`)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美元符号（`$`）
- en: Underscore (`_`)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下划线（`_`）
- en: 'Subsequent characters are:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 后续字符是：
- en: Any legal first character
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何合法的第一个字符
- en: Any Unicode digit in the Unicode category “Decimal number (Nd)”; this includes
    European numerals such as 7 and Indic numerals such as ٣
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode类别“十进制数字（Nd）”中的任何Unicode数字；这包括欧洲数字如7和印度数字如٣
- en: Various other Unicode marks and punctuations
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他各种Unicode标记和标点符号
- en: 'Examples of legal identifiers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 合法标识符的示例：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Even though this enables you to use a variety of human languages in JavaScript
    code, I recommend sticking with English, for both identifiers and comments. That
    ensures that your code is understandable by the largest possible group of people,
    which is important, given how much code can spread internationally these days.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这使您可以在JavaScript代码中使用各种人类语言，但我建议使用英语，无论是标识符还是注释。这可以确保您的代码可以被尽可能多的人理解，这很重要，考虑到如今代码可以在国际间传播。
- en: 'The following identifiers are *reserved words*—they are part of the syntax
    and can’t be used as variable names (including function names and parameter names):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标识符是*保留字*——它们是语法的一部分，不能用作变量名（包括函数名和参数名）：
- en: '| `arguments` | `break` | `case` | `catch` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `arguments` | `break` | `case` | `catch` |'
- en: '| `class` | `const` | `continue` | `debugger` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `class` | `const` | `continue` | `debugger` |'
- en: '| `default` | `delete` | `do` | `else` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `default` | `delete` | `do` | `else` |'
- en: '| `enum` | `export` | `extends` | `false` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `enum` | `export` | `extends` | `false` |'
- en: '| `finally` | `for` | `function` | `if` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `finally` | `for` | `function` | `if` |'
- en: '| `implements` | `import` | `in` | `instanceof` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `implements` | `import` | `in` | `instanceof` |'
- en: '| `interface` | `let` | `new` | `null` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `interface` | `let` | `new` | `null` |'
- en: '| `package` | `private` | `protected` | `public` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `package` | `private` | `protected` | `public` |'
- en: '| `return` | `static` | `super` | `switch` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `return` | `static` | `super` | `switch` |'
- en: '| `this` | `throw` | `true` | `try` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `this` | `throw` | `true` | `try` |'
- en: '| `typeof` | `var` | `void` | `while` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `typeof` | `var` | `void` | `while` |'
- en: 'The following three identifiers are not reserved words, but you should treat
    them as if they were:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个标识符不是保留字，但您应该将它们视为保留字：
- en: '| `Infinity` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `Infinity` |'
- en: '| `NaN` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `NaN` |'
- en: '| `undefined` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` |'
- en: Lastly, you should also stay away from the names of standard global variables
    (see [Chapter 23](ch23.html "Chapter 23. Standard Global Variables")). You can
    use them for local variables without breaking anything, but your code still becomes
    confusing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还应该避免使用标准全局变量的名称（参见[第23章](ch23.html "第23章. 标准全局变量")）。您可以将它们用作局部变量而不会破坏任何内容，但您的代码仍然会变得混乱。
- en: 'Note that you *can* use reserved words as unquoted property keys (as of ECMAScript 5):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您*可以*使用保留字作为未引用的属性键（自ECMAScript 5起）：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can look up the precise rules for identifiers in Mathias Bynens’s blog post
    [“Valid JavaScript variable names”](http://mathiasbynens.be/notes/javascript-identifiers).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Mathias Bynens的博客文章[“有效的JavaScript变量名”](http://mathiasbynens.be/notes/javascript-identifiers)中查找标识符的精确规则。
- en: Invoking Methods on Number Literals
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数字文字上调用方法
- en: 'With method invocations, it is important to distinguish between the floating-point
    dot and the method invocation dot. Thus, you cannot write `1.toString()`; you
    must use one of the following alternatives:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法调用中，重要的是要区分浮点数点和方法调用点。因此，您不能写成`1.toString()`；您必须使用以下替代之一：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Strict Mode
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格模式
- en: ECMAScript 5 has a *strict mode* that results in cleaner JavaScript, with fewer
    unsafe features, more warnings, and more logical behavior. The normal (nonstrict)
    mode is sometimes called “sloppy mode.”
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 5有一个*严格模式*，可以使JavaScript更清晰，减少不安全的特性，增加警告，以及更合乎逻辑的行为。正常（非严格）模式有时被称为“松散模式”。
- en: Switching on Strict Mode
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开严格模式
- en: 'You switch strict mode on by typing the following line first in your JavaScript
    file or inside your `<script>` element:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在JavaScript文件中或在`<script>`元素内首先输入以下行来打开严格模式：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that JavaScript engines that don’t support ECMAScript 5 will simply ignore
    the preceding statement, as writing strings in this manner (as an expression statement;
    see [Statements](ch07.html#expression_statement "Statements")) normally does nothing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不支持ECMAScript 5的JavaScript引擎将简单地忽略前面的语句，因为以这种方式编写字符串（作为表达式语句；请参阅[语句](ch07.html#expression_statement
    "语句")）通常不会做任何事情。
- en: 'You can also switch on strict mode per function. To do so, write your function
    like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以按函数打开严格模式。要这样做，请像这样编写您的函数：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is handy when you are working with a legacy code base where switching on
    strict mode everywhere may break things.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用严格模式处理到处都可能破坏事物的旧代码库时，这很方便。
- en: 'Strict Mode: Recommended, with Caveats'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格模式：推荐，但有注意事项
- en: 'In general, the changes enabled by strict mode are all for the better. Thus,
    it is highly recommended to use it for new code you write—simply switch it on
    at the beginning of a file. There are, however, two caveats:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，严格模式启用的更改都是为了更好。因此，强烈建议您在编写新代码时使用它——只需在文件开头打开它。然而，有两个注意事项：
- en: Enabling strict mode for existing code may break it
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为现有代码启用严格模式可能会破坏它
- en: The code may rely on a feature that is not available anymore, or it may rely
    on behavior that is different in sloppy mode than in strict mode. Don’t forget
    that you have the option to add single strict mode functions to files that are
    in sloppy mode.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能依赖于不再可用的功能，或者可能依赖于在松散模式和严格模式中行为不同的行为。不要忘记您可以将单个严格模式函数添加到处于松散模式的文件中的选项。
- en: Package with care
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 小心处理包
- en: When you concatenate and/or minify files, you have to be careful that strict
    mode isn’t switched off where it should be switched on or vice versa. Both can
    break code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当您连接和/或缩小文件时，您必须小心，严格模式在应该打开时没有关闭，或者反之亦然。两者都可能破坏代码。
- en: The following sections explain the strict mode features in more detail. You
    normally don’t need to know them, as you will mostly get more warnings for things
    that you shouldn’t do anyway.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分详细解释了严格模式的特性。通常情况下，您不需要了解它们，因为您大多数情况下会因为您本不应该做的事情而得到更多的警告。
- en: Variables Must Be Declared in Strict Mode
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量必须在严格模式下声明
- en: 'All variables must be explicitly declared in strict mode. This helps to prevent
    typos. In sloppy mode, assigning to an undeclared variable creates a global variable:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，所有变量必须明确声明。这有助于防止拼写错误。在松散模式下，对未声明的变量进行赋值会创建一个全局变量：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In strict mode, assigning to an undeclared variable throws an exception:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，对未声明的变量进行赋值会引发异常：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Functions in Strict Mode
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格模式中的函数
- en: Strict mode limits function-related features.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式限制了与函数相关的特性。
- en: Functions must be declared at the top level of a scope
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数必须在作用域的顶层声明
- en: 'In strict mode, all functions must be declared at the top level of a scope
    (global scope or directly inside a function). That means that you can’t put a
    function declaration inside a block. If you do, you get a descriptive `SyntaxError`.
    For example, V8 tells you: “In strict mode code, functions can only be declared
    at top level or immediately within another function”:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，所有函数必须在作用域的顶层声明（全局作用域或直接在函数内部）。这意味着您不能将函数声明放在块内。如果这样做，您将收到一个描述性的`SyntaxError`。例如，V8会告诉您：“在严格模式代码中，函数只能在顶层或直接在另一个函数内部声明”：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That is something that isn’t useful anyway, because the function is created
    in the scope of the surrounding function, not “inside” the block.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是无用的，因为该函数是在周围函数的范围内创建的，而不是“在”块内部。
- en: 'If you want to work around this limitation, you can create a function inside
    a block via a variable declaration and a function expression:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想解决此限制，可以通过变量声明和函数表达式在块内创建一个函数：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Stricter rules for function parameters
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数参数的更严格规则
- en: 'The rules for function parameters are less permissive: using the same parameter
    name twice is forbidden, as are local variables that have the same name as a parameter.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数的规则不太宽容：禁止使用相同的参数名称两次，以及与参数同名的局部变量。
- en: The arguments objects has fewer properties
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: arguments对象的属性更少
- en: 'The `arguments` object is simpler in strict mode: the properties `arguments.callee`
    and `arguments.caller` have been eliminated, you can’t assign to the variable
    `arguments`, and `arguments` does not track changes to parameters (if a parameter
    changes, the corresponding array element does not change with it). [Deprecated
    features of arguments](ch15.html#arguments_deprecated_features "Deprecated features
    of arguments") explains the details.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，`arguments`对象更简单：属性`arguments.callee`和`arguments.caller`已被删除，您不能对变量`arguments`进行赋值，`arguments`不会跟踪参数的更改（如果参数更改，相应的数组元素不会随之更改）。[arguments的弃用特性](ch15.html#arguments_deprecated_features
    "arguments的弃用特性")解释了详细信息。
- en: this is undefined in nonmethod functions
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非方法函数中的`this`是未定义的
- en: 'In sloppy mode, the value of `this` in nonmethod functions is the global object
    (`window` in browsers; see [The Global Object](ch16.html#global_object "The Global
    Object")):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在松散模式下，非方法函数中`this`的值是全局对象（在浏览器中是`window`；请参阅[全局对象](ch16.html#global_object
    "全局对象")）：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In strict mode, it is `undefined`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，它是`undefined`：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is useful for constructors. For example, the following constructor, `Point`,
    is in strict mode:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这对构造函数很有用。例如，以下构造函数`Point`是在严格模式下的：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Due to strict mode, you get a warning when you accidentally forget `new` and
    call it as a function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于严格模式，当您意外忘记`new`并将其作为函数调用时，您会收到警告：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In sloppy mode, you don’t get a warning, and global variables `x` and `y` are
    created. Consult [Tips for Implementing Constructors](ch17_split_001.html#constructor_tips
    "Tips for Implementing Constructors") for details.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在松散模式下，您不会收到警告，并且会创建全局变量`x`和`y`。有关详细信息，请参阅[实现构造函数的提示](ch17_split_001.html#constructor_tips
    "实现构造函数的提示")。
- en: Setting and Deleting Immutable Properties Fails with an Exception in Strict
    Mode
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在严格模式下，设置和删除不可变属性会引发异常
- en: 'Illegal manipulations of properties throw exceptions in strict mode. For example,
    attempting to set the value of a read-only property throws an exception, as does
    attempting to delete a nonconfigurable property. Here is an example of the former:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Unqualified Identifiers Can’t Be Deleted in Strict Mode
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In sloppy mode, you can delete a global variable `foo` like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In strict mode, you get a syntax error whenever you try to delete unqualified
    identifiers. You can still delete global variables like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: eval() Is Cleaner in Strict Mode
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In strict mode, the `eval()` function becomes less quirky: variables declared
    in the evaluated string are not added to the scope surrounding `eval()` anymore.
    For details, consult [Evaluating Code Using eval()](ch23.html#eval "Evaluating
    Code Using eval()").'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Features That Are Forbidden in Strict Mode
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two more JavaScript features are forbidden in strict mode:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The `with` statement is not allowed anymore (see [The with Statement](ch13.html#with_statement
    "The with Statement")). You get a syntax error at compile time (when loading the
    code).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No more octal numbers: in sloppy mode, an integer with a leading zero is interpreted
    as octal (base 8). For example:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In strict mode, you get a syntax error if you use this kind of literal:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '* * *'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#id370625)]) To keep things simple, I’m pretending that declarations
    are statements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8. Values
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has most of the values that we have come to expect from programming
    languages: booleans, numbers, strings, arrays, and so on. All normal values in
    JavaScript have *properties*.^([[7](#ftn.id914993)]) Each property has a *key*
    (or *name*) and a *value*. You can think of properties like fields of a record.
    You use the dot (`.`) operator to access properties:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: JavaScript’s Type System
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter gives an overview of JavaScript’s type system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript’s Types
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has only six types, according to [Chapter 8 of the ECMAScript language
    specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'An ECMAScript language type corresponds to values that are directly manipulated
    by an ECMAScript programmer using the ECMAScript language. The ECMAScript language
    types are:'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Undefined, Null
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean, String, Number, and
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Object
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, constructors technically don’t introduce new types, even though they
    are said to have instances.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Static Versus Dynamic
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the context of language semantics and type systems, *static* usually means
    “at compile time” or “without running a program,” while *dynamic* means “at runtime.”
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Static Typing Versus Dynamic Typing
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a statically typed language, variables, parameters, and members of objects
    (JavaScript calls them properties) have types that the compiler knows at compile
    time. The compiler can use that information to perform type checks and to optimize
    the compiled code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Even in statically typed languages, a variable also has a dynamic type, the
    type of the variable’s value at a given point at runtime. The dynamic type can
    differ from the static type. For example (Java):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The static type of `foo` is `Object`; its dynamic type is `String`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is dynamically typed; types of variables are generally not known
    at compile time.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Static Type Checking Versus Dynamic Type Checking
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have type information, you can check whether a value used in an operation
    (calling a function, applying an operator, etc.) has the correct type. Statically
    type-checked languages perform this kind of check at compile time, while dynamically
    type-checked languages do so at runtime. A language can be both statically type-checked
    and dynamically type-checked. If a check fails, you usually get some kind of error
    or exception.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript performs a very limited kind of dynamic type checking:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Mostly, however, things silently fail or work. For example, if you access a
    property that does not exist, you get the value `undefined`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Coercion
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript, the main way of dealing with a value whose type doesn’t fit
    is to *coerce* it to the correct type. *Coercion* means implicit type conversion.
    Most operands coerce:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，处理类型不匹配的值的主要方法是将其*强制转换*为正确的类型。*强制转换*意味着隐式类型转换。大多数操作数都会强制转换：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: JavaScript’s built-in conversion mechanisms support only the types `Boolean`,
    `Number`, `String`, and `Object`. There is no standard way to convert an instance
    of one constructor to an instance of another constructor.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的内置转换机制仅支持`Boolean`，`Number`，`String`和`Object`类型。没有标准的方法将一个构造函数的实例转换为另一个构造函数的实例。
- en: Warning
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: The terms *strongly typed* and *weakly typed* do not have [generally meaningful
    definitions](http://bit.ly/1oO7t1p). They are used, but normally incorrectly.
    It is better to instead use *statically typed*, *statically type-checked*, and
    so on.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*强类型*和*弱类型*没有[普遍有意义的定义](http://bit.ly/1oO7t1p)。它们被使用，但通常是不正确的。最好使用*静态类型*，*静态类型检查*等。
- en: Primitive Values Versus Objects
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始值与对象
- en: 'JavaScript makes a somewhat arbitrary distinction between values:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在值之间做了一个相当任意的区分：
- en: The *primitive values* are booleans, numbers, strings, `null`, and `undefined`.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原始值*是布尔值，数字，字符串，`null`和`undefined`。'
- en: All other values are *objects*.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他值都是*对象*。
- en: 'A major difference between the two is how they are compared; each object has
    a unique identity and is only (strictly) equal to itself:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的主要区别在于它们的比较方式；每个对象都有唯一的身份，只有（严格）等于自己：
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In contrast, all primitive values encoding the same value are considered the
    same:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，编码相同值的所有原始值被认为是相同的：
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The following two sections explain primitive values and objects in more detail.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两节详细解释了原始值和对象。
- en: Primitive Values
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始值
- en: 'The following are all of the *primitive values* (*primitives* for short):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有的*原始值*（简称*原始值*）：
- en: 'Booleans: `true`, `false` (see [Chapter 10](ch10.html "Chapter 10. Booleans"))'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：`true`，`false`（参见[第10章](ch10.html "第10章。布尔值"））
- en: 'Numbers: `1736`, `1.351` (see [Chapter 11](ch11.html "Chapter 11. Numbers"))'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：`1736`，`1.351`（参见[第11章](ch11.html "第11章。数字"））
- en: 'Strings: `''abc''`, `"abc"` (see [Chapter 12](ch12.html "Chapter 12. Strings"))'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：`'abc'`，`"abc"`（参见[第12章](ch12.html "第12章。字符串"））
- en: 'Two “nonvalues”: `undefined`, `null` (see [undefined and null](ch08.html#undefined_null
    "undefined and null"))'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个“非值”：`undefined`，`null`（参见[undefined和null](ch08.html#undefined_null "undefined和null"））
- en: 'Primitives have the following characteristics:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 原始值具有以下特征：
- en: Compared by value
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 按值比较
- en: 'The “content” is compared:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 比较“内容”：
- en: '[PRE56]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Always immutable
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 始终不可变
- en: 'Properties can’t be changed, added, or removed:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 属性不能被更改，添加或删除：
- en: '[PRE57]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: (Reading an unknown property always returns `undefined`.)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: （读取未知属性总是返回`undefined`。）
- en: A fixed set of types
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一组固定的类型
- en: You can’t define your own primitive types.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能定义自己的原始类型。
- en: Objects
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: 'All nonprimitive values are *objects*. The most common kinds of objects are:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 所有非原始值都是*对象*。最常见的对象类型是：
- en: '*Plain objects* (constructor `Object`) can be created by *object literals*
    (see [Chapter 17](ch17_split_000.html "Chapter 17. Objects and Inheritance")):'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*普通对象*（构造函数`Object`）可以通过*对象字面量*（参见[第17章](ch17_split_000.html "第17章。对象和继承"））创建：'
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding object has two properties: the value of property `firstName`
    is `''Jane''`, and the value of property `lastName` is `''Doe''`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的对象有两个属性：属性`firstName`的值为`'Jane'`，属性`lastName`的值为`'Doe'`。
- en: '*Arrays* (constructor `Array`) can be created by *array literals* (see [Chapter 18](ch18.html
    "Chapter 18. Arrays")):'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组*（构造函数`Array`）可以通过*数组字面量*（参见[第18章](ch18.html "第18章。数组"））创建：'
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The preceding array has three elements that can be accessed via numeric indices.
    For example, the index of `'apple'` is 0.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数组有三个元素，可以通过数字索引访问。例如，'apple'的索引是0。
- en: '*Regular expressions* (constructor `RegExp`) can be created by *regular expression
    literals* (see [Chapter 19](ch19.html "Chapter 19. Regular Expressions")):'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正则表达式*（构造函数`RegExp`）可以通过*正则表达式字面量*（参见[第19章](ch19.html "第19章。正则表达式"））创建：'
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Objects have the following characteristics:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对象具有以下特征：
- en: Compared by reference
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 按引用比较
- en: 'Identities are compared; every object has its own identity:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 比较身份；每个对象都有自己的身份：
- en: '[PRE61]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Mutable by default
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 默认可变
- en: 'You can normally freely change, add, and remove properties (see [Dot Operator
    (.): Accessing Properties via Fixed Keys](ch17_split_000.html#dot_operator "Dot
    Operator (.): Accessing Properties via Fixed Keys")):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以自由更改，添加和删除属性（参见[点运算符（.）：通过固定键访问属性](ch17_split_000.html#dot_operator "点运算符（.）：通过固定键访问属性"））：
- en: '[PRE62]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: User-extensible
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可扩展
- en: 'Constructors (see [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances")) can be seen as implementations
    of custom types (similar to classes in other languages).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数（参见[第3层：构造函数-实例的工厂](ch17_split_001.html#constructors "第3层：构造函数-实例的工厂"）可以看作是自定义类型的实现（类似于其他语言中的类）。
- en: undefined and null
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: undefined和null
- en: 'JavaScript has two “nonvalues” that indicate missing information, `undefined`
    and `null`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有两个“非值”，表示缺少信息，`undefined`和`null`：
- en: '`undefined` means “no value” (neither primitive nor object). Uninitialized
    variables, missing parameters, and missing properties have that nonvalue. And
    functions implicitly return it if nothing has been explicitly returned.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`表示“没有值”（既不是原始值也不是对象）。未初始化的变量，缺少的参数和缺少的属性都具有该非值。如果没有明确返回任何内容，函数会隐式返回它。'
- en: '`null` means “no object.” It is used as a nonvalue where an object is expected
    (as a parameter, as a member in a chain of objects, etc.).'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`表示“没有对象”。它用作一个非值，期望一个对象（作为参数，在对象链中的成员等）。'
- en: '`undefined` and `null` are the only values for which any kind of property access
    results in an exception:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`和`null`是唯一的值，任何属性访问都会导致异常：'
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`undefined` is also sometimes used as more of a metavalue that indicates nonexistence.
    In contrast, `null` indicates emptiness. For example, a JSON node visitor (see
    [Transforming Data via Node Visitors](ch22.html#node_visitors "Transforming Data
    via Node Visitors")) returns:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`有时也被用作指示不存在的元值。相比之下，`null`表示空。例如，JSON节点访问者（请参阅[通过节点访问者转换数据](ch22.html#node_visitors
    "通过节点访问者转换数据")）返回：'
- en: '`undefined` to remove an object property or array element'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`用于删除对象属性或数组元素'
- en: '`null` to set the property or element to `null`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将属性或元素设置为`null`
- en: Occurrences of undefined and null
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未定义和null的出现
- en: Here we review the various scenarios where `undefined` and `null` occur.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们回顾了`undefined`和`null`出现的各种情况。
- en: Occurrences of undefined
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 未定义的出现
- en: 'Uninitialized variables are `undefined`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 未初始化的变量是`undefined`：
- en: '[PRE64]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Missing parameters are `undefined`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少参数是`undefined`：
- en: '[PRE65]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you read a nonexistent property, you get `undefined`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读取不存在的属性，则会得到`undefined`：
- en: '[PRE66]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And functions implicitly return `undefined` if nothing has been explicitly
    returned:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确返回，函数会隐式返回`undefined`：
- en: '[PRE67]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Occurrences of null
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: null的出现
- en: '`null` is the last element in the prototype chain (a chain of objects; see
    [Layer 2: The Prototype Relationship Between Objects](ch17_split_000.html#prototype_relationship
    "Layer 2: The Prototype Relationship Between Objects")):'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`是原型链中的最后一个元素（一系列对象的链；请参阅[第2层：对象之间的原型关系](ch17_split_000.html#prototype_relationship
    "第2层：对象之间的原型关系")）：'
- en: '[PRE68]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`null` is returned by `RegExp.prototype.exec()` if there was no match for the
    regular expression in the string:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字符串中的正则表达式没有匹配项，则`RegExp.prototype.exec()`将返回`null`：
- en: '[PRE69]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Checking for undefined or null
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查未定义或null
- en: In the following sections we review how to check for `undefined` and `null`
    individually, or to check if either exists.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将回顾如何分别检查`undefined`和`null`，或者检查它们是否存在。
- en: Checking for null
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查null
- en: 'You check for `null` via strict equality:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过严格相等来检查`null`：
- en: '[PRE70]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Checking for undefined
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查未定义
- en: 'Strict equality (`===`) is the canonical way of checking for `undefined`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 严格相等（`===`）是检查`undefined`的规范方式：
- en: '[PRE71]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can also check for `undefined` via the `typeof` operator ([typeof: Categorizing
    Primitives](ch09.html#typeof "typeof: Categorizing Primitives")), but you should
    normally use the aforementioned approach.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过`typeof`运算符（[typeof：对基元进行分类](ch09.html#typeof "typeof：对基元进行分类")）来检查`undefined`，但通常应使用前面提到的方法。
- en: Checking for either undefined or null
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查未定义或null
- en: 'Most functions allow you to indicate a missing value via either `undefined`
    or `null`. One way of checking for both of them is via an explicit comparison:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数允许您通过`undefined`或`null`指示缺少值。检查它们两者之一的一种方法是通过显式比较：
- en: '[PRE72]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Another way is to exploit the fact that both `undefined` and `null` are considered
    `false` (see [Truthy and Falsy Values](ch10.html#truthy_falsy "Truthy and Falsy
    Values")):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是利用`undefined`和`null`都被视为`false`的事实（请参阅[真值和假值](ch10.html#truthy_falsy "真值和假值")）：
- en: '[PRE73]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Warning
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '`false`, `0`, `NaN`, and `''''` are also considered `false`.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`false`，`0`，`NaN`和`''''`也被视为`false`。'
- en: The History of undefined and null
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未定义和null的历史
- en: A single nonvalue could play the roles of both `undefined` and `null`. Why does
    JavaScript have two such values? The reason is historical.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 单个非值可以扮演`undefined`和`null`的角色。为什么JavaScript有两个这样的值？原因是历史性的。
- en: 'JavaScript adopted Java’s approach of partitioning values into primitives and
    objects. It also used Java’s value for “not an object,” `null`. Following the
    precedent set by C (but not Java), `null` becomes 0 if coerced to a number:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript采用了Java对值进行分区为基元和对象的方法。它还使用了Java的“不是对象”的值，`null`。遵循C（但不是Java）所设定的先例，如果强制转换为数字，则`null`变为0：
- en: '[PRE74]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Remember that the first version of JavaScript did not have exception handling.
    Therefore, exceptional cases such as uninitialized variables and missing properties
    had to be indicated via a value. `null` would have been a good choice, but Brendan
    Eich wanted to avoid two things at the time:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，JavaScript的第一个版本没有异常处理。因此，未初始化的变量和丢失的属性等特殊情况必须通过一个值来指示。`null`本来是一个不错的选择，但当时Brendan
    Eich想要避免两件事：
- en: The value shouldn’t have the connotation of a reference, because it was about
    more than just objects.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值不应该具有引用的含义，因为它不仅仅是关于对象。
- en: The value shouldn’t coerce to 0, because that makes errors harder to spot.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值不应该强制转换为0，因为这样会使错误更难以发现。
- en: 'As a result, Eich added `undefined` as an additional nonvalue to the language.
    It coerces to `NaN`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Eich将`undefined`作为语言中的另一个非值。它强制转换为`NaN`：
- en: '[PRE75]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Changing undefined
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改未定义
- en: '`undefined` is a [property of the global object](http://bit.ly/1oO9pXM) (and
    thus a global variable; see [The Global Object](ch16.html#global_object "The Global
    Object")). Under ECMAScript 3, you had to take precautions when reading `undefined`,
    because it was easy to accidentally change its value. Under ECMAScript 5, that
    is not necessary, because `undefined` is read-only.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`是全局对象的一个属性（因此是全局变量；请参阅[全局对象](ch16.html#global_object "全局对象")）。在ECMAScript
    3中，读取`undefined`时必须采取预防措施，因为很容易意外更改其值。在ECMAScript 5中，这是不必要的，因为`undefined`是只读的。'
- en: 'To protect against a changed `undefined`, two techniques were popular (they
    are still relevant for older JavaScript engines):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止更改`undefined`，有两种流行的技术（它们对于旧的JavaScript引擎仍然相关）：
- en: Technique 1
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 技术1
- en: 'Shadow the global `undefined` (which may have the wrong value):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 屏蔽全局`undefined`（可能具有错误的值）：
- en: '[PRE76]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the preceding code, `undefined` is guaranteed to have the right value, because
    it is a parameter whose value has not been provided by the function call.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`undefined`保证具有正确的值，因为它是一个参数，其值未由函数调用提供。
- en: Technique 2
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 技术2
- en: 'Compare with `void 0`, which is always (the correct) `undefined` (see [The
    void Operator](ch09.html#void_operator "The void Operator")):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 与始终（正确的）`undefined`相比，`void 0`（请参阅[void运算符](ch09.html#void_operator "void运算符")）：
- en: '[PRE77]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Wrapper Objects for Primitives
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基元的包装对象
- en: 'The three primitive types boolean, number, and string have corresponding constructors:
    `Boolean`, `Number`, `String`. Their instances (so-called *wrapper objects*) contain
    (*wrap*) primitive values. The constructors can be used in two ways:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值、数字和字符串这三种原始类型都有对应的构造函数：`Boolean`、`Number`、`String`。它们的实例（称为*包装对象*）包含（*包装*）原始值。这些构造函数可以以两种方式使用：
- en: 'As constructors, they create objects that are largely incompatible with the
    primitive values that they wrap:'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为构造函数，它们创建的对象与它们包装的原始值大部分不兼容：
- en: '[PRE78]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As functions, they convert values to the corresponding primitive types (see
    [Functions for Converting to Boolean, Number, String, and Object](ch08.html#convert_to_primitive
    "Functions for Converting to Boolean, Number, String, and Object")). This is the
    recommended method of conversion:'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数，它们将值转换为相应的原始类型（见[转换为布尔值、数字、字符串和对象的函数](ch08.html#convert_to_primitive "转换为布尔值、数字、字符串和对象的函数"））。这是推荐的转换方法：
- en: '[PRE79]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Tip
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It’s considered a best practice to avoid wrapper objects. You normally don’t
    need them, as there is nothing that objects can do that primitives can’t (with
    the exception of being mutated). (This is different from Java, from which JavaScript
    inherited the difference between primitives and objects!)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是避免使用包装对象。通常情况下，您不需要它们，因为对象不能做的事情原始值都可以做（除了被改变）。（这与Java不同，JavaScript从中继承了原始值和对象之间的差异！）
- en: Wrapper Objects Are Different from Primitives
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装对象与原始值不同
- en: 'Primitive values such as `''abc''` are fundamentally different from wrapper
    instances such as `new String(''abc'')`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`'abc'`之类的原始值与诸如`new String('abc')`之类的包装实例在根本上是不同的：
- en: '[PRE80]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Wrapper instances are objects, and there is no way of comparing objects in
    JavaScript, not even via lenient equals `==` (see [Equality Operators: === Versus
    ==](ch09.html#equality_operators "Equality Operators: === Versus ==")):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 包装实例是对象，JavaScript中没有办法比较对象，甚至不能通过宽松相等`==`进行比较（见[相等运算符：===与==](ch09.html#equality_operators
    "相等运算符：===与=="））：
- en: '[PRE81]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Wrapping and Unwrapping Primitives
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装和解包原始值
- en: 'There is one use case for wrapper objects: you want to add properties to a
    primitive value. Then you wrap the primitive and add properties to the wrapper
    object. You need to unwrap the value before you can work with it.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 包装对象的一个用例是：您想要向原始值添加属性。然后您包装原始值并向包装对象添加属性。在使用之前，您需要解包该值。
- en: 'Wrap a primitive by invoking a wrapper constructor:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用包装构造函数来包装原始值：
- en: '[PRE82]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Unwrap a primitive by invoking the method `valueOf()`. All objects have this
    method (as discussed in [Conversion to Primitive](ch17_split_001.html#Object.prototype.valueOf
    "Conversion to Primitive")):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用方法`valueOf()`来解包原始值。所有对象都有这个方法（如[转换为原始值](ch17_split_001.html#Object.prototype.valueOf
    "转换为原始值"）中所讨论的）：
- en: '[PRE83]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Converting wrapper objects to primitives properly extracts numbers and strings,
    but not booleans:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 将包装对象转换为原始值可以正确提取数字和字符串，但不能提取布尔值：
- en: '[PRE84]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The reason for this is explained in [Converting to Boolean](ch10.html#toboolean
    "Converting to Boolean").
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在[转换为布尔值](ch10.html#toboolean "转换为布尔值"）中解释的原因。
- en: Primitives Borrow Their Methods from Wrappers
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始值从包装对象中借用它们的方法
- en: 'Primitives don’t have their own methods and borrow them from wrappers:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 原始值没有自己的方法，而是从包装对象中借用它们：
- en: '[PRE85]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Sloppy mode and strict mode handle this borrowing differently. In sloppy mode,
    primitives are converted to wrappers on the fly:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 松散模式和严格模式以不同的方式处理这种借用。在松散模式下，原始值会即时转换为包装对象：
- en: '[PRE86]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In strict mode, methods from the wrapper prototype are used transparently:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，会透明地使用包装原型中的方法：
- en: '[PRE87]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Type Coercion
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型强制
- en: '*Type coercion* means the implicit conversion of a value of one type to a value
    of another type. Most of JavaScript’s operators, functions, and methods coerce
    operands and arguments to the types that they need. For example, the operands
    of the multiplication operator (`*`) are coerced to numbers:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型强制*意味着将一个类型的值隐式转换为另一个类型的值。JavaScript的大多数运算符、函数和方法都会将操作数和参数强制转换为它们需要的类型。例如，乘法运算符（`*`）的操作数会被强制转换为数字：'
- en: '[PRE88]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'As another example, if one of the operands is a string, the plus operator (`+`)
    converts the other one to a string:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，如果操作数之一是字符串，加号运算符（`+`）会将另一个操作数转换为字符串：
- en: '[PRE89]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Type Coercion Can Hide Bugs
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型强制可以隐藏错误
- en: 'Therefore, JavaScript rarely complains about a value having the wrong type.
    For example, programs normally receive user input (from online forms or GUI widgets)
    as strings, even if the user has entered a number. If you treat a number-as-string
    like a number, you will not get a warning, just unexpected results. For example:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JavaScript很少抱怨值的类型错误。例如，程序通常会将用户输入（来自在线表单或GUI小部件）作为字符串接收，即使用户输入的是一个数字。如果您将一个数字作为字符串处理，您将不会收到警告，只会得到意外的结果。例如：
- en: '[PRE90]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In cases such as the preceding one, you should convert to the appropriate type
    early on:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如前面的情况下，您应该尽早将其转换为适当的类型：
- en: '[PRE91]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Functions for Converting to Boolean, Number, String, and Object
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换为布尔值、数字、字符串和对象的函数
- en: 'The following functions are the preferred way of converting a value to a boolean,
    number, string, or object:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是将值转换为布尔值、数字、字符串或对象的首选方法：
- en: '`Boolean()` (see [Converting to Boolean](ch10.html#toboolean "Converting to
    Boolean"))'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boolean()`（见[转换为布尔值](ch10.html#toboolean "转换为布尔值"））'
- en: 'Converts a value to a boolean. The following values are converted to `false`;
    they are the so-called “falsy” values:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个值转换为布尔值。以下值被转换为`false`；它们被称为“假值”：
- en: '`undefined`, `null`'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`，`null`'
- en: '`false`'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`0`, `NaN`'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`，`NaN`'
- en: '`''''`'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''''`'
- en: All other values are considered “truthy” and converted to `true` (including
    all objects!).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他值都被视为“真值”，并转换为`true`（包括所有对象！）。
- en: '`Number()` (see [Converting to Number](ch11.html#tonumber "Converting to Number"))'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number()`（见[转换为数字](ch11.html#tonumber "转换为数字"））'
- en: 'Converts a value to a number:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个值转换为数字：
- en: '`undefined` becomes `NaN`.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`变为`NaN`。'
- en: '`null` becomes `0`.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`变为`0`。'
- en: '`false` becomes `0`, `true` becomes `1`.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`变为`0`，`true`变为`1`。'
- en: Strings are parsed.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串被解析。
- en: Objects are first converted to primitives (discussed shortly), which are then
    converted to numbers.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先将对象转换为原始值（稍后讨论），然后将其转换为数字。
- en: '`String()` (see [Converting to String](ch12.html#tostring "Converting to String"))'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`String()`（参见[转换为字符串](ch12.html#tostring "转换为字符串")）'
- en: 'Converts a value to a string. It has the obvious results for all primitives.
    For example:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 将值转换为字符串。对于所有原始值，它都有明显的结果。例如：
- en: '[PRE92]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Objects are first converted to primitives (discussed shortly), which are then
    converted to strings.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将对象转换为原始值（稍后讨论），然后将其转换为字符串。
- en: '`Object()` (see [Converting Any Value to an Object](ch17_split_000.html#toobject
    "Converting Any Value to an Object"))'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object()`（参见[将任何值转换为对象](ch17_split_000.html#toobject "将任何值转换为对象")）'
- en: 'Converts objects to themselves, `undefined` and `null` to empty objects, and
    primitives to wrapped primitives. For example:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象转换为它们自己，将`undefined`和`null`转换为空对象，将原始值转换为包装的原始值。例如：
- en: '[PRE93]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note that `Boolean()`, `Number()`, `String()`, and `Object()` are called as
    functions. You normally don’t use them as constructors. Then they create instances
    of themselves (see [Wrapper Objects for Primitives](ch08.html#wrapper_objects
    "Wrapper Objects for Primitives")).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Boolean()`、`Number()`、`String()`和`Object()`都被作为函数调用。你通常不会将它们用作构造函数。然后它们创建自己的实例（参见[原始值的包装对象](ch08.html#wrapper_objects
    "原始值的包装对象")）。
- en: 'Algorithm: ToPrimitive()—Converting a Value to a Primitive'
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法：ToPrimitive()——将值转换为原始值
- en: To convert a value to either a number or a string, it is first converted to
    an arbitrary primitive value, which is then converted to the final type (as discussed
    in [Functions for Converting to Boolean, Number, String, and Object](ch08.html#convert_to_primitive
    "Functions for Converting to Boolean, Number, String, and Object")).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要将值转换为数字或字符串，首先将其转换为任意原始值，然后将其转换为最终类型（如[用于转换为布尔值、数字、字符串和对象的函数](ch08.html#convert_to_primitive
    "用于转换为布尔值、数字、字符串和对象的函数")中所讨论的）。
- en: 'The ECMAScript specification has an internal function, `ToPrimitive()` (which
    is not accessible from JavaScript), that performs this conversion. Understanding
    `ToPrimitive()` enables you to configure how objects are converted to numbers
    and strings. It has the following signature:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript规范有一个内部函数`ToPrimitive()`（无法从JavaScript中访问），它执行这种转换。了解`ToPrimitive()`使你能够配置对象如何转换为数字和字符串。它有以下签名：
- en: '[PRE94]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The optional parameter `PreferredType` indicates the final type of the conversion:
    it is either `Number` or `String`, depending on whether the result of `ToPrimitive()`
    will be converted to a number or a string.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数`PreferredType`指示转换的最终类型：它可以是`Number`或`String`，具体取决于`ToPrimitive()`的结果将被转换为数字还是字符串。
- en: 'If `PreferredType` is `Number`, then you perform the following steps:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`PreferredType`是`Number`，则执行以下步骤：
- en: If `input` is primitive, return it (there is nothing more to do).
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`input`是原始的，就返回它（没有更多的事情要做了）。
- en: Otherwise, `input` is an object. Call `input.valueOf()`. If the result is primitive,
    return it.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，`input`是一个对象。调用`input.valueOf()`。如果结果是原始的，就返回它。
- en: Otherwise, call `input.toString()`. If the result is primitive, return it.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，调用`input.toString()`。如果结果是原始的，就返回它。
- en: Otherwise, throw a `TypeError` (indicating the failure to convert `input` to
    a primitive).
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，抛出`TypeError`（表示无法将`input`转换为原始值）。
- en: If `PreferredType` is `String`, steps 2 and 3 are swapped. The `PreferredType`
    can also be omitted; it is then considered to be `String` for dates and `Number`
    for all other values. This is how the operators `+` and `==` call `ToPrimitive()`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`PreferredType`是`String`，则步骤2和3会交换。`PreferredType`也可以省略；然后它被认为是日期的`String`，而对于所有其他值，则被认为是`Number`。这就是运算符`+`和`==`调用`ToPrimitive()`的方式。
- en: 'Examples: ToPrimitive() in action'
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例：ToPrimitive()的实际应用
- en: 'The default implementation of `valueOf()` returns `this`, while the default
    implementation of `toString()` returns type information:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`valueOf()`的默认实现返回`this`，而`toString()`的默认实现返回类型信息：'
- en: '[PRE95]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Therefore, `Number()` skips `valueOf()` and converts the result of `toString()`
    to a number; that is, it converts `''[object Object]''` to `NaN`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Number()`跳过`valueOf()`，将`toString()`的结果转换为数字；也就是说，它将`'[object Object]'`转换为`NaN`：
- en: '[PRE96]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The following object customizes `valueOf()`, which influences `Number()`, but
    doesn’t change anything for `String()`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对象自定义了`valueOf()`，它影响`Number()`，但对于`String()`没有任何改变：
- en: '[PRE97]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The following object customizes `toString()`. Because the result can be converted
    to a number, `Number()` can return a number:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对象自定义了`toString()`。因为结果可以转换为数字，所以`Number()`可以返回一个数字：
- en: '[PRE98]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '* * *'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[7](#id914993)]) Technically, primitive values do not have their own properties,
    they borrow them from wrapper constructors. But that is something that goes on
    behind the scenes, so you don’t normally see it.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#id914993)]) 从技术上讲，原始值没有自己的属性，它们从包装构造函数中借用。但这是在幕后进行的，所以你通常看不到它。
- en: Chapter 9. Operators
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章 运算符
- en: This chapter gives an overview of operators.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了运算符。
- en: Operators and Objects
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符和对象
- en: 'All operators coerce (as discussed in [Type Coercion](ch08.html#type_coercion
    "Type Coercion")) their operands to appropriate types. Most operators only work
    with primitive values (e.g., arithmetic operators and comparison operators). That
    means that objects are converted to primitives before anything is done with them.
    One example where that is unfortunate is the plus operator, which many languages
    use for array concatenation. That’s not so with JavaScript, however, where this
    operator converts arrays to strings and appends them:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 所有运算符都会强制转换（如[类型强制转换](ch08.html#type_coercion "类型强制转换")中所讨论的）它们的操作数为适当的类型。大多数运算符只能处理原始值（例如，算术运算符和比较运算符）。这意味着在对它们进行任何操作之前，对象都会被转换为原始值。其中一个不幸的例子是加号运算符，许多语言用它来进行数组连接。然而，在JavaScript中并非如此，这个运算符会将数组转换为字符串并将它们连接起来：
- en: '[PRE99]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is no way to overload or customize operators in JavaScript, not even equality.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中没有办法重载或自定义运算符，甚至没有相等性。
- en: Assignment Operators
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: 'There are several ways to use the plain assignment operator:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种使用普通赋值运算符的方法：
- en: '`x = value`'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`x = value`'
- en: Assigns to a variable `x` that has previously been declared
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给先前声明的变量`x`
- en: '`var x = value`'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`var x = value`'
- en: Combines a variable declaration with an assignment
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量声明与赋值结合
- en: '`obj.propKey = value`'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj.propKey = value`'
- en: Sets a property
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 设置属性
- en: '`obj[''propKey''] = value`'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj[''propKey''] = value`'
- en: Sets a property
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 设置属性
- en: '`arr[index] = value`'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr[index] = value`'
- en: Sets an array element^([[8](#ftn.id443353)])
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 设置数组元素^([[8](#ftn.id443353)])
- en: 'An assignment is an expression that evaluates to the assigned value. That allows
    you to chain assignments. For example, the following statement assigns `0` to
    both `y` and `x`:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值是一个求值为赋值的表达式。这允许您链接赋值。例如，以下语句将`0`分配给`y`和`x`：
- en: '[PRE100]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Compound Assignment Operators
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复合赋值运算符
- en: 'A *compound assignment operator* is written as `op=`, where `op` is one of
    several binary operators and `=` is the assignment operator. The following two
    expressions are equivalent:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '*复合赋值运算符*写为`op=`，其中`op`是几个二进制运算符之一，`=`是赋值运算符。以下两个表达式是等价的：'
- en: '[PRE101]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In other words, a compound assignment operator `op=` applies `op` to both operands
    and assigns the result to the first operand. Let’s look at an example of using
    the plus operator (`+`) via compound assignment:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，复合赋值运算符`op=`将`op`应用于两个操作数，并将结果分配给第一个操作数。让我们看一个使用加法运算符（`+`）的复合赋值的示例：
- en: '[PRE102]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The following are all compound assignment operators:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 以下都是复合赋值运算符：
- en: 'Arithmetic operations (see [Arithmetic Operators](ch11.html#arithmetic_operators
    "Arithmetic Operators")): `*=`, `/=`, `%=`, `+=`, `-=`'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算（参见[算术运算符](ch11.html#arithmetic_operators "算术运算符")）：`*=`, `/=`, `%=`, `+=`,
    `-=`
- en: 'Bitwise operations (see [Binary Bitwise Operators](ch11.html#binary_bitwise_operators
    "Binary Bitwise Operators")): `<<=`, `>>=`, `>>>=`, `&=`, `^=`, `|=`'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位操作（参见[二进制按位运算符](ch11.html#binary_bitwise_operators "二进制按位运算符")）：`<<=`, `>>=`,
    `>>>=`, `&=`, `^=`, `|=`
- en: 'String concatenation (see [Concatenation: The Plus (+) Operator](ch12.html#string_plus
    "Concatenation: The Plus (+) Operator")): `+=`'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串连接（参见[连接：加号（+）运算符](ch12.html#string_plus "连接：加号（+）运算符")）：`+=`
- en: 'Equality Operators: === Versus =='
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相等运算符：===与==
- en: 'JavaScript has two ways of determining whether two values are equal:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有两种确定两个值是否相等的方法：
- en: Strict equality (`===`) and strict inequality (`!==`) consider only values that
    have the same type to be equal.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格相等（`===`）和严格不等（`!==`）仅认为具有相同类型的值相等。
- en: Normal (or “lenient”) equality (`==`) and inequality (`!=`) try to convert values
    of different types before comparing them as with strict (in)equality.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常（或“宽松”）相等（`==`）和不等（`!=`）在比较之前尝试转换不同类型的值，就像严格（不）相等一样。
- en: Lenient equality is problematic in two regards. First, how it performs conversion
    is confusing. Second, due to the operators being so forgiving, type errors can
    remain hidden longer.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 宽松相等在两个方面存在问题。首先，它的转换方式令人困惑。其次，由于运算符如此宽容，类型错误可能会隐藏更长时间。
- en: Always use strict equality and avoid lenient equality. You only need to learn
    about the latter if you want to know why it should be avoided.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用严格相等，避免宽松相等。只有在您想知道为什么应该避免它时，才需要了解后者。
- en: Equality is not customizable. Operators can’t be overloaded in JavaScript, and
    you can’t customize how equality works. There are some operations where you often
    need to influence comparison—for example, `Array.prototype.sort()` (see [Sorting
    and Reversing Elements (Destructive)](ch18.html#Array.prototype.sort "Sorting
    and Reversing Elements (Destructive)")). That method optionally accepts a callback
    that performs all comparisons between array elements.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 相等是不可定制的。JavaScript中的运算符不能被重载，也不能定制相等的工作方式。有一些操作，您经常需要影响比较——例如，`Array.prototype.sort()`（参见[排序和反转元素（破坏性）](ch18.html#Array.prototype.sort
    "排序和反转元素（破坏性）")）。该方法可选择接受一个回调，该回调执行数组元素之间的所有比较。
- en: Strict Equality (===, !==)
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格相等（===, !==）
- en: 'Values with different types are never strictly equal. If both values have the
    same type, then the following assertions hold:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 具有不同类型的值永远不会严格相等。如果两个值具有相同的类型，则以下断言成立：
- en: '`undefined === undefined`'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined === undefined`'
- en: '`null === null`'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null === null`'
- en: 'Two numbers:'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个数字：
- en: '[PRE103]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Two booleans, two strings: obvious results'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个布尔值，两个字符串：显而易见的结果
- en: 'Two objects (including arrays and functions): `x === y` if and only if `x`
    and `y` are the same object; that is, if you want to compare different objects,
    you have to implement your own comparison algorithm:'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '两个对象（包括数组和函数）：`x === y`当且仅当`x`和`y`是同一个对象时；也就是说，如果要比较不同的对象，您必须实现自己的比较算法： '
- en: '[PRE104]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Everything else: not strictly equal.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他一切：不严格相等。
- en: 'Pitfall: NaN'
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：NaN
- en: 'The special number value `NaN` (see [NaN](ch11.html#nan "NaN")) is not equal
    to itself:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的数字值`NaN`（参见[NaN](ch11.html#nan "NaN")）不等于自身：
- en: '[PRE105]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Thus, you need to use other means to check for it, which are described in [Pitfall:
    checking whether a value is NaN](ch11.html#isNaN "Pitfall: checking whether a
    value is NaN").'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要使用其他方法来检查它，这些方法在[陷阱：检查值是否为NaN](ch11.html#isNaN "陷阱：检查值是否为NaN")中有描述。
- en: Strict inequality (!==)
  id: totrans-493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 严格不等 (!==)
- en: 'A strict inequality comparison:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 严格不等比较：
- en: '[PRE106]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'is equivalent to the negation of a strict equality comparison:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于严格相等比较的否定：
- en: '[PRE107]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Normal (Lenient) Equality (==, !=)
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正常（宽松）相等（==, !=）
- en: The algorithm for comparing via normal equality works as follows. If both operands
    have the same type (one of the six specification types—Undefined, Null, Boolean,
    Number, String, and Object), then compare them via strict equality.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 通过正常相等比较的算法工作如下。如果两个操作数具有相同的类型（六种规范类型之一——Undefined、Null、Boolean、Number、String和Object），则通过严格相等比较它们。
- en: 'Otherwise, if the operands are:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果操作数是：
- en: '`undefined` and `null`, then they are considered leniently equal:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`undefined`和`null`，那么它们被认为是宽松相等的：'
- en: '[PRE108]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: A string and a number, then convert the string to a number and compare both
    operands via strict equality.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个字符串和一个数字，然后将字符串转换为数字，并通过严格相等比较两个操作数。
- en: A boolean and a nonboolean, then convert the boolean to a number and compare
    leniently (again).
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个布尔值和一个非布尔值，然后将布尔值转换为数字并进行宽松比较（再次）。
- en: 'An object and a number or a string, then try to convert the object to a primitive
    (via the algorithm described in [Algorithm: ToPrimitive()—Converting a Value to
    a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting a Value
    to a Primitive")) and compare leniently (again).'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个对象和一个数字或字符串，然后尝试将对象转换为原始值（通过[算法：ToPrimitive()—将值转换为原始值](ch08.html#toprimitive
    "算法：ToPrimitive()—将值转换为原始值")中描述的算法）并进行宽松比较。
- en: Otherwise—if none of the aforementioned cases apply—the result of the lenient
    comparison is `false`.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 否则——如果上述任何情况都不适用——宽松比较的结果是`false`。
- en: Lenient inequality (!=)
  id: totrans-507
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 宽松不等号（!=）
- en: 'An inequality comparison:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不等式比较：
- en: '[PRE109]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'is equivalent to the negation of an equality comparison:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于等式比较的否定：
- en: '[PRE110]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Pitfall: lenient equality is different from conversion to boolean'
  id: totrans-512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：宽松相等与转换为布尔值不同
- en: 'Step 3 means that equality and conversion to boolean (see [Converting to Boolean](ch10.html#toboolean
    "Converting to Boolean")) work differently. If converted to boolean, numbers greater
    than 1 become `true` (e.g., in `if` statements). But those numbers are not leniently
    equal to `true`. The comments explain how the results were computed:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步意味着相等和转换为布尔值（参见[转换为布尔值](ch10.html#toboolean "转换为布尔值")）的工作方式不同。如果转换为布尔值，大于1的数字变为`true`（例如，在`if`语句中）。但这些数字并不宽松相等于`true`。注释解释了结果是如何计算的：
- en: '[PRE111]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Similarly, while the empty string is equal to `false`, not all nonempty strings
    are equal to `true`:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，虽然空字符串等于`false`，但并非所有非空字符串都等于`true`：
- en: '[PRE112]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Pitfall: lenient equality and strings'
  id: totrans-517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：宽松相等和字符串
- en: 'Some of the leniency can be useful, depending on what you want:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 一些宽松性可能是有用的，这取决于你的需求：
- en: '[PRE113]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Other cases are problematic, due to how JavaScript converts strings to numbers
    (see [Converting to Number](ch11.html#tonumber "Converting to Number")):'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 其他情况可能有问题，因为JavaScript如何将字符串转换为数字（参见[转换为数字](ch11.html#tonumber "转换为数字")）：
- en: '[PRE114]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Pitfall: lenient equality and objects'
  id: totrans-522
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：宽松相等和对象
- en: 'If you compare an object to a nonobject, it is converted to a primitive, which
    leads to strange results:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个对象与一个非对象进行比较，它会被转换为原始值，这会导致奇怪的结果：
- en: '[PRE115]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'However, two objects are only equal if they are they same object. That means
    that you can’t really compare two wrapper objects:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有两个对象是相等的，如果它们是同一个对象。这意味着你不能真正比较两个包装对象：
- en: '[PRE116]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: There Are No Valid Use Cases for ==
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有`==`的有效用例
- en: You sometimes read about valid use cases for lenient equality (`==`). This section
    lists them and points out better alternatives.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会读到关于宽松相等（`==`）的有效用例。本节列出了它们，并指出了更好的替代方案。
- en: 'Use case: checking for undefined or null'
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用例：检查undefined或null
- en: 'The following comparison ensures that `x` is neither `undefined` nor `null`:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 以下比较确保`x`既不是`undefined`也不是`null`：
- en: '[PRE117]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'While this is a compact way of writing this check, it confuses beginners, and
    experts can’t be sure whether it is a typo or not. Thus, if you want to check
    whether `x` has a value, use the standard check for truthiness (covered in [Truthy
    and Falsy Values](ch10.html#truthy_falsy "Truthy and Falsy Values")):'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一种简洁的写法，但它会让初学者感到困惑，而专家也无法确定它是否是打字错误。因此，如果你想检查`x`是否有值，请使用标准的真值检查（在[真值和假值](ch10.html#truthy_falsy
    "真值和假值")中介绍）：
- en: '[PRE118]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'If you want to be more precise, you should perform an explicit check for both
    values:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更精确，你应该对两个值进行显式检查：
- en: '[PRE119]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Use case: working with numbers in strings'
  id: totrans-536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用例：处理字符串中的数字
- en: 'If you are not sure whether a value `x` is a number or a number-as-a-string,
    you can use checks such as the following:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定一个值`x`是一个数字还是一个数字字符串，你可以使用以下检查：
- en: '[PRE120]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The preceding checks whether `x` is either `123` or `''123''`. Again, this
    is very compact, and again, it is better to be explicit:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的检查是为了确保`x`是`123`或`'123'`。同样，这是非常紧凑的，而且最好是明确的：
- en: '[PRE121]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Use case: comparing wrapper instances with primitives'
  id: totrans-541
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用例：比较包装实例和原始值
- en: 'Lenient equals lets you compare primitives with wrapped primitives:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 宽松相等允许你比较原始值和包装原始值：
- en: '[PRE122]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'There are three reasons against this approach. First, lenient equality does
    not work between wrapped primitives:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个理由反对这种方法。首先，宽松相等在包装原始值之间不起作用：
- en: '[PRE123]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Second, you should avoid wrappers anyway. Third, if you do use them, it is
    better to be explicit:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你应该无论如何避免使用包装器。第三，如果你使用它们，最好是明确的：
- en: '[PRE124]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Ordering Operators
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序运算符
- en: 'JavaScript knows the following ordering operators:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript知道以下排序运算符：
- en: Less than (`<`)
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于（`<`）
- en: Less than or equal (`<=`)
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于或等于（`<=`）
- en: Greater than (`>`)
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于（`>`）
- en: Greater than or equal (`>=`)
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于或等于（`>=`）
- en: 'These operators work for numbers and for strings:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符适用于数字和字符串：
- en: '[PRE125]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: For strings, they are not very useful, because they are case-sensitive and don’t
    handle features such as accents well (for details, see [Comparing Strings](ch12.html#comparing_strings
    "Comparing Strings")).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串来说，它们并不是非常有用，因为它们区分大小写，而且不能很好地处理重音等特性（有关详细信息，请参见[比较字符串](ch12.html#comparing_strings
    "比较字符串")）。
- en: The Algorithm
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法
- en: 'You evaluate a comparison:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 你评估一个比较：
- en: '[PRE126]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'by taking the following steps:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤：
- en: 'Ensure that both operands are primitives. Objects `obj` are converted to primitives
    via the internal operation `ToPrimitive(obj, Number)` (refer to [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")), which calls `obj.valueOf()` and, possibly, `obj.toString()`
    to do so.'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保两个操作数都是原始值。对象`obj`通过内部操作`ToPrimitive(obj, Number)`（参见[算法：ToPrimitive()—将值转换为原始值](ch08.html#toprimitive
    "算法：ToPrimitive()—将值转换为原始值")）转换为原始值，该操作调用`obj.valueOf()`和可能的`obj.toString()`来实现。
- en: If both operands are strings, then compare them by lexicographically comparing
    the 16-bit code units (see [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript"))
    that represent the JavaScript characters of the string.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个操作数都是字符串，那么通过按字典顺序比较表示字符串的JavaScript字符的16位代码单元（参见[第24章](ch24.html "第24章.
    Unicode and JavaScript")）来比较它们。
- en: Otherwise, convert both operands to numbers and compare them numerically.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，将两个操作数转换为数字并进行数字比较。
- en: The other ordering operators are handled similarly.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 其他排序运算符类似处理。
- en: The Plus Operator (+)
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加号运算符（+）
- en: 'Roughly, the plus operator examines its operands. If one of them is a string,
    the other is also converted to a string and both are concatenated:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，加号运算符检查它的操作数。 如果其中一个是字符串，则另一个也被转换为字符串，并且两者被连接：
- en: '[PRE127]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Otherwise, both operands are converted to numbers (see [Converting to Number](ch11.html#tonumber
    "Converting to Number")) and added:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，两个操作数都转换为数字（参见[转换为数字](ch11.html#tonumber "转换为数字")）并相加：
- en: '[PRE128]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'That means that the order in which you evaluate matters:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着评估的顺序很重要：
- en: '[PRE129]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The Algorithm
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法
- en: 'You evaluate an addition:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 你评估一个加法：
- en: '[PRE130]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'by taking the following steps:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '通过以下步骤进行： '
- en: 'Ensure that both operands are primitives. Objects `obj` are converted to primitives
    via the internal operation `ToPrimitive(obj)` (refer to [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")), which calls `obj.valueOf()` and, possibly, `obj.toString()`
    to do so. For dates, `obj.toString()` is called first.'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保两个操作数都是原始值。 对象`obj`通过内部操作`ToPrimitive(obj)`（参见[算法：ToPrimitive()—将值转换为原始值](ch08.html#toprimitive
    "算法：ToPrimitive()—将值转换为原始值")）转换为原始值，该操作调用`obj.valueOf()`和可能的`obj.toString()`来执行此操作。
    对于日期，首先调用`obj.toString()`。
- en: If either operand is a string, then convert both to strings and return the concatenation
    of the results.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任一操作数是字符串，则将两者转换为字符串并返回结果的连接。
- en: Otherwise, convert both operands to numbers and return the sum of the results.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，将两个操作数转换为数字，并返回结果的总和。
- en: Operators for Booleans and Numbers
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值和数字的运算符
- en: The following operators only have operands of a single type and also produce
    results of that type. They are covered elsewhere.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 以下运算符只有单一类型的操作数，并且也产生该类型的结果。 它们在其他地方有所涉及。
- en: 'Boolean operators:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符：
- en: 'Binary logical operators (see [Binary Logical Operators: And (&&) and Or (||)](ch10.html#binary_logical_operators
    "Binary Logical Operators: And (&&) and Or (||)")):'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制逻辑运算符（参见[二进制逻辑运算符：And (&&)和Or (||)](ch10.html#binary_logical_operators "二进制逻辑运算符：And
    (&&)和Or (||)")）：
- en: '[PRE131]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Logical Not (see [Logical Not (!)](ch10.html#logical_not "Logical Not (!)")):'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑非（参见[逻辑非(!)](ch10.html#logical_not "逻辑非(!)")）：
- en: '[PRE132]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Number operators:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 数字运算符：
- en: 'Arithmetic operators (see [Arithmetic Operators](ch11.html#arithmetic_operators
    "Arithmetic Operators")):'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符（参见[算术运算符](ch11.html#arithmetic_operators "算术运算符"）：
- en: '[PRE133]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Bitwise operators (see [Bitwise Operators](ch11.html#bitwise_operators "Bitwise
    Operators")):'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位运算符（参见[按位运算符](ch11.html#bitwise_operators "按位运算符"）：
- en: '[PRE134]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Special Operators
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊运算符
- en: Here we will review special operators, namely the conditional, comma, and `void`
    operators.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将回顾特殊运算符，即条件、逗号和`void`运算符。
- en: 'The Conditional Operator ( ? : )'
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件运算符（？：）
- en: 'The conditional operator is an expression:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符是一个表达式：
- en: '[PRE135]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'If the condition is `true`, the result is `if_true`; otherwise, the result
    is `if_false`. For example:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件为`true`，则结果为`if_true`； 否则，结果为`if_false`。 例如：
- en: '[PRE136]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The parentheses around the operator are not needed, but they make it easier
    to read.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要在运算符周围加括号，但这样做会使其更易于阅读。
- en: The Comma Operator
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逗号运算符
- en: '[PRE137]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The comma operator evaluates both operands and returns the result of `right`.
    Roughly, it does for expressions what the semicolon does for statements.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符评估两个操作数并返回“right”的结果。 粗略地说，它对表达式做了分号对语句所做的事情。
- en: 'This example demonstrates that the second operand becomes the result of the
    operator:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了第二个操作数成为运算符的结果：
- en: '[PRE138]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'This example demonstrates that both operands are evaluated:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了两个操作数都被评估：
- en: '[PRE139]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The comma operator is confusing. It’s better to not be clever and to write two
    separate statements whenever you can.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符很令人困惑。 最好不要聪明，而是在您可以的情况下编写两个单独的语句。
- en: The void Operator
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: void运算符
- en: 'The syntax for the `void` operator is:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`运算符的语法是：'
- en: '[PRE140]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'which evaluates `expr` and returns `undefined`. Here are some examples:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 评估`expr`并返回`undefined`。 以下是一些例子：
- en: '[PRE141]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Thus, if you implement `void` as a function, it looks as follows:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您将`void`实现为一个函数，它看起来如下：
- en: '[PRE142]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The `void` operator is associated closely with its operand, so use parentheses
    as necessary. For example, `void 4+7` binds as `(void 4)+7`.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`运算符与其操作数密切相关，因此根据需要使用括号。 例如，`void 4+7`绑定为`(void 4)+7`。'
- en: What is void used for?
  id: totrans-615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: void用于什么？
- en: 'Under ECMAScript 5, `void` is rarely useful. Its main use cases are:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 5下，`void`很少有用。 它的主要用例是：
- en: '`void 0` as a synonym for `undefined`'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`void 0`作为`undefined`的同义词'
- en: The latter can be changed, while the former will always have the correct value.
    However, `undefined` is reasonably safe from being changed under ECMAScript 5,
    which makes this use case less important (for details, see [Changing undefined](ch08.html#changing_undefined
    "Changing undefined")).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 后者可以更改，而前者将始终具有正确的值。 但是，在ECMAScript 5下，`undefined`相对安全，这使得这种用例不那么重要（有关详细信息，请参见[更改undefined](ch08.html#changing_undefined
    "更改undefined")）。
- en: Discarding the result of an expression
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 丢弃表达式的结果
- en: 'In some situations, it is important to return `undefined` as opposed to the
    result of an expression. Then `void` can be used to discard that result. One such
    situation involves `javascript:` URLs, which should be avoided for links, but
    are useful for bookmarklets. When you visit one of those URLs, many browsers replace
    the current document with the result of evaluating the URL’s “content,” but only
    if the result isn’t `undefined`. Hence, if you want to open a new window without
    changing the currently displayed content, you can do the following:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，返回`undefined`而不是表达式的结果很重要。 然后可以使用`void`来丢弃该结果。 其中一种情况涉及`javascript:`
    URL，应该避免使用链接，但对于书签很有用。 当您访问这些URL之一时，许多浏览器会用URL的“内容”评估结果替换当前文档，但前提是结果不是`undefined`。
    因此，如果您想要打开一个新窗口而不更改当前显示的内容，可以执行以下操作：
- en: '[PRE143]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Prefixing an IIFE
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀IIFE
- en: 'An IIFE must be parsed as an expression. One of several ways to ensure that
    is by prefixing it with `void` (see [IIFE Variation: Prefix Operators](ch16.html#iife_prefix
    "IIFE Variation: Prefix Operators")).^([[9](#ftn.id936155)])'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 'IIFE必须被解析为表达式。确保这一点的几种方法之一是用`void`作为前缀（参见[IIFE变体：前缀运算符](ch16.html#iife_prefix
    "IIFE Variation: Prefix Operators")）^([[9](#ftn.id936155)])'
- en: Why does JavaScript have a void operator?
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么JavaScript有void运算符？
- en: 'According to JavaScript creator Brendan Eich, he added it to the language to
    help with `javascript:` links (one of the aforementioned use cases):'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JavaScript的创始人Brendan Eich，他将其添加到语言中以帮助处理`javascript:`链接（前面提到的用例之一）：
- en: 'I added the `void` operator to JS before Netscape 2 shipped to make it easy
    to discard any non-undefined value in a javascript: URL.^([[10](#ftn.id872078)])'
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '我在Netscape 2发布之前向JS添加了`void`运算符，以便轻松丢弃javascript: URL中的任何非undefined值。^([[10](#ftn.id872078)])'
- en: Categorizing Values via typeof and instanceof
  id: totrans-627
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过typeof和instanceof对值进行分类
- en: 'If you want to categorize a value, you unfortunately have to distinguish between
    primitives and objects (refer back to [Chapter 8](ch08.html "Chapter 8. Values"))
    in JavaScript:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对一个值进行分类，不幸的是你必须区分原始值和对象（参见[第8章](ch08.html "第8章. Values")中的内容）：
- en: The `typeof` operator distinguishes primitives from objects and determines the
    types of primitives.
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: typeof运算符区分原始值和对象，并确定原始值的类型。
- en: The `instanceof` operator determines whether an object is an instance of a given
    constructor. Consult [Chapter 17](ch17_split_000.html "Chapter 17. Objects and
    Inheritance") for more information on object-oriented programming in JavaScript.
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instanceof`运算符确定一个对象是否是给定构造函数的实例。有关JavaScript中面向对象编程的更多信息，请参阅[第17章](ch17_split_000.html
    "第17章. Objects and Inheritance")。'
- en: 'typeof: Categorizing Primitives'
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: typeof：对原始值进行分类
- en: 'The `typeof` operator:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: typeof运算符：
- en: '[PRE144]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'returns a string describing what kind of value `value` is. Here are some examples:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 返回描述`value`是什么类型的字符串。以下是一些例子：
- en: '[PRE145]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '`typeof` is used to distinguish primitives and objects and to categorize primitives
    (which cannot be handled by `instanceof`). Unfortunately, the results of this
    operator are not completely logical and only loosely correspond to the types of
    the ECMAScript specification (which are explained in [JavaScript’s Types](ch08.html#javascript_types
    "JavaScript’s Types")):'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`用于区分原始值和对象，并对原始值进行分类（`instanceof`无法处理原始值）。不幸的是，这个运算符的结果并不完全符合逻辑，而且只是松散地对应于ECMAScript规范的类型（在[JavaScript的类型](ch08.html#javascript_types
    "JavaScript’s Types")中有解释）：'
- en: '| Operand | Result |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| 操作数 | 结果 |'
- en: '| --- | --- |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `undefined`, undeclared variable | `''undefined''` |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| `undefined`，未声明的变量 | `''undefined''` |'
- en: '| `null` | `''object''` |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `''object''` |'
- en: '| Boolean value | `''boolean''` |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | `''boolean''` |'
- en: '| Number value | `''number''` |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '| 数值 | `''number''` |'
- en: '| String value | `''string''` |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| 字符串值 | `''string''` |'
- en: '| Function | `''function''` |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | `''function''` |'
- en: '| All other normal values | `''object''` |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| 所有其他正常值 | `''object''` |'
- en: '| (Engine-created value) | JavaScript engines are allowed to create values
    for whom `typeof` returns arbitrary strings (different from all results listed
    in this table). |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| （引擎创建的值） | JavaScript引擎允许创建值，对于这些值，`typeof`返回任意字符串（与表中列出的所有结果不同）。'
- en: 'Pitfall: typeof null'
  id: totrans-647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：typeof null
- en: 'Unfortunately, `typeof null` is `''object''`. This is considered a bug (`null`
    is not a member of the internal type Object), but it can’t be fixed, because doing
    so would break existing code. You thus have to be wary of `null`. For example,
    the following function checks whether `value` is an object:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`typeof null`是`'object'`。这被认为是一个错误（`null`不是内部类型Object的成员），但无法修复，因为这样做会破坏现有的代码。因此，你必须谨慎处理`null`。例如，以下函数检查`value`是否是一个对象：
- en: '[PRE146]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Trying it out:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 试一试：
- en: '[PRE147]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The history of typeof null
  id: totrans-652
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: typeof null的历史
- en: The [first JavaScript engine](http://mzl.la/1oO9VF7) represented JavaScript
    values as 32-bit words. The lowest 3 bits of such a word were used as a type tag,
    to indicate whether the value was an object, an integer, a double, a string, or
    a boolean (as you can see, even this early engine already stored numbers as integers
    if possible).
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个JavaScript引擎将JavaScript值表示为32位字。这样的字的最低3位用作类型标记，以指示该值是对象、整数、双精度、字符串还是布尔值（正如你所看到的，即使这个早期引擎已经尽可能将数字存储为整数）。
- en: The type tag for objects was 000\. In order to represent the value `null`, the
    engine used the machine language NULL pointer, a word where all bits are zero.
    `typeof` checked the type tag to determine the type of value, which is why it
    reported `null` to be an object.^([[11](#ftn.id894831)])
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的类型标记为000。为了表示值`null`，引擎使用了机器语言的NULL指针，一个所有位都为零的字。`typeof`检查类型标记以确定值的类型，这就是为什么它报告`null`是一个对象的原因。^([[11](#ftn.id894831)])
- en: Checking whether a variable exists
  id: totrans-655
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查变量是否存在
- en: 'The check:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 检查：
- en: '[PRE148]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'has two use cases:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种用例：
- en: It determines whether `x` is `undefined`.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它确定`x`是否`undefined`。
- en: It determines whether the variable `x` exists.
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它确定变量`x`是否存在。
- en: 'Here are examples of both use cases:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两种用例的示例：
- en: '[PRE149]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'For the first use case, comparing directly with `undefined` is usually a better
    choice. However, it doesn’t work for the second use case:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个用例，直接与`undefined`进行比较通常是更好的选择。但是，对于第二个用例，这种方法行不通。
- en: '[PRE150]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'instanceof: Checking Whether an Object Is an Instance of a Given Constructor'
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: instanceof：检查对象是否是给定构造函数的实例
- en: 'The `instanceof` operator:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`运算符：'
- en: '[PRE151]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'determines whether `value` has been created by the constructor `Constr` or
    a subconstructor. Here are some examples:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 确定`value`是由构造函数`Constr`还是子构造函数创建的。以下是一些例子：
- en: '[PRE152]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'As expected, `instanceof` is `false` for the nonvalues `undefined` and `null`:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的是，`instanceof`对非值`undefined`和`null`返回`false`：
- en: '[PRE153]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'But it is also `false` for all other primitive values:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于所有其他原始值也是`false`：
- en: '[PRE154]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: For details on `instanceof`, consult [The instanceof Operator](ch17_split_001.html#operator_instanceof
    "The instanceof Operator").
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`instanceof`的详细信息，请参阅[instanceof运算符](ch17_split_001.html#operator_instanceof
    "The instanceof Operator")。
- en: Object Operators
  id: totrans-675
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象运算符
- en: 'The following three operators work on objects. They are explained elsewhere:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个运算符适用于对象。它们在其他地方有解释：
- en: '`new` (see [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances"))'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`（参见[第三层：构造函数——实例的工厂](ch17_split_001.html#constructors "第三层：构造函数——实例的工厂")）'
- en: Invoke a constructor—for example, `new Point(3, 5)`
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 调用构造函数，例如，`new Point(3, 5)`
- en: '`delete` (see [Deleting properties](ch17_split_000.html#operator_delete "Deleting
    properties"))'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`（参见[删除属性](ch17_split_000.html#operator_delete "删除属性")）'
- en: Delete a property—for example, `delete obj.prop`
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 删除属性，例如，`delete obj.prop`
- en: '`in` (see [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties"))'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`（参见[迭代和属性检测](ch17_split_000.html#iterate_and_detect_properties "迭代和属性检测")）'
- en: Check whether an object has a given property—for example, `'prop' in obj`
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 检查对象是否具有给定属性，例如，`'prop' in obj`
- en: '* * *'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[8](#id443353)]) Strictly speaking, setting an array element is a special
    case of setting a property.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[8](#id443353)]) 严格来说，设置数组元素是设置属性的特例。
- en: ^([[9](#id936155)]) Thanks to Brandon Benvie (@benvie), who told me about using
    `void` for IIFEs.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[9](#id936155)]) 感谢 Brandon Benvie (@benvie)，他告诉我如何使用`void`来进行 IIFEs。
- en: '^([[10](#id872078)]) Source: [http://en.wikipedia.org/wiki/Bookmarklet](http://en.wikipedia.org/wiki/Bookmarklet)'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[10](#id872078)]) 来源：[http://en.wikipedia.org/wiki/Bookmarklet](http://en.wikipedia.org/wiki/Bookmarklet)
- en: ^([[11](#id894831)]) Thanks to Tom Schuster (@evilpies) for pointing me to the
    source code of the first JavaScript engine.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[11](#id894831)]) 感谢 Tom Schuster (@evilpies) 指引我到第一个 JavaScript 引擎的源代码。
- en: Chapter 10. Booleans
  id: totrans-688
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章。布尔值
- en: 'The primitive boolean type comprises the values `true` and `false`:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 原始布尔类型包括值`true`和`false`：
- en: '[PRE155]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Converting to Boolean
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为布尔值
- en: 'Values are converted to booleans as follows:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换为布尔值的方式如下：
- en: '| Value | Converted to boolean |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 转换为布尔值 |'
- en: '| --- | --- |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `undefined` | `false` |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` | `false` |'
- en: '| `null` | `false` |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `false` |'
- en: '| A boolean | Same as input (nothing to convert) |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| 一个布尔值 | 与输入相同（无需转换） |'
- en: '| A number | `0`, `NaN` → `false` |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| 一个数字 | `0`、`NaN` → `false` |'
- en: '|  | other numbers → `true` |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '|  | 其他数字 → `true` |'
- en: '| A string | `''''` → `false` |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
  zh: '| 一个字符串 | `''''` → `false` |'
- en: '|  | other strings → `true` |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '|  | 其他字符串 → `true` |'
- en: '| An object | `true` (always!) |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '| 一个对象 | `true`（总是！） |'
- en: Manually Converting to Boolean
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动转换为布尔值
- en: 'There are three ways any value can be converted to a boolean:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 任何值都可以通过三种方式转换为布尔值：
- en: '| `Boolean(value)` | (Invoked as a function, not as a constructor) |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '| `Boolean(value)` | （作为函数调用，而不是构造函数） |'
- en: '| `value ? true : false` |  |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '| `value ? true : false` |  |'
- en: '| `!!value` | A single “not” converts to negated boolean; use twice for the
    nonnegated conversion. |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '| `!!value` | 单个“not”转换为取反的布尔值；使用两次进行非取反转换。 |'
- en: 'I prefer `Boolean()`, because it is more descriptive. Here are some examples:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢`Boolean()`，因为它更具描述性。以下是一些例子：
- en: '[PRE156]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Truthy and Falsy Values
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真值和假值
- en: 'Wherever JavaScript expects a boolean, you can provide any kind of value and
    it is automatically converted to boolean. Thus, there are two sets of values in
    JavaScript: one set is converted to `false`, while the other set is converted
    to `true`. These sets are called *falsy values* and *truthy values*. Given the
    preceding table, the following are all falsy values:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 需要布尔值的地方，你可以提供任何类型的值，它会自动转换为布尔值。因此，在 JavaScript 中有两组值：一组转换为`false`，而另一组转换为`true`。这些组被称为*假值*和*真值*。根据前面的表格，以下是所有的假值：
- en: '`undefined`, `null`'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`、`null`'
- en: 'Boolean: `false`'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：`false`
- en: 'Number: `0`, `NaN`'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：`0`、`NaN`
- en: 'String: `''''`'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：`''`
- en: 'All other values—including *all* objects, even empty objects, empty arrays,
    and `new Boolean(false)`—are truthy. Because `undefined` and `null` are falsy,
    you can use the `if` statement to check whether a variable `x` has a value:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他值，包括*所有*对象，甚至是空对象、空数组和`new Boolean(false)`，都是真值。因为`undefined`和`null`是假值，你可以使用`if`语句来检查变量`x`是否有值：
- en: '[PRE157]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The caveat is that the preceding check interprets all falsy values as “does
    not have a value,” not just `undefined` and `null`. But if you can live with that
    limitation, you get to use a compact and established pattern.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，前面的检查将所有假值解释为“没有值”，不仅仅是`undefined`和`null`。但如果你可以接受这个限制，你就可以使用一种简洁和成熟的模式。
- en: 'Pitfall: all objects are truthy'
  id: totrans-719
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：所有对象都是真值
- en: 'All objects are truthy:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象都是真值：
- en: '[PRE158]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'That is different from how objects are converted to a number or string, where
    you can control the result by implementing the methods `valueOf()` and `toString()`:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 这与对象转换为数字或字符串的方式不同，你可以通过实现`valueOf()`和`toString()`方法来控制结果。
- en: '[PRE159]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'History: Why are objects always truthy?'
  id: totrans-724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 历史：为什么对象总是真值？
- en: The conversion to boolean is different for historic reasons. For ECMAScript 1,
    it was decided to not enable objects to configure that conversion (e.g., via a
    `toBoolean()` method). The rationale was that the boolean operators `||` and `&&`
    preserve the values of their operands. Therefore, if you chain those operators,
    the same value may be checked multiple times for truthiness or falsiness. Such
    checks are cheap for primitives, but would be costly for objects if they were
    able to configure their conversion to boolean. ECMAScript 1 avoided that cost
    by making objects always truthy.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，布尔值的转换方式不同。在 ECMAScript 1 中，决定不允许对象配置该转换（例如，通过`toBoolean()`方法）。其理由是布尔运算符`||`和`&&`会保留其操作数的值。因此，如果你链式使用这些运算符，相同的值可能会被多次检查真值或假值。对于原始值来说，这些检查是廉价的，但如果对象能够配置它们的布尔值转换，那么对于对象来说将会很昂贵。ECMAScript
    1 通过使对象始终为真值来避免这种成本。
- en: Logical Operators
  id: totrans-726
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: In this section, we cover the basics of the And (&&), Or (||), and Not (!) logical
    operators.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 And（&&）、Or（||）和Not（!）逻辑运算符的基础知识。
- en: 'Binary Logical Operators: And (&&) and Or (||)'
  id: totrans-728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制逻辑运算符：And（&&）和Or（||）
- en: 'Binary logical operators are:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制逻辑运算符有：
- en: Value-preserving
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 保持值不变
- en: 'They always return either one of the operands, unchanged:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 它们总是返回两个操作数中的一个，不会改变：
- en: '[PRE160]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Short-circuiting
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 短路
- en: 'The second operand is not evaluated if the first operand already determines
    the result. For example (the result of `console.log` is `undefined`):'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数已经确定了结果，则不会评估第二个操作数。例如（`console.log`的结果是`undefined`）：
- en: '[PRE161]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: That is uncommon behavior for operators. Normally, all operands are evaluated
    before an operator is invoked (just like for functions).
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运算符的不常见行为。通常，在调用运算符之前会评估所有操作数（就像函数一样）。
- en: Logical And (&&)
  id: totrans-737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑与（&&）
- en: 'If the first operand can be converted to `false`, return it. Otherwise, return
    the second operand:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数可以转换为`false`，则返回它。否则，返回第二个操作数：
- en: '[PRE162]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Logical Or (||)
  id: totrans-740
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑或（||）
- en: 'If the first operand can be converted to `true`, return it. Otherwise, return
    the second operand:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数可以转换为`true`，则返回它。否则，返回第二个操作数：
- en: '[PRE163]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Pattern: providing a default value'
  id: totrans-743
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模式：提供默认值
- en: 'Sometimes there are situations where a value (a parameter, the result of a
    function, etc.) can be either a nonvalue (`undefined`, `null`) or an actual value.
    If you want to provide a default value for the former case, you can use the Or
    operator:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会出现这样的情况：一个值（参数、函数的结果等）可以是非值（`undefined`、`null`）或实际值。如果要为前一种情况提供默认值，可以使用或运算符：
- en: '[PRE164]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The preceding expression evaluates to `theValue` if it is truthy and to `defaultValue`
    otherwise. The usual caveat applies: `defaultValue` will also be returned if `theValue`
    has a falsy value other than `undefined` and `null`. Let’s look at three examples
    of using that pattern.'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式在`theValue`为真值时求值为`theValue`，否则为`defaultValue`。通常的警告适用：如果`theValue`具有除`undefined`和`null`之外的假值，则也将返回`defaultValue`。让我们看看使用该模式的三个示例。
- en: 'Example 1: a default for a parameter'
  id: totrans-747
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例1：参数的默认值
- en: 'The parameter `text` of the function `saveText()` is optional and should be
    the empty string if it has been omitted:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`saveText()`的参数`text`是可选的，如果省略了，则应该是空字符串：
- en: '[PRE165]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: This is the most common use of `||` as a default operator. Consult [Optional
    Parameters](ch15.html#optional_parameters "Optional Parameters") for more on optional
    parameters.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`||`作为默认运算符的最常见用法。有关可选参数的更多信息，请参阅[可选参数](ch15.html#optional_parameters "可选参数")。
- en: 'Example 2: a default for a property'
  id: totrans-751
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例2：属性的默认值
- en: 'The object `options` may or may not have the property `title`. If it is missing,
    the value `''Untitled''` should be used when setting the title:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`options`可能有也可能没有属性`title`。如果缺少，则在设置标题时应使用值`'Untitled'`：
- en: '[PRE166]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Example 3: a default for the result of a function'
  id: totrans-754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例3：函数结果的默认值
- en: 'The function `countOccurrences` counts how often `regex` matches inside `str`:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`countOccurrences`计算`regex`在`str`中匹配的次数：
- en: '[PRE167]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'The problem is that `match()` (see [String.prototype.match: Capture Groups
    or Return All Matching Substrings](ch19.html#String.prototype.match "String.prototype.match:
    Capture Groups or Return All Matching Substrings")) either returns an array or
    `null`. Thanks to `||`, a default value is used in the latter case. Therefore,
    you can safely access the property `length` in both cases.'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '问题在于`match()`（请参见[String.prototype.match: Capture Groups or Return All Matching
    Substrings](ch19.html#String.prototype.match "String.prototype.match: Capture
    Groups or Return All Matching Substrings")）要么返回一个数组，要么返回`null`。由于`||`，在后一种情况下使用了默认值。因此，您可以安全地在两种情况下访问属性`length`。'
- en: Logical Not (!)
  id: totrans-758
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑非（！）
- en: 'The logical not operator `!` converts its operand to boolean and then negates
    it:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑非运算符`!`将其操作数转换为布尔值，然后对其取反：
- en: '[PRE168]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Equality Operators, Ordering Operators
  id: totrans-761
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相等运算符，排序运算符
- en: 'The following operators are covered elsewhere:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 其他运算符在其他地方有所涵盖：
- en: 'Equality operators: `===`, `!==`, `==`, `!=` (see [Equality Operators: ===
    Versus ==](ch09.html#equality_operators "Equality Operators: === Versus =="))'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等运算符：`===`，`!==`，`==`，`!=`（参见[相等运算符：===与==](ch09.html#equality_operators "相等运算符：===与==")）
- en: 'Ordering operators: `>`, `>=`, `<`, `<=` (see [Ordering Operators](ch09.html#ordering_operators
    "Ordering Operators"))'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序运算符：`>`，`>=`，`<`，`<=`（参见[排序运算符](ch09.html#ordering_operators "排序运算符")）
- en: The Function Boolean
  id: totrans-765
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔函数
- en: 'The function `Boolean` can be invoked in two ways:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`Boolean`可以以两种方式调用：
- en: '`Boolean(value)`'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boolean(value)`'
- en: 'As a normal function, it converts `value` to a primitive boolean (see [Converting
    to Boolean](ch10.html#toboolean "Converting to Boolean")):'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 作为普通函数，它将`value`转换为原始布尔值（请参见[转换为布尔值](ch10.html#toboolean "转换为布尔值")）：
- en: '[PRE169]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '`new Boolean(bool)`'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Boolean(bool)`'
- en: 'As a constructor, it creates a new instance of `Boolean` (see [Wrapper Objects
    for Primitives](ch08.html#wrapper_objects "Wrapper Objects for Primitives")),
    an object that wraps `bool` (after converting it to a boolean). For example:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 作为构造函数，它创建了`Boolean`的新实例（参见[原始包装对象](ch08.html#wrapper_objects "原始包装对象")），一个将`bool`（在将其转换为布尔值后）包装起来的对象。例如：
- en: '[PRE170]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: The former invocation is the common one.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的调用是常见的。
- en: Chapter 11. Numbers
  id: totrans-774
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章。数字
- en: 'JavaScript has a single type for all numbers: it treats all of them as floating-point
    numbers. However, the dot is not displayed if there are no digits after the decimal
    point:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对所有数字都使用单一类型：它将它们全部视为浮点数。但是，如果小数点后没有数字，则不显示小数点：
- en: '[PRE171]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Internally, most JavaScript engines optimize and do distinguish between floating-point
    numbers and integers (details: [Integers in JavaScript](ch11.html#integers "Integers
    in JavaScript")). But that is something that programmers don’t see.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，大多数JavaScript引擎都会优化并区分浮点数和整数（详情请参见[JavaScript中的整数](ch11.html#integers "JavaScript中的整数")）。但这是程序员看不到的东西。
- en: JavaScript numbers are `double` (64-bit) values, based on the IEEE Standard
    for Floating-Point Arithmetic (IEEE 754). That standard is used by many programming
    languages.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript数字是基于IEEE浮点算术标准（IEEE 754）的`double`（64位）值。该标准被许多编程语言使用。
- en: Number Literals
  id: totrans-779
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字文字
- en: 'A number literal can be an integer, floating point, or (integer) hexadecimal:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 数字文字可以是整数、浮点数或（整数）十六进制：
- en: '[PRE172]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Exponent
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指数
- en: 'An exponent, `eX`, is an abbreviation for “multiply with 10^X”:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 指数`eX`是“乘以10^X”的缩写：
- en: '[PRE173]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Invoking Methods on Literals
  id: totrans-785
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在文字上调用方法
- en: 'With number literals, the dot for accessing a property must be distinguished
    from the decimal dot. This leaves you with the following options if you want to
    invoke `toString()` on the number literal `123`:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数字文字，访问属性的点必须与小数点区分开。如果要在数字文字`123`上调用`toString()`，则有以下选项：
- en: '[PRE174]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Converting to Number
  id: totrans-788
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为数字
- en: 'Values are converted to numbers as follows:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 将值转换为数字的方式如下：
- en: '| Value | Result |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 结果 |'
- en: '| --- | --- |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `undefined` | `NaN` |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` | `NaN` |'
- en: '| `null` | `0` |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `0` |'
- en: '| A boolean | `false` → `0` |'
  id: totrans-794
  prefs: []
  type: TYPE_TB
  zh: '| 一个布尔值 | `false` → `0` |'
- en: '|  | `true` → `1` |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '|  | `true` → `1` |'
- en: '| A number | Same as input (nothing to convert) |'
  id: totrans-796
  prefs: []
  type: TYPE_TB
  zh: '| 一个数字 | 与输入相同（无需转换）|'
- en: '| A string | Parse the number in the string (ignoring leading and trailing
    whitespace); the empty string is converted to 0. Example: `''3.141''` → `3.141`
    |'
  id: totrans-797
  prefs: []
  type: TYPE_TB
  zh: '| 一个字符串 | 解析字符串中的数字（忽略前导和尾随空格）；空字符串转换为0。示例：`''3.141''` → `3.141` |'
- en: '| An object | Call `ToPrimitive(value, Number)` (see [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")) and convert the resulting primitive. |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
  zh: '| 一个对象 | 调用`ToPrimitive(value, Number)`（参见[算法：ToPrimitive()—将值转换为原始值](ch08.html#toprimitive
    "算法：ToPrimitive()—将值转换为原始值")）并转换生成的原始值。|'
- en: When converting the empty string to a number, `NaN` would arguably be a better
    result. The result 0 was chosen to help with empty numeric input fields, in line
    with what other programming languages did in the mid-1990s.^([[12](#ftn.id995098)])
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 将空字符串转换为数字时，`NaN`可能是更好的结果。选择结果0是为了帮助处理空的数字输入字段，符合1990年代中期其他编程语言的做法。^([[12](#ftn.id995098)])
- en: Manually Converting to Number
  id: totrans-800
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动转换为数字
- en: 'The two most common ways to convert any value to a number are:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何值转换为数字的两种最常见方法是：
- en: '| `Number(value)` | (Invoked as a function, not as a constructor) |'
  id: totrans-802
  prefs: []
  type: TYPE_TB
  zh: '| `Number(value)` |（作为函数调用，而不是作为构造函数调用）|'
- en: '| `+value` |  |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
  zh: '| `+value` |  |'
- en: 'I prefer `Number()`, because it is more descriptive. Here are some examples:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢`Number()`，因为它更具描述性。以下是一些示例：
- en: '[PRE175]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: parseFloat()
  id: totrans-806
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: parseFloat()
- en: 'The global function `parseFloat()` provides another way to convert values to
    numbers. However, `Number()` is usually a better choice, as we shall see in a
    moment. This code:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 全局函数`parseFloat()`提供了另一种将值转换为数字的方法。但是，`Number()`通常是更好的选择，我们稍后将看到。这段代码：
- en: '[PRE176]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: converts `str` to string, trims leading whitespace, and then parses the longest
    prefix that is a floating-point number. If no such prefix exists (e.g., in an
    empty string), `NaN` is returned.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 将`str`转换为字符串，修剪前导空格，然后解析最长的浮点数前缀。如果不存在这样的前缀（例如，在空字符串中），则返回`NaN`。
- en: 'Comparing `parseFloat()` and `Number()`:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 比较`parseFloat()`和`Number()`：
- en: 'Applying `parseFloat()` to a nonstring is less efficient, because it coerces
    its argument to a string before parsing it. As a consequence, many values that
    `Number()` converts to actual numbers are converted to `NaN` by `parseFloat()`:'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`parseFloat()`应用于非字符串的效率较低，因为它在解析之前将其参数强制转换为字符串。因此，`Number()`转换为实际数字的许多值被`parseFloat()`转换为`NaN`：
- en: '[PRE177]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '`parseFloat()` parses the empty string as `NaN`:'
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseFloat()`将空字符串解析为`NaN`：'
- en: '[PRE178]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '`parseFloat()` parses until the last legal character, meaning you get a result
    where you may not want one:'
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseFloat()`解析到最后一个合法字符，这意味着您可能会得到一个您不想要的结果：'
- en: '[PRE179]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '`parseFloat()` ignores leading whitespace and stops before illegal characters
    (which include whitespace):'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseFloat()`忽略前导空格，并在非法字符之前停止（其中包括空格）：'
- en: '[PRE180]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '`Number()` ignores both leading and trailing whitespace (but other illegal
    characters lead to `NaN`).'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number()`忽略前导和尾随空格（但其他非法字符会导致`NaN`）。'
- en: Special Number Values
  id: totrans-820
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊数字值
- en: 'JavaScript has several special number values:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有几个特殊的数字值：
- en: Two error values, `NaN` and `Infinity`.
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个错误值，`NaN`和`Infinity`。
- en: Two values for zero, `+0` and `-0`. JavaScript has two zeros, a positive zero
    and a negative zero, because the sign and the magnitude of a number are stored
    separately. In most of this book, I pretend that there is only a single zero,
    and you almost never see in JavaScript that there are two of them.
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个零值，`+0`和`-0`。JavaScript有两个零，一个正零和一个负零，因为数字的符号和大小存储在不同的位置。在本书的大部分内容中，我假设只有一个零，并且您几乎从不在JavaScript中看到有两个零。
- en: NaN
  id: totrans-824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NaN
- en: 'The error value `NaN` (an abbreviation for “not a number”) is, ironically,
    a number value:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 错误值`NaN`（“不是一个数字”的缩写）是一个数字值，具有讽刺意味：
- en: '[PRE181]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'It is produced by errors such as the following:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 它是由以下错误产生的：
- en: 'A number could not be parsed:'
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法解析数字：
- en: '[PRE182]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'An operation failed:'
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作失败：
- en: '[PRE183]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'One of the operands is `NaN` (this ensures that, if an error occurs during
    a longer computation, you can see it in the final result):'
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数之一是`NaN`（这可以确保在较长的计算过程中发生错误时，您可以在最终结果中看到它）：
- en: '[PRE184]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Pitfall: checking whether a value is NaN'
  id: totrans-834
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：检查值是否为NaN
- en: '`NaN` is the only value that is not equal to itself:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`是唯一不等于自身的值：'
- en: '[PRE185]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Strict equality (`===`) is also used by `Array.prototype.indexOf`. You therefore
    can’t search for `NaN` in an array via that method:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 严格相等（`===`）也被`Array.prototype.indexOf`使用。因此，您不能通过该方法在数组中搜索`NaN`：
- en: '[PRE186]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'If you want to check whether a value is `NaN`, you have to use the global function
    `isNaN()`:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要检查值是否为`NaN`，则必须使用全局函数`isNaN()`：
- en: '[PRE187]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'However, `isNaN` does not work properly with nonnumbers, because it first converts
    those to numbers. That conversion can produce `NaN` and then the function incorrectly
    returns `true`:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`isNaN`不能正确处理非数字，因为它首先将它们转换为数字。该转换可能产生`NaN`，然后该函数错误地返回`true`：
- en: '[PRE188]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Thus, it is best to combine `isNaN` with a type check:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好将`isNaN`与类型检查结合使用：
- en: '[PRE189]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Alternatively, you can check whether the value is unequal to itself (as `NaN`
    is the only value with this trait). But that is less self-explanatory:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以检查值是否不等于自身（因为`NaN`是唯一具有此特性的值）。但这不够自解释：
- en: '[PRE190]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Note that this behavior is dictated by IEEE 754\. As noted in Section 7.11,
    “Details of comparison predicates”:^([[13](#ftn.id1001327)])
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此行为由IEEE 754规定。如第7.11节“比较谓词的详细信息”中所述：^([[13](#ftn.id1001327)])
- en: Every NaN shall compare unordered with everything, including itself.
  id: totrans-848
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个NaN都将与任何东西（包括自身）比较无序。
- en: Infinity
  id: totrans-849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Infinity
- en: '`Infinity` is an error value indicating one of two problems: a number can’t
    be represented because its magnitude is too large, or a division by zero has happened.'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`是一个错误值，指示两个问题中的一个：一个数字无法表示，因为其大小太大，或者发生了除以零。'
- en: '`Infinity` is larger than any other number (except `NaN`). Similarly, `-Infinity`
    is smaller than any other number (except `NaN`). That makes them useful as default
    values—for example, when you are looking for a minimum or maximum.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`大于任何其他数字（除了`NaN`）。同样，`-Infinity`小于任何其他数字（除了`NaN`）。这使它们在默认值方面非常有用，例如，当您正在寻找最小值或最大值时。'
- en: 'Error: a number’s magnitude is too large'
  id: totrans-852
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误：数字的大小太大
- en: 'How large a number’s magnitude can become is determined by its internal representation
    (as discussed in [The Internal Representation of Numbers](ch11.html#number_representation
    "The Internal Representation of Numbers")), which is the arithmetic product of:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字的大小取决于其内部表示（如[数字的内部表示](ch11.html#number_representation "数字的内部表示")中所讨论的），即：
- en: A mantissa (a binary number 1.f[1]f[2]...)
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾数（一个二进制数1.f[1]f[2]...）
- en: 2 to the power of an exponent
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数的2次幂
- en: 'The exponent must be between (and excluding) −1023 and 1024\. If the exponent
    is too small, the number becomes 0\. If the exponent is too large, it becomes
    `Infinity`. 2^(1023) can still be represented, but 2^(1024) can’t:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 指数必须在（不包括）-1023和1024之间。如果指数太小，数字变为0。如果指数太大，它变为`Infinity`。2^(1023)仍然可以表示，但2^(1024)不能：
- en: '[PRE191]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Error: division by zero'
  id: totrans-858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误：除以零
- en: 'Dividing by zero produces `Infinity` as an error value:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 除以零会产生`Infinity`作为错误值：
- en: '[PRE192]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Computing with Infinity
  id: totrans-861
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Infinity进行计算
- en: 'You get the error result `NaN` if you try to “neutralize” one `Infinity` with
    another one:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试用另一个`Infinity`“中和”一个`Infinity`，则会得到错误结果`NaN`：
- en: '[PRE193]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'If you try to go beyond `Infinity`, you still get `Infinity`:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试超出`Infinity`，您仍然会得到`Infinity`：
- en: '[PRE194]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Checking for Infinity
  id: totrans-866
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查Infinity
- en: 'Strict and lenient equality work fine for `Infinity`:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 严格和宽松的相等对`Infinity`也适用：
- en: '[PRE195]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Additionally, the global function `isFinite()` allows you to check whether
    a value is an actual number (neither infinite nor `NaN`):'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，全局函数`isFinite()`允许您检查一个值是否是一个实际的数字（既不是无穷大也不是`NaN`）：
- en: '[PRE196]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Two Zeros
  id: totrans-871
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个零
- en: Because JavaScript’s numbers keep magnitude and sign separate, each nonnegative
    number has a negative, including `0`.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 因为JavaScript的数字保持大小和符号分开，每个非负数都有一个负数，包括`0`。
- en: 'The rationale for this is that whenever you represent a number digitally, it
    can become so small that it is indistinguishable from 0, because the encoding
    is not precise enough to represent the difference. Then a signed zero allows you
    to record “from which direction” you approached zero; that is, what sign the number
    had before it was considered zero. Wikipedia nicely sums up the pros and cons
    of [signed zeros](http://en.wikipedia.org/wiki/Signed_zero):'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当您以数字的方式表示数字时，它可能变得非常小，以至于无法与0区分，因为编码不够精确以表示差异。然后，有符号零允许您记录“从哪个方向”接近零；也就是说，在被视为零之前，数字具有什么符号。维基百科很好地总结了[有符号零](http://en.wikipedia.org/wiki/Signed_zero)的利弊：
- en: It is claimed that the inclusion of signed zero in IEEE 754 makes it much easier
    to achieve numerical accuracy in some critical problems, in particular when computing
    with complex elementary functions. On the other hand, the concept of signed zero
    runs contrary to the general assumption made in most mathematical fields (and
    in most mathematics courses) that negative zero is the same thing as zero. Representations
    that allow negative zero can be a source of errors in programs, as software developers
    do not realize (or may forget) that, while the two zero representations behave
    as equal under numeric comparisons, they are different bit patterns and yield
    different results in some operations.
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 据称，IEEE 754中包含有符号零使得在一些关键问题中更容易实现数值精度，特别是在计算复杂的初等函数时。另一方面，有符号零的概念与大多数数学领域（以及大多数数学课程）中的一般假设相矛盾，即负零和零是相同的。允许负零的表示可以成为程序中的错误源，因为软件开发人员没有意识到（或可能忘记了），虽然这两个零表示在数值比较下行为相等，但它们是不同的位模式，并在一些操作中产生不同的结果。
- en: 'Best practice: pretend there’s only one zero'
  id: totrans-875
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最佳实践：假装只有一个零
- en: JavaScript goes to great lengths to hide the fact that there are two zeros.
    Given that it normally doesn’t matter that they are different, it is recommended
    that you play along with the illusion of the single zero. Let’s examine how that
    illusion is maintained.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript竭尽全力隐藏有两个零这一事实。鉴于通常并不重要它们是不同的，建议您配合单个零的幻觉。让我们看看这个幻觉是如何维持的。
- en: 'In JavaScript, you normally write `0`, which means `+0`. But `-0` is also displayed
    as simply `0`. This is what you see when you use a browser command line or the
    Node.js REPL:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，通常写为`0`，这意味着`+0`。但`-0`也显示为简单的`0`。这是您在使用浏览器命令行或Node.js REPL时看到的情况：
- en: '[PRE197]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'That is because the standard `toString()` method converts both zeros to the
    same `''0''`:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为标准的`toString()`方法将这两个零都转换为相同的`'0'`：
- en: '[PRE198]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Equality doesn’t distinguish zeros, either. Not even `===`:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 相等也无法区分零。甚至`===`也不行：
- en: '[PRE199]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '`Array.prototype.indexOf` uses `===` to search for elements, maintaining the
    illusion:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.indexOf`使用`===`搜索元素，维持了这个幻觉：'
- en: '[PRE200]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'The ordering operators also consider the zeros to be equal:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 排序运算符也认为这两个零是相等的：
- en: '[PRE201]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Distinguishing the two zeros
  id: totrans-887
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 区分这两个零
- en: 'How *can* you actually observe that the two zeros are different? You can divide
    by zero (`-Infinity` and `+Infinity` *can* be distinguished by `===`):'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '*您*如何实际观察到这两个零是不同的？您可以除以零（`-Infinity`和`+Infinity`可以通过`===`进行区分）：'
- en: '[PRE202]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Another way to perform the division by zero is via `Math.pow()` (see [Numerical
    Functions](ch21.html#Math.pow "Numerical Functions")):'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Math.pow()`（参见[数值函数](ch21.html#Math.pow "数值函数")）进行除以零的另一种方法：
- en: '[PRE203]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '`Math.atan2()` (see [Trigonometric Functions](ch21.html#Math.atan2 "Trigonometric
    Functions")) also reveals that the zeros are different:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'The canonical way of telling the two zeros apart is the division by zero. Therefore,
    a function for detecting negative zeros would look like this:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Here is the function in use:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: The Internal Representation of Numbers
  id: totrans-898
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript numbers have 64-bit precision, which is also called *double precision*
    (type `double` in some programming languages). The internal representation is
    based on the IEEE 754 standard. The 64 bits are distributed between a number’s
    sign, exponent, and fraction as follows:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '| Sign | Exponent ∈ [−1023, 1024] | Fraction |'
  id: totrans-900
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
- en: '| 1 bit | 11 bits | 52 bits |'
  id: totrans-902
  prefs: []
  type: TYPE_TB
- en: '| Bit 63 | Bits 62–52 | Bits 51–0 |'
  id: totrans-903
  prefs: []
  type: TYPE_TB
- en: 'The value of a number is computed by the following formula:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: (–1)^(sign) × %1.fraction × 2^(exponent)
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: 'The prefixed percentage sign (`%`) means that the number in the middle is written
    in binary notation: a 1, followed by a binary point, followed by a binary fraction—namely
    the binary digits of the fraction (a natural number). Here are some examples of
    this representation:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '| +0 |  | (sign = 0, fraction = 0, exponent = −1023) |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
- en: '| –0 |  | (sign = 1, fraction = 0, exponent = −1023) |'
  id: totrans-908
  prefs: []
  type: TYPE_TB
- en: '| 1 | = (−1)⁰ × %1.0 × 2⁰ | (sign = 0, fraction = 0, exponent = 0) |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
- en: '| 2 | = (−1)⁰ × %1.0 × 2¹ |  |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
- en: '| 3 | = (−1)⁰ × %1.1 × 2¹ | (sign = 0, fraction = 2^(51), exponent = 0) |'
  id: totrans-911
  prefs: []
  type: TYPE_TB
- en: '| 0.5 | = (−1)⁰ × %1.0 × 2^(−1) |  |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
- en: '| −1 | = (−1)¹ × %1.0 × 2⁰ |  |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
- en: 'The encodings of +0, −0, and 3 can be explained as follows:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: '±0: Given that the fraction is always prefixed by a 1, it’s impossible to represent
    0 with it. Hence, JavaScript encodes a zero via the fraction 0 and the special
    exponent −1023\. The sign can be either positive or negative, meaning that JavaScript
    has two zeros (see [Two Zeros](ch11.html#two_zeros "Two Zeros")).'
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3: Bit 51 is the most significant (highest) bit of the fraction. That bit is
    1.'
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special Exponents
  id: totrans-917
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previously mentioned representation of numbers is called *normalized*.
    In that case, the exponent *e* is in the range −1023 < *e* < 1024 (excluding lower
    and upper bounds). −1023 and 1024 are special exponents:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: 1024 is used for error values such as `NaN` and `Infinity`.
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '−1023 is used for:'
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero (if the fraction is 0, as just explained)
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small numbers close to zero (if the fraction is not 0).
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enable both applications, a different, so-called *denormalized*, representation
    is used:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: (–1)^(sign) × %0.fraction × 2^(–1022)
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare, the smallest (as in “closest to zero”) numbers in normalized representation
    are:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: (–1)^(sign) × %1.fraction × 2^(–1022)
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: Denormalized numbers are smaller, because there is no leading digit 1.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: Handling Rounding Errors
  id: totrans-928
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript’s numbers are usually entered as decimal floating-point numbers,
    but they are internally represented as binary floating-point numbers. That leads
    to imprecision. To understand why, let’s forget JavaScript’s internal storage
    format and take a general look at what fractions can be well represented by decimal
    floating-point numbers and by binary floating-point numbers. In the decimal system,
    all fractions are a mantissa *m* divided by a power of 10:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '![](eq_1101.png)'
  id: totrans-930
  prefs: []
  type: TYPE_IMG
- en: 'So, in the denominator, there are only tens. That’s why ![](inleq_1102.png)
    cannot be expressed precisely as a decimal floating-point number—there is no way
    to get a 3 into the denominator. Binary floating-point numbers only have twos
    in the denominator. Let’s examine which decimal floating-point numbers can be
    represented well as binary and which can’t. If there are only twos in the denominator,
    the decimal number can be represented:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: 0.5[dec] = ![](inleq_1103.png) = ![](inleq_1104.png) = 0.1[bin]
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0.75[dec] = ![](inleq_1105.png) = ![](inleq_1106.png) = 0.11[bin]
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0.125[dec] = ![](inleq_1107.png) = ![](inleq_1108.png) = 0.001[bin]
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other fractions cannot be represented precisely, because they have numbers
    other than 2 in the denominator (after prime factorization):'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: 0.1[dec] = ![](inleq_1109.png) = ![](inleq_1110.png)
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.1[dec] = ![](inleq_1109.png) = ![](inleq_1110.png)
- en: 0.2[dec] = ![](inleq_1111.png) = ![](inleq_1112.png)
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.2[dec] = ![](inleq_1111.png) = ![](inleq_1112.png)
- en: 'You can’t normally see that JavaScript doesn’t store exactly 0.1 internally.
    But you can make it visible by multiplying it with a high enough power of 10:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 通常看不到JavaScript内部并未精确存储0.1。但是，通过将其乘以足够高的10的幂，可以使其可见：
- en: '[PRE207]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'And if you add two imprecisely represented numbers, the result is sometimes
    imprecise enough that the imprecision becomes visible:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将两个不精确表示的数字相加，结果有时会不精确到足以使不精确性变得可见：
- en: '[PRE208]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Another example:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子：
- en: '[PRE209]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Due to rounding errors, as a best practice you should not compare nonintegers
    directly. Instead, take an upper bound for rounding errors into consideration.
    Such an upper bound is called a [*machine epsilon*](http://en.wikipedia.org/wiki/Machine_epsilon).
    The standard epsilon value for double precision is 2^(−53):'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 由于舍入误差，最好的做法是不直接比较非整数。而是考虑舍入误差的上限。这样的上限称为[*机器epsilon*](http://en.wikipedia.org/wiki/Machine_epsilon)。双精度标准epsilon值为2^(−53)：
- en: '[PRE210]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '`epsEqu()` ensures correct results where a normal comparison would be inadequate:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '`epsEqu()`确保正确的结果，普通比较会不足以满足要求：'
- en: '[PRE211]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Integers in JavaScript
  id: totrans-948
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript中的整数
- en: As mentioned before, JavaScript has only floating-point numbers. Integers appear
    internally in two ways. First, most JavaScript engines store a small enough number
    without a decimal fraction as an integer (with, for example, 31 bits) and maintain
    that representation as long as possible. They have to switch back to a floating-point
    representation if a number’s magnitude grows too large or if a decimal fraction
    appears.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JavaScript只有浮点数。整数在内部以两种方式出现。首先，大多数JavaScript引擎将足够小的没有小数部分的数字存储为整数（例如，31位），并尽可能长时间地保持该表示。如果数字的大小增长太大或出现小数部分，则必须切换回浮点表示。
- en: 'Second, the ECMAScript specification has integer operators: namely, all of
    the bitwise operators. Those operators convert their operands to 32-bit integers
    and return 32-bit integers. For the specification, *integer* only means that the
    numbers don’t have a decimal fraction, and *32-bit* means that they are within
    a certain range. For engines, *32-bit integer* means that an actual integer (non-floating-point)
    representation can usually be introduced or maintained.'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，ECMAScript规范具有整数运算符：即所有按位运算符。这些运算符将其操作数转换为32位整数并返回32位整数。对于规范，*整数*只意味着数字没有小数部分，*32位*意味着它们在某个范围内。对于引擎，*32位整数*意味着通常可以引入或保持实际整数（非浮点）表示。
- en: Ranges of Integers
  id: totrans-951
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数范围
- en: 'Internally, the following ranges of integers are important in JavaScript:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，以下整数范围很重要：
- en: 'Safe integers (see [Safe Integers](ch11.html#safe_integers "Safe Integers")),
    the largest practically usable range of integers that JavaScript supports:'
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全整数（参见[安全整数](ch11.html#safe_integers "安全整数")），JavaScript支持的最大实用整数范围：
- en: 53 bits plus a sign, range (−2^(53), 2^(53))
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 53位加上一个符号，范围（−2^(53), 2^(53)）
- en: 'Array indices (see [Array Indices](ch18.html#array_indices "Array Indices")):'
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组索引（参见[数组索引](ch18.html#array_indices "数组索引")）：
- en: 32 bits, unsigned
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位，无符号
- en: 'Maximum length: 2^(32)−1'
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大长度：2^(32)−1
- en: 'Range of indices: [0, 2^(32)−1) (excluding the maximum length!)'
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引范围：[0, 2^(32)−1)（不包括最大长度！）
- en: 'Bitwise operands (see [Bitwise Operators](ch11.html#bitwise_operators "Bitwise
    Operators")):'
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位操作数（参见[按位运算符](ch11.html#bitwise_operators "按位运算符")）：
- en: 'Unsigned right shift operator (`>>>`): 32 bits, unsigned, range [0, 2^(32))'
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无符号右移运算符(`>>>`)：32位，无符号，范围[0, 2^(32))
- en: 'All other bitwise operators: 32 bits, including a sign, range [−2^(31), 2^(31))'
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他按位运算符：32位，包括符号，范围[−2^(31), 2^(31)]
- en: '“Char codes,” UTF-16 code units as numbers:'
  id: totrans-962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “字符代码”，UTF-16代码单元作为数字：
- en: Accepted by `String.fromCharCode()` (see [String Constructor Method](ch12.html#String.fromCharCode
    "String Constructor Method"))
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被`String.fromCharCode()`接受（参见[字符串构造方法](ch12.html#String.fromCharCode "字符串构造方法")）
- en: Returned by `String.prototype.charCodeAt()` (see [Extract Substrings](ch12.html#String.prototype.charCodeAt
    "Extract Substrings"))
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由`String.prototype.charCodeAt()`返回（参见[提取子字符串](ch12.html#String.prototype.charCodeAt
    "提取子字符串")）
- en: 16 bits, unsigned
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位，无符号
- en: Representing Integers as Floating-Point Numbers
  id: totrans-966
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将整数表示为浮点数
- en: JavaScript can only handle integer values up to a magnitude of 53 bits (the
    52 bits of the fraction plus 1 indirect bit, via the exponent; see [The Internal
    Representation of Numbers](ch11.html#number_representation "The Internal Representation
    of Numbers") for details).
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript只能处理最大为53位的整数值（52位的小数部分加上1个间接位，通过指数; 有关详细信息，请参见[数字的内部表示](ch11.html#number_representation
    "数字的内部表示")）。
- en: 'The following table explains how JavaScript represents 53-bit integers as floating-point
    numbers:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了JavaScript如何将53位整数表示为浮点数：
- en: '| Bits | Range | Encoding |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
  zh: '| 位 | 范围 | 编码 |'
- en: '| --- | --- | --- |'
  id: totrans-970
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 bit | 0 | (See [The Internal Representation of Numbers](ch11.html#number_representation
    "The Internal Representation of Numbers").) |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
  zh: '| 1位 | 0 | (参见[数字的内部表示](ch11.html#number_representation "数字的内部表示")) |'
- en: '| 1 bit | 1 | %1 × 2⁰ |'
  id: totrans-972
  prefs: []
  type: TYPE_TB
  zh: '| 1位 | 1 | %1 × 2⁰ |'
- en: '| 2 bits | 2–3 | %1.f[51] × 2¹ |'
  id: totrans-973
  prefs: []
  type: TYPE_TB
  zh: '| 2位 | 2–3 | %1.f[51] × 2¹ |'
- en: '| 3 bits | 4–7 = 2²–(2³−1) | %1.f[51]f[50] × 2² |'
  id: totrans-974
  prefs: []
  type: TYPE_TB
  zh: '| 3位 | 4–7 = 2²–(2³−1) | %1.f[51]f[50] × 2² |'
- en: '| 4 bits | 2³–(2⁴−1) | %1.f[51]f[50]f[49] × 2³ |'
  id: totrans-975
  prefs: []
  type: TYPE_TB
  zh: '| 4位 | 2³–(2⁴−1) | %1.f[51]f[50]f[49] × 2³ |'
- en: '| ⋯ | ⋯ | ⋯ |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
  zh: '| ⋯ | ⋯ | ⋯ |'
- en: '| 53 bits | 2^(52)–(2^(53)−1) | %1.f[51]⋯f[0] × 2^(52) |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
  zh: '| 53位 | 2^(52)–(2^(53)−1) | %1.f[51]⋯f[0] × 2^(52) |'
- en: 'There is no fixed sequence of bits that represents the integer. Instead, the
    mantissa %1.f is shifted by the exponent, so that the leading digit 1 is in the
    right place. In a way, the exponent counts the number of digits of the fraction
    that are in active use (the remaining digits are 0). That means that for 2 bits,
    we use one digit of the fraction and for 53 bits, we use all digits of the fraction.
    Additionally, we can represent 2^(53) as %1.0 × 2^(53), but we get problems with
    higher numbers:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 没有固定的位序列表示整数。相反，尾数%1.f被指数移位，以便领先的数字1位于正确的位置。在某种程度上，指数计算出分数中活跃使用的数字的数量（其余数字为0）。这意味着对于2位，我们使用分数的一位数字，对于53位，我们使用分数的所有数字。此外，我们可以将2^(53)表示为%1.0
    × 2^(53)，但是对于更高的数字，我们会遇到问题：
- en: '| Bits | Range | Encoding |'
  id: totrans-979
  prefs: []
  type: TYPE_TB
  zh: '| 位 | 范围 | 编码 |'
- en: '| --- | --- | --- |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 54 bits | 2^(53)–(2^(54)−1) | %1.f[51]⋯f[0]0 × 2^(53) |'
  id: totrans-981
  prefs: []
  type: TYPE_TB
  zh: '| 54位 | 2^(53)–(2^(54)−1) | %1.f[51]⋯f[0]0 × 2^(53) |'
- en: '| 55 bits | 2^(54)–(2^(55)−1) | %1.f[51]⋯f[0]00 × 2^(54) |'
  id: totrans-982
  prefs: []
  type: TYPE_TB
  zh: '| 55位 | 2^(54)–(2^(55)−1) | %1.f[51]⋯f[0]00 × 2^(54) |'
- en: '| ⋯ |  |  |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
  zh: '| ⋯ |  |  |'
- en: 'For 54 bits, the least significant digit is always 0, for 55 bits the two least
    significant digits are always 0, and so on. That means that for 54 bits, we can
    only represent every second number, for 55 bits only every fourth number, and
    so on. For example:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 对于54位，最低有效位始终为0，对于55位，最低的两位始终为0，依此类推。这意味着对于54位，我们只能表示每第二个数字，对于55位，只能表示每第四个数字，依此类推。例如：
- en: '[PRE212]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Best practice
  id: totrans-986
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最佳实践
- en: If you work with integers of up to 53 bits magnitude, you are fine. Unfortunately,
    you’ll often encounter 64-bit unsigned integers in programming (Twitter IDs, databases,
    etc.). These must be stored in strings in JavaScript. If you want to perform arithmetic
    with such integers, you need special libraries. There are plans to bring larger
    integers to JavaScript, but that will take a while.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的整数的大小不超过53位，那么就没问题。不幸的是，在编程中经常会遇到64位无符号整数（Twitter ID、数据库等）。这些必须以字符串形式存储在JavaScript中。如果要对这样的整数执行算术运算，就需要特殊的库。有计划将更大的整数引入JavaScript，但这需要一些时间。
- en: Safe Integers
  id: totrans-988
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全整数
- en: JavaScript can only safely represent integers *i* in the range −2^(53) < *i*
    < 2^(53). This section examines what that means and what the consequences are.
    It is based on an [email by Mark S. Miller to the es-discuss mailing list](http://mzl.la/1oOaCOO).
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript只能安全地表示范围在−2^(53) < i < 2^(53)的整数。本节将探讨这意味着什么以及其后果。它基于Mark S. Miller发送给es-discuss邮件列表的一封邮件。
- en: 'The idea of a safe integer centers on how mathematical integers are represented
    in JavaScript. In the range (−2^(53), 2^(53)) (excluding the lower and upper bounds),
    JavaScript integers are *safe*: there is a one-to-one mapping between mathematical
    integers and their representations in JavaScript.'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 安全整数的概念集中在JavaScript中如何表示数学整数上。在范围(−2^(53), 2^(53))（不包括下限和上限）内，JavaScript整数是*安全*的：数学整数与它们在JavaScript中的表示之间存在一对一的映射。
- en: 'Beyond this range, JavaScript integers are *unsafe*: two or more mathematical
    integers are represented as the same JavaScript integer. For example, starting
    at 2^(53), JavaScript can represent only every second mathematical integer (the
    previous section explains why). Therefore, a safe JavaScript integer is one that
    unambiguously represents a single mathematical integer.'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 超出此范围后，JavaScript整数是*不安全*的：两个或更多数学整数被表示为相同的JavaScript整数。例如，从2^(53)开始，JavaScript只能表示每第二个数学整数（前一节解释了原因）。因此，安全的JavaScript整数是可以明确表示单个数学整数的整数。
- en: Definitions in ECMAScript 6
  id: totrans-992
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ECMAScript 6中的定义
- en: 'ECMAScript 6 will provide the following constants:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6将提供以下常量：
- en: '[PRE213]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'It will also provide a function for determining whether an integer is safe:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将提供一个用于确定整数是否安全的函数：
- en: '[PRE214]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: For a given value `n`, this function first checks whether `n` is a number and
    an integer. If both checks succeed, `n` is safe if it is greater than or equal
    to `MIN_SAFE_INTEGER` and less than or equal to `MAX_SAFE_INTEGER`.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定值`n`，此函数首先检查`n`是否为数字和整数。如果两个检查都成功，则如果`n`大于或等于`MIN_SAFE_INTEGER`且小于或等于`MAX_SAFE_INTEGER`，则`n`是安全的。
- en: Safe results of arithmetic computations
  id: totrans-998
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 算术计算的安全结果
- en: 'How can we make sure that results of arithmetic computations are correct? For
    example, the following result is clearly not correct:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保算术计算的结果是正确的？例如，以下结果显然是不正确的：
- en: '[PRE215]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'We have two safe operands, but an unsafe result:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个安全的操作数，但是一个不安全的结果：
- en: '[PRE216]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'The following result is also incorrect:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果也是不正确的：
- en: '[PRE217]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'This time, the result is safe, but one of the operands isn’t:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 这次结果是安全的，但其中一个操作数不是：
- en: '[PRE218]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Therefore, the result of applying an integer operator `op` is guaranteed to
    be correct only if all operands and the result are safe. More formally:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只有当所有操作数和结果都是安全的时，才能保证应用整数运算符`op`的结果是正确的。更正式地说：
- en: '[PRE219]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: implies that `a op b` is a correct result.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着`a op b`是正确的结果。
- en: Converting to Integer
  id: totrans-1010
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为整数
- en: 'In JavaScript, all numbers are floating point. Integers are floating-point
    numbers without a fraction. Converting a number `n` to an integer means finding
    the integer that is “closest” to `n` (where the meaning of “closest” depends on
    how you convert). You have several options for performing this conversion:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，所有数字都是浮点数。整数是没有小数部分的浮点数。将数字`n`转换为整数意味着找到与`n`“最接近”的整数（“最接近”的含义取决于如何进行转换）。您有几种选项可以执行此转换：
- en: The `Math` functions `Math.floor()`, `Math.ceil()`, and `Math.round()` (see
    [Integers via Math.floor(), Math.ceil(), and Math.round()](ch11.html#integers_via_math
    "Integers via Math.floor(), Math.ceil(), and Math.round()"))
  id: totrans-1012
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Math`函数`Math.floor()`、`Math.ceil()`和`Math.round()`（参见[Integers via Math.floor(),
    Math.ceil(), and Math.round()](ch11.html#integers_via_math "Integers via Math.floor(),
    Math.ceil(), and Math.round()")）'
- en: The custom function `ToInteger()` (see [Integers via the Custom Function ToInteger()](ch11.html#ToInteger
    "Integers via the Custom Function ToInteger()"))
  id: totrans-1013
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义函数`ToInteger()`（参见[Integers via the Custom Function ToInteger()](ch11.html#ToInteger
    "Integers via the Custom Function ToInteger()")）
- en: Binary bitwise operators (see [32-bit Integers via Bitwise Operators](ch11.html#integers_via_bitwise_operators
    "32-bit Integers via Bitwise Operators"))
  id: totrans-1014
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The global function `parseInt()` (see [Integers via parseInt()](ch11.html#parseInt
    "Integers via parseInt()"))
  id: totrans-1015
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Spoiler: #1 is usually the best choice, #2 and #3 have niche applications,
    and #4 is OK for parsing strings, but not for converting numbers to integers.'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: Integers via Math.floor(), Math.ceil(), and Math.round()
  id: totrans-1017
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following three functions are usually the best way of converting a number
    to an integer:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.floor()` converts its argument to the closest lower integer:'
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '`Math.ceil()` converts its argument to the closest higher integer:'
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '`Math.round()` converts its argument to the closest integer:'
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'The result of rounding `-3.5` may be surprising:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Therefore, `Math.round(x)` is the same as:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Integers via the Custom Function ToInteger()
  id: totrans-1029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another good option for converting any value to an integer is the internal
    ECMAScript operation `ToInteger()`, which removes the fraction of a floating-point
    number. If it was accessible in JavaScript, it would work like this:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'The ECMAScript specification defines the result of `ToInteger(number)` as:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: sign(number) × floor(abs(number))
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: 'For what it does, this formula is relatively complicated because `floor` seeks
    the closest *larger* integer; if you want to remove the fraction of a negative
    integer, you have to seek the closest smaller integer. The following code implements
    the operation in JavaScript. We avoid the `sign` operation by using `ceil` if
    the number is negative:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 32-bit Integers via Bitwise Operators
  id: totrans-1036
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Binary bitwise operators (see [Binary Bitwise Operators](ch11.html#binary_bitwise_operators
    "Binary Bitwise Operators")) convert (at least) one of their operands to a 32-bit
    integer that is then manipulated to produce a result that is also a 32-bit integer.
    Therefore, if you choose the other operand appropriately, you get a fast way to
    convert an arbitrary number to a 32-bit integer (that is either signed or unsigned).
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise Or (|)
  id: totrans-1038
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If the mask, the second operand, is 0, you don’t change any bits and the result
    is the first operand, coerced to a signed 32-bit integer. This is the canonical
    way to execute this kind of coercion and is used, for example, by asm.js (refer
    back to [Is JavaScript Fast Enough?](ch02.html#asm.js "Is JavaScript Fast Enough?")):'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '`ToInt32()` removes the fraction and applies modulo 2^(32):'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Shift operators
  id: totrans-1043
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The same trick that worked for bitwise Or also works for shift operators: if
    you shift by zero bits, the result of a shift operation is the first operand,
    coerced to a 32-bit integer. Here are some examples of implementing operations
    of the ECMAScript specification via shift operators:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'Here is `ToUint32()` in action:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Should I use bitwise operators to coerce to integer?
  id: totrans-1048
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You have to decide for yourself if the slight increase in efficiency is worth
    your code being harder to understand. Also note that bitwise operators artificially
    limit themselves to 32 bits, which is often neither necessary nor useful. Using
    one of the `Math` functions, possibly in addition to `Math.abs()`, is a more self-explanatory
    and arguably better choice.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: Integers via parseInt()
  id: totrans-1050
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `parseInt()` function:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: parses the string `str` (nonstrings are coerced) as an integer. The function
    ignores leading whitespace and considers as many consecutive legal digits as it
    can find.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: The radix
  id: totrans-1054
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The range of the radix is 2 ≤ `radix` ≤ 36. It determines the base of the number
    to be parsed. If the radix is greater than 10, letters are used as digits (case-insensitively),
    in addition to 0–9.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: 'If `radix` is missing, then it is assumed to be 10, except if `str` begins
    with “0x” or “0X,” in which case `radix` is set to 16 (hexadecimal):'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'If `radix` is already 16, then the hexadecimal prefix is optional:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'So far I have described the behavior of `parseInt()` according to the ECMAScript
    specification. Additionally, some engines set the radix to 8 if `str` starts with
    a zero:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-1061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Thus, it is best to always explicitly state the radix, to always call `parseInt()`
    with two arguments.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Don’t use `parseInt()` to convert a number to an integer. The last example
    gives us hope that we might be able to use `parseInt()` for converting numbers
    to integers. Alas, here is an example where the conversion is incorrect:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Explanation
  id: totrans-1067
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The argument is first converted to a string:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '`parseInt` doesn’t consider “e” to be an integer digit and thus stops parsing
    after the 1\. Here’s another example:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Summary
  id: totrans-1072
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`parseInt()` shouldn’t be used to convert numbers to integers: coercion to
    string is an unnecessary detour and even then, the result is not always correct.'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: '`parseInt()` *is* useful for parsing strings, but you have to be aware that
    it stops at the first illegal digit. Parsing strings via `Number()` (see [The
    Function Number](ch11.html#function_number "The Function Number")) is less forgiving,
    but may produce nonintegers.'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic Operators
  id: totrans-1075
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following operators are available for numbers:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '`number1 + number2`'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: 'Numerical addition, unless either of the operands is a string. Then both operands
    are converted to strings and concatenated (see [The Plus Operator (+)](ch09.html#plus_operator
    "The Plus Operator (+)")):'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '`number1 - number2`'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: Subtraction.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: '`number1 * number2`'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: Multiplication.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: '`number1 / number2`'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: Division.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: '`number1 % number2`'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: 'Remainder:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: Warning
  id: totrans-1089
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This operation is not modulo. It returns a value whose sign is the same as the
    first operand (more details in a moment).
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: '`-number`'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: Negates its argument.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: '`+number`'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: Leaves its argument as is; nonnumbers are converted to a number.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '`++variable`, `--variable`'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the current value of the variable after incrementing (or decrementing)
    it by 1:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '`variable++`, `variable--`'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: 'Increments (or decrements) the value of the variable by 1 and returns it:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Mnemonic: increment (++) and decrement (--) operators'
  id: totrans-1101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The position of the operand can help you remember whether it is returned before
    or after incrementing (or decrementing) it. If the operand comes before the increment
    operator, it is returned before incrementing it. If the operand comes after the
    operator, it is incremented and then returned. (The decrement operator works similarly.)
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: The Remainder Operator (%) Is Not Modulo'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the remainder operator always has the sign of the first operand
    (for modulo, it is the sign of the second operand):'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'That means that the following function does not work:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'The correct version is:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Bitwise Operators
  id: totrans-1110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has several bitwise operators that work with 32-bit integers. That
    is, they convert their operands to 32-bit integers and produce a result that is
    a 32-bit integer. Use cases for these operators include processing binary protocols,
    special algorithms, etc.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: Background Knowledge
  id: totrans-1112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section explains a few concepts that will help you understand bitwise operators.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: Binary complements
  id: totrans-1114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Two common ways of computing a binary complement (or inverse) of a binary number
    are:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: Ones’ complement
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: 'You compute the ones’ complement `~x` of a number `x` by inverting each of
    the 32 digits. Let’s illustrate the ones’ complement via four-digit numbers. The
    ones’ complement of `1100` is `0011`. Adding a number to its ones’ complement
    results in a number whose digits are all 1:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Twos’ complement
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: 'The twos’ complement `-x` of a number `x` is the ones’ complement plus one.
    Adding a number to its twos’ complement results in `0` (ignoring overflow beyond
    the most significant digit). Here’s an example using four-digit numbers:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Signed 32-bit integers
  id: totrans-1122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '32-bit integers don’t have an explicit sign, but you can still encode negative
    numbers. For example, −1 can be encoded as the twos’ complement of 1: adding 1
    to the result yields 0 (within 32 bits). The boundary between positive and negative
    numbers is fluid; 4294967295 (2^(32)−1) and −1 are the same integer here. But
    you have to decide on a sign when you convert such an integer from or to a JavaScript
    number, which has an explicit sign as opposed to an implicit one. Therefore, *signed
    32-bit integers* are partitioned into two groups:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: 'Highest bit is 0: number is zero or positive.'
  id: totrans-1124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Highest bit is 1: number is negative.'
  id: totrans-1125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The highest bit is often called the *sign bit*. Accordingly, 4294967295, interpreted
    as a signed 32-bit integer, becomes −1 when converted to a JavaScript number:'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '`ToInt32()` is explained in [32-bit Integers via Bitwise Operators](ch11.html#integers_via_bitwise_operators
    "32-bit Integers via Bitwise Operators").'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only the unsigned right shift operator (`>>>`) works with unsigned 32-bit integers;
    all other bitwise operators work with signed 32-bit integers.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: Inputting and outputting binary numbers
  id: totrans-1131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following examples, we work with binary numbers via the following two
    operations:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: '`parseInt(str, 2)` (see [Integers via parseInt()](ch11.html#parseInt "Integers
    via parseInt()")) parses a string `str` in binary notation (base 2). For example:'
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '`num.toString(2)` (see [Number.prototype.toString(radix?)](ch11.html#Number.prototype.toString
    "Number.prototype.toString(radix?)")) converts the number `num` to a string in
    binary notation. For example:'
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Bitwise Not Operator
  id: totrans-1137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`~number` computes the ones’ complement of `number`:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Binary Bitwise Operators
  id: totrans-1140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has three binary bitwise operators:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: '`number1 & number2` (bitwise And):'
  id: totrans-1142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '`number1 | number2` (bitwise Or):'
  id: totrans-1144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '`number1 ^ number2` (bitwise Xor; eXclusive Or):'
  id: totrans-1146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'There are two ways to intuitively understand binary bitwise operators:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: One boolean operation per bit
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following formulas, `n[i]` means bit `i` of number `n` interpreted as
    a boolean (0 is `false`, 1 is `true`). For example, `2[0]` is `false`; `2[1]`
    is `true`:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: 'And: `result[i] = number1[i] && number2[i]`'
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or: `result[i] = number1[i] || number2[i]`'
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xor: `result[i] = number1[i] ^^ number2[i]`'
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The operator `^^` does not exist. If it did, it would work like this (the result
    is `true` if exactly one of the operands is `true`):'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Changing bits of `number1` via `number2`
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: 'And: Keeps only those bits of `number1` that are set in `number2`. This operation
    is also called *masking*, with `number2` being the *mask*.'
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or: Sets all bits of `number1` that are set in `number2` and keeps all other
    bits unchanged.'
  id: totrans-1158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xor: Inverts all bits of `number1` that are set in `number2` and keeps all
    other bits unchanged.'
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise Shift Operators
  id: totrans-1160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has three bitwise shift operators:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: '`number << digitCount` (left shift):'
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '`number >> digitCount` (signed right shift):'
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The 32-bit binary number is interpreted as signed (see the preceding section).
    When shifting right, the sign is preserved:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: We have right-shifted –2\. The result, –1, is equivalent to a 32-bit integer
    whose digits are all 1 (the twos’ complement of 1). In other words, a signed right
    shift by one digit divides both negative and positive integers by two.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: 'number >>> digitCount` (unsigned right shift):'
  id: totrans-1168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: As you can see, this operator shifts in zeros from the left.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: The Function Number
  id: totrans-1171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function `Number` can be invoked in two ways:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: '`Number(value)`'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: 'As a normal function, it converts `value` to a primitive number (see [Converting
    to Number](ch11.html#tonumber "Converting to Number")):'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '`new Number(num)`'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: 'As a constructor, it creates a new instance of `Number` (see [Wrapper Objects
    for Primitives](ch08.html#wrapper_objects "Wrapper Objects for Primitives")),
    an object that wraps `num` (after converting it to a number). For example:'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: The former invocation is the common one.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: Number Constructor Properties
  id: totrans-1180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The object `Number` has the following properties:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: '`Number.MAX_VALUE`'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: 'The largest positive number that can be represented. Internally, all digits
    of its fraction are ones and the exponent is maximal, at 1023\. If you try to
    increment the exponent by multiplying it by two, the result is the error value
    `Infinity` (see [Infinity](ch11.html#infinity "Infinity")):'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '`Number.MIN_VALUE`'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: 'The smallest representable positive number (greater than zero, a tiny fraction):'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-1187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '`Number.NaN`'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: The same value as the global `NaN`.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: '`Number.NEGATIVE_INFINITY`'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: 'The same value as `-Infinity`:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '`Number.POSITIVE_INFINITY`'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: 'The same value as `Infinity`:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Number Prototype Methods
  id: totrans-1196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All methods of primitive numbers are stored in `Number.prototype` (see [Primitives
    Borrow Their Methods from Wrappers](ch08.html#primitive_methods_via_wrappers "Primitives
    Borrow Their Methods from Wrappers")).
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: Number.prototype.toFixed(fractionDigits?)
  id: totrans-1198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Number.prototype.toFixed(fractionDigits?)` returns an exponent-free representation
    of the number, rounded to `fractionDigits` digits. If the parameter is omitted,
    the value 0 is used:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'If the number is greater than or equal to 10^(21), then this method works the
    same as `toString()`. You get a number in exponential notation:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: Number.prototype.toPrecision(precision?)
  id: totrans-1203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Number.prototype.toPrecision(precision?)` prunes the mantissa to `precision`
    digits before using a conversion algorithm similar to `toString()`. If no precision
    is given, `toString()` is used directly:'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: You need the exponential notation to display 1234 with a precision of three
    digits.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: Number.prototype.toString(radix?)
  id: totrans-1207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For `Number.prototype.toString(radix?)`, the parameter `radix` indicates the
    base of the system in which the number is to be displayed. The most common radices
    are 10 (decimal), 2 (binary), and 16 (hexadecimal):'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'The radix must be at least 2 and at most 36\. Any radix greater than 10 leads
    to alphabetical characters being used as digits, which explains the maximum 36,
    as the Latin alphabet has 26 characters:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'The global function `parseInt` (see [Integers via parseInt()](ch11.html#parseInt
    "Integers via parseInt()")) allows you to convert such notations back to a number:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: Decimal exponential notation
  id: totrans-1214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For the radix 10, `toString()` uses exponential notation (with a single digit
    before the decimal point) in two cases. First, if there are more than 21 digits
    before the decimal point of a number:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'Second, if a number starts with `0.` followed by more than five zeros and a
    non-zero digit:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: In all other cases, a fixed notation is used.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: Number.prototype.toExponential(fractionDigits?)
  id: totrans-1220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Number.prototype.toExponential(fractionDigits?)` forces a number to be expressed
    in exponential notation. `fractionDigits` is a number between 0 and 20 that determines
    how many digits should be shown after the decimal point. If it is omitted, then
    as many significant digits are included as necessary to uniquely specify the number.'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we force more precision when `toString()` would also use exponential
    notation. Results are mixed, because we reach the limits of the precision that
    can be achieved when converting binary numbers to a decimal notation:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'In this example, the magnitude of the number is not large enough for an exponent
    being displayed by `toString()`. However, `toExponential()` does display an exponent:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'In this example, we get exponential notation when the fraction is not small
    enough:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Functions for Numbers
  id: totrans-1228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following functions operate on numbers:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: '`isFinite(number)`'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether `number` is an actual number (neither `Infinity` nor `NaN`).
    For details, see [Checking for Infinity](ch11.html#isFinite "Checking for Infinity").
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: '`isNaN(number)`'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns `true` if `number` is `NaN`. For details, see [Pitfall: checking whether
    a value is NaN](ch11.html#isNaN "Pitfall: checking whether a value is NaN").'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: '`parseFloat(str)`'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: Turns `str` into a floating-point number. For details, see [parseFloat()](ch11.html#parseFloat
    "parseFloat()").
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: '`parseInt(str, radix?)`'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: Parses `str` as an integer whose base is `radix` (2–36). For details, see [Integers
    via parseInt()](ch11.html#parseInt "Integers via parseInt()").
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: Sources for This Chapter
  id: totrans-1238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I referred to the following sources while writing this chapter:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: '[“IEEE Standard 754 Floating Point Numbers”](http://bit.ly/1oOc43P) by Steve
    Hollasch'
  id: totrans-1240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Data Types and Scaling (Fixed-Point Blockset)”](http://bit.ly/1oOc83t) in
    the MATLAB documentation'
  id: totrans-1241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“IEEE floating point”](http://en.wikipedia.org/wiki/IEEE_754) on Wikipedia'
  id: totrans-1242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: '^([[12](#id995098)]) Source: Brendan Eich, [http://bit.ly/1lKzQeC](http://bit.ly/1lKzQeC).'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: ^([[13](#id1001327)]) Béla Varga (@netzzwerg) pointed out that IEEE 754 specifies
    NaN as not equal to itself.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12. Strings
  id: totrans-1246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strings are immutable sequences of JavaScript characters. Each such character
    is a 16-bit UTF-16 code unit. That means that a single Unicode character is represented
    by either one or two JavaScript characters. You mainly need to worry about the
    two-character case whenever you are counting characters or splitting strings (see
    [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript")).
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: String Literals
  id: totrans-1248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both single and double quotes can be used to delimit string literals:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'Thus, you are free to use either kind of quote. There are several considerations,
    though:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: The most common style in the community is to use double quotes for HTML and
    single quotes for JavaScript.
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, double quotes are used exclusively for strings in some languages
    (e.g., C and Java). Therefore, it may make sense to use them in a multilanguage
    code base.
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For JSON (discussed in [Chapter 22](ch22.html "Chapter 22. JSON")), you must
    use double quotes.
  id: totrans-1254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your code will look cleaner if you quote consistently. But sometimes, a different
    quote means that you don’t have to escape, which can justify your being less consistent
    (e.g., you may normally use single quotes, but temporarily switch to double quotes
    to write the last one of the preceding examples).
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: Escaping in String Literals
  id: totrans-1256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most characters in string literals simply represent themselves. The backslash
    is used for *escaping* and enables several special features:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: Line continuations
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: 'You can spread a string over multiple lines by escaping the end of the line
    (the line-terminating character, the *line terminator*) with a backslash:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  id: totrans-1260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'An alternative is to use the plus operator to concatenate:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: Character escape sequences
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: 'These sequences start with a backslash:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: 'Control characters: `\b` is a backspace, `\f` is a form feed, `\n` is a line
    feed (newline), `\r` is a carriage return, `\t` is a horizontal tab, and `\v`
    is a vertical tab.'
  id: totrans-1265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Escaped characters that represent themselves: `\''` is a single quote, `\"`
    is a double quote, and `\\` is a backslash. All characters except `b f n r t v
    x u` and decimal digits represent themselves, too. Here are two examples:'
  id: totrans-1266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE279]'
  id: totrans-1267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: NUL character (Unicode code point 0)
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: This character is represented by `\0`.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal escape sequences
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: '`\xHH` (`HH` are two hexadecimal digits) specifies a character via an ASCII
    code. For example:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: Unicode escape sequences
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: '`\uHHHH` (`HHHH` are four hexadecimal digits) specifies a UTF-16 code unit
    (see [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript")). Here are two
    examples:'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: Character Access
  id: totrans-1276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two operations that return the *n*th character of a string.^([[14](#ftn.id925641)])
    Note that JavaScript does not have a special data type for characters; these operations
    return strings:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: Some older browsers don’t support the array-like access to characters via square
    brackets.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: Converting to String
  id: totrans-1280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Values are converted to a string as follows:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Result |'
  id: totrans-1282
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1283
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `''undefined''` |'
  id: totrans-1284
  prefs: []
  type: TYPE_TB
- en: '| `null` | `''null''` |'
  id: totrans-1285
  prefs: []
  type: TYPE_TB
- en: '| A boolean | `false` → `''false''` |'
  id: totrans-1286
  prefs: []
  type: TYPE_TB
- en: '|  | `true` → `''true''` |'
  id: totrans-1287
  prefs: []
  type: TYPE_TB
- en: '| A number | The number as a string (e.g., `3.141` → `''3.141''`) |'
  id: totrans-1288
  prefs: []
  type: TYPE_TB
- en: '| A string | Same as input (nothing to convert) |'
  id: totrans-1289
  prefs: []
  type: TYPE_TB
- en: '| An object | Call `ToPrimitive(value, String)` (see [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")) and convert the resulting primitive. |'
  id: totrans-1290
  prefs: []
  type: TYPE_TB
- en: Manually Converting to String
  id: totrans-1291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The three most common ways to convert any value to a string are:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: '| `String(value)` | (Invoked as a function, not as a constructor) |'
  id: totrans-1293
  prefs: []
  type: TYPE_TB
- en: '| `''''+value` |  |'
  id: totrans-1294
  prefs: []
  type: TYPE_TB
- en: '| `value.toString()` | (Does not work for `undefined` and `null`!) |'
  id: totrans-1295
  prefs: []
  type: TYPE_TB
- en: 'I prefer `String()`, because it is more descriptive. Here are some examples:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-1297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'Note that for displaying data, `JSON.stringify()` ([JSON.stringify(value, replacer?,
    space?)](ch22.html#JSON.stringify "JSON.stringify(value, replacer?, space?)"))
    often works better than the canonical conversion to string:'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  id: totrans-1299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Naturally, you have to be aware of the limitations of `JSON.stringify()`—it
    doesn’t always show everything. For example, it hides properties whose values
    it can’t handle (functions and more!). On the plus side, its output can be parsed
    by `eval()` and it can display deeply nested data as nicely formatted trees.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: conversion is not invertible'
  id: totrans-1301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given how often JavaScript automatically converts, it is a shame that the conversion
    isn’t always invertible, especially with regard to booleans:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: For `undefined` and `null`, we face similar problems.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Strings
  id: totrans-1305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways of comparing strings. First, you can use the comparison
    operators: `<`, `>`, `===`, `<=`, `>=`. They have the following drawbacks:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: 'They’re case-sensitive:'
  id: totrans-1307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE286]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'They don’t handle umlauts and accents well:'
  id: totrans-1309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE287]'
  id: totrans-1310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'Second, you can use `String.prototype.localeCompare(other)`, which tends to
    fare better, but isn’t always supported (consult [Search and Compare](ch12.html#String.prototype.localeCompare
    "Search and Compare") for details). The following is an interaction in Firefox’s
    console:'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  id: totrans-1312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: A result less than zero means that the receiver is “smaller” than the argument.
    A result greater than zero means that the receiver is “larger” than the argument.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating Strings
  id: totrans-1314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two main approaches for concatenating strings.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: 'Concatenation: The Plus (+) Operator'
  id: totrans-1316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The operator `+` does string concatenation as soon as one of its operands is
    a string. If you want to collect string pieces in a variable, the compound assignment
    operator `+=` is useful:'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  id: totrans-1318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'Concatenation: Joining an Array of String Fragments'
  id: totrans-1319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It may seem that the previous approach creates a new string whenever a piece
    is added to `str`. Older JavaScript engines do it that way, which means that you
    can improve the performance of string concatenation by collecting all the pieces
    in an array first and joining them as a last step:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: However, newer engines optimize string concatenation via `+` and use a similar
    method internally. Therefore, the plus operator is faster on those engines.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: The Function String
  id: totrans-1323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function `String` can be invoked in two ways:'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: '`String(value)`'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: 'As a normal function, it converts `value` to a primitive string (see [Converting
    to String](ch12.html#tostring "Converting to String")):'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  id: totrans-1327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '`new String(str)`'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: 'As a constructor, it creates a new instance of `String` (see [Wrapper Objects
    for Primitives](ch08.html#wrapper_objects "Wrapper Objects for Primitives")),
    an object that wraps `str` (nonstrings are coerced to string). For example:'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  id: totrans-1330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: The former invocation is the common one.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: String Constructor Method
  id: totrans-1332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`String.fromCharCode(codeUnit1, codeUnit2, ...)` produces a string whose characters
    are the UTF-16 code units specified by the 16-bit unsigned integers `codeUnit1`,
    `codeUnit2`, and so on. For example:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'If you want to turn an array of numbers into a string, you can do so via `apply()`
    (see [func.apply(thisValue, argArray)](ch15.html#functional_apply "func.apply(thisValue,
    argArray)")):'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  id: totrans-1336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: The inverse of `String.fromCharCode()` is `String.prototype.charCodeAt()`.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: String Instance Property length
  id: totrans-1338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `length` property indicates the number of JavaScript characters in the
    string and is immutable:'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  id: totrans-1340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: String Prototype Methods
  id: totrans-1341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All methods of primitive strings are stored in `String.prototype` (refer back
    to [Primitives Borrow Their Methods from Wrappers](ch08.html#primitive_methods_via_wrappers
    "Primitives Borrow Their Methods from Wrappers")). Next, I describe how they work
    for primitive strings, not for instances of `String`.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: Extract Substrings
  id: totrans-1343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods extract substrings from the receiver:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.charAt(pos)`'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a string with the character at position `pos`. For example:'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'The following two expressions return the same result, but some older JavaScript
    engines support only `charAt()` for accessing characters:'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '`String.prototype.charCodeAt(pos)`'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: Returns the code (a 16-bit unsigned integer) of the JavaScript character (a
    UTF-16 code unit; see [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript"))
    at position `pos`.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you create an array of character codes:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: The inverse of `charCodeAt()` is `String.fromCharCode()`.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.slice(start, end?)`'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the substring starting at position `start` up to and excluding position
    `end`. Both of the two parameters can be negative, and then the `length` of the
    string is added to them:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '`String.prototype.substring(start, end?)`'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: Should be avoided in favor of `slice()`, which is similar, but can handle negative
    positions and is implemented more consistently across browsers.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.split(separator?, limit?)`'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracts the substrings of the receiver that are delimited by `separator` and
    returns them in an array. The method has two parameters:'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: '`separator`: Either a string or a regular expression. If missing, the complete
    string is returned, wrapped in an array.'
  id: totrans-1362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit`: If given, the returned array contains at most `limit` elements.'
  id: totrans-1363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'If there is a group, then the matches are also returned as array elements:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'Use `''''` (empty string) as a separator to produce an array with the characters
    of a string:'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: Transform
  id: totrans-1370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the previous section was about extracting substrings, this section is
    about transforming a given string into a new one. These methods are typically
    used as follows:'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: 'In other words, the original string is discarded after it has been (nondestructively)
    transformed:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.trim()`'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: 'Removes all whitespace from the beginning and the end of the string:'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  id: totrans-1376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '`String.prototype.concat(str1?, str2?, ...)`'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the concatenation of the receiver and `str1`, `str2`, etc.:'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '`String.prototype.toLowerCase()`'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: 'Creates a new string with all of the original string’s characters converted
    to lowercase:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '`String.prototype.toLocaleLowerCase()`'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: 'Works the same as `toLowerCase()`, but respects the rules of the current locale.
    According to the ECMAScript spec: “There will only be a difference in the few
    cases (such as Turkish) where the rules for that language conflict with the regular
    Unicode case mappings.”'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.toUpperCase()`'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: 'Creates a new string with all of the original string’s characters converted
    to uppercase:'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  id: totrans-1387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '`String.prototype.toLocaleUpperCase()`'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: Works the same as `toUpperCase()`, but respects the rules of the current locale.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: Search and Compare
  id: totrans-1390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods are used for searching and comparing strings:'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.indexOf(searchString, position?)`'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches for `searchString` starting at `position` (the default is 0). It returns
    the position where `searchString` has been found or –1 if it can’t be found:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'Note that when it comes to finding text inside a string, a regular expression
    works just as well. For example, the following two expressions are equivalent:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '`String.prototype.lastIndexOf(searchString, position?)`'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches for `searchString`, starting at `position` (the default is the end),
    backward. It returns the position where `searchString` has been found or –1 if
    it can’t be found:'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '`String.prototype.localeCompare(other)`'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: 'Performs a locale-sensitive comparison of the string with `other`. It returns
    a number:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: < 0 if the string comes before `other`
  id: totrans-1402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: = 0 if the string is equivalent to `other`
  id: totrans-1403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 if the string comes after `other`
  id: totrans-1404
  prefs:
  - PREF_UL
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  id: totrans-1406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: Warning
  id: totrans-1407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all JavaScript engines implement this method properly. Some just base it
    on the comparison operators. However, the ECMAScript Internationalization API
    (see [The ECMAScript Internationalization API](ch30.html#i18n_api "The ECMAScript
    Internationalization API")) does provide a Unicode-aware implementation. That
    is, if that API is available in an engine, `localeCompare()` will work.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: If it is supported, `localeCompare()` is a better choice for comparing strings
    than the comparison operators. Consult [Comparing Strings](ch12.html#comparing_strings
    "Comparing Strings") for more information.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: Test, Match, and Replace with Regular Expressions
  id: totrans-1410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods work with regular expressions:'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.search(regexp)` (more thoroughly explained in [String.prototype.search:
    At What Index Is There a Match?](ch19.html#String.prototype.search "String.prototype.search:
    At What Index Is There a Match?"))'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the first index at which `regexp` matches in the receiver (or –1 if
    it doesn’t):'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '`String.prototype.match(regexp)` (more thoroughly explained in [String.prototype.match:
    Capture Groups or Return All Matching Substrings](ch19.html#String.prototype.match
    "String.prototype.match: Capture Groups or Return All Matching Substrings"))'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: 'Matches the given regular expression against the receiver. It returns a match
    object for the first match if the flag `/g` of `regexp` is not set:'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  id: totrans-1417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: 'If the flag `/g` is set, then all complete matches (group 0) are returned in
    an array:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '`String.prototype.replace(search, replacement)` (more thoroughly explained
    in [String.prototype.replace: Search and Replace](ch19.html#String.prototype.replace
    "String.prototype.replace: Search and Replace"))'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches for `search` and replaces it with `replacement`. `search` can be a
    string or a regular expression, and `replacement` can be a string or a function.
    Unless you use a regular expression as `search` whose flag `/g` is set, only the
    first occurrence will be replaced:'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  id: totrans-1422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'A dollar sign (`$`) in a replacement string allows you to refer to the complete
    match or a captured group:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: 'You can also compute a replacement via a function:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '* * *'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: ^([[14](#id925641)]) Strictly speaking, a JavaScript string consists of a sequence
    of UTF-16 code units. That is, JavaScript characters are Unicode code units (see
    [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript")).
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13. Statements
  id: totrans-1429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter covers JavaScript’s statements: variable declarations, loops,
    conditionals, and others.'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and Assigning Variables
  id: totrans-1431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`var` is used to *declare* a variable, which creates the variable and enables
    you to work with it. The equals operator (`=`) is used to assign a value to it:'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  id: totrans-1433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '`var` also lets you combine the preceding two statements into a single one:'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'Finally, you can also combine multiple `var` statements into one:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'Read more about how variables work in [Chapter 16](ch16.html "Chapter 16. Variables:
    Scopes, Environments, and Closures").'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: The Bodies of Loops and Conditionals
  id: totrans-1439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compound statements such as loops and conditionals have one or more “bodies”
    embedded—for example, the `while` loop:'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  id: totrans-1441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'For the body `«statement»`, you have a choice. You can either use a single
    statement:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  id: totrans-1443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'or you can use a block (which counts as a single statement):'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  id: totrans-1445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: You need to use a block if you want the body to comprise multiple statements.
    Unless the complete compound statement can be written in a single line, I recommend
    using a block.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  id: totrans-1447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explores JavaScript’s loop statements.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: Mechanisms to Be Used with Loops
  id: totrans-1449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following mechanisms can be used with all loops:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: '`break ⟦«label»⟧`'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: Exit from a loop.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: '`continue ⟦«label»⟧`'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: Stop the current loop iteration, and immediately continue with the next one.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: Labels
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: 'A label is an identifier followed by a colon. In front of a loop, a label allows
    you to break or continue that loop even from a loop nested inside of it. In front
    of a block, you can break out of that block. In both cases, the name of the label
    becomes an argument of `break` or `continue`. Here’s an example of breaking out
    of a block:'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  id: totrans-1457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: while
  id: totrans-1458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `while` loop:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  id: totrans-1460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'executes `statement` as long as `condition` holds. If `condition` is always
    `true`, you get an infinite loop:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  id: totrans-1462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'In the following example, we remove all elements of an array and log them to
    the console:'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  id: totrans-1464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'Here is the output:'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  id: totrans-1466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: do-while
  id: totrans-1467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `do-while` loop:'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  id: totrans-1469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'executes `statement` at least once and then as long as `condition` holds. For
    example:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  id: totrans-1471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: for
  id: totrans-1472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a `for` loop:'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '`init` is executed once before the loop, which continues as long as `condition`
    is `true`. You can use `var` in `init` to declare variables, but the scope of
    those variables is always the complete surrounding function. `post_iteration`
    is executed after each iteration of the loop. Taking all of this into consideration,
    the preceding loop is equivalent to the following `while` loop:'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  id: totrans-1476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'The following example is the traditional way of iterating over arrays (other
    possibilities are described in [Best Practices: Iterating over Arrays](ch18.html#array_iteration
    "Best Practices: Iterating over Arrays")):'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'A `for` loop becomes infinite if you omit all parts of the head:'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  id: totrans-1480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: for-in
  id: totrans-1481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `for-in` loop:'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  id: totrans-1483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'iterates over all property keys of `object`, including inherited ones. However,
    properties that are marked as not enumerable are ignored (see [Property Attributes
    and Property Descriptors](ch17_split_000.html#property_attributes "Property Attributes
    and Property Descriptors")). The following rules apply to `for-in` loops:'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: You can use `var` to declare variables, but the scope of those variables is
    always the complete surrounding function.
  id: totrans-1485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties can be deleted during iteration.
  id: totrans-1486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Best practice: don’t use for-in for arrays'
  id: totrans-1487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Don’t use `for-in` to iterate over arrays. First, it iterates over indices,
    not over values:'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  id: totrans-1489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'Second, it also iterates over all (nonindex) property keys. The following example
    illustrates what happens when you add a property `foo` to an array:'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  id: totrans-1491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'Thus, you are better off with a normal `for` loop or the array method `forEach()`
    (see [Best Practices: Iterating over Arrays](ch18.html#array_iteration "Best Practices:
    Iterating over Arrays")).'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: 'Best practice: be careful with for-in for objects'
  id: totrans-1493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `for-in` loop iterates over *all* (enumerable) properties, including inherited
    ones. That may not be what you want. Let’s use the following constructor to illustrate
    the problem:'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: 'Instances of `Person` inherit the property `describe` from `Person.prototype`,
    which is seen by `for-in`:'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  id: totrans-1497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'Here is the output:'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  id: totrans-1499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'Normally, the best way to use `for-in` is to skip inherited properties via
    `hasOwnProperty()`:'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  id: totrans-1501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: 'And here is the output:'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  id: totrans-1503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: 'There is one last caveat: `person` may have a property `hasOwnProperty`, which
    would prevent the check from working. To be safe, you have to refer to the generic
    method (see [Generic Methods: Borrowing Methods from Prototypes](ch17_split_001.html#generic_method
    "Generic Methods: Borrowing Methods from Prototypes")) `Object.prototype.hasOwnProperty`
    directly:'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  id: totrans-1505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'There are other, more comfortable, means for iterating over property keys,
    which are described in [Best Practices: Iterating over Own Properties](ch17_split_000.html#object_iteration
    "Best Practices: Iterating over Own Properties").'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: for each-in
  id: totrans-1507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This loop exists only on Firefox. Don’t use it.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  id: totrans-1509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section covers JavaScript’s conditional statements.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: if-then-else
  id: totrans-1511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In an `if-then-else` statement:'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  id: totrans-1513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '`then_branch` and `else_branch` can be either single statements or blocks of
    statements (see [The Bodies of Loops and Conditionals](ch13.html#loops_conditionals_bodies
    "The Bodies of Loops and Conditionals")).'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: Chaining if statements
  id: totrans-1515
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can chain several `if` statements:'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  id: totrans-1517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: Note that in the preceding example, all the `else` branches are single statements
    (`if` statements). Programming languages that only allow blocks for `else` branches
    need some kind of `else-if` branch for chaining.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: dangling else'
  id: totrans-1519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `else` branch of the following example is called *dangling*, because it
    is not clear to which of the two `if` statements it belongs:'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  id: totrans-1521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: 'Here’s a simple rule: use braces. The preceding snippet is equivalent to the
    following code (where it is obvious who the `else` belongs to):'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: switch
  id: totrans-1524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `switch` statement:'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  id: totrans-1526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: evaluates `expression` and then jumps to the `case` clause whose label matches
    the result. If no label matches, `switch` jumps to the `default` clause if it
    exists or does nothing otherwise.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: The “operand” after `case` can be any expression; it is compared via `===` with
    the parameter of `switch`.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t finish a clause with a terminating statement, execution continues
    into the next clause. The most frequently used terminating statement is `break`.
    But `return` and `throw` also work, even though they normally leave more than
    just the `switch` statement.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates that you don’t need to `break` if you use
    `throw` or `return`:'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  id: totrans-1531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: 'In this example, there is no `default` clause. Therefore, nothing happens if
    `fruit` matches none of the `case` labels:'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  id: totrans-1533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: 'Here, there are multiple `case` labels in a row:'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  id: totrans-1535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: 'This example demonstrates that the value after `case` can be an arbitrary expression:'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  id: totrans-1537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: 'The preceding `switch` statement looks for a match for its parameter `true`
    by going through the `case` clauses. If one of the `case` expressions evaluates
    to `true`, the corresponding `case` body is executed. Therefore, the preceding
    code is equivalent to the following `if` statement:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  id: totrans-1539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: You normally should prefer the latter solution; it is more self-explanatory.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: The with Statement
  id: totrans-1541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explains how the `with` statement works in JavaScript and why its
    use is discouraged.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: Syntax and Semantics
  id: totrans-1543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax of the `with` statement is as follows:'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'It turns the properties of `object` into local variables for `statement`. For
    example:'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  id: totrans-1547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'Its intended use is to avoid redundancy when accessing an object several times.
    The following is an example of code with redundancies:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '`with` makes this shorter:'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  id: totrans-1551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: The with Statement Is Deprecated
  id: totrans-1552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The use of the `with` statement is generally discouraged (the next section
    explains why). For example, it is forbidden in strict mode:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  id: totrans-1554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: Techniques for avoiding the with statement
  id: totrans-1555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Avoid code like this:'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'Instead, use a temporary variable with a short name:'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  id: totrans-1559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: 'If you don’t want to expose the temporary variable `b` to the current scope,
    you can use an IIFE (see [Introducing a New Scope via an IIFE](ch16.html#iife
    "Introducing a New Scope via an IIFE")):'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  id: totrans-1561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: 'You also have the option of making the object that you want to access a parameter
    of the IIFE:'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  id: totrans-1563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: The Rationale for the Deprecation
  id: totrans-1564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand why `with` is deprecated, look at the following example and notice
    how the function’s argument completely changes how it works:'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  id: totrans-1566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: 'If `opts` has a property `msg`, then the statement in line (1) doesn’t access
    the parameter `msg` anymore. It accesses the property:'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  id: totrans-1568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'There are three problems that the `with` statement causes:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: Performance suffers
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: Variable lookup becomes slower, because an object is temporarily inserted into
    the scope chain.
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: Code becomes less predictable
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot determine what an identifier refers to by looking at its syntactic
    surroundings (its lexical context). According to [Brendan Eich](http://bit.ly/1jCrTKj),
    that was the actual reason why `with` was deprecated, not performance considerations:'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: '`with` violates lexical scope, making program analysis (e.g. for security)
    hard to infeasible.'
  id: totrans-1574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Minifiers (described in [Chapter 32](ch32.html "Chapter 32. More Tools")) can’t
    shorten variable names
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: Inside a `with` statement, you can’t statically determine whether a name refers
    to a variable or a property. Only variables can be renamed by minifiers.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of `with` making code brittle:'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  id: totrans-1578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: You can prevent the function call in line (3) from working, even if you don’t
    have access to the array `myData`.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: 'How? By adding a property `values` to `Array.prototype`. For example:'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  id: totrans-1581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: Now the code in line (2) calls `someArray.values.someMethod()` instead of `values.someMethod()`.
    The reason is that, inside the `with` statement, `values` now refers to `someArray.values`
    and not the local variable from line (1) anymore.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not just a thought experiment: the array method `values()` was added
    to Firefox and broke the TYPO3 content management system. [Brandon Benvie figured
    out what went wrong](http://mzl.la/1jCrXti).'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: The debugger Statement
  id: totrans-1584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax for the `debugger` statement is as follows:'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  id: totrans-1586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: If a debugger is active, this statement functions as a breakpoint; if not, it
    has no observable effect.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14. Exception Handling
  id: totrans-1588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter describes how JavaScript’s exception handling works. It begins
    with a general explanation of what exception handling is.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: What Is Exception Handling?
  id: totrans-1590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In exception handling, you often group statements that are tightly coupled.
    If, while you are executing those statements, one of them causes an error, then
    it makes no sense to continue with the remaining statements. Instead, you try
    to recover from the error as gracefully as you can. This is loosely reminiscent
    of transactions (but without the atomicity).
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at code without exception handling:'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  id: totrans-1593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'What is the best way to react to an error in `openFile()` at (2)? Clearly,
    the statement (1) should not be executed anymore. But we wouldn’t want to abort
    `extractAllEntries()`, either. Instead, it is enough to skip the current file
    and continue with the next one. To do that, we add exception handling to the previous
    code:'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  id: totrans-1595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: 'There are two aspects to exception handling:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: If there is a problem that can’t be handled meaningfully where it occurs, throw
    an exception.
  id: totrans-1597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find a place where errors can be handled: catch exceptions.'
  id: totrans-1598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At (1), the following constructs are active:'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  id: totrans-1600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: The `throw` statement at (1) walks up that tree and leaves all constructs until
    it encounters an active `try` statement. It then invokes that statement’s `catch`
    block and passes it the exception value.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: Exception Handling in JavaScript
  id: totrans-1602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exception handling in JavaScript works like in most programming languages:
    a `try` statement groups statements and lets you intercept exceptions in those
    statements.'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: throw
  id: totrans-1604
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax of `throw` is as follows:'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  id: totrans-1606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: 'Any JavaScript value can be thrown. For simplicity’s sake, many JavaScript
    programs just throw strings:'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  id: totrans-1608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'Don’t do this. JavaScript has special constructors for exception objects (see
    [Error Constructors](ch14.html#error_constructors "Error Constructors")). Use
    those or subclass them (see [Chapter 28](ch28.html "Chapter 28. Subclassing Built-ins")).
    Their advantage is that JavaScript automatically adds a stack trace (on most engines)
    and that they have room for additional context-specific properties. The simplest
    solution is to use the built-in constructor `Error()`:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  id: totrans-1610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: try-catch-finally
  id: totrans-1611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax of `try-catch-finally` looks as follows. `try` is mandatory, and
    at least one of `catch` and `finally` must be there, too:'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  id: totrans-1613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: 'Here’s how it works:'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: '`catch` catches any exception that is thrown in `try_statements`, whether directly
    or in functions they invoke. Tip: If you want to distinguish between different
    kinds of exceptions, you can use the `constructor` property to switch over the
    exceptions’ constructors (see [Use cases for the constructor property](ch17_split_001.html#switch_constructor
    "Use cases for the constructor property")).'
  id: totrans-1615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finally` is always executed, no matter what happens in `try_statements` (or
    in functions they invoke). Use it for clean-up operations that should always be
    performed, no matter what happens in `try_statements`:'
  id: totrans-1616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE375]'
  id: totrans-1617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: If one of the `try_statements` is a `return`, then the `try` block is executed
    afterward (immediately before leaving the function or method; see the examples
    that follow).
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  id: totrans-1619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any value can be thrown:'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  id: totrans-1621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: 'Here is the interaction:'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  id: totrans-1623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '`finally` is always executed:'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  id: totrans-1625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: 'Here is the interaction:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  id: totrans-1627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '`finally` is executed *after* a `return` statement:'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  id: totrans-1629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'Here is the interaction:'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  id: totrans-1631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: 'The return value is queued before executing `finally`:'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  id: totrans-1633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'By the time statement (1) is executed, the value of `count` has already been
    queued for returning:'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  id: totrans-1635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: Error Constructors
  id: totrans-1636
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ECMAScript standardizes the following error constructors. The descriptions
    are quoted from the ECMAScript 5 specification:'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: '`Error` is a generic constructor for errors. All other error constructors mentioned
    here are subconstructors.'
  id: totrans-1638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EvalError` “is not currently used within this specification. This object remains
    for compatibility with previous editions of this specification.”'
  id: totrans-1639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RangeError` “indicates a numeric value has exceeded the allowable range.”
    For example:'
  id: totrans-1640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE384]'
  id: totrans-1641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '`ReferenceError` “indicates that an invalid reference value has been detected.”
    Usually, this is an unknown variable. For example:'
  id: totrans-1642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE385]'
  id: totrans-1643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '`SyntaxError` “indicates that a parsing error has occurred”—for example, while
    parsing code via `eval()`:'
  id: totrans-1644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE386]'
  id: totrans-1645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '`TypeError` “indicates the actual type of an operand is different than the
    expected type.” For example:'
  id: totrans-1646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE387]'
  id: totrans-1647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '`URIError` “indicates that one of the global URI handling functions was used
    in a way that is incompatible with its definition.” For example:'
  id: totrans-1648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE388]'
  id: totrans-1649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: 'Here are the properties of errors:'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: '`message`'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: The error message.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: The name of the error.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: '`stack`'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: A stack trace. This is nonstandard, but is available on many platforms—for example,
    Chrome, Node.js, and Firefox.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: Stack Traces
  id: totrans-1657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The usual sources of errors are either external (wrong input, missing file,
    etc.) or internal (a bug in the program). Especially in the latter case, you will
    get unexpected exceptions and need to debug. Often you don’t have a debugger running.
    For “manual” debugging, two pieces of information are helpful:'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: 'Data: What values do variables have?'
  id: totrans-1659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execution: In what line did the exception happen, and what function calls were
    active?'
  id: totrans-1660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can put some of the first item (data) into either the message or the properties
    of an exception object. The second item (execution) is supported on many JavaScript
    engines via *stack traces*, snapshots of the call stack when the exception objects
    were created. The following example prints a stack trace:'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  id: totrans-1662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: 'Here’s the interaction:'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  id: totrans-1664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: Implementing Your Own Error Constructor
  id: totrans-1665
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want stack traces, you need the services of the built-in error constructors.
    You can use an existing constructor and attach your own data to it. Or you can
    create a subconstructor, whose instances can be distinguished from those of other
    error constructors via `instanceof`. Alas, doing so (for built-in constructors)
    is complicated; see [Chapter 28](ch28.html "Chapter 28. Subclassing Built-ins")
    to learn how to do it.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15. Functions
  id: totrans-1667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions are values that can be called. One way of defining a function is
    called a *function declaration*. For example, the following code defines the function
    `id` that has a single parameter, `x`:'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  id: totrans-1669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: 'The `return` statement returns a value from `id`. You can call a function by
    mentioning its name, followed by arguments in parentheses:'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  id: totrans-1671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'If you don’t return anything from a function, `undefined` is returned (implicitly):'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  id: totrans-1673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: This section showed just one way of defining and one way of calling a function.
    Others are described later.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: The Three Roles of Functions in JavaScript
  id: totrans-1675
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have defined a function as just shown, it can play several roles:'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: Nonmethod function (“normal function”)
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: 'You can call a function directly. Then it works as a normal function. Here’s
    an example invocation:'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  id: totrans-1679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: By convention, the names of normal functions start with lowercase letters.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: Constructor
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: 'You can invoke a function via the `new` operator. Then it becomes a constructor,
    a factory for objects. Here’s an example invocation:'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  id: totrans-1683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: By convention, the names of constructors start with uppercase letters.
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: Method
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: 'You can store a function in a property of an object, which turns it into a
    *method* that you can invoke via that object. Here’s an example invocation:'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  id: totrans-1687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: By convention, the names of methods start with lowercase letters.
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: Nonmethod functions are explained in this chapter; constructors and methods
    are explained in [Chapter 17](ch17_split_000.html "Chapter 17. Objects and Inheritance").
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminology: “Parameter” Versus “Argument”'
  id: totrans-1690
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The terms *parameter* and *argument* are often used interchangeably, because
    the context usually makes it clear what the intended meaning is. The following
    is a rule of thumb for distinguishing them.
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: '*Parameters* are used to define a function. They are also called formal parameters
    and formal arguments. In the following example, `param1` and `param2` are parameters:'
  id: totrans-1692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE397]'
  id: totrans-1693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '*Arguments* are used to invoke a function. They are also called actual parameters
    and actual arguments. In the following example, `3` and `7` are arguments:'
  id: totrans-1694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE398]'
  id: totrans-1695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: Defining Functions
  id: totrans-1696
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section describes three ways to create a function:'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: Via a function expression
  id: totrans-1698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via a function declaration
  id: totrans-1699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via the constructor `Function()`
  id: totrans-1700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All functions are objects, instances of `Function`:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  id: totrans-1702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Therefore, functions get their methods from `Function.prototype`.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: Function Expressions
  id: totrans-1704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function expression produces a value—a function object. For example:'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  id: totrans-1706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: The preceding code assigned the result of a function expression to the variable
    `add` and called it via that variable. The value produced by a function expression
    can be assigned to a variable (as shown in the last example), passed as an argument
    to another function, and more. Because normal function expressions don’t have
    a name, they are also called *anonymous function expressions*.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: Named function expressions
  id: totrans-1708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can give a function expression a name. *Named function expressions* allow
    a function expression to refer to itself, which is useful for self-recursion:'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  id: totrans-1710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: Note
  id: totrans-1711
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The name of a named function expression is only accessible inside the function
    expression:'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  id: totrans-1713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: Function Declarations
  id: totrans-1714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a function declaration:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  id: totrans-1716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: 'The preceding looks like a function expression, but it is a statement (see
    [Expressions Versus Statements](ch07.html#expr_vs_stmt "Expressions Versus Statements")).
    It is roughly equivalent to the following code:'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  id: totrans-1718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: In other words, a function declaration declares a new variable, creates a function
    object, and assigns it to the variable.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: The Function Constructor
  id: totrans-1720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The constructor `Function()` evaluates JavaScript code stored in strings. For
    example, the following code is equivalent to the previous example:'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: However, this way of defining a function is slow and keeps code in strings (inaccessible
    to tools). Therefore, it is much better to use a function expression or a function
    declaration if possible. [Evaluating Code Using new Function()](ch23.html#function_constructor
    "Evaluating Code Using new Function()") explains `Function()` in more detail;
    it works similarly to `eval()`.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: Hoisting
  id: totrans-1724
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Hoisting* means “moving to the beginning of a scope.” Function declarations
    are hoisted completely, variable declarations only partially.'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: 'Function declarations are completely hoisted. That allows you to call a function
    before it has been declared:'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  id: totrans-1727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: 'The reason the preceding code works is that JavaScript engines move the declaration
    of `foo` to the beginning of the scope. They execute the code as if it looked
    like this:'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  id: totrans-1729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '`var` declarations are hoisted, too, but only the declarations, not assignments
    made with them. Therefore, using a `var` declaration and a function expression
    similarly to the previous example results in an error:'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  id: totrans-1731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: 'Only the variable declaration is hoisted. The engine executes the preceding
    code as:'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  id: totrans-1733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: The Name of a Function
  id: totrans-1734
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most JavaScript engines support the nonstandard property `name` for function
    objects. Function declarations have it:'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  id: totrans-1736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: 'The name of anonymous function expressions is the empty string:'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  id: totrans-1738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: 'Named function expressions, however, do have a name:'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  id: totrans-1740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: The name of a function is useful for debugging. Some people always give their
    function expressions names for that reason.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: 'Which Is Better: A Function Declaration or a Function Expression?'
  id: totrans-1742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Should you prefer a function declaration like the following?
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: Or the equivalent combination of a `var` declaration plus a function expression?
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  id: totrans-1746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: 'They are basically the same, but function declarations have two advantages
    over function expressions:'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: They are hoisted (see [Hoisting](ch15.html#function_hoisting "Hoisting")), so
    you can call them before they appear in the source code.
  id: totrans-1748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have a name (see [The Name of a Function](ch15.html#function_names "The
    Name of a Function")). However, JavaScript engines are getting better at inferring
    the names of anonymous function expressions.
  id: totrans-1749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More Control over Function Calls: call(), apply(), and bind()'
  id: totrans-1750
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`call()`, `apply()`, and `bind()` are methods that all functions have (remember
    that functions are objects and therefore have methods). They can supply a value
    for `this` when invoking a method and thus are mainly interesting in an object-oriented
    context (see [Calling Functions While Setting this: call(), apply(), and bind()](ch17_split_000.html#oop_call_apply_bind
    "Calling Functions While Setting this: call(), apply(), and bind()")). This section
    explains two use cases for nonmethods.'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: func.apply(thisValue, argArray)
  id: totrans-1752
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method uses the elements of `argArray` as arguments while calling the
    function `func`; that is, the following two expressions are equivalent:'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  id: totrans-1754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '`thisValue` is the value that `this` has while executing `func`. It is not
    needed in a non-object-oriented setting and is thus `null` here.'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: '`apply()` is useful whenever a function accepts multiple arguments in an array-like
    manner, but not an array.'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to `apply()`, we can use `Math.max()` (see [Other Functions](ch21.html#Math_max
    "Other Functions")) to determine the maximum element of an array:'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  id: totrans-1758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: func.bind(thisValue, arg1, ..., argN)
  id: totrans-1759
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This performs *partial function application*—a new function is created that
    calls `func` with `this` set to `thisValue` and the following arguments: first
    `arg1` until `argN`, and then the actual arguments of the new function. `thisValue`
    is not needed in the following non-object-oriented setting, which is why it is
    `null`.'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use `bind()` to create a new function `plus1()` that is like `add()`,
    but only requires the parameter `y`, because `x` is always 1:'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  id: totrans-1762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: 'In other words, we have created a new function that is equivalent to the following
    code:'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  id: totrans-1764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: Handling Missing or Extra Parameters
  id: totrans-1765
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript does not enforce a function’s arity: you can call it with any number
    of actual parameters, independent of what formal parameters have been defined.
    Hence, the number of actual parameters and formal parameters can differ in two
    ways:'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: More actual parameters than formal parameters
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: The extra parameters are ignored but can be retrieved via the special array-like
    variable `arguments` (discussed momentarily).
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: Fewer actual parameters than formal parameters
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: The missing formal parameters all have the value `undefined`.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: 'All Parameters by Index: The Special Variable arguments'
  id: totrans-1771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The special variable `arguments` exists only inside functions (including methods).
    It is an array-like object that holds all of the actual parameters of the current
    function call. The following code uses it:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  id: totrans-1773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: 'And here is the interaction:'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  id: totrans-1775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '`arguments` has the following characteristics:'
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: It is array-like, but not an array. On one hand, it has a property `length`,
    and individual parameters can be read and written by index.
  id: totrans-1777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, `arguments` is not an array, it is only similar to one. It
    has none of the array methods (`slice()`, `forEach()`, etc.). Thankfully, you
    can borrow array methods or convert `arguments` to an array, as explained in [Array-Like
    Objects and Generic Methods](ch17_split_001.html#array-like_objects "Array-Like
    Objects and Generic Methods").
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: 'It is an object, so all object methods and operators are available. For example,
    you can use the `in` operator ([Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")) to check whether `arguments` “has” a
    given index:'
  id: totrans-1779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE421]'
  id: totrans-1780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: 'You can use `hasOwnProperty()` ([Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")) in a similar manner:'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  id: totrans-1782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: Deprecated features of arguments
  id: totrans-1783
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strict mode drops several of the more unusual features of `arguments`:'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.callee` refers to the current function. It is mainly used to do
    self-recursion in anonymous functions, and is not allowed in strict mode. As a
    workaround, use a named function expression (see [Named function expressions](ch15.html#named_function_expression
    "Named function expressions")), which can refer to itself via its name.'
  id: totrans-1785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In nonstrict mode, `arguments` stays up-to-date if you change a parameter:'
  id: totrans-1786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE423]'
  id: totrans-1787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: 'But this kind of updating is not done in strict mode:'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  id: totrans-1789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: Strict mode forbids assigning to the variable `arguments` (e.g., via `arguments++`).
    Assigning to elements and properties is still allowed.
  id: totrans-1790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mandatory Parameters, Enforcing a Minimum Arity
  id: totrans-1791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three ways to find out whether a parameter is missing. First, you
    can check if it is `undefined`:'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  id: totrans-1793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: 'Second, you can interpret the parameter as a boolean. Then `undefined` is considered
    `false`. However, there is a caveat: several other values are also considered
    `false` (see [Truthy and Falsy Values](ch10.html#truthy_falsy "Truthy and Falsy
    Values")), so the check cannot distinguish between, say, `0` and a missing parameter:'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  id: totrans-1795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: 'Third, you can also check the length of `arguments` to enforce a minimum arity:'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  id: totrans-1797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'The last approach differs from the other ones:'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: The first two approaches don’t distinguish between `foo()` and `foo(undefined)`.
    In both cases, an exception is thrown.
  id: totrans-1799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third approach throws an exception for `foo()` and sets `optional` to `undefined`
    for `foo(undefined)`.
  id: totrans-1800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional Parameters
  id: totrans-1801
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a parameter is optional, it means that you give it a default value if it
    is missing. Similarly to mandatory parameters, there are four alternatives.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: 'First, check for `undefined`:'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  id: totrans-1804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: 'Second, interpret `optional` as a boolean:'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  id: totrans-1806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: 'Third, you can use the Or operator `||` (see [Logical Or (||)](ch10.html#logical_or
    "Logical Or (||)")), which returns the left operand, if it isn’t falsy. Otherwise,
    it returns the right operand:'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  id: totrans-1808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: 'Fourth, you can check a function’s arity via `arguments.length`:'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  id: totrans-1810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: 'Again, the last approach differs from the other ones:'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: The first three approaches don’t distinguish between `bar(1, 2)` and `bar(1,
    2, undefined)`. In both cases, `optional` is `'default value'`.
  id: totrans-1812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth approach sets `optional` to `'default value'` for `bar(1, 2)` and
    leaves it `undefined` (i.e., unchanged) for `bar(1, 2, undefined)`.
  id: totrans-1813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another possibility is to hand in optional parameters as *named parameters*,
    as properties of an object literal (see [Named Parameters](ch15.html#named_parameters
    "Named Parameters")).
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: Simulating Pass-by-Reference Parameters
  id: totrans-1815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript, you cannot pass parameters by reference; that is, if you pass
    a variable to a function, its value is copied and handed to the function (pass
    by value). Therefore, the function can’t change the variable. If you need to do
    so, you must wrap the value of the variable in an array.
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstates a function that increments a variable:'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  id: totrans-1818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: 'Pitfall: Unexpected Optional Parameters'
  id: totrans-1819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you hand a function `c` as a parameter to another function `f`, then you
    have to be aware of two signatures:'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: The signature that `f` expects its parameter to have. `f` might provide several
    parameters, and `c` can decide how many (if any) of them to use.
  id: totrans-1821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual signature of `c`. For example, it might support optional parameters.
  id: totrans-1822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the two diverge, then you can get unexpected results: `c` could have optional
    parameters that you don’t know about and that would interpret additional arguments
    provided by `f` incorrectly.'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the array method `map()` (see [Transformation Methods](ch18.html#Array.prototype.map
    "Transformation Methods")) whose parameter is normally a function with a single
    parameter:'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  id: totrans-1825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: 'One function that you could pass as an argument is `parseInt()` (see [Integers
    via parseInt()](ch11.html#parseInt "Integers via parseInt()")):'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  id: totrans-1827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: 'You may (incorrectly) think that `map()` provides only a single argument and
    that `parseInt()` accepts only a single argument. Then you would be surprised
    by the following result:'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  id: totrans-1829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '`map()` expects a function with the following signature:'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  id: totrans-1831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: 'But `parseInt()` has the following signature:'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  id: totrans-1833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'Thus, `map()` not only fills in `string` (via `element`), but also `radix`
    (via `index`). That means that the values of the preceding array are produced
    as follows:'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  id: totrans-1835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: 'To sum up, be careful with functions and methods whose signature you are not
    sure about. If you use them, it often makes sense to be explicit about what parameters
    are received and what parameters are passed on. That is achieved via a callback:'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  id: totrans-1837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: Named Parameters
  id: totrans-1838
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When calling a function (or method) in a programming language, you must map
    the actual parameters (specified by the caller) to the formal parameters (of a
    function definition). There are two common ways to do so:'
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: '*Positional parameters* are mapped by position. The first actual parameter
    is mapped to the first formal parameter, the second actual to the second formal,
    and so on.'
  id: totrans-1840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Named parameters* use *names* (labels) to perform the mapping. Names are associated
    with formal parameters in a function definition and label actual parameters in
    a function call. It does not matter in which order named parameters appear, as
    long as they are correctly labeled.'
  id: totrans-1841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Named parameters have two main benefits: they provide descriptions for arguments
    in function calls and they work well for optional parameters. I’ll first explain
    the benefits and then show you how to simulate named parameters in JavaScript
    via object literals.'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: Named Parameters as Descriptions
  id: totrans-1843
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As soon as a function has more than one parameter, you might get confused about
    what each parameter is used for. For example, let’s say you have a function, `selectEntries()`,
    that returns entries from a database. Given the following function call:'
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  id: totrans-1845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: 'what do these two numbers mean? Python supports named parameters, and they
    make it easy to figure out what is going on:'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  id: totrans-1847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: Optional Named Parameters
  id: totrans-1848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Optional positional parameters work well only if they are omitted at the end.
    Anywhere else, you have to insert placeholders such as `null` so that the remaining
    parameters have correct positions. With optional named parameters, that is not
    an issue. You can easily omit any of them. Here are some examples:'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  id: totrans-1850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: Simulating Named Parameters in JavaScript
  id: totrans-1851
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript does not have native support for named parameters like Python and
    many other languages. But there is a reasonably elegant simulation: name parameters
    via an object literal, passed as a single actual parameter. When you use this
    technique, an invocation of `selectEntries()` looks like:'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  id: totrans-1853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: 'The function receives an object with the properties `start`, `end`, and `step`.
    You can omit any of them:'
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  id: totrans-1855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: 'You could implement `selectEntries()` as follows:'
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  id: totrans-1857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: 'You can also combine positional parameters with named parameters. It is customary
    for the latter to come last:'
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  id: totrans-1859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: Note
  id: totrans-1860
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript, the pattern for named parameters shown here is sometimes called
    *options* or *option object* (e.g., by the jQuery documentation).
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 16. Variables: Scopes, Environments, and Closures'
  id: totrans-1862
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter first explains how to use variables and then goes into detail on
    how they work (environments, closures, etc.).
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Variable
  id: totrans-1864
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, you declare a variable via a `var` statement before you use
    it:'
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  id: totrans-1866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: 'You can also combine a declaration with an assignment, to immediately initialize
    a variable:'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  id: totrans-1868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: 'The value of an uninitialized variable is `undefined`:'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  id: totrans-1870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: 'Background: Static Versus Dynamic'
  id: totrans-1871
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two angles from which you can examine the workings of a program:'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
- en: Statically (or lexically)
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: 'You examine the program as it exists in source code, without running it. Given
    the following code, we can make the static assertion that function `g` is nested
    inside function `f`:'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  id: totrans-1875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: The adjective *lexical* is used synonymously with *static*, because both pertain
    to the *lexicon* (the words, the source) of the program.
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: 'You examine what happens while executing the program (“at runtime”). Given
    the following code:'
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  id: totrans-1879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: when we call `f()`, it calls `g()`. During runtime, `g` being called by `f`
    represents a dynamic relationship.
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
- en: 'Background: The Scope of a Variable'
  id: totrans-1881
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the rest of this chapter, you should understand the following concepts:'
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
- en: The scope of a variable
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
- en: 'The scope of a variable are the locations where it is accessible. For example:'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  id: totrans-1885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: Here, the *direct scope* of `x` is the function `foo()`.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
- en: Lexical scoping
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
- en: Variables in JavaScript are *lexically scoped*, so the static structure of a
    program determines the scope of a variable (it is not influenced by, say, where
    a function is called from).
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
- en: Nested scopes
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
- en: 'If scopes are nested within the direct scope of a variable, then the variable
    is accessible in all of those scopes:'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  id: totrans-1891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: The direct scope of `arg` is `foo()`, but it is also accessible in the nested
    scope `bar()`. With regard to nesting, `foo()` is the *outer scope* and `bar()`
    is the *inner scope*.
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
- en: Shadowing
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
- en: 'If a scope declares a variable that has the same name as one in a surrounding
    scope, access to the outer variable is blocked in the inner scope and all scopes
    nested inside it. Changes to the inner variable do not affect the outer variable,
    which is accessible again after the inner scope is left:'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  id: totrans-1895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: Inside the function `f()`, the global `x` is shadowed by a local `x`.
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
- en: Variables Are Function-Scoped
  id: totrans-1897
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most mainstream languages are *block-scoped*: variables “live inside” the innermost
    surrounding code block. Here is an example from Java:'
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  id: totrans-1899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: In the preceding code, the variable `foo` is accessible only inside the block
    that directly surrounds it. If we try to access it after the end of the block,
    we get a compilation error.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, JavaScript’s variables are *function-scoped*: only functions introduce
    new scopes; blocks are ignored when it comes to scoping. For example:'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  id: totrans-1902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: Put another way, `foo` is accessible within all of `main()`, not just inside
    the block.
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
- en: Variable Declarations Are Hoisted
  id: totrans-1904
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript *hoists* all variable declarations, it moves them to the beginning
    of their direct scopes. This makes it clear what happens if a variable is accessed
    before it has been declared:'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  id: totrans-1906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: 'We can see that the variable `bar` already exists in the first line of `f()`,
    but it does not have a value yet; that is, the declaration has been hoisted, but
    not the assignment. JavaScript executes `f()` as if its code were:'
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  id: totrans-1908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: 'If you declare a variable that has already been declared, nothing happens (the
    variable’s value is unchanged):'
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  id: totrans-1910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: Each function declaration is also hoisted, but in a slightly different manner.
    The complete function is hoisted, not just the creation of the variable in which
    it is stored (see [Hoisting](ch15.html#function_hoisting "Hoisting")).
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
- en: 'Best practice: be aware of hoisting, but don’t be scared of it'
  id: totrans-1912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some JavaScript style guides recommend that you only put variable declarations
    at the beginning of a function, in order to avoid being tricked by hoisting. If
    your function is relatively small (which it should be anyway), then you can afford
    to relax that rule a bit and declare variables close to where they are used (e.g.,
    inside a `for` loop). That better encapsulates pieces of code. Obviously, you
    should be aware that that encapsulation is only conceptual, because function-wide
    hoisting still happens.
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: Assigning to an Undeclared Variable Makes It Global'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
- en: 'In sloppy mode, assigning to a variable that hasn’t been declared via `var`
    creates a global variable:'
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  id: totrans-1916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: 'Thankfully, strict mode throws an exception when that happens:'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  id: totrans-1918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: Introducing a New Scope via an IIFE
  id: totrans-1919
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You typically introduce a new scope to restrict the lifetime of a variable.
    One example where you may want to do so is the “then” part of an `if` statement:
    it is executed only if the condition holds; and if it exclusively uses helper
    variables, we don’t want them to “leak out” into the surrounding scope:'
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  id: totrans-1921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: 'If you want to introduce a new scope for the `then` block, you can define a
    function and immediately invoke it. This is a workaround, a simulation of block
    scoping:'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  id: totrans-1923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: 'This is a common pattern in JavaScript. Ben Alman suggested it be called [*immediately
    invoked function expression*](http://bit.ly/i-ife) (IIFE, pronounced “iffy”).
    In general, an IIFE looks like this:'
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  id: totrans-1925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: 'Here are some things to note about an IIFE:'
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
- en: It is immediately invoked
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses following the closing brace of the function immediately invoke
    it. That means its body is executed right away.
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
- en: It must be an expression
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
- en: If a statement starts with the keyword `function`, the parser expects it to
    be a function declaration (see [Expressions Versus Statements](ch07.html#expr_vs_stmt
    "Expressions Versus Statements")). But a function declaration cannot be immediately
    invoked. Thus, we tell the parser that the keyword `function` is the beginning
    of a function expression by starting the statement with an open parenthesis. Inside
    parentheses, there can only be expressions.
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
- en: The trailing semicolon is required
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
- en: 'If you forget it between two IIFEs, then your code won’t work anymore:'
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  id: totrans-1933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: The preceding code is interpreted as a function call—the first IIFE (including
    the parentheses) is the function to be called, and the second IIFE is the parameter.
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1935
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An IIFE incurs costs (both cognitively and performance-wise), so it rarely makes
    sense to use it inside an `if` statement. The preceding example was chosen for
    didactic reasons.
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
- en: 'IIFE Variation: Prefix Operators'
  id: totrans-1937
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also enforce the expression context via prefix operators. For example,
    you can do so via the logical Not operator:'
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  id: totrans-1939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: 'or via the `void` operator (see [The void Operator](ch09.html#void_operator
    "The void Operator")):'
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  id: totrans-1941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: The advantage of using prefix operators is that forgetting the terminating semicolon
    does not cause trouble.
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
- en: 'IIFE Variation: Already Inside Expression Context'
  id: totrans-1943
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that enforcing the expression context for an IIFE is not necessary, if
    you are already in the expression context. Then you need no parentheses or prefix
    operators. For example:'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  id: totrans-1945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: In the preceding example, there are two different variables that have the name
    `File`. On one hand, there is the function that is only directly accessible inside
    the IIFE. On the other hand, there is the variable that is declared in the first
    line. It is assigned the value that is returned in the IIFE.
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
- en: 'IIFE Variation: An IIFE with Parameters'
  id: totrans-1947
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use parameters to define variables for the inside of the IIFE:'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  id: totrans-1949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: 'This is similar to:'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  id: totrans-1951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: IIFE Applications
  id: totrans-1952
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An IIFE enables you to attach private data to a function. Then you don’t have
    to declare a global variable and can tightly package the function with its state.
    You avoid polluting the global namespace:'
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  id: totrans-1954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: 'Other applications of IIFEs are mentioned elsewhere in this book:'
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoiding global variables; hiding variables from global scope (see [Best Practice:
    Avoid Creating Global Variables](ch16.html#avoid_global_variables "Best Practice:
    Avoid Creating Global Variables"))'
  id: totrans-1956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating fresh environments; avoiding sharing (see [Pitfall: Inadvertently
    Sharing an Environment](ch16.html#inadvertently_sharing_environments "Pitfall:
    Inadvertently Sharing an Environment"))'
  id: totrans-1957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping global data private to all of a constructor (see [Keeping global data
    private to all of a constructor](ch17_split_001.html#private_data_complete_constructor
    "Keeping global data private to all of a constructor"))
  id: totrans-1958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching global data to a singleton object (see [Attaching private global data
    to a singleton object](ch17_split_001.html#private_data_singleton "Attaching private
    global data to a singleton object"))
  id: totrans-1959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching global data to a method (see [Attaching global data to a method](ch17_split_001.html#private_data_method
    "Attaching global data to a method"))
  id: totrans-1960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global Variables
  id: totrans-1961
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scope containing all of a program is called *global scope* or *program
    scope*. This is the scope you are in when entering a script (be it a `<script>`
    tag in a web page or be it a *.js* file). Inside the global scope, you can create
    a nested scope by defining a function. Inside such a function, you can again nest
    scopes. Each scope has access to its own variables and to the variables in the
    scopes that surround it. As the global scope surrounds all other scopes, its variables
    can be accessed everywhere:'
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  id: totrans-1963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: 'Best Practice: Avoid Creating Global Variables'
  id: totrans-1964
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Global variables have two disadvantages. First, pieces of software that rely
    on global variables are subject to side effects; they are less robust, behave
    less predictably, and are less reusable.
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, all of the JavaScript on a web page shares the same global variables:
    your code, built-ins, analytics code, social media buttons, and so on. That means
    that name clashes can become a problem. That is why it is best to hide as many
    variables from the global scope as possible. For example, don’t do this:'
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  id: totrans-1967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: 'The variable `tmp` becomes global, because its declaration is executed in global
    scope. But it is only used locally. Hence, we can use an IIFE (see [Introducing
    a New Scope via an IIFE](ch16.html#iife "Introducing a New Scope via an IIFE"))
    to hide it inside a nested scope:'
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  id: totrans-1969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: Module Systems Lead to Fewer Globals
  id: totrans-1970
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thankfully, module systems (see [Module Systems](ch31.html#module_systems "Module
    Systems")) mostly eliminate the problem of global variables, because modules don’t
    interface via the global scope and because each module has its own scope for module-global
    variables.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
- en: The Global Object
  id: totrans-1972
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ECMAScript specification uses the internal data structure *environment*
    to store variables (see [Environments: Managing Variables](ch16.html#environments
    "Environments: Managing Variables")). The language has the somewhat unusual feature
    of making the environment for global variables accessible via an object, the so-called
    *global object*. The global object can be used to create, read, and change global
    variables. In global scope, `this` points to it:'
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  id: totrans-1974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: 'Note that the global object has prototypes. If you want to list all of its
    (own and inherited) properties, you need a function such as `getAllPropertyNames()`
    from [Listing All Property Keys](ch17_split_000.html#getAllPropertyNames "Listing
    All Property Keys"):'
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  id: totrans-1976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: JavaScript creator Brendan Eich considers the global object one of his [“biggest
    regrets”](http://mzl.la/1oOeCif). It affects performance negatively, makes the
    implementation of variable scoping more complicated, and leads to less modular
    code.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Platform Considerations
  id: totrans-1978
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Browsers and Node.js have global variables for referring to the global object.
    Unfortunately, they are different:'
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
- en: Browsers include `window`, which is standardized as part of the Document Object
    Model (DOM), not as part of ECMAScript 5\. There is one global object per frame
    or window.
  id: totrans-1980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js contains `global`, which is a Node.js-specific variable. Each module
    has its own scope in which `this` points to an object with that scopes variables.
    Accordingly, `this` and `global` are different inside modules.
  id: totrans-1981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On both platforms, `this` refers to the global object, but only when you are
    in global scope. That is almost never the case on Node.js. If you want to access
    the global object in a cross-platform manner, you can use a pattern such as the
    following:'
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  id: totrans-1983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: From now on, I use `window` to refer to the global object, but in cross-platform
    code, you should use the preceding pattern and `glob` instead.
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases for window
  id: totrans-1985
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section describes use cases for accessing global variables via `window`.
    But the general rule is: avoid doing that as much as you can.'
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
- en: 'Use case: marking global variables'
  id: totrans-1987
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The prefix `window` is a visual clue that code is referring to a global variable
    and not to a local one:'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  id: totrans-1989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: 'However, this makes your code brittle. It ceases to work as soon as you move
    `foo` from global scope to another surrounding scope:'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  id: totrans-1991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: 'Thus, it is better to refer to `foo` as a variable, not as a property of `window`.
    If you want to make it obvious that `foo` is a global or global-like variable,
    you can add a name prefix such as `g_`:'
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  id: totrans-1993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: 'Use case: built-ins'
  id: totrans-1994
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I prefer not to refer to built-in global variables via `window`. They are well-known
    names, so you gain little from an indicator that they are global. And the prefixed
    `window` adds clutter:'
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  id: totrans-1996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: 'Use case: style checkers'
  id: totrans-1997
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you are working with a style checking tool such as JSLint and JSHint, using
    `window` means that you don’t get an error when referring to a global variable
    that is not declared in the current file. However, both tools provide ways to
    tell them about such variables and prevent such errors (search for “global variable”
    in their documentation).
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
- en: 'Use case: checking whether a global variable exists'
  id: totrans-1999
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s not a frequent use case, but shims and polyfills especially (see [Shims
    Versus Polyfills](ch30.html#shim_vs_polyfill "Shims Versus Polyfills")) need to
    check whether a global variable `someVariable` exists. In that case, `window`
    helps:'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  id: totrans-2001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: 'This is a safe way of performing this check. The following statement throws
    an exception if `someVariable` has not been declared:'
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  id: totrans-2003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: 'There are two additional ways in which you can check via `window`; they are
    roughly equivalent, but a little more explicit:'
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  id: totrans-2005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: 'The general way of checking whether a variable exists (and has a value) is
    via `typeof` (see [typeof: Categorizing Primitives](ch09.html#typeof "typeof:
    Categorizing Primitives")):'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  id: totrans-2007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: 'Use case: creating things in global scope'
  id: totrans-2008
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`window` lets you add things to the global scope (even if you are in a nested
    scope), and it lets you do so conditionally:'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  id: totrans-2010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: It is normally best to add things to the global scope via `var`, while you are
    in the global scope. However, `window` provides a clean way of making additions
    conditionally.
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
- en: 'Environments: Managing Variables'
  id: totrans-2012
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tip
  id: totrans-2013
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Environments are an advanced topic. They are a detail of JavaScript’s internals.
    Read this section if you want to get a deeper understanding of how variables work.
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
- en: Variables come into existence when program execution enters their scope. Then
    they need storage space. The data structure that provides that storage space is
    called an *environment* in JavaScript. It maps variable names to values. Its structure
    is very similar to that of JavaScript objects. Environments sometimes live on
    after you leave their scope. Therefore, they are stored on a heap, not on a stack.
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are passed on in two ways. There are two dimensions to them, if you
    will:'
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic dimension: invoking functions'
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time a function is invoked, it needs new storage for its parameters and
    variables. After it is finished, that storage can usually be reclaimed. As an
    example, take the following implementation of the faculty function. It calls itself
    recursively several times and each time, it needs fresh storage for `n`:'
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  id: totrans-2019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: 'Lexical (static) dimension: staying connected to your surrounding scopes'
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter how often a function is called, it always needs access to both its
    own (fresh) local variables and the variables of the surrounding scopes. For example,
    the following function, `doNTimes`, has a helper function, `doNTimesRec`, inside
    it. When `doNTimesRec` calls itself several times, a new environment is created
    each time. However, `doNTimesRec` also stays connected to the single environment
    of `doNTimes` during those calls (similar to all functions sharing a single global
    environment). `doNTimesRec` needs that connection to access `action` in line (1):'
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  id: totrans-2022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: 'These two dimensions are handled as follows:'
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic dimension: stack of execution contexts'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
- en: Each time a function is invoked, a new *environment* is created to map identifiers
    (of parameters and variables) to values. To handle recursion, *execution contexts*—references
    to environments—are managed in a stack. That stack mirrors the call stack.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
- en: 'Lexical dimension: chain of environments'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
- en: To support this dimension, a function records the scope it was created in via
    the internal property `[[Scope]]`. When a function is called, an environment is
    created for the new scope that is entered. That environment has a field called
    `outer` that points to the outer scope’s environment and is set up via `[[Scope]]`.
    Therefore, there is always a chain of environments, starting with the currently
    active environment, continuing with its outer environment, and so on. Every chain
    ends with the global environment (the scope of all initially invoked functions).
    The field `outer` of the global environment is `null`.
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
- en: To resolve an identifier, the complete environment chain is traversed, starting
    with the active environment.
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example:'
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  id: totrans-2030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '![The dynamic dimension of variables is handled via a stack of execution contexts,
    and the static dimension is handled by chaining environments. The active execution
    contexts, environments, and functions are highlighted. Step 1 shows those data
    structures before the function call myFunction(abc). Step 2 shows them during
    the function call.](images/spjs_2001.png)Figure 16-1. The dynamic dimension of
    variables is handled via a stack of execution contexts, and the static dimension
    is handled by chaining environments. The active execution contexts, environments,
    and functions are highlighted. Step 1 shows those data structures before the function
    call myFunction(*abc*). Step 2 shows them during the function call.'
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-1](ch16.html#figenv_intro "Figure 16-1. The dynamic dimension of
    variables is handled via a stack of execution contexts, and the static dimension
    is handled by chaining environments. The active execution contexts, environments,
    and functions are highlighted. Step 1 shows those data structures before the function
    call myFunction(abc). Step 2 shows them during the function call.") illustrates
    what happens when the preceding code is executed:'
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
- en: '`myFunction` and `myFloat` have been stored in the global environment (#0).
    Note that the `function` object referred to by `myFunction` points to its scope
    (the global scope) via the internal property `[[Scope]]`.'
  id: totrans-2033
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the execution of `myFunction('abc')`, a new environment (#1) is created
    that holds the parameter and the local variable. It refers to its outer environment
    via `outer` (which is initialized from `myFunction.[[Scope]]`). Thanks to the
    outer environment, `myFunction` can access `myFloat`.
  id: totrans-2034
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Closures: Functions Stay Connected to Their Birth Scopes'
  id: totrans-2035
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a function leaves the scope in which it was created, it stays connected
    to the variables of that scope (and of the surrounding scopes). For example:'
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  id: totrans-2037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: 'The function returned by `createInc()` does not lose its connection to `startValue`—the
    variable provides the function with state that persists across function calls:'
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  id: totrans-2039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: A *closure* is a function plus the connection to the scope in which the function
    was created. The name stems from the fact that a closure “closes over” the free
    variables of a function. A variable is free if it is not declared within the function—that
    is, if it comes “from outside.”
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
- en: Handling Closures via Environments
  id: totrans-2041
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tip
  id: totrans-2042
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is an advanced section that goes deeper into how closures work. You should
    be familiar with environments (review [Environments: Managing Variables](ch16.html#environments
    "Environments: Managing Variables")).'
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
- en: 'A closure is an example of an environment surviving after execution has left
    its scope. To illustrate how closures work, let’s examine the previous interaction
    with `createInc()` and split it up into four steps (during each step, the active
    execution context and its environment are highlighted; if a function is active,
    it is highlighted, too):'
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
- en: This step takes place before the interaction, and after the evaluation of the
    function declaration of `createInc`. An entry for `createInc` has been added to
    the global environment (#0) and points to a function object.
  id: totrans-2045
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image with no caption](images/spjs_20in01.png)'
  id: totrans-2046
  prefs: []
  type: TYPE_IMG
- en: This step occurs during the execution of the function call `createInc(5)`. A
    fresh environment (#1) for `createInc` is created and pushed onto the stack. Its
    outer environment is the global environment (the same as `createInc.[[Scope]]`).
    The environment holds the parameter `startValue`.
  id: totrans-2047
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image with no caption](images/spjs_20in02.png)'
  id: totrans-2048
  prefs: []
  type: TYPE_IMG
- en: This step happens after the assignment to `inc`. After we returned from `createInc`,
    the execution context pointing to its environment was removed from the stack,
    but the environment still exists on the heap, because `inc.[[Scope]]` refers to
    it. `inc` is a closure (function plus birth environment).
  id: totrans-2049
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image with no caption](images/spjs_20in03.png)'
  id: totrans-2050
  prefs: []
  type: TYPE_IMG
- en: This step takes place during the execution of `inc(1)`. A new environment (#1)
    has been created and an execution context pointing to it has been pushed onto
    the stack. Its outer environment is the `[[Scope]]` of `inc`. The outer environment
    gives `inc` access to `startValue`.
  id: totrans-2051
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image with no caption](images/spjs_20in04.png)'
  id: totrans-2052
  prefs: []
  type: TYPE_IMG
- en: This step happens after the execution of `inc(1)`. No reference (execution context,
    `outer` field, or `[[Scope]]`) points to `inc`’s environment, anymore. It is therefore
    not needed and can be removed from the heap.
  id: totrans-2053
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image with no caption](images/spjs_20in03.png)'
  id: totrans-2054
  prefs: []
  type: TYPE_IMG
- en: 'Pitfall: Inadvertently Sharing an Environment'
  id: totrans-2055
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes the behavior of functions you create is influenced by a variable
    in the current scope. In JavaScript, that can be problematic, because each function
    should work with the value that the variable had when the function was created.
    However, due to functions being closures, the function will always work with the
    *current* value of the variable. In `for` loops, that can prevent things from
    working properly. An example will make things clearer:'
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  id: totrans-2057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '`f` returns an array with three functions in it. All of these functions can
    still access the environment of `f` and thus `i`. In fact, they share the same
    environment. Alas, after the loop is finished, `i` has the value 3 in that environment.
    Therefore, all functions return `3`.'
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not what we want. To fix things, we need to make a snapshot of the
    index `i` before creating a function that uses it. In other words, we want to
    package each function with the value that `i` had at the time of the function’s
    creation. We therefore take the following steps:'
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
- en: Create a new environment for each function in the returned array.
  id: totrans-2060
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store (a copy of) the current value of *i* in that environment.
  id: totrans-2061
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Only functions create environments, so we use an IIFE (see [Introducing a New
    Scope via an IIFE](ch16.html#iife "Introducing a New Scope via an IIFE")) to accomplish
    step 1:'
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  id: totrans-2063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: Note that the example has real-world relevance, because similar scenarios arise
    when you add event handlers to DOM elements via loops.
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17. Objects and Inheritance
  id: totrans-2065
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several layers to object-oriented programming (OOP) in JavaScript:'
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
- en: 'Layer 1: Object-orientation with single objects (covered in [Layer 1: Single
    Objects](ch17_split_000.html#single_objects "Layer 1: Single Objects"))'
  id: totrans-2067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Layer 2: Prototype chains of objects (described in [Layer 2: The Prototype
    Relationship Between Objects](ch17_split_000.html#prototype_relationship "Layer
    2: The Prototype Relationship Between Objects"))'
  id: totrans-2068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Layer 3: Constructors as factories for instances, similar to classes in other
    languages (discussed in [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances"))'
  id: totrans-2069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Layer 4: Subclassing, creating new constructors by inheriting from existing
    ones (covered in [Layer 4: Inheritance Between Constructors](ch17_split_001.html#constructor_inheritance
    "Layer 4: Inheritance Between Constructors"))'
  id: totrans-2070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each new layer only depends on prior ones, enabling you to learn JavaScript
    OOP incrementally. Layers 1 and 2 form a simple core that you can refer back to
    whenever you are getting confused by the more complicated layers 3 and 4.
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
- en: 'Layer 1: Single Objects'
  id: totrans-2072
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Roughly, all objects in JavaScript are maps (dictionaries) from strings to values.
    A (key, value) entry in an object is called a *property*. The key of a property
    is always a text string. The value of a property can be any JavaScript value,
    including a function. *Methods* are properties whose values are functions.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
- en: Kinds of Properties
  id: totrans-2074
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three kinds of properties:'
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
- en: Properties (or named data properties)
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
- en: Normal properties in an object—that is, mappings from string keys to values.
    Named data properties include methods. This is by far the most common kind of
    property.
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
- en: Accessors (or named accessor properties)
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
- en: Special methods whose invocations look like reading or writing properties. Normal
    properties are storage locations for property values; accessors allow you to compute
    the values of properties. They are virtual properties, if you will. See [Accessors
    (Getters and Setters)](ch17_split_000.html#getters_setters "Accessors (Getters
    and Setters)") for details.
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
- en: Internal properties
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
- en: Exist only in the ECMAScript language specification. They are not directly accessible
    from JavaScript, but there might be indirect ways of accessing them. The specification
    writes the keys of internal properties in brackets. For example, `[[Prototype]]`
    holds the prototype of an object and is readable via `Object.getPrototypeOf()`.
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
- en: Object Literals
  id: totrans-2082
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript’s *object literals* allow you to directly create *plain objects*
    (direct instances of `Object`). The following code uses an object literal to assign
    an object to the variable `jane`. The object has the two properties: `name` and
    `describe`. `describe` is a method:'
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  id: totrans-2084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: Use `this` in methods to refer to the current object (also called the *receiver*
    of a method invocation).
  id: totrans-2085
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ECMAScript 5 allows a trailing comma (after the last property) in an object
    literal. Alas, not all older browsers support it. A trailing comma is useful,
    because you can rearrange properties without having to worry which property is
    last.
  id: totrans-2086
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may get the impression that objects are *only* maps from strings to values.
    But they are more than that: they are real general-purpose objects. For example,
    you can use inheritance between objects (see [Layer 2: The Prototype Relationship
    Between Objects](ch17_split_000.html#prototype_relationship "Layer 2: The Prototype
    Relationship Between Objects")), and you can protect objects from being changed.
    The ability to directly create objects is one of JavaScript’s standout features:
    you can start with concrete objects (no classes needed!) and introduce abstractions
    later. For example, *constructors*, which are factories for objects (as discussed
    in [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances")), are roughly similar to classes
    in other languages.'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
- en: 'Dot Operator (.): Accessing Properties via Fixed Keys'
  id: totrans-2088
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dot operator provides a compact syntax for accessing properties. The property
    keys must be identifiers (consult [Legal Identifiers](ch07.html#identifiers "Legal
    Identifiers")). If you want to read or write properties with arbitrary names,
    you need to use the bracket operator (see [Bracket Operator ([]): Accessing Properties
    via Computed Keys](ch17_split_000.html#bracket_operator "Bracket Operator ([]):
    Accessing Properties via Computed Keys")).'
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples in this section work with the following object:'
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  id: totrans-2091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: Getting properties
  id: totrans-2092
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The dot operator lets you “get” a property (read its value). Here are some
    examples:'
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  id: totrans-2094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: 'Getting a property that doesn’t exist returns `undefined`:'
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  id: totrans-2096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: Calling methods
  id: totrans-2097
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The dot operator is also used to call methods:'
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  id: totrans-2099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: Setting properties
  id: totrans-2100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use the assignment operator (`=`) to set the value of a property referred
    to via the dot notation. For example:'
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  id: totrans-2102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: If a property doesn’t exist yet, setting it automatically creates it. If a property
    already exists, setting it changes its value.
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
- en: Deleting properties
  id: totrans-2104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `delete` operator lets you completely remove a property (the whole key-value
    pair) from an object. For example:'
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  id: totrans-2106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: 'If you merely set a property to `undefined`, the property still exists and
    the object still contains its key:'
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  id: totrans-2108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: 'If you delete the property, its key is gone, too:'
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  id: totrans-2110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '`delete` affects only the direct (“own,” noninherited) properties of an object.
    Its prototypes are not touched (see [Deleting an inherited property](ch17_split_000.html#delete_inherited_property
    "Deleting an inherited property")).'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-2112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the `delete` operator sparingly. Most modern JavaScript engines optimize
    the performance of instances created by constructors if their “shape” doesn’t
    change (roughly: no properties are removed or added). Deleting a property prevents
    that optimization.'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
- en: The return value of delete
  id: totrans-2114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`delete` returns `false` if the property is an own property, but cannot be
    deleted. It returns `true` in all other cases. Following are some examples.'
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
- en: 'As a preparation, we create one property that can be deleted and another one
    that can’t be deleted ([Getting and Defining Properties via Descriptors](ch17_split_000.html#functions_for_property_descriptors
    "Getting and Defining Properties via Descriptors") explains `Object.defineProperty()`):'
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  id: totrans-2117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '`delete` returns `false` for own properties that can’t be deleted:'
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  id: totrans-2119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '`delete` returns `true` in all other cases:'
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  id: totrans-2121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '`delete` returns `true` even if it doesn’t change anything (inherited properties
    are never removed):'
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  id: totrans-2123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: Unusual Property Keys
  id: totrans-2124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While you can’t use reserved words (such as `var` and `function`) as variable
    names, you can use them as property keys:'
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  id: totrans-2126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: 'Numbers can be used as property keys in object literals, but they are interpreted
    as strings. The dot operator can only access properties whose keys are identifiers.
    Therefore, you need the bracket operator (shown in the following example) to access
    properties whose keys are numbers:'
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  id: totrans-2128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: 'Object literals also allow you to use arbitrary strings (that are neither identifiers
    nor numbers) as property keys, but you must quote them. Again, you need the bracket
    operator to access the property values:'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  id: totrans-2130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: 'Bracket Operator ([]): Accessing Properties via Computed Keys'
  id: totrans-2131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the dot operator works with fixed property keys, the bracket operator
    allows you to refer to a property via an expression.
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
- en: Getting properties via the bracket operator
  id: totrans-2133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The bracket operator lets you compute the key of a property, via an expression:'
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  id: totrans-2135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: 'That also allows you to access properties whose keys are not identifiers:'
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  id: totrans-2137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: 'Note that the bracket operator coerces its interior to string. For example:'
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  id: totrans-2139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: Calling methods via the bracket operator
  id: totrans-2140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Calling methods works as you would expect:'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  id: totrans-2142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: Setting properties via the bracket operator
  id: totrans-2143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Setting properties works analogously to the dot operator:'
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  id: totrans-2145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: Deleting properties via the bracket operator
  id: totrans-2146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Deleting properties also works similarly to the dot operator:'
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  id: totrans-2148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: Converting Any Value to an Object
  id: totrans-2149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s not a frequent use case, but sometimes you need to convert an arbitrary
    value to an object. `Object()`, used as a function (not as a constructor), provides
    that service. It produces the following results:'
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Result |'
  id: totrans-2151
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2152
  prefs: []
  type: TYPE_TB
- en: '| (Called with no parameters) | `{}` |'
  id: totrans-2153
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `{}` |'
  id: totrans-2154
  prefs: []
  type: TYPE_TB
- en: '| `null` | `{}` |'
  id: totrans-2155
  prefs: []
  type: TYPE_TB
- en: '| A boolean `bool` | `new Boolean(bool)` |'
  id: totrans-2156
  prefs: []
  type: TYPE_TB
- en: '| A number `num` | `new Number(num)` |'
  id: totrans-2157
  prefs: []
  type: TYPE_TB
- en: '| A string `str` | `new String(str)` |'
  id: totrans-2158
  prefs: []
  type: TYPE_TB
- en: '| An object `obj` | `obj` (unchanged, nothing to convert) |'
  id: totrans-2159
  prefs: []
  type: TYPE_TB
- en: 'Here are some examples:'
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  id: totrans-2161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: 'Tthe following function checks whether `value` is an object:'
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  id: totrans-2163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: 'Note that the preceding function creates an object if `value` isn’t an object.
    You can implement the same function without doing that, via `typeof` (see [Pitfall:
    typeof null](ch09.html#isobject_typeof "Pitfall: typeof null")).'
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also invoke `Object` as a constructor, which produces the same results
    as calling it as a function:'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  id: totrans-2166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: Tip
  id: totrans-2167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Avoid the constructor; an empty object literal is almost always a better choice:'
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  id: totrans-2169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: this as an Implicit Parameter of Functions and Methods
  id: totrans-2170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you call a function, `this` is always an (implicit) parameter:'
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
- en: Normal functions in sloppy mode
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though normal functions have no use for `this`, it still exists as a special
    variable whose value is always the global object (`window` in browsers; see [The
    Global Object](ch16.html#global_object "The Global Object")):'
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  id: totrans-2174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: Normal functions in strict mode
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
- en: '`this` is always `undefined`:'
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  id: totrans-2177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: Methods
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
- en: '`this` refers to the object on which the method has been invoked:'
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  id: totrans-2180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: In the case of methods, the value of `this` is called the *receiver* of the
    method call.
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling Functions While Setting this: call(), apply(), and bind()'
  id: totrans-2182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember that functions are also objects. Thus, each function has methods of
    its own. Three of them are introduced in this section and help with calling functions.
    These three methods are used in the following sections to work around some of
    the pitfalls of calling functions. The upcoming examples all refer to the following
    object, `jane`:'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  id: totrans-2184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: Function.prototype.call(thisValue, arg1?, arg2?, ...)
  id: totrans-2185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first parameter is the value that `this` will have inside the invoked function;
    the remaining parameters are handed over as arguments to the invoked function.
    The following three invocations are equivalent:'
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  id: totrans-2187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: For the second invocation, you need to repeat `jane`, because `call()` doesn’t
    know how you got the function that it is invoked on.
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
- en: Function.prototype.apply(thisValue, argArray)
  id: totrans-2189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first parameter is the value that `this` will have inside the invoked function;
    the second parameter is an array that provides the arguments for the invocation.
    The following three invocations are equivalent:'
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  id: totrans-2191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: For the second invocation, you need to repeat `jane`, because `apply()` doesn’t
    know how you got the function that it is invoked on.
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
- en: '[apply() for Constructors](ch17_split_000.html#apply_constructors "apply()
    for Constructors") explains how to use `apply()` with constructors.'
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
- en: Function.prototype.bind(thisValue, arg1?, ..., argN?)
  id: totrans-2194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method performs *partial function application*—meaning it creates a new
    function that calls the receiver of `bind()` in the following manner: the value
    of `this` is `thisValue` and the arguments start with `arg1` until `argN`, followed
    by the arguments of the new function. In other words, the new function appends
    its arguments to `arg1, ..., argN` when it calls the original function. Let’s
    look at an example:'
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  id: totrans-2196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: 'The array method `slice` is used to convert `arguments` to an array, which
    is necessary for logging it (this operation is explained in [Array-Like Objects
    and Generic Methods](ch17_split_001.html#array-like_objects "Array-Like Objects
    and Generic Methods")). `bound` is a new function. Here’s the interaction:'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  id: totrans-2198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: 'The following three invocations of `sayHelloTo` are all equivalent:'
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  id: totrans-2200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: apply() for Constructors
  id: totrans-2201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s pretend that JavaScript has a triple dot operator (`...`) that turns
    arrays into actual parameters. Such an operator would allow you to use `Math.max()`
    (see [Other Functions](ch21.html#Math_max "Other Functions")) with arrays. In
    that case, the following two expressions would be equivalent:'
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  id: totrans-2203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: 'For functions, you can achieve the effect of the triple dot operator via `apply()`:'
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  id: totrans-2205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: 'The triple dot operator would also make sense for constructors:'
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  id: totrans-2207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: Alas, here `apply()` does not work, because it helps only with function or method
    calls, not with constructor invocations.
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
- en: Manually simulating an apply() for constructors
  id: totrans-2209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can simulate `apply()` in two steps.
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
- en: Step 1
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass the arguments to `Date` via a method call (they are not in an array—yet):'
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  id: totrans-2213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: The preceding code uses `bind()` to create a constructor without parameters
    and invokes it via `new`.
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
- en: Step 2
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `apply()` to hand an array to `bind()`. Because `bind()` is a method call,
    we can use `apply()`:'
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  id: totrans-2217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: 'The preceding array still has one element too many, `null`. We can use `concat()`
    to prepend it:'
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  id: totrans-2219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: A library method
  id: totrans-2220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The preceding manual workaround is inspired by a [library method](http://mzl.la/1oOf7sK)
    published by Mozilla. The following is a slightly edited version of it:'
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  id: totrans-2222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: 'Here is the method in use:'
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  id: totrans-2224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: An alternative approach
  id: totrans-2225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An alternative to the previous approach is to create an uninitialized instance
    via `Object.create()` and then call the constructor (as a function) via `apply()`.
    That means that you are effectively reimplementing the `new` operator (some checks
    are omitted):'
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  id: totrans-2227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: Warning
  id: totrans-2228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code does not work for most built-in constructors, which always
    produce new instances when called as functions. In other words, the step in line
    (1) doesn’t set up `inst` as desired.
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: Losing this When Extracting a Method'
  id: totrans-2230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you extract a method from an object, it becomes a true function again. Its
    connection with the object is severed, and it usually doesn’t work properly anymore.
    Take, for example, the following object, `counter`:'
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  id: totrans-2232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: 'Extracting `inc` and calling it (as a function!) fails:'
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  id: totrans-2234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: 'Here’s the explanation: we have called the value of `counter.inc` as a function.
    Hence, `this` is the global object and we have performed `window.count++`. `window.count`
    does not exist and is `undefined`. Applying the `++` operator to it sets it to
    `NaN`:'
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  id: totrans-2236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: How to get a warning
  id: totrans-2237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If method `inc()` is in strict mode, you get a warning:'
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  id: totrans-2239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: The reason is that when we call the strict mode function `func2`, `this` is
    `undefined`, resulting in an error.
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
- en: How to properly extract a method
  id: totrans-2241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Thanks to `bind()`, we can make sure that `inc` doesn’t lose the connection
    with `counter`:'
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  id: totrans-2243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: Callbacks and extracted methods
  id: totrans-2244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In JavaScript, there are many functions and methods that accept callbacks.
    Examples in browsers are `setTimeout()` and event handling. If we pass in `counter.inc`
    as a callback, it is also invoked as a function, resulting in the same problem
    just described. To illustrate this phenomenon, let’s use a simple callback-invoking
    function:'
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  id: totrans-2246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: 'Executing `counter.count` via `callIt` triggers a warning (due to strict mode):'
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  id: totrans-2248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: 'As before, we fix things via `bind()`:'
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  id: totrans-2250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: Warning
  id: totrans-2251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each call to `bind()` creates a new function. That has consequences when you’re
    registering and unregistering callbacks (e.g., for event handling). You need to
    store the value you registered somewhere and use it for unregistering, too.
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: Functions Inside Methods Shadow this'
  id: totrans-2253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You often nest function definitions in JavaScript, because functions can be
    parameters (e.g., callbacks) and because they can be created in place, via function
    expressions. This poses a problem when a method contains a normal function and
    you want to access the former’s `this` inside the latter, because the method’s
    `this` is shadowed by the normal function’s `this` (which doesn’t even have any
    use for its own `this`). In the following example, the function at (1) tries to
    access the method’s `this` at (2):'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  id: totrans-2255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: 'Obviously, this fails, because the function at (1) has its own `this`, which
    is `undefined` here:'
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  id: totrans-2257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: There are three ways to work around this problem.
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
- en: 'Workaround 1: that = this'
  id: totrans-2259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We assign `this` to a variable that won’t be shadowed inside the nested function:'
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  id: totrans-2261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: 'Here’s the interaction:'
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  id: totrans-2263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: 'Workaround 2: bind()'
  id: totrans-2264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use `bind()` to give the callback a fixed value for `this`—namely, the
    method’s `this` (line (1)):'
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  id: totrans-2266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: 'Workaround 3: a thisValue for forEach()'
  id: totrans-2267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A workaround that is specific to `forEach()` (see [Examination Methods](ch18.html#Array_prototype_forEach
    "Examination Methods")) is to provide a second parameter after the callback that
    becomes the `this` of the callback:'
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  id: totrans-2269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: 'Layer 2: The Prototype Relationship Between Objects'
  id: totrans-2270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prototype relationship between two objects is about inheritance: every
    object can have another object as its prototype. Then the former object inherits
    all of its prototype’s properties. An object specifies its prototype via the internal
    property `[[Prototype]]`. Every object has this property, but it can be `null`.
    The chain of objects connected by the `[[Prototype]]` property is called the *prototype
    chain* ([Figure 17-1](ch17_split_000.html#figoo_proto_chain "Figure 17-1. A prototype
    chain.")).'
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
- en: '![A prototype chain.](images/spjs_2101.png)Figure 17-1. A prototype chain.'
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how prototype-based (or *prototypal*) inheritance works, let’s look
    at an example (with invented syntax for specifying the `[[Prototype]]` property):'
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  id: totrans-2274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: The object `obj` inherits the property `describe` from `proto`. It also has
    a so-called *own* (noninherited, direct) property, `name`.
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  id: totrans-2276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`obj` inherits the property `describe`; you can access it as if the object
    itself had that property:'
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  id: totrans-2278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: 'Whenever you access a property via `obj`, JavaScript starts the search for
    it in that object and continues with its prototype, the prototype’s prototype,
    and so on. That’s why we can access `proto.describe` via `obj.describe`. The prototype
    chain behaves as if it were a single object. That illusion is maintained when
    you call a method: the value of `this` is always the object where the search for
    the method began, not where the method was found. That allows the method to access
    all of the properties of the prototype chain. For example:'
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  id: totrans-2280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: Inside `describe()`, `this` is `obj`, which allows the method to access `obj.name`.
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
- en: Overriding
  id: totrans-2282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a prototype chain, a property in an object *overrides* a property with the
    same key in a “later” object: the former property is found first. It hides the
    latter property, which can’t be accessed anymore. As an example, let’s override
    the method `proto.describe()` in `obj`:'
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  id: totrans-2284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: That is similar to how overriding of methods works in class-based languages.
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
- en: Sharing Data Between Objects via a Prototype
  id: totrans-2286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prototypes are great for sharing data between objects: several objects get
    the same prototype, which holds all shared properties. Let’s look at an example.
    The objects `jane` and `tarzan` both contain the same method, `describe()`. That
    is something that we would like to avoid by using sharing:'
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  id: totrans-2288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: Both objects are persons. Their `name` property is different, but we could have
    them share the method `describe`. We do that by creating a common prototype called
    `PersonProto` and putting `describe` into it ([Figure 17-2](ch17_split_000.html#figoo_person_shared
    "Figure 17-2. The objects jane and tarzan share the prototype PersonProto and
    thus the property describe.")).
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
- en: '![The objects jane and tarzan share the prototype PersonProto and thus the
    property describe.](images/spjs_2102.png)Figure 17-2. The objects jane and tarzan
    share the prototype PersonProto and thus the property describe.'
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates objects `jane` and `tarzan` that share the prototype
    `PersonProto`:'
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  id: totrans-2292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: 'And here is the interaction:'
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  id: totrans-2294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: 'This is a common pattern: the data resides in the first object of a prototype
    chain, while methods reside in later objects. JavaScript’s flavor of prototypal
    inheritance is designed to support this pattern: setting a property affects only
    the first object in a prototype chain, whereas getting a property considers the
    complete chain (see [Setting and Deleting Affects Only Own Properties](ch17_split_000.html#setting_properties_proto_chain
    "Setting and Deleting Affects Only Own Properties")).'
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
- en: Getting and Setting the Prototype
  id: totrans-2296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have pretended that you can access the internal property `[[Prototype]]`
    from JavaScript. But the language does not let you do that. Instead, there are
    functions for reading the prototype and for creating a new object with a given
    prototype.
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new object with a given prototype
  id: totrans-2298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This invocation:'
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  id: totrans-2300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: 'creates an object whose prototype is `proto`. Optionally, properties can be
    added via descriptors (which are explained in [Property Descriptors](ch17_split_000.html#property_descriptors
    "Property Descriptors")). In the following example, object `jane` gets the prototype
    `PersonProto` and a mutable property `name` whose value is `''Jane''` (as specified
    via a property descriptor):'
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  id: totrans-2302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: 'Here is the interaction:'
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  id: totrans-2304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: 'But you frequently just create an empty object and then manually add properties,
    because descriptors are verbose:'
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  id: totrans-2306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: Reading the prototype of an object
  id: totrans-2307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method call:'
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  id: totrans-2309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: 'returns the prototype of `obj`. Continuing the preceding example:'
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  id: totrans-2311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: Checking whether one object a prototype of another one
  id: totrans-2312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This syntax:'
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  id: totrans-2314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: 'checks whether the receiver of the method is a (direct or indirect) prototype
    of `obj`. In other words: are the receiver and `obj` in the same prototype chain,
    and does `obj` come before the receiver? For example:'
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  id: totrans-2316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: Finding the object where a property is defined
  id: totrans-2317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following function iterates over the property chain of an object `obj`.
    It returns the first object that has an own property with the key `propKey`, or
    `null` if there is no such object:'
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  id: totrans-2319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: 'In the preceding code, we called the method `Object.prototype.hasOwnProperty`
    generically (see [Generic Methods: Borrowing Methods from Prototypes](ch17_split_001.html#generic_method
    "Generic Methods: Borrowing Methods from Prototypes")).'
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
- en: The Special Property __proto__
  id: totrans-2321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some JavaScript engines have a special property for getting and setting the
    prototype of an object: `__proto__`. It brings direct access to `[[Prototype]]`
    to the language:'
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  id: totrans-2323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: 'There are several things you need to know about `__proto__`:'
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
- en: '`__proto__` is pronounced “dunder proto,” an abbreviation of “double underscore
    proto.” That pronunciation has been borrowed from the Python programming language
    (as [suggested by Ned Batchelder](http://bit.ly/1fwlzN8) in 2006). Special variables
    with double underscores are quite frequent in Python.'
  id: totrans-2325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__proto__` is not part of the ECMAScript 5 standard. Therefore, you must not
    use it if you want your code to conform to that standard and run reliably across
    current JavaScript engines.'
  id: totrans-2326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, more and more engines are adding support for `__proto__` and it will
    be part of ECMAScript 6.
  id: totrans-2327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following expression checks whether an engine supports `__proto__` as a
    special property:'
  id: totrans-2328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE569]'
  id: totrans-2329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: Setting and Deleting Affects Only Own Properties
  id: totrans-2330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only getting a property considers the complete prototype chain of an object.
    Setting and deleting ignores inheritance and affects only own properties.
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
- en: Setting a property
  id: totrans-2332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Setting a property creates an own property, even if there is an inherited property
    with that key. For example, given the following source code:'
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  id: totrans-2334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '`obj` inherits `foo` from `proto`:'
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  id: totrans-2336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: 'Setting `foo` has the desired result:'
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  id: totrans-2338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: 'However, we have created an own property and not changed `proto.foo`:'
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  id: totrans-2340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: The rationale is that prototype properties are meant to be shared by several
    objects. This approach allows us to nondestructively “change” them—only the current
    object is affected.
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an inherited property
  id: totrans-2342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can only delete own properties. Let’s again set up an object, `obj`, with
    a prototype, `proto`:'
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  id: totrans-2344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: 'Deleting the inherited property `foo` has no effect:'
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  id: totrans-2346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: For more information on the `delete` operator, consult [Deleting properties](ch17_split_000.html#operator_delete
    "Deleting properties").
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
- en: Changing properties anywhere in the prototype chain
  id: totrans-2348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you want to change an inherited property, you first have to find the object
    that owns it (see [Finding the object where a property is defined](ch17_split_000.html#code_getDefiningObject
    "Finding the object where a property is defined")) and then perform the change
    on that object. For example, let’s delete the property `foo` from the previous
    example:'
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  id: totrans-2350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: Iteration and Detection of Properties
  id: totrans-2351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Operations for iterating over and detecting properties are influenced by:'
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance (own properties versus inherited properties)
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
- en: An own property of an object is stored directly in that object. An inherited
    property is stored in one of its prototypes.
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
- en: Enumerability (enumerable properties versus nonenumerable properties)
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
- en: 'The enumerability of a property is an *attribute* (see [Property Attributes
    and Property Descriptors](ch17_split_000.html#property_attributes "Property Attributes
    and Property Descriptors")), a flag that can be `true` or `false`. Enumerability
    rarely matters and can normally be ignored (see [Enumerability: Best Practices](ch17_split_001.html#enumerability_best_practices
    "Enumerability: Best Practices")).'
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
- en: You can list own property keys, list all enumerable property keys, and check
    whether a property exists. The following subsections show how.
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
- en: Listing Own Property Keys
  id: totrans-2358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can either list all own property keys, or only enumerable ones:'
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.getOwnPropertyNames(obj)` returns the keys of all own properties of
    `obj`.'
  id: totrans-2360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.keys(obj)` returns the keys of all enumerable own properties of `obj`.'
  id: totrans-2361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that properties are normally enumerable (see [Enumerability: Best Practices](ch17_split_001.html#enumerability_best_practices
    "Enumerability: Best Practices")), so you can use `Object.keys()`, especially
    for objects that you have created.'
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
- en: Listing All Property Keys
  id: totrans-2363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to list all properties (both own and inherited ones) of an object,
    then you have two options.
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1 is to use the loop:'
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  id: totrans-2366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: to iterate over the keys of all enumerable properties of `object`. See [for-in](ch13.html#for-in
    "for-in") for a more thorough description.
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 2 is to implement a function yourself that iterates over all properties
    (not just enumerable ones). For example:'
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  id: totrans-2369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: Checking Whether a Property Exists
  id: totrans-2370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can check whether an object has a property, or whether a property exists
    directly inside an object:'
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
- en: '`propKey in obj`'
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if `obj` has a property whose key is `propKey`. Inherited properties
    are included in this test.
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.prototype.hasOwnProperty(propKey)`'
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if the receiver (`this`) has an own (noninherited) property whose
    key is `propKey`.
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-2376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Avoid invoking `hasOwnProperty()` directly on an object, as it may be overridden
    (e.g., by an own property whose key is `hasOwnProperty`):'
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  id: totrans-2378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: 'Instead, it is better to call it generically (see [Generic Methods: Borrowing
    Methods from Prototypes](ch17_split_001.html#generic_method "Generic Methods:
    Borrowing Methods from Prototypes")):'
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  id: totrans-2380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: Examples
  id: totrans-2381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following examples are based on these definitions:'
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  id: totrans-2383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '`Object.defineProperties()` is explained in [Getting and Defining Properties
    via Descriptors](ch17_split_000.html#functions_for_property_descriptors "Getting
    and Defining Properties via Descriptors"), but it should be fairly obvious how
    it works: `proto` has the own properties `protoEnumTrue` and `protoEnumFalse`
    and `obj` has the own properties `objEnumTrue` and `objEnumFalse` (and inherits
    all of `proto`’s properties).'
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-2385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that objects (such as `proto` in the preceding example) normally have
    at least the prototype `Object.prototype` (where standard methods such as `toString()`
    and `hasOwnProperty()` are defined):'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  id: totrans-2387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: The effects of enumerability
  id: totrans-2388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Among property-related operations, enumberability only influences the `for-in`
    loop and `Object.keys()` (it also influences `JSON.stringify()`, see [JSON.stringify(value,
    replacer?, space?)](ch22.html#JSON.stringify "JSON.stringify(value, replacer?,
    space?)")).
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for-in` loop iterates over the keys of all enumerable properties, including
    inherited ones (note that none of the nonenumerable properties of `Object.prototype`
    show up):'
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  id: totrans-2391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '`Object.keys()` returns the keys of all own (noninherited) enumerable properties:'
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  id: totrans-2393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: 'If you want the keys of all own properties, you need to use `Object.getOwnPropertyNames()`:'
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  id: totrans-2395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: The effects of inheritance
  id: totrans-2396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Only the `for-in` loop (see the previous example) and the `in` operator consider
    inheritance:'
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  id: totrans-2398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: Computing the number of own properties of an object
  id: totrans-2399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Objects don’t have a method such as `length` or `size`, so you have to use
    the following workaround:'
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  id: totrans-2401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: 'Best Practices: Iterating over Own Properties'
  id: totrans-2402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To iterate over property keys:'
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
- en: 'Combine `for-in` with `hasOwnProperty()`, in the manner described in [for-in](ch13.html#for-in
    "for-in"). This works even on older JavaScript engines. For example:'
  id: totrans-2404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE588]'
  id: totrans-2405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: 'Combine `Object.keys()` or `Object.getOwnPropertyNames()` with `forEach()`
    array iteration:'
  id: totrans-2406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE589]'
  id: totrans-2407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: 'To iterate over property values or over (key, value) pairs:'
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
- en: Iterate over the keys, and use each key to retrieve the corresponding value.
    Other languages make this simpler, but not JavaScript.
  id: totrans-2409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessors (Getters and Setters)
  id: totrans-2410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 5 lets you write methods whose invocations look like you are getting
    or setting a property. That means that a property is virtual and not storage space.
    You could, for example, forbid setting a property and always compute the value
    returned when reading it.
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
- en: Defining Accessors via an Object Literal
  id: totrans-2412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example uses an object literal to define a setter and a getter
    for property `foo`:'
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  id: totrans-2414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: 'Here’s the interaction:'
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  id: totrans-2416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: Defining Accessors via Property Descriptors
  id: totrans-2417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternate way to specify getters and setters is via property descriptors
    (see [Property Descriptors](ch17_split_000.html#property_descriptors "Property
    Descriptors")). The following code defines the same object as the preceding literal:'
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  id: totrans-2419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: Accessors and Inheritance
  id: totrans-2420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Getters and setters are inherited from prototypes:'
  id: totrans-2421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  id: totrans-2422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: Property Attributes and Property Descriptors
  id: totrans-2423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tip
  id: totrans-2424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Property attributes and property descriptors are an advanced topic. You normally
    don’t need to know how they work.
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at the internal structure of properties:'
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
- en: '*Property attributes* are the atomic building blocks of properties.'
  id: totrans-2427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *property descriptor* is a data structure for working programmatically with
    attributes.
  id: totrans-2428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property Attributes
  id: totrans-2429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of a property’s state, both its data and its metadata, is stored in *attributes*.
    They are fields that a property has, much like an object has properties. Attribute
    keys are often written in double brackets. Attributes matter for normal properties
    and for accessors (getters and setters).
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
- en: 'The following attributes are specific to normal properties:'
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
- en: '`[[Value]]` holds the property’s value, its data.'
  id: totrans-2432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[Writable]]` holds a boolean indicating whether the value of a property can
    be changed.'
  id: totrans-2433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following attributes are specific to accessors:'
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
- en: '`[[Get]]` holds the getter, a function that is called when a property is read.
    The function computes the result of the read access.'
  id: totrans-2435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[Set]]` holds the setter, a function that is called when a property is set
    to a value. The function receives that value as a parameter.'
  id: totrans-2436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All properties have the following attributes:'
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
- en: '`[[Enumerable]]` holds a boolean. Making a property nonenumerable hides it
    from some operations (see [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")).'
  id: totrans-2438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[Configurable]]` holds a boolean. If it is `false`, you cannot delete a property,
    change any of its attributes (except `[[Value]]`), or convert it from a data property
    to an accessor property or vice versa. In other words, `[[Configurable]]` controls
    the writability of a property’s metadata. There is one exception to this rule—JavaScript
    allows you to change an unconfigurable property from writable to read-only, for
    [historic reasons](http://bit.ly/1fwlIQI); the property `length` of arrays has
    always been writable and unconfigurable. Without this exception, you wouldn’t
    be able to freeze (see [Freezing](ch17_split_001.html#freezing_objects "Freezing"))
    arrays.'
  id: totrans-2439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default values
  id: totrans-2440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you don’t specify attributes, the following defaults are used:'
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute key | Default value |'
  id: totrans-2442
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2443
  prefs: []
  type: TYPE_TB
- en: '| `[[Value]]` | `undefined` |'
  id: totrans-2444
  prefs: []
  type: TYPE_TB
- en: '| `[[Get]]` | `undefined` |'
  id: totrans-2445
  prefs: []
  type: TYPE_TB
- en: '| `[[Set]]` | `undefined` |'
  id: totrans-2446
  prefs: []
  type: TYPE_TB
- en: '| `[[Writable]]` | `false` |'
  id: totrans-2447
  prefs: []
  type: TYPE_TB
- en: '| `[[Enumerable]]` | `false` |'
  id: totrans-2448
  prefs: []
  type: TYPE_TB
- en: '| `[[Configurable]]` | `false` |'
  id: totrans-2449
  prefs: []
  type: TYPE_TB
- en: These defaults are important when you are creating properties via property descriptors
    (see the following section).
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
- en: Property Descriptors
  id: totrans-2451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A property descriptor is a data structure for working programmatically with
    attributes. It is an object that encodes the attributes of a property. Each of
    a descriptor’s properties corresponds to an attribute. For example, the following
    is the descriptor of a read-only property whose value is 123:'
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  id: totrans-2453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: 'You can achieve the same goal, immutability, via accessors. Then the descriptor
    looks as follows:'
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  id: totrans-2455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: Getting and Defining Properties via Descriptors
  id: totrans-2456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Property descriptors are used for two kinds of operations:'
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
- en: Getting a property
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
- en: All attributes of a property are returned as a descriptor.
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
- en: Defining a property
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining a property means something different depending on whether a property
    already exists:'
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
- en: 'If a property does not exist, create a new property whose attributes are as
    specified by the descriptor. If an attribute has no corresponding property in
    the descriptor, then use the default value. The defaults are dictated by what
    the attribute names mean. They are the opposite of the values that are used when
    creating a property via assignment (then the property is writable, enumerable,
    and configurable). For example:'
  id: totrans-2462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE596]'
  id: totrans-2463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: I usually don’t rely on the defaults and explicitly state all attributes, to
    be completely clear.
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
- en: 'If a property already exists, update the attributes of the property as specified
    by the descriptor. If an attribute has no corresponding property in the descriptor,
    then don’t change it. Here is an example (continued from the previous one):'
  id: totrans-2465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE597]'
  id: totrans-2466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: 'The following operations allow you to get and set a property’s attributes via
    property descriptors:'
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.getOwnPropertyDescriptor(obj, propKey)`'
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the descriptor of the own (noninherited) property of `obj` whose key
    is `propKey`. If there is no such property, `undefined` is returned:'
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  id: totrans-2470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '`Object.defineProperty(obj, propKey, propDesc)`'
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
- en: 'Create or change a property of `obj` whose key is `propKey` and whose attributes
    are specified via `propDesc`. Return the modified object. For example:'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  id: totrans-2473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '`Object.defineProperties(obj, propDescObj)`'
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
- en: 'The batch version of `Object.defineProperty()`. Each property of `propDescObj`
    holds a property descriptor. The keys of the properties and their values tell
    `Object.defineProperties` what properties to create or change on `obj`. For example:'
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  id: totrans-2476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '`Object.create(proto, propDescObj?)`'
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create an object whose prototype is `proto`. Then, if the optional parameter
    `propDescObj` has been specified, add properties to it—in the same manner as `Object.defineProperties`.
    Finally, return the result. For example, the following code snippet produces the
    same result as the previous snippet:'
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  id: totrans-2479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: Copying an Object
  id: totrans-2480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create an identical copy of an object, you need to get two things right:'
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
- en: 'The copy must have the same prototype (see [Layer 2: The Prototype Relationship
    Between Objects](ch17_split_000.html#prototype_relationship "Layer 2: The Prototype
    Relationship Between Objects")) as the original.'
  id: totrans-2482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The copy must have the same properties, with the same attributes as the original.
  id: totrans-2483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following function performs such a copy:'
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  id: totrans-2485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: 'The properties are copied from `orig` to `copy` via this function:'
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  id: totrans-2487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: 'These are the steps involved:'
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
- en: Get an array with the keys of all own properties of `source`.
  id: totrans-2489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over those keys.
  id: totrans-2490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve a property descriptor.
  id: totrans-2491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use that property descriptor to create an own property in `target`.
  id: totrans-2492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this function is very similar to the function [`_.extend()`](http://underscorejs.org/#extend)
    in the Underscore.js library.
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties: Definition Versus Assignment'
  id: totrans-2494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following two operations are very similar:'
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
- en: Defining a property via `defineProperty()` and `defineProperties()` (see [Getting
    and Defining Properties via Descriptors](ch17_split_000.html#functions_for_property_descriptors
    "Getting and Defining Properties via Descriptors")).
  id: totrans-2496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning to a property via `=`.
  id: totrans-2497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are, however, a few subtle differences:'
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
- en: '*Defining a property* means creating a new own property or updating the attributes
    of an existing own property. In both cases, the prototype chain is completely
    ignored.'
  id: totrans-2499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Assigning to a property* `prop` means changing an existing property. The process
    is as follows:'
  id: totrans-2500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `prop` is a setter (own or inherited), call that setter.
  id: totrans-2501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, if `prop` is read-only (own or inherited), throw an exception (in
    strict mode) or do nothing (in sloppy mode). The next section explains this (slightly
    unexpected) phenomenon in more detail.
  id: totrans-2502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, if `prop` is own (and writable), change the value of that property.
  id: totrans-2503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, there either is no property `prop`, or it is inherited and writable.
    In both cases, define an own property `prop` that is writable, configurable, and
    enumerable. In the latter case, we have just overridden an inherited property
    (nondestructively changed it). In the former case, a missing property has been
    defined automatically. This kind of autodefining is problematic, because typos
    in assignments can be hard to detect.
  id: totrans-2504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inherited Read-Only Properties Can’t Be Assigned To
  id: totrans-2505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If an object, `obj`, inherits a property, `foo`, from a prototype and `foo`
    is not writable, then you can’t assign to `obj.foo`:'
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  id: totrans-2507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '`obj` inherits the read-only property `foo` from `proto`. In sloppy mode, setting
    the property has no effect:'
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  id: totrans-2509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: 'In strict mode, you get an exception:'
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  id: totrans-2511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: This fits with the idea that assignment changes inherited properties, but nondestructively.
    If an inherited property is read-only, you want to forbid all changes, even nondestructive
    ones.
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can circumvent this protection by defining an own property (see
    the previous subsection for the difference between definition and assignment):'
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  id: totrans-2514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: 'Enumerability: Best Practices'
  id: totrans-2515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The general rule is that properties created by the system are nonenumerable,
    while properties created by users are enumerable:'
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  id: totrans-2517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: 'This is especially true for the methods of the built-in instance prototypes:'
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  id: totrans-2519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: The main purpose of enumerability is to tell the `for-in` loop which properties
    it should ignore. As we have seen just now when we looked at instances of built-in
    constructors, everything not created by the user is hidden from `for-in`.
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
- en: 'The only operations affected by enumerability are:'
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
- en: The `for-in` loop
  id: totrans-2522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.keys()` ([Listing Own Property Keys](ch17_split_000.html#Object.keys
    "Listing Own Property Keys"))'
  id: totrans-2523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON.stringify()` ([JSON.stringify(value, replacer?, space?)](ch22.html#JSON.stringify
    "JSON.stringify(value, replacer?, space?)"))'
  id: totrans-2524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some best practices to keep in mind:'
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
- en: 'For your own code, you can usually ignore enumerability and should avoid the
    `for-in` loop ([Best Practices: Iterating over Arrays](ch18.html#array_iteration
    "Best Practices: Iterating over Arrays")).'
  id: totrans-2526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You normally shouldn’t add properties to built-in prototypes and objects. But
    if you do, you should make them nonenumerable to avoid breaking existing code.
  id: totrans-2527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting Objects
  id: totrans-2528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three levels of protecting an object, listed here from weakest to
    strongest:'
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
- en: Preventing extensions
  id: totrans-2530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sealing
  id: totrans-2531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freezing
  id: totrans-2532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing Extensions
  id: totrans-2533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Preventing extensions via:'
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  id: totrans-2535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: 'makes it impossible to add properties to `obj`. For example:'
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  id: totrans-2537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: 'Now adding a property fails silently in sloppy mode:'
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  id: totrans-2539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: 'and throws an error in strict mode:'
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  id: totrans-2541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: 'You can still delete properties, though:'
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  id: totrans-2543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: 'You check whether an object is extensible via:'
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  id: totrans-2545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: Sealing
  id: totrans-2546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sealing via:'
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  id: totrans-2548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: prevents extensions and makes all properties “unconfigurable.” The latter means
    that the attributes (see [Property Attributes and Property Descriptors](ch17_split_000.html#property_attributes
    "Property Attributes and Property Descriptors")) of properties can’t be changed
    anymore. For example, read-only properties stay read-only forever.
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates that sealing makes all properties unconfigurable:'
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  id: totrans-2551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: 'You can still change the property `foo`:'
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  id: totrans-2553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: 'but you can’t change its attributes:'
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  id: totrans-2555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: 'You check whether an object is sealed via:'
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  id: totrans-2557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: Freezing
  id: totrans-2558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Freezing is performed via:'
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  id: totrans-2560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: 'It makes all properties nonwritable and seals `obj`. In other words, `obj`
    is not extensible and all properties are read-only, and there is no way to change
    that. Let’s look at an example:'
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  id: totrans-2562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: 'Once again, you get silent failures in sloppy mode:'
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  id: totrans-2564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: 'And you get errors in strict mode:'
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  id: totrans-2566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: 'You check whether an object is frozen via:'
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  id: totrans-2568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: 'Pitfall: Protection Is Shallow'
  id: totrans-2569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Protecting an object is *shallow*: it affects the own properties, but not the
    values of those properties. For example, consider the following object:'
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  id: totrans-2571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: 'Even though you have frozen `obj`, it is not completely immutable—you can change
    the (mutable) value of property `bar`:'
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  id: totrans-2573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: Additionally, `obj` has the prototype `Object.prototype`, which is also mutable.
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
- en: 'Layer 3: Constructors—Factories for Instances'
  id: totrans-2575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *constructor function* (short: *constructor*) helps with producing objects
    that are similar in some way. It is a normal function, but it is named, set up,
    and invoked differently. This section explains how constructors work. They correspond
    to classes in other languages.'
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen an example of two objects that are similar (in [Sharing
    Data Between Objects via a Prototype](ch17_split_000.html#sharing_via_prototype
    "Sharing Data Between Objects via a Prototype")):'
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  id: totrans-2578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: 'The objects `jane` and `tarzan` are both considered “persons” and share the
    prototype object `PersonProto`. Let’s turn that prototype into a constructor `Person`
    that creates objects like `jane` and `tarzan`. The objects a constructor creates
    are called its *instances*. Such instances have the same structure as `jane` and
    `tarzan`, consisting of two parts:'
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
- en: Data is instance-specific and stored in the own properties of the instance objects
    (`jane` and `tarzan` in the preceding example).
  id: totrans-2580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Behavior is shared by all instances—they have a common prototype object with
    methods (`PersonProto` in the preceding example).
  id: totrans-2581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A constructor is a function that is invoked via the `new` operator. By convention,
    the names of constructors start with uppercase letters, while the names of normal
    functions and methods start with lowercase letters. The function itself sets up
    part 1:'
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  id: totrans-2583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: 'The object in `Person.prototype` becomes the prototype of all instances of
    `Person`. It contributes part 2:'
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  id: totrans-2585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: 'Let’s create and use an instance of `Person`:'
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  id: totrans-2587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: 'We can see that `Person` is a normal function. It only becomes a constructor
    when it is invoked via `new`. The `new` operator performs the following steps:'
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
- en: 'First the behavior is set up: a new object is created whose prototype is `Person.`
    `prototype`.'
  id: totrans-2589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then the data is set up: `Person` receives that object as the implicit parameter
    `this` and adds instance properties.'
  id: totrans-2590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 17-3](ch17_split_001.html#figoo_person_instance "Figure 17-3. jane
    is an instance of the constructor Person; its prototype is the object Person.prototype.")
    shows what the instance `jane` looks like. The property `constructor` of `Person.prototype`
    points back to the constructor and is explained in [The constructor Property of
    Instances](ch17_split_001.html#constructor_property "The constructor Property
    of Instances").'
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
- en: '![jane is an instance of the constructor Person; its prototype is the object
    Person.prototype.](images/spjs_2103.png)Figure 17-3. jane is an instance of the
    constructor Person; its prototype is the object Person.prototype.'
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
- en: 'The `instanceof` operator allows us to check whether an object is an instance
    of a given constructor:'
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  id: totrans-2594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: The new Operator Implemented in JavaScript
  id: totrans-2595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you were to manually implement the `new` operator, it would look roughly
    as follows:'
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  id: totrans-2597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: In line (1), you can see that the prototype of an instance created by a constructor
    `Constr` is `Constr.prototype`.
  id: totrans-2598
  prefs: []
  type: TYPE_NORMAL
- en: 'Line (2) reveals another feature of the `new` operator: you can return an arbitrary
    object from a constructor and it becomes the result of the `new` operator. This
    is useful if you want a constructor to return an instance of a subconstructor
    (an example is given in [Returning arbitrary objects from a constructor](ch17_split_001.html#constructor_arbitrary_objects
    "Returning arbitrary objects from a constructor")).'
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminology: The Two Prototypes'
  id: totrans-2600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unfortunately, the term *prototype* is used ambiguously in JavaScript:'
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototype 1: The prototype relationship'
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
- en: 'An object can be the prototype of another object:'
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  id: totrans-2604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: In the preceding example, `proto` is the prototype of `obj`.
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototype 2: The value of the property `prototype`'
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
- en: 'Each constructor `C` has a `prototype` property that refers to an object. That
    object becomes the prototype of all instances of `C`:'
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  id: totrans-2608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: 'Usually the context makes it clear which of the two prototypes is meant. Should
    disambiguation be necessary, then we are stuck with *prototype* to describe the
    relationship between objects, because that name has made it into the standard
    library via `getPrototypeOf` and `isPrototypeOf`. We thus need to find a different
    name for the object referenced by the `prototype` property. One possibility is
    *constructor prototype*, but that is problematic because constructors have prototypes,
    too:'
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  id: totrans-2610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: Thus, *instance prototype* is the best option.
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
- en: The constructor Property of Instances
  id: totrans-2612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, each function `C` contains an instance prototype object `C.prototype`
    whose property `constructor` points back to `C`:'
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  id: totrans-2614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: 'Because the `constructor` property is inherited from the prototype by each
    instance, you can use it to get the constructor of an instance:'
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  id: totrans-2616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: Use cases for the constructor property
  id: totrans-2617
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Switching over an object’s constructor
  id: totrans-2618
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following `catch` clause, we take different actions, depending on the
    constructor of the caught exception:'
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  id: totrans-2620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: Warning
  id: totrans-2621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach detects only direct instances of a given constructor. In contrast,
    `instanceof` detects both direct instances and instances of all subconstructors.
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
- en: Determining the name of an object’s constructor
  id: totrans-2623
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  id: totrans-2625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: Warning
  id: totrans-2626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all JavaScript engines support the property `name` for functions.
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
- en: Creating similar objects
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you create a new object, `y`, that has the same constructor as
    an existing object, `x`:'
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  id: totrans-2630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: 'This trick is handy for a method that must work for instances of subconstructors
    and wants to create a new instance that is similar to `this`. Then you can’t use
    a fixed constructor:'
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  id: totrans-2632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: Referring to a superconstructor
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
- en: 'Some inheritance libraries assign the superprototype to a property of a subconstructor.
    For example, the YUI framework provides subclassing via [`Y.extend`](http://yuilibrary.com/yui/docs/yui/yui-extend.html):'
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  id: totrans-2635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: The call in line (1) works, because `extend` sets `Sub.superclass` to `Super.prototype`.
    Thanks to the `constructor` property, you can call the superconstructor as a method.
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-2637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `instanceof` operator (see [The instanceof Operator](ch17_split_001.html#operator_instanceof
    "The instanceof Operator")) does not rely on the property `constructor`.
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
- en: Best practice
  id: totrans-2639
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Make sure that for each constructor `C`, the following assertion holds:'
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  id: totrans-2641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: 'By default, every function `f` already has a property `prototype` that is set
    up correctly:'
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  id: totrans-2643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: 'You should thus avoid replacing this object and only add properties to it:'
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  id: totrans-2645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: 'If you do replace it, you should manually assign the correct value to `constructor`:'
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  id: totrans-2647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: Note that nothing crucial in JavaScript depends on the `constructor` property;
    but it is good style to set it up, because it enables the techniques mentioned
    in this section.
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
- en: The instanceof Operator
  id: totrans-2649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `instanceof` operator:'
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  id: totrans-2651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: 'determines whether `value` has been created by the constructor `Constr` or
    a subconstructor. It does so by checking whether `Constr.prototype` is in the
    prototype chain of `value`. Therefore, the following two expressions are equivalent:'
  id: totrans-2652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  id: totrans-2653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: 'Here are some examples:'
  id: totrans-2654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  id: totrans-2655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: 'As expected, `instanceof` is always `false` for primitive values:'
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  id: totrans-2657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: 'Finally, `instanceof` throws an exception if its right side isn’t a function:'
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  id: totrans-2659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: 'Pitfall: objects that are not instances of Object'
  id: totrans-2660
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Almost all objects are instances of `Object`, because `Object.prototype` is
    in their prototype chain. But there are also objects where that is not the case.
    Here are two examples:'
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  id: totrans-2662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: 'The former object is explained in more detail in [The dict Pattern: Objects
    Without Prototypes Are Better Maps](ch17_split_001.html#dict_pattern "The dict
    Pattern: Objects Without Prototypes Are Better Maps"). The latter object is where
    most prototype chains end (and they must end somewhere). Neither object has a
    prototype:'
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  id: totrans-2664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: 'But `typeof` correctly classifies them as objects:'
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  id: totrans-2666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: This pitfall is not a deal-breaker for most use cases for `instanceof`, but
    you have to be aware of it.
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: crossing realms (frames or windows)'
  id: totrans-2668
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In web browsers, each frame and window has its own *realm* with separate global
    variables. That prevents `instanceof` from working for objects that cross realms.
    To see why, look at the following code:'
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  id: totrans-2670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: 'If `myvar` is an array from a different realm, then its prototype is the `Array.prototype`
    from that realm. Therefore, `instanceof` will not find the `Array.prototype` of
    the current realm in the prototype chain of `myvar` and will return `false`. ECMAScript 5
    has the function `Array.isArray()`, which always works:'
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  id: totrans-2672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: Obviously, this is also an issue with non-built-in constructors.
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from using `Array.isArray()`, there are several things you can do to
    work around this problem:'
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
- en: Avoid objects crossing realms. Browsers have the [`postMessage()`](http://mzl.la/1fwmNrL)
    method, which can copy an object to another realm instead of passing a reference.
  id: totrans-2675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check the name of the constructor of an instance (only works on engines that
    support the property `name` for functions):'
  id: totrans-2676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE658]'
  id: totrans-2677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: 'Use a prototype property to mark instances as belonging to a type `T`. There
    are several ways in which you can do so. The checks for whether `value` is an
    instance of `T` look as follows:'
  id: totrans-2678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value.isT()`: The prototype of `T` instances must return `true` from this
    method; a common superconstructor should return the default value, `false`.'
  id: totrans-2679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''T'' in value`: You must tag the prototype of `T` instances with a property
    whose key is `''T''` (or something more unique).'
  id: totrans-2680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value.TYPE_NAME === ''T''`: Every relevant prototype must have a `TYPE_NAME`
    property with an appropriate value.'
  id: totrans-2681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips for Implementing Constructors
  id: totrans-2682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section gives a few tips for implementing constructors.
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
- en: 'Protection against forgetting new: strict mode'
  id: totrans-2684
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you forget `new` when you use a constructor, you are calling it as a function
    instead of as a constructor. In sloppy mode, you don’t get an instance and global
    variables are created. Unfortunately, all of this happens without a warning:'
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  id: totrans-2686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: 'In strict mode, you get an exception:'
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  id: totrans-2688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: Returning arbitrary objects from a constructor
  id: totrans-2689
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In many object-oriented languages, constructors can produce only direct instances.
    For example, consider Java: let’s say you want to implement a class `Expression`
    that has the subclasses `Addition` and `Multiplication`. Parsing produces direct
    instances of the latter two classes. You can’t implement it as a constructor of
    `Expression`, because that constructor can produce only direct instances of `Expression`.
    As a workaround, static factory methods are used in Java:'
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  id: totrans-2691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: 'In JavaScript, you can simply return whatever object you need from a constructor.
    Thus, the JavaScript version of the preceding code would look like:'
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  id: totrans-2693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: 'That is good news: JavaScript constructors don’t lock you in, so you can always
    change your mind as to whether a constructor should return a direct instance or
    something else.'
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
- en: Data in Prototype Properties
  id: totrans-2695
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explains that in most cases, you should not put data in prototype
    properties. There are, however, a few exceptions to that rule.
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Prototype Properties with Initial Values for Instance Properties
  id: totrans-2697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prototypes contain properties that are shared by several objects. Hence, they
    work well for methods. Additionally, with a technique that is described next,
    you can also use them to provide initial values for instance properties. I’ll
    later explain why that is not recommended.
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
- en: 'A constructor usually sets instance properties to initial values. If one such
    value is a default, then you don’t need to create an instance property. You only
    need a prototype property with the same key whose value is the default. For example:'
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  id: totrans-2700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: The parameter `data` is optional. If it is missing, the instance does not get
    a property `data`, but inherits `Names.prototype.data` instead.
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach mostly works: you can create an instance `n` of `Names`. Getting
    `n.data` reads `Names.prototype.data`. Setting `n.data` creates a new own property
    in `n` and preserves the shared default value in the prototype. We only have a
    problem if we *change* the default value (instead of replacing it with a new value):'
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  id: totrans-2703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: In the preceding example, `push()` changed the array in `Names.prototype.data`.
    Since that array is shared by all instances without an own property `data`, `n2.data`’s
    initial value has changed, too.
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
- en: 'Best practice: don’t share default values'
  id: totrans-2705
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given what we’ve just discussed, it is better to not share default values and
    to always create new ones:'
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  id: totrans-2707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: 'Obviously, the problem of modifying a shared default value does not arise if
    that value is immutable (as all primitives are; see [Primitive Values](ch08.html#primitive_values
    "Primitive Values")). But for consistency’s sake, it’s best to stick to a single
    way of setting up properties. I also prefer to maintain the usual separation of
    concerns (see [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances")): the constructor sets up the
    instance properties, and the prototype contains the methods.'
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 6 will make this even more of a best practice, because constructor
    parameters can have default values and you can define prototype methods via classes,
    but not prototype properties with data.
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
- en: Creating instance properties on demand
  id: totrans-2710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Occasionally, creating a property value is an expensive operation (computationally
    or storage-wise). In that case, you can create an instance property on demand:'
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  id: totrans-2712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: 'We can’t add the property `data` to the instance via assignment, because JavaScript
    would complain about a missing setter (which it does when it only finds a getter).
    Therefore, we add it via `Object.defineProperty()`. Consult [Properties: Definition
    Versus Assignment](ch17_split_000.html#definition_vs_assignment "Properties: Definition
    Versus Assignment") to review the differences between defining and assigning.
    In line (1), we are ensuring that the property `constructor` is set up properly
    (see [The constructor Property of Instances](ch17_split_001.html#constructor_property
    "The constructor Property of Instances")).'
  id: totrans-2713
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, that is quite a bit of work, so you have to be sure it is worth it.
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Nonpolymorphic Prototype Properties
  id: totrans-2715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the same property (same key, same semantics, generally different values),
    exists in several prototypes, it is called *polymorphic*. Then the result of reading
    the property via an instance is dynamically determined via that instance’s prototype.
    Prototype properties that are not used polymorphically can be replaced by variables
    (which better reflects their nonpolymorphic nature).
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can store a constant in a prototype property and access it
    via `this`:'
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  id: totrans-2718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: 'This constant is not polymorphic. Therefore, you can just as well access it
    via a variable:'
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  id: totrans-2720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: Polymorphic Prototype Properties
  id: totrans-2721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an example of polymorphic prototype properties with immutable data.
    Tagging instances of a constructor via prototype properties enables you to tell
    them apart from instances of a different constructor:'
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  id: totrans-2723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: 'Thanks to the polymorphic “tag” `TYPE_NAME`, you can distinguish the instances
    of `ConstrA` and `ConstrB` even when they cross realms (then `instanceof` does
    not work; see [Pitfall: crossing realms (frames or windows)](ch17_split_001.html#cross-realm_instanceof
    "Pitfall: crossing realms (frames or windows)")).'
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Data Private
  id: totrans-2725
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript does not have dedicated means for managing private data for an object.
    This section will describe three techniques for working around that limitation:'
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
- en: Private data in the environment of a constructor
  id: totrans-2727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private data in properties with marked keys
  id: totrans-2728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private data in properties with reified keys
  id: totrans-2729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, I will explain how to keep global data private via IIFEs.
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
- en: Private Data in the Environment of a Constructor (Crockford Privacy Pattern)
  id: totrans-2731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a constructor is invoked, two things are created: the constructor’s instance
    and an environment (see [Environments: Managing Variables](ch16.html#environments
    "Environments: Managing Variables")). The instance is to be initialized by the
    constructor. The environment holds the constructor’s parameters and local variables.
    Every function (which includes methods) created inside the constructor will retain
    a reference to the environment—the environment in which it was created. Thanks
    to that reference, it will always have access to the environment, even after the
    constructor is finished. This combination of function and environment is called
    a *closure* ([Closures: Functions Stay Connected to Their Birth Scopes](ch16.html#closures
    "Closures: Functions Stay Connected to Their Birth Scopes")). The constructor’s
    environment is thus data storage that is independent of the instance and related
    to it only because the two are created at the same time. To properly connect them,
    we must have functions that live in both worlds. Using [Douglas Crockford’s terminology](http://www.crockford.com/javascript/private.html),
    an instance can have three kinds of values associated with it (see [Figure 17-4](ch17_split_001.html#figprivate_data
    "Figure 17-4. When a constructor Constr is invoked, two data structures are created:
    an environment for parameters and local variables and an instance to be initialized.")):'
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
- en: Public properties
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
- en: Values stored in properties (either in the instance or in its prototype) are
    publicly accessible.
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
- en: Private values
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
- en: Data and functions stored in the environment are *private*—only accessible to
    the constructor and to the functions it created.
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
- en: Privileged methods
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
- en: Private functions can access public properties, but public methods in the prototype
    can’t access private data. We thus need *privileged* methods—public methods in
    the instance. Privileged methods are public and can be called by everyone, but
    they also have access to private values, because they were created in the constructor.
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
- en: '![When a constructor Constr is invoked, two data structures are created: an
    environment for parameters and local variables and an instance to be initialized.](images/spjs_2104.png)Figure 17-4. When
    a constructor Constr is invoked, two data structures are created: an environment
    for parameters and local variables and an instance to be initialized.'
  id: totrans-2739
  prefs: []
  type: TYPE_NORMAL
- en: The following sections explain each kind of value in more detail.
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
- en: Public properties
  id: totrans-2741
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Remember that given a constructor `Constr`, there are two kinds of properties
    that are *public*, accessible to everyone. First, *prototype properties* are stored
    in `Constr.prototype` and shared by all instances. Prototype properties are usually
    methods:'
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  id: totrans-2743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: 'Second, *instance properties* are unique to each instance. They are added in
    the constructor and usually hold data (not methods):'
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  id: totrans-2745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: Private values
  id: totrans-2746
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The constructor’s environment consists of the parameters and local variables.
    They are accessible only from inside the constructor and thus private to the instance:'
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  id: totrans-2748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: Privileged methods
  id: totrans-2749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Private data is so safe from outside access that prototype methods can’t access
    it. But then how else would you use it after leaving the constructor? The answer
    is *privileged methods*: functions created in the constructor are added as instance
    methods. That means that, on one hand, they can access private data; on the other
    hand, they are public and therefore seen by prototype methods. In other words,
    they serve as mediators between private data and the public (including prototype
    methods):'
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  id: totrans-2751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: An example
  id: totrans-2752
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following is an implementation of a `StringBuilder`, using the Crockford
    privacy pattern:'
  id: totrans-2753
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  id: totrans-2754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: 'Here is the interaction:'
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  id: totrans-2756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: The pros and cons of the Crockford privacy pattern
  id: totrans-2757
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are some points to consider when you are using the Crockford privacy pattern:'
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
- en: It’s not very elegant
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
- en: Mediating access to private data via privileged methods introduces an unnecessary
    indirection. Privileged methods and private functions both destroy the separation
    of concerns between the constructor (setting up instance data) and the instance
    prototype (methods).
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
- en: It’s completely secure
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to access the environment’s data from outside, which makes this
    solution secure if you need that (e.g., for security-critical code). On the other
    hand, private data not being accessible to the outside can also be an inconvenience.
    Sometimes you want to unit-test private functionality. And some temporary quick
    fixes depend on the ability to access private data. This kind of quick fix cannot
    be predicted, so no matter how good your design is, the need can arise.
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
- en: It may be slower
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
- en: Accessing properties in the prototype chain is highly optimized in current JavaScript
    engines. Accessing values in the closure may be slower. But these things change
    constantly, so you’ll have to measure should this really matter for your code.
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
- en: It consumes more memory
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the environment around and putting privileged methods in instances costs
    memory. Again, be sure it really matters for your code and measure.
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
- en: Private Data in Properties with Marked Keys
  id: totrans-2767
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For most non-security-critical applications, privacy is more like a hint to
    clients of an API: “You don’t need to see this.” That’s the key benefit of encapsulation—hiding
    complexity. Even though more is going on under the hood, you only need to understand
    the public part of an API. The idea of a naming convention is to let clients know
    about privacy by marking the key of a property. A prefixed underscore is often
    used for this purpose.'
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite the previous `StringBuilder` example so that the buffer is kept
    in a property `_buffer`, which is private, but by convention only:'
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  id: totrans-2770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: 'Here are some pros and cons of privacy via marked property keys:'
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
- en: It offers a more natural coding style
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
- en: Being able to access private and public data in the same manner is more elegant
    than using environments for privacy.
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
- en: It pollutes the namespace of properties
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
- en: Properties with marked keys can be seen everywhere. The more people use IDEs,
    the more it will be a nuisance that they are shown alongside public properties,
    in places where they should be hidden. IDEs could, in theory, adapt by recognizing
    naming conventions and by hiding private properties where possible.
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
- en: Private properties can be accessed from “outside”
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
- en: That can be useful for unit tests and quick fixes. Additionally, subconstructors
    and helper functions (so-called “friend functions”) can profit from easier access
    to private data. The environment approach doesn’t offer this kind of flexibility;
    private data can be accessed only from within the constructor.
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
- en: It can lead to key clashes
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
- en: Keys of private properties can clash. This is already an issue for subconstructors,
    but it is even more problematic if you work with multiple inheritance (as enabled
    by some libraries). With the environment approach, there are never any clashes.
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
- en: Private Data in Properties with Reified Keys
  id: totrans-2780
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One problem with a naming convention for private properties is that keys might
    clash (e.g., a key from a constructor with a key from a subconstructor, or a key
    from a mixin with a key from a constructor). You can make such clashes less likely
    by using longer keys, that, for example, include the name of the constructor.
    Then, in the previous case, the private property `_buffer` would be called `_StringBuilder_buffer`.
    If such a key is too long for your taste, you have the option of *reifying it*,
    of storing it in a variable:'
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  id: totrans-2782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: 'We now access the private data via `this[KEY_BUFFER]`:'
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  id: totrans-2784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: We have wrapped an IIFE around `StringBuilder` so that the constant `KEY_BUFFER`
    stays local and doesn’t pollute the global namespace.
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
- en: 'Reified property keys enable you to use UUIDs (universally unique identifiers)
    in keys. For example, via Robert Kieffer’s [node-uuid](https://github.com/broofa/node-uuid):'
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  id: totrans-2787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '`KEY_BUFFER` has a different value each time the code runs. It may, for example,
    look like this:'
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  id: totrans-2789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: Long keys with UUIDs make key clashes virtually impossible.
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Global Data Private via IIFEs
  id: totrans-2791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This subsection explains how to keep global data private to singleton objects,
    constructors, and methods, via IIFEs (see [Introducing a New Scope via an IIFE](ch16.html#iife
    "Introducing a New Scope via an IIFE")). Those IIFEs create new environments (refer
    back to [Environments: Managing Variables](ch16.html#environments "Environments:
    Managing Variables")), which is where you put the private data.'
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
- en: Attaching private global data to a singleton object
  id: totrans-2793
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t need a constructor to associate an object with private data in an
    environment. The following example shows how to use an IIFE for the same purpose,
    by wrapping it around a singleton object:'
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  id: totrans-2795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: Keeping global data private to all of a constructor
  id: totrans-2796
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some global data is relevant only for a constructor and the prototype methods.
    By wrapping an IIFE around both, you can hide it from public view. [Private Data
    in Properties with Reified Keys](ch17_split_001.html#private_data_reified_keys
    "Private Data in Properties with Reified Keys") gave an example: the constructor
    `StringBuilder` and its prototype methods use the constant `KEY_BUFFER`, which
    contains a property key. That constant is stored in the environment of an IIFE:'
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  id: totrans-2798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: Note that if you are using a module system (see [Chapter 31](ch31.html "Chapter 31. Module
    Systems and Package Managers")), you can achieve the same effect with cleaner
    code by putting the constructor plus methods in a module.
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
- en: Attaching global data to a method
  id: totrans-2800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes you only need global data for a single method. You can keep it private
    by putting it in the environment of an IIFE that you wrap around the method. For
    example:'
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  id: totrans-2802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: 'Here is the interaction:'
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  id: totrans-2804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: 'Layer 4: Inheritance Between Constructors'
  id: totrans-2805
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we examine how constructors can be inherited from: given a
    constructor `Super`, how can we write a new constructor, `Sub`, that has all the
    features of `Super` plus some features of its own? Unfortunately, JavaScript does
    not have a built-in mechanism for performing this task. Hence, we’ll have to do
    some manual work.'
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-5](ch17_split_001.html#figoo_subclassing_idea "Figure 17-5. Sub
    should inherit from Super: it should have all of Super’s prototype properties
    and all of Super’s instance properties in addition to its own. Note that methodB
    overrides Super’s methodB.") illustrates the idea: the subconstructor `Sub` should
    have all of the properties of `Super` (both prototype properties and instance
    properties) in addition to its own. Thus, we have a rough idea of what `Sub` should
    look like, but don’t know how to get there. There are several things we need to
    figure out, which I’ll explain next:'
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting instance properties.
  id: totrans-2808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting prototype properties.
  id: totrans-2809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensuring that `instanceof` works: if `sub` is an instance of `Sub`, we also
    want `sub instanceof Super` to be true.'
  id: totrans-2810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding a method to adapt one of `Super`’s methods in `Sub`.
  id: totrans-2811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Making supercalls: if we have overridden one of `Super`’s methods, we may need
    to call the original method from `Sub`.'
  id: totrans-2812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Sub should inherit from Super: it should have all of Super’s prototype properties
    and all of Super’s instance properties in addition to its own. Note that methodB
    overrides Super’s methodB.](images/spjs_2105.png)Figure 17-5. Sub should inherit
    from Super: it should have all of Super’s prototype properties and all of Super’s
    instance properties in addition to its own. Note that methodB overrides Super’s
    methodB.'
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting Instance Properties
  id: totrans-2814
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instance properties are set up in the constructor itself, so inheriting the
    superconstructor’s instance properties involves calling that constructor:'
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  id: totrans-2816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: When `Sub` is invoked via `new`, its implicit parameter `this` refers to a fresh
    instance. It first passes that instance on to `Super` (1), which adds its instance
    properties. Afterward, `Sub` sets up its own instance properties (2,3). The trick
    is not to invoke `Super` via `new`, because that would create a fresh superinstance.
    Instead, we call `Super` as a function and hand in the current (sub)instance as
    the value of `this`.
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting Prototype Properties
  id: totrans-2818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shared properties such as methods are kept in the instance prototype. Thus,
    we need to find a way for `Sub.prototype` to inherit all of `Super.prototype`’s
    properties. The solution is to give `Sub.prototype` the prototype `Super.prototype`.
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
- en: Confused by the two kinds of prototypes?
  id: totrans-2820
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Yes, JavaScript terminology is confusing here. If you feel lost, consult [Terminology:
    The Two Prototypes](ch17_split_001.html#two_prototypes "Terminology: The Two Prototypes"),
    which explains how they differ.'
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code that achieves that:'
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  id: totrans-2823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '`Object.create()` produces a fresh object whose prototype is `Super.prototype`.
    Afterward, we add `Sub`’s methods. As explained in [The constructor Property of
    Instances](ch17_split_001.html#constructor_property "The constructor Property
    of Instances"), we also need to set up the property `constructor`, because we
    have replaced the original instance prototype where it had the correct value.'
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-6](ch17_split_001.html#figoo_sub_constructor "Figure 17-6. The constructor
    Sub inherits the constructor Super by calling it and by making Sub.prototype a
    prototypee of Super.prototype.") shows how `Sub` and `Super` are related now.
    `Sub`’s structure does resemble what I have sketched in [Figure 17-5](ch17_split_001.html#figoo_subclassing_idea
    "Figure 17-5. Sub should inherit from Super: it should have all of Super’s prototype
    properties and all of Super’s instance properties in addition to its own. Note
    that methodB overrides Super’s methodB."). The diagram does not show the instance
    properties, which are set up by the function call mentioned in the diagram.'
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
- en: '![The constructor Sub inherits the constructor Super by calling it and by making
    Sub.prototype a prototypee of Super.prototype.](images/spjs_2106.png)Figure 17-6. The
    constructor Sub inherits the constructor Super by calling it and by making Sub.prototype
    a prototypee of Super.prototype.'
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring That instanceof Works
  id: totrans-2827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '“Ensuring that `instanceof` works” means that every instance of `Sub` must
    also be an instance of `Super`. [Figure 17-7](ch17_split_001.html#figoo_sub_instance
    "Figure 17-7. subInstance has been created by the constructor Sub. It has the
    two prototypes Sub.prototype and Super.prototype.") shows what the prototype chain
    of `subInstance`, an instance of `Sub`, looks like: its first prototype is `Sub.prototype`,
    and its second prototype is `Super.prototype`.'
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
- en: '![subInstance has been created by the constructor Sub. It has the two prototypes
    Sub.prototype and Super.prototype.](images/spjs_2107.png)Figure 17-7. subInstance
    has been created by the constructor Sub. It has the two prototypes Sub.prototype
    and Super.prototype.'
  id: totrans-2829
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with an easier question: is `subInstance` an instance of `Sub`?
    Yes, it is, because the following two assertions are equivalent (the latter can
    be considered the definition of the former):'
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  id: totrans-2831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: 'As mentioned before, `Sub.prototype` is one of the prototypes of `subInstance`,
    so both assertions are true. Similarly, `subInstance` is also an instance of `Super`,
    because the following two assertions hold:'
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  id: totrans-2833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: Overriding a Method
  id: totrans-2834
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We override a method in `Super.prototype` by adding a method with the same
    name to `Sub.prototype`. `methodB` is an example and in [Figure 17-7](ch17_split_001.html#figoo_sub_instance
    "Figure 17-7. subInstance has been created by the constructor Sub. It has the
    two prototypes Sub.prototype and Super.prototype."), we can see why it works:
    the search for `methodB` begins in `subInstance` and finds `Sub.prototype.methodB`
    before `Super.prototype.methodB`.'
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
- en: Making a Supercall
  id: totrans-2836
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand supercalls, you need to know the term *home object*. The home
    object of a method is the object that owns the property whose value is the method.
    For example, the home object of `Sub.prototype.methodB` is `Sub.prototype`. Supercalling
    a method `foo` involves three steps:'
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
- en: Start your search “after” (in the prototype of) the home object of the current
    method.
  id: totrans-2838
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for a method whose name is `foo`.
  id: totrans-2839
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke that method with the current `this`. The rationale is that the supermethod
    must work with the same instance as the current method; it must be able to access
    the same instance properties.
  id: totrans-2840
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Therefore, the code of the submethod looks as follows. It supercalls itself,
    it calls the method it has overridden:'
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  id: totrans-2842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: 'One way of reading the supercall at (1) is as follows: refer to the supermethod
    directly and call it with the current `this`. However, if we split it into three
    parts, we find the aforementioned steps:'
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
- en: '`Super.prototype`: Start your search in `Super.prototype`, the prototype of
    `Sub.prototype` (the home object of the current method `Sub.prototype.methodB`).'
  id: totrans-2844
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`methodB`: Look for a method with the name `methodB`.'
  id: totrans-2845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`call(this, ...)`: Call the method found in the previous step, and maintain
    the current `this`.'
  id: totrans-2846
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoiding Hardcoding the Name of the Superconstructor
  id: totrans-2847
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Until now, we have always referred to supermethods and superconstructors by
    mentioning the superconstructor name. This kind of hardcoding makes your code
    less flexible. You can avoid it by assigning the superprototype to a property
    of `Sub`:'
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  id: totrans-2849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: 'Then calling the superconstructor and a supermethod looks as follows:'
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  id: totrans-2851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: 'Setting up `Sub._super` is usually handled by a utility function that also
    connects the subprototype to the superprototype. For example:'
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  id: totrans-2853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: This code uses the helper function `copyOwnPropertiesFrom()`, which is shown
    and explained in [Copying an Object](ch17_split_000.html#code_copyOwnPropertiesFrom
    "Copying an Object").
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-2855
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read “subclasses” as a verb: `SubC` *subclasses* `SuperC`. Such a utility function
    can take some of the pain out of creating a subconstructor: there are fewer things
    to do manually, and the name of the superconstructor is never mentioned redundantly.
    The following example demonstrates how it simplifies code.'
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Constructor Inheritance in Use'
  id: totrans-2857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a concrete example, let’s assume that the constructor `Person` already exists:'
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  id: totrans-2859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: 'We now want to create the constructor `Employee` as a subconstructor of `Person`.
    We do so manually, which looks like this:'
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  id: totrans-2861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: 'Here is the interaction:'
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  id: totrans-2863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: 'The utility function `subclasses()` from the previous section makes the code
    of `Employee` slightly simpler and avoids hardcoding the superconstructor `Person`:'
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  id: totrans-2865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: 'Example: The Inheritance Hierarchy of Built-in Constructors'
  id: totrans-2866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Built-in constructors use the same subclassing approach described in this section.
    For example, `Array` is a subconstructor of `Object`. Therefore, the prototype
    chain of an instance of `Array` looks like this:'
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  id: totrans-2868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: 'Antipattern: The Prototype Is an Instance of the Superconstructor'
  id: totrans-2869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before ECMAScript 5 and `Object.create()`, an often-used solution was to create
    the subprototype by invoking the superconstructor:'
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  id: totrans-2871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: This is not recommended under ECMAScript 5\. The prototype will have all of
    `Super`’s instance properties, which it has no use for. Therefore, it is better
    to use the aforementioned pattern (involving `Object.create()`).
  id: totrans-2872
  prefs: []
  type: TYPE_NORMAL
- en: Methods of All Objects
  id: totrans-2873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Almost all objects have `Object.prototype` in their prototype chain:'
  id: totrans-2874
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  id: totrans-2875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: The following subsections describe the methods that `Object.prototype` provides
    for its prototypees.
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
- en: Conversion to Primitive
  id: totrans-2877
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following two methods are used to convert an object to a primitive value:'
  id: totrans-2878
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.prototype.toString()`'
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a string representation of an object:'
  id: totrans-2880
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  id: totrans-2881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: '`Object.prototype.valueOf()`'
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the preferred way of converting an object to a number. The default
    implementation returns `this`:'
  id: totrans-2883
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  id: totrans-2884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: '`valueOf` is overridden by wrapper constructors to return the wrapped primitive:'
  id: totrans-2885
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  id: totrans-2886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: 'The conversion to number and string (whether implicit or explicit) builds on
    the conversion to primitive (for details, see [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")). That is why you can use the aforementioned two methods
    to configure those conversions. `valueOf()` is preferred by the conversion to
    number:'
  id: totrans-2887
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  id: totrans-2888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: '`toString()` is preferred by the conversion to string:'
  id: totrans-2889
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  id: totrans-2890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: The conversion to boolean is not configurable; objects are always considered
    to be `true` (see [Converting to Boolean](ch10.html#toboolean "Converting to Boolean")).
  id: totrans-2891
  prefs: []
  type: TYPE_NORMAL
- en: Object.prototype.toLocaleString()
  id: totrans-2892
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method returns a locale-specific string representation of an object. The
    default implementation calls `toString()`. Most engines don’t go beyond this support
    for this method. However, the ECMAScript Internationalization API (see [The ECMAScript
    Internationalization API](ch30.html#i18n_api "The ECMAScript Internationalization
    API")), which is supported by many modern engines, overrides it for several built-in
    constructors.
  id: totrans-2893
  prefs: []
  type: TYPE_NORMAL
- en: Prototypal Inheritance and Properties
  id: totrans-2894
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods help with prototypal inheritance and properties:'
  id: totrans-2895
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.prototype.isPrototypeOf(obj)`'
  id: totrans-2896
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns `true` if the receiver is part of the prototype chain of `obj`:'
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  id: totrans-2898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: '`Object.prototype.hasOwnProperty(key)`'
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if `this` owns a property whose key is `key`. “Own” means that
    the property exists in the object itself and not in one of its prototypes.
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-2901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You normally should invoke this method generically (not directly), especially
    on objects whose properties you don’t know statically. Why and how is explained
    in [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties"):'
  id: totrans-2902
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  id: totrans-2903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: '`Object.prototype.propertyIsEnumerable(propKey)`'
  id: totrans-2904
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns `true` if the receiver has a property with the key `propKey` that is
    enumerable and `false` otherwise:'
  id: totrans-2905
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  id: totrans-2906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: 'Generic Methods: Borrowing Methods from Prototypes'
  id: totrans-2907
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes instance prototypes have methods that are useful for more objects
    than those that inherit from them. This section explains how to use the methods
    of a prototype without inheriting from it. For example, the instance prototype
    `Wine.prototype` has the method `incAge()`:'
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  id: totrans-2909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: 'The interaction is as follows:'
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  id: totrans-2911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: 'The method `incAge()` works for any object that has the property `age`. How
    can we invoke it on an object that is not an instance of `Wine`? Let’s look at
    the preceding method call:'
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  id: totrans-2913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: 'There are actually two arguments:'
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
- en: '`chablis` is the receiver of the method call, passed to `incAge` via `this`.'
  id: totrans-2915
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1` is an argument, passed to `incAge` via `years`.'
  id: totrans-2916
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can’t replace the former with an arbitrary object—the receiver must be an
    instance of `Wine`. Otherwise, the method `incAge` is not found. But the preceding
    method call is equivalent to (refer back to [Calling Functions While Setting this:
    call(), apply(), and bind()](ch17_split_000.html#oop_call_apply_bind "Calling
    Functions While Setting this: call(), apply(), and bind()")):'
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  id: totrans-2918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: 'With the preceding pattern, we can make an object the receiver (first argument
    of `call`) that is not an instance of `Wine`, because the receiver isn’t used
    to find the method `Wine.prototype.incAge`. In the following example, we apply
    the method `incAge()` to the object `john`:'
  id: totrans-2919
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  id: totrans-2920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: A function that can be used in this manner is called a *generic method*; it
    must be prepared for `this` not being an instance of “its” constructor. Thus,
    not all methods are generic; the ECMAScript language specification explicitly
    states which ones are (see [A List of All Generic Methods](ch17_split_001.html#list_of_generic_methods
    "A List of All Generic Methods")).
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Object.prototype and Array.prototype via Literals
  id: totrans-2922
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calling a method generically is quite verbose:'
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  id: totrans-2924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: 'You can make this shorter by accessing `hasOwnProperty` via an instance of
    `Object`, as created by an empty object literal `{}`:'
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  id: totrans-2926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: 'Similarly, the following two expressions are equivalent:'
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  id: totrans-2928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: The advantage of this pattern is that it is less verbose. But it is also less
    self-explanatory. Performance should not be an issue (at least long term), as
    engines can statically determine that the literals should not create objects.
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
- en: Examples of Calling Methods Generically
  id: totrans-2930
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are a few examples of generic methods in use:'
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `apply()`(see [Function.prototype.apply(thisValue, argArray)](ch17_split_000.html#oop_apply
    "Function.prototype.apply(thisValue, argArray)")) to push an array (instead of
    individual elements; see [Adding and Removing Elements (Destructive)](ch18.html#Array.prototype.push
    "Adding and Removing Elements (Destructive)")):'
  id: totrans-2932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE716]'
  id: totrans-2933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: This example is about turning an array into arguments, not about borrowing a
    method from another constructor.
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the array method `join()` to a string (which is not an array):'
  id: totrans-2935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE717]'
  id: totrans-2936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: Apply the array method `map()` to a string:^([[15](ch17_split_001.html#ftn.id1038112)])
  id: totrans-2937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE718]'
  id: totrans-2938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: 'Using `map()` generically is more efficient than using `split('''')`, which
    creates an intermediate array:'
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  id: totrans-2940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: 'Apply a string method to nonstrings. `toUpperCase()` converts the receiver
    to a string and uppercases the result:'
  id: totrans-2941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE720]'
  id: totrans-2942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: 'Using generic array methods on plain objects gives you insight into how they
    work:'
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke an array method on a fake array:'
  id: totrans-2944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE721]'
  id: totrans-2945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: 'See how an array method transforms an object that it treats like an array:'
  id: totrans-2946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE722]'
  id: totrans-2947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: Array-Like Objects and Generic Methods
  id: totrans-2948
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some objects in JavaScript that feel like an array, but actually
    aren’t. That means that while they have indexed access and a `length` property,
    they don’t have any of the array methods (`forEach()`, `push`, `concat()`, etc.).
    This is unfortunate, but as we will see, generic array methods enable a workaround.
    Examples of array-like objects include:'
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
- en: 'The special variable `arguments` (see [All Parameters by Index: The Special
    Variable arguments](ch15.html#arguments_variable "All Parameters by Index: The
    Special Variable arguments")), which is an important array-like object, because
    it is such a fundamental part of JavaScript. `arguments` looks like an array:'
  id: totrans-2950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE723]'
  id: totrans-2951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: 'But none of the array methods are available:'
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  id: totrans-2953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: 'That’s because `arrayLike` is not an instance of `Array` (and `Array.prototype`
    is not in the prototype chain):'
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  id: totrans-2955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: 'Browser DOM node lists, which are returned by `document.getElementsBy*()` (e.g.,
    `getElementsByTagName()`), `document.forms`, and so on:'
  id: totrans-2956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE726]'
  id: totrans-2957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: 'Strings, which are array-like, too:'
  id: totrans-2958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE727]'
  id: totrans-2959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: 'The term *array-like* can also be seen as a contract between generic array
    methods and objects. The objects have to fulfill certain requirements; otherwise,
    the methods won’t work on them. The requirements are:'
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of an array-like object must be accessible via square brackets
    and integer indices starting at 0\. All methods need read access, and some methods
    additionally need write access. Note that all objects support this kind of indexing:
    an index in brackets is converted to a string and used as a key to look up a property
    value:'
  id: totrans-2961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE728]'
  id: totrans-2962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: An array-like object must have a `length` property whose value is the number
    of its elements. Some methods require `length` to be mutable (for example, `reverse()`).
    Values whose lengths are immutable (for example, strings) cannot be used with
    those methods.
  id: totrans-2963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns for working with array-like objects
  id: totrans-2964
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following patterns are useful for working with array-like objects:'
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
- en: 'Turn an array-like object into an array:'
  id: totrans-2966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE729]'
  id: totrans-2967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: 'The method `slice()` (see [Concatenating, Slicing, Joining (Nondestructive)](ch18.html#Array.prototype.slice
    "Concatenating, Slicing, Joining (Nondestructive)")) without any arguments creates
    a copy of an array-like receiver:'
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  id: totrans-2969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: 'To iterate over all elements of an array-like object, you can use a simple
    `for` loop:'
  id: totrans-2970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE731]'
  id: totrans-2971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: 'But you can also borrow `Array.prototype.forEach()`:'
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  id: totrans-2973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: 'In both cases, the interaction looks as follows:'
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  id: totrans-2975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: A List of All Generic Methods
  id: totrans-2976
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following list includes all methods that are generic, as mentioned in the
    ECMAScript language specification:'
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype` (see [Array Prototype Methods](ch18.html#array_prototype_methods
    "Array Prototype Methods")):'
  id: totrans-2978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concat`'
  id: totrans-2979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`every`'
  id: totrans-2980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter`'
  id: totrans-2981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach`'
  id: totrans-2982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOf`'
  id: totrans-2983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`join`'
  id: totrans-2984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastIndexOf`'
  id: totrans-2985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`'
  id: totrans-2986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop`'
  id: totrans-2987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push`'
  id: totrans-2988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce`'
  id: totrans-2989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduceRight`'
  id: totrans-2990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reverse`'
  id: totrans-2991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shift`'
  id: totrans-2992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slice`'
  id: totrans-2993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`some`'
  id: totrans-2994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort`'
  id: totrans-2995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splice`'
  id: totrans-2996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toLocaleString`'
  id: totrans-2997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString`'
  id: totrans-2998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unshift`'
  id: totrans-2999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype` (see [Date Prototype Methods](ch20.html#date_prototype_methods
    "Date Prototype Methods"))'
  id: totrans-3000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toJSON`'
  id: totrans-3001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.prototype` (see [Methods of All Objects](ch17_split_001.html#methods_of_all_objects
    "Methods of All Objects"))'
  id: totrans-3002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (All `Object` methods are automatically generic—they have to work for all objects.)
  id: totrans-3003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype` (see [String Prototype Methods](ch12.html#string_prototype_methods
    "String Prototype Methods"))'
  id: totrans-3004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charAt`'
  id: totrans-3005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charCodeAt`'
  id: totrans-3006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concat`'
  id: totrans-3007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOf`'
  id: totrans-3008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastIndexOf`'
  id: totrans-3009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localeCompare`'
  id: totrans-3010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`match`'
  id: totrans-3011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace`'
  id: totrans-3012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search`'
  id: totrans-3013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slice`'
  id: totrans-3014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split`'
  id: totrans-3015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`substring`'
  id: totrans-3016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toLocaleLowerCase`'
  id: totrans-3017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toLocaleUpperCase`'
  id: totrans-3018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toLowerCase`'
  id: totrans-3019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toUpperCase`'
  id: totrans-3020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trim`'
  id: totrans-3021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pitfalls: Using an Object as a Map'
  id: totrans-3022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since JavaScript has no built-in data structure for maps, objects are often
    used as maps from strings to values. Alas, that is more error-prone than it seems.
    This section explains three pitfalls that are involved in this task.
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall 1: Inheritance Affects Reading Properties'
  id: totrans-3024
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The operations that read properties can be partitioned into two kinds:'
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
- en: Some operations consider the whole prototype chain and see inherited properties.
  id: totrans-3026
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other operations access only the *own* (noninherited) properties of an object.
  id: totrans-3027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You need to choose carefully between these kinds of operations when you read
    the entries of an object-as-map. To see why, consider the following example:'
  id: totrans-3028
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  id: totrans-3029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: '`obj` is an object with one own property whose prototype is `proto`, which
    also has one own property. `proto` has the prototype `Object.prototype`, like
    all objects that are created by object literals. Thus, `obj` inherits properties
    from both `proto` and `Object.` `prototype`.'
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
- en: 'We want `obj` to be interpreted as a map with the single entry:'
  id: totrans-3031
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  id: totrans-3032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: That is, we want to ignore inherited properties and only consider own properties.
    Let’s see which read operations interpret `obj` in this manner and which don’t.
    Note that for objects-as-maps, we normally want to use arbitrary property keys,
    stored in variables. That rules out dot notation.
  id: totrans-3033
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a property exists
  id: totrans-3034
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `in` operator checks whether an object has a property with a given key,
    but it considers inherited properties:'
  id: totrans-3035
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  id: totrans-3036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: 'We need the check to ignore inherited properties. `hasOwnProperty()` does what
    we want:'
  id: totrans-3037
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  id: totrans-3038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: Collecting property keys
  id: totrans-3039
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What operations can we use to find all of the keys of `obj`, while honoring
    our interpretation of it as a map? `for-in` looks like it might work. But, alas,
    it doesn’t:'
  id: totrans-3040
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  id: totrans-3041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: It considers inherited enumerable properties. The reason that no properties
    of `Object.prototype` show up here is that all of them are nonenumerable.
  id: totrans-3042
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, `Object.keys()` lists only own properties:'
  id: totrans-3043
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  id: totrans-3044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: This method returns only enumerable own properties; `ownProp` has been added
    via assignment and is thus enumerable by default. If you want to list all own
    properties, you need to use `Object.getOwnPropertyNames()`.
  id: totrans-3045
  prefs: []
  type: TYPE_NORMAL
- en: Getting a property value
  id: totrans-3046
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For reading the value of a property, we can only choose between the dot operator
    and the bracket operator. We can’t use the former, because we have arbitrary keys,
    stored in variables. That leaves us with the bracket operator, which considers
    inherited properties:'
  id: totrans-3047
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  id: totrans-3048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: 'This is not what we want. There is no built-in operation for reading only own
    properties, but you can easily implement one yourself:'
  id: totrans-3049
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  id: totrans-3050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: 'With that function, the inherited property `toString` is ignored:'
  id: totrans-3051
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  id: totrans-3052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: 'Pitfall 2: Overriding Affects Invoking Methods'
  id: totrans-3053
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function `getOwnProperty()` invoked the method `hasOwnProperty()` on `obj`.
    Normally, that is fine:'
  id: totrans-3054
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  id: totrans-3055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: 'However, if you add a property to `obj` whose key is `hasOwnProperty`, then
    that property overrides the method `Object.prototype.hasOwnProperty()` and `getOwnProperty()`
    ceases to work:'
  id: totrans-3056
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  id: totrans-3057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: 'You can fix this problem by directly referring to `hasOwnProperty()`. This
    avoids going through `obj` to find it:'
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  id: totrans-3059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: 'We have called `hasOwnProperty()` generically (see [Generic Methods: Borrowing
    Methods from Prototypes](ch17_split_001.html#generic_method "Generic Methods:
    Borrowing Methods from Prototypes")).'
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall 3: The Special Property __proto__'
  id: totrans-3061
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In many JavaScript engines, the property `__proto__` (see [The Special Property
    __proto__](ch17_split_000.html#proto "The Special Property __proto__")) is special:
    getting it retrieves the prototype of an object, and setting it changes the prototype
    of an object. This is why the object can’t store map data in a property whose
    key is `''__proto__''`. If you want to allow the map key `''__proto__''`, you
    must escape it before using it as a property key:'
  id: totrans-3062
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  id: totrans-3063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: We also need to escape the escaped version of `'__proto__'` (etc.) to avoid
    clashes; that is, if we escape the key `'__proto__'` as `'__proto__%'`, then we
    also need to escape the key `'__proto__%'` so that it doesn’t replace a `'__proto__'`
    entry. That’s what happens in line (1).
  id: totrans-3064
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark S. Miller mentions the real-world implications of this pitfall in [an
    email](http://mzl.la/1fwnd1l):'
  id: totrans-3065
  prefs: []
  type: TYPE_NORMAL
- en: Think this exercise is academic and doesn’t arise in real systems? As observed
    at a support thread, until recently, on all non-IE browsers, if you typed “__proto__”
    at the beginning of a new Google Doc, your Google Doc would hang. This was tracked
    down to such a buggy use of an object as a string map.
  id: totrans-3066
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The dict Pattern: Objects Without Prototypes Are Better Maps'
  id: totrans-3067
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You create an object without a prototype like this:'
  id: totrans-3068
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  id: totrans-3069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: Such an object is a better map (dictionary) than a normal object, which is why
    this pattern is sometimes called the *dict pattern* (*dict* for *dictionary*).
    Let’s first examine normal objects and then find out why prototype-less objects
    are better maps.
  id: totrans-3070
  prefs: []
  type: TYPE_NORMAL
- en: Normal objects
  id: totrans-3071
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Usually, each object you create in JavaScript has at least `Object.prototype`
    in its prototype chain. The prototype of `Object.prototype` is `null`, so that’s
    where most prototype chains end:'
  id: totrans-3072
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE748]'
  id: totrans-3073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: Prototype-less objects
  id: totrans-3074
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Prototype-less objects have two advantages as maps:'
  id: totrans-3075
  prefs: []
  type: TYPE_NORMAL
- en: 'Inherited properties (pitfall #1) are not an issue anymore, simply because
    there are none. Therefore, you can now freely use the `in` operator to detect
    whether a property exists and brackets to read properties.'
  id: totrans-3076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soon, `__proto__` will be disabled. In ECMAScript 6, the special property `__proto__`
    will be disabled if `Object.prototype` is not in the prototype chain of an object.
    You can expect JavaScript engines to slowly migrate to this behavior, but it is
    not yet very common.
  id: totrans-3077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only disadvantage is that you’ll lose the services provided by `Object.prototype`.
    For example, a dict object can’t be automatically converted to a string anymore:'
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  id: totrans-3079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: But that is not a real disadvantage, because it isn’t safe to directly invoke
    methods on a dict object anyway.
  id: totrans-3080
  prefs: []
  type: TYPE_NORMAL
- en: Recommendation
  id: totrans-3081
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use the dict pattern for quick hacks and as a foundation for libraries. In (nonlibrary)
    production code, a library is preferable, because you can be sure to avoid all
    pitfalls. The next section lists a few such libraries.
  id: totrans-3082
  prefs: []
  type: TYPE_NORMAL
- en: Best Practices
  id: totrans-3083
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many applications for using objects as maps. If all property keys
    are known statically (at development time), then you just need to make sure that
    you ignore inheritance and look only at own properties. If arbitrary keys can
    be used, you should turn to a library to avoid the pitfalls mentioned in this
    section. Here are two examples:'
  id: totrans-3084
  prefs: []
  type: TYPE_NORMAL
- en: '[StringMap.js](http://bit.ly/1fwnp0E) by Google’s [es-lab](http://code.google.com/p/es-lab/)'
  id: totrans-3085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[stringmap.js](https://github.com/olov/stringmap) by Olov Lassus'
  id: totrans-3086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cheat Sheet: Working with Objects'
  id: totrans-3087
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section is a quick reference with pointers to more thorough explanations.
  id: totrans-3088
  prefs: []
  type: TYPE_NORMAL
- en: 'Object literals (see [Object Literals](ch17_split_000.html#object_literals
    "Object Literals")):'
  id: totrans-3089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE750]'
  id: totrans-3090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: 'Dot operator (.) (see [Dot Operator (.): Accessing Properties via Fixed Keys](ch17_split_000.html#dot_operator
    "Dot Operator (.): Accessing Properties via Fixed Keys")):'
  id: totrans-3091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE751]'
  id: totrans-3092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: 'Bracket operator ([]) (see [Bracket Operator ([]): Accessing Properties via
    Computed Keys](ch17_split_000.html#bracket_operator "Bracket Operator ([]): Accessing
    Properties via Computed Keys")):'
  id: totrans-3093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE752]'
  id: totrans-3094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: 'Getting and setting the prototype (see [Getting and Setting the Prototype](ch17_split_000.html#get_set_prototype
    "Getting and Setting the Prototype")):'
  id: totrans-3095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE753]'
  id: totrans-3096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: 'Iteration and detection of properties (see [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")):'
  id: totrans-3097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE754]'
  id: totrans-3098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: 'Getting and defining properties via descriptors (see [Getting and Defining
    Properties via Descriptors](ch17_split_000.html#functions_for_property_descriptors
    "Getting and Defining Properties via Descriptors")):'
  id: totrans-3099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE755]'
  id: totrans-3100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: 'Protecting objects (see [Protecting Objects](ch17_split_001.html#protecting_objects
    "Protecting Objects")):'
  id: totrans-3101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE756]'
  id: totrans-3102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: 'Methods of all objects (see [Methods of All Objects](ch17_split_001.html#methods_of_all_objects
    "Methods of All Objects")):'
  id: totrans-3103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE757]'
  id: totrans-3104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: '* * *'
  id: totrans-3105
  prefs: []
  type: TYPE_NORMAL
- en: ^([[15](ch17_split_001.html#id1038112)]) Using `map()` in this manner is a tip
    by Brandon Benvie (@benvie).
  id: totrans-3106
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18. Arrays
  id: totrans-3107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array is a map from indices (natural numbers, starting at zero) to arbitrary
    values. The values (the range of the map) are called the array’s *elements*. The
    most convenient way of creating an array is via an array literal. Such a literal
    enumerates the array elements; an element’s position implicitly specifies its
    index.
  id: totrans-3108
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will first cover basic array mechanisms, such as indexed
    access and the `length` property, and then go over array methods.
  id: totrans-3109
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  id: totrans-3110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section provides a quick overview of arrays. Details are explained later.
  id: totrans-3111
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first example, we create an array `arr` via an array literal (see [Creating
    Arrays](ch18.html#creating_arrays "Creating Arrays")) and access elements (see
    [Array Indices](ch18.html#array_indices "Array Indices")):'
  id: totrans-3112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  id: totrans-3113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: 'We can use the array property `length` (see [length](ch18.html#array_length
    "length")) to remove and append elements:'
  id: totrans-3114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  id: totrans-3115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: 'The array method `push()` provides another way of appending an element:'
  id: totrans-3116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  id: totrans-3117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: Arrays Are Maps, Not Tuples
  id: totrans-3118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ECMAScript standard specifies arrays as maps (dictionaries) from indices
    to values. In other words, arrays may not be contiguous and can have holes in
    them. For example:'
  id: totrans-3119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  id: totrans-3120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: 'The preceding array has a hole: there is no element at index 1\. [Holes in
    Arrays](ch18.html#array_holes "Holes in Arrays") explains holes in more detail.'
  id: totrans-3121
  prefs: []
  type: TYPE_NORMAL
- en: Note that most JavaScript engines optimize arrays without holes internally and
    store them contiguously.
  id: totrans-3122
  prefs: []
  type: TYPE_NORMAL
- en: Arrays Can Also Have Properties
  id: totrans-3123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arrays are still objects and can have object properties. Those are not considered
    part of the actual array; that is, they are not considered array elements:'
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  id: totrans-3125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: Creating Arrays
  id: totrans-3126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You create an array via an array literal:'
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  id: totrans-3128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: 'Trailing commas in arrays are ignored:'
  id: totrans-3129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  id: totrans-3130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: The Array Constructor
  id: totrans-3131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to use the constructor `Array`: you can create an empty
    array with a given length or an array whose elements are the given values. For
    this constructor, `new` is optional: invoking it as a normal function (without
    `new`) does the same as invoking it as a constructor.'
  id: totrans-3132
  prefs: []
  type: TYPE_NORMAL
- en: Creating an empty array with a given length
  id: totrans-3133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An empty array with a given length has only holes in it! Thus, it rarely makes
    sense to use this version of the constructor:'
  id: totrans-3134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  id: totrans-3135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: Some engines may preallocate contiguous memory when you call `Array()` in this
    manner, which may slightly improve performance. However, be sure that the increased
    verbosity and redundancy is worth it!
  id: totrans-3136
  prefs: []
  type: TYPE_NORMAL
- en: Initializing an array with elements (avoid!)
  id: totrans-3137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This way of invoking `Array` is similar to an array literal:'
  id: totrans-3138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  id: totrans-3139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: 'The problem is that you can’t create arrays with a single number in them, because
    that is interpreted as creating an array whose `length` is the number:'
  id: totrans-3140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  id: totrans-3141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: Multidimensional Arrays
  id: totrans-3142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need multiple dimensions for elements, you must nest arrays. When you
    create such nested arrays, the innermost arrays can grow as needed. But if you
    want direct access to elements, you need to at least create the outer arrays.
    In the following example, I create a three-by-three matrix for Tic-tac-toe. The
    matrix is completely filled with data (as opposed to letting rows grow as needed):'
  id: totrans-3143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  id: totrans-3144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: 'Here is the output:'
  id: totrans-3145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  id: totrans-3146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: 'I wanted the example to demonstrate the general case. Obviously, if a matrix
    is so small and has fixed dimensions, you can set it up via an array literal:'
  id: totrans-3147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  id: totrans-3148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: Array Indices
  id: totrans-3149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you are working with array indices, you must keep in mind the following
    limits:'
  id: totrans-3150
  prefs: []
  type: TYPE_NORMAL
- en: Indices are numbers *i* in the range 0 ≤ `i` < 2^(32)−1.
  id: totrans-3151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum length is 2^(32)−1.
  id: totrans-3152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Indices that are out of range are treated as normal property keys (strings!).
    They don’t show up as array elements and they don’t influence the property `length`.
    For example:'
  id: totrans-3153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE771]'
  id: totrans-3154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: The in Operator and Indices
  id: totrans-3155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `in` operator detects whether an object has a property with a given key.
    But it can also be used to determine whether a given element index exists in an
    array. For example:'
  id: totrans-3156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE772]'
  id: totrans-3157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: Deleting Array Elements
  id: totrans-3158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to deleting properties, the `delete` operator also deletes array
    elements. Deleting elements creates holes (the `length` property is not updated):'
  id: totrans-3159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE773]'
  id: totrans-3160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: 'You can also delete trailing array elements by decreasing an array’s length
    (see [length](ch18.html#array_length "length") for details). To remove elements
    without creating holes (i.e., the indices of subsequent elements are decremented),
    you use `Array.prototype.splice()` (see [Adding and Removing Elements (Destructive)](ch18.html#Array.prototype.push
    "Adding and Removing Elements (Destructive)")). In this example, we remove two
    elements at index 1:'
  id: totrans-3161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE774]'
  id: totrans-3162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: Array Indices in Detail
  id: totrans-3163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tip
  id: totrans-3164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is an advanced section. You normally don’t need to know the details explained
    here.
  id: totrans-3165
  prefs: []
  type: TYPE_NORMAL
- en: '*Array indices are not what they seem.* Until now, I have pretended that array
    indices are numbers. And that is how JavaScript engines implement arrays, internally.
    However, the ECMAScript specification sees indices differently. Paraphrasing [Section
    15.4](http://bit.ly/1fwoCFg):'
  id: totrans-3166
  prefs: []
  type: TYPE_NORMAL
- en: A property key `P` (a string) is an *array index* if and only if `ToString``(ToUint32(P))`
    is equal to `P` and `ToUint32(P)` is not equal to 2^(32)−1\. What this means is
    explained momentarily.
  id: totrans-3167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array property whose key is an array index is called an *element*.
  id: totrans-3168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words, in the world of the spec all values in brackets are converted
    to strings and interpreted as property keys, even numbers. The following interaction
    demonstrates this:'
  id: totrans-3169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  id: totrans-3170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE775]'
- en: 'To be an array index, a property key `P` (a string!) must be equal to the result
    of the following computation:'
  id: totrans-3171
  prefs: []
  type: TYPE_NORMAL
- en: Convert `P` to a number.
  id: totrans-3172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the number to a 32-bit unsigned integer.
  id: totrans-3173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the integer to a string.
  id: totrans-3174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That means that an array index must be a stringified integer *i* in the 32-bit
    range 0 ≤ *i* < 2^(32)−1\. The upper limit has been explicitly excluded in the
    spec (as quoted previously). It is reserved for the maximum length. To see how
    this definition works, let’s use the function `ToUint32()` from [32-bit Integers
    via Bitwise Operators](ch11.html#integers_via_bitwise_operators "32-bit Integers
    via Bitwise Operators").
  id: totrans-3175
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a string that doesn’t contain a number is always converted to 0, which,
    after stringification, is not equal to the string:'
  id: totrans-3176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  id: totrans-3177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: 'Second, a stringified integer that is out of range is also converted to a completely
    different integer, which is not equal to the string, after stringification:'
  id: totrans-3178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  id: totrans-3179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE777]'
- en: 'Third, stringified noninteger numbers are converted to integers, which are,
    again, different:'
  id: totrans-3180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  id: totrans-3181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: 'Note that the specification also enforces that array indices don’t have exponents:'
  id: totrans-3182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  id: totrans-3183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: 'And that they don’t have leading zeros:'
  id: totrans-3184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  id: totrans-3185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: length
  id: totrans-3186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic function of the `length` property is to track the highest index in
    an array:'
  id: totrans-3187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  id: totrans-3188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: 'Thus, `length` does not count the number of elements, so you’d have to write
    your own function for doing so. For example:'
  id: totrans-3189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE782]'
  id: totrans-3190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: 'To count elements (nonholes), we have used the fact that `forEach` skips holes.
    Here is the interaction:'
  id: totrans-3191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  id: totrans-3192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: Manually Increasing the Length of an Array
  id: totrans-3193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Manually increasing the length of an array has remarkably little effect on
    an array; it only creates holes:'
  id: totrans-3194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE784]'
  id: totrans-3195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: The last result has two commas at the end, because a trailing comma is optional
    and thus always ignored.
  id: totrans-3196
  prefs: []
  type: TYPE_NORMAL
- en: 'What we just did did not add any elements:'
  id: totrans-3197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  id: totrans-3198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: 'However, the `length` property does act as a pointer indicating where to insert
    new elements. For example:'
  id: totrans-3199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  id: totrans-3200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: 'Thus, setting the initial length of an array via the `Array` constructor creates
    an array that is completely empty:'
  id: totrans-3201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  id: totrans-3202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: Decreasing the Length of an Array
  id: totrans-3203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you decrease the length of an array, all elements at the new length and
    above are deleted:'
  id: totrans-3204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  id: totrans-3205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: Clearing an array
  id: totrans-3206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you set an array’s length to 0, then it becomes empty. That allows you to
    clear an array for someone else. For example:'
  id: totrans-3207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  id: totrans-3208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: 'Here’s the interaction:'
  id: totrans-3209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  id: totrans-3210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: 'Note, however, that this approach can be slow, because each array element is
    explicitly deleted. Ironically, creating a new empty array is often faster:'
  id: totrans-3211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  id: totrans-3212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: Clearing shared arrays
  id: totrans-3213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You need to be aware of the fact that setting an array’s length to zero affects
    everybody who shares the array:'
  id: totrans-3214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  id: totrans-3215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: 'In contrast, assigning an empty array doesn’t:'
  id: totrans-3216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  id: totrans-3217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: The Maximum Length
  id: totrans-3218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The maximum array length is 2^(32)−1:'
  id: totrans-3219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  id: totrans-3220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: Holes in Arrays
  id: totrans-3221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are maps from indices to values. That means that arrays can have *holes*,
    indices smaller than the length that are missing in the array. Reading an element
    at one of those indices returns `undefined`.
  id: totrans-3222
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-3223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is recommended that you avoid holes in arrays. JavaScript handles them inconsistently
    (i.e., some methods ignore them, other don’t). Thankfully, you normally don’t
    need to know how holes are handled: they are rarely useful and affect performance
    negatively.'
  id: totrans-3224
  prefs: []
  type: TYPE_NORMAL
- en: Creating Holes
  id: totrans-3225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create holes by assigning to array indices:'
  id: totrans-3226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE795]'
  id: totrans-3227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: 'You can also create holes by omitting values in array literals:'
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  id: totrans-3229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: Warning
  id: totrans-3230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You need two trailing commas to create a trailing hole, because the last comma
    is always ignored:'
  id: totrans-3231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  id: totrans-3232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE797]'
- en: Sparse Arrays Versus Dense Arrays
  id: totrans-3233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section examines the differences between a hole and `undefined` as an element.
    Given that reading a hole returns `undefined`, both are very similar.
  id: totrans-3234
  prefs: []
  type: TYPE_NORMAL
- en: 'An array with holes is called *sparse*. An array without holes is called *dense*.
    Dense arrays are contiguous and have an element at each index—starting at zero,
    and ending at `length` − 1\. Let’s compare the following two arrays, a sparse
    array and a dense array. The two are very similar:'
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE798]'
  id: totrans-3236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: 'A hole is almost like having the element `undefined` at the same index. Both
    arrays have the same length:'
  id: totrans-3237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE799]'
  id: totrans-3238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE799]'
- en: 'But the sparse array does not have an element at index 0:'
  id: totrans-3239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE800]'
  id: totrans-3240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: 'Iteration via `for` is the same for both arrays:'
  id: totrans-3241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE801]'
  id: totrans-3242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE801]'
- en: 'Iteration via `forEach` skips the holes, but not the undefined elements:'
  id: totrans-3243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE802]'
  id: totrans-3244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: Which Operations Ignore Holes, and Which Consider Them?
  id: totrans-3245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some operations involving arrays ignore holes, while others consider them. This
    sections explains the details.
  id: totrans-3246
  prefs: []
  type: TYPE_NORMAL
- en: Array iteration methods
  id: totrans-3247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`forEach()` skips holes:'
  id: totrans-3248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE803]'
  id: totrans-3249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: '`every()` also skips holes (similarly: `some()`):'
  id: totrans-3250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE804]'
  id: totrans-3251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: '`map()` skips, but preserves holes:'
  id: totrans-3252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE805]'
  id: totrans-3253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE805]'
- en: '`filter()` eliminates holes:'
  id: totrans-3254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE806]'
  id: totrans-3255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: Other array methods
  id: totrans-3256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`join()` converts holes, `undefined`s, and `null`s to empty strings:'
  id: totrans-3257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE807]'
  id: totrans-3258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: '`sort()` preserves holes while sorting:'
  id: totrans-3259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  id: totrans-3260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: The for-in loop
  id: totrans-3261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `for-in` loop correctly lists property keys (which are a superset of array
    indices):'
  id: totrans-3262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE809]'
  id: totrans-3263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: Function.prototype.apply()
  id: totrans-3264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`apply()` turns each hole into an argument whose value is `undefined`. The
    following interaction demonstrates this: function `f()` returns its arguments
    as an array. When we pass `apply()` an array with three holes in order to invoke
    `f()`, the latter receives three `undefined` arguments:'
  id: totrans-3265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE810]'
  id: totrans-3266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: 'That means that we can use `apply()` to create an array with `undefined`s:'
  id: totrans-3267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE811]'
  id: totrans-3268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE811]'
- en: Warning
  id: totrans-3269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`apply()` translates holes to `undefined`s in empty arrays, but it can’t be
    used to plug holes in arbitrary arrays (which may or may not contain holes). Take,
    for example, the arbitrary array `[2]`:'
  id: totrans-3270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE812]'
  id: totrans-3271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: The array does not contain any holes, so `apply()` should return the same array.
    Instead, it returns an empty array with length 2 (all it contains are two holes).
    That is because `Array()` interprets single numbers as array lengths, not as array
    elements.
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
- en: Removing Holes from Arrays
  id: totrans-3273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have seen, `filter()` removes holes:'
  id: totrans-3274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE813]'
  id: totrans-3275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE813]'
- en: 'Use a custom function to convert holes to `undefined`s in arbitrary arrays:'
  id: totrans-3276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE814]'
  id: totrans-3277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: 'Using the function:'
  id: totrans-3278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE815]'
  id: totrans-3279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE815]'
- en: Array Constructor Method
  id: totrans-3280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Array.isArray(obj)`'
  id: totrans-3281
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns `true` if `obj` is an array. It correctly handles objects that cross
    *realms* (windows or frames)—as opposed to `instanceof` (see [Pitfall: crossing
    realms (frames or windows)](ch17_split_001.html#cross-realm_instanceof "Pitfall:
    crossing realms (frames or windows)")).'
  id: totrans-3282
  prefs: []
  type: TYPE_NORMAL
- en: Array Prototype Methods
  id: totrans-3283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following sections, array prototype methods are grouped by functionality.
    For each of the subsections, I mention whether the methods are *destructive* (they
    change the arrays that they are invoked on) or *nondestructive* (they don’t modify
    their receivers; such methods often return new arrays).
  id: totrans-3284
  prefs: []
  type: TYPE_NORMAL
- en: Adding and Removing Elements (Destructive)
  id: totrans-3285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the methods in this section are destructive:'
  id: totrans-3286
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.shift()`'
  id: totrans-3287
  prefs: []
  type: TYPE_NORMAL
- en: 'Removes the element at index 0 and returns it. The indices of subsequent elements
    are decremented by 1:'
  id: totrans-3288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE816]'
  id: totrans-3289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE816]'
- en: '`Array.prototype.unshift(elem1?, elem2?, ...)`'
  id: totrans-3290
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepends the given elements to the array. It returns the new length:'
  id: totrans-3291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE817]'
  id: totrans-3292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: '`Array.prototype.pop()`'
  id: totrans-3293
  prefs: []
  type: TYPE_NORMAL
- en: 'Removes the last element of the array and returns it:'
  id: totrans-3294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE818]'
  id: totrans-3295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE818]'
- en: '`Array.prototype.push(elem1?, elem2?, ...)`'
  id: totrans-3296
  prefs: []
  type: TYPE_NORMAL
- en: 'Adds the given elements to the end of the array. It returns the new length:'
  id: totrans-3297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE819]'
  id: totrans-3298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: '`apply()` (see [Function.prototype.apply(thisValue, argArray)](ch17_split_000.html#oop_apply
    "Function.prototype.apply(thisValue, argArray)")) enables you to destructively
    append an array `arr2` to another array `arr1`:'
  id: totrans-3299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE820]'
  id: totrans-3300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: '`Array.prototype.splice(start, deleteCount?, elem1?, elem2?, ...)`'
  id: totrans-3301
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting at `start`, removes `deleteCount` elements and inserts the elements
    given. In other words, you are replacing the `deleteCount` elements at position
    `start` with `elem1`, `elem2`, and so on. The method returns the elements that
    have been removed:'
  id: totrans-3302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE821]'
  id: totrans-3303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: 'Special parameter values:'
  id: totrans-3304
  prefs: []
  type: TYPE_NORMAL
- en: '`start` can be negative, in which case it is added to the length to determine
    the start index. Thus, `-1` refers the last element, and so on.'
  id: totrans-3305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteCount` is optional. If it is omitted (along with all subsequent arguments),
    then all elements at and after index `start` are removed.'
  id: totrans-3306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we remove all elements after and including the second-to-last
    index:'
  id: totrans-3307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE822]'
  id: totrans-3308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE822]'
- en: Sorting and Reversing Elements (Destructive)
  id: totrans-3309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These methods are also destructive:'
  id: totrans-3310
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.reverse()`'
  id: totrans-3311
  prefs: []
  type: TYPE_NORMAL
- en: 'Reverses the order of the elements in the array and returns a reference to
    the original (modified) array:'
  id: totrans-3312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]'
  id: totrans-3313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE823]'
- en: '`Array.prototype.sort(compareFunction?)`'
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorts the array and returns it:'
  id: totrans-3315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE824]'
  id: totrans-3316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE824]'
- en: 'Keep in mind that sorting compares values by converting them to strings, which
    means that numbers are not sorted numerically:'
  id: totrans-3317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE825]'
  id: totrans-3318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE825]'
- en: 'You can fix this by providing the optional parameter `compareFunction`, which
    controls how sorting is done. It has the following signature:'
  id: totrans-3319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  id: totrans-3320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE826]'
- en: 'This function compares `a` and `b` and returns:'
  id: totrans-3321
  prefs: []
  type: TYPE_NORMAL
- en: An integer less than zero (e.g., `-1`) if `a` is less than `b`
  id: totrans-3322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero if `a` is equal to `b`
  id: totrans-3323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer greater than zero (e.g., `1`) if `a` is greater than `b`
  id: totrans-3324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing Numbers
  id: totrans-3325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For numbers, you can simply return `a-b`, but that can cause numeric overflow.
    To prevent that from happening, you need more verbose code:'
  id: totrans-3326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  id: totrans-3327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE827]'
- en: 'I don’t like nested conditional operators. But in this case, the code is so
    much less verbose that I’m tempted to recommend it:'
  id: totrans-3328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE828]'
  id: totrans-3329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE828]'
- en: 'Using the function:'
  id: totrans-3330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE829]'
  id: totrans-3331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE829]'
- en: Comparing Strings
  id: totrans-3332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For strings, you can use `String.prototype.localeCompare` (see [Comparing Strings](ch12.html#comparing_strings
    "Comparing Strings")):'
  id: totrans-3333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE830]'
  id: totrans-3334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE830]'
- en: Comparing Objects
  id: totrans-3335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The parameter `compareFunction` is also useful for sorting objects:'
  id: totrans-3336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE831]'
  id: totrans-3337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE831]'
- en: 'With `compareNames` as the compare function, `arr` is sorted by `name`:'
  id: totrans-3338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  id: totrans-3339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE832]'
- en: Concatenating, Slicing, Joining (Nondestructive)
  id: totrans-3340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following methods perform various nondestructive operations on arrays:'
  id: totrans-3341
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.concat(arr1?, arr2?, ...)`'
  id: totrans-3342
  prefs: []
  type: TYPE_NORMAL
- en: 'Creates a new array that contains all the elements of the receiver, followed
    by all the elements of the array `arr1`, and so on. If one of the parameters is
    not an array, then it is added to the result as an element (for example, the first
    argument, `''c''`, here):'
  id: totrans-3343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE833]'
  id: totrans-3344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE833]'
- en: 'The array that `concat()` is invoked on is not changed:'
  id: totrans-3345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE834]'
  id: totrans-3346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE834]'
- en: '`Array.prototype.slice(begin?, end?)`'
  id: totrans-3347
  prefs: []
  type: TYPE_NORMAL
- en: 'Copies array elements into a new array, starting at `begin`, until and excluding
    the element at `end`:'
  id: totrans-3348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]'
  id: totrans-3349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE835]'
- en: 'If `end` is missing, the array length is used:'
  id: totrans-3350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE836]'
  id: totrans-3351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE836]'
- en: 'If both indices are missing, the array is copied:'
  id: totrans-3352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE837]'
  id: totrans-3353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE837]'
- en: 'If either of the indices is negative, the array length is added to it. Thus,
    `-1` refers to the last element, and so on:'
  id: totrans-3354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE838]'
  id: totrans-3355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE838]'
- en: '`Array.prototype.join(separator?)`'
  id: totrans-3356
  prefs: []
  type: TYPE_NORMAL
- en: 'Creates a string by applying `toString()` to all array elements and putting
    the string in `separator` between the results. If `separator` is omitted, `'',''`
    is used:'
  id: totrans-3357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE839]'
  id: totrans-3358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE839]'
- en: '`join()` converts `undefined` and `null` to empty strings:'
  id: totrans-3359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE840]'
  id: totrans-3360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE840]'
- en: 'Holes in arrays are also converted to empty strings:'
  id: totrans-3361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE841]'
  id: totrans-3362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE841]'
- en: Searching for Values (Nondestructive)
  id: totrans-3363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following methods search for values in arrays:'
  id: totrans-3364
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.indexOf(searchValue, startIndex?)`'
  id: totrans-3365
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches the array for `searchValue`, starting at `startIndex`. It returns
    the index of the first occurrence or –1 if nothing is found. If `startIndex` is
    negative, the array length is added to it; if it is missing, the whole array is
    searched:'
  id: totrans-3366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE842]'
  id: totrans-3367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE842]'
- en: 'Strict equality (seev[Equality Operators: === Versus ==](ch09.html#equality_operators
    "Equality Operators: === Versus ==")) is used for the search, which means that
    `indexOf()` can’t find `NaN`:'
  id: totrans-3368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE843]'
  id: totrans-3369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE843]'
- en: '`Array.prototype.lastIndexOf(searchElement, startIndex?)`'
  id: totrans-3370
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches the array for `searchElement`, starting at `startIndex`, backward.
    It returns the index of the first occurrence or –1 if nothing is found. If `startIndex`
    is negative, the array length is added to it; if it is missing, the whole array
    is searched. Strict equality (see [Equality Operators: === Versus ==](ch09.html#equality_operators
    "Equality Operators: === Versus ==")) is used for the search:'
  id: totrans-3371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  id: totrans-3372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE844]'
- en: Iteration (Nondestructive)
  id: totrans-3373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iteration methods use a function to iterate over an array. I distinguish three
    kinds of iteration methods, all of which are nondestructive: *examination methods*
    mainly observe the content of an array; *transformation methods* derive a new
    array from the receiver; and *reduction methods* compute a result based on the
    receiver’s elements.'
  id: totrans-3374
  prefs: []
  type: TYPE_NORMAL
- en: Examination Methods
  id: totrans-3375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each method described in this section looks like this:'
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE845]'
  id: totrans-3377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE845]'
- en: 'Such a method takes the following parameters:'
  id: totrans-3378
  prefs: []
  type: TYPE_NORMAL
- en: '`callback` is its first parameter, a function that it calls. Depending on the
    examination method, the callback returns a boolean or nothing. It has the following
    signature:'
  id: totrans-3379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE846]'
  id: totrans-3380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE846]'
- en: '`element` is an array element for `callback` to process, `index` is the element’s
    index, and `array` is the array that `examinationMethod` has been invoked on.'
  id: totrans-3381
  prefs: []
  type: TYPE_NORMAL
- en: '`thisValue` allows you to configure the value of `this` inside `callback`.'
  id: totrans-3382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And now for the examination methods whose signatures I have just described:'
  id: totrans-3383
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.forEach(callback, thisValue?)`'
  id: totrans-3384
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterates over the elements of an array:'
  id: totrans-3385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  id: totrans-3386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE847]'
- en: '`Array.prototype.every(callback, thisValue?)`'
  id: totrans-3387
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if the callback returns `true` for every element. It stops iteration
    as soon as the callback returns `false`. Note that not returning a value leads
    to an implicit return of `undefined`, which `every()` interprets as `false`. `every()`
    works like the universal quantifier (“for all”).
  id: totrans-3388
  prefs: []
  type: TYPE_NORMAL
- en: 'This example checks whether every number in the array is even:'
  id: totrans-3389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE848]'
  id: totrans-3390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE848]'
- en: 'If the array is empty, the result is `true` (and `callback` is not called):'
  id: totrans-3391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE849]'
  id: totrans-3392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE849]'
- en: '`Array.prototype.some(callback, thisValue?)`'
  id: totrans-3393
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if the callback returns `true` for at least one element. It stops
    iteration as soon as the callback returns `true`. Note that not returning a value
    leads to an implicit return of `undefined`, which `some` interprets as `false`.
    `some()` works like the existential quantifier (“there exists”).
  id: totrans-3394
  prefs: []
  type: TYPE_NORMAL
- en: 'This example checks whether there is an even number in the array:'
  id: totrans-3395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE850]'
  id: totrans-3396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE850]'
- en: 'If the array is empty, the result is `false` (and `callback` is not called):'
  id: totrans-3397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE851]'
  id: totrans-3398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE851]'
- en: 'One potential pitfall of `forEach()` is that it does not support `break` or
    something similar to prematurely abort the loop. If you need to do that, you can
    use `some()`:'
  id: totrans-3399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE852]'
  id: totrans-3400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE852]'
- en: '`some()` returns `true` if a break happened, and `false` otherwise. This allows
    you to react differently depending on whether iterating finished successfully
    (something that is slightly tricky with `for` loops).'
  id: totrans-3401
  prefs: []
  type: TYPE_NORMAL
- en: Transformation Methods
  id: totrans-3402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transformation methods take an input array and produce an output array, while
    the callback controls how the output is produced. The callback has the same signature
    as for examination:'
  id: totrans-3403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  id: totrans-3404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE853]'
- en: 'There are two transformation methods:'
  id: totrans-3405
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.map(callback, thisValue?)`'
  id: totrans-3406
  prefs: []
  type: TYPE_NORMAL
- en: 'Each output array element is the result of applying `callback` to an input
    element. For example:'
  id: totrans-3407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE854]'
  id: totrans-3408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE854]'
- en: '`Array.prototype.filter(callback, thisValue?)`'
  id: totrans-3409
  prefs: []
  type: TYPE_NORMAL
- en: 'The output array contains only those input elements for which `callback` returns
    `true`. For example:'
  id: totrans-3410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE855]'
  id: totrans-3411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE855]'
- en: Reduction Methods
  id: totrans-3412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For reducing, the callback has a different signature:'
  id: totrans-3413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  id: totrans-3414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE856]'
- en: 'The parameter `previousValue` is the value previously returned by the callback.
    When the callback is first called, there are two possibilities (the descriptions
    are for `Array.prototype.reduce()`; differences with `reduceRight()` are mentioned
    in parentheses):'
  id: totrans-3415
  prefs: []
  type: TYPE_NORMAL
- en: 'An explicit `initialValue` has been provided. Then `previousValue` is `initialValue`,
    and `currentElement` is the first array element (`reduceRight`: the last array
    element).'
  id: totrans-3416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No explicit `initialValue` has been provided. Then `previousValue` is the first
    array element, and `currentElement` is the second array element (`reduceRight`:
    the last array element and second-to-last array element).'
  id: totrans-3417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two reduction methods:'
  id: totrans-3418
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.reduce(callback, initialValue?)`'
  id: totrans-3419
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterates from left to right and invokes the callback as previously sketched.
    The result of the method is the last value returned by the callback. This example
    computes the sum of all array elements:'
  id: totrans-3420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  id: totrans-3421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE857]'
- en: 'If you invoke `reduce` on an array with a single element, that element is returned:'
  id: totrans-3422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE858]'
  id: totrans-3423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE858]'
- en: 'If you invoke `reduce` on an empty array, you must specify `initialValue`,
    otherwise you get an exception:'
  id: totrans-3424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE859]'
  id: totrans-3425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE859]'
- en: '`Array.prototype.reduceRight(callback, initialValue?)`'
  id: totrans-3426
  prefs: []
  type: TYPE_NORMAL
- en: Works the same as `reduce()`, but iterates from right to left.
  id: totrans-3427
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-3428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many functional programming languages, `reduce` is known as `fold` or `foldl`
    (left fold) and `reduceRight` is known as `foldr` (right fold).
  id: totrans-3429
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to look at the `reduce` method is that it implements an n-ary operator
    `OP`:'
  id: totrans-3430
  prefs: []
  type: TYPE_NORMAL
- en: '`OP[1≤i≤n]` x[i]'
  id: totrans-3431
  prefs: []
  type: TYPE_NORMAL
- en: 'via a series of applications of a binary operator `op2`:'
  id: totrans-3432
  prefs: []
  type: TYPE_NORMAL
- en: (...(x[1] `op2` x[2]) `op2` ...) `op2` x[n]
  id: totrans-3433
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s what happened in the previous code example: we implemented an n-ary
    sum operator for arrays via JavaScript’s binary plus operator.'
  id: totrans-3434
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s examine the two iteration directions via the following
    function:'
  id: totrans-3435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE860]'
  id: totrans-3436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE860]'
- en: 'As expected, `reduce()` iterates from left to right:'
  id: totrans-3437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE861]'
  id: totrans-3438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE861]'
- en: 'And `reduceRight()` iterates from right to left:'
  id: totrans-3439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  id: totrans-3440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE862]'
- en: 'Pitfall: Array-Like Objects'
  id: totrans-3441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some objects in JavaScript look like an array, but they aren’t one. That usually
    means that they have indexed access and a `length` property, but none of the array
    methods. Examples include the special variable `arguments`, DOM node lists, and
    strings. [Array-Like Objects and Generic Methods](ch17_split_001.html#array-like_objects
    "Array-Like Objects and Generic Methods") gives tips for working with array-like
    objects.
  id: totrans-3442
  prefs: []
  type: TYPE_NORMAL
- en: 'Best Practices: Iterating over Arrays'
  id: totrans-3443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To iterate over an array `arr`, you have two options:'
  id: totrans-3444
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `for` loop (see [for](ch13.html#for_loop "for")):'
  id: totrans-3445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE863]'
  id: totrans-3446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE863]'
- en: 'One of the array iteration methods (see [Iteration (Nondestructive)](ch18.html#array_iteration_methods
    "Iteration (Nondestructive)")). For example, `forEach()`:'
  id: totrans-3447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE864]'
  id: totrans-3448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE864]'
- en: Do not use the `for-in` loop (see [for-in](ch13.html#for-in "for-in")) to iterate
    over arrays. It iterates over indices, not over values. And it includes the keys
    of normal properties while doing so, including inherited ones.
  id: totrans-3449
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19. Regular Expressions
  id: totrans-3450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter gives an overview of the JavaScript API for regular expressions.
    It assumes that you are roughly familiar with how they work. If you are not, there
    are many good tutorials on the Web. Two examples are:'
  id: totrans-3451
  prefs: []
  type: TYPE_NORMAL
- en: '[Regular-Expressions.info](http://www.regular-expressions.info/) by Jan Goyvaerts'
  id: totrans-3452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JavaScript Regular Expression Enlightenment](http://bit.ly/1fwoQMs) by Cody
    Lindley'
  id: totrans-3453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular Expression Syntax
  id: totrans-3454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The terms used here closely reflect the grammar in the ECMAScript specification.
    I sometimes deviate to make things easier to understand.
  id: totrans-3455
  prefs: []
  type: TYPE_NORMAL
- en: 'Atoms: General'
  id: totrans-3456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax for general atoms is as follows:'
  id: totrans-3457
  prefs: []
  type: TYPE_NORMAL
- en: Special characters
  id: totrans-3458
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the following characters have special meaning:'
  id: totrans-3459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE865]'
  id: totrans-3460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE865]'
- en: 'You can escape them by prefixing a backslash. For example:'
  id: totrans-3461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE866]'
  id: totrans-3462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE866]'
- en: 'Additional special characters are:'
  id: totrans-3463
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside a character class `[...]`:'
  id: totrans-3464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE867]'
  id: totrans-3465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE867]'
- en: 'Inside a group that starts with a question mark `(?...)`:'
  id: totrans-3466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE868]'
  id: totrans-3467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE868]'
- en: The angle brackets are used only by the XRegExp library (see [Chapter 30](ch30.html
    "Chapter 30. Libraries")), to name groups.
  id: totrans-3468
  prefs: []
  type: TYPE_NORMAL
- en: Pattern characters
  id: totrans-3469
  prefs: []
  type: TYPE_NORMAL
- en: All characters except the aforementioned special ones match themselves.
  id: totrans-3470
  prefs: []
  type: TYPE_NORMAL
- en: '`.` (dot)'
  id: totrans-3471
  prefs: []
  type: TYPE_NORMAL
- en: 'Matches any JavaScript character (UTF-16 code unit) except line terminators
    (newline, carriage return, etc.). To really match any character, use `[\s\S]`.
    For example:'
  id: totrans-3472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE869]'
  id: totrans-3473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE869]'
- en: Character escapes (match single characters)
  id: totrans-3474
  prefs: []
  type: TYPE_NORMAL
- en: Specific control characters include `\f` (form feed), `\n` (line feed, newline),
    `\r` (carriage return), `\t` (horizontal tab), and `\v` (vertical tab).
  id: totrans-3475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\0` matches the NUL character (`\u0000`).'
  id: totrans-3476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any control character: `\cA` – `\cZ`.'
  id: totrans-3477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unicode character escapes: `\u0000` – `\xFFFF` (Unicode code units; see [Chapter 24](ch24.html
    "Chapter 24. Unicode and JavaScript")).'
  id: totrans-3478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hexadecimal character escapes: `\x00` – `\xFF`.'
  id: totrans-3479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character class escapes (match one of a set of characters)
  id: totrans-3480
  prefs: []
  type: TYPE_NORMAL
- en: 'Digits: `\d` matches any digit (same as `[0-9]`); `\D` matches any nondigit
    (same as `[^0-9]`).'
  id: totrans-3481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alphanumeric characters: `\w` matches any Latin alphanumeric character plus
    underscore (same as `[A-Za-z0-9_]`); `\W` matches all characters not matched by
    `\w`.'
  id: totrans-3482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whitespace: `\s` matches whitespace characters (space, tab, line feed, carriage
    return, form feed, all Unicode spaces, etc.); `\S` matches all nonwhitespace characters.'
  id: totrans-3483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Atoms: Character Classes'
  id: totrans-3484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax for character classes is as follows:'
  id: totrans-3485
  prefs: []
  type: TYPE_NORMAL
- en: '`[«charSpecs»]` matches any single character that matches at least one of the
    `charSpecs`.'
  id: totrans-3486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[^«charSpecs»]` matches any single character that does not match any of the
    `charSpecs`.'
  id: totrans-3487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following constructs are all character specifications:'
  id: totrans-3488
  prefs: []
  type: TYPE_NORMAL
- en: 'Source characters match themselves. Most characters are source characters (even
    many characters that are special elsewhere). Only three characters are not:'
  id: totrans-3489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE870]'
  id: totrans-3490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE870]'
- en: As usual, you escape via a backslash. If you want to match a dash without escaping
    it, it must be the first character after the opening bracket or the right side
    of a range, as described shortly.
  id: totrans-3491
  prefs: []
  type: TYPE_NORMAL
- en: 'Class escapes: Any of the character escapes and character class escapes listed
    previously are allowed. There is one additional escape:'
  id: totrans-3492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Backspace (`\b`): Outside a character class, `\b` matches word boundaries.
    Inside a character class, it matches the control character *backspace*.'
  id: totrans-3493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges comprise a source character or a class escape, followed by a dash (`-`),
    followed by a source character or a class escape.
  id: totrans-3494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate using character classes, this example parses a date formatted
    in the ISO 8601 standard:'
  id: totrans-3495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE871]'
  id: totrans-3496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE871]'
- en: 'And here is the interaction:'
  id: totrans-3497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE872]'
  id: totrans-3498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE872]'
- en: 'Atoms: Groups'
  id: totrans-3499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax for groups is as follows:'
  id: totrans-3500
  prefs: []
  type: TYPE_NORMAL
- en: '`(«pattern»)` is a capturing group. Whatever is matched by `pattern` can be
    accessed via backreferences or as the result of a match operation.'
  id: totrans-3501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(?:«pattern»)` is a noncapturing group. `pattern` is still matched against
    the input, but not saved as a capture. Therefore, the group does not have a number
    you can refer to (e.g., via a backreference).'
  id: totrans-3502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\1`, `\2`, and so on are known as *backreferences*; they refer back to a previously
    matched group. The number after the backslash can be any integer greater than
    or equal to 1, but the first digit must not be 0.'
  id: totrans-3503
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, a backreference guarantees the same amount of a’s before and
    after the dash:'
  id: totrans-3504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  id: totrans-3505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE873]'
- en: 'This example uses a backreference to match an HTML tag (obviously, you should
    normally use a proper parser to process HTML):'
  id: totrans-3506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  id: totrans-3507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE874]'
- en: Quantifiers
  id: totrans-3508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any atom (including character classes and groups) can be followed by a quantifier:'
  id: totrans-3509
  prefs: []
  type: TYPE_NORMAL
- en: '`?` means match never or once.'
  id: totrans-3510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` means match zero or more times.'
  id: totrans-3511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+` means match one or more times.'
  id: totrans-3512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n}` means match exactly `n` times.'
  id: totrans-3513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n,}` means match `n` or more times.'
  id: totrans-3514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n,m}` means match at least `n`, at most `m`, times.'
  id: totrans-3515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, quantifiers are *greedy*; that is, they match as much as possible.
    You can get *reluctant* matching (as little as possible) by suffixing any of the
    preceding quantifiers (including the ranges in curly braces) with a question mark
    (`?`). For example:'
  id: totrans-3516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE875]'
  id: totrans-3517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE875]'
- en: 'Thus, `.*?` is a useful pattern for matching everything until the next occurrence
    of the following atom. For example, the following is a more compact version of
    the regular expression for HTML tags just shown (which used `[^<]*` instead of
    `.*?`):'
  id: totrans-3518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE876]'
  id: totrans-3519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE876]'
- en: Assertions
  id: totrans-3520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assertions, shown in the following list, are checks about the current position
    in the input:'
  id: totrans-3521
  prefs: []
  type: TYPE_NORMAL
- en: '| `^` | Matches only at the beginning of the input. |'
  id: totrans-3522
  prefs: []
  type: TYPE_TB
- en: '| `$` | Matches only at the end of the input. |'
  id: totrans-3523
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Matches only at a word boundary. Don’t confuse with `[\b]`, which
    matches a backspace. |'
  id: totrans-3524
  prefs: []
  type: TYPE_TB
- en: '| `\B` | Matches only if not at a word boundary. |'
  id: totrans-3525
  prefs: []
  type: TYPE_TB
- en: '| `(?=«pattern»)` | Positive lookahead: Matches only if `pattern` matches what
    comes next. `pattern` is used only to look ahead, but otherwise ignored. |'
  id: totrans-3526
  prefs: []
  type: TYPE_TB
- en: '| `(?!«pattern»)` | Negative lookahead: Matches only if `pattern` does not
    match what comes next. `pattern` is used only to look ahead, but otherwise ignored.
    |'
  id: totrans-3527
  prefs: []
  type: TYPE_TB
- en: 'This example matches a word boundary via `\b`:'
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE877]'
  id: totrans-3529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE877]'
- en: 'This example matches the inside of a word via `\B`:'
  id: totrans-3530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  id: totrans-3531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE878]'
- en: Note
  id: totrans-3532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lookbehind is not supported. [Manually Implementing Lookbehind](ch19.html#regexp-look-behind
    "Manually Implementing Lookbehind") explains how to implement it manually.
  id: totrans-3533
  prefs: []
  type: TYPE_NORMAL
- en: Disjunction
  id: totrans-3534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A disjunction operator (`|`) separates two alternatives; either of the alternatives
    must match for the disjunction to match. The alternatives are atoms (optionally
    including quantifiers).
  id: totrans-3535
  prefs: []
  type: TYPE_NORMAL
- en: 'The operator binds very weakly, so you have to be careful that the alternatives
    don’t extend too far. For example, the following regular expression matches all
    strings that either start with `aa` or end with `bb`:'
  id: totrans-3536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  id: totrans-3537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE879]'
- en: 'In other words, the disjunction binds more weakly than even `^` and `$` and
    the two alternatives are `^aa` and `bb$`. If you want to match the two strings
    `''aa''` and `''bb''`, you need parentheses:'
  id: totrans-3538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE880]'
  id: totrans-3539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE880]'
- en: 'Similarly, if you want to match the strings `''aab''` and `''abb''`:'
  id: totrans-3540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE881]'
  id: totrans-3541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE881]'
- en: Unicode and Regular Expressions
  id: totrans-3542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript’s regular expressions have only very limited support for Unicode.
    Especially when it comes to code points in the astral planes, you have to be careful.
    [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript") explains the details.
  id: totrans-3543
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Regular Expression
  id: totrans-3544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a regular expression via either a literal or a constructor and
    configure how it works via flags.
  id: totrans-3545
  prefs: []
  type: TYPE_NORMAL
- en: Literal Versus Constructor
  id: totrans-3546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to create a regular expression: you can use a literal or
    the constructor `RegExp`:'
  id: totrans-3547
  prefs: []
  type: TYPE_NORMAL
- en: '| Literal | `/xyz/i` | Compiled at load time |'
  id: totrans-3548
  prefs: []
  type: TYPE_TB
- en: '| Constructor (second argument is optional) | `new RegExp(''xyz'', ''i'')`
    | Compiled at runtime |'
  id: totrans-3549
  prefs: []
  type: TYPE_TB
- en: 'A literal and a constructor differ in when they are compiled:'
  id: totrans-3550
  prefs: []
  type: TYPE_NORMAL
- en: 'The literal is compiled at load time. The following code will cause an exception
    when it is evaluated:'
  id: totrans-3551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE882]'
  id: totrans-3552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE882]'
- en: 'The constructor compiles the regular expression when it is called. The following
    code will not cause an exception, but calling `foo()` will:'
  id: totrans-3553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE883]'
  id: totrans-3554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE883]'
- en: Thus, you should normally use literals, but you need the constructor if you
    want to dynamically assemble a regular expression.
  id: totrans-3555
  prefs: []
  type: TYPE_NORMAL
- en: Flags
  id: totrans-3556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Flags are a suffix of regular expression literals and a parameter of regular
    expression constructors; they modify the matching behavior of regular expressions.
    The following flags exist:'
  id: totrans-3557
  prefs: []
  type: TYPE_NORMAL
- en: '| Short name | Long name | Description |'
  id: totrans-3558
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3559
  prefs: []
  type: TYPE_TB
- en: '| `g` | `global` | The given regular expression is matched multiple times.
    Influences several methods, especially `replace()`. |'
  id: totrans-3560
  prefs: []
  type: TYPE_TB
- en: '| `i` | `ignoreCase` | Case is ignored when trying to match the given regular
    expression. |'
  id: totrans-3561
  prefs: []
  type: TYPE_TB
- en: '| `m` | `multiline` | In multiline mode, the begin operator `^` and the end
    operator `$` match each line, instead of the complete input string. |'
  id: totrans-3562
  prefs: []
  type: TYPE_TB
- en: The short name is used for literal prefixes and constructor parameters (see
    examples in the next section). The long name is used for properties of a regular
    expression that indicate what flags were set during its creation.
  id: totrans-3563
  prefs: []
  type: TYPE_NORMAL
- en: Instance Properties of Regular Expressions
  id: totrans-3564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regular expressions have the following instance properties:'
  id: totrans-3565
  prefs: []
  type: TYPE_NORMAL
- en: 'Flags: boolean values indicating what flags are set:'
  id: totrans-3566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`global`: Is flag `/g` set?'
  id: totrans-3567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignoreCase`: Is flag `/i` set?'
  id: totrans-3568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiline`: Is flag `/m` set?'
  id: totrans-3569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data for matching multiple times (flag `/g` is set):'
  id: totrans-3570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastIndex` is the index where to continue the search next time.'
  id: totrans-3571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of accessing the instance properties for flags:'
  id: totrans-3572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE884]'
  id: totrans-3573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE884]'
- en: Examples of Creating Regular Expressions
  id: totrans-3574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we create the same regular expression first with a literal,
    then with a constructor, and use the `test()` method to determine whether it matches
    a string:'
  id: totrans-3575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE885]'
  id: totrans-3576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE885]'
- en: 'In this example, we create a regular expression that ignores case (flag `/i`):'
  id: totrans-3577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE886]'
  id: totrans-3578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE886]'
- en: 'RegExp.prototype.test: Is There a Match?'
  id: totrans-3579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `test()` method checks whether a regular expression, `regex`, matches a
    string, `str`:'
  id: totrans-3580
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE887]'
  id: totrans-3581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE887]'
- en: '`test()` operates differently depending on whether the flag `/g` is set or
    not.'
  id: totrans-3582
  prefs: []
  type: TYPE_NORMAL
- en: 'If the flag `/g` is not set, then the method checks whether there is a match
    somewhere in `str`. For example:'
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  id: totrans-3584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE888]'
- en: 'If the flag `/g` is set, then the method returns `true` as many times as there
    are matches for `regex` in `str`. The property `regex.lastIndex` contains the
    index after the last match:'
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE889]'
  id: totrans-3586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE889]'
- en: 'String.prototype.search: At What Index Is There a Match?'
  id: totrans-3587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `search()` method looks for a match with `regex` within `str`:'
  id: totrans-3588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE890]'
  id: totrans-3589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE890]'
- en: If there is a match, the index where it was found is returned. Otherwise, the
    result is `-1`. The properties `global` and `lastIndex` of `regex` are ignored
    as the search is performed (and `lastIndex` is not changed).
  id: totrans-3590
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-3591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE891]'
  id: totrans-3592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE891]'
- en: 'If the argument of `search()` is not a regular expression, it is converted
    to one:'
  id: totrans-3593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE892]'
  id: totrans-3594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE892]'
- en: 'RegExp.prototype.exec: Capture Groups'
  id: totrans-3595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following method call captures groups while matching `regex` against `str`:'
  id: totrans-3596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE893]'
  id: totrans-3597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE893]'
- en: 'If there was no match, `matchData` is `null`. Otherwise, `matchData` is a *match
    result*, an array with two additional properties:'
  id: totrans-3598
  prefs: []
  type: TYPE_NORMAL
- en: Array elements
  id: totrans-3599
  prefs: []
  type: TYPE_NORMAL
- en: Element 0 is the match for the complete regular expression (group 0, if you
    will).
  id: totrans-3600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element *n* > 1 is the capture of group *n*.
  id: totrans-3601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  id: totrans-3602
  prefs: []
  type: TYPE_NORMAL
- en: '`input` is the complete input string.'
  id: totrans-3603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index` is the index where the match was found.'
  id: totrans-3604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First Match (Flag /g Not Set)
  id: totrans-3605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the flag `/g` is not set, only the first match is returned:'
  id: totrans-3606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  id: totrans-3607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE894]'
- en: All Matches (Flag /g Set)
  id: totrans-3608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the flag `/g` is set, all matches are returned if you invoke `exec()` repeatedly.
    The return value `null` signals that there are no more matches. The property `lastIndex`
    indicates where matching will continue next time:'
  id: totrans-3609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE895]'
  id: totrans-3610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE895]'
- en: 'Here we loop over matches:'
  id: totrans-3611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE896]'
  id: totrans-3612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE896]'
- en: 'and we get the following output:'
  id: totrans-3613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE897]'
  id: totrans-3614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE897]'
- en: 'String.prototype.match: Capture Groups or Return All Matching Substrings'
  id: totrans-3615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following method call matches `regex` against `str`:'
  id: totrans-3616
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE898]'
  id: totrans-3617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE898]'
- en: 'If the flag `/g` of `regex` is not set, this method works like `RegExp.prototype.exec()`:'
  id: totrans-3618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE899]'
  id: totrans-3619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE899]'
- en: 'If the flag is set, then the method returns an array with all matching substrings
    in `str` (i.e., group 0 of every match) or `null` if there is no match:'
  id: totrans-3620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE900]'
  id: totrans-3621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE900]'
- en: 'String.prototype.replace: Search and Replace'
  id: totrans-3622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `replace()` method searches a string, `str`, for matches with `search`
    and replaces them with `replacement`:'
  id: totrans-3623
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE901]'
  id: totrans-3624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE901]'
- en: 'There are several ways in which the two parameters can be specified:'
  id: totrans-3625
  prefs: []
  type: TYPE_NORMAL
- en: '`search`'
  id: totrans-3626
  prefs: []
  type: TYPE_NORMAL
- en: 'Either a string or a regular expression:'
  id: totrans-3627
  prefs: []
  type: TYPE_NORMAL
- en: 'String: To be found literally in the input string. Be warned that only the
    first occurrence of a string is replaced. If you want to replace multiple occurrences,
    you must use a regular expression with a `/g` flag. This is unexpected and a major
    pitfall.'
  id: totrans-3628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regular expression: To be matched against the input string. Warning: Use the
    `global` flag, otherwise only one attempt is made to match the regular expression.'
  id: totrans-3629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replacement`'
  id: totrans-3630
  prefs: []
  type: TYPE_NORMAL
- en: 'Either a string or a function:'
  id: totrans-3631
  prefs: []
  type: TYPE_NORMAL
- en: 'String: Describes how to replace what has been found.'
  id: totrans-3632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function: Computes a replacement and is given matching information via parameters.'
  id: totrans-3633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacement Is a String
  id: totrans-3634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If `replacement` is a string, its content is used verbatim to replace the match.
    The only exception is the special character dollar sign (`$`), which starts so-called
    *replacement directives*:'
  id: totrans-3635
  prefs: []
  type: TYPE_NORMAL
- en: 'Groups: `$n` inserts group n from the match. `n` must be at least 1 (`$0` has
    no special meaning).'
  id: totrans-3636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The matching substring:'
  id: totrans-3637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`` (backtick) inserts the text before the match.'
  id: totrans-3638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$&` inserts the complete match.'
  id: totrans-3639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$''` (apostrophe) inserts the text after the match.'
  id: totrans-3640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$$` inserts a single `$`.'
  id: totrans-3641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This example refers to the matching substring and its prefix and suffix:'
  id: totrans-3642
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE902]'
  id: totrans-3643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE902]'
- en: 'This example refers to a group:'
  id: totrans-3644
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE903]'
  id: totrans-3645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE903]'
- en: Replacement Is a Function
  id: totrans-3646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If `replacement` is a function, it computes the string that is to replace the
    match. This function has the following signature:'
  id: totrans-3647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE904]'
  id: totrans-3648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE904]'
- en: '`completeMatch` is the same as `$&` previously, `offset` indicates where the
    match was found, and `inputStr` is what is being matched against. Thus, you can
    use the special variable `arguments` to access groups (group 1 via `arguments[1]`,
    and so on). For example:'
  id: totrans-3649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  id: totrans-3650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE905]'
- en: Problems with the Flag /g
  id: totrans-3651
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regular expressions whose `/g` flag is set are problematic if a method invoked
    on them must be invoked multiple times to return all results. That’s the case
    for two methods:'
  id: totrans-3652
  prefs: []
  type: TYPE_NORMAL
- en: '`RegExp.prototype.test()`'
  id: totrans-3653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegExp.prototype.exec()`'
  id: totrans-3654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then JavaScript abuses the regular expression as an iterator, as a pointer
    into the sequence of results. That causes problems:'
  id: totrans-3655
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 1: `/g` regular expressions can’t be inlined'
  id: totrans-3656
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-3657
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE906]'
  id: totrans-3658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE906]'
- en: 'The preceding loop is infinite, because a new regular expression is created
    for each loop iteration, which restarts the iteration over the results. Therefore,
    the code must be rewritten:'
  id: totrans-3659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE907]'
  id: totrans-3660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE907]'
- en: 'Here is another example:'
  id: totrans-3661
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  id: totrans-3662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE908]'
- en: 'Calling the preceding function will again result in an infinite loop. The correct
    version is (why `lastIndex` is set to 0 is explained shortly):'
  id: totrans-3663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE909]'
  id: totrans-3664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE909]'
- en: 'Using the function:'
  id: totrans-3665
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE910]'
  id: totrans-3666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE910]'
- en: Tip
  id: totrans-3667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s a best practice not to inline anyway (then you can give regular expressions
    descriptive names). But you have to be aware that you can’t do it, not even in
    quick hacks.
  id: totrans-3668
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: `/g` regular expressions as parameters'
  id: totrans-3669
  prefs: []
  type: TYPE_NORMAL
- en: Code that wants to invoke `test()` and `exec()` multiple times must be careful
    with a regular expression handed to it as a parameter. Its flag `/g` must active
    and, to be safe, its `lastIndex` should be set to zero (an explanation is offered
    in the next example).
  id: totrans-3670
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 3: Shared `/g` regular expressions (e.g., constants)'
  id: totrans-3671
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you are referring to a regular expression that has not been freshly
    created, you should set its `lastIndex` property to zero, before using it as an
    iterator (an explanation is offered in the next example). As iteration depends
    on `lastIndex`, such a regular expression can’t be used in more than one iteration
    at the same time.
  id: totrans-3672
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates problem 2\. It is a naive implementation
    of a function that counts how many matches there are for the regular expression
    `regex` in the string `str`:'
  id: totrans-3673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE911]'
  id: totrans-3674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE911]'
- en: 'Here’s an example of using this function:'
  id: totrans-3675
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE912]'
  id: totrans-3676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE912]'
- en: 'The first problem is that this function goes into an infinite loop if the regular
    expression’s `/g` flag is not set. For example:'
  id: totrans-3677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE913]'
  id: totrans-3678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE913]'
- en: 'The second problem is that the function doesn’t work correctly if `regex.lastIndex`
    isn’t 0, because that property indicates where to start the search. For example:'
  id: totrans-3679
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE914]'
  id: totrans-3680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE914]'
- en: 'The following implementation fixes the two problems:'
  id: totrans-3681
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  id: totrans-3682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE915]'
- en: 'A simpler alternative is to use `match()`:'
  id: totrans-3683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE916]'
  id: totrans-3684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE916]'
- en: 'There’s one possible pitfall: `str.match()` returns `null` if the `/g` flag
    is set and there are no matches. We avoid that pitfall in the preceding code by
    using `[]` if the result of `match()` isn’t truthy.'
  id: totrans-3685
  prefs: []
  type: TYPE_NORMAL
- en: Tips and Tricks
  id: totrans-3686
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section gives a few tips and tricks for working with regular expressions
    in JavaScript.
  id: totrans-3687
  prefs: []
  type: TYPE_NORMAL
- en: Quoting Text
  id: totrans-3688
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, when you assemble a regular expression manually, you want to use
    a given string verbatim. That means that none of the special characters (e.g.,
    `*`, `[`) should be interpreted as such—all of them need to be escaped. JavaScript
    has no built-in means for this kind of quoting, but you can program your own function,
    `quoteText`, that would work as follows:'
  id: totrans-3689
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE917]'
  id: totrans-3690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE917]'
- en: 'Such a function is especially handy if you need to do a search and replace
    with multiple occurrences. Then the value to search for must be a regular expression
    with the `global` flag set. With `quoteText()`, you can use arbitrary strings.
    The function looks like this:'
  id: totrans-3691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE918]'
  id: totrans-3692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE918]'
- en: All special characters are escaped, because you may want to quote several characters
    inside parentheses or square brackets.
  id: totrans-3693
  prefs: []
  type: TYPE_NORMAL
- en: 'Pitfall: Without an Assertion (e.g., ^, $), a Regular Expression Is Found Anywhere'
  id: totrans-3694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don’t use assertions such as `^` and `$`, most regular expression methods
    find a pattern anywhere. For example:'
  id: totrans-3695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE919]'
  id: totrans-3696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE919]'
- en: Matching Everything or Nothing
  id: totrans-3697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s a rare use case, but sometimes you need a regular expression that matches
    everything or nothing. For example, a function may have a parameter with a regular
    expression that is used for filtering. If that parameter is missing, you give
    it a default value, a regular expression that matches everything.
  id: totrans-3698
  prefs: []
  type: TYPE_NORMAL
- en: Matching everything
  id: totrans-3699
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The empty regular expression matches everything. We can create an instance
    of `RegExp` based on that regular expression like this:'
  id: totrans-3700
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE920]'
  id: totrans-3701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE920]'
- en: 'However, the empty regular expression literal would be `//`, which is interpreted
    as a comment by JavaScript. Therefore, the following is the closest you can get
    via a literal: `/(?:)/` (empty noncapturing group). The group matches everything,
    while not capturing anything, which the group from influencing the result returned
    by `exec()`. Even JavaScript itself uses the preceding representation when displaying
    an empty regular expression:'
  id: totrans-3702
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE921]'
  id: totrans-3703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE921]'
- en: Matching nothing
  id: totrans-3704
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The empty regular expression has an inverse—the regular expression that matches
    nothing:'
  id: totrans-3705
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE922]'
  id: totrans-3706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE922]'
- en: Manually Implementing Lookbehind
  id: totrans-3707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lookbehind is an assertion. Similar to lookahead, a pattern is used to check
    something about the current position in the input, but otherwise ignored. In contrast
    to lookahead, the match for the pattern has to *end* at the current position (not
    start at it).
  id: totrans-3708
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function replaces each occurrence of the string `''NAME''` with
    the value of the parameter `name`, but only if the occurrence is not preceded
    by a quote. We handle the quote by “manually” checking the character before the
    current match:'
  id: totrans-3709
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE923]'
  id: totrans-3710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE923]'
- en: '[PRE924]'
  id: totrans-3711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE924]'
- en: 'An alternative is to include the characters that may escape in the regular
    expression. Then you have to temporarily add a prefix to the string you are searching
    in; otherwise, you’d miss matches at the beginning of that string:'
  id: totrans-3712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE925]'
  id: totrans-3713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE925]'
- en: Regular Expression Cheat Sheet
  id: totrans-3714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Atoms (see [Atoms: General](ch19.html#regex_atoms_general "Atoms: General")):'
  id: totrans-3715
  prefs: []
  type: TYPE_NORMAL
- en: '`.` (dot) matches everything except line terminators (e.g., newlines). Use
    `[\s\S]` to really match everything.'
  id: totrans-3716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Character class escapes:'
  id: totrans-3717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\d` matches digits (`[0-9]`); `\D` matches nondigits (`[^0-9]`).'
  id: totrans-3718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\w` matches Latin alphanumeric characters plus underscore (`[A-Za-z0-9_]`);
    `\W` matches all other characters.'
  id: totrans-3719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s` matches all whitespace characters (space, tab, line feed, etc.); `\S`
    matches all nonwhitespace characters.'
  id: totrans-3720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Character class (set of characters): `[...]` and `[^...]`'
  id: totrans-3721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source characters: `[abc]` (all characters except `\ ] -` match themselves)'
  id: totrans-3722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Character class escapes (see previous): `[\d\w]`'
  id: totrans-3723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ranges: `[A-Za-z0-9]`'
  id: totrans-3724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Groups:'
  id: totrans-3725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Capturing group: `(...)`; backreference: `\1`'
  id: totrans-3726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Noncapturing group: `(?:...)`'
  id: totrans-3727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quantifiers (see [Quantifiers](ch19.html#regexp_quantifiers "Quantifiers")):'
  id: totrans-3728
  prefs: []
  type: TYPE_NORMAL
- en: 'Greedy:'
  id: totrans-3729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`? * +`'
  id: totrans-3730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n} {n,} {n,m}`'
  id: totrans-3731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reluctant: Put a `?` after any of the greedy quantifiers.'
  id: totrans-3732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assertions (see [Assertions](ch19.html#regexp_assertions "Assertions")):'
  id: totrans-3733
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginning of input, end of input: `^ $`'
  id: totrans-3734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At a word boundary, not at a word boundary: `\b \B`'
  id: totrans-3735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Positive lookahead: `(?=...)` (pattern must come next, but is otherwise ignored)'
  id: totrans-3736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Negative lookahead: `(?!...)` (pattern must not come next, but is otherwise
    ignored)'
  id: totrans-3737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disjunction: `|`'
  id: totrans-3738
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a regular expression (see [Creating a Regular Expression](ch19.html#creating_regexps
    "Creating a Regular Expression")):'
  id: totrans-3739
  prefs: []
  type: TYPE_NORMAL
- en: 'Literal: `/xyz/i` (compiled at load time)'
  id: totrans-3740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constructor: `new RegExp(''xzy'', ''i'')` (compiled at runtime)'
  id: totrans-3741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flags (see [Flags](ch19.html#regexp_flags "Flags")):'
  id: totrans-3742
  prefs: []
  type: TYPE_NORMAL
- en: 'global: `/g` (influences several regular expression methods)'
  id: totrans-3743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ignoreCase: `/i`'
  id: totrans-3744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'multiline: `/m` (`^` and `$` match per line, as opposed to the complete input)'
  id: totrans-3745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods:'
  id: totrans-3746
  prefs: []
  type: TYPE_NORMAL
- en: '`regex.test(str)`: Is there a match (see [RegExp.prototype.test: Is There a
    Match?](ch19.html#RegExp.prototype.test "RegExp.prototype.test: Is There a Match?"))?'
  id: totrans-3747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/g` is not set: Is there a match somewhere?'
  id: totrans-3748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/g` is set: Return `true` as many times as there are matches.'
  id: totrans-3749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str.search(regex)`: At what index is there a match (see [String.prototype.search:
    At What Index Is There a Match?](ch19.html#String.prototype.search "String.prototype.search:
    At What Index Is There a Match?"))?'
  id: totrans-3750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regex.exec(str)`: Capture groups (see the section [RegExp.prototype.exec:
    Capture Groups](ch19.html#RegExp.prototype.exec "RegExp.prototype.exec: Capture
    Groups"))?'
  id: totrans-3751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/g` is not set: Capture groups of first match only (invoked once)'
  id: totrans-3752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/g` is set: Capture groups of all matches (invoked repeatedly; returns `null`
    if there are no more matches)'
  id: totrans-3753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str.match(regex)`: Capture groups or return all matching substrings (see [String.prototype.match:
    Capture Groups or Return All Matching Substrings](ch19.html#String.prototype.match
    "String.prototype.match: Capture Groups or Return All Matching Substrings"))'
  id: totrans-3754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/g` is not set: Capture groups'
  id: totrans-3755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/g` is set: Return all matching substrings in an array'
  id: totrans-3756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str.replace(search, replacement)`: Search and replace (see [String.prototype.replace:
    Search and Replace](ch19.html#String.prototype.replace "String.prototype.replace:
    Search and Replace"))'
  id: totrans-3757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search`: String or regular expression (use the latter, set `/g`!)'
  id: totrans-3758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replacement`: String (with `$1`, etc.) or function (`arguments[1]` is group
    1, etc.) that returns a string'
  id: totrans-3759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For tips on using the flag `/g`, see [Problems with the Flag /g](ch19.html#tips_flag_g
    "Problems with the Flag /g").
  id: totrans-3760
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgments
  id: totrans-3761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mathias Bynens (@mathias) and Juan Ignacio Dopazo (@juandopazo) recommended
    using `match()` and `test()` for counting occurrences, and Šime Vidas (@simevidas)
    warned me about being careful with `match()` if there are no matches. The pitfall
    of the global flag causing infinite loops comes from a [talk by Andrea Giammarchi](http://bit.ly/1fwpdXv)
    (@webreflection). Claude Pache told me to escape more characters in `quoteText()`.
  id: totrans-3762
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 20. Dates
  id: totrans-3763
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript’s `Date` constructor helps with parsing, managing, and displaying
    dates. This chapter describes how it works.
  id: totrans-3764
  prefs: []
  type: TYPE_NORMAL
- en: The date API uses the term *UTC* (Coordinated Universal Time). For most purposes,
    UTC is a synonym for GMT (Greenwich Mean Time) and roughly means the time zone
    of London, UK.
  id: totrans-3765
  prefs: []
  type: TYPE_NORMAL
- en: The Date Constructor
  id: totrans-3766
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four ways of invoking the constructor of `Date`:'
  id: totrans-3767
  prefs: []
  type: TYPE_NORMAL
- en: '`new Date(year, month, date?, hours?, minutes?, seconds?, milliseconds?)`'
  id: totrans-3768
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructs a new date from the given data. The time is interpreted relative
    to the current time zone. `Date.UTC()` provides similar functionality, but relative
    to UTC. The parameters have the following ranges:'
  id: totrans-3769
  prefs: []
  type: TYPE_NORMAL
- en: '`year`: For 0 ≤ `year` ≤ 99, 1900 is added.'
  id: totrans-3770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`month`: 0–11 (0 is January, 1 is February, etc.)'
  id: totrans-3771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date`: 1–31'
  id: totrans-3772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hours`: 0–23'
  id: totrans-3773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minutes`: 0–59'
  id: totrans-3774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seconds`: 0–59'
  id: totrans-3775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`milliseconds`: 0–999'
  id: totrans-3776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-3777
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE926]'
  id: totrans-3778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE926]'
- en: As an aside, JavaScript has inherited the slightly weird convention of interpreting
    0 as January, 1 as February, and so on, from Java.
  id: totrans-3779
  prefs: []
  type: TYPE_NORMAL
- en: '`new Date(dateTimeStr)`'
  id: totrans-3780
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a date time string that is converted into a number, with which `new
    Date(number)` is invoked. [Date Time Formats](ch20.html#date_time_formats "Date
    Time Formats") explains the date time formats. For example:'
  id: totrans-3781
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE927]'
  id: totrans-3782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE927]'
- en: Illegal date time strings lead to `NaN` being passed to `new Date(number)`.
  id: totrans-3783
  prefs: []
  type: TYPE_NORMAL
- en: '`new Date(timeValue)`'
  id: totrans-3784
  prefs: []
  type: TYPE_NORMAL
- en: 'Creates a date as specified in the number of milliseconds since 1 January 1970
    00:00:00 UTC. For example:'
  id: totrans-3785
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE928]'
  id: totrans-3786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE928]'
- en: 'The inverse of this constructor is the `getTime()` method, which returns the
    milliseconds:'
  id: totrans-3787
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE929]'
  id: totrans-3788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE929]'
- en: 'You can use `NaN` as an argument, which produces a special instance of `Date`,
    an “invalid date”:'
  id: totrans-3789
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE930]'
  id: totrans-3790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE930]'
- en: '`new Date()`'
  id: totrans-3791
  prefs: []
  type: TYPE_NORMAL
- en: Creates an object for the current date and time; it works the same as `new Date(Date.now())`.
  id: totrans-3792
  prefs: []
  type: TYPE_NORMAL
- en: Date Constructor Methods
  id: totrans-3793
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The constructor `Date` has the following methods:'
  id: totrans-3794
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.now()`'
  id: totrans-3795
  prefs: []
  type: TYPE_NORMAL
- en: Returns the current date and time in milliseconds (since 1 January 1970, 00:00:00
    UTC). It produces the same result as `new Date().getTime()`.
  id: totrans-3796
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.parse(dateTimeString)`'
  id: totrans-3797
  prefs: []
  type: TYPE_NORMAL
- en: 'Converts `dateTimeString` to milliseconds since 1 January 1970, 00:00:00 UTC.
    [Date Time Formats](ch20.html#date_time_formats "Date Time Formats") explains
    the format of `dateTimeString`. The result can be used to invoke `new Date(number)`.
    Here are some examples:'
  id: totrans-3798
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE931]'
  id: totrans-3799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE931]'
- en: 'If it can’t parse a string, this method returns `NaN`:'
  id: totrans-3800
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE932]'
  id: totrans-3801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE932]'
- en: '`Date.UTC(year, month, date?, hours?, minutes?, seconds?, milliseconds?)`'
  id: totrans-3802
  prefs: []
  type: TYPE_NORMAL
- en: 'Converts the given data to milliseconds since 1 January 1970 00:00:00 UTC.
    It differs from the `Date` constructor with the same arguments in two ways:'
  id: totrans-3803
  prefs: []
  type: TYPE_NORMAL
- en: It returns a number, not a new date object.
  id: totrans-3804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It interprets the arguments as UTC, rather than as local time.
  id: totrans-3805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date Prototype Methods
  id: totrans-3806
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section covers the methods of `Date.prototype`.
  id: totrans-3807
  prefs: []
  type: TYPE_NORMAL
- en: Time Unit Getters and Setters
  id: totrans-3808
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Time unit getters and setters are available with the following signatures:'
  id: totrans-3809
  prefs: []
  type: TYPE_NORMAL
- en: 'Local time:'
  id: totrans-3810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.get«Unit»()` returns `Unit`, according to local time.'
  id: totrans-3811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.set«Unit»(number)` sets `Unit`, according to local time.'
  id: totrans-3812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Universal time:'
  id: totrans-3813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.getUTC«Unit»()` returns `Unit`, according to universal time.'
  id: totrans-3814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.setUTC«Unit»(number)` sets `Unit`, according to universal time.'
  id: totrans-3815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unit` is one of the following words:'
  id: totrans-3816
  prefs: []
  type: TYPE_NORMAL
- en: '`FullYear`: Usually four digits'
  id: totrans-3817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Month`: Month (0–11)'
  id: totrans-3818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date`: Day of the month (1–31)'
  id: totrans-3819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Day` (getter only): Day of the week (0–6); 0 is Sunday'
  id: totrans-3820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hours`: Hour (0–23)'
  id: totrans-3821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Minutes`: Minutes (0–59)'
  id: totrans-3822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Seconds`: Seconds (0–59)'
  id: totrans-3823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Milliseconds`: Milliseconds (0–999)'
  id: totrans-3824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-3825
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE933]'
  id: totrans-3826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE933]'
- en: Various Getters and Setters
  id: totrans-3827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods enable you to get and set the time in milliseconds since
    1 January 1970 and more:'
  id: totrans-3828
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.getTime()` returns the milliseconds since 1 January 1970 00:00:00
    UTC (see [Time Values: Dates as Milliseconds Since 1970-01-01](ch20.html#date_milliseconds
    "Time Values: Dates as Milliseconds Since 1970-01-01")).'
  id: totrans-3829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.setTime(timeValue)` sets the date as specified in milliseconds
    since 1 January 1970 00:00:00 UTC (see [Time Values: Dates as Milliseconds Since
    1970-01-01](ch20.html#date_milliseconds "Time Values: Dates as Milliseconds Since
    1970-01-01")).'
  id: totrans-3830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.valueOf()` is the same as `getTime()`. This method is called
    when a date is converted to a number.'
  id: totrans-3831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.getTimezoneOffset()` returns the difference between local time
    and UTC time in minutes.'
  id: totrans-3832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The unit `Year` has been deprecated in favor of `FullYear`:'
  id: totrans-3833
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.getYear()` is deprecated; use `getFullYear()` instead.'
  id: totrans-3834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.setYear(number)` is deprecated; use `setFullYear()` instead.'
  id: totrans-3835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert a Date to a String
  id: totrans-3836
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that conversion to a string is highly implementation-dependent. The following
    date is used to compute the output in the following examples (in Firefox, which
    had the most complete support when this book was written):'
  id: totrans-3837
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE934]'
  id: totrans-3838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE934]'
- en: Time (human-readable)
  id: totrans-3839
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toTimeString()`:'
  id: totrans-3840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE935]'
  id: totrans-3841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE935]'
- en: The time, in the current time zone.
  id: totrans-3842
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toLocaleTimeString()`:'
  id: totrans-3843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE936]'
  id: totrans-3844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE936]'
- en: The time in a locale-specific format. This method is provided by the ECMAScript
    Internationalization API (see [The ECMAScript Internationalization API](ch30.html#i18n_api
    "The ECMAScript Internationalization API")) and does not make much sense without
    it.
  id: totrans-3845
  prefs: []
  type: TYPE_NORMAL
- en: Date (human-readable)
  id: totrans-3846
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toDateString()`:'
  id: totrans-3847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE937]'
  id: totrans-3848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE937]'
- en: The date.
  id: totrans-3849
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toLocaleDateString()`:'
  id: totrans-3850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE938]'
  id: totrans-3851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE938]'
- en: The date, in a locale-specific format. This method is provided by the ECMAScript
    Internationalization API (see [The ECMAScript Internationalization API](ch30.html#i18n_api
    "The ECMAScript Internationalization API")) and does not make much sense without
    it.
  id: totrans-3852
  prefs: []
  type: TYPE_NORMAL
- en: Date and time (human-readable)
  id: totrans-3853
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toString()`:'
  id: totrans-3854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE939]'
  id: totrans-3855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE939]'
- en: 'Date and time, in the current time zone. For any `Date` instance that has no
    milliseconds (i.e., the second is full), the following expression is true:'
  id: totrans-3856
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE940]'
  id: totrans-3857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE940]'
- en: '`Date.prototype.toLocaleString()`:'
  id: totrans-3858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE941]'
  id: totrans-3859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE941]'
- en: Date and time in a locale-specific format. This method is provided by the ECMAScript
    Internationalization API (see [The ECMAScript Internationalization API](ch30.html#i18n_api
    "The ECMAScript Internationalization API")) and does not make much sense without
    it.
  id: totrans-3860
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toUTCString()`:'
  id: totrans-3861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE942]'
  id: totrans-3862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE942]'
- en: Date and time, in UTC.
  id: totrans-3863
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toGMTString()`:'
  id: totrans-3864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated; use `toUTCString()` instead.
  id: totrans-3865
  prefs: []
  type: TYPE_NORMAL
- en: Date and time (machine-readable)
  id: totrans-3866
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toISOString()`:'
  id: totrans-3867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE943]'
  id: totrans-3868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE943]'
- en: All internal properties show up in the returned string. The format is in accordance
    with [Date Time Formats](ch20.html#date_time_formats "Date Time Formats"); the
    time zone is always `Z`.
  id: totrans-3869
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.prototype.toJSON()`:'
  id: totrans-3870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method internally calls `toISOString()`. It is used by `JSON.stringify()`
    (see [JSON.stringify(value, replacer?, space?)](ch22.html#JSON.stringify "JSON.stringify(value,
    replacer?, space?)")) to convert date objects to JSON strings.
  id: totrans-3871
  prefs: []
  type: TYPE_NORMAL
- en: Date Time Formats
  id: totrans-3872
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section describes formats for expressing points in time as strings. There
    are many ways of doing so: indicating just the date, including a time of day,
    omitting the time zone, specifying the time zone, and more. In its support for
    date time formats, ECMAScript 5 closely follows the standard ISO 8601 Extended
    Format. JavaScript engines implement the ECMAScript specification relatively completely,
    but there are still some variations, so you have to be vigilant.'
  id: totrans-3873
  prefs: []
  type: TYPE_NORMAL
- en: 'The longest date time format is:'
  id: totrans-3874
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE944]'
  id: totrans-3875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE944]'
- en: 'Each part stands for several decimal digits of date time data. For example,
    `YYYY` means that the format starts with a four-digit year. The following subsections
    explain what each part means. Formats are relevant for the following methods:'
  id: totrans-3876
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.parse()` can parse the formats.'
  id: totrans-3877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new Date()` can parse the formats.'
  id: totrans-3878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toISOString()` creates a string in the aforementioned “full”
    format:'
  id: totrans-3879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE945]'
  id: totrans-3880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE945]'
- en: Date Formats (No Time)
  id: totrans-3881
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following date formats are available:'
  id: totrans-3882
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE946]'
  id: totrans-3883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE946]'
- en: 'They include the following parts:'
  id: totrans-3884
  prefs: []
  type: TYPE_NORMAL
- en: '`YYYY` refers to year (Gregorian calendar).'
  id: totrans-3885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MM` refers to month, from 01 to 12.'
  id: totrans-3886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DD` refers to day, from 01 to 31.'
  id: totrans-3887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-3888
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE947]'
  id: totrans-3889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE947]'
- en: Time Formats (No Date)
  id: totrans-3890
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following time formats are available. As you can see, time zone information
    `Z` is optional:'
  id: totrans-3891
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE948]'
  id: totrans-3892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE948]'
- en: 'They include the following parts:'
  id: totrans-3893
  prefs: []
  type: TYPE_NORMAL
- en: '`T` is the prefix of the time part of a format (a literal `T`, not a digit).'
  id: totrans-3894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HH` refers to hour, from 00 to 23\. You can use 24 as a value for `HH` (which
    refers to hour 00 of the following day), but then all remaining parts must be
    0.'
  id: totrans-3895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mm` indicates the minute, from 00 to 59.'
  id: totrans-3896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ss` indicates the second, from 00 to 59.'
  id: totrans-3897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sss` indicates the millisecond, from 000 to 999.'
  id: totrans-3898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Z` refers to time zone, either of the following two:'
  id: totrans-3899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “`Z`” for UTC
  id: totrans-3900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “`+`” or “`-`” followed by a time “`hh:mm`”
  id: totrans-3901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some JavaScript engines allow you to specify only a time (others require a
    date):'
  id: totrans-3902
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE949]'
  id: totrans-3903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE949]'
- en: Date Time Formats
  id: totrans-3904
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Date formats and time formats can also be combined. In date time formats, you
    can use a date or a date and a time (or, in some engines, just the time). For
    example:'
  id: totrans-3905
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE950]'
  id: totrans-3906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE950]'
- en: 'Time Values: Dates as Milliseconds Since 1970-01-01'
  id: totrans-3907
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What the date API calls `time` is called a *time value* by the ECMAScript specification.
    It is a primitive number that encodes a date as milliseconds since 1 January 1970
    00:00:00 UTC. Each date object stores its state as a time value, in the internal
    property `[[PrimitiveValue]]` (the same property that instances of the wrapper
    constructors `Boolean`, `Number`, and `String` use to store their wrapped primitive
    values).
  id: totrans-3908
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-3909
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Leap seconds are ignored in time values.
  id: totrans-3910
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods work with time values:'
  id: totrans-3911
  prefs: []
  type: TYPE_NORMAL
- en: '`new Date(timeValue)` uses a time value to create a date.'
  id: totrans-3912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.parse(dateTimeString)` parses a string with a date time string and returns
    a time value.'
  id: totrans-3913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.now()` returns the current date time as a time value.'
  id: totrans-3914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.UTC(year, month, date?, hours?, minutes?, seconds?, milliseconds?)` interprets
    the parameters relative to UTC and returns a time value.'
  id: totrans-3915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.getTime()` returns the time value stored in the receiver.'
  id: totrans-3916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.setTime(timeValue)` changes the date as specified via a time
    value.'
  id: totrans-3917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.valueOf()` returns the time value stored in the receiver. This
    method determines how dates are converted to primitives, as explained in the next
    subsection.'
  id: totrans-3918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The range of JavaScript integers (53 bits plus a sign) is large enough that
    a time span can be represented that starts at approximately 285,616 years before
    1970 and ends at approximately 285,616 years after 1970.
  id: totrans-3919
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of converting dates to time values:'
  id: totrans-3920
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE951]'
  id: totrans-3921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE951]'
- en: 'The `Date` constructor enables you to convert times values to dates:'
  id: totrans-3922
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE952]'
  id: totrans-3923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE952]'
- en: Converting a Date to a Number
  id: totrans-3924
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A date is converted to a number via `Date.prototype.valueOf()`, which returns
    a time value. This allows you to compare dates:'
  id: totrans-3925
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE953]'
  id: totrans-3926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE953]'
- en: 'You can also perform arithmetic, but beware that leap seconds are ignored:'
  id: totrans-3927
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE954]'
  id: totrans-3928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE954]'
- en: Warning
  id: totrans-3929
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the plus operator (`+`) to add a date to another date or a number results
    in a string, because the default for the conversion to primitive is to convert
    dates to strings (consult [The Plus Operator (+)](ch09.html#plus_operator "The
    Plus Operator (+)") for an explanation of how the plus operator works):'
  id: totrans-3930
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE955]'
  id: totrans-3931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE955]'
- en: Chapter 21. Math
  id: totrans-3932
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Math` object is used as a namespace for several math functions. This chapter
    provides an overview.
  id: totrans-3933
  prefs: []
  type: TYPE_NORMAL
- en: Math Properties
  id: totrans-3934
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The properties of `Math` are as follows:'
  id: totrans-3935
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.E`'
  id: totrans-3936
  prefs: []
  type: TYPE_NORMAL
- en: Euler’s constant (e)
  id: totrans-3937
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.LN2`'
  id: totrans-3938
  prefs: []
  type: TYPE_NORMAL
- en: Natural logarithm of 2
  id: totrans-3939
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.LN10`'
  id: totrans-3940
  prefs: []
  type: TYPE_NORMAL
- en: Natural logarithm of 10
  id: totrans-3941
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.LOG2E`'
  id: totrans-3942
  prefs: []
  type: TYPE_NORMAL
- en: Base 2 logarithm of e
  id: totrans-3943
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.LOG10E`'
  id: totrans-3944
  prefs: []
  type: TYPE_NORMAL
- en: Base 10 logarithm of e
  id: totrans-3945
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.PI`'
  id: totrans-3946
  prefs: []
  type: TYPE_NORMAL
- en: The ratio of the circumference of a circle to its diameter (3.14159 ...), π
  id: totrans-3947
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.SQRT1_2`'
  id: totrans-3948
  prefs: []
  type: TYPE_NORMAL
- en: The square root of one-half, ![](inleq_2101.png)
  id: totrans-3949
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.SQRT2`'
  id: totrans-3950
  prefs: []
  type: TYPE_NORMAL
- en: The square root of two, ![](inleq_2102.png)
  id: totrans-3951
  prefs: []
  type: TYPE_NORMAL
- en: Numerical Functions
  id: totrans-3952
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The numerical functions of `Math` include the following:'
  id: totrans-3953
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.abs(x)`'
  id: totrans-3954
  prefs: []
  type: TYPE_NORMAL
- en: Returns the absolute value of `x`.
  id: totrans-3955
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.ceil(x)`'
  id: totrans-3956
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the smallest integer ≥ `x`:'
  id: totrans-3957
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE956]'
  id: totrans-3958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE956]'
- en: For more on converting floating-point numbers to integers, see [Converting to
    Integer](ch11.html#converting_to_integer "Converting to Integer").
  id: totrans-3959
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.exp(x)`'
  id: totrans-3960
  prefs: []
  type: TYPE_NORMAL
- en: Returns e^x where e is Euler’s constant (`Math.E`). This is the inverse of `Math.log()`.
  id: totrans-3961
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.floor(x)`'
  id: totrans-3962
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the largest integer ≤ `x`:'
  id: totrans-3963
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE957]'
  id: totrans-3964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE957]'
- en: For more on converting floating-point numbers to integers, see [Converting to
    Integer](ch11.html#converting_to_integer "Converting to Integer").
  id: totrans-3965
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.log(x)`'
  id: totrans-3966
  prefs: []
  type: TYPE_NORMAL
- en: Returns the natural (base is Euler’s constant) logarithm ln(`x`) of `x`. This
    is the inverse of `Math.exp()`.
  id: totrans-3967
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.pow(x, y)`'
  id: totrans-3968
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns x^y, `x` raised to the power of `y`:'
  id: totrans-3969
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE958]'
  id: totrans-3970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE958]'
- en: '`Math.round(x)`'
  id: totrans-3971
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns `x` rounded to the nearest integer (the greater one if it is between
    two integers):'
  id: totrans-3972
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE959]'
  id: totrans-3973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE959]'
- en: For more on converting floating-point numbers to integers, see [Converting to
    Integer](ch11.html#converting_to_integer "Converting to Integer").
  id: totrans-3974
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.sqrt(x)`'
  id: totrans-3975
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns ![](inleq_2103.png), the square root of `x`:'
  id: totrans-3976
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE960]'
  id: totrans-3977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE960]'
- en: Trigonometric Functions
  id: totrans-3978
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The trigonometric methods accept and return angles as radians. The following
    functions show you how you could implement conversions, should you need to:'
  id: totrans-3979
  prefs: []
  type: TYPE_NORMAL
- en: 'From degrees to radians:'
  id: totrans-3980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE961]'
  id: totrans-3981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE961]'
- en: 'Here is the interaction:'
  id: totrans-3982
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE962]'
  id: totrans-3983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE962]'
- en: 'From radians to degrees:'
  id: totrans-3984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE963]'
  id: totrans-3985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE963]'
- en: 'Here is the interaction:'
  id: totrans-3986
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE964]'
  id: totrans-3987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE964]'
- en: 'The trigonometric methods are as follows:'
  id: totrans-3988
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.acos(x)`'
  id: totrans-3989
  prefs: []
  type: TYPE_NORMAL
- en: Returns the arc cosine of `x`.
  id: totrans-3990
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.asin(x)`'
  id: totrans-3991
  prefs: []
  type: TYPE_NORMAL
- en: Returns the arc sine of `x`.
  id: totrans-3992
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.atan(x)`'
  id: totrans-3993
  prefs: []
  type: TYPE_NORMAL
- en: Returns the arc tangent of `x`.
  id: totrans-3994
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.atan2(y, x)`'
  id: totrans-3995
  prefs: []
  type: TYPE_NORMAL
- en: Returns the arc tangent of the quotient ![](inleq_2104.png).
  id: totrans-3996
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.cos(x)`'
  id: totrans-3997
  prefs: []
  type: TYPE_NORMAL
- en: Returns the cosine of `x`.
  id: totrans-3998
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.sin(x)`'
  id: totrans-3999
  prefs: []
  type: TYPE_NORMAL
- en: Returns the sine of `x`.
  id: totrans-4000
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.tan(x)`'
  id: totrans-4001
  prefs: []
  type: TYPE_NORMAL
- en: Returns the tangent of `x`.
  id: totrans-4002
  prefs: []
  type: TYPE_NORMAL
- en: Other Functions
  id: totrans-4003
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the remaining `Math` functions:'
  id: totrans-4004
  prefs: []
  type: TYPE_NORMAL
- en: '`min(x1?, x2?, ...)`'
  id: totrans-4005
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the smallest number among the parameters:'
  id: totrans-4006
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE965]'
  id: totrans-4007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE965]'
- en: 'Use it on arrays via `apply()` (see [func.apply(thisValue, argArray)](ch15.html#functional_apply
    "func.apply(thisValue, argArray)")):'
  id: totrans-4008
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE966]'
  id: totrans-4009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE966]'
- en: '`max(x1?, x2?, ...)`'
  id: totrans-4010
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the largest number among the parameters:'
  id: totrans-4011
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE967]'
  id: totrans-4012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE967]'
- en: 'Use it on arrays via `apply()` (see [func.apply(thisValue, argArray)](ch15.html#functional_apply
    "func.apply(thisValue, argArray)")):'
  id: totrans-4013
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE968]'
  id: totrans-4014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE968]'
- en: '`Math.random()`'
  id: totrans-4015
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a pseudorandom number `r`, 0 ≤ `r` < 1. The following function uses
    `Math.random()` to compute a random integer:'
  id: totrans-4016
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE969]'
  id: totrans-4017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE969]'
- en: Chapter 22. JSON
  id: totrans-4018
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON (JavaScript Object Notation) is a plain-text format for data storage. It
    has become quite popular as a data interchange format for web services, for configuration
    files, and more. ECMAScript 5 has an API for converting from a string in JSON
    format to a JavaScript value (*parsing*) and vice versa (*stringifying*).
  id: totrans-4019
  prefs: []
  type: TYPE_NORMAL
- en: Background
  id: totrans-4020
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explains what JSON is and how it was created.
  id: totrans-4021
  prefs: []
  type: TYPE_NORMAL
- en: Data Format
  id: totrans-4022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JSON stores data as plain text. Its grammar is a subset of the grammar of JavaScript
    expressions. For example:'
  id: totrans-4023
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE970]'
  id: totrans-4024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE970]'
- en: 'JSON uses the following constructs from JavaScript expressions:'
  id: totrans-4025
  prefs: []
  type: TYPE_NORMAL
- en: Compound
  id: totrans-4026
  prefs: []
  type: TYPE_NORMAL
- en: Objects of JSON data and arrays of JSON data
  id: totrans-4027
  prefs: []
  type: TYPE_NORMAL
- en: Atomic
  id: totrans-4028
  prefs: []
  type: TYPE_NORMAL
- en: Strings, numbers, booleans, and `null`
  id: totrans-4029
  prefs: []
  type: TYPE_NORMAL
- en: 'It adheres to these rules:'
  id: totrans-4030
  prefs: []
  type: TYPE_NORMAL
- en: Strings must always be double-quoted; string literals such as `'mystr'` are
    illegal.
  id: totrans-4031
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property keys must be double-quoted.
  id: totrans-4032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History
  id: totrans-4033
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Douglas Crockford discovered JSON in 2001\. He gave it a name and put up a
    specification at [http://json.org](http://json.org):'
  id: totrans-4034
  prefs: []
  type: TYPE_NORMAL
- en: I discovered JSON. I do not claim to have invented JSON, because it already
    existed in nature. What I did was I found it, I named it, I described how it was
    useful. I don’t claim to be the first person to have discovered it; I know that
    there are other people who discovered it at least a year before I did. The earliest
    occurrence I’ve found was, there was someone at Netscape who was using JavaScript
    array literals for doing data communication as early as 1996, which was at least
    five years before I stumbled onto the idea.
  id: totrans-4035
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Initially, Crockford wanted JSON to have the name *JavaScript Markup Language*,
    but the acronym JSML was already taken by the [JSpeech Markup Language](http://www.w3.org/TR/jsml/).
  id: totrans-4036
  prefs: []
  type: TYPE_NORMAL
- en: The JSON specification has been translated to many human languages, and there
    are now libraries for many programming languages that support parsing and generating
    JSON.
  id: totrans-4037
  prefs: []
  type: TYPE_NORMAL
- en: Grammar
  id: totrans-4038
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Douglas Crockford created a JSON business card with a logo on the front (see
    [Figure 22-1](ch22.html#figjson_business_card_front_25 "Figure 22-1. The front
    side of the JSON business card shows a logo (source: Eric Miraglia).")) and the
    full grammar on the back (see [Figure 22-2](ch22.html#figjson_business_card_back_25
    "Figure 22-2. The back side of the JSON business card contains the complete grammar
    (source: Eric Miraglia).")). That makes it visually obvious how positively simple
    JSON is.'
  id: totrans-4039
  prefs: []
  type: TYPE_NORMAL
- en: '![The front side of the JSON business card shows a logo (source: Eric Miraglia).](images/spjs_2601.png.jpg)Figure 22-1. The
    front side of the JSON business card shows a logo (source: [Eric Miraglia](http://www.flickr.com/photos/equanimity/3762360637/)).![The
    back side of the JSON business card contains the complete grammar (source: Eric
    Miraglia).](images/spjs_2602.png.jpg)Figure 22-2. The back side of the JSON business
    card contains the complete grammar (source: [Eric Miraglia](http://www.flickr.com/photos/equanimity/3763158824/)).'
  id: totrans-4040
  prefs: []
  type: TYPE_NORMAL
- en: 'The grammar can be transcribed as follows:'
  id: totrans-4041
  prefs: []
  type: TYPE_NORMAL
- en: object
  id: totrans-4042
  prefs: []
  type: TYPE_NORMAL
- en: '`{` `}`'
  id: totrans-4043
  prefs: []
  type: TYPE_NORMAL
- en: '`{` members `}`'
  id: totrans-4044
  prefs: []
  type: TYPE_NORMAL
- en: members
  id: totrans-4045
  prefs: []
  type: TYPE_NORMAL
- en: pair
  id: totrans-4046
  prefs: []
  type: TYPE_NORMAL
- en: pair `,` members
  id: totrans-4047
  prefs: []
  type: TYPE_NORMAL
- en: pair
  id: totrans-4048
  prefs: []
  type: TYPE_NORMAL
- en: string `:` value
  id: totrans-4049
  prefs: []
  type: TYPE_NORMAL
- en: array
  id: totrans-4050
  prefs: []
  type: TYPE_NORMAL
- en: '`[` `]`'
  id: totrans-4051
  prefs: []
  type: TYPE_NORMAL
- en: '`[` elements `]`'
  id: totrans-4052
  prefs: []
  type: TYPE_NORMAL
- en: elements
  id: totrans-4053
  prefs: []
  type: TYPE_NORMAL
- en: value
  id: totrans-4054
  prefs: []
  type: TYPE_NORMAL
- en: value `,` elements
  id: totrans-4055
  prefs: []
  type: TYPE_NORMAL
- en: value
  id: totrans-4056
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-4057
  prefs: []
  type: TYPE_NORMAL
- en: number
  id: totrans-4058
  prefs: []
  type: TYPE_NORMAL
- en: object
  id: totrans-4059
  prefs: []
  type: TYPE_NORMAL
- en: array
  id: totrans-4060
  prefs: []
  type: TYPE_NORMAL
- en: '`true`'
  id: totrans-4061
  prefs: []
  type: TYPE_NORMAL
- en: '`false`'
  id: totrans-4062
  prefs: []
  type: TYPE_NORMAL
- en: '`null`'
  id: totrans-4063
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-4064
  prefs: []
  type: TYPE_NORMAL
- en: '`""`'
  id: totrans-4065
  prefs: []
  type: TYPE_NORMAL
- en: '`"` chars `"`'
  id: totrans-4066
  prefs: []
  type: TYPE_NORMAL
- en: chars
  id: totrans-4067
  prefs: []
  type: TYPE_NORMAL
- en: char
  id: totrans-4068
  prefs: []
  type: TYPE_NORMAL
- en: char chars
  id: totrans-4069
  prefs: []
  type: TYPE_NORMAL
- en: char
  id: totrans-4070
  prefs: []
  type: TYPE_NORMAL
- en: any-Unicode-character-except-"-or-\-or-control-character
  id: totrans-4071
  prefs: []
  type: TYPE_NORMAL
- en: '`\" \\ \/ \b \f \n \r \t`'
  id: totrans-4072
  prefs: []
  type: TYPE_NORMAL
- en: '`\u` four-hex-digits'
  id: totrans-4073
  prefs: []
  type: TYPE_NORMAL
- en: number
  id: totrans-4074
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-4075
  prefs: []
  type: TYPE_NORMAL
- en: int frac
  id: totrans-4076
  prefs: []
  type: TYPE_NORMAL
- en: int exp
  id: totrans-4077
  prefs: []
  type: TYPE_NORMAL
- en: int frac exp
  id: totrans-4078
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-4079
  prefs: []
  type: TYPE_NORMAL
- en: digit
  id: totrans-4080
  prefs: []
  type: TYPE_NORMAL
- en: digit1-9 digits
  id: totrans-4081
  prefs: []
  type: TYPE_NORMAL
- en: '`-` digit'
  id: totrans-4082
  prefs: []
  type: TYPE_NORMAL
- en: '`-` digit1-9 digits'
  id: totrans-4083
  prefs: []
  type: TYPE_NORMAL
- en: frac
  id: totrans-4084
  prefs: []
  type: TYPE_NORMAL
- en: '`.` digits'
  id: totrans-4085
  prefs: []
  type: TYPE_NORMAL
- en: exp
  id: totrans-4086
  prefs: []
  type: TYPE_NORMAL
- en: e digits
  id: totrans-4087
  prefs: []
  type: TYPE_NORMAL
- en: digits
  id: totrans-4088
  prefs: []
  type: TYPE_NORMAL
- en: digit
  id: totrans-4089
  prefs: []
  type: TYPE_NORMAL
- en: digit digits
  id: totrans-4090
  prefs: []
  type: TYPE_NORMAL
- en: e
  id: totrans-4091
  prefs: []
  type: TYPE_NORMAL
- en: '`e e+ e-`'
  id: totrans-4092
  prefs: []
  type: TYPE_NORMAL
- en: '`E E+ E-`'
  id: totrans-4093
  prefs: []
  type: TYPE_NORMAL
- en: The global variable `JSON` serves as a namespace for functions that produce
    and parse strings with JSON data.
  id: totrans-4094
  prefs: []
  type: TYPE_NORMAL
- en: JSON.stringify(value, replacer?, space?)
  id: totrans-4095
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`JSON.stringify(value, replacer?, space?)` translates the JavaScript value
    `value` to a string in JSON format. It has two optional arguments.'
  id: totrans-4096
  prefs: []
  type: TYPE_NORMAL
- en: 'The optional parameter `replacer` is used to change the `value` before stringifying
    it. It can be:'
  id: totrans-4097
  prefs: []
  type: TYPE_NORMAL
- en: 'A *node visitor* (see [Transforming Data via Node Visitors](ch22.html#node_visitors
    "Transforming Data via Node Visitors")) that transforms the tree of values before
    it is stringified. For example:'
  id: totrans-4098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE971]'
  id: totrans-4099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE971]'
- en: 'Using the replacer:'
  id: totrans-4100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE972]'
  id: totrans-4101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE972]'
- en: 'A whitelist of property keys that hides all properties (of nonarray objects)
    whose keys are not in the list. For example:'
  id: totrans-4102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE973]'
  id: totrans-4103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE973]'
- en: 'The whitelist has no effect on arrays:'
  id: totrans-4104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE974]'
  id: totrans-4105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE974]'
- en: 'The optional parameter `space` influences the formatting of the output. Without
    this parameter, the result of `stringify` is a single line of text:'
  id: totrans-4106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE975]'
  id: totrans-4107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE975]'
- en: 'With it, newlines are inserted and each level of nesting via arrays and objects
    increases indentation. There are two ways to specify how to indent:'
  id: totrans-4108
  prefs: []
  type: TYPE_NORMAL
- en: A number
  id: totrans-4109
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply the number by the level of indentation and indent the line by as many
    spaces. Numbers smaller than 0 are interpreted as 0; numbers larger than 10 are
    interpreted as 10:'
  id: totrans-4110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE976]'
  id: totrans-4111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE976]'
- en: A string
  id: totrans-4112
  prefs: []
  type: TYPE_NORMAL
- en: 'To indent, repeat the given string once for each level of indentation. Only
    the first 10 characters of the string are used:'
  id: totrans-4113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE977]'
  id: totrans-4114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE977]'
- en: 'Therefore, the following invocation of `JSON.stringify()` prints an object
    as a nicely formatted tree:'
  id: totrans-4115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE978]'
  id: totrans-4116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE978]'
- en: Data Ignored by JSON.stringify()
  id: totrans-4117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In objects, `JSON.stringify()` only considers enumerable own properties (see
    [Property Attributes and Property Descriptors](ch17_split_000.html#property_attributes
    "Property Attributes and Property Descriptors")). The following example demonstrates
    the nonenumerable own property `obj.foo` being ignored:'
  id: totrans-4118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE979]'
  id: totrans-4119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE979]'
- en: 'How `JSON.stringify()` handles values that are not supported by JSON (such
    as functions and `undefined`) depends on where it encounters them. An unsupported
    value itself leads to `stringify()` returning `undefined` instead of a string:'
  id: totrans-4120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE980]'
  id: totrans-4121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE980]'
- en: 'Properties whose values are unsupported are simply ignored:'
  id: totrans-4122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE981]'
  id: totrans-4123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE981]'
- en: 'Unsupported values in arrays are stringified as `null`s:'
  id: totrans-4124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE982]'
  id: totrans-4125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE982]'
- en: The toJSON() Method
  id: totrans-4126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If `JSON.stringify()` encounters an object that has a `toJSON` method, it uses
    that method to obtain a value to be stringified. For example:'
  id: totrans-4127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE983]'
  id: totrans-4128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE983]'
- en: 'Dates already have a `toJSON` method that produces an ISO 8601 date string:'
  id: totrans-4129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE984]'
  id: totrans-4130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE984]'
- en: 'The full signature of a `toJSON` method is as follows:'
  id: totrans-4131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE985]'
  id: totrans-4132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE985]'
- en: 'The `key` parameter allows you to stringify differently, depending on context.
    It is always a string and indicates where your object was found in the parent
    object:'
  id: totrans-4133
  prefs: []
  type: TYPE_NORMAL
- en: Root position
  id: totrans-4134
  prefs: []
  type: TYPE_NORMAL
- en: The empty string
  id: totrans-4135
  prefs: []
  type: TYPE_NORMAL
- en: Property value
  id: totrans-4136
  prefs: []
  type: TYPE_NORMAL
- en: The property key
  id: totrans-4137
  prefs: []
  type: TYPE_NORMAL
- en: Array element
  id: totrans-4138
  prefs: []
  type: TYPE_NORMAL
- en: The element’s index as a string
  id: totrans-4139
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll demonstrate `toJSON()` via the following object:'
  id: totrans-4140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE986]'
  id: totrans-4141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE986]'
- en: 'If you use `JSON.stringify()`, each occurrence of `obj` is replaced with `0`.
    The `toJSON()` method is notified that `obj` was encountered at the property key
    `''foo''` and at the array index 0:'
  id: totrans-4142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE987]'
  id: totrans-4143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE987]'
- en: 'The built-in `toJSON()` methods are as follows:'
  id: totrans-4144
  prefs: []
  type: TYPE_NORMAL
- en: '`Boolean.prototype.toJSON()`'
  id: totrans-4145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.prototype.toJSON()`'
  id: totrans-4146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.toJSON()`'
  id: totrans-4147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toJSON()`'
  id: totrans-4148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON.parse(text, reviver?)
  id: totrans-4149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`JSON.parse(text, reviver?)` parses the JSON data in `text` and returns a JavaScript
    value. Here are some examples:'
  id: totrans-4150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE988]'
  id: totrans-4151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE988]'
- en: 'The optional parameter `reviver` is a *node visitor* (see [Transforming Data
    via Node Visitors](ch22.html#node_visitors "Transforming Data via Node Visitors"))
    and can be used to transform the parsed data. In this example, we are translating
    date strings to date objects:'
  id: totrans-4152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE989]'
  id: totrans-4153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE989]'
- en: 'And here is the interaction:'
  id: totrans-4154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE990]'
  id: totrans-4155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE990]'
- en: Transforming Data via Node Visitors
  id: totrans-4156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both `JSON.stringify()` and `JSON.parse()` let you transform JavaScript data
    by passing in a function:'
  id: totrans-4157
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON.stringify()` lets you change the JavaScript data before turning it into
    JSON.'
  id: totrans-4158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON.parse()` parses JSON and then lets you post-process the resulting JavaScript
    data.'
  id: totrans-4159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JavaScript data is a tree whose compound nodes are arrays and objects and
    whose leaves are primitive values (booleans, numbers, strings, `null`). Let’s
    use the name *node visitor* for the transformation function that you pass in.
    The methods iterate over the tree and call the visitor for each node. It then
    has the option to replace or delete the node. The node visitor has the signature:'
  id: totrans-4160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE991]'
  id: totrans-4161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE991]'
- en: 'The parameters are:'
  id: totrans-4162
  prefs: []
  type: TYPE_NORMAL
- en: '`this`'
  id: totrans-4163
  prefs: []
  type: TYPE_NORMAL
- en: The parent of the current node.
  id: totrans-4164
  prefs: []
  type: TYPE_NORMAL
- en: '`key`'
  id: totrans-4165
  prefs: []
  type: TYPE_NORMAL
- en: A key where the current node is located inside its parent. `key` is always a
    string.
  id: totrans-4166
  prefs: []
  type: TYPE_NORMAL
- en: '`value`'
  id: totrans-4167
  prefs: []
  type: TYPE_NORMAL
- en: The current node.
  id: totrans-4168
  prefs: []
  type: TYPE_NORMAL
- en: 'The root node `root` has no parent. When `root` is visited, a pseudoparent
    is created for it and the parameters have the following values:'
  id: totrans-4169
  prefs: []
  type: TYPE_NORMAL
- en: '`this` is `{ '''': root }`.'
  id: totrans-4170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key` is `''''`.'
  id: totrans-4171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` is `root`.'
  id: totrans-4172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The node visitor has three options for returning a value:'
  id: totrans-4173
  prefs: []
  type: TYPE_NORMAL
- en: Return `value` as it is. Then no change is performed.
  id: totrans-4174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a different value. Then the current node is replaced with it.
  id: totrans-4175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return `undefined`. Then the node is removed.
  id: totrans-4176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is an example of a node visitor. It logs what values have been
    passed to it.
  id: totrans-4177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE992]'
  id: totrans-4178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE992]'
- en: Let’s use this function to examine how the JSON methods iterate over JavaScript
    data.
  id: totrans-4179
  prefs: []
  type: TYPE_NORMAL
- en: JSON.stringify()
  id: totrans-4180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The special root node comes first, in a prefix iteration (parent before children).
    The first node that is visited is always the pseudoroot. The last line that is
    displayed after each call is the string returned by `stringify()`:'
  id: totrans-4181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE993]'
  id: totrans-4182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE993]'
- en: JSON.parse()
  id: totrans-4183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The leaves come first, in a postfix iteration (children before parent). The
    last node that is visited is always the pseudoroot. The last line that is displayed
    after each call is the JavaScript value returned by `parse()`:'
  id: totrans-4184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE994]'
  id: totrans-4185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE994]'
- en: Chapter 23. Standard Global Variables
  id: totrans-4186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter is a reference for the global variables standardized by the ECMAScript
    specification. Web browsers have more global variables, which are [listed on MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window).
    All global variables are (own or inherited) properties of the global object (`window`
    in browsers; see [The Global Object](ch16.html#global_object "The Global Object")).
  id: totrans-4187
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  id: totrans-4188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For details on the following constructors, see the sections indicated in parentheses:'
  id: totrans-4189
  prefs: []
  type: TYPE_NORMAL
- en: '`Array` ([The Array Constructor](ch18.html#array_constructor "The Array Constructor"))'
  id: totrans-4190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean` ([Wrapper Objects for Primitives](ch08.html#wrapper_objects "Wrapper
    Objects for Primitives"))'
  id: totrans-4191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date` ([The Date Constructor](ch20.html#date_constructors "The Date Constructor"))'
  id: totrans-4192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Function` ([Evaluating Code Using new Function()](ch23.html#function_constructor
    "Evaluating Code Using new Function()"))'
  id: totrans-4193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number` ([Wrapper Objects for Primitives](ch08.html#wrapper_objects "Wrapper
    Objects for Primitives"))'
  id: totrans-4194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object` ([Converting Any Value to an Object](ch17_split_000.html#toobject
    "Converting Any Value to an Object"))'
  id: totrans-4195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegExp` ([Creating a Regular Expression](ch19.html#creating_regexps "Creating
    a Regular Expression"))'
  id: totrans-4196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String` ([Wrapper Objects for Primitives](ch08.html#wrapper_objects "Wrapper
    Objects for Primitives"))'
  id: totrans-4197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error Constructors
  id: totrans-4198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For details on these constructors, see [Error Constructors](ch14.html#error_constructors
    "Error Constructors"):'
  id: totrans-4199
  prefs: []
  type: TYPE_NORMAL
- en: '`Error`'
  id: totrans-4200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EvalError`'
  id: totrans-4201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RangeError`'
  id: totrans-4202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReferenceError`'
  id: totrans-4203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SyntaxError`'
  id: totrans-4204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypeError`'
  id: totrans-4205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URIError`'
  id: totrans-4206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonconstructor Functions
  id: totrans-4207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several global functions are not constructors. They are listed in this section.
  id: totrans-4208
  prefs: []
  type: TYPE_NORMAL
- en: Encoding and Decoding Text
  id: totrans-4209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following functions handle several ways of URI encoding and decoding:'
  id: totrans-4210
  prefs: []
  type: TYPE_NORMAL
- en: '`encodeURI(uri)`'
  id: totrans-4211
  prefs: []
  type: TYPE_NORMAL
- en: 'Percent-encodes special characters in `uri`. Special characters are all Unicode
    characters except for the following ones:'
  id: totrans-4212
  prefs: []
  type: TYPE_NORMAL
- en: '| URI characters: | `; , / ? : @ & = + $ #` |'
  id: totrans-4213
  prefs: []
  type: TYPE_TB
- en: '| Not encoded either: | `a-z A-Z 0-9 - _ . ! ~ * '' ( )` |'
  id: totrans-4214
  prefs: []
  type: TYPE_TB
- en: 'For example:'
  id: totrans-4215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE995]'
  id: totrans-4216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE995]'
- en: '`encodeURIComponent(uriComponent)`'
  id: totrans-4217
  prefs: []
  type: TYPE_NORMAL
- en: 'Percent-encodes all characters in `uriComponent`, except for:'
  id: totrans-4218
  prefs: []
  type: TYPE_NORMAL
- en: '| Not encoded: | `a-z A-Z 0-9 - _ . ! ~ * '' ( )` |'
  id: totrans-4219
  prefs: []
  type: TYPE_TB
- en: 'In contrast to `encodeURI`, characters that are significant in URLs and filenames
    are encoded, too. You can thus use this function to turn any text into a legal
    filename or URL path segment. For example:'
  id: totrans-4220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE996]'
  id: totrans-4221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE996]'
- en: '`decodeURI(encodedURI)`'
  id: totrans-4222
  prefs: []
  type: TYPE_NORMAL
- en: 'Decodes a percent-encoded URI that has been produced by `encodeURI`:'
  id: totrans-4223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE997]'
  id: totrans-4224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE997]'
- en: '`encodeURI` does not encode URI characters and `decodeURI` does not decode
    them, even if they have been correctly encoded:'
  id: totrans-4225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE998]'
  id: totrans-4226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE998]'
- en: '`decodeURIComponent(encodedURIComponent)`'
  id: totrans-4227
  prefs: []
  type: TYPE_NORMAL
- en: 'Decodes a percent-encoded URI component that has been produced by `encodeURIComponent`.
    In contrast to `decodeURI`, all percent-encoded characters are decoded:'
  id: totrans-4228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE999]'
  id: totrans-4229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE999]'
- en: 'The following are deprecated:'
  id: totrans-4230
  prefs: []
  type: TYPE_NORMAL
- en: '`escape(str)` percent-encodes `str`. It is deprecated because it does not handle
    non-ASCII characters properly. Use `encodeURIComponent()` instead.'
  id: totrans-4231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unescape(str)` percent-decodes `str`. It is deprecated because it does not
    handle non-ASCII characters properly. Use `decodeURIComponent()` instead.'
  id: totrans-4232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Categorizing and Parsing Numbers
  id: totrans-4233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods help with categorizing and parsing numbers:'
  id: totrans-4234
  prefs: []
  type: TYPE_NORMAL
- en: '`isFinite(number)` ([Checking for Infinity](ch11.html#isFinite "Checking for
    Infinity"))'
  id: totrans-4235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isNaN(value)` ([Pitfall: checking whether a value is NaN](ch11.html#isNaN
    "Pitfall: checking whether a value is NaN"))'
  id: totrans-4236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseFloat(string)` ([parseFloat()](ch11.html#parseFloat "parseFloat()"))'
  id: totrans-4237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseInt(string, radix)` ([Integers via parseInt()](ch11.html#parseInt "Integers
    via parseInt()"))'
  id: totrans-4238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically Evaluating JavaScript Code via eval() and new Function()
  id: totrans-4239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section examines how one can dynamically evaluate code in JavaScript.
  id: totrans-4240
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating Code Using eval()
  id: totrans-4241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function call:'
  id: totrans-4242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1000]'
  id: totrans-4243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1000]'
- en: 'evaluates the JavaScript code in `str`. For example:'
  id: totrans-4244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1001]'
  id: totrans-4245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1001]'
- en: 'Note that `eval()` parses in statement context (see [Expressions Versus Statements](ch07.html#expr_vs_stmt
    "Expressions Versus Statements")):'
  id: totrans-4246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1002]'
  id: totrans-4247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1002]'
- en: Use eval() in strict mode
  id: totrans-4248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For `eval()`, you really should use strict mode (see [Strict Mode](ch07.html#strict_mode
    "Strict Mode")). In sloppy mode, evaluated code can create local variables in
    the surrounding scope:'
  id: totrans-4249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1003]'
  id: totrans-4250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1003]'
- en: 'That can’t happen in strict mode:'
  id: totrans-4251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1004]'
  id: totrans-4252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1004]'
- en: However, even in strict mode, evaluated code still has read and write access
    to variables in surrounding scopes. To prevent such access, you need to call `eval()`
    indirectly.
  id: totrans-4253
  prefs: []
  type: TYPE_NORMAL
- en: Indirect eval() evaluates in global scope
  id: totrans-4254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two ways to invoke `eval()`:'
  id: totrans-4255
  prefs: []
  type: TYPE_NORMAL
- en: '[Directly](http://ecma-international.org/ecma-262/5.1/#sec-15.1.2.1.1). Via
    a direct call to a function whose name is “eval.”'
  id: totrans-4256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indirectly. In some other way (via `call()`, as a method of `window`, by storing
    it under a different name and calling it there, etc.).
  id: totrans-4257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we have already seen, direct `eval()` executes code in the current scope:'
  id: totrans-4258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1005]'
  id: totrans-4259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1005]'
- en: 'Conversely, indirect `eval()` executes it in global scope:'
  id: totrans-4260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1006]'
  id: totrans-4261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1006]'
- en: 'Explanation of (1): When you refer to a variable via its name, the initial
    result is a so-called [*reference*](http://ecma-international.org/ecma-262/5.1/#sec-8.7),
    a data structure with two main fields:'
  id: totrans-4262
  prefs: []
  type: TYPE_NORMAL
- en: '`base` points to the *environment*, the data structure in which the variable’s
    value is stored.'
  id: totrans-4263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`referencedName` is the name of the variable.'
  id: totrans-4264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During an `eval()` function call, the function call operator (the parentheses)
    encounters a reference to `eval` and can determine the name of the function to
    be called. Therefore, such a function call triggers a direct `eval()`. You can,
    however, force an indirect `eval()` by not giving the call operator a reference.
    That is achieved by retrieving the value of the reference before applying the
    operator. The comma operator does that for us in line (1). This operator evaluates
    the first operand and returns the result of evaluating the second operand. The
    evaluation always produces values, which means that references are resolved and
    function names are lost.
  id: totrans-4265
  prefs: []
  type: TYPE_NORMAL
- en: 'Indirectly evaluated code is always sloppy. That is a consequence of the code
    being evaluated independently of its current surroundings:'
  id: totrans-4266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1007]'
  id: totrans-4267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1007]'
- en: Evaluating Code Using new Function()
  id: totrans-4268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The constructor `Function()` has the signature:'
  id: totrans-4269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1008]'
  id: totrans-4270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1008]'
- en: 'It creates a function whose zero or more parameters have the names `param1`,
    `parem2`, and so on, and whose body is `funcBody`; that is, the created function
    looks like this:'
  id: totrans-4271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1009]'
  id: totrans-4272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1009]'
- en: 'Let’s use `new Function()` to create a function `f` that returns the sum of
    its parameters:'
  id: totrans-4273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1010]'
  id: totrans-4274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1010]'
- en: Similar to indirect `eval()`, `new Function()` creates functions whose scope
    is global:^([[16](#ftn.id1065911)])
  id: totrans-4275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1011]'
  id: totrans-4276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1011]'
- en: 'Such functions are also sloppy by default:'
  id: totrans-4277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1012]'
  id: totrans-4278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1012]'
- en: eval() Versus new Function()
  id: totrans-4279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally, it is better to use `new Function()` than `eval()` in order to evaluate
    code: the function parameters provide a clear interface to the evaluated code
    and you don’t need the slightly awkward syntax of indirect `eval()` to ensure
    that the evaluated code can access only global variables (in addition to its own).'
  id: totrans-4280
  prefs: []
  type: TYPE_NORMAL
- en: Best Practices
  id: totrans-4281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should avoid `eval()` and `new Function()`. Dynamically evaluating code
    is slow and a potential security risk. It also prevents most tools (such as IDEs)
    that use static analysis from considering the code.
  id: totrans-4282
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, there are better alternatives. For example, Brendan Eich recently [tweeted](http://bit.ly/1fwpWrB)
    an antipattern used by programmers who want to access a property whose name is
    stored in a variable `propName`:'
  id: totrans-4283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1013]'
  id: totrans-4284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1013]'
- en: 'The idea makes sense: the dot operator only supports fixed, statically provided
    property keys. In this case, the property key is only known at runtime, which
    is why `eval()` is needed in order to use that operator. Luckily, JavaScript also
    has the bracket operator, which does accept dynamic property keys. Therefore,
    the following is a better version of the preceding code:'
  id: totrans-4285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1014]'
  id: totrans-4286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1014]'
- en: You also shouldn’t use `eval()` or `new Function()` to parse JSON data. That
    is unsafe. Either rely on ECMAScript 5’s built-in support for JSON (see [Chapter 22](ch22.html
    "Chapter 22. JSON")) or use a library.
  id: totrans-4287
  prefs: []
  type: TYPE_NORMAL
- en: Legitimate use cases
  id: totrans-4288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are a few legitimate, albeit advanced, use cases for `eval()` and `new
    Function()`: configuration data with functions (which JSON does not allow), template
    libraries, interpreters, command lines, and module systems.'
  id: totrans-4289
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-4290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This was a relatively high-level overview of dynamically evaluating code in
    JavaScript. If you want to dig deeper, you can take a look at the article [“Global
    eval. What are the options?”](http://perfectionkills.com/global-eval-what-are-the-options/)
    by kangax.
  id: totrans-4291
  prefs: []
  type: TYPE_NORMAL
- en: The Console API
  id: totrans-4292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most JavaScript engines, there is a global object, `console`, with methods
    for logging and debugging. That object is not part of the language proper, but
    has become a de facto standard. Since their main purpose is debugging, the `console`
    methods will most frequently be used during development and rarely in deployed
    code.
  id: totrans-4293
  prefs: []
  type: TYPE_NORMAL
- en: This section provides an overview of the console API. It documents the status
    quo as of Chrome 32, Firebug 1.12, Firefox 25, Internet Explorer 11, Node.js 0.10.22,
    and Safari 7.0.
  id: totrans-4294
  prefs: []
  type: TYPE_NORMAL
- en: How Standardized Is the Console API Across Engines?
  id: totrans-4295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The implementations of the console API vary greatly and are constantly changing.
    If you want authoritative documentation, you have two options. First, you can
    look at standard-like overviews of the API:'
  id: totrans-4296
  prefs: []
  type: TYPE_NORMAL
- en: Firebug first implemented the console API, and the [documentation](http://bit.ly/1fwq1vk)
    in its wiki is the closest thing to a standard there currently is.
  id: totrans-4297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, Brian Kardell and Paul Irish are working on a [specification](http://bit.ly/1fwq7mX)
    for the API, which should lead to more consistent behavior.
  id: totrans-4298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, you can look at the documentation of various engines:'
  id: totrans-4299
  prefs: []
  type: TYPE_NORMAL
- en: '[Chrome](https://developers.google.com/chrome-developer-tools/docs/console-api/)'
  id: totrans-4300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Firebug](https://getfirebug.com/wiki/index.php/Console_API)'
  id: totrans-4301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Firefox](https://developer.mozilla.org/en-US/docs/Web/API/console)'
  id: totrans-4302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Internet Explorer](http://msdn.microsoft.com/en-us/library/ie/hh772183.aspx)'
  id: totrans-4303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Node.js](http://nodejs.org/api/stdio.html)'
  id: totrans-4304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Safari](http://bit.ly/1fwq9er)'
  id: totrans-4305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  id: totrans-4306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a bug in Internet Explorer 9\. In that browser, the `console` object
    exists only if the developer tools were open at least once. That means that you
    get a `ReferenceError` if you refer to `console` and the tools weren’t open before.
    As a workaround, you can check whether `console` exists and create a dummy implementation
    if it doesn’t.
  id: totrans-4307
  prefs: []
  type: TYPE_NORMAL
- en: Simple Logging
  id: totrans-4308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console API includes the following logging methods:'
  id: totrans-4309
  prefs: []
  type: TYPE_NORMAL
- en: '`console.clear()`'
  id: totrans-4310
  prefs: []
  type: TYPE_NORMAL
- en: Clear the console.
  id: totrans-4311
  prefs: []
  type: TYPE_NORMAL
- en: '`console.debug(object1, object2?, ...)`'
  id: totrans-4312
  prefs: []
  type: TYPE_NORMAL
- en: Prefer `console.log()`, which does the same as this method.
  id: totrans-4313
  prefs: []
  type: TYPE_NORMAL
- en: '`console.error(object1, object2?, ...)`'
  id: totrans-4314
  prefs: []
  type: TYPE_NORMAL
- en: Log the parameters to the console. In browsers, the logged content may be marked
    by an “error” icon and/or include a stack trace or a link to the code.
  id: totrans-4315
  prefs: []
  type: TYPE_NORMAL
- en: '`console.exception(errorObject, object1?, ...])` [Firebug-only]'
  id: totrans-4316
  prefs: []
  type: TYPE_NORMAL
- en: Log `object1` etc. and show an interactive stack trace.
  id: totrans-4317
  prefs: []
  type: TYPE_NORMAL
- en: '`console.info(object1?, object2?, ...)`'
  id: totrans-4318
  prefs: []
  type: TYPE_NORMAL
- en: Log the parameters to the console. In browsers, the logged content may be marked
    by an “info” icon and/or include a stack trace or a link to the code.
  id: totrans-4319
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(object1?, object2?, ...)`'
  id: totrans-4320
  prefs: []
  type: TYPE_NORMAL
- en: 'Log the parameters to the console. If the first parameter is a `printf`-style
    format string, use it to print the remaining parameters. For example (Node.js
    REPL):'
  id: totrans-4321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1015]'
  id: totrans-4322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1015]'
- en: The only dependable cross-platform formatting directive is `%s`. Node.js supports
    `%j` to format data as JSON; browsers tend to support directives that log something
    interactive to the console.
  id: totrans-4323
  prefs: []
  type: TYPE_NORMAL
- en: '`console.trace()`'
  id: totrans-4324
  prefs: []
  type: TYPE_NORMAL
- en: Logs a stack trace (which is interactive in many browsers).
  id: totrans-4325
  prefs: []
  type: TYPE_NORMAL
- en: '`console.warn(object1?, object2?, ...)`'
  id: totrans-4326
  prefs: []
  type: TYPE_NORMAL
- en: Log the parameters to the console. In browsers, the logged content may be marked
    by a “warning” icon and/or include a stack trace or a link to the code.
  id: totrans-4327
  prefs: []
  type: TYPE_NORMAL
- en: 'Support on various platforms is indicated in the following table:'
  id: totrans-4328
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
  id: totrans-4329
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-4330
  prefs: []
  type: TYPE_TB
- en: '| `clear` | ✓ | ✓ |  | ✓ |  | ✓ |'
  id: totrans-4331
  prefs: []
  type: TYPE_TB
- en: '| `debug` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
  id: totrans-4332
  prefs: []
  type: TYPE_TB
- en: '| `error` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4333
  prefs: []
  type: TYPE_TB
- en: '| *`exception`* |  | ✓ |  |  |  |  |'
  id: totrans-4334
  prefs: []
  type: TYPE_TB
- en: '| `info` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4335
  prefs: []
  type: TYPE_TB
- en: '| `log` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4336
  prefs: []
  type: TYPE_TB
- en: '| `trace` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4337
  prefs: []
  type: TYPE_TB
- en: '| `warn` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4338
  prefs: []
  type: TYPE_TB
- en: '`exception` has been typeset in italics, because it is supported only on a
    single platform.'
  id: totrans-4339
  prefs: []
  type: TYPE_NORMAL
- en: Checking and Counting
  id: totrans-4340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console API includes the following checking and counting methods:'
  id: totrans-4341
  prefs: []
  type: TYPE_NORMAL
- en: '`console.assert(expr, obj?)`'
  id: totrans-4342
  prefs: []
  type: TYPE_NORMAL
- en: If `expr` is `false`, log `obj` to the console and throw an exception. If it
    is `true`, do nothing.
  id: totrans-4343
  prefs: []
  type: TYPE_NORMAL
- en: '`console.count(label?)`'
  id: totrans-4344
  prefs: []
  type: TYPE_NORMAL
- en: Count how many times the line with this statement is executed with this label.
  id: totrans-4345
  prefs: []
  type: TYPE_NORMAL
- en: 'Support on various platforms is indicated in the following table:'
  id: totrans-4346
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
  id: totrans-4347
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-4348
  prefs: []
  type: TYPE_TB
- en: '| `assert` | ✓ | ✓ |  | ✓ | ✓ | ✓ |'
  id: totrans-4349
  prefs: []
  type: TYPE_TB
- en: '| `count` | ✓ | ✓ |  | ✓ |  | ✓ |'
  id: totrans-4350
  prefs: []
  type: TYPE_TB
- en: Formatted Logging
  id: totrans-4351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console API includes the following methods for formatted logging:'
  id: totrans-4352
  prefs: []
  type: TYPE_NORMAL
- en: '`console.dir(object)`'
  id: totrans-4353
  prefs: []
  type: TYPE_NORMAL
- en: Print a representation of the object to the console. In browsers, that representation
    can be explored interactively.
  id: totrans-4354
  prefs: []
  type: TYPE_NORMAL
- en: '`console.dirxml(object)`'
  id: totrans-4355
  prefs: []
  type: TYPE_NORMAL
- en: Print the XML source tree of an HTML or XML element.
  id: totrans-4356
  prefs: []
  type: TYPE_NORMAL
- en: '`console.group(object1?, object2?, ...)`'
  id: totrans-4357
  prefs: []
  type: TYPE_NORMAL
- en: Log the objects to the console and open a nested block that contains all future
    logged content. Close the block by calling `console.groupEnd()`. The block is
    initially expanded, but can be collapsed.
  id: totrans-4358
  prefs: []
  type: TYPE_NORMAL
- en: '`console.groupCollapsed(object1?, object2?, ...)`'
  id: totrans-4359
  prefs: []
  type: TYPE_NORMAL
- en: Works like `console.group()`, but the block is initially collapsed.
  id: totrans-4360
  prefs: []
  type: TYPE_NORMAL
- en: '`console.groupEnd()`'
  id: totrans-4361
  prefs: []
  type: TYPE_NORMAL
- en: Close a group that has been opened by `console.group()` or `console.group` `Collapsed()`.
  id: totrans-4362
  prefs: []
  type: TYPE_NORMAL
- en: '`console.table(data, columns?)`'
  id: totrans-4363
  prefs: []
  type: TYPE_NORMAL
- en: 'Print an array as a table, one element per row. The optional parameter `columns`
    specifies which properties/array indices are shown in the columns. If that parameter
    is missing, all property keys are used as table columns. Missing properties and
    array elements show up as `undefined` in columns:'
  id: totrans-4364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1016]'
  id: totrans-4365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1016]'
- en: 'The resulting table is as follows:'
  id: totrans-4366
  prefs: []
  type: TYPE_NORMAL
- en: '| (index) | firstName | lastName | age |'
  id: totrans-4367
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-4368
  prefs: []
  type: TYPE_TB
- en: '| 0 | “Jane” | “Bond” | undefined |'
  id: totrans-4369
  prefs: []
  type: TYPE_TB
- en: '| 1 | “Lars” | “Croft” | 72 |'
  id: totrans-4370
  prefs: []
  type: TYPE_TB
- en: 'Support on various platforms is indicated in the following table:'
  id: totrans-4371
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
  id: totrans-4372
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-4373
  prefs: []
  type: TYPE_TB
- en: '| `dir` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4374
  prefs: []
  type: TYPE_TB
- en: '| `dirxml` | ✓ | ✓ |  | ✓ |  | ✓ |'
  id: totrans-4375
  prefs: []
  type: TYPE_TB
- en: '| `group` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
  id: totrans-4376
  prefs: []
  type: TYPE_TB
- en: '| `groupCollapsed` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
  id: totrans-4377
  prefs: []
  type: TYPE_TB
- en: '| `groupEnd` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
  id: totrans-4378
  prefs: []
  type: TYPE_TB
- en: '| `table` | ✓ | ✓ |  |  |  |  |'
  id: totrans-4379
  prefs: []
  type: TYPE_TB
- en: Profiling and Timing
  id: totrans-4380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console API includes the following methods for profiling and timing:'
  id: totrans-4381
  prefs: []
  type: TYPE_NORMAL
- en: '`console.markTimeline(label)` [Safari-only]'
  id: totrans-4382
  prefs: []
  type: TYPE_NORMAL
- en: The same as `console.timeStamp`.
  id: totrans-4383
  prefs: []
  type: TYPE_NORMAL
- en: '`console.profile(title?)`'
  id: totrans-4384
  prefs: []
  type: TYPE_NORMAL
- en: Turn on profiling. The optional `title` is used for the profile report.
  id: totrans-4385
  prefs: []
  type: TYPE_NORMAL
- en: '`console.profileEnd()`'
  id: totrans-4386
  prefs: []
  type: TYPE_NORMAL
- en: Stop profiling and print the profile report.
  id: totrans-4387
  prefs: []
  type: TYPE_NORMAL
- en: '`console.time(label)`'
  id: totrans-4388
  prefs: []
  type: TYPE_NORMAL
- en: Start a timer whose label is `label`.
  id: totrans-4389
  prefs: []
  type: TYPE_NORMAL
- en: '`console.timeEnd(label)`'
  id: totrans-4390
  prefs: []
  type: TYPE_NORMAL
- en: Stop the timer whose label is `label` and print the time that has elapsed since
    starting it.
  id: totrans-4391
  prefs: []
  type: TYPE_NORMAL
- en: '`console.timeStamp(label?)`'
  id: totrans-4392
  prefs: []
  type: TYPE_NORMAL
- en: Log a timestamp with the given `label`. May be logged to the console or a timeline.
  id: totrans-4393
  prefs: []
  type: TYPE_NORMAL
- en: 'Support on various platforms is indicated in the following table:'
  id: totrans-4394
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
  id: totrans-4395
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-4396
  prefs: []
  type: TYPE_TB
- en: '| *`markTimeline`* |  |  |  |  |  | ✓ |'
  id: totrans-4397
  prefs: []
  type: TYPE_TB
- en: '| `profile` | ✓ | ✓ | (devtools) | ✓ |  | ✓ |'
  id: totrans-4398
  prefs: []
  type: TYPE_TB
- en: '| `profileEnd` | ✓ | ✓ | (devtools) | ✓ |  | ✓ |'
  id: totrans-4399
  prefs: []
  type: TYPE_TB
- en: '| `time` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4400
  prefs: []
  type: TYPE_TB
- en: '| `timeEnd` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4401
  prefs: []
  type: TYPE_TB
- en: '| `timeStamp` | ✓ | ✓ |  |  |  |  |'
  id: totrans-4402
  prefs: []
  type: TYPE_TB
- en: '`markTimeline` has been typeset in italics, because it is supported only on
    a single platform. The (devtools) designation means that the developer tools must
    be open in order for the method to work.^([[17](#ftn.id1069062)])'
  id: totrans-4403
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces and Special Values
  id: totrans-4404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following global variables serve as namespaces for functions. For details,
    see the material indicated in parentheses:'
  id: totrans-4405
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON`'
  id: totrans-4406
  prefs: []
  type: TYPE_NORMAL
- en: JSON API functionality ([Chapter 22](ch22.html "Chapter 22. JSON"))
  id: totrans-4407
  prefs: []
  type: TYPE_NORMAL
- en: '`Math`'
  id: totrans-4408
  prefs: []
  type: TYPE_NORMAL
- en: Math API functionality ([Chapter 21](ch21.html "Chapter 21. Math"))
  id: totrans-4409
  prefs: []
  type: TYPE_NORMAL
- en: '`Object`'
  id: totrans-4410
  prefs: []
  type: TYPE_NORMAL
- en: 'Metaprogramming functionality ([Cheat Sheet: Working with Objects](ch17_split_001.html#oop_cheat_sheet
    "Cheat Sheet: Working with Objects"))'
  id: totrans-4411
  prefs: []
  type: TYPE_NORMAL
- en: 'The following global variables contain special values. For more on them, review
    the material indicated in parentheses:'
  id: totrans-4412
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined`'
  id: totrans-4413
  prefs: []
  type: TYPE_NORMAL
- en: 'A value expressing that something does not exist ([undefined and null](ch08.html#undefined_null
    "undefined and null")):'
  id: totrans-4414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1017]'
  id: totrans-4415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1017]'
- en: '`NaN`'
  id: totrans-4416
  prefs: []
  type: TYPE_NORMAL
- en: 'A value expressing that something is “not a number” ([NaN](ch11.html#nan "NaN")):'
  id: totrans-4417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1018]'
  id: totrans-4418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1018]'
- en: '`Infinity`'
  id: totrans-4419
  prefs: []
  type: TYPE_NORMAL
- en: 'A value denoting numeric infinity ∞ ([Infinity](ch11.html#infinity "Infinity")):'
  id: totrans-4420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1019]'
  id: totrans-4421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1019]'
- en: '* * *'
  id: totrans-4422
  prefs: []
  type: TYPE_NORMAL
- en: ^([[16](#id1065911)]) Mariusz Nowak (@medikoo) told me that code evaluated by
    `Function` is sloppy by default, everywhere.
  id: totrans-4423
  prefs: []
  type: TYPE_NORMAL
- en: ^([[17](#id1069062)]) Thanks to Matthias Reuter (@gweax) and Philipp Kyeck (@pkyeck),
    who contributed to this section.
  id: totrans-4424
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 24. Unicode and JavaScript
  id: totrans-4425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter is a brief introduction to Unicode and how it is handled in JavaScript.
  id: totrans-4426
  prefs: []
  type: TYPE_NORMAL
- en: Unicode History
  id: totrans-4427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unicode was started in 1987, by Joe Becker (Xerox), Lee Collins (Apple), and
    Mark Davis (Apple). The idea was to create a universal character set, as there
    were many incompatible standards for encoding plain text at that time: numerous
    variations of 8-bit ASCII, Big Five (Traditional Chinese), GB 2312 (Simplified
    Chinese), and more. Before Unicode, no standard for multilingual plain text existed,
    but there were rich-text systems (such as Apple’s WorldScript) that allowed you
    to combine multiple encodings.'
  id: totrans-4428
  prefs: []
  type: TYPE_NORMAL
- en: 'The first Unicode draft proposal was published in 1988\. Work continued afterward
    and the working group expanded. The [*Unicode Consortium*](http://www.unicode.org/consortium/consort.html)
    was incorporated on January 3, 1991:'
  id: totrans-4429
  prefs: []
  type: TYPE_NORMAL
- en: The Unicode Consortium is a non-profit corporation devoted to developing, maintaining,
    and promoting software internationalization standards and data, particularly the
    Unicode Standard [...]
  id: totrans-4430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The first volume of the Unicode 1.0 standard was published in October 1991,
    and the second in June 1992.
  id: totrans-4431
  prefs: []
  type: TYPE_NORMAL
- en: Important Unicode Concepts
  id: totrans-4432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea of a character may seem a simple one, but there are many aspects to
    it. That’s why Unicode is such a complex standard. The following are important
    basic concepts:'
  id: totrans-4433
  prefs: []
  type: TYPE_NORMAL
- en: Characters and graphemes
  id: totrans-4434
  prefs: []
  type: TYPE_NORMAL
- en: These two terms mean something quite similar. Characters are digital entities,
    while graphemes are atomic units of written languages (alphabetic letters, typographic
    ligatures, Chinese characters, punctuation marks, etc.). Programmers think in
    characters, but users think in graphemes. Sometimes several characters are used
    to represent a single grapheme. For example, we can produce the single grapheme
    ô by combining the character *o* and the character ^ (the circumflex accent).
  id: totrans-4435
  prefs: []
  type: TYPE_NORMAL
- en: Glyph
  id: totrans-4436
  prefs: []
  type: TYPE_NORMAL
- en: This is a concrete way of displaying a grapheme. Sometimes, the same grapheme
    is displayed differently, depending on its context or other factors. For example,
    the graphemes *f* and *i* can be presented as a glyph *f* and a glyph *i*, connected
    by a ligature glyph, or without a ligature.
  id: totrans-4437
  prefs: []
  type: TYPE_NORMAL
- en: Code points
  id: totrans-4438
  prefs: []
  type: TYPE_NORMAL
- en: Unicode represents the characters it supports via numbers called *code points*.
    The hexadecimal range of code points is 0x0 to 0x10FFFF (17 times 16 bits).
  id: totrans-4439
  prefs: []
  type: TYPE_NORMAL
- en: Code units
  id: totrans-4440
  prefs: []
  type: TYPE_NORMAL
- en: To store or transmit code points, we encode them as *code units*, pieces of
    data with a fixed length. The length is measured in bits and determined by an
    encoding scheme, of which Unicode has several—for example, UTF-8 and UTF-16\.
    The number in the name indicates the length of the code unit, in bits. If a code
    point is too large to fit into a single code unit, it must be broken up into multiple
    units; that is, the number of code units needed to represent a single code point
    can vary.
  id: totrans-4441
  prefs: []
  type: TYPE_NORMAL
- en: BOM (byte order mark)
  id: totrans-4442
  prefs: []
  type: TYPE_NORMAL
- en: 'If a code unit is larger than a single byte, byte ordering matters. The BOM
    is a single pseudocharacter (possibly encoded as multiple code units) at the beginning
    of a text that indicates whether the code units are *big endian* (most significant
    bytes come first) or *little endian* (least significant bytes come first). The
    default for texts without a BOM is big endian. The BOM also indicates the encoding
    that is used; it is different for UTF-8, UTF-16, and so on. Additionally, it serves
    as a marker for Unicode if web browsers have no other information regarding the
    encoding of a text. However, the BOM is not used very often, for several reasons:'
  id: totrans-4443
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 is by far the most popular Unicode encoding and does not need a BOM, because
    there is only one way of ordering bytes.
  id: totrans-4444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several character encodings specify a fixed byte ordering. Then a BOM must not
    be used. Examples include UTF-16BE (UTF-16 big endian), UTF-16LE, UTF-32BE, and
    UTF-32LE. This is a safer way of handling byte ordering, because metadata and
    data stay separate and can’t be mixed up.
  id: totrans-4445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normalization
  id: totrans-4446
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the same grapheme can be represented in several ways. For example,
    the grapheme ö can be represented as a single code point or as an *o* followed
    by a combining character ¨ (diaeresis, double dot). Normalization is about translating
    a text to a canonical representation; equivalent code points and sequences of
    code points are all translated to the same code point (or sequence of code points).
    That is useful for text processing (e.g., to search for text). Unicode specifies
    several normalizations.
  id: totrans-4447
  prefs: []
  type: TYPE_NORMAL
- en: Character properties
  id: totrans-4448
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Unicode character is assigned several properties by the specification,
    some of which are listed here:'
  id: totrans-4449
  prefs: []
  type: TYPE_NORMAL
- en: '*Name*. An English name, composed of uppercase letters A–Z, digits 0–9, hyphen
    (-), and <space>. Two examples:'
  id: totrans-4450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “λ” has the name “GREEK SMALL LETTER LAMBDA.”
  id: totrans-4451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “!” has the name “EXCLAMATION MARK.”
  id: totrans-4452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*General category*](http://bit.ly/1fwsjL9). Partitions characters into categories
    such as letter, uppercase letter, number, and punctuation.'
  id: totrans-4453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Age*. With what version of Unicode was the character introduced (1.0, 1.1.,
    2.0, etc.)?'
  id: totrans-4454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deprecated*. Is the use of the character discouraged?'
  id: totrans-4455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*And many more*.'
  id: totrans-4456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code Points
  id: totrans-4457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The range of the code points was initially 16 bits. With Unicode version 2.0
    (July 1996), it was expanded: it is now divided into 17 *planes*, numbered from
    0 to 16\. Each plane comprises 16 bits (in hexadecimal notation: 0x0000–0xFFFF).
    Thus, in the hexadecimal ranges that follow, digits beyond the four bottom ones
    contain the number of the plane.'
  id: totrans-4458
  prefs: []
  type: TYPE_NORMAL
- en: 'Plane 0, Basic Multilingual Plane (BMP): 0x0000–0xFFFF'
  id: totrans-4459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plane 1, Supplementary Multilingual Plane (SMP): 0x10000–0x1FFFF'
  id: totrans-4460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plane 2, Supplementary Ideographic Plane (SIP): 0x20000–0x2FFFF'
  id: totrans-4461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planes 3–13, Unassigned
  id: totrans-4462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plane 14, Supplementary Special-Purpose Plane (SSP): 0xE0000–0xEFFFF'
  id: totrans-4463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Planes 15–16, Supplementary Private Use Area (S PUA A/B): 0x0F0000–0x10FFFF'
  id: totrans-4464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planes 1–16 are called *supplementary planes* or *astral planes*.
  id: totrans-4465
  prefs: []
  type: TYPE_NORMAL
- en: Unicode Encodings
  id: totrans-4466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*UTF-32* (Unicode Transformation Format 32) is a format with 32-bit code units.
    Any code point can be encoded by a single code unit, making this the only fixed-length
    encoding; for other encodings, the number of units needed to encode a point varies.'
  id: totrans-4467
  prefs: []
  type: TYPE_NORMAL
- en: '*UTF-16* is a format with 16-bit code units that needs one to two units to
    represent a code point. BMP code points can be represented by single code units.
    Higher code points are 20 bit (16 times 16 bits), after 0x10000 (the range of
    the BMP) is subtracted. These bits are encoded as two code units (a so-called
    *surrogate pair*):'
  id: totrans-4468
  prefs: []
  type: TYPE_NORMAL
- en: Leading surrogate
  id: totrans-4469
  prefs: []
  type: TYPE_NORMAL
- en: 'Most significant 10 bits: stored in the range 0xD800–0xDBFF. Also called *high-surrogate
    code unit*.'
  id: totrans-4470
  prefs: []
  type: TYPE_NORMAL
- en: Trailing surrogate
  id: totrans-4471
  prefs: []
  type: TYPE_NORMAL
- en: 'Least significant 10 bits: stored in the range 0xDC00–0xDFFF. Also called *low-surrogate
    code unit*.'
  id: totrans-4472
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table (adapted from Unicode Standard 6.2.0, Table 3-5) visualizes
    how the bits are distributed:'
  id: totrans-4473
  prefs: []
  type: TYPE_NORMAL
- en: '| Code point | UTF-16 code unit(s) |'
  id: totrans-4474
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-4475
  prefs: []
  type: TYPE_TB
- en: '| xxxxxxxxxxxxxxxx (16 bits) | xxxxxxxxxxxxxxxx |'
  id: totrans-4476
  prefs: []
  type: TYPE_TB
- en: '| pppppxxxxxxyyyyyyyyyy (21 bits = 5+6+10 bits) | 110110qqqqxxxxxx 110111yyyyyyyyyy
    (qqqq = ppppp − 1) |'
  id: totrans-4477
  prefs: []
  type: TYPE_TB
- en: 'To enable this encoding scheme, the BMP has a hole with unused code points
    whose range is 0xD800–0xDFFF. Therefore, the ranges of leading surrogates, trailing
    surrogates, and BMP code points are disjoint, making decoding robust in the face
    of errors. The following function encodes a code point as UTF-16 (later we’ll
    see an example of using it):'
  id: totrans-4478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1020]'
  id: totrans-4479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1020]'
- en: '*UCS-2*, a deprecated format, uses 16-bit code units to represent (only!) the
    code points of the BMP. When the range of Unicode code points expanded beyond
    16 bits, UTF-16 replaced UCS-2.'
  id: totrans-4480
  prefs: []
  type: TYPE_NORMAL
- en: '*UTF-8* has 8-bit code units. It builds a bridge between the legacy ASCII encoding
    and Unicode. ASCII has only 128 characters, whose numbers are the same as the
    first 128 Unicode code points. UTF-8 is backward compatible, because all ASCII
    codes are valid code units. In other words, a single code unit in the range 0–127
    encodes a single code point in the same range. Such code units are marked by their
    highest bit being zero. If, on the other hand, the highest bit is one, then more
    units will follow, to provide the additional bits for the higher code points.
    That leads to the following encoding scheme:'
  id: totrans-4481
  prefs: []
  type: TYPE_NORMAL
- en: '0000–007F: 0xxxxxxx (7 bits, stored in 1 byte)'
  id: totrans-4482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0080–07FF: 110xxxxx, 10xxxxxx (5+6 bits = 11 bits, stored in 2 bytes)'
  id: totrans-4483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0800–FFFF: 1110xxxx, 10xxxxxx, 10xxxxxx (4+6+6 bits = 16 bits, stored in 3
    bytes)'
  id: totrans-4484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '10000–1FFFFF: 11110xxx, 10xxxxxx, 10xxxxxx, 10xxxxxx (3+6+6+6 bits = 21 bits,
    stored in 4 bytes). The highest code point is 10FFFF, so UTF-8 has some extra
    room.'
  id: totrans-4485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the highest bit is not 0, then the number of ones before the zero indicates
    how many code units there are in a sequence. All code units after the initial
    one have the bit prefix 10\. Therefore, the ranges of initial code units and subsequent
    code units are disjoint, which helps with recovering from encoding errors.
  id: totrans-4486
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 has become the most popular Unicode format. Initially, its popularity
    was due to its backward compatibility with ASCII. Later, it gained traction because
    of its broad and consistent support across operating systems, programming environments,
    and applications.
  id: totrans-4487
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Source Code and Unicode
  id: totrans-4488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways in which JavaScript handles Unicode source code: internally
    (during parsing) and externally (while loading a file).'
  id: totrans-4489
  prefs: []
  type: TYPE_NORMAL
- en: Source Code Internally
  id: totrans-4490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Internally, JavaScript source code is treated as a sequence of UTF-16 code
    units. According to [Section 6](http://ecma-international.org/ecma-262/5.1/#sec-6)
    of the EMCAScript specification:'
  id: totrans-4491
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript source text is represented as a sequence of characters in the Unicode
    character encoding, version 3.0 or later. [...] ECMAScript source text is assumed
    to be a sequence of 16-bit code units for the purposes of this specification.
    [...] If an actual source text is encoded in a form other than 16-bit code units,
    it must be processed as if it was first converted to UTF-16.
  id: totrans-4492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In identifiers, string literals, and regular expression literals, any code
    unit can also be expressed via a Unicode escape sequence `\uHHHH`, where `HHHH`
    are four hexadecimal digits. For example:'
  id: totrans-4493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1021]'
  id: totrans-4494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1021]'
- en: That means that you can use Unicode characters in literals and variable names,
    without leaving the ASCII range in the source code.
  id: totrans-4495
  prefs: []
  type: TYPE_NORMAL
- en: 'In string literals, an additional kind of escape is available: *hexadecimal
    escape sequences* with two-digit hexadecimal numbers that represent code units
    in the range 0x00–0xFF. For example:'
  id: totrans-4496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1022]'
  id: totrans-4497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1022]'
- en: Source Code Externally
  id: totrans-4498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While UTF-16 is used internally, JavaScript source code is usually not stored
    in that format. When a web browser loads a source file via a `<script>` tag, it
    determines the encoding [as follows](http://bit.ly/1fwstC9):'
  id: totrans-4499
  prefs: []
  type: TYPE_NORMAL
- en: If the file starts with a BOM, the encoding is a UTF variant, depending on what
    BOM is used.
  id: totrans-4500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, if the file is loaded via HTTP(S), then the `Content-Type` header
    can specify an encoding, via the `charset` parameter. For example:'
  id: totrans-4501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1023]'
  id: totrans-4502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1023]'
- en: Tip
  id: totrans-4503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The correct *media type* (formerly known as *MIME type*) for JavaScript files
    is `application/javascript`. However, older browsers (e.g., Internet Explorer
    8 and earlier) work most reliably with `text/javascript`. Unfortunately, the [default
    value](http://bit.ly/1fwsvKe) for the attribute `type` of `<script>` tags is `text/javascript`.
    At least you can omit that attribute for JavaScript; there is no benefit in including
    it.
  id: totrans-4504
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if the `<script>` tag has the attribute `charset`, then that encoding
    is used. Even though the attribute `type` holds a valid media type, that type
    must not have the parameter `charset` (like in the aforementioned `Content-Type`
    header). That ensures that the values of `charset` and `type` don’t clash.
  id: totrans-4505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, the encoding of the document is used, in which the `<script>` tag
    resides. For example, this is the beginning of an HTML5 document, where a `<meta>`
    tag declares that the document is encoded as UTF-8:'
  id: totrans-4506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1024]'
  id: totrans-4507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1024]'
- en: It is highly recommended that you always specify an encoding. If you don’t,
    a locale-specific [default encoding](http://bit.ly/1oODGWp) is used. In other
    words, people will see the file differently in different countries. Only the lowest
    7 bits are relatively stable across locales.
  id: totrans-4508
  prefs: []
  type: TYPE_NORMAL
- en: 'My recommendations can be summarized as follows:'
  id: totrans-4509
  prefs: []
  type: TYPE_NORMAL
- en: For your own application, you can use Unicode. But you must specify the encoding
    of the app’s HTML page as UTF-8.
  id: totrans-4510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For libraries, it’s safest to release code that is ASCII (7 bit).
  id: totrans-4511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some minification tools can translate source with Unicode code points beyond
    7 bit to source that is “7-bit clean.” They do so by replacing non-ASCII characters
    with Unicode escapes. For example, the following invocation of [UglifyJS](https://github.com/mishoo/UglifyJS2)
    translates the file *test.js*:'
  id: totrans-4512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1025]'
  id: totrans-4513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1025]'
- en: 'The file *test.js* looks like this:'
  id: totrans-4514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1026]'
  id: totrans-4515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1026]'
- en: 'The output of UglifyJS looks like this:'
  id: totrans-4516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1027]'
  id: totrans-4517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1027]'
- en: 'Consider the following negative example. For a while, the library D3.js was
    published in UTF-8\. That caused an [error](https://github.com/mbostock/d3/issues/1195)
    when it was loaded from a page whose encoding was not UTF-8, because the code
    contained statements such as:'
  id: totrans-4518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1028]'
  id: totrans-4519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1028]'
- en: 'The identifiers π and ε were not decoded correctly and not recognized as valid
    variable names. Additionally, some string literals with code points beyond 7 bit
    weren’t decoded correctly either. As a workaround, you could load the code by
    adding the appropriate `charset` attribute to the `<script>` tag:'
  id: totrans-4520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1029]'
  id: totrans-4521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1029]'
- en: JavaScript Strings and Unicode
  id: totrans-4522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JavaScript string is a sequence of UTF-16 code units. According to the ECMAScript
    specification, [Section 8.4](http://ecma-international.org/ecma-262/5.1/#sec-8.4):'
  id: totrans-4523
  prefs: []
  type: TYPE_NORMAL
- en: When a String contains actual textual data, each element is considered to be
    a single UTF-16 code unit.
  id: totrans-4524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Escape Sequences
  id: totrans-4525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned before, you can use Unicode escape sequences and hexadecimal escape
    sequences in string literals. For example, you can produce the character ö by
    combining an *o* with a diaeresis (code point 0x0308):'
  id: totrans-4526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1030]'
  id: totrans-4527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1030]'
- en: This works in JavaScript command lines, such as web browser consoles and the
    Node.js REPL. You can also insert this kind of string into the DOM of a web page.
  id: totrans-4528
  prefs: []
  type: TYPE_NORMAL
- en: Refering to Astral Plane Characters via Escapes
  id: totrans-4529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many nice Unicode symbol tables on the Web. Take a look at Tim Whitlock’s
    [“Emoji Unicode Tables”](http://apps.timwhitlock.info/emoji/tables/unicode) and
    be amazed by how many symbols there are in modern Unicode fonts. None of the symbols
    in the table are images; they are all font glyphs. Let’s assume you want to display
    a Unicode character via JavaScript that is in an astral plane (obviously, there
    is a risk when doing so: not all fonts support all such characters). For example,
    consider a cow, code point 0x1F404: ![](images/spjs_24in01.png.jpg).'
  id: totrans-4530
  prefs: []
  type: TYPE_NORMAL
- en: 'You can copy the character and paste it directly into your Unicode-encoded
    JavaScript source:'
  id: totrans-4531
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/spjs_24in02.png)'
  id: totrans-4532
  prefs: []
  type: TYPE_IMG
- en: 'JavaScript engines will decode the source (which is most often in UTF-8) and
    create a string with two UTF-16 code units. Alternatively, you can compute the
    two code units yourself and use Unicode escape sequences. There are web apps that
    perform this computation, such as:'
  id: totrans-4533
  prefs: []
  type: TYPE_NORMAL
- en: '[UTF Converter](http://macchiato.com/unicode/convert.html)'
  id: totrans-4534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“JavaScript escapes”](http://mothereff.in/js-escapes) by Mathias Bynens'
  id: totrans-4535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The previously defined function `toUTF16` performs it, too:'
  id: totrans-4536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1031]'
  id: totrans-4537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1031]'
- en: 'The UTF-16 surrogate pair (0xD83D, 0xDC04) does indeed encode the cow:'
  id: totrans-4538
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/spjs_24in03.png)'
  id: totrans-4539
  prefs: []
  type: TYPE_IMG
- en: Counting Characters
  id: totrans-4540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a string contains a surrogate pair (two code units encoding a single code
    point), then the `length` property doesn’t count graphemes anymore. It counts
    code units:'
  id: totrans-4541
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/spjs_24in04.png)'
  id: totrans-4542
  prefs: []
  type: TYPE_IMG
- en: 'This can be fixed via libraries, such as Mathias Bynens’s [Punycode.js](https://github.com/bestiejs/punycode.js),
    which is bundled with Node.js:'
  id: totrans-4543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1032]'
  id: totrans-4544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1032]'
- en: Unicode Normalization
  id: totrans-4545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to search in strings or compare them, then you need to normalize—for
    example, via the library [unorm](https://github.com/walling/unorm) (by Bjarke
    Walling).
  id: totrans-4546
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Regular Expressions and Unicode
  id: totrans-4547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Support for Unicode in JavaScript’s regular expressions (see [Chapter 19](ch19.html
    "Chapter 19. Regular Expressions")) is very limited. For example, there is no
    way to match Unicode categories such as “uppercase letter.”
  id: totrans-4548
  prefs: []
  type: TYPE_NORMAL
- en: 'Line terminators influence matching. A line terminator is one of four characters,
    specified in the following table:'
  id: totrans-4549
  prefs: []
  type: TYPE_NORMAL
- en: '| Code unit | Name | Character escape sequence |'
  id: totrans-4550
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-4551
  prefs: []
  type: TYPE_TB
- en: '| \u000A | Line feed | `\n` |'
  id: totrans-4552
  prefs: []
  type: TYPE_TB
- en: '| \u000D | Carriage return | `\r` |'
  id: totrans-4553
  prefs: []
  type: TYPE_TB
- en: '| \u2028 | Line separator |  |'
  id: totrans-4554
  prefs: []
  type: TYPE_TB
- en: '| \u2029 | Paragraph separator |  |'
  id: totrans-4555
  prefs: []
  type: TYPE_TB
- en: 'The following regular expression constructs are based on Unicode:'
  id: totrans-4556
  prefs: []
  type: TYPE_NORMAL
- en: '`\s \S` (whitespace, nonwhitespace) have Unicode-based definitions:'
  id: totrans-4557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1033]'
  id: totrans-4558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1033]'
- en: '`.` (dot) matches all code units (not code points!) except line terminators.
    See the next section to learn how to match any code point.'
  id: totrans-4559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiline mode `/m`: In multiline mode, the assertion `^` matches at the beginning
    of the input and after line terminators. The assertion `$` matches before line
    terminators and at the end of the input. In nonmultiline mode, they match only
    at the beginning or the end of the input, respectively.'
  id: totrans-4560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other important character classes have definitions that are based on ASCII,
    not on Unicode:'
  id: totrans-4561
  prefs: []
  type: TYPE_NORMAL
- en: '`\d \D` (digits, nondigits): A digit is equivalent to `[0-9]`.'
  id: totrans-4562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\w \W` (word characters, nonword characters): A word character is equivalent
    to `[A-Za-z0-9_]`.'
  id: totrans-4563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\b \B` (at word breaks, inside words): Words are sequences of word characters
    (`[A-Za-z0-9_]`). For example, in the string `''über''`, the character class escape
    `\b` sees the character *b* as starting a word:'
  id: totrans-4564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1034]'
  id: totrans-4565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1034]'
- en: Matching Any Code Unit and Any Code Point
  id: totrans-4566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To match any code unit, you can use `[\s\S]`; see [Atoms: General](ch19.html#regex_atoms_general
    "Atoms: General").'
  id: totrans-4567
  prefs: []
  type: TYPE_NORMAL
- en: To match any code point, you need to use:^([[18](#ftn.id1072129)])
  id: totrans-4568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1035]'
  id: totrans-4569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1035]'
- en: 'The preceding pattern works like this:'
  id: totrans-4570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1036]'
  id: totrans-4571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1036]'
- en: As all of these ranges are disjoint, the pattern will correctly match code points
    in well-formed UTF-16 strings.
  id: totrans-4572
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  id: totrans-4573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A few libraries help with handling Unicode in JavaScript:'
  id: totrans-4574
  prefs: []
  type: TYPE_NORMAL
- en: '[Regenerate](https://github.com/mathiasbynens/regenerate) helps with generating
    ranges like the preceding one, for matching any code unit. It is meant to be used
    as part of a build tool, but also works dynamically, for trying out things.'
  id: totrans-4575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[XRegExp](http://xregexp.com) is a regular expression library that has an [official
    add-on](http://xregexp.com/plugins/#unicode) for matching Unicode categories,
    scripts, blocks, and properties via one of the following three constructs:'
  id: totrans-4576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1037]'
  id: totrans-4577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1037]'
- en: For example, `\p{Letter}` matches letters in various alphabets while `\p{^Letter}`
    and `\P{Letter}` both match all other code points. [Chapter 30](ch30.html "Chapter 30. Libraries")
    contains a brief overview of XRegExp.
  id: totrans-4578
  prefs: []
  type: TYPE_NORMAL
- en: The ECMAScript Internationalization API (see [The ECMAScript Internationalization
    API](ch30.html#i18n_api "The ECMAScript Internationalization API")) provides Unicode-aware
    collation (sorting and searching of strings) and more.
  id: totrans-4579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommended Reading and Chapter Sources
  id: totrans-4580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on Unicode, see the following:'
  id: totrans-4581
  prefs: []
  type: TYPE_NORMAL
- en: Wikipedia has several good entries on [Unicode](http://en.wikipedia.org/wiki/Unicode)
    and its terminology.
  id: totrans-4582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Unicode.org](http://www.unicode.org/), the official website of the Unicode
    Consortium, and its [FAQ](http://www.unicode.org/faq/) are also good resources.'
  id: totrans-4583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joel Spolsky’s introductory article [“The Absolute Minimum Every Software Developer
    Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)”](http://www.joelonsoftware.com/articles/Unicode.html)
    is helpful.
  id: totrans-4584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For information on Unicode support in JavaScript, see:'
  id: totrans-4585
  prefs: []
  type: TYPE_NORMAL
- en: '[“JavaScript’s internal character encoding: UCS-2 or UTF-16?”](http://mathiasbynens.be/notes/javascript-encoding)
    by Mathias Bynens'
  id: totrans-4586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“JavaScript, Regex, and Unicode”](http://bit.ly/1oOE0oh) by Steven Levithan'
  id: totrans-4587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acknowledgments
  id: totrans-4588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following people contributed to this chapter: Mathias Bynens (@mathias),
    Anne van Kesteren ‏(@annevk), and Calvin Metcalf ‏(@CWMma).'
  id: totrans-4589
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-4590
  prefs: []
  type: TYPE_NORMAL
- en: ^([[18](#id1072129)]) Strictly speaking, any [Unicode scalar value](http://www.unicode.org/glossary/#unicode_scalar_value).
  id: totrans-4591
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 25. New in ECMAScript 5
  id: totrans-4592
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter lists features that are available only in ECMAScript 5\. Should
    you have to work with older JavaScript engines, you should avoid these features
    or enable some of them via a library (how is described later). Note that normally,
    this book assumes that you are working with modern engines, which fully support
    ECMAScript 5.
  id: totrans-4593
  prefs: []
  type: TYPE_NORMAL
- en: 'The ECMAScript 5 specification contains the following description of its scope:'
  id: totrans-4594
  prefs: []
  type: TYPE_NORMAL
- en: The fifth edition of ECMAScript (published as ECMA-262 5th edition)
  id: totrans-4595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-4596
  prefs: []
  type: TYPE_NORMAL
- en: codifies de facto interpretations of the language specification that have become
    common among browser implementations and
  id: totrans-4597
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: adds support for new features that have emerged since the publication of the
    third edition. Such features include
  id: totrans-4598
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '>'
  id: totrans-4599
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-4600
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-4601
  prefs: []
  type: TYPE_NORMAL
- en: accessor properties,
  id: totrans-4602
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: reflective creation and inspection of objects,
  id: totrans-4603
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: program control of property attributes,
  id: totrans-4604
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: additional array manipulation functions,
  id: totrans-4605
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: support for the JSON object encoding format, and
  id: totrans-4606
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a strict mode that provides enhanced error checking and program security.
  id: totrans-4607
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: New Features
  id: totrans-4608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new features included in ECMAScript 5 are as follows:'
  id: totrans-4609
  prefs: []
  type: TYPE_NORMAL
- en: Strict mode (see [Strict Mode](ch07.html#strict_mode "Strict Mode"))
  id: totrans-4610
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting the following line first in a file or a function switches on the so-called
    *strict mode* that makes JavaScript a cleaner language by forbidding some features,
    performing more checks, and throwing more exceptions:'
  id: totrans-4611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1038]'
  id: totrans-4612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1038]'
- en: Accessors (see [Accessors (Getters and Setters)](ch17_split_000.html#getters_setters
    "Accessors (Getters and Setters)"))
  id: totrans-4613
  prefs: []
  type: TYPE_NORMAL
- en: 'Getters and setters allow you to implement the getting and setting of a property
    via methods. For example, the following object `obj` contains a getter for the
    property `foo`:'
  id: totrans-4614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1039]'
  id: totrans-4615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1039]'
- en: Syntactic Changes
  id: totrans-4616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ECMAScript 5 includes the following syntactic changes:'
  id: totrans-4617
  prefs: []
  type: TYPE_NORMAL
- en: Reserved words as property keys
  id: totrans-4618
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use reserved words (such as `new` and `function`) after the dot operator
    and as unquoted property keys in object literals:'
  id: totrans-4619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1040]'
  id: totrans-4620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1040]'
- en: Legal trailing commas
  id: totrans-4621
  prefs: []
  type: TYPE_NORMAL
- en: Trailing commas in object literals and array literals are legal.
  id: totrans-4622
  prefs: []
  type: TYPE_NORMAL
- en: Multiline string literals
  id: totrans-4623
  prefs: []
  type: TYPE_NORMAL
- en: String literals can span multiple lines if you escape the end of the line via
    a backslash.
  id: totrans-4624
  prefs: []
  type: TYPE_NORMAL
- en: New Functionality in the Standard Library
  id: totrans-4625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 5 brought several additions to JavaScript’s standard library. This
    section lists them by category.
  id: totrans-4626
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming
  id: totrans-4627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Getting and setting prototypes (see [Getting and Setting the Prototype](ch17_split_000.html#get_set_prototype
    "Getting and Setting the Prototype")):'
  id: totrans-4628
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.create()`'
  id: totrans-4629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.getPrototypeOf()`'
  id: totrans-4630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing property attributes via property descriptors (see [Property Descriptors](ch17_split_000.html#property_descriptors
    "Property Descriptors")):'
  id: totrans-4631
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.defineProperty()`'
  id: totrans-4632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.defineProperties()`'
  id: totrans-4633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.create()`'
  id: totrans-4634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.getOwnPropertyDescriptor()`'
  id: totrans-4635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Listing properties (see [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")):'
  id: totrans-4636
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.keys()`'
  id: totrans-4637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.getOwnPropertyNames()`'
  id: totrans-4638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Protecting objects (see [Protecting Objects](ch17_split_001.html#protecting_objects
    "Protecting Objects")):'
  id: totrans-4639
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.preventExtensions()`'
  id: totrans-4640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.isExtensible()`'
  id: totrans-4641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.seal()`'
  id: totrans-4642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.isSealed()`'
  id: totrans-4643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.freeze()`'
  id: totrans-4644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.isFrozen()`'
  id: totrans-4645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New `Function` method (see [Function.prototype.bind(thisValue, arg1?, ...,
    argN?)](ch17_split_000.html#Function.prototype.bind "Function.prototype.bind(thisValue,
    arg1?, ..., argN?)")):'
  id: totrans-4646
  prefs: []
  type: TYPE_NORMAL
- en: '`Function.prototype.bind()`'
  id: totrans-4647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New Methods
  id: totrans-4648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings (see [Chapter 12](ch12.html "Chapter 12. Strings")):'
  id: totrans-4649
  prefs: []
  type: TYPE_NORMAL
- en: New method `String.prototype.trim()`
  id: totrans-4650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access characters via the bracket operator `[...]`
  id: totrans-4651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New `Array` methods (see [Array Prototype Methods](ch18.html#array_prototype_methods
    "Array Prototype Methods")):'
  id: totrans-4652
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.isArray()`'
  id: totrans-4653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.every()`'
  id: totrans-4654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.filter()`'
  id: totrans-4655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.forEach()`'
  id: totrans-4656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.indexOf()`'
  id: totrans-4657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.lastIndexOf()`'
  id: totrans-4658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.map()`'
  id: totrans-4659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.reduce()`'
  id: totrans-4660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.some()`'
  id: totrans-4661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New `Date` methods (see [Date Prototype Methods](ch20.html#date_prototype_methods
    "Date Prototype Methods")):'
  id: totrans-4662
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.now()`'
  id: totrans-4663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toISOString()`'
  id: totrans-4664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON
  id: totrans-4665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Support for JSON (see [Chapter 22](ch22.html "Chapter 22. JSON")):'
  id: totrans-4666
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON.parse()` (see [JSON.parse(text, reviver?)](ch22.html#JSON.parse "JSON.parse(text,
    reviver?)"))'
  id: totrans-4667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON.stringify()` (see [JSON.stringify(value, replacer?, space?)](ch22.html#JSON.stringify
    "JSON.stringify(value, replacer?, space?)"))'
  id: totrans-4668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some built-in objects have special `toJSON()` methods:'
  id: totrans-4669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean.prototype.toJSON()`'
  id: totrans-4670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.prototype.toJSON()`'
  id: totrans-4671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.toJSON()`'
  id: totrans-4672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toJSON()`'
  id: totrans-4673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips for Working with Legacy Browsers
  id: totrans-4674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following resources will be useful if you need to work with legacy browsers:'
  id: totrans-4675
  prefs: []
  type: TYPE_NORMAL
- en: A [compatibility table](http://kangax.github.io/es5-compat-table/) by Juriy
    Zaytsev (“kangax”) shows how much of ECMAScript 5 is supported by various versions
    of various browsers.
  id: totrans-4676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[es5-shim](https://github.com/kriskowal/es5-shim/) brings most (but not all)
    of ECMAScript 5’s functionality to browsers that support only ECMAScript 3.'
  id: totrans-4677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

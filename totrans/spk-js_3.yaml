- en: Part III. JavaScript in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分。深入JavaScript
- en: This part is a comprehensive reference of the JavaScript language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分是JavaScript语言的全面参考。
- en: Chapter 7. JavaScript’s Syntax
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章。JavaScript的语法
- en: JavaScript’s syntax is fairly straightforward. This chapter describes things
    to watch out for.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的语法相当简单。本章描述了需要注意的事项。
- en: An Overview of the Syntax
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法概述
- en: This section gives you a quick impression of what JavaScript’s syntax looks
    like.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本节让你快速了解JavaScript的语法是什么样子的。
- en: 'The following are five fundamental kinds of values:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是五种基本类型的值：
- en: 'Booleans:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Numbers:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Strings:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Plain objects:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通对象：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Arrays:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here are a few examples of basic syntax:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些基本语法的例子：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note the two different uses of the equals sign:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意等号的两种不同用法：
- en: A single equals sign (`=`) is used to assign a value to a variable.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个等号（`=`）用于将一个值赋给一个变量。
- en: A triple equals sign (`===`) is used to compare two values (see [Equality Operators](ch01.html#basic_equality_operators
    "Equality Operators")).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个等号（`===`）用于比较两个值（参见[相等运算符](ch01.html#basic_equality_operators "相等运算符")）。
- en: Comments
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'There are two kinds of comments:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种注释：
- en: 'Single-line comments via `//` extend to the rest of the line. Here’s an example:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`//`进行单行注释，延伸到行的其余部分。这是一个例子：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Multiline comments via `/* */` can extend over arbitrary ranges of text. They
    cannot be nested. Here are two examples:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`/* */`进行多行注释，可以延伸到任意范围的文本。它们不能嵌套。以下是两个例子：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Expressions Versus Statements
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式与语句
- en: 'This section looks at an important syntactic distinction in JavaScript: the
    difference between expressions and statements.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了JavaScript中一个重要的语法区别：表达式和语句之间的区别。
- en: Expressions
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式
- en: 'An *expression* produces a value and can be written wherever a value is expected—for
    example, as an argument in a function call or at the right side of an assignment.
    Each of the following lines contains an expression:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式*产生一个值，并且可以在期望值的任何地方编写，例如，在函数调用的参数中或赋值的右侧。以下每一行都包含一个表达式：'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Statements
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语句
- en: Roughly, a *statement* performs an action. Loops and `if` statements are examples
    of statements. A program is basically a sequence of statements.^([[6](#ftn.id370625)])
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，*语句*执行一个动作。循环和`if`语句是语句的例子。程序基本上是一系列语句。^([[6](#ftn.id370625)])
- en: 'Wherever JavaScript expects a statement, you can also write an expression.
    Such a statement is called an *expression statement*. The reverse does not hold:
    you cannot write a statement where JavaScript expects an expression. For example,
    an `if` statement cannot become the argument of a function.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无论在哪里，JavaScript都期望一个语句，你也可以写一个表达式。这样的语句称为*表达式语句*。反之则不成立：你不能在JavaScript期望表达式的地方写一个语句。例如，`if`语句不能成为函数的参数。
- en: Conditional statement versus conditional expressions
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件语句与条件表达式
- en: 'The difference between statements and expressions becomes clearer if we look
    at members of the two syntactic categories that are similar: the `if` statement
    and the conditional operator (an expression).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下两个语法类别的成员，即`if`语句和条件运算符（一个表达式），那么语句和表达式之间的区别就变得更加清晰了。
- en: 'The following is an example of an `if` statement:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`if`语句的例子：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There is a similar kind of expression, the *conditional operator*. The preceding
    statements are equivalent to the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种类似的表达式，*条件运算符*。前面的语句等同于以下代码：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code between the equals sign and the semicolon is an expression. The parentheses
    are not necessary, but I find the conditional operator easier to read if I put
    it in parens.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 等号和分号之间的代码是一个表达式。括号不是必需的，但我发现如果我把它放在括号中，条件运算符更容易阅读。
- en: Using ambiguous expressions as statements
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用模棱两可的表达式作为语句
- en: 'Two kinds of expressions look like statements—they are ambiguous with regard
    to their syntactic category:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 两种表达式看起来像语句——它们在语法类别上是模棱两可的：
- en: 'Object literals (expressions) look like blocks (statements):'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象文字（表达式）看起来像块（语句）：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding construct is either an object literal (details: [Object Literals](ch17_split_000.html#object_literals
    "Object Literals")) or a block followed by the label `foo:`, followed by the function
    call `bar(3, 5)`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结构要么是一个对象文字（详细信息：[对象文字](ch17_split_000.html#object_literals "对象文字")），要么是一个块，后面跟着标签`foo:`，再跟着函数调用`bar(3,
    5)`。
- en: 'Named function expressions look like function declarations (statements):'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名函数表达式看起来像函数声明（语句）：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding construct is either a named function expression or a function
    declaration. The former produces a function, the latter creates a variable and
    assigns a function to it (details on both kinds of function definition: [Defining
    Functions](ch15.html#defining_functions "Defining Functions")).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结构要么是一个命名的函数表达式，要么是一个函数声明。前者产生一个函数，后者创建一个变量并将一个函数赋给它（有关两种函数定义的详细信息：[定义函数](ch15.html#defining_functions
    "定义函数")）。
- en: 'In order to prevent ambiguity during parsing, JavaScript does not let you use
    object literals and function expressions as statements. That is, expression statements
    must not start with:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在解析过程中避免歧义，JavaScript不允许你将对象文字和函数表达式用作语句。也就是说，表达式语句不能以以下内容开头：
- en: A curly brace
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号
- en: The keyword `function`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`function`
- en: If an expression starts with either of those tokens, it can only appear in an
    expression context. You can comply with that requirement by, for example, putting
    parentheses around the expression. Next, we’ll look at two examples where that
    is necessary.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个表达式以这两个标记中的任何一个开头，它只能出现在表达式上下文中。例如，你可以通过在表达式周围放置括号来满足这个要求。接下来，我们将看两个必要的例子。
- en: Evaluating an object literal via eval()
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过eval()评估对象文字
- en: '`eval` parses its argument in statement context. You have to put parentheses
    around an object literal if you want `eval` to return an object:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`在语句上下文中解析其参数。如果你想要`eval`返回一个对象，你必须在对象文字周围放括号：'
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Immediately invoking a function expression
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 立即调用函数表达式
- en: 'The following code is an *immediately invoked function expression* (IIFE),
    a function whose body is executed right away (you’ll learn what IIFEs are used
    for in [Introducing a New Scope via an IIFE](ch16.html#iife "Introducing a New
    Scope via an IIFE")):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个“立即调用的函数表达式”（IIFE），一个函数的主体会立即执行（您将在[通过IIFE引入新作用域](ch16.html#iife "通过IIFE引入新作用域")中了解到IIFE的用途）：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you omit the parentheses, you get a syntax error, because JavaScript sees
    a function declaration, which can’t be anonymous:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略括号，您将得到语法错误，因为JavaScript看到一个函数声明，它不能是匿名的：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you add a name, you also get a syntax error, because function declarations
    can’t be immediately invoked:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加名称，您也会得到语法错误，因为函数声明不能立即调用：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Whatever follows a function declaration must be a legal statement and `()` isn’t.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明后面必须是一个合法的语句，而`()`不是。
- en: Control Flow Statements and Blocks
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制流语句和块
- en: 'For control flow statements, the body is a single statement. Here are two examples:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于控制流语句，主体是一个单语句。以下是两个示例：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, any statement can always be replaced by a *block*, curly braces containing
    zero or more statements. Thus, you can also write:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任何语句都可以被*块*替换，即包含零个或多个语句的花括号。因此，您也可以这样写：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I prefer the latter form of control flow statement. Standardizing on it means
    that there is no difference between single-statement bodies and multistatement
    bodies. As a consequence, your code looks more consistent, and alternating between
    one statement and more than one statement is easier.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢后一种控制流语句形式。对其进行标准化意味着单语句主体和多语句主体之间没有区别。因此，您的代码看起来更一致，并且在单语句和多于一条语句之间切换更容易。
- en: Rules for Using Semicolons
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分号的规则
- en: 'In this section, we examine how semicolons are used in JavaScript. The basic
    rules are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论JavaScript中分号的使用。基本规则是：
- en: Normally, statements are terminated by semicolons.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，语句以分号终止。
- en: The exception is statements ending with blocks.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例外是以块结束的语句。
- en: Semicolons are optional in JavaScript. Missing semicolons are added via so-called
    *automatic semicolon insertion* (ASI; see [Automatic Semicolon Insertion](ch07.html#automatic_semicolon_insertion
    "Automatic Semicolon Insertion")). However, that feature doesn’t always work as
    expected, which is why you should always include semicolons.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中分号是可选的。缺少分号会通过所谓的“自动分号插入”（ASI）添加（请参阅[自动分号插入](ch07.html#automatic_semicolon_insertion
    "自动分号插入")）。然而，该功能并不总是按预期工作，这就是为什么您应该始终包括分号的原因。
- en: No Semicolon After a Statement Ending with a Block
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语句结束于块之后没有分号
- en: 'The following statements are not terminated by semicolons if they end with
    a block:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以块结束，以下语句不会以分号终止：
- en: 'Loops: `for`, `while` (but not `do-while`)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环：`for`，`while`（但不包括`do-while`）
- en: 'Branching: `if`, `switch`, `try`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支：`if`，`switch`，`try`
- en: Function declarations (but not function expressions)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明（但不是函数表达式）
- en: 'Here’s an example of `while` versus `do-while`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`while`与`do-while`的示例：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And here’s an example of a function declaration versus a function expression.
    The latter is followed by a semicolon, because it appears inside a `var` declaration
    (which *is* terminated by a semicolon):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是函数声明与函数表达式的示例。后者后面跟着一个分号，因为它出现在`var`声明内（它*以*分号结束）：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you do add a semicolon after a block, you do not get a syntax error, because
    it is considered an empty statement (see the next section).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在块后添加分号，您不会得到语法错误，因为它被视为一个空语句（请参阅下一节）。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: That’s most of what you need to know about semicolons. If you always add semicolons,
    you can probably get by without reading the remaining parts of this section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要了解的关于分号的大部分内容。如果您始终添加分号，您可能可以不阅读本节其余部分。
- en: The Empty Statement
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空语句
- en: 'A semicolon on its own is an *empty statement* and does nothing. Empty statements
    can appear anywhere a statement is expected. They are useful in situations where
    a statement is demanded, but not needed. In such situations, blocks are usually
    also allowed. For example, the following two statements are equivalent:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 分号本身是一个“空语句”，什么也不做。空语句可以出现在需要语句的任何地方。它们在需要语句但不需要语句的情况下很有用。在这种情况下，通常也允许块。例如，以下两个语句是等价的：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The function `processNextItem` is assumed to return the number of remaining
    items. The following program, consisting of three empty statements, is also syntactically
    correct:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`processNextItem`被假定返回剩余项目的数量。以下程序由三个空语句组成，也是语法上正确的：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Automatic Semicolon Insertion
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动分号插入
- en: The goal of automatic semicolon insertion (ASI) is to make semicolons optional
    at the end of a line. The image invoked by the term *automatic semicolon insertion*
    is that the JavaScript parser inserts semicolons for you (internally, things are
    usually handled differently).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 自动分号插入（ASI）的目标是使分号在行末变为可选。术语“自动分号插入”所引发的图像是JavaScript解析器为您插入分号（在内部，通常处理方式不同）。
- en: 'Put another way, ASI helps the parser to determine when a statement ends. Normally,
    it ends with a semicolon. ASI dictates that a statement also ends if:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，ASI帮助解析器确定语句何时结束。通常，它以分号结束。ASI规定，如果：
- en: A line terminator (e.g., a newline) is followed by an illegal token.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行终止符（例如换行符）后面跟着一个非法标记。
- en: A closing brace is encountered.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到右括号。
- en: The end of the file has been reached.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已到达文件末尾。
- en: 'Example: ASI via illegal token'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例：通过非法标记进行ASI
- en: 'The following code contains a line terminator followed by an illegal token:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码包含了一个行终止符后面跟着一个非法标记：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The token `console` is illegal after `0` and triggers ASI:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`0`之后的`console`标记是非法的，并触发ASI：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Example: ASI via closing brace'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例：通过右括号进行ASI
- en: 'In the following code, the statement inside the braces is not terminated by
    a semicolon:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，大括号内的语句未以分号终止：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'ASI creates a syntactically correct version of the preceding code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ASI创建了前述代码的语法上正确的版本：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Pitfall: ASI can unexpectedly break up statements'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：ASI可能会意外地中断语句
- en: 'ASI is also triggered if there is a line terminator after the keyword `return`.
    For example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在关键字`return`后有行终止符，ASI也会被触发。例如：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'ASI turns the preceding into:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ASI将前面的转换为：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That’s an empty return, followed by a block with the label `name` in front of
    the expression statement `'John'`. After the block, there is an empty statement.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个空的返回，紧接着是一个带有标签`name`的块，位于表达式语句`'John'`之前。在块之后，有一个空语句。
- en: 'Pitfall: ASI might unexpectedly not be triggered'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：ASI可能意外地不会被触发
- en: 'Sometimes a statement in a new line starts with a token that is allowed as
    a continuation of the previous statement. Then ASI is not triggered, even though
    it seems like it should be. For example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，新行中的语句以允许作为前一语句的延续的标记开头。然后，尽管看起来应该被触发，但ASI不会被触发。例如：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The square brackets in the second line are interpreted as an index into the
    result returned by `func()`. The comma inside the brackets is interpreted as the
    comma operator (which returns `''ol''` in this case; see [The Comma Operator](ch09.html#comma_operator
    "The Comma Operator")). Thus, JavaScript sees the previous code as:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行中的方括号被解释为对`func()`返回结果的索引。方括号内的逗号被解释为逗号运算符（在这种情况下返回`'ol'`；参见[逗号运算符](ch09.html#comma_operator
    "逗号运算符")）。因此，JavaScript将前面的代码视为：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Legal Identifiers
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合法标识符
- en: Identifiers are used for naming things and appear in various syntactic roles
    in JavaScript. For example, the names of variables and unquoted property keys
    must be valid identifiers. Identifiers are case sensitive.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符用于命名事物，并在JavaScript中的各种句法角色中出现。例如，变量的名称和未引用的属性键的名称必须是有效的标识符。标识符区分大小写。
- en: 'The first character of an identifier is one of:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符的第一个字符是：
- en: Any Unicode letter, including Latin letters such as D, Greek letters such as
    λ, and Cyrillic letters such as Д
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何Unicode字母，包括拉丁字母如D，希腊字母如λ，和西里尔字母如Д
- en: Dollar sign (`$`)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美元符号（`$`）
- en: Underscore (`_`)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下划线（`_`）
- en: 'Subsequent characters are:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 后续字符是：
- en: Any legal first character
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何合法的第一个字符
- en: Any Unicode digit in the Unicode category “Decimal number (Nd)”; this includes
    European numerals such as 7 and Indic numerals such as ٣
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode类别“十进制数字（Nd）”中的任何Unicode数字；这包括欧洲数字如7和印度数字如٣
- en: Various other Unicode marks and punctuations
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他各种Unicode标记和标点符号
- en: 'Examples of legal identifiers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 合法标识符的示例：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Even though this enables you to use a variety of human languages in JavaScript
    code, I recommend sticking with English, for both identifiers and comments. That
    ensures that your code is understandable by the largest possible group of people,
    which is important, given how much code can spread internationally these days.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这使您可以在JavaScript代码中使用各种人类语言，但我建议使用英语，无论是标识符还是注释。这可以确保您的代码可以被尽可能多的人理解，这很重要，考虑到如今代码可以在国际间传播。
- en: 'The following identifiers are *reserved words*—they are part of the syntax
    and can’t be used as variable names (including function names and parameter names):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标识符是*保留字*——它们是语法的一部分，不能用作变量名（包括函数名和参数名）：
- en: '| `arguments` | `break` | `case` | `catch` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `arguments` | `break` | `case` | `catch` |'
- en: '| `class` | `const` | `continue` | `debugger` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `class` | `const` | `continue` | `debugger` |'
- en: '| `default` | `delete` | `do` | `else` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `default` | `delete` | `do` | `else` |'
- en: '| `enum` | `export` | `extends` | `false` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `enum` | `export` | `extends` | `false` |'
- en: '| `finally` | `for` | `function` | `if` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `finally` | `for` | `function` | `if` |'
- en: '| `implements` | `import` | `in` | `instanceof` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `implements` | `import` | `in` | `instanceof` |'
- en: '| `interface` | `let` | `new` | `null` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `interface` | `let` | `new` | `null` |'
- en: '| `package` | `private` | `protected` | `public` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `package` | `private` | `protected` | `public` |'
- en: '| `return` | `static` | `super` | `switch` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `return` | `static` | `super` | `switch` |'
- en: '| `this` | `throw` | `true` | `try` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `this` | `throw` | `true` | `try` |'
- en: '| `typeof` | `var` | `void` | `while` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `typeof` | `var` | `void` | `while` |'
- en: 'The following three identifiers are not reserved words, but you should treat
    them as if they were:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个标识符不是保留字，但您应该将它们视为保留字：
- en: '| `Infinity` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `Infinity` |'
- en: '| `NaN` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `NaN` |'
- en: '| `undefined` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` |'
- en: Lastly, you should also stay away from the names of standard global variables
    (see [Chapter 23](ch23.html "Chapter 23. Standard Global Variables")). You can
    use them for local variables without breaking anything, but your code still becomes
    confusing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还应该避免使用标准全局变量的名称（参见[第23章](ch23.html "第23章. 标准全局变量")）。您可以将它们用作局部变量而不会破坏任何内容，但您的代码仍然会变得混乱。
- en: 'Note that you *can* use reserved words as unquoted property keys (as of ECMAScript 5):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您*可以*使用保留字作为未引用的属性键（自ECMAScript 5起）：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can look up the precise rules for identifiers in Mathias Bynens’s blog post
    [“Valid JavaScript variable names”](http://mathiasbynens.be/notes/javascript-identifiers).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Mathias Bynens的博客文章[“有效的JavaScript变量名”](http://mathiasbynens.be/notes/javascript-identifiers)中查找标识符的精确规则。
- en: Invoking Methods on Number Literals
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数字文字上调用方法
- en: 'With method invocations, it is important to distinguish between the floating-point
    dot and the method invocation dot. Thus, you cannot write `1.toString()`; you
    must use one of the following alternatives:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法调用中，重要的是要区分浮点数点和方法调用点。因此，您不能写成`1.toString()`；您必须使用以下替代之一：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Strict Mode
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格模式
- en: ECMAScript 5 has a *strict mode* that results in cleaner JavaScript, with fewer
    unsafe features, more warnings, and more logical behavior. The normal (nonstrict)
    mode is sometimes called “sloppy mode.”
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 5有一个*严格模式*，可以使JavaScript更清晰，减少不安全的特性，增加警告，以及更合乎逻辑的行为。正常（非严格）模式有时被称为“松散模式”。
- en: Switching on Strict Mode
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开严格模式
- en: 'You switch strict mode on by typing the following line first in your JavaScript
    file or inside your `<script>` element:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在JavaScript文件中或在`<script>`元素内首先输入以下行来打开严格模式：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that JavaScript engines that don’t support ECMAScript 5 will simply ignore
    the preceding statement, as writing strings in this manner (as an expression statement;
    see [Statements](ch07.html#expression_statement "Statements")) normally does nothing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不支持ECMAScript 5的JavaScript引擎将简单地忽略前面的语句，因为以这种方式编写字符串（作为表达式语句；请参阅[语句](ch07.html#expression_statement
    "语句")）通常不会做任何事情。
- en: 'You can also switch on strict mode per function. To do so, write your function
    like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以按函数打开严格模式。要这样做，请像这样编写您的函数：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is handy when you are working with a legacy code base where switching on
    strict mode everywhere may break things.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用严格模式处理到处都可能破坏事物的旧代码库时，这很方便。
- en: 'Strict Mode: Recommended, with Caveats'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格模式：推荐，但有注意事项
- en: 'In general, the changes enabled by strict mode are all for the better. Thus,
    it is highly recommended to use it for new code you write—simply switch it on
    at the beginning of a file. There are, however, two caveats:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，严格模式启用的更改都是为了更好。因此，强烈建议您在编写新代码时使用它——只需在文件开头打开它。然而，有两个注意事项：
- en: Enabling strict mode for existing code may break it
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为现有代码启用严格模式可能会破坏它
- en: The code may rely on a feature that is not available anymore, or it may rely
    on behavior that is different in sloppy mode than in strict mode. Don’t forget
    that you have the option to add single strict mode functions to files that are
    in sloppy mode.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能依赖于不再可用的功能，或者可能依赖于在松散模式和严格模式中行为不同的行为。不要忘记您可以将单个严格模式函数添加到处于松散模式的文件中的选项。
- en: Package with care
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 小心处理包
- en: When you concatenate and/or minify files, you have to be careful that strict
    mode isn’t switched off where it should be switched on or vice versa. Both can
    break code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当您连接和/或缩小文件时，您必须小心，严格模式在应该打开时没有关闭，或者反之亦然。两者都可能破坏代码。
- en: The following sections explain the strict mode features in more detail. You
    normally don’t need to know them, as you will mostly get more warnings for things
    that you shouldn’t do anyway.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分详细解释了严格模式的特性。通常情况下，您不需要了解它们，因为您大多数情况下会因为您本不应该做的事情而得到更多的警告。
- en: Variables Must Be Declared in Strict Mode
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量必须在严格模式下声明
- en: 'All variables must be explicitly declared in strict mode. This helps to prevent
    typos. In sloppy mode, assigning to an undeclared variable creates a global variable:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，所有变量必须明确声明。这有助于防止拼写错误。在松散模式下，对未声明的变量进行赋值会创建一个全局变量：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In strict mode, assigning to an undeclared variable throws an exception:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，对未声明的变量进行赋值会引发异常：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Functions in Strict Mode
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格模式中的函数
- en: Strict mode limits function-related features.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式限制了与函数相关的特性。
- en: Functions must be declared at the top level of a scope
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数必须在作用域的顶层声明
- en: 'In strict mode, all functions must be declared at the top level of a scope
    (global scope or directly inside a function). That means that you can’t put a
    function declaration inside a block. If you do, you get a descriptive `SyntaxError`.
    For example, V8 tells you: “In strict mode code, functions can only be declared
    at top level or immediately within another function”:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，所有函数必须在作用域的顶层声明（全局作用域或直接在函数内部）。这意味着您不能将函数声明放在块内。如果这样做，您将收到一个描述性的`SyntaxError`。例如，V8会告诉您：“在严格模式代码中，函数只能在顶层或直接在另一个函数内部声明”：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That is something that isn’t useful anyway, because the function is created
    in the scope of the surrounding function, not “inside” the block.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是无用的，因为该函数是在周围函数的范围内创建的，而不是“在”块内部。
- en: 'If you want to work around this limitation, you can create a function inside
    a block via a variable declaration and a function expression:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想解决此限制，可以通过变量声明和函数表达式在块内创建一个函数：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Stricter rules for function parameters
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数参数的更严格规则
- en: 'The rules for function parameters are less permissive: using the same parameter
    name twice is forbidden, as are local variables that have the same name as a parameter.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数的规则不太宽容：禁止使用相同的参数名称两次，以及与参数同名的局部变量。
- en: The arguments objects has fewer properties
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: arguments对象的属性更少
- en: 'The `arguments` object is simpler in strict mode: the properties `arguments.callee`
    and `arguments.caller` have been eliminated, you can’t assign to the variable
    `arguments`, and `arguments` does not track changes to parameters (if a parameter
    changes, the corresponding array element does not change with it). [Deprecated
    features of arguments](ch15.html#arguments_deprecated_features "Deprecated features
    of arguments") explains the details.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，`arguments`对象更简单：属性`arguments.callee`和`arguments.caller`已被删除，您不能对变量`arguments`进行赋值，`arguments`不会跟踪参数的更改（如果参数更改，相应的数组元素不会随之更改）。[arguments的弃用特性](ch15.html#arguments_deprecated_features
    "arguments的弃用特性")解释了详细信息。
- en: this is undefined in nonmethod functions
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非方法函数中的`this`是未定义的
- en: 'In sloppy mode, the value of `this` in nonmethod functions is the global object
    (`window` in browsers; see [The Global Object](ch16.html#global_object "The Global
    Object")):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在松散模式下，非方法函数中`this`的值是全局对象（在浏览器中是`window`；请参阅[全局对象](ch16.html#global_object
    "全局对象")）：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In strict mode, it is `undefined`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，它是`undefined`：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is useful for constructors. For example, the following constructor, `Point`,
    is in strict mode:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这对构造函数很有用。例如，以下构造函数`Point`是在严格模式下的：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Due to strict mode, you get a warning when you accidentally forget `new` and
    call it as a function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于严格模式，当您意外忘记`new`并将其作为函数调用时，您会收到警告：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In sloppy mode, you don’t get a warning, and global variables `x` and `y` are
    created. Consult [Tips for Implementing Constructors](ch17_split_001.html#constructor_tips
    "Tips for Implementing Constructors") for details.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在松散模式下，您不会收到警告，并且会创建全局变量`x`和`y`。有关详细信息，请参阅[实现构造函数的提示](ch17_split_001.html#constructor_tips
    "实现构造函数的提示")。
- en: Setting and Deleting Immutable Properties Fails with an Exception in Strict
    Mode
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在严格模式下，设置和删除不可变属性会引发异常
- en: 'Illegal manipulations of properties throw exceptions in strict mode. For example,
    attempting to set the value of a read-only property throws an exception, as does
    attempting to delete a nonconfigurable property. Here is an example of the former:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，非法的属性操作会抛出异常。例如，试图设置只读属性的值会抛出异常，试图删除不可配置属性也会抛出异常。以下是一个例子：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Unqualified Identifiers Can’t Be Deleted in Strict Mode
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在严格模式下，不能删除未经限定的标识符
- en: 'In sloppy mode, you can delete a global variable `foo` like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在松散模式下，你可以像这样删除全局变量`foo`：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In strict mode, you get a syntax error whenever you try to delete unqualified
    identifiers. You can still delete global variables like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，当你尝试删除未经限定的标识符时，你会得到一个语法错误。你仍然可以像这样删除全局变量：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: eval() Is Cleaner in Strict Mode
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在严格模式下，eval()更加干净
- en: 'In strict mode, the `eval()` function becomes less quirky: variables declared
    in the evaluated string are not added to the scope surrounding `eval()` anymore.
    For details, consult [Evaluating Code Using eval()](ch23.html#eval "Evaluating
    Code Using eval()").'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，`eval()`函数变得不那么古怪了：在评估的字符串中声明的变量不再添加到`eval()`周围的作用域中。详情请参阅[Evaluating
    Code Using eval()](ch23.html#eval "Evaluating Code Using eval()")。
- en: Features That Are Forbidden in Strict Mode
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在严格模式下被禁止的特性
- en: 'Two more JavaScript features are forbidden in strict mode:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，还有两个JavaScript特性是被禁止的：
- en: The `with` statement is not allowed anymore (see [The with Statement](ch13.html#with_statement
    "The with Statement")). You get a syntax error at compile time (when loading the
    code).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不再允许使用`with`语句（参见[The with Statement](ch13.html#with_statement "The with Statement")）。在编译时（加载代码时）会得到语法错误。
- en: 'No more octal numbers: in sloppy mode, an integer with a leading zero is interpreted
    as octal (base 8). For example:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不再有八进制数：在松散模式下，以零开头的整数被解释为八进制（基数8）。例如：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In strict mode, you get a syntax error if you use this kind of literal:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，如果你使用这种文字类型，你会得到一个语法错误：
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '* * *'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[6](#id370625)]) To keep things simple, I’m pretending that declarations
    are statements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#id370625)]) 为了简化问题，我假装声明是语句。
- en: Chapter 8. Values
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章。值
- en: 'JavaScript has most of the values that we have come to expect from programming
    languages: booleans, numbers, strings, arrays, and so on. All normal values in
    JavaScript have *properties*.^([[7](#ftn.id914993)]) Each property has a *key*
    (or *name*) and a *value*. You can think of properties like fields of a record.
    You use the dot (`.`) operator to access properties:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript拥有我们所期望的大多数编程语言的值：布尔值、数字、字符串、数组等。JavaScript中的所有正常值都有*属性*。^([[7](#ftn.id914993)])
    每个属性都有一个*键*（或*名称*）和一个*值*。你可以把属性看作记录的字段。你可以使用点（`.`）运算符来访问属性：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: JavaScript’s Type System
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript的类型系统
- en: This chapter gives an overview of JavaScript’s type system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了JavaScript的类型系统。
- en: JavaScript’s Types
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript的类型
- en: 'JavaScript has only six types, according to [Chapter 8 of the ECMAScript language
    specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 根据ECMAScript语言规范的第8章，JavaScript只有六种类型：
- en: 'An ECMAScript language type corresponds to values that are directly manipulated
    by an ECMAScript programmer using the ECMAScript language. The ECMAScript language
    types are:'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ECMAScript语言类型对应于由ECMAScript程序员直接使用ECMAScript语言进行操作的值。ECMAScript语言类型包括：
- en: '>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: Undefined, Null
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义、空值
- en: Boolean, String, Number, and
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值、字符串、数字和
- en: Object
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Therefore, constructors technically don’t introduce new types, even though they
    are said to have instances.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，构造函数在技术上并没有引入新的类型，尽管它们被认为有实例。
- en: Static Versus Dynamic
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态与动态
- en: In the context of language semantics and type systems, *static* usually means
    “at compile time” or “without running a program,” while *dynamic* means “at runtime.”
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言语义和类型系统的背景下，“静态”通常意味着“在编译时”或“在不运行程序时”，而“动态”意味着“在运行时”。
- en: Static Typing Versus Dynamic Typing
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态类型检查与动态类型检查
- en: In a statically typed language, variables, parameters, and members of objects
    (JavaScript calls them properties) have types that the compiler knows at compile
    time. The compiler can use that information to perform type checks and to optimize
    the compiled code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态类型语言中，变量、参数和对象的成员（JavaScript称之为属性）在编译时就已经知道类型。编译器可以使用这些信息进行类型检查和优化编译后的代码。
- en: 'Even in statically typed languages, a variable also has a dynamic type, the
    type of the variable’s value at a given point at runtime. The dynamic type can
    differ from the static type. For example (Java):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在静态类型语言中，变量也有动态类型，即运行时变量值的类型。动态类型可以与静态类型不同。例如（Java）：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The static type of `foo` is `Object`; its dynamic type is `String`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo`的静态类型是`Object`；它的动态类型是`String`。'
- en: JavaScript is dynamically typed; types of variables are generally not known
    at compile time.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是动态类型的；变量的类型通常在编译时不知道。
- en: Static Type Checking Versus Dynamic Type Checking
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态类型检查与动态类型检查
- en: If you have type information, you can check whether a value used in an operation
    (calling a function, applying an operator, etc.) has the correct type. Statically
    type-checked languages perform this kind of check at compile time, while dynamically
    type-checked languages do so at runtime. A language can be both statically type-checked
    and dynamically type-checked. If a check fails, you usually get some kind of error
    or exception.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有类型信息，你可以检查在操作中使用的值（调用函数、应用运算符等）是否具有正确的类型。在静态类型检查的语言中，这种检查是在编译时进行的，而在动态类型检查的语言中是在运行时进行的。一种语言可以同时进行静态类型检查和动态类型检查。如果检查失败，通常会得到某种错误或异常。
- en: 'JavaScript performs a very limited kind of dynamic type checking:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript执行一种非常有限的动态类型检查：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Mostly, however, things silently fail or work. For example, if you access a
    property that does not exist, you get the value `undefined`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数情况下，事情会悄悄地失败或者成功。例如，如果你访问一个不存在的属性，你会得到值`undefined`：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Coercion
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制转换
- en: 'In JavaScript, the main way of dealing with a value whose type doesn’t fit
    is to *coerce* it to the correct type. *Coercion* means implicit type conversion.
    Most operands coerce:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，处理类型不匹配的值的主要方法是将其*强制转换*为正确的类型。*强制转换*意味着隐式类型转换。大多数操作数都会强制转换：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: JavaScript’s built-in conversion mechanisms support only the types `Boolean`,
    `Number`, `String`, and `Object`. There is no standard way to convert an instance
    of one constructor to an instance of another constructor.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的内置转换机制仅支持`Boolean`，`Number`，`String`和`Object`类型。没有标准的方法将一个构造函数的实例转换为另一个构造函数的实例。
- en: Warning
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: The terms *strongly typed* and *weakly typed* do not have [generally meaningful
    definitions](http://bit.ly/1oO7t1p). They are used, but normally incorrectly.
    It is better to instead use *statically typed*, *statically type-checked*, and
    so on.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*强类型*和*弱类型*没有[普遍有意义的定义](http://bit.ly/1oO7t1p)。它们被使用，但通常是不正确的。最好使用*静态类型*，*静态类型检查*等。
- en: Primitive Values Versus Objects
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始值与对象
- en: 'JavaScript makes a somewhat arbitrary distinction between values:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在值之间做了一个相当任意的区分：
- en: The *primitive values* are booleans, numbers, strings, `null`, and `undefined`.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原始值*是布尔值，数字，字符串，`null`和`undefined`。'
- en: All other values are *objects*.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他值都是*对象*。
- en: 'A major difference between the two is how they are compared; each object has
    a unique identity and is only (strictly) equal to itself:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的主要区别在于它们的比较方式；每个对象都有唯一的身份，只有（严格）等于自己：
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In contrast, all primitive values encoding the same value are considered the
    same:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，编码相同值的所有原始值被认为是相同的：
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The following two sections explain primitive values and objects in more detail.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两节详细解释了原始值和对象。
- en: Primitive Values
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始值
- en: 'The following are all of the *primitive values* (*primitives* for short):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有的*原始值*（简称*原始值*）：
- en: 'Booleans: `true`, `false` (see [Chapter 10](ch10.html "Chapter 10. Booleans"))'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：`true`，`false`（参见[第10章](ch10.html "第10章。布尔值"））
- en: 'Numbers: `1736`, `1.351` (see [Chapter 11](ch11.html "Chapter 11. Numbers"))'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：`1736`，`1.351`（参见[第11章](ch11.html "第11章。数字"））
- en: 'Strings: `''abc''`, `"abc"` (see [Chapter 12](ch12.html "Chapter 12. Strings"))'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：`'abc'`，`"abc"`（参见[第12章](ch12.html "第12章。字符串"））
- en: 'Two “nonvalues”: `undefined`, `null` (see [undefined and null](ch08.html#undefined_null
    "undefined and null"))'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个“非值”：`undefined`，`null`（参见[undefined和null](ch08.html#undefined_null "undefined和null"））
- en: 'Primitives have the following characteristics:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 原始值具有以下特征：
- en: Compared by value
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 按值比较
- en: 'The “content” is compared:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 比较“内容”：
- en: '[PRE56]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Always immutable
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 始终不可变
- en: 'Properties can’t be changed, added, or removed:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 属性不能被更改，添加或删除：
- en: '[PRE57]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: (Reading an unknown property always returns `undefined`.)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: （读取未知属性总是返回`undefined`。）
- en: A fixed set of types
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一组固定的类型
- en: You can’t define your own primitive types.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能定义自己的原始类型。
- en: Objects
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: 'All nonprimitive values are *objects*. The most common kinds of objects are:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 所有非原始值都是*对象*。最常见的对象类型是：
- en: '*Plain objects* (constructor `Object`) can be created by *object literals*
    (see [Chapter 17](ch17_split_000.html "Chapter 17. Objects and Inheritance")):'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*普通对象*（构造函数`Object`）可以通过*对象字面量*（参见[第17章](ch17_split_000.html "第17章。对象和继承"））创建：'
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding object has two properties: the value of property `firstName`
    is `''Jane''`, and the value of property `lastName` is `''Doe''`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的对象有两个属性：属性`firstName`的值为`'Jane'`，属性`lastName`的值为`'Doe'`。
- en: '*Arrays* (constructor `Array`) can be created by *array literals* (see [Chapter 18](ch18.html
    "Chapter 18. Arrays")):'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组*（构造函数`Array`）可以通过*数组字面量*（参见[第18章](ch18.html "第18章。数组"））创建：'
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The preceding array has three elements that can be accessed via numeric indices.
    For example, the index of `'apple'` is 0.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数组有三个元素，可以通过数字索引访问。例如，'apple'的索引是0。
- en: '*Regular expressions* (constructor `RegExp`) can be created by *regular expression
    literals* (see [Chapter 19](ch19.html "Chapter 19. Regular Expressions")):'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正则表达式*（构造函数`RegExp`）可以通过*正则表达式字面量*（参见[第19章](ch19.html "第19章。正则表达式"））创建：'
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Objects have the following characteristics:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对象具有以下特征：
- en: Compared by reference
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 按引用比较
- en: 'Identities are compared; every object has its own identity:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 比较身份；每个对象都有自己的身份：
- en: '[PRE61]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Mutable by default
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 默认可变
- en: 'You can normally freely change, add, and remove properties (see [Dot Operator
    (.): Accessing Properties via Fixed Keys](ch17_split_000.html#dot_operator "Dot
    Operator (.): Accessing Properties via Fixed Keys")):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以自由更改，添加和删除属性（参见[点运算符（.）：通过固定键访问属性](ch17_split_000.html#dot_operator "点运算符（.）：通过固定键访问属性"））：
- en: '[PRE62]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: User-extensible
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可扩展
- en: 'Constructors (see [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances")) can be seen as implementations
    of custom types (similar to classes in other languages).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数（参见[第3层：构造函数-实例的工厂](ch17_split_001.html#constructors "第3层：构造函数-实例的工厂"）可以看作是自定义类型的实现（类似于其他语言中的类）。
- en: undefined and null
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: undefined和null
- en: 'JavaScript has two “nonvalues” that indicate missing information, `undefined`
    and `null`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有两个“非值”，表示缺少信息，`undefined`和`null`：
- en: '`undefined` means “no value” (neither primitive nor object). Uninitialized
    variables, missing parameters, and missing properties have that nonvalue. And
    functions implicitly return it if nothing has been explicitly returned.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`表示“没有值”（既不是原始值也不是对象）。未初始化的变量，缺少的参数和缺少的属性都具有该非值。如果没有明确返回任何内容，函数会隐式返回它。'
- en: '`null` means “no object.” It is used as a nonvalue where an object is expected
    (as a parameter, as a member in a chain of objects, etc.).'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`表示“没有对象”。它用作一个非值，期望一个对象（作为参数，在对象链中的成员等）。'
- en: '`undefined` and `null` are the only values for which any kind of property access
    results in an exception:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`和`null`是唯一的值，任何属性访问都会导致异常：'
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`undefined` is also sometimes used as more of a metavalue that indicates nonexistence.
    In contrast, `null` indicates emptiness. For example, a JSON node visitor (see
    [Transforming Data via Node Visitors](ch22.html#node_visitors "Transforming Data
    via Node Visitors")) returns:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`有时也被用作指示不存在的元值。相比之下，`null`表示空。例如，JSON节点访问者（请参阅[通过节点访问者转换数据](ch22.html#node_visitors
    "通过节点访问者转换数据")）返回：'
- en: '`undefined` to remove an object property or array element'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`用于删除对象属性或数组元素'
- en: '`null` to set the property or element to `null`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将属性或元素设置为`null`
- en: Occurrences of undefined and null
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未定义和null的出现
- en: Here we review the various scenarios where `undefined` and `null` occur.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们回顾了`undefined`和`null`出现的各种情况。
- en: Occurrences of undefined
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 未定义的出现
- en: 'Uninitialized variables are `undefined`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 未初始化的变量是`undefined`：
- en: '[PRE64]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Missing parameters are `undefined`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少参数是`undefined`：
- en: '[PRE65]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you read a nonexistent property, you get `undefined`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读取不存在的属性，则会得到`undefined`：
- en: '[PRE66]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And functions implicitly return `undefined` if nothing has been explicitly
    returned:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确返回，函数会隐式返回`undefined`：
- en: '[PRE67]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Occurrences of null
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: null的出现
- en: '`null` is the last element in the prototype chain (a chain of objects; see
    [Layer 2: The Prototype Relationship Between Objects](ch17_split_000.html#prototype_relationship
    "Layer 2: The Prototype Relationship Between Objects")):'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`是原型链中的最后一个元素（一系列对象的链；请参阅[第2层：对象之间的原型关系](ch17_split_000.html#prototype_relationship
    "第2层：对象之间的原型关系")）：'
- en: '[PRE68]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`null` is returned by `RegExp.prototype.exec()` if there was no match for the
    regular expression in the string:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字符串中的正则表达式没有匹配项，则`RegExp.prototype.exec()`将返回`null`：
- en: '[PRE69]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Checking for undefined or null
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查未定义或null
- en: In the following sections we review how to check for `undefined` and `null`
    individually, or to check if either exists.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将回顾如何分别检查`undefined`和`null`，或者检查它们是否存在。
- en: Checking for null
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查null
- en: 'You check for `null` via strict equality:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过严格相等来检查`null`：
- en: '[PRE70]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Checking for undefined
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查未定义
- en: 'Strict equality (`===`) is the canonical way of checking for `undefined`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 严格相等（`===`）是检查`undefined`的规范方式：
- en: '[PRE71]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can also check for `undefined` via the `typeof` operator ([typeof: Categorizing
    Primitives](ch09.html#typeof "typeof: Categorizing Primitives")), but you should
    normally use the aforementioned approach.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过`typeof`运算符（[typeof：对基元进行分类](ch09.html#typeof "typeof：对基元进行分类")）来检查`undefined`，但通常应使用前面提到的方法。
- en: Checking for either undefined or null
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查未定义或null
- en: 'Most functions allow you to indicate a missing value via either `undefined`
    or `null`. One way of checking for both of them is via an explicit comparison:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数允许您通过`undefined`或`null`指示缺少值。检查它们两者之一的一种方法是通过显式比较：
- en: '[PRE72]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Another way is to exploit the fact that both `undefined` and `null` are considered
    `false` (see [Truthy and Falsy Values](ch10.html#truthy_falsy "Truthy and Falsy
    Values")):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是利用`undefined`和`null`都被视为`false`的事实（请参阅[真值和假值](ch10.html#truthy_falsy "真值和假值")）：
- en: '[PRE73]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Warning
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '`false`, `0`, `NaN`, and `''''` are also considered `false`.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`false`，`0`，`NaN`和`''''`也被视为`false`。'
- en: The History of undefined and null
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未定义和null的历史
- en: A single nonvalue could play the roles of both `undefined` and `null`. Why does
    JavaScript have two such values? The reason is historical.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 单个非值可以扮演`undefined`和`null`的角色。为什么JavaScript有两个这样的值？原因是历史性的。
- en: 'JavaScript adopted Java’s approach of partitioning values into primitives and
    objects. It also used Java’s value for “not an object,” `null`. Following the
    precedent set by C (but not Java), `null` becomes 0 if coerced to a number:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript采用了Java对值进行分区为基元和对象的方法。它还使用了Java的“不是对象”的值，`null`。遵循C（但不是Java）所设定的先例，如果强制转换为数字，则`null`变为0：
- en: '[PRE74]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Remember that the first version of JavaScript did not have exception handling.
    Therefore, exceptional cases such as uninitialized variables and missing properties
    had to be indicated via a value. `null` would have been a good choice, but Brendan
    Eich wanted to avoid two things at the time:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，JavaScript的第一个版本没有异常处理。因此，未初始化的变量和丢失的属性等特殊情况必须通过一个值来指示。`null`本来是一个不错的选择，但当时Brendan
    Eich想要避免两件事：
- en: The value shouldn’t have the connotation of a reference, because it was about
    more than just objects.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值不应该具有引用的含义，因为它不仅仅是关于对象。
- en: The value shouldn’t coerce to 0, because that makes errors harder to spot.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值不应该强制转换为0，因为这样会使错误更难以发现。
- en: 'As a result, Eich added `undefined` as an additional nonvalue to the language.
    It coerces to `NaN`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Eich将`undefined`作为语言中的另一个非值。它强制转换为`NaN`：
- en: '[PRE75]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Changing undefined
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改未定义
- en: '`undefined` is a [property of the global object](http://bit.ly/1oO9pXM) (and
    thus a global variable; see [The Global Object](ch16.html#global_object "The Global
    Object")). Under ECMAScript 3, you had to take precautions when reading `undefined`,
    because it was easy to accidentally change its value. Under ECMAScript 5, that
    is not necessary, because `undefined` is read-only.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`是全局对象的一个属性（因此是全局变量；请参阅[全局对象](ch16.html#global_object "全局对象")）。在ECMAScript
    3中，读取`undefined`时必须采取预防措施，因为很容易意外更改其值。在ECMAScript 5中，这是不必要的，因为`undefined`是只读的。'
- en: 'To protect against a changed `undefined`, two techniques were popular (they
    are still relevant for older JavaScript engines):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止更改`undefined`，有两种流行的技术（它们对于旧的JavaScript引擎仍然相关）：
- en: Technique 1
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 技术1
- en: 'Shadow the global `undefined` (which may have the wrong value):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 屏蔽全局`undefined`（可能具有错误的值）：
- en: '[PRE76]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the preceding code, `undefined` is guaranteed to have the right value, because
    it is a parameter whose value has not been provided by the function call.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`undefined`保证具有正确的值，因为它是一个参数，其值未由函数调用提供。
- en: Technique 2
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 技术2
- en: 'Compare with `void 0`, which is always (the correct) `undefined` (see [The
    void Operator](ch09.html#void_operator "The void Operator")):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 与始终（正确的）`undefined`相比，`void 0`（请参阅[void运算符](ch09.html#void_operator "void运算符")）：
- en: '[PRE77]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Wrapper Objects for Primitives
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基元的包装对象
- en: 'The three primitive types boolean, number, and string have corresponding constructors:
    `Boolean`, `Number`, `String`. Their instances (so-called *wrapper objects*) contain
    (*wrap*) primitive values. The constructors can be used in two ways:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值、数字和字符串这三种原始类型都有对应的构造函数：`Boolean`、`Number`、`String`。它们的实例（称为*包装对象*）包含（*包装*）原始值。这些构造函数可以以两种方式使用：
- en: 'As constructors, they create objects that are largely incompatible with the
    primitive values that they wrap:'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为构造函数，它们创建的对象与它们包装的原始值大部分不兼容：
- en: '[PRE78]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As functions, they convert values to the corresponding primitive types (see
    [Functions for Converting to Boolean, Number, String, and Object](ch08.html#convert_to_primitive
    "Functions for Converting to Boolean, Number, String, and Object")). This is the
    recommended method of conversion:'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数，它们将值转换为相应的原始类型（见[转换为布尔值、数字、字符串和对象的函数](ch08.html#convert_to_primitive "转换为布尔值、数字、字符串和对象的函数"））。这是推荐的转换方法：
- en: '[PRE79]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Tip
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It’s considered a best practice to avoid wrapper objects. You normally don’t
    need them, as there is nothing that objects can do that primitives can’t (with
    the exception of being mutated). (This is different from Java, from which JavaScript
    inherited the difference between primitives and objects!)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是避免使用包装对象。通常情况下，您不需要它们，因为对象不能做的事情原始值都可以做（除了被改变）。（这与Java不同，JavaScript从中继承了原始值和对象之间的差异！）
- en: Wrapper Objects Are Different from Primitives
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装对象与原始值不同
- en: 'Primitive values such as `''abc''` are fundamentally different from wrapper
    instances such as `new String(''abc'')`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`'abc'`之类的原始值与诸如`new String('abc')`之类的包装实例在根本上是不同的：
- en: '[PRE80]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Wrapper instances are objects, and there is no way of comparing objects in
    JavaScript, not even via lenient equals `==` (see [Equality Operators: === Versus
    ==](ch09.html#equality_operators "Equality Operators: === Versus ==")):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 包装实例是对象，JavaScript中没有办法比较对象，甚至不能通过宽松相等`==`进行比较（见[相等运算符：===与==](ch09.html#equality_operators
    "相等运算符：===与=="））：
- en: '[PRE81]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Wrapping and Unwrapping Primitives
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装和解包原始值
- en: 'There is one use case for wrapper objects: you want to add properties to a
    primitive value. Then you wrap the primitive and add properties to the wrapper
    object. You need to unwrap the value before you can work with it.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 包装对象的一个用例是：您想要向原始值添加属性。然后您包装原始值并向包装对象添加属性。在使用之前，您需要解包该值。
- en: 'Wrap a primitive by invoking a wrapper constructor:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用包装构造函数来包装原始值：
- en: '[PRE82]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Unwrap a primitive by invoking the method `valueOf()`. All objects have this
    method (as discussed in [Conversion to Primitive](ch17_split_001.html#Object.prototype.valueOf
    "Conversion to Primitive")):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用方法`valueOf()`来解包原始值。所有对象都有这个方法（如[转换为原始值](ch17_split_001.html#Object.prototype.valueOf
    "转换为原始值"）中所讨论的）：
- en: '[PRE83]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Converting wrapper objects to primitives properly extracts numbers and strings,
    but not booleans:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 将包装对象转换为原始值可以正确提取数字和字符串，但不能提取布尔值：
- en: '[PRE84]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The reason for this is explained in [Converting to Boolean](ch10.html#toboolean
    "Converting to Boolean").
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在[转换为布尔值](ch10.html#toboolean "转换为布尔值"）中解释的原因。
- en: Primitives Borrow Their Methods from Wrappers
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始值从包装对象中借用它们的方法
- en: 'Primitives don’t have their own methods and borrow them from wrappers:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 原始值没有自己的方法，而是从包装对象中借用它们：
- en: '[PRE85]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Sloppy mode and strict mode handle this borrowing differently. In sloppy mode,
    primitives are converted to wrappers on the fly:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 松散模式和严格模式以不同的方式处理这种借用。在松散模式下，原始值会即时转换为包装对象：
- en: '[PRE86]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In strict mode, methods from the wrapper prototype are used transparently:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，会透明地使用包装原型中的方法：
- en: '[PRE87]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Type Coercion
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型强制
- en: '*Type coercion* means the implicit conversion of a value of one type to a value
    of another type. Most of JavaScript’s operators, functions, and methods coerce
    operands and arguments to the types that they need. For example, the operands
    of the multiplication operator (`*`) are coerced to numbers:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型强制*意味着将一个类型的值隐式转换为另一个类型的值。JavaScript的大多数运算符、函数和方法都会将操作数和参数强制转换为它们需要的类型。例如，乘法运算符（`*`）的操作数会被强制转换为数字：'
- en: '[PRE88]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'As another example, if one of the operands is a string, the plus operator (`+`)
    converts the other one to a string:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，如果操作数之一是字符串，加号运算符（`+`）会将另一个操作数转换为字符串：
- en: '[PRE89]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Type Coercion Can Hide Bugs
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型强制可以隐藏错误
- en: 'Therefore, JavaScript rarely complains about a value having the wrong type.
    For example, programs normally receive user input (from online forms or GUI widgets)
    as strings, even if the user has entered a number. If you treat a number-as-string
    like a number, you will not get a warning, just unexpected results. For example:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JavaScript很少抱怨值的类型错误。例如，程序通常会将用户输入（来自在线表单或GUI小部件）作为字符串接收，即使用户输入的是一个数字。如果您将一个数字作为字符串处理，您将不会收到警告，只会得到意外的结果。例如：
- en: '[PRE90]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In cases such as the preceding one, you should convert to the appropriate type
    early on:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如前面的情况下，您应该尽早将其转换为适当的类型：
- en: '[PRE91]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Functions for Converting to Boolean, Number, String, and Object
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换为布尔值、数字、字符串和对象的函数
- en: 'The following functions are the preferred way of converting a value to a boolean,
    number, string, or object:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是将值转换为布尔值、数字、字符串或对象的首选方法：
- en: '`Boolean()` (see [Converting to Boolean](ch10.html#toboolean "Converting to
    Boolean"))'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boolean()`（见[转换为布尔值](ch10.html#toboolean "转换为布尔值"））'
- en: 'Converts a value to a boolean. The following values are converted to `false`;
    they are the so-called “falsy” values:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个值转换为布尔值。以下值被转换为`false`；它们被称为“假值”：
- en: '`undefined`, `null`'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`，`null`'
- en: '`false`'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`0`, `NaN`'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`，`NaN`'
- en: '`''''`'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''''`'
- en: All other values are considered “truthy” and converted to `true` (including
    all objects!).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他值都被视为“真值”，并转换为`true`（包括所有对象！）。
- en: '`Number()` (see [Converting to Number](ch11.html#tonumber "Converting to Number"))'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number()`（见[转换为数字](ch11.html#tonumber "转换为数字"））'
- en: 'Converts a value to a number:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个值转换为数字：
- en: '`undefined` becomes `NaN`.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`变为`NaN`。'
- en: '`null` becomes `0`.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`变为`0`。'
- en: '`false` becomes `0`, `true` becomes `1`.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`变为`0`，`true`变为`1`。'
- en: Strings are parsed.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串被解析。
- en: Objects are first converted to primitives (discussed shortly), which are then
    converted to numbers.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先将对象转换为原始值（稍后讨论），然后将其转换为数字。
- en: '`String()` (see [Converting to String](ch12.html#tostring "Converting to String"))'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`String()`（参见[转换为字符串](ch12.html#tostring "转换为字符串")）'
- en: 'Converts a value to a string. It has the obvious results for all primitives.
    For example:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 将值转换为字符串。对于所有原始值，它都有明显的结果。例如：
- en: '[PRE92]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Objects are first converted to primitives (discussed shortly), which are then
    converted to strings.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将对象转换为原始值（稍后讨论），然后将其转换为字符串。
- en: '`Object()` (see [Converting Any Value to an Object](ch17_split_000.html#toobject
    "Converting Any Value to an Object"))'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object()`（参见[将任何值转换为对象](ch17_split_000.html#toobject "将任何值转换为对象")）'
- en: 'Converts objects to themselves, `undefined` and `null` to empty objects, and
    primitives to wrapped primitives. For example:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象转换为它们自己，将`undefined`和`null`转换为空对象，将原始值转换为包装的原始值。例如：
- en: '[PRE93]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note that `Boolean()`, `Number()`, `String()`, and `Object()` are called as
    functions. You normally don’t use them as constructors. Then they create instances
    of themselves (see [Wrapper Objects for Primitives](ch08.html#wrapper_objects
    "Wrapper Objects for Primitives")).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Boolean()`、`Number()`、`String()`和`Object()`都被作为函数调用。你通常不会将它们用作构造函数。然后它们创建自己的实例（参见[原始值的包装对象](ch08.html#wrapper_objects
    "原始值的包装对象")）。
- en: 'Algorithm: ToPrimitive()—Converting a Value to a Primitive'
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法：ToPrimitive()——将值转换为原始值
- en: To convert a value to either a number or a string, it is first converted to
    an arbitrary primitive value, which is then converted to the final type (as discussed
    in [Functions for Converting to Boolean, Number, String, and Object](ch08.html#convert_to_primitive
    "Functions for Converting to Boolean, Number, String, and Object")).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要将值转换为数字或字符串，首先将其转换为任意原始值，然后将其转换为最终类型（如[用于转换为布尔值、数字、字符串和对象的函数](ch08.html#convert_to_primitive
    "用于转换为布尔值、数字、字符串和对象的函数")中所讨论的）。
- en: 'The ECMAScript specification has an internal function, `ToPrimitive()` (which
    is not accessible from JavaScript), that performs this conversion. Understanding
    `ToPrimitive()` enables you to configure how objects are converted to numbers
    and strings. It has the following signature:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript规范有一个内部函数`ToPrimitive()`（无法从JavaScript中访问），它执行这种转换。了解`ToPrimitive()`使你能够配置对象如何转换为数字和字符串。它有以下签名：
- en: '[PRE94]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The optional parameter `PreferredType` indicates the final type of the conversion:
    it is either `Number` or `String`, depending on whether the result of `ToPrimitive()`
    will be converted to a number or a string.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数`PreferredType`指示转换的最终类型：它可以是`Number`或`String`，具体取决于`ToPrimitive()`的结果将被转换为数字还是字符串。
- en: 'If `PreferredType` is `Number`, then you perform the following steps:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`PreferredType`是`Number`，则执行以下步骤：
- en: If `input` is primitive, return it (there is nothing more to do).
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`input`是原始的，就返回它（没有更多的事情要做了）。
- en: Otherwise, `input` is an object. Call `input.valueOf()`. If the result is primitive,
    return it.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，`input`是一个对象。调用`input.valueOf()`。如果结果是原始的，就返回它。
- en: Otherwise, call `input.toString()`. If the result is primitive, return it.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，调用`input.toString()`。如果结果是原始的，就返回它。
- en: Otherwise, throw a `TypeError` (indicating the failure to convert `input` to
    a primitive).
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，抛出`TypeError`（表示无法将`input`转换为原始值）。
- en: If `PreferredType` is `String`, steps 2 and 3 are swapped. The `PreferredType`
    can also be omitted; it is then considered to be `String` for dates and `Number`
    for all other values. This is how the operators `+` and `==` call `ToPrimitive()`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`PreferredType`是`String`，则步骤2和3会交换。`PreferredType`也可以省略；然后它被认为是日期的`String`，而对于所有其他值，则被认为是`Number`。这就是运算符`+`和`==`调用`ToPrimitive()`的方式。
- en: 'Examples: ToPrimitive() in action'
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例：ToPrimitive()的实际应用
- en: 'The default implementation of `valueOf()` returns `this`, while the default
    implementation of `toString()` returns type information:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`valueOf()`的默认实现返回`this`，而`toString()`的默认实现返回类型信息：'
- en: '[PRE95]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Therefore, `Number()` skips `valueOf()` and converts the result of `toString()`
    to a number; that is, it converts `''[object Object]''` to `NaN`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Number()`跳过`valueOf()`，将`toString()`的结果转换为数字；也就是说，它将`'[object Object]'`转换为`NaN`：
- en: '[PRE96]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The following object customizes `valueOf()`, which influences `Number()`, but
    doesn’t change anything for `String()`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对象自定义了`valueOf()`，它影响`Number()`，但对于`String()`没有任何改变：
- en: '[PRE97]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The following object customizes `toString()`. Because the result can be converted
    to a number, `Number()` can return a number:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对象自定义了`toString()`。因为结果可以转换为数字，所以`Number()`可以返回一个数字：
- en: '[PRE98]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '* * *'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[7](#id914993)]) Technically, primitive values do not have their own properties,
    they borrow them from wrapper constructors. But that is something that goes on
    behind the scenes, so you don’t normally see it.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#id914993)]) 从技术上讲，原始值没有自己的属性，它们从包装构造函数中借用。但这是在幕后进行的，所以你通常看不到它。
- en: Chapter 9. Operators
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章 运算符
- en: This chapter gives an overview of operators.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了运算符。
- en: Operators and Objects
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符和对象
- en: 'All operators coerce (as discussed in [Type Coercion](ch08.html#type_coercion
    "Type Coercion")) their operands to appropriate types. Most operators only work
    with primitive values (e.g., arithmetic operators and comparison operators). That
    means that objects are converted to primitives before anything is done with them.
    One example where that is unfortunate is the plus operator, which many languages
    use for array concatenation. That’s not so with JavaScript, however, where this
    operator converts arrays to strings and appends them:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 所有运算符都会强制转换（如[类型强制转换](ch08.html#type_coercion "类型强制转换")中所讨论的）它们的操作数为适当的类型。大多数运算符只能处理原始值（例如，算术运算符和比较运算符）。这意味着在对它们进行任何操作之前，对象都会被转换为原始值。其中一个不幸的例子是加号运算符，许多语言用它来进行数组连接。然而，在JavaScript中并非如此，这个运算符会将数组转换为字符串并将它们连接起来：
- en: '[PRE99]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is no way to overload or customize operators in JavaScript, not even equality.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中没有办法重载或自定义运算符，甚至没有相等性。
- en: Assignment Operators
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: 'There are several ways to use the plain assignment operator:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种使用普通赋值运算符的方法：
- en: '`x = value`'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`x = value`'
- en: Assigns to a variable `x` that has previously been declared
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给先前声明的变量`x`
- en: '`var x = value`'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`var x = value`'
- en: Combines a variable declaration with an assignment
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量声明与赋值结合
- en: '`obj.propKey = value`'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj.propKey = value`'
- en: Sets a property
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 设置属性
- en: '`obj[''propKey''] = value`'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj[''propKey''] = value`'
- en: Sets a property
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 设置属性
- en: '`arr[index] = value`'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr[index] = value`'
- en: Sets an array element^([[8](#ftn.id443353)])
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 设置数组元素^([[8](#ftn.id443353)])
- en: 'An assignment is an expression that evaluates to the assigned value. That allows
    you to chain assignments. For example, the following statement assigns `0` to
    both `y` and `x`:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值是一个求值为赋值的表达式。这允许您链接赋值。例如，以下语句将`0`分配给`y`和`x`：
- en: '[PRE100]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Compound Assignment Operators
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复合赋值运算符
- en: 'A *compound assignment operator* is written as `op=`, where `op` is one of
    several binary operators and `=` is the assignment operator. The following two
    expressions are equivalent:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '*复合赋值运算符*写为`op=`，其中`op`是几个二进制运算符之一，`=`是赋值运算符。以下两个表达式是等价的：'
- en: '[PRE101]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In other words, a compound assignment operator `op=` applies `op` to both operands
    and assigns the result to the first operand. Let’s look at an example of using
    the plus operator (`+`) via compound assignment:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，复合赋值运算符`op=`将`op`应用于两个操作数，并将结果分配给第一个操作数。让我们看一个使用加法运算符（`+`）的复合赋值的示例：
- en: '[PRE102]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The following are all compound assignment operators:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 以下都是复合赋值运算符：
- en: 'Arithmetic operations (see [Arithmetic Operators](ch11.html#arithmetic_operators
    "Arithmetic Operators")): `*=`, `/=`, `%=`, `+=`, `-=`'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算（参见[算术运算符](ch11.html#arithmetic_operators "算术运算符")）：`*=`, `/=`, `%=`, `+=`,
    `-=`
- en: 'Bitwise operations (see [Binary Bitwise Operators](ch11.html#binary_bitwise_operators
    "Binary Bitwise Operators")): `<<=`, `>>=`, `>>>=`, `&=`, `^=`, `|=`'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位操作（参见[二进制按位运算符](ch11.html#binary_bitwise_operators "二进制按位运算符")）：`<<=`, `>>=`,
    `>>>=`, `&=`, `^=`, `|=`
- en: 'String concatenation (see [Concatenation: The Plus (+) Operator](ch12.html#string_plus
    "Concatenation: The Plus (+) Operator")): `+=`'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串连接（参见[连接：加号（+）运算符](ch12.html#string_plus "连接：加号（+）运算符")）：`+=`
- en: 'Equality Operators: === Versus =='
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相等运算符：===与==
- en: 'JavaScript has two ways of determining whether two values are equal:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有两种确定两个值是否相等的方法：
- en: Strict equality (`===`) and strict inequality (`!==`) consider only values that
    have the same type to be equal.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格相等（`===`）和严格不等（`!==`）仅认为具有相同类型的值相等。
- en: Normal (or “lenient”) equality (`==`) and inequality (`!=`) try to convert values
    of different types before comparing them as with strict (in)equality.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常（或“宽松”）相等（`==`）和不等（`!=`）在比较之前尝试转换不同类型的值，就像严格（不）相等一样。
- en: Lenient equality is problematic in two regards. First, how it performs conversion
    is confusing. Second, due to the operators being so forgiving, type errors can
    remain hidden longer.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 宽松相等在两个方面存在问题。首先，它的转换方式令人困惑。其次，由于运算符如此宽容，类型错误可能会隐藏更长时间。
- en: Always use strict equality and avoid lenient equality. You only need to learn
    about the latter if you want to know why it should be avoided.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用严格相等，避免宽松相等。只有在您想知道为什么应该避免它时，才需要了解后者。
- en: Equality is not customizable. Operators can’t be overloaded in JavaScript, and
    you can’t customize how equality works. There are some operations where you often
    need to influence comparison—for example, `Array.prototype.sort()` (see [Sorting
    and Reversing Elements (Destructive)](ch18.html#Array.prototype.sort "Sorting
    and Reversing Elements (Destructive)")). That method optionally accepts a callback
    that performs all comparisons between array elements.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 相等是不可定制的。JavaScript中的运算符不能被重载，也不能定制相等的工作方式。有一些操作，您经常需要影响比较——例如，`Array.prototype.sort()`（参见[排序和反转元素（破坏性）](ch18.html#Array.prototype.sort
    "排序和反转元素（破坏性）")）。该方法可选择接受一个回调，该回调执行数组元素之间的所有比较。
- en: Strict Equality (===, !==)
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格相等（===, !==）
- en: 'Values with different types are never strictly equal. If both values have the
    same type, then the following assertions hold:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 具有不同类型的值永远不会严格相等。如果两个值具有相同的类型，则以下断言成立：
- en: '`undefined === undefined`'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined === undefined`'
- en: '`null === null`'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null === null`'
- en: 'Two numbers:'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个数字：
- en: '[PRE103]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Two booleans, two strings: obvious results'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个布尔值，两个字符串：显而易见的结果
- en: 'Two objects (including arrays and functions): `x === y` if and only if `x`
    and `y` are the same object; that is, if you want to compare different objects,
    you have to implement your own comparison algorithm:'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '两个对象（包括数组和函数）：`x === y`当且仅当`x`和`y`是同一个对象时；也就是说，如果要比较不同的对象，您必须实现自己的比较算法： '
- en: '[PRE104]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Everything else: not strictly equal.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他一切：不严格相等。
- en: 'Pitfall: NaN'
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：NaN
- en: 'The special number value `NaN` (see [NaN](ch11.html#nan "NaN")) is not equal
    to itself:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的数字值`NaN`（参见[NaN](ch11.html#nan "NaN")）不等于自身：
- en: '[PRE105]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Thus, you need to use other means to check for it, which are described in [Pitfall:
    checking whether a value is NaN](ch11.html#isNaN "Pitfall: checking whether a
    value is NaN").'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要使用其他方法来检查它，这些方法在[陷阱：检查值是否为NaN](ch11.html#isNaN "陷阱：检查值是否为NaN")中有描述。
- en: Strict inequality (!==)
  id: totrans-493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 严格不等 (!==)
- en: 'A strict inequality comparison:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 严格不等比较：
- en: '[PRE106]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'is equivalent to the negation of a strict equality comparison:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于严格相等比较的否定：
- en: '[PRE107]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Normal (Lenient) Equality (==, !=)
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正常（宽松）相等（==, !=）
- en: The algorithm for comparing via normal equality works as follows. If both operands
    have the same type (one of the six specification types—Undefined, Null, Boolean,
    Number, String, and Object), then compare them via strict equality.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 通过正常相等比较的算法工作如下。如果两个操作数具有相同的类型（六种规范类型之一——Undefined、Null、Boolean、Number、String和Object），则通过严格相等比较它们。
- en: 'Otherwise, if the operands are:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果操作数是：
- en: '`undefined` and `null`, then they are considered leniently equal:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`undefined`和`null`，那么它们被认为是宽松相等的：'
- en: '[PRE108]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: A string and a number, then convert the string to a number and compare both
    operands via strict equality.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个字符串和一个数字，然后将字符串转换为数字，并通过严格相等比较两个操作数。
- en: A boolean and a nonboolean, then convert the boolean to a number and compare
    leniently (again).
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个布尔值和一个非布尔值，然后将布尔值转换为数字并进行宽松比较（再次）。
- en: 'An object and a number or a string, then try to convert the object to a primitive
    (via the algorithm described in [Algorithm: ToPrimitive()—Converting a Value to
    a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting a Value
    to a Primitive")) and compare leniently (again).'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个对象和一个数字或字符串，然后尝试将对象转换为原始值（通过[算法：ToPrimitive()—将值转换为原始值](ch08.html#toprimitive
    "算法：ToPrimitive()—将值转换为原始值")中描述的算法）并进行宽松比较。
- en: Otherwise—if none of the aforementioned cases apply—the result of the lenient
    comparison is `false`.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 否则——如果上述任何情况都不适用——宽松比较的结果是`false`。
- en: Lenient inequality (!=)
  id: totrans-507
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 宽松不等号（!=）
- en: 'An inequality comparison:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不等式比较：
- en: '[PRE109]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'is equivalent to the negation of an equality comparison:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于等式比较的否定：
- en: '[PRE110]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Pitfall: lenient equality is different from conversion to boolean'
  id: totrans-512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：宽松相等与转换为布尔值不同
- en: 'Step 3 means that equality and conversion to boolean (see [Converting to Boolean](ch10.html#toboolean
    "Converting to Boolean")) work differently. If converted to boolean, numbers greater
    than 1 become `true` (e.g., in `if` statements). But those numbers are not leniently
    equal to `true`. The comments explain how the results were computed:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步意味着相等和转换为布尔值（参见[转换为布尔值](ch10.html#toboolean "转换为布尔值")）的工作方式不同。如果转换为布尔值，大于1的数字变为`true`（例如，在`if`语句中）。但这些数字并不宽松相等于`true`。注释解释了结果是如何计算的：
- en: '[PRE111]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Similarly, while the empty string is equal to `false`, not all nonempty strings
    are equal to `true`:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，虽然空字符串等于`false`，但并非所有非空字符串都等于`true`：
- en: '[PRE112]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Pitfall: lenient equality and strings'
  id: totrans-517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：宽松相等和字符串
- en: 'Some of the leniency can be useful, depending on what you want:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 一些宽松性可能是有用的，这取决于你的需求：
- en: '[PRE113]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Other cases are problematic, due to how JavaScript converts strings to numbers
    (see [Converting to Number](ch11.html#tonumber "Converting to Number")):'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 其他情况可能有问题，因为JavaScript如何将字符串转换为数字（参见[转换为数字](ch11.html#tonumber "转换为数字")）：
- en: '[PRE114]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Pitfall: lenient equality and objects'
  id: totrans-522
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：宽松相等和对象
- en: 'If you compare an object to a nonobject, it is converted to a primitive, which
    leads to strange results:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个对象与一个非对象进行比较，它会被转换为原始值，这会导致奇怪的结果：
- en: '[PRE115]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'However, two objects are only equal if they are they same object. That means
    that you can’t really compare two wrapper objects:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有两个对象是相等的，如果它们是同一个对象。这意味着你不能真正比较两个包装对象：
- en: '[PRE116]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: There Are No Valid Use Cases for ==
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有`==`的有效用例
- en: You sometimes read about valid use cases for lenient equality (`==`). This section
    lists them and points out better alternatives.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会读到关于宽松相等（`==`）的有效用例。本节列出了它们，并指出了更好的替代方案。
- en: 'Use case: checking for undefined or null'
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用例：检查undefined或null
- en: 'The following comparison ensures that `x` is neither `undefined` nor `null`:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 以下比较确保`x`既不是`undefined`也不是`null`：
- en: '[PRE117]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'While this is a compact way of writing this check, it confuses beginners, and
    experts can’t be sure whether it is a typo or not. Thus, if you want to check
    whether `x` has a value, use the standard check for truthiness (covered in [Truthy
    and Falsy Values](ch10.html#truthy_falsy "Truthy and Falsy Values")):'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一种简洁的写法，但它会让初学者感到困惑，而专家也无法确定它是否是打字错误。因此，如果你想检查`x`是否有值，请使用标准的真值检查（在[真值和假值](ch10.html#truthy_falsy
    "真值和假值")中介绍）：
- en: '[PRE118]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'If you want to be more precise, you should perform an explicit check for both
    values:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更精确，你应该对两个值进行显式检查：
- en: '[PRE119]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Use case: working with numbers in strings'
  id: totrans-536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用例：处理字符串中的数字
- en: 'If you are not sure whether a value `x` is a number or a number-as-a-string,
    you can use checks such as the following:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定一个值`x`是一个数字还是一个数字字符串，你可以使用以下检查：
- en: '[PRE120]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The preceding checks whether `x` is either `123` or `''123''`. Again, this
    is very compact, and again, it is better to be explicit:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的检查是为了确保`x`是`123`或`'123'`。同样，这是非常紧凑的，而且最好是明确的：
- en: '[PRE121]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Use case: comparing wrapper instances with primitives'
  id: totrans-541
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用例：比较包装实例和原始值
- en: 'Lenient equals lets you compare primitives with wrapped primitives:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 宽松相等允许你比较原始值和包装原始值：
- en: '[PRE122]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'There are three reasons against this approach. First, lenient equality does
    not work between wrapped primitives:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个理由反对这种方法。首先，宽松相等在包装原始值之间不起作用：
- en: '[PRE123]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Second, you should avoid wrappers anyway. Third, if you do use them, it is
    better to be explicit:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你应该无论如何避免使用包装器。第三，如果你使用它们，最好是明确的：
- en: '[PRE124]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Ordering Operators
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序运算符
- en: 'JavaScript knows the following ordering operators:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript知道以下排序运算符：
- en: Less than (`<`)
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于（`<`）
- en: Less than or equal (`<=`)
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于或等于（`<=`）
- en: Greater than (`>`)
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于（`>`）
- en: Greater than or equal (`>=`)
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于或等于（`>=`）
- en: 'These operators work for numbers and for strings:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符适用于数字和字符串：
- en: '[PRE125]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: For strings, they are not very useful, because they are case-sensitive and don’t
    handle features such as accents well (for details, see [Comparing Strings](ch12.html#comparing_strings
    "Comparing Strings")).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串来说，它们并不是非常有用，因为它们区分大小写，而且不能很好地处理重音等特性（有关详细信息，请参见[比较字符串](ch12.html#comparing_strings
    "比较字符串")）。
- en: The Algorithm
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法
- en: 'You evaluate a comparison:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 你评估一个比较：
- en: '[PRE126]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'by taking the following steps:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤：
- en: 'Ensure that both operands are primitives. Objects `obj` are converted to primitives
    via the internal operation `ToPrimitive(obj, Number)` (refer to [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")), which calls `obj.valueOf()` and, possibly, `obj.toString()`
    to do so.'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保两个操作数都是原始值。对象`obj`通过内部操作`ToPrimitive(obj, Number)`（参见[算法：ToPrimitive()—将值转换为原始值](ch08.html#toprimitive
    "算法：ToPrimitive()—将值转换为原始值")）转换为原始值，该操作调用`obj.valueOf()`和可能的`obj.toString()`来实现。
- en: If both operands are strings, then compare them by lexicographically comparing
    the 16-bit code units (see [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript"))
    that represent the JavaScript characters of the string.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个操作数都是字符串，那么通过按字典顺序比较表示字符串的JavaScript字符的16位代码单元（参见[第24章](ch24.html "第24章.
    Unicode and JavaScript")）来比较它们。
- en: Otherwise, convert both operands to numbers and compare them numerically.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，将两个操作数转换为数字并进行数字比较。
- en: The other ordering operators are handled similarly.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 其他排序运算符类似处理。
- en: The Plus Operator (+)
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加号运算符（+）
- en: 'Roughly, the plus operator examines its operands. If one of them is a string,
    the other is also converted to a string and both are concatenated:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，加号运算符检查它的操作数。 如果其中一个是字符串，则另一个也被转换为字符串，并且两者被连接：
- en: '[PRE127]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Otherwise, both operands are converted to numbers (see [Converting to Number](ch11.html#tonumber
    "Converting to Number")) and added:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，两个操作数都转换为数字（参见[转换为数字](ch11.html#tonumber "转换为数字")）并相加：
- en: '[PRE128]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'That means that the order in which you evaluate matters:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着评估的顺序很重要：
- en: '[PRE129]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The Algorithm
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法
- en: 'You evaluate an addition:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 你评估一个加法：
- en: '[PRE130]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'by taking the following steps:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '通过以下步骤进行： '
- en: 'Ensure that both operands are primitives. Objects `obj` are converted to primitives
    via the internal operation `ToPrimitive(obj)` (refer to [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")), which calls `obj.valueOf()` and, possibly, `obj.toString()`
    to do so. For dates, `obj.toString()` is called first.'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保两个操作数都是原始值。 对象`obj`通过内部操作`ToPrimitive(obj)`（参见[算法：ToPrimitive()—将值转换为原始值](ch08.html#toprimitive
    "算法：ToPrimitive()—将值转换为原始值")）转换为原始值，该操作调用`obj.valueOf()`和可能的`obj.toString()`来执行此操作。
    对于日期，首先调用`obj.toString()`。
- en: If either operand is a string, then convert both to strings and return the concatenation
    of the results.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任一操作数是字符串，则将两者转换为字符串并返回结果的连接。
- en: Otherwise, convert both operands to numbers and return the sum of the results.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，将两个操作数转换为数字，并返回结果的总和。
- en: Operators for Booleans and Numbers
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值和数字的运算符
- en: The following operators only have operands of a single type and also produce
    results of that type. They are covered elsewhere.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 以下运算符只有单一类型的操作数，并且也产生该类型的结果。 它们在其他地方有所涉及。
- en: 'Boolean operators:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符：
- en: 'Binary logical operators (see [Binary Logical Operators: And (&&) and Or (||)](ch10.html#binary_logical_operators
    "Binary Logical Operators: And (&&) and Or (||)")):'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制逻辑运算符（参见[二进制逻辑运算符：And (&&)和Or (||)](ch10.html#binary_logical_operators "二进制逻辑运算符：And
    (&&)和Or (||)")）：
- en: '[PRE131]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Logical Not (see [Logical Not (!)](ch10.html#logical_not "Logical Not (!)")):'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑非（参见[逻辑非(!)](ch10.html#logical_not "逻辑非(!)")）：
- en: '[PRE132]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Number operators:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 数字运算符：
- en: 'Arithmetic operators (see [Arithmetic Operators](ch11.html#arithmetic_operators
    "Arithmetic Operators")):'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符（参见[算术运算符](ch11.html#arithmetic_operators "算术运算符"）：
- en: '[PRE133]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Bitwise operators (see [Bitwise Operators](ch11.html#bitwise_operators "Bitwise
    Operators")):'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位运算符（参见[按位运算符](ch11.html#bitwise_operators "按位运算符"）：
- en: '[PRE134]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Special Operators
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊运算符
- en: Here we will review special operators, namely the conditional, comma, and `void`
    operators.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将回顾特殊运算符，即条件、逗号和`void`运算符。
- en: 'The Conditional Operator ( ? : )'
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件运算符（？：）
- en: 'The conditional operator is an expression:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符是一个表达式：
- en: '[PRE135]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'If the condition is `true`, the result is `if_true`; otherwise, the result
    is `if_false`. For example:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件为`true`，则结果为`if_true`； 否则，结果为`if_false`。 例如：
- en: '[PRE136]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The parentheses around the operator are not needed, but they make it easier
    to read.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要在运算符周围加括号，但这样做会使其更易于阅读。
- en: The Comma Operator
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逗号运算符
- en: '[PRE137]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The comma operator evaluates both operands and returns the result of `right`.
    Roughly, it does for expressions what the semicolon does for statements.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符评估两个操作数并返回“right”的结果。 粗略地说，它对表达式做了分号对语句所做的事情。
- en: 'This example demonstrates that the second operand becomes the result of the
    operator:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了第二个操作数成为运算符的结果：
- en: '[PRE138]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'This example demonstrates that both operands are evaluated:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了两个操作数都被评估：
- en: '[PRE139]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The comma operator is confusing. It’s better to not be clever and to write two
    separate statements whenever you can.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符很令人困惑。 最好不要聪明，而是在您可以的情况下编写两个单独的语句。
- en: The void Operator
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: void运算符
- en: 'The syntax for the `void` operator is:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`运算符的语法是：'
- en: '[PRE140]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'which evaluates `expr` and returns `undefined`. Here are some examples:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 评估`expr`并返回`undefined`。 以下是一些例子：
- en: '[PRE141]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Thus, if you implement `void` as a function, it looks as follows:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您将`void`实现为一个函数，它看起来如下：
- en: '[PRE142]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The `void` operator is associated closely with its operand, so use parentheses
    as necessary. For example, `void 4+7` binds as `(void 4)+7`.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`运算符与其操作数密切相关，因此根据需要使用括号。 例如，`void 4+7`绑定为`(void 4)+7`。'
- en: What is void used for?
  id: totrans-615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: void用于什么？
- en: 'Under ECMAScript 5, `void` is rarely useful. Its main use cases are:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 5下，`void`很少有用。 它的主要用例是：
- en: '`void 0` as a synonym for `undefined`'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`void 0`作为`undefined`的同义词'
- en: The latter can be changed, while the former will always have the correct value.
    However, `undefined` is reasonably safe from being changed under ECMAScript 5,
    which makes this use case less important (for details, see [Changing undefined](ch08.html#changing_undefined
    "Changing undefined")).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 后者可以更改，而前者将始终具有正确的值。 但是，在ECMAScript 5下，`undefined`相对安全，这使得这种用例不那么重要（有关详细信息，请参见[更改undefined](ch08.html#changing_undefined
    "更改undefined")）。
- en: Discarding the result of an expression
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 丢弃表达式的结果
- en: 'In some situations, it is important to return `undefined` as opposed to the
    result of an expression. Then `void` can be used to discard that result. One such
    situation involves `javascript:` URLs, which should be avoided for links, but
    are useful for bookmarklets. When you visit one of those URLs, many browsers replace
    the current document with the result of evaluating the URL’s “content,” but only
    if the result isn’t `undefined`. Hence, if you want to open a new window without
    changing the currently displayed content, you can do the following:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，返回`undefined`而不是表达式的结果很重要。 然后可以使用`void`来丢弃该结果。 其中一种情况涉及`javascript:`
    URL，应该避免使用链接，但对于书签很有用。 当您访问这些URL之一时，许多浏览器会用URL的“内容”评估结果替换当前文档，但前提是结果不是`undefined`。
    因此，如果您想要打开一个新窗口而不更改当前显示的内容，可以执行以下操作：
- en: '[PRE143]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Prefixing an IIFE
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀IIFE
- en: 'An IIFE must be parsed as an expression. One of several ways to ensure that
    is by prefixing it with `void` (see [IIFE Variation: Prefix Operators](ch16.html#iife_prefix
    "IIFE Variation: Prefix Operators")).^([[9](#ftn.id936155)])'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 'IIFE必须被解析为表达式。确保这一点的几种方法之一是用`void`作为前缀（参见[IIFE变体：前缀运算符](ch16.html#iife_prefix
    "IIFE Variation: Prefix Operators")）^([[9](#ftn.id936155)])'
- en: Why does JavaScript have a void operator?
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么JavaScript有void运算符？
- en: 'According to JavaScript creator Brendan Eich, he added it to the language to
    help with `javascript:` links (one of the aforementioned use cases):'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JavaScript的创始人Brendan Eich，他将其添加到语言中以帮助处理`javascript:`链接（前面提到的用例之一）：
- en: 'I added the `void` operator to JS before Netscape 2 shipped to make it easy
    to discard any non-undefined value in a javascript: URL.^([[10](#ftn.id872078)])'
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '我在Netscape 2发布之前向JS添加了`void`运算符，以便轻松丢弃javascript: URL中的任何非undefined值。^([[10](#ftn.id872078)])'
- en: Categorizing Values via typeof and instanceof
  id: totrans-627
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过typeof和instanceof对值进行分类
- en: 'If you want to categorize a value, you unfortunately have to distinguish between
    primitives and objects (refer back to [Chapter 8](ch08.html "Chapter 8. Values"))
    in JavaScript:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对一个值进行分类，不幸的是你必须区分原始值和对象（参见[第8章](ch08.html "第8章. Values")中的内容）：
- en: The `typeof` operator distinguishes primitives from objects and determines the
    types of primitives.
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: typeof运算符区分原始值和对象，并确定原始值的类型。
- en: The `instanceof` operator determines whether an object is an instance of a given
    constructor. Consult [Chapter 17](ch17_split_000.html "Chapter 17. Objects and
    Inheritance") for more information on object-oriented programming in JavaScript.
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instanceof`运算符确定一个对象是否是给定构造函数的实例。有关JavaScript中面向对象编程的更多信息，请参阅[第17章](ch17_split_000.html
    "第17章. Objects and Inheritance")。'
- en: 'typeof: Categorizing Primitives'
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: typeof：对原始值进行分类
- en: 'The `typeof` operator:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: typeof运算符：
- en: '[PRE144]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'returns a string describing what kind of value `value` is. Here are some examples:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 返回描述`value`是什么类型的字符串。以下是一些例子：
- en: '[PRE145]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '`typeof` is used to distinguish primitives and objects and to categorize primitives
    (which cannot be handled by `instanceof`). Unfortunately, the results of this
    operator are not completely logical and only loosely correspond to the types of
    the ECMAScript specification (which are explained in [JavaScript’s Types](ch08.html#javascript_types
    "JavaScript’s Types")):'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`用于区分原始值和对象，并对原始值进行分类（`instanceof`无法处理原始值）。不幸的是，这个运算符的结果并不完全符合逻辑，而且只是松散地对应于ECMAScript规范的类型（在[JavaScript的类型](ch08.html#javascript_types
    "JavaScript’s Types")中有解释）：'
- en: '| Operand | Result |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| 操作数 | 结果 |'
- en: '| --- | --- |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `undefined`, undeclared variable | `''undefined''` |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| `undefined`，未声明的变量 | `''undefined''` |'
- en: '| `null` | `''object''` |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `''object''` |'
- en: '| Boolean value | `''boolean''` |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | `''boolean''` |'
- en: '| Number value | `''number''` |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '| 数值 | `''number''` |'
- en: '| String value | `''string''` |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| 字符串值 | `''string''` |'
- en: '| Function | `''function''` |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | `''function''` |'
- en: '| All other normal values | `''object''` |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| 所有其他正常值 | `''object''` |'
- en: '| (Engine-created value) | JavaScript engines are allowed to create values
    for whom `typeof` returns arbitrary strings (different from all results listed
    in this table). |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| （引擎创建的值） | JavaScript引擎允许创建值，对于这些值，`typeof`返回任意字符串（与表中列出的所有结果不同）。'
- en: 'Pitfall: typeof null'
  id: totrans-647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：typeof null
- en: 'Unfortunately, `typeof null` is `''object''`. This is considered a bug (`null`
    is not a member of the internal type Object), but it can’t be fixed, because doing
    so would break existing code. You thus have to be wary of `null`. For example,
    the following function checks whether `value` is an object:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`typeof null`是`'object'`。这被认为是一个错误（`null`不是内部类型Object的成员），但无法修复，因为这样做会破坏现有的代码。因此，你必须谨慎处理`null`。例如，以下函数检查`value`是否是一个对象：
- en: '[PRE146]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Trying it out:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 试一试：
- en: '[PRE147]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The history of typeof null
  id: totrans-652
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: typeof null的历史
- en: The [first JavaScript engine](http://mzl.la/1oO9VF7) represented JavaScript
    values as 32-bit words. The lowest 3 bits of such a word were used as a type tag,
    to indicate whether the value was an object, an integer, a double, a string, or
    a boolean (as you can see, even this early engine already stored numbers as integers
    if possible).
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个JavaScript引擎将JavaScript值表示为32位字。这样的字的最低3位用作类型标记，以指示该值是对象、整数、双精度、字符串还是布尔值（正如你所看到的，即使这个早期引擎已经尽可能将数字存储为整数）。
- en: The type tag for objects was 000\. In order to represent the value `null`, the
    engine used the machine language NULL pointer, a word where all bits are zero.
    `typeof` checked the type tag to determine the type of value, which is why it
    reported `null` to be an object.^([[11](#ftn.id894831)])
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的类型标记为000。为了表示值`null`，引擎使用了机器语言的NULL指针，一个所有位都为零的字。`typeof`检查类型标记以确定值的类型，这就是为什么它报告`null`是一个对象的原因。^([[11](#ftn.id894831)])
- en: Checking whether a variable exists
  id: totrans-655
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查变量是否存在
- en: 'The check:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 检查：
- en: '[PRE148]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'has two use cases:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种用例：
- en: It determines whether `x` is `undefined`.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它确定`x`是否`undefined`。
- en: It determines whether the variable `x` exists.
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它确定变量`x`是否存在。
- en: 'Here are examples of both use cases:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两种用例的示例：
- en: '[PRE149]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'For the first use case, comparing directly with `undefined` is usually a better
    choice. However, it doesn’t work for the second use case:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个用例，直接与`undefined`进行比较通常是更好的选择。但是，对于第二个用例，这种方法行不通。
- en: '[PRE150]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'instanceof: Checking Whether an Object Is an Instance of a Given Constructor'
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: instanceof：检查对象是否是给定构造函数的实例
- en: 'The `instanceof` operator:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`运算符：'
- en: '[PRE151]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'determines whether `value` has been created by the constructor `Constr` or
    a subconstructor. Here are some examples:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 确定`value`是由构造函数`Constr`还是子构造函数创建的。以下是一些例子：
- en: '[PRE152]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'As expected, `instanceof` is `false` for the nonvalues `undefined` and `null`:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的是，`instanceof`对非值`undefined`和`null`返回`false`：
- en: '[PRE153]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'But it is also `false` for all other primitive values:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于所有其他原始值也是`false`：
- en: '[PRE154]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: For details on `instanceof`, consult [The instanceof Operator](ch17_split_001.html#operator_instanceof
    "The instanceof Operator").
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`instanceof`的详细信息，请参阅[instanceof运算符](ch17_split_001.html#operator_instanceof
    "The instanceof Operator")。
- en: Object Operators
  id: totrans-675
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象运算符
- en: 'The following three operators work on objects. They are explained elsewhere:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个运算符适用于对象。它们在其他地方有解释：
- en: '`new` (see [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances"))'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`（参见[第三层：构造函数——实例的工厂](ch17_split_001.html#constructors "第三层：构造函数——实例的工厂")）'
- en: Invoke a constructor—for example, `new Point(3, 5)`
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 调用构造函数，例如，`new Point(3, 5)`
- en: '`delete` (see [Deleting properties](ch17_split_000.html#operator_delete "Deleting
    properties"))'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`（参见[删除属性](ch17_split_000.html#operator_delete "删除属性")）'
- en: Delete a property—for example, `delete obj.prop`
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 删除属性，例如，`delete obj.prop`
- en: '`in` (see [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties"))'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`（参见[迭代和属性检测](ch17_split_000.html#iterate_and_detect_properties "迭代和属性检测")）'
- en: Check whether an object has a given property—for example, `'prop' in obj`
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 检查对象是否具有给定属性，例如，`'prop' in obj`
- en: '* * *'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[8](#id443353)]) Strictly speaking, setting an array element is a special
    case of setting a property.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[8](#id443353)]) 严格来说，设置数组元素是设置属性的特例。
- en: ^([[9](#id936155)]) Thanks to Brandon Benvie (@benvie), who told me about using
    `void` for IIFEs.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[9](#id936155)]) 感谢 Brandon Benvie (@benvie)，他告诉我如何使用`void`来进行 IIFEs。
- en: '^([[10](#id872078)]) Source: [http://en.wikipedia.org/wiki/Bookmarklet](http://en.wikipedia.org/wiki/Bookmarklet)'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[10](#id872078)]) 来源：[http://en.wikipedia.org/wiki/Bookmarklet](http://en.wikipedia.org/wiki/Bookmarklet)
- en: ^([[11](#id894831)]) Thanks to Tom Schuster (@evilpies) for pointing me to the
    source code of the first JavaScript engine.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[11](#id894831)]) 感谢 Tom Schuster (@evilpies) 指引我到第一个 JavaScript 引擎的源代码。
- en: Chapter 10. Booleans
  id: totrans-688
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章。布尔值
- en: 'The primitive boolean type comprises the values `true` and `false`:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 原始布尔类型包括值`true`和`false`：
- en: '[PRE155]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Converting to Boolean
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为布尔值
- en: 'Values are converted to booleans as follows:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换为布尔值的方式如下：
- en: '| Value | Converted to boolean |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 转换为布尔值 |'
- en: '| --- | --- |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `undefined` | `false` |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` | `false` |'
- en: '| `null` | `false` |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `false` |'
- en: '| A boolean | Same as input (nothing to convert) |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| 一个布尔值 | 与输入相同（无需转换） |'
- en: '| A number | `0`, `NaN` → `false` |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| 一个数字 | `0`、`NaN` → `false` |'
- en: '|  | other numbers → `true` |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '|  | 其他数字 → `true` |'
- en: '| A string | `''''` → `false` |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
  zh: '| 一个字符串 | `''''` → `false` |'
- en: '|  | other strings → `true` |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '|  | 其他字符串 → `true` |'
- en: '| An object | `true` (always!) |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '| 一个对象 | `true`（总是！） |'
- en: Manually Converting to Boolean
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动转换为布尔值
- en: 'There are three ways any value can be converted to a boolean:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 任何值都可以通过三种方式转换为布尔值：
- en: '| `Boolean(value)` | (Invoked as a function, not as a constructor) |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '| `Boolean(value)` | （作为函数调用，而不是构造函数） |'
- en: '| `value ? true : false` |  |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '| `value ? true : false` |  |'
- en: '| `!!value` | A single “not” converts to negated boolean; use twice for the
    nonnegated conversion. |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '| `!!value` | 单个“not”转换为取反的布尔值；使用两次进行非取反转换。 |'
- en: 'I prefer `Boolean()`, because it is more descriptive. Here are some examples:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢`Boolean()`，因为它更具描述性。以下是一些例子：
- en: '[PRE156]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Truthy and Falsy Values
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真值和假值
- en: 'Wherever JavaScript expects a boolean, you can provide any kind of value and
    it is automatically converted to boolean. Thus, there are two sets of values in
    JavaScript: one set is converted to `false`, while the other set is converted
    to `true`. These sets are called *falsy values* and *truthy values*. Given the
    preceding table, the following are all falsy values:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 需要布尔值的地方，你可以提供任何类型的值，它会自动转换为布尔值。因此，在 JavaScript 中有两组值：一组转换为`false`，而另一组转换为`true`。这些组被称为*假值*和*真值*。根据前面的表格，以下是所有的假值：
- en: '`undefined`, `null`'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`、`null`'
- en: 'Boolean: `false`'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：`false`
- en: 'Number: `0`, `NaN`'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：`0`、`NaN`
- en: 'String: `''''`'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：`''`
- en: 'All other values—including *all* objects, even empty objects, empty arrays,
    and `new Boolean(false)`—are truthy. Because `undefined` and `null` are falsy,
    you can use the `if` statement to check whether a variable `x` has a value:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他值，包括*所有*对象，甚至是空对象、空数组和`new Boolean(false)`，都是真值。因为`undefined`和`null`是假值，你可以使用`if`语句来检查变量`x`是否有值：
- en: '[PRE157]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The caveat is that the preceding check interprets all falsy values as “does
    not have a value,” not just `undefined` and `null`. But if you can live with that
    limitation, you get to use a compact and established pattern.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，前面的检查将所有假值解释为“没有值”，不仅仅是`undefined`和`null`。但如果你可以接受这个限制，你就可以使用一种简洁和成熟的模式。
- en: 'Pitfall: all objects are truthy'
  id: totrans-719
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：所有对象都是真值
- en: 'All objects are truthy:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象都是真值：
- en: '[PRE158]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'That is different from how objects are converted to a number or string, where
    you can control the result by implementing the methods `valueOf()` and `toString()`:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 这与对象转换为数字或字符串的方式不同，你可以通过实现`valueOf()`和`toString()`方法来控制结果。
- en: '[PRE159]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'History: Why are objects always truthy?'
  id: totrans-724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 历史：为什么对象总是真值？
- en: The conversion to boolean is different for historic reasons. For ECMAScript 1,
    it was decided to not enable objects to configure that conversion (e.g., via a
    `toBoolean()` method). The rationale was that the boolean operators `||` and `&&`
    preserve the values of their operands. Therefore, if you chain those operators,
    the same value may be checked multiple times for truthiness or falsiness. Such
    checks are cheap for primitives, but would be costly for objects if they were
    able to configure their conversion to boolean. ECMAScript 1 avoided that cost
    by making objects always truthy.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，布尔值的转换方式不同。在 ECMAScript 1 中，决定不允许对象配置该转换（例如，通过`toBoolean()`方法）。其理由是布尔运算符`||`和`&&`会保留其操作数的值。因此，如果你链式使用这些运算符，相同的值可能会被多次检查真值或假值。对于原始值来说，这些检查是廉价的，但如果对象能够配置它们的布尔值转换，那么对于对象来说将会很昂贵。ECMAScript
    1 通过使对象始终为真值来避免这种成本。
- en: Logical Operators
  id: totrans-726
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: In this section, we cover the basics of the And (&&), Or (||), and Not (!) logical
    operators.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 And（&&）、Or（||）和Not（!）逻辑运算符的基础知识。
- en: 'Binary Logical Operators: And (&&) and Or (||)'
  id: totrans-728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制逻辑运算符：And（&&）和Or（||）
- en: 'Binary logical operators are:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制逻辑运算符有：
- en: Value-preserving
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 保持值不变
- en: 'They always return either one of the operands, unchanged:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 它们总是返回两个操作数中的一个，不会改变：
- en: '[PRE160]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Short-circuiting
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 短路
- en: 'The second operand is not evaluated if the first operand already determines
    the result. For example (the result of `console.log` is `undefined`):'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数已经确定了结果，则不会评估第二个操作数。例如（`console.log`的结果是`undefined`）：
- en: '[PRE161]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: That is uncommon behavior for operators. Normally, all operands are evaluated
    before an operator is invoked (just like for functions).
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运算符的不常见行为。通常，在调用运算符之前会评估所有操作数（就像函数一样）。
- en: Logical And (&&)
  id: totrans-737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑与（&&）
- en: 'If the first operand can be converted to `false`, return it. Otherwise, return
    the second operand:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数可以转换为`false`，则返回它。否则，返回第二个操作数：
- en: '[PRE162]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Logical Or (||)
  id: totrans-740
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑或（||）
- en: 'If the first operand can be converted to `true`, return it. Otherwise, return
    the second operand:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数可以转换为`true`，则返回它。否则，返回第二个操作数：
- en: '[PRE163]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Pattern: providing a default value'
  id: totrans-743
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模式：提供默认值
- en: 'Sometimes there are situations where a value (a parameter, the result of a
    function, etc.) can be either a nonvalue (`undefined`, `null`) or an actual value.
    If you want to provide a default value for the former case, you can use the Or
    operator:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会出现这样的情况：一个值（参数、函数的结果等）可以是非值（`undefined`、`null`）或实际值。如果要为前一种情况提供默认值，可以使用或运算符：
- en: '[PRE164]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The preceding expression evaluates to `theValue` if it is truthy and to `defaultValue`
    otherwise. The usual caveat applies: `defaultValue` will also be returned if `theValue`
    has a falsy value other than `undefined` and `null`. Let’s look at three examples
    of using that pattern.'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式在`theValue`为真值时求值为`theValue`，否则为`defaultValue`。通常的警告适用：如果`theValue`具有除`undefined`和`null`之外的假值，则也将返回`defaultValue`。让我们看看使用该模式的三个示例。
- en: 'Example 1: a default for a parameter'
  id: totrans-747
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例1：参数的默认值
- en: 'The parameter `text` of the function `saveText()` is optional and should be
    the empty string if it has been omitted:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`saveText()`的参数`text`是可选的，如果省略了，则应该是空字符串：
- en: '[PRE165]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: This is the most common use of `||` as a default operator. Consult [Optional
    Parameters](ch15.html#optional_parameters "Optional Parameters") for more on optional
    parameters.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`||`作为默认运算符的最常见用法。有关可选参数的更多信息，请参阅[可选参数](ch15.html#optional_parameters "可选参数")。
- en: 'Example 2: a default for a property'
  id: totrans-751
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例2：属性的默认值
- en: 'The object `options` may or may not have the property `title`. If it is missing,
    the value `''Untitled''` should be used when setting the title:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`options`可能有也可能没有属性`title`。如果缺少，则在设置标题时应使用值`'Untitled'`：
- en: '[PRE166]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Example 3: a default for the result of a function'
  id: totrans-754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例3：函数结果的默认值
- en: 'The function `countOccurrences` counts how often `regex` matches inside `str`:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`countOccurrences`计算`regex`在`str`中匹配的次数：
- en: '[PRE167]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'The problem is that `match()` (see [String.prototype.match: Capture Groups
    or Return All Matching Substrings](ch19.html#String.prototype.match "String.prototype.match:
    Capture Groups or Return All Matching Substrings")) either returns an array or
    `null`. Thanks to `||`, a default value is used in the latter case. Therefore,
    you can safely access the property `length` in both cases.'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '问题在于`match()`（请参见[String.prototype.match: Capture Groups or Return All Matching
    Substrings](ch19.html#String.prototype.match "String.prototype.match: Capture
    Groups or Return All Matching Substrings")）要么返回一个数组，要么返回`null`。由于`||`，在后一种情况下使用了默认值。因此，您可以安全地在两种情况下访问属性`length`。'
- en: Logical Not (!)
  id: totrans-758
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑非（！）
- en: 'The logical not operator `!` converts its operand to boolean and then negates
    it:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑非运算符`!`将其操作数转换为布尔值，然后对其取反：
- en: '[PRE168]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Equality Operators, Ordering Operators
  id: totrans-761
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相等运算符，排序运算符
- en: 'The following operators are covered elsewhere:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 其他运算符在其他地方有所涵盖：
- en: 'Equality operators: `===`, `!==`, `==`, `!=` (see [Equality Operators: ===
    Versus ==](ch09.html#equality_operators "Equality Operators: === Versus =="))'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等运算符：`===`，`!==`，`==`，`!=`（参见[相等运算符：===与==](ch09.html#equality_operators "相等运算符：===与==")）
- en: 'Ordering operators: `>`, `>=`, `<`, `<=` (see [Ordering Operators](ch09.html#ordering_operators
    "Ordering Operators"))'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序运算符：`>`，`>=`，`<`，`<=`（参见[排序运算符](ch09.html#ordering_operators "排序运算符")）
- en: The Function Boolean
  id: totrans-765
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔函数
- en: 'The function `Boolean` can be invoked in two ways:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`Boolean`可以以两种方式调用：
- en: '`Boolean(value)`'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boolean(value)`'
- en: 'As a normal function, it converts `value` to a primitive boolean (see [Converting
    to Boolean](ch10.html#toboolean "Converting to Boolean")):'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 作为普通函数，它将`value`转换为原始布尔值（请参见[转换为布尔值](ch10.html#toboolean "转换为布尔值")）：
- en: '[PRE169]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '`new Boolean(bool)`'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Boolean(bool)`'
- en: 'As a constructor, it creates a new instance of `Boolean` (see [Wrapper Objects
    for Primitives](ch08.html#wrapper_objects "Wrapper Objects for Primitives")),
    an object that wraps `bool` (after converting it to a boolean). For example:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 作为构造函数，它创建了`Boolean`的新实例（参见[原始包装对象](ch08.html#wrapper_objects "原始包装对象")），一个将`bool`（在将其转换为布尔值后）包装起来的对象。例如：
- en: '[PRE170]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: The former invocation is the common one.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的调用是常见的。
- en: Chapter 11. Numbers
  id: totrans-774
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章。数字
- en: 'JavaScript has a single type for all numbers: it treats all of them as floating-point
    numbers. However, the dot is not displayed if there are no digits after the decimal
    point:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对所有数字都使用单一类型：它将它们全部视为浮点数。但是，如果小数点后没有数字，则不显示小数点：
- en: '[PRE171]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Internally, most JavaScript engines optimize and do distinguish between floating-point
    numbers and integers (details: [Integers in JavaScript](ch11.html#integers "Integers
    in JavaScript")). But that is something that programmers don’t see.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，大多数JavaScript引擎都会优化并区分浮点数和整数（详情请参见[JavaScript中的整数](ch11.html#integers "JavaScript中的整数")）。但这是程序员看不到的东西。
- en: JavaScript numbers are `double` (64-bit) values, based on the IEEE Standard
    for Floating-Point Arithmetic (IEEE 754). That standard is used by many programming
    languages.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript数字是基于IEEE浮点算术标准（IEEE 754）的`double`（64位）值。该标准被许多编程语言使用。
- en: Number Literals
  id: totrans-779
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字文字
- en: 'A number literal can be an integer, floating point, or (integer) hexadecimal:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 数字文字可以是整数、浮点数或（整数）十六进制：
- en: '[PRE172]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Exponent
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指数
- en: 'An exponent, `eX`, is an abbreviation for “multiply with 10^X”:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 指数`eX`是“乘以10^X”的缩写：
- en: '[PRE173]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Invoking Methods on Literals
  id: totrans-785
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在文字上调用方法
- en: 'With number literals, the dot for accessing a property must be distinguished
    from the decimal dot. This leaves you with the following options if you want to
    invoke `toString()` on the number literal `123`:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数字文字，访问属性的点必须与小数点区分开。如果要在数字文字`123`上调用`toString()`，则有以下选项：
- en: '[PRE174]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Converting to Number
  id: totrans-788
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为数字
- en: 'Values are converted to numbers as follows:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 将值转换为数字的方式如下：
- en: '| Value | Result |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 结果 |'
- en: '| --- | --- |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `undefined` | `NaN` |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` | `NaN` |'
- en: '| `null` | `0` |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `0` |'
- en: '| A boolean | `false` → `0` |'
  id: totrans-794
  prefs: []
  type: TYPE_TB
  zh: '| 一个布尔值 | `false` → `0` |'
- en: '|  | `true` → `1` |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '|  | `true` → `1` |'
- en: '| A number | Same as input (nothing to convert) |'
  id: totrans-796
  prefs: []
  type: TYPE_TB
  zh: '| 一个数字 | 与输入相同（无需转换）|'
- en: '| A string | Parse the number in the string (ignoring leading and trailing
    whitespace); the empty string is converted to 0. Example: `''3.141''` → `3.141`
    |'
  id: totrans-797
  prefs: []
  type: TYPE_TB
  zh: '| 一个字符串 | 解析字符串中的数字（忽略前导和尾随空格）；空字符串转换为0。示例：`''3.141''` → `3.141` |'
- en: '| An object | Call `ToPrimitive(value, Number)` (see [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")) and convert the resulting primitive. |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
  zh: '| 一个对象 | 调用`ToPrimitive(value, Number)`（参见[算法：ToPrimitive()—将值转换为原始值](ch08.html#toprimitive
    "算法：ToPrimitive()—将值转换为原始值")）并转换生成的原始值。|'
- en: When converting the empty string to a number, `NaN` would arguably be a better
    result. The result 0 was chosen to help with empty numeric input fields, in line
    with what other programming languages did in the mid-1990s.^([[12](#ftn.id995098)])
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 将空字符串转换为数字时，`NaN`可能是更好的结果。选择结果0是为了帮助处理空的数字输入字段，符合1990年代中期其他编程语言的做法。^([[12](#ftn.id995098)])
- en: Manually Converting to Number
  id: totrans-800
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动转换为数字
- en: 'The two most common ways to convert any value to a number are:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何值转换为数字的两种最常见方法是：
- en: '| `Number(value)` | (Invoked as a function, not as a constructor) |'
  id: totrans-802
  prefs: []
  type: TYPE_TB
  zh: '| `Number(value)` |（作为函数调用，而不是作为构造函数调用）|'
- en: '| `+value` |  |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
  zh: '| `+value` |  |'
- en: 'I prefer `Number()`, because it is more descriptive. Here are some examples:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢`Number()`，因为它更具描述性。以下是一些示例：
- en: '[PRE175]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: parseFloat()
  id: totrans-806
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: parseFloat()
- en: 'The global function `parseFloat()` provides another way to convert values to
    numbers. However, `Number()` is usually a better choice, as we shall see in a
    moment. This code:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 全局函数`parseFloat()`提供了另一种将值转换为数字的方法。但是，`Number()`通常是更好的选择，我们稍后将看到。这段代码：
- en: '[PRE176]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: converts `str` to string, trims leading whitespace, and then parses the longest
    prefix that is a floating-point number. If no such prefix exists (e.g., in an
    empty string), `NaN` is returned.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 将`str`转换为字符串，修剪前导空格，然后解析最长的浮点数前缀。如果不存在这样的前缀（例如，在空字符串中），则返回`NaN`。
- en: 'Comparing `parseFloat()` and `Number()`:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 比较`parseFloat()`和`Number()`：
- en: 'Applying `parseFloat()` to a nonstring is less efficient, because it coerces
    its argument to a string before parsing it. As a consequence, many values that
    `Number()` converts to actual numbers are converted to `NaN` by `parseFloat()`:'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`parseFloat()`应用于非字符串的效率较低，因为它在解析之前将其参数强制转换为字符串。因此，`Number()`转换为实际数字的许多值被`parseFloat()`转换为`NaN`：
- en: '[PRE177]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '`parseFloat()` parses the empty string as `NaN`:'
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseFloat()`将空字符串解析为`NaN`：'
- en: '[PRE178]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '`parseFloat()` parses until the last legal character, meaning you get a result
    where you may not want one:'
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseFloat()`解析到最后一个合法字符，这意味着您可能会得到一个您不想要的结果：'
- en: '[PRE179]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '`parseFloat()` ignores leading whitespace and stops before illegal characters
    (which include whitespace):'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseFloat()`忽略前导空格，并在非法字符之前停止（其中包括空格）：'
- en: '[PRE180]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '`Number()` ignores both leading and trailing whitespace (but other illegal
    characters lead to `NaN`).'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number()`忽略前导和尾随空格（但其他非法字符会导致`NaN`）。'
- en: Special Number Values
  id: totrans-820
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊数字值
- en: 'JavaScript has several special number values:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有几个特殊的数字值：
- en: Two error values, `NaN` and `Infinity`.
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个错误值，`NaN`和`Infinity`。
- en: Two values for zero, `+0` and `-0`. JavaScript has two zeros, a positive zero
    and a negative zero, because the sign and the magnitude of a number are stored
    separately. In most of this book, I pretend that there is only a single zero,
    and you almost never see in JavaScript that there are two of them.
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个零值，`+0`和`-0`。JavaScript有两个零，一个正零和一个负零，因为数字的符号和大小存储在不同的位置。在本书的大部分内容中，我假设只有一个零，并且您几乎从不在JavaScript中看到有两个零。
- en: NaN
  id: totrans-824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NaN
- en: 'The error value `NaN` (an abbreviation for “not a number”) is, ironically,
    a number value:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 错误值`NaN`（“不是一个数字”的缩写）是一个数字值，具有讽刺意味：
- en: '[PRE181]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'It is produced by errors such as the following:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 它是由以下错误产生的：
- en: 'A number could not be parsed:'
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法解析数字：
- en: '[PRE182]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'An operation failed:'
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作失败：
- en: '[PRE183]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'One of the operands is `NaN` (this ensures that, if an error occurs during
    a longer computation, you can see it in the final result):'
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数之一是`NaN`（这可以确保在较长的计算过程中发生错误时，您可以在最终结果中看到它）：
- en: '[PRE184]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Pitfall: checking whether a value is NaN'
  id: totrans-834
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：检查值是否为NaN
- en: '`NaN` is the only value that is not equal to itself:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`是唯一不等于自身的值：'
- en: '[PRE185]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Strict equality (`===`) is also used by `Array.prototype.indexOf`. You therefore
    can’t search for `NaN` in an array via that method:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 严格相等（`===`）也被`Array.prototype.indexOf`使用。因此，您不能通过该方法在数组中搜索`NaN`：
- en: '[PRE186]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'If you want to check whether a value is `NaN`, you have to use the global function
    `isNaN()`:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要检查值是否为`NaN`，则必须使用全局函数`isNaN()`：
- en: '[PRE187]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'However, `isNaN` does not work properly with nonnumbers, because it first converts
    those to numbers. That conversion can produce `NaN` and then the function incorrectly
    returns `true`:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`isNaN`不能正确处理非数字，因为它首先将它们转换为数字。该转换可能产生`NaN`，然后该函数错误地返回`true`：
- en: '[PRE188]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Thus, it is best to combine `isNaN` with a type check:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好将`isNaN`与类型检查结合使用：
- en: '[PRE189]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Alternatively, you can check whether the value is unequal to itself (as `NaN`
    is the only value with this trait). But that is less self-explanatory:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以检查值是否不等于自身（因为`NaN`是唯一具有此特性的值）。但这不够自解释：
- en: '[PRE190]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Note that this behavior is dictated by IEEE 754\. As noted in Section 7.11,
    “Details of comparison predicates”:^([[13](#ftn.id1001327)])
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此行为由IEEE 754规定。如第7.11节“比较谓词的详细信息”中所述：^([[13](#ftn.id1001327)])
- en: Every NaN shall compare unordered with everything, including itself.
  id: totrans-848
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个NaN都将与任何东西（包括自身）比较无序。
- en: Infinity
  id: totrans-849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Infinity
- en: '`Infinity` is an error value indicating one of two problems: a number can’t
    be represented because its magnitude is too large, or a division by zero has happened.'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`是一个错误值，指示两个问题中的一个：一个数字无法表示，因为其大小太大，或者发生了除以零。'
- en: '`Infinity` is larger than any other number (except `NaN`). Similarly, `-Infinity`
    is smaller than any other number (except `NaN`). That makes them useful as default
    values—for example, when you are looking for a minimum or maximum.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`大于任何其他数字（除了`NaN`）。同样，`-Infinity`小于任何其他数字（除了`NaN`）。这使它们在默认值方面非常有用，例如，当您正在寻找最小值或最大值时。'
- en: 'Error: a number’s magnitude is too large'
  id: totrans-852
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误：数字的大小太大
- en: 'How large a number’s magnitude can become is determined by its internal representation
    (as discussed in [The Internal Representation of Numbers](ch11.html#number_representation
    "The Internal Representation of Numbers")), which is the arithmetic product of:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字的大小取决于其内部表示（如[数字的内部表示](ch11.html#number_representation "数字的内部表示")中所讨论的），即：
- en: A mantissa (a binary number 1.f[1]f[2]...)
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾数（一个二进制数1.f[1]f[2]...）
- en: 2 to the power of an exponent
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数的2次幂
- en: 'The exponent must be between (and excluding) −1023 and 1024\. If the exponent
    is too small, the number becomes 0\. If the exponent is too large, it becomes
    `Infinity`. 2^(1023) can still be represented, but 2^(1024) can’t:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 指数必须在（不包括）-1023和1024之间。如果指数太小，数字变为0。如果指数太大，它变为`Infinity`。2^(1023)仍然可以表示，但2^(1024)不能：
- en: '[PRE191]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Error: division by zero'
  id: totrans-858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误：除以零
- en: 'Dividing by zero produces `Infinity` as an error value:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 除以零会产生`Infinity`作为错误值：
- en: '[PRE192]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Computing with Infinity
  id: totrans-861
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Infinity进行计算
- en: 'You get the error result `NaN` if you try to “neutralize” one `Infinity` with
    another one:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试用另一个`Infinity`“中和”一个`Infinity`，则会得到错误结果`NaN`：
- en: '[PRE193]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'If you try to go beyond `Infinity`, you still get `Infinity`:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试超出`Infinity`，您仍然会得到`Infinity`：
- en: '[PRE194]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Checking for Infinity
  id: totrans-866
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查Infinity
- en: 'Strict and lenient equality work fine for `Infinity`:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 严格和宽松的相等对`Infinity`也适用：
- en: '[PRE195]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Additionally, the global function `isFinite()` allows you to check whether
    a value is an actual number (neither infinite nor `NaN`):'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，全局函数`isFinite()`允许您检查一个值是否是一个实际的数字（既不是无穷大也不是`NaN`）：
- en: '[PRE196]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Two Zeros
  id: totrans-871
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个零
- en: Because JavaScript’s numbers keep magnitude and sign separate, each nonnegative
    number has a negative, including `0`.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 因为JavaScript的数字保持大小和符号分开，每个非负数都有一个负数，包括`0`。
- en: 'The rationale for this is that whenever you represent a number digitally, it
    can become so small that it is indistinguishable from 0, because the encoding
    is not precise enough to represent the difference. Then a signed zero allows you
    to record “from which direction” you approached zero; that is, what sign the number
    had before it was considered zero. Wikipedia nicely sums up the pros and cons
    of [signed zeros](http://en.wikipedia.org/wiki/Signed_zero):'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当您以数字的方式表示数字时，它可能变得非常小，以至于无法与0区分，因为编码不够精确以表示差异。然后，有符号零允许您记录“从哪个方向”接近零；也就是说，在被视为零之前，数字具有什么符号。维基百科很好地总结了[有符号零](http://en.wikipedia.org/wiki/Signed_zero)的利弊：
- en: It is claimed that the inclusion of signed zero in IEEE 754 makes it much easier
    to achieve numerical accuracy in some critical problems, in particular when computing
    with complex elementary functions. On the other hand, the concept of signed zero
    runs contrary to the general assumption made in most mathematical fields (and
    in most mathematics courses) that negative zero is the same thing as zero. Representations
    that allow negative zero can be a source of errors in programs, as software developers
    do not realize (or may forget) that, while the two zero representations behave
    as equal under numeric comparisons, they are different bit patterns and yield
    different results in some operations.
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 据称，IEEE 754中包含有符号零使得在一些关键问题中更容易实现数值精度，特别是在计算复杂的初等函数时。另一方面，有符号零的概念与大多数数学领域（以及大多数数学课程）中的一般假设相矛盾，即负零和零是相同的。允许负零的表示可以成为程序中的错误源，因为软件开发人员没有意识到（或可能忘记了），虽然这两个零表示在数值比较下行为相等，但它们是不同的位模式，并在一些操作中产生不同的结果。
- en: 'Best practice: pretend there’s only one zero'
  id: totrans-875
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最佳实践：假装只有一个零
- en: JavaScript goes to great lengths to hide the fact that there are two zeros.
    Given that it normally doesn’t matter that they are different, it is recommended
    that you play along with the illusion of the single zero. Let’s examine how that
    illusion is maintained.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript竭尽全力隐藏有两个零这一事实。鉴于通常并不重要它们是不同的，建议您配合单个零的幻觉。让我们看看这个幻觉是如何维持的。
- en: 'In JavaScript, you normally write `0`, which means `+0`. But `-0` is also displayed
    as simply `0`. This is what you see when you use a browser command line or the
    Node.js REPL:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，通常写为`0`，这意味着`+0`。但`-0`也显示为简单的`0`。这是您在使用浏览器命令行或Node.js REPL时看到的情况：
- en: '[PRE197]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'That is because the standard `toString()` method converts both zeros to the
    same `''0''`:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为标准的`toString()`方法将这两个零都转换为相同的`'0'`：
- en: '[PRE198]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Equality doesn’t distinguish zeros, either. Not even `===`:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 相等也无法区分零。甚至`===`也不行：
- en: '[PRE199]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '`Array.prototype.indexOf` uses `===` to search for elements, maintaining the
    illusion:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.indexOf`使用`===`搜索元素，维持了这个幻觉：'
- en: '[PRE200]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'The ordering operators also consider the zeros to be equal:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 排序运算符也认为这两个零是相等的：
- en: '[PRE201]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Distinguishing the two zeros
  id: totrans-887
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 区分这两个零
- en: 'How *can* you actually observe that the two zeros are different? You can divide
    by zero (`-Infinity` and `+Infinity` *can* be distinguished by `===`):'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '*您*如何实际观察到这两个零是不同的？您可以除以零（`-Infinity`和`+Infinity`可以通过`===`进行区分）：'
- en: '[PRE202]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Another way to perform the division by zero is via `Math.pow()` (see [Numerical
    Functions](ch21.html#Math.pow "Numerical Functions")):'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Math.pow()`（参见[数值函数](ch21.html#Math.pow "数值函数")）进行除以零的另一种方法：
- en: '[PRE203]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '`Math.atan2()` (see [Trigonometric Functions](ch21.html#Math.atan2 "Trigonometric
    Functions")) also reveals that the zeros are different:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.atan2()`（参见[三角函数](ch21.html#Math.atan2 "Trigonometric Functions"））还显示了这两个零是不同的：'
- en: '[PRE204]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'The canonical way of telling the two zeros apart is the division by zero. Therefore,
    a function for detecting negative zeros would look like this:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 区分这两个零的规范方法是除以零。因此，用于检测负零的函数如下：
- en: '[PRE205]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Here is the function in use:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用的函数：
- en: '[PRE206]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: The Internal Representation of Numbers
  id: totrans-898
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字的内部表示
- en: 'JavaScript numbers have 64-bit precision, which is also called *double precision*
    (type `double` in some programming languages). The internal representation is
    based on the IEEE 754 standard. The 64 bits are distributed between a number’s
    sign, exponent, and fraction as follows:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript数字具有64位精度，也称为*双精度*（某些编程语言中的`double`类型）。内部表示基于IEEE 754标准。64位分布在数字的符号、指数和分数之间，如下所示：
- en: '| Sign | Exponent ∈ [−1023, 1024] | Fraction |'
  id: totrans-900
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 指数 ∈ [−1023, 1024] | 分数 |'
- en: '| --- | --- | --- |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 bit | 11 bits | 52 bits |'
  id: totrans-902
  prefs: []
  type: TYPE_TB
  zh: '| 1位 | 11位 | 52位 |'
- en: '| Bit 63 | Bits 62–52 | Bits 51–0 |'
  id: totrans-903
  prefs: []
  type: TYPE_TB
  zh: '| 位63 | 位62–52 | 位51–0 |'
- en: 'The value of a number is computed by the following formula:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 数字的值由以下公式计算：
- en: (–1)^(sign) × %1.fraction × 2^(exponent)
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: (–1)^(sign) × %1.fraction × 2^(exponent)
- en: 'The prefixed percentage sign (`%`) means that the number in the middle is written
    in binary notation: a 1, followed by a binary point, followed by a binary fraction—namely
    the binary digits of the fraction (a natural number). Here are some examples of
    this representation:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀百分号（`%`）表示中间的数字以二进制表示：1，后跟二进制点，后跟二进制分数，即分数的二进制数字（自然数）。以下是此表示的一些示例：
- en: '| +0 |  | (sign = 0, fraction = 0, exponent = −1023) |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
  zh: '| +0 |  | (sign = 0, fraction = 0, exponent = −1023) |'
- en: '| –0 |  | (sign = 1, fraction = 0, exponent = −1023) |'
  id: totrans-908
  prefs: []
  type: TYPE_TB
  zh: '| –0 |  | (sign = 1, fraction = 0, exponent = −1023) |'
- en: '| 1 | = (−1)⁰ × %1.0 × 2⁰ | (sign = 0, fraction = 0, exponent = 0) |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '| 1 | = (−1)⁰ × %1.0 × 2⁰ | (sign = 0, fraction = 0, exponent = 0) |'
- en: '| 2 | = (−1)⁰ × %1.0 × 2¹ |  |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
  zh: '| 2 | = (−1)⁰ × %1.0 × 2¹ |  |'
- en: '| 3 | = (−1)⁰ × %1.1 × 2¹ | (sign = 0, fraction = 2^(51), exponent = 0) |'
  id: totrans-911
  prefs: []
  type: TYPE_TB
  zh: '| 3 | = (−1)⁰ × %1.1 × 2¹ | (sign = 0, fraction = 2^(51), exponent = 0) |'
- en: '| 0.5 | = (−1)⁰ × %1.0 × 2^(−1) |  |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '| 0.5 | = (−1)⁰ × %1.0 × 2^(−1) |  |'
- en: '| −1 | = (−1)¹ × %1.0 × 2⁰ |  |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
  zh: '| −1 | = (−1)¹ × %1.0 × 2⁰ |  |'
- en: 'The encodings of +0, −0, and 3 can be explained as follows:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: +0、−0和3的编码可以解释如下：
- en: '±0: Given that the fraction is always prefixed by a 1, it’s impossible to represent
    0 with it. Hence, JavaScript encodes a zero via the fraction 0 and the special
    exponent −1023\. The sign can be either positive or negative, meaning that JavaScript
    has two zeros (see [Two Zeros](ch11.html#two_zeros "Two Zeros")).'
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ±0：鉴于分数始终以1为前缀，因此无法使用它来表示0。因此，JavaScript通过分数0和特殊指数−1023来编码零。符号可以是正数或负数，这意味着JavaScript有两个零（参见[两个零](ch11.html#two_zeros
    "Two Zeros")）。
- en: '3: Bit 51 is the most significant (highest) bit of the fraction. That bit is
    1.'
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3：位51是分数的最高有效位。该位为1。
- en: Special Exponents
  id: totrans-917
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊指数
- en: 'The previously mentioned representation of numbers is called *normalized*.
    In that case, the exponent *e* is in the range −1023 < *e* < 1024 (excluding lower
    and upper bounds). −1023 and 1024 are special exponents:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的数字表示称为*标准化*。在这种情况下，指数 *e* 在范围内 −1023 < *e* < 1024（不包括下限和上限）。−1023和1024是特殊指数：
- en: 1024 is used for error values such as `NaN` and `Infinity`.
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1024用于`NaN`和`Infinity`等错误值。
- en: '−1023 is used for:'
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: −1023用于：
- en: Zero (if the fraction is 0, as just explained)
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零（如果分数为0，如刚才解释的那样）
- en: Small numbers close to zero (if the fraction is not 0).
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 靠近零的小数字（如果分数不为0）。
- en: 'To enable both applications, a different, so-called *denormalized*, representation
    is used:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 为了同时启用两个应用程序，使用了不同的所谓*非标准化*表示：
- en: (–1)^(sign) × %0.fraction × 2^(–1022)
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: (–1)^(sign) × %0.fraction × 2^(–1022)
- en: 'To compare, the smallest (as in “closest to zero”) numbers in normalized representation
    are:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较，标准化表示中最小（即“最接近零”的）数字是：
- en: (–1)^(sign) × %1.fraction × 2^(–1022)
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: (–1)^(sign) × %1.fraction × 2^(–1022)
- en: Denormalized numbers are smaller, because there is no leading digit 1.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 非标准化的数字更小，因为没有前导数字1。
- en: Handling Rounding Errors
  id: totrans-928
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理舍入误差
- en: 'JavaScript’s numbers are usually entered as decimal floating-point numbers,
    but they are internally represented as binary floating-point numbers. That leads
    to imprecision. To understand why, let’s forget JavaScript’s internal storage
    format and take a general look at what fractions can be well represented by decimal
    floating-point numbers and by binary floating-point numbers. In the decimal system,
    all fractions are a mantissa *m* divided by a power of 10:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的数字通常以十进制浮点数输入，但在内部表示为二进制浮点数。这导致了不精确。为了理解原因，让我们忘记JavaScript的内部存储格式，来看看十进制浮点数和二进制浮点数可以很好地表示哪些分数。在十进制系统中，所有分数都是一个底数
    *m* 除以10的幂：
- en: '![](eq_1101.png)'
  id: totrans-930
  prefs: []
  type: TYPE_IMG
  zh: '![](eq_1101.png)'
- en: 'So, in the denominator, there are only tens. That’s why ![](inleq_1102.png)
    cannot be expressed precisely as a decimal floating-point number—there is no way
    to get a 3 into the denominator. Binary floating-point numbers only have twos
    in the denominator. Let’s examine which decimal floating-point numbers can be
    represented well as binary and which can’t. If there are only twos in the denominator,
    the decimal number can be represented:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在分母中只有十。这就是为什么无法将![](inleq_1102.png)精确表示为十进制浮点数的原因——无法将3放入分母。二进制浮点数中只有二。让我们看看哪些十进制浮点数可以很好地表示为二进制浮点数，哪些不能。如果分母中只有二，那么可以表示十进制数：
- en: 0.5[dec] = ![](inleq_1103.png) = ![](inleq_1104.png) = 0.1[bin]
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.5[dec] = ![](inleq_1103.png) = ![](inleq_1104.png) = 0.1[bin]
- en: 0.75[dec] = ![](inleq_1105.png) = ![](inleq_1106.png) = 0.11[bin]
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.75[dec] = ![](inleq_1105.png) = ![](inleq_1106.png) = 0.11[bin]
- en: 0.125[dec] = ![](inleq_1107.png) = ![](inleq_1108.png) = 0.001[bin]
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.125[dec] = ![](inleq_1107.png) = ![](inleq_1108.png) = 0.001[bin]
- en: 'Other fractions cannot be represented precisely, because they have numbers
    other than 2 in the denominator (after prime factorization):'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 其他分数无法精确表示，因为分母中有2以外的数字（经过质因数分解）：
- en: 0.1[dec] = ![](inleq_1109.png) = ![](inleq_1110.png)
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.1[dec] = ![](inleq_1109.png) = ![](inleq_1110.png)
- en: 0.2[dec] = ![](inleq_1111.png) = ![](inleq_1112.png)
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.2[dec] = ![](inleq_1111.png) = ![](inleq_1112.png)
- en: 'You can’t normally see that JavaScript doesn’t store exactly 0.1 internally.
    But you can make it visible by multiplying it with a high enough power of 10:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 通常看不到JavaScript内部并未精确存储0.1。但是，通过将其乘以足够高的10的幂，可以使其可见：
- en: '[PRE207]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'And if you add two imprecisely represented numbers, the result is sometimes
    imprecise enough that the imprecision becomes visible:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将两个不精确表示的数字相加，结果有时会不精确到足以使不精确性变得可见：
- en: '[PRE208]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Another example:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子：
- en: '[PRE209]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Due to rounding errors, as a best practice you should not compare nonintegers
    directly. Instead, take an upper bound for rounding errors into consideration.
    Such an upper bound is called a [*machine epsilon*](http://en.wikipedia.org/wiki/Machine_epsilon).
    The standard epsilon value for double precision is 2^(−53):'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 由于舍入误差，最好的做法是不直接比较非整数。而是考虑舍入误差的上限。这样的上限称为[*机器epsilon*](http://en.wikipedia.org/wiki/Machine_epsilon)。双精度标准epsilon值为2^(−53)：
- en: '[PRE210]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '`epsEqu()` ensures correct results where a normal comparison would be inadequate:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '`epsEqu()`确保正确的结果，普通比较会不足以满足要求：'
- en: '[PRE211]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Integers in JavaScript
  id: totrans-948
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript中的整数
- en: As mentioned before, JavaScript has only floating-point numbers. Integers appear
    internally in two ways. First, most JavaScript engines store a small enough number
    without a decimal fraction as an integer (with, for example, 31 bits) and maintain
    that representation as long as possible. They have to switch back to a floating-point
    representation if a number’s magnitude grows too large or if a decimal fraction
    appears.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JavaScript只有浮点数。整数在内部以两种方式出现。首先，大多数JavaScript引擎将足够小的没有小数部分的数字存储为整数（例如，31位），并尽可能长时间地保持该表示。如果数字的大小增长太大或出现小数部分，则必须切换回浮点表示。
- en: 'Second, the ECMAScript specification has integer operators: namely, all of
    the bitwise operators. Those operators convert their operands to 32-bit integers
    and return 32-bit integers. For the specification, *integer* only means that the
    numbers don’t have a decimal fraction, and *32-bit* means that they are within
    a certain range. For engines, *32-bit integer* means that an actual integer (non-floating-point)
    representation can usually be introduced or maintained.'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，ECMAScript规范具有整数运算符：即所有按位运算符。这些运算符将其操作数转换为32位整数并返回32位整数。对于规范，*整数*只意味着数字没有小数部分，*32位*意味着它们在某个范围内。对于引擎，*32位整数*意味着通常可以引入或保持实际整数（非浮点）表示。
- en: Ranges of Integers
  id: totrans-951
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数范围
- en: 'Internally, the following ranges of integers are important in JavaScript:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，以下整数范围很重要：
- en: 'Safe integers (see [Safe Integers](ch11.html#safe_integers "Safe Integers")),
    the largest practically usable range of integers that JavaScript supports:'
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全整数（参见[安全整数](ch11.html#safe_integers "安全整数")），JavaScript支持的最大实用整数范围：
- en: 53 bits plus a sign, range (−2^(53), 2^(53))
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 53位加上一个符号，范围（−2^(53), 2^(53)）
- en: 'Array indices (see [Array Indices](ch18.html#array_indices "Array Indices")):'
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组索引（参见[数组索引](ch18.html#array_indices "数组索引")）：
- en: 32 bits, unsigned
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位，无符号
- en: 'Maximum length: 2^(32)−1'
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大长度：2^(32)−1
- en: 'Range of indices: [0, 2^(32)−1) (excluding the maximum length!)'
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引范围：[0, 2^(32)−1)（不包括最大长度！）
- en: 'Bitwise operands (see [Bitwise Operators](ch11.html#bitwise_operators "Bitwise
    Operators")):'
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位操作数（参见[按位运算符](ch11.html#bitwise_operators "按位运算符")）：
- en: 'Unsigned right shift operator (`>>>`): 32 bits, unsigned, range [0, 2^(32))'
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无符号右移运算符(`>>>`)：32位，无符号，范围[0, 2^(32))
- en: 'All other bitwise operators: 32 bits, including a sign, range [−2^(31), 2^(31))'
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他按位运算符：32位，包括符号，范围[−2^(31), 2^(31)]
- en: '“Char codes,” UTF-16 code units as numbers:'
  id: totrans-962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “字符代码”，UTF-16代码单元作为数字：
- en: Accepted by `String.fromCharCode()` (see [String Constructor Method](ch12.html#String.fromCharCode
    "String Constructor Method"))
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被`String.fromCharCode()`接受（参见[字符串构造方法](ch12.html#String.fromCharCode "字符串构造方法")）
- en: Returned by `String.prototype.charCodeAt()` (see [Extract Substrings](ch12.html#String.prototype.charCodeAt
    "Extract Substrings"))
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由`String.prototype.charCodeAt()`返回（参见[提取子字符串](ch12.html#String.prototype.charCodeAt
    "提取子字符串")）
- en: 16 bits, unsigned
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位，无符号
- en: Representing Integers as Floating-Point Numbers
  id: totrans-966
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将整数表示为浮点数
- en: JavaScript can only handle integer values up to a magnitude of 53 bits (the
    52 bits of the fraction plus 1 indirect bit, via the exponent; see [The Internal
    Representation of Numbers](ch11.html#number_representation "The Internal Representation
    of Numbers") for details).
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript只能处理最大为53位的整数值（52位的小数部分加上1个间接位，通过指数; 有关详细信息，请参见[数字的内部表示](ch11.html#number_representation
    "数字的内部表示")）。
- en: 'The following table explains how JavaScript represents 53-bit integers as floating-point
    numbers:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了JavaScript如何将53位整数表示为浮点数：
- en: '| Bits | Range | Encoding |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
  zh: '| 位 | 范围 | 编码 |'
- en: '| --- | --- | --- |'
  id: totrans-970
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 bit | 0 | (See [The Internal Representation of Numbers](ch11.html#number_representation
    "The Internal Representation of Numbers").) |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
  zh: '| 1位 | 0 | (参见[数字的内部表示](ch11.html#number_representation "数字的内部表示")) |'
- en: '| 1 bit | 1 | %1 × 2⁰ |'
  id: totrans-972
  prefs: []
  type: TYPE_TB
  zh: '| 1位 | 1 | %1 × 2⁰ |'
- en: '| 2 bits | 2–3 | %1.f[51] × 2¹ |'
  id: totrans-973
  prefs: []
  type: TYPE_TB
  zh: '| 2位 | 2–3 | %1.f[51] × 2¹ |'
- en: '| 3 bits | 4–7 = 2²–(2³−1) | %1.f[51]f[50] × 2² |'
  id: totrans-974
  prefs: []
  type: TYPE_TB
  zh: '| 3位 | 4–7 = 2²–(2³−1) | %1.f[51]f[50] × 2² |'
- en: '| 4 bits | 2³–(2⁴−1) | %1.f[51]f[50]f[49] × 2³ |'
  id: totrans-975
  prefs: []
  type: TYPE_TB
  zh: '| 4位 | 2³–(2⁴−1) | %1.f[51]f[50]f[49] × 2³ |'
- en: '| ⋯ | ⋯ | ⋯ |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
  zh: '| ⋯ | ⋯ | ⋯ |'
- en: '| 53 bits | 2^(52)–(2^(53)−1) | %1.f[51]⋯f[0] × 2^(52) |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
  zh: '| 53位 | 2^(52)–(2^(53)−1) | %1.f[51]⋯f[0] × 2^(52) |'
- en: 'There is no fixed sequence of bits that represents the integer. Instead, the
    mantissa %1.f is shifted by the exponent, so that the leading digit 1 is in the
    right place. In a way, the exponent counts the number of digits of the fraction
    that are in active use (the remaining digits are 0). That means that for 2 bits,
    we use one digit of the fraction and for 53 bits, we use all digits of the fraction.
    Additionally, we can represent 2^(53) as %1.0 × 2^(53), but we get problems with
    higher numbers:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 没有固定的位序列表示整数。相反，尾数%1.f被指数移位，以便领先的数字1位于正确的位置。在某种程度上，指数计算出分数中活跃使用的数字的数量（其余数字为0）。这意味着对于2位，我们使用分数的一位数字，对于53位，我们使用分数的所有数字。此外，我们可以将2^(53)表示为%1.0
    × 2^(53)，但是对于更高的数字，我们会遇到问题：
- en: '| Bits | Range | Encoding |'
  id: totrans-979
  prefs: []
  type: TYPE_TB
  zh: '| 位 | 范围 | 编码 |'
- en: '| --- | --- | --- |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 54 bits | 2^(53)–(2^(54)−1) | %1.f[51]⋯f[0]0 × 2^(53) |'
  id: totrans-981
  prefs: []
  type: TYPE_TB
  zh: '| 54位 | 2^(53)–(2^(54)−1) | %1.f[51]⋯f[0]0 × 2^(53) |'
- en: '| 55 bits | 2^(54)–(2^(55)−1) | %1.f[51]⋯f[0]00 × 2^(54) |'
  id: totrans-982
  prefs: []
  type: TYPE_TB
  zh: '| 55位 | 2^(54)–(2^(55)−1) | %1.f[51]⋯f[0]00 × 2^(54) |'
- en: '| ⋯ |  |  |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
  zh: '| ⋯ |  |  |'
- en: 'For 54 bits, the least significant digit is always 0, for 55 bits the two least
    significant digits are always 0, and so on. That means that for 54 bits, we can
    only represent every second number, for 55 bits only every fourth number, and
    so on. For example:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 对于54位，最低有效位始终为0，对于55位，最低的两位始终为0，依此类推。这意味着对于54位，我们只能表示每第二个数字，对于55位，只能表示每第四个数字，依此类推。例如：
- en: '[PRE212]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Best practice
  id: totrans-986
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最佳实践
- en: If you work with integers of up to 53 bits magnitude, you are fine. Unfortunately,
    you’ll often encounter 64-bit unsigned integers in programming (Twitter IDs, databases,
    etc.). These must be stored in strings in JavaScript. If you want to perform arithmetic
    with such integers, you need special libraries. There are plans to bring larger
    integers to JavaScript, but that will take a while.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的整数的大小不超过53位，那么就没问题。不幸的是，在编程中经常会遇到64位无符号整数（Twitter ID、数据库等）。这些必须以字符串形式存储在JavaScript中。如果要对这样的整数执行算术运算，就需要特殊的库。有计划将更大的整数引入JavaScript，但这需要一些时间。
- en: Safe Integers
  id: totrans-988
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全整数
- en: JavaScript can only safely represent integers *i* in the range −2^(53) < *i*
    < 2^(53). This section examines what that means and what the consequences are.
    It is based on an [email by Mark S. Miller to the es-discuss mailing list](http://mzl.la/1oOaCOO).
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript只能安全地表示范围在−2^(53) < i < 2^(53)的整数。本节将探讨这意味着什么以及其后果。它基于Mark S. Miller发送给es-discuss邮件列表的一封邮件。
- en: 'The idea of a safe integer centers on how mathematical integers are represented
    in JavaScript. In the range (−2^(53), 2^(53)) (excluding the lower and upper bounds),
    JavaScript integers are *safe*: there is a one-to-one mapping between mathematical
    integers and their representations in JavaScript.'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 安全整数的概念集中在JavaScript中如何表示数学整数上。在范围(−2^(53), 2^(53))（不包括下限和上限）内，JavaScript整数是*安全*的：数学整数与它们在JavaScript中的表示之间存在一对一的映射。
- en: 'Beyond this range, JavaScript integers are *unsafe*: two or more mathematical
    integers are represented as the same JavaScript integer. For example, starting
    at 2^(53), JavaScript can represent only every second mathematical integer (the
    previous section explains why). Therefore, a safe JavaScript integer is one that
    unambiguously represents a single mathematical integer.'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 超出此范围后，JavaScript整数是*不安全*的：两个或更多数学整数被表示为相同的JavaScript整数。例如，从2^(53)开始，JavaScript只能表示每第二个数学整数（前一节解释了原因）。因此，安全的JavaScript整数是可以明确表示单个数学整数的整数。
- en: Definitions in ECMAScript 6
  id: totrans-992
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ECMAScript 6中的定义
- en: 'ECMAScript 6 will provide the following constants:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6将提供以下常量：
- en: '[PRE213]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'It will also provide a function for determining whether an integer is safe:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将提供一个用于确定整数是否安全的函数：
- en: '[PRE214]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: For a given value `n`, this function first checks whether `n` is a number and
    an integer. If both checks succeed, `n` is safe if it is greater than or equal
    to `MIN_SAFE_INTEGER` and less than or equal to `MAX_SAFE_INTEGER`.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定值`n`，此函数首先检查`n`是否为数字和整数。如果两个检查都成功，则如果`n`大于或等于`MIN_SAFE_INTEGER`且小于或等于`MAX_SAFE_INTEGER`，则`n`是安全的。
- en: Safe results of arithmetic computations
  id: totrans-998
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 算术计算的安全结果
- en: 'How can we make sure that results of arithmetic computations are correct? For
    example, the following result is clearly not correct:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保算术计算的结果是正确的？例如，以下结果显然是不正确的：
- en: '[PRE215]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'We have two safe operands, but an unsafe result:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个安全的操作数，但是一个不安全的结果：
- en: '[PRE216]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'The following result is also incorrect:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果也是不正确的：
- en: '[PRE217]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'This time, the result is safe, but one of the operands isn’t:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 这次结果是安全的，但其中一个操作数不是：
- en: '[PRE218]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Therefore, the result of applying an integer operator `op` is guaranteed to
    be correct only if all operands and the result are safe. More formally:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只有当所有操作数和结果都是安全的时，才能保证应用整数运算符`op`的结果是正确的。更正式地说：
- en: '[PRE219]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: implies that `a op b` is a correct result.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着`a op b`是正确的结果。
- en: Converting to Integer
  id: totrans-1010
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为整数
- en: 'In JavaScript, all numbers are floating point. Integers are floating-point
    numbers without a fraction. Converting a number `n` to an integer means finding
    the integer that is “closest” to `n` (where the meaning of “closest” depends on
    how you convert). You have several options for performing this conversion:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，所有数字都是浮点数。整数是没有小数部分的浮点数。将数字`n`转换为整数意味着找到与`n`“最接近”的整数（“最接近”的含义取决于如何进行转换）。您有几种选项可以执行此转换：
- en: The `Math` functions `Math.floor()`, `Math.ceil()`, and `Math.round()` (see
    [Integers via Math.floor(), Math.ceil(), and Math.round()](ch11.html#integers_via_math
    "Integers via Math.floor(), Math.ceil(), and Math.round()"))
  id: totrans-1012
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Math`函数`Math.floor()`、`Math.ceil()`和`Math.round()`（参见[Integers via Math.floor(),
    Math.ceil(), and Math.round()](ch11.html#integers_via_math "Integers via Math.floor(),
    Math.ceil(), and Math.round()")）'
- en: The custom function `ToInteger()` (see [Integers via the Custom Function ToInteger()](ch11.html#ToInteger
    "Integers via the Custom Function ToInteger()"))
  id: totrans-1013
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义函数`ToInteger()`（参见[Integers via the Custom Function ToInteger()](ch11.html#ToInteger
    "Integers via the Custom Function ToInteger()")）
- en: Binary bitwise operators (see [32-bit Integers via Bitwise Operators](ch11.html#integers_via_bitwise_operators
    "32-bit Integers via Bitwise Operators"))
  id: totrans-1014
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制位运算符（参见[通过位运算符实现32位整数](ch11.html#integers_via_bitwise_operators "通过位运算符实现32位整数"））
- en: The global function `parseInt()` (see [Integers via parseInt()](ch11.html#parseInt
    "Integers via parseInt()"))
  id: totrans-1015
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局函数`parseInt()`（参见[通过parseInt()实现整数](ch11.html#parseInt "通过parseInt()实现整数"））
- en: 'Spoiler: #1 is usually the best choice, #2 and #3 have niche applications,
    and #4 is OK for parsing strings, but not for converting numbers to integers.'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 结论：#1通常是最佳选择，#2和#3有特定应用，#4适用于解析字符串，但不适用于将数字转换为整数。
- en: Integers via Math.floor(), Math.ceil(), and Math.round()
  id: totrans-1017
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过Math.floor()、Math.ceil()和Math.round()实现整数
- en: 'The following three functions are usually the best way of converting a number
    to an integer:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个函数通常是将数字转换为整数的最佳方式：
- en: '`Math.floor()` converts its argument to the closest lower integer:'
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.floor()`将其参数转换为最接近的较低整数：'
- en: '[PRE220]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '`Math.ceil()` converts its argument to the closest higher integer:'
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.ceil()`将其参数转换为最接近的更高整数：'
- en: '[PRE221]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '`Math.round()` converts its argument to the closest integer:'
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.round()`将其参数转换为最接近的整数：'
- en: '[PRE222]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'The result of rounding `-3.5` may be surprising:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 四舍五入`-3.5`的结果可能会让人惊讶：
- en: '[PRE223]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Therefore, `Math.round(x)` is the same as:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Math.round(x)`与以下相同：
- en: '[PRE224]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Integers via the Custom Function ToInteger()
  id: totrans-1029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过自定义函数ToInteger()实现整数
- en: 'Another good option for converting any value to an integer is the internal
    ECMAScript operation `ToInteger()`, which removes the fraction of a floating-point
    number. If it was accessible in JavaScript, it would work like this:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何值转换为整数的另一个好选择是内部ECMAScript操作`ToInteger()`，它去除了浮点数的小数部分。如果它在JavaScript中可用，它将像这样工作：
- en: '[PRE225]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'The ECMAScript specification defines the result of `ToInteger(number)` as:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript规范将`ToInteger(number)`的结果定义为：
- en: sign(number) × floor(abs(number))
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: sign(number) × floor(abs(number))
- en: 'For what it does, this formula is relatively complicated because `floor` seeks
    the closest *larger* integer; if you want to remove the fraction of a negative
    integer, you have to seek the closest smaller integer. The following code implements
    the operation in JavaScript. We avoid the `sign` operation by using `ceil` if
    the number is negative:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式相对复杂，因为`floor`寻找最接近的*大*整数；如果你想去掉负整数的小数部分，你必须寻找最接近的小整数。以下代码在JavaScript中实现了这个操作。如果数字是负数，我们避免使用`sign`操作，而是使用`ceil`：
- en: '[PRE226]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 32-bit Integers via Bitwise Operators
  id: totrans-1036
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过位运算符实现32位整数
- en: Binary bitwise operators (see [Binary Bitwise Operators](ch11.html#binary_bitwise_operators
    "Binary Bitwise Operators")) convert (at least) one of their operands to a 32-bit
    integer that is then manipulated to produce a result that is also a 32-bit integer.
    Therefore, if you choose the other operand appropriately, you get a fast way to
    convert an arbitrary number to a 32-bit integer (that is either signed or unsigned).
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制位运算符（参见[二进制位运算符](ch11.html#binary_bitwise_operators "二进制位运算符"）将（至少）一个操作数转换为32位整数，然后对其进行操作以产生也是32位整数的结果。因此，如果你适当选择另一个操作数，你可以快速地将任意数字转换为32位整数（有符号或无符号）。
- en: Bitwise Or (|)
  id: totrans-1038
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按位或（|)
- en: 'If the mask, the second operand, is 0, you don’t change any bits and the result
    is the first operand, coerced to a signed 32-bit integer. This is the canonical
    way to execute this kind of coercion and is used, for example, by asm.js (refer
    back to [Is JavaScript Fast Enough?](ch02.html#asm.js "Is JavaScript Fast Enough?")):'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 如果掩码，第二个操作数，为0，则不改变任何位，结果是第一个操作数，强制转换为有符号32位整数。这是执行这种强制转换的规范方式，例如，asm.js（参见[JavaScript足够快吗？](ch02.html#asm.js
    "JavaScript足够快吗？"））中使用：
- en: '[PRE227]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '`ToInt32()` removes the fraction and applies modulo 2^(32):'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToInt32()`去除小数并应用模2^(32)：'
- en: '[PRE228]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Shift operators
  id: totrans-1043
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移位运算符
- en: 'The same trick that worked for bitwise Or also works for shift operators: if
    you shift by zero bits, the result of a shift operation is the first operand,
    coerced to a 32-bit integer. Here are some examples of implementing operations
    of the ECMAScript specification via shift operators:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 对移位运算符也适用与按位或相同的技巧：如果你移动零位，移位操作的结果是第一个操作数，强制转换为32位整数。以下是通过移位运算符实现ECMAScript规范操作的一些示例：
- en: '[PRE229]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'Here is `ToUint32()` in action:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ToUint32()`的实际操作：
- en: '[PRE230]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Should I use bitwise operators to coerce to integer?
  id: totrans-1048
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我应该使用位运算符强制转换为整数吗？
- en: You have to decide for yourself if the slight increase in efficiency is worth
    your code being harder to understand. Also note that bitwise operators artificially
    limit themselves to 32 bits, which is often neither necessary nor useful. Using
    one of the `Math` functions, possibly in addition to `Math.abs()`, is a more self-explanatory
    and arguably better choice.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须自己决定，稍微提高效率是否值得让你的代码更难理解。另外要注意，位运算符人为地限制自己在32位，这通常既不必要也不实用。使用`Math`函数之一，可能还加上`Math.abs()`，是一个更易于理解且可能更好的选择。
- en: Integers via parseInt()
  id: totrans-1050
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过parseInt()实现整数
- en: 'The `parseInt()` function:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt()`函数：'
- en: '[PRE231]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: parses the string `str` (nonstrings are coerced) as an integer. The function
    ignores leading whitespace and considers as many consecutive legal digits as it
    can find.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 解析字符串`str`（非字符串被强制转换）为整数。该函数忽略前导空格，并考虑尽可能多的连续合法数字。
- en: The radix
  id: totrans-1054
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基数
- en: The range of the radix is 2 ≤ `radix` ≤ 36. It determines the base of the number
    to be parsed. If the radix is greater than 10, letters are used as digits (case-insensitively),
    in addition to 0–9.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 基数的范围是2 ≤ `radix` ≤ 36。它确定要解析的数字的基数。如果基数大于10，则除了0-9，还使用字母作为数字（不区分大小写）。
- en: 'If `radix` is missing, then it is assumed to be 10, except if `str` begins
    with “0x” or “0X,” in which case `radix` is set to 16 (hexadecimal):'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`radix`缺失，则假定为10，除非`str`以“0x”或“0X”开头，此时`radix`设置为16（十六进制）：
- en: '[PRE232]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'If `radix` is already 16, then the hexadecimal prefix is optional:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`radix`已经是16，则十六进制前缀是可选的：
- en: '[PRE233]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'So far I have described the behavior of `parseInt()` according to the ECMAScript
    specification. Additionally, some engines set the radix to 8 if `str` starts with
    a zero:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经描述了`parseInt()`的行为，符合ECMAScript规范。此外，一些引擎如果`str`以零开头，则将基数设置为8：
- en: '[PRE234]'
  id: totrans-1061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Thus, it is best to always explicitly state the radix, to always call `parseInt()`
    with two arguments.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好总是明确指定基数，始终使用两个参数调用`parseInt()`。
- en: 'Here are a few examples:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些例子：
- en: '[PRE235]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Don’t use `parseInt()` to convert a number to an integer. The last example
    gives us hope that we might be able to use `parseInt()` for converting numbers
    to integers. Alas, here is an example where the conversion is incorrect:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`parseInt()`将数字转换为整数。最后一个例子让我们希望我们可以使用`parseInt()`将数字转换为整数。然而，这里有一个转换不正确的例子：
- en: '[PRE236]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Explanation
  id: totrans-1067
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解释
- en: 'The argument is first converted to a string:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将参数转换为字符串：
- en: '[PRE237]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '`parseInt` doesn’t consider “e” to be an integer digit and thus stops parsing
    after the 1\. Here’s another example:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt`不认为“e”是一个整数数字，因此在1之后停止解析。这里是另一个例子：'
- en: '[PRE238]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Summary
  id: totrans-1072
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 总结
- en: '`parseInt()` shouldn’t be used to convert numbers to integers: coercion to
    string is an unnecessary detour and even then, the result is not always correct.'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt()`不应该用于将数字转换为整数：强制转换为字符串是一个不必要的绕道，即使这样，结果也不总是正确的。'
- en: '`parseInt()` *is* useful for parsing strings, but you have to be aware that
    it stops at the first illegal digit. Parsing strings via `Number()` (see [The
    Function Number](ch11.html#function_number "The Function Number")) is less forgiving,
    but may produce nonintegers.'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt()`用于解析字符串很有用，但你必须意识到它会在第一个非法数字处停止。通过`Number()`（参见[函数Number](ch11.html#function_number
    "函数Number"））解析字符串不太宽容，但可能会产生非整数。'
- en: Arithmetic Operators
  id: totrans-1075
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: 'The following operators are available for numbers:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 以下运算符适用于数字：
- en: '`number1 + number2`'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '`number1 + number2`'
- en: 'Numerical addition, unless either of the operands is a string. Then both operands
    are converted to strings and concatenated (see [The Plus Operator (+)](ch09.html#plus_operator
    "The Plus Operator (+)")):'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 数值相加，除非其中一个操作数是字符串。然后两个操作数都会被转换为字符串并连接在一起（参见[加号运算符（+）](ch09.html#plus_operator
    "加号运算符（+）"））：
- en: '[PRE239]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '`number1 - number2`'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '`number1 - number2`'
- en: Subtraction.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 减法。
- en: '`number1 * number2`'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '`number1 * number2`'
- en: Multiplication.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法。
- en: '`number1 / number2`'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '`number1 / number2`'
- en: Division.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 除法。
- en: '`number1 % number2`'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '`number1 % number2`'
- en: 'Remainder:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 余数：
- en: '[PRE240]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: Warning
  id: totrans-1089
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: This operation is not modulo. It returns a value whose sign is the same as the
    first operand (more details in a moment).
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作不是模运算。它返回一个与第一个操作数相同符号的值（稍后会有更多细节）。
- en: '`-number`'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '`-number`'
- en: Negates its argument.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 否定其参数。
- en: '`+number`'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '`+number`'
- en: Leaves its argument as is; nonnumbers are converted to a number.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 将其参数保持不变；非数字被转换为数字。
- en: '`++variable`, `--variable`'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '`++variable`, `--variable`'
- en: 'Returns the current value of the variable after incrementing (or decrementing)
    it by 1:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 在增加（或减少）1之后返回变量的当前值：
- en: '[PRE241]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '`variable++`, `variable--`'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '`variable++`, `variable--`'
- en: 'Increments (or decrements) the value of the variable by 1 and returns it:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 通过1来增加（或减少）变量的值并返回它：
- en: '[PRE242]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Mnemonic: increment (++) and decrement (--) operators'
  id: totrans-1101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 助记符：增量（++）和减量（--）运算符
- en: The position of the operand can help you remember whether it is returned before
    or after incrementing (or decrementing) it. If the operand comes before the increment
    operator, it is returned before incrementing it. If the operand comes after the
    operator, it is incremented and then returned. (The decrement operator works similarly.)
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数的位置可以帮助你记住它是在增加（或减少）之前还是之后返回的。如果操作数在增加运算符之前，它在增加之前返回。如果操作数在运算符之后，它会增加然后返回。（减量运算符的工作方式类似。）
- en: 'Pitfall: The Remainder Operator (%) Is Not Modulo'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 陷阱：余数运算符（%）不是模运算
- en: 'The result of the remainder operator always has the sign of the first operand
    (for modulo, it is the sign of the second operand):'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 余数运算符的结果始终具有第一个操作数的符号（对于模运算，它是第二个操作数的符号）：
- en: '[PRE243]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'That means that the following function does not work:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下函数不起作用：
- en: '[PRE244]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'The correct version is:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的版本是：
- en: '[PRE245]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Bitwise Operators
  id: totrans-1110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位运算符
- en: JavaScript has several bitwise operators that work with 32-bit integers. That
    is, they convert their operands to 32-bit integers and produce a result that is
    a 32-bit integer. Use cases for these operators include processing binary protocols,
    special algorithms, etc.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有几个位运算符，可以处理32位整数。也就是说，它们将操作数转换为32位整数，并产生一个32位整数的结果。这些运算符的用例包括处理二进制协议、特殊算法等。
- en: Background Knowledge
  id: totrans-1112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景知识
- en: This section explains a few concepts that will help you understand bitwise operators.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了一些概念，这些概念将帮助你理解位运算符。
- en: Binary complements
  id: totrans-1114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二进制补码
- en: 'Two common ways of computing a binary complement (or inverse) of a binary number
    are:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 计算二进制补码（或反码）的两种常见方法是：
- en: Ones’ complement
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 补码
- en: 'You compute the ones’ complement `~x` of a number `x` by inverting each of
    the 32 digits. Let’s illustrate the ones’ complement via four-digit numbers. The
    ones’ complement of `1100` is `0011`. Adding a number to its ones’ complement
    results in a number whose digits are all 1:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反转32位数字来计算数字`x`的补码`~x`。让我们通过四位数字来说明补码。`1100`的补码是`0011`。将一个数字加上它的补码会得到一个所有数字都是1的数字：
- en: '[PRE246]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Twos’ complement
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制补码
- en: 'The twos’ complement `-x` of a number `x` is the ones’ complement plus one.
    Adding a number to its twos’ complement results in `0` (ignoring overflow beyond
    the most significant digit). Here’s an example using four-digit numbers:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 数字`x`的二进制补码`-x`是补码加一。将一个数字加上它的二进制补码会得到`0`（忽略最高位之外的溢出）。以下是一个使用四位数字的例子：
- en: '[PRE247]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Signed 32-bit integers
  id: totrans-1122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 有符号的32位整数
- en: '32-bit integers don’t have an explicit sign, but you can still encode negative
    numbers. For example, −1 can be encoded as the twos’ complement of 1: adding 1
    to the result yields 0 (within 32 bits). The boundary between positive and negative
    numbers is fluid; 4294967295 (2^(32)−1) and −1 are the same integer here. But
    you have to decide on a sign when you convert such an integer from or to a JavaScript
    number, which has an explicit sign as opposed to an implicit one. Therefore, *signed
    32-bit integers* are partitioned into two groups:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 32位整数没有显式的符号，但你仍然可以编码负数。例如，-1可以编码为1的补码：将结果加1得到0（在32位内）。正数和负数之间的边界是流动的；4294967295（2^(32)−1）和-1在这里是相同的整数。但是，当你将这样的整数从JavaScript数字转换到JavaScript数字时，你必须决定一个符号，这个符号与隐式符号相对。因此，*有符号的32位整数*被分成两组：
- en: 'Highest bit is 0: number is zero or positive.'
  id: totrans-1124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高位为0：数字为零或正数。
- en: 'Highest bit is 1: number is negative.'
  id: totrans-1125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高位为1：数字为负数。
- en: 'The highest bit is often called the *sign bit*. Accordingly, 4294967295, interpreted
    as a signed 32-bit integer, becomes −1 when converted to a JavaScript number:'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 最高位通常称为*符号位*。因此，4294967295，解释为有符号32位整数，当转换为JavaScript数字时变为-1：
- en: '[PRE248]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '`ToInt32()` is explained in [32-bit Integers via Bitwise Operators](ch11.html#integers_via_bitwise_operators
    "32-bit Integers via Bitwise Operators").'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToInt32()`在[通过按位操作获取32位整数](ch11.html#integers_via_bitwise_operators "32-bit
    Integers via Bitwise Operators")中有解释。'
- en: Note
  id: totrans-1129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Only the unsigned right shift operator (`>>>`) works with unsigned 32-bit integers;
    all other bitwise operators work with signed 32-bit integers.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 只有无符号右移操作符（`>>>`）适用于无符号32位整数；所有其他按位操作符适用于有符号32位整数。
- en: Inputting and outputting binary numbers
  id: totrans-1131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入和输出二进制数
- en: 'In the following examples, we work with binary numbers via the following two
    operations:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们通过以下两个操作使用二进制数：
- en: '`parseInt(str, 2)` (see [Integers via parseInt()](ch11.html#parseInt "Integers
    via parseInt()")) parses a string `str` in binary notation (base 2). For example:'
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseInt(str, 2)`（参见[通过parseInt()获取整数](ch11.html#parseInt "Integers via parseInt()"））解析二进制表示法（基数为2）的字符串`str`。例如：'
- en: '[PRE249]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '`num.toString(2)` (see [Number.prototype.toString(radix?)](ch11.html#Number.prototype.toString
    "Number.prototype.toString(radix?)")) converts the number `num` to a string in
    binary notation. For example:'
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num.toString(2)`（参见[Number.prototype.toString(radix?)](ch11.html#Number.prototype.toString
    "Number.prototype.toString(radix?)"）将数字`num`转换为二进制表示的字符串。例如：'
- en: '[PRE250]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Bitwise Not Operator
  id: totrans-1137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按位非操作符
- en: '`~number` computes the ones’ complement of `number`:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '`~number`计算`number`的补码：'
- en: '[PRE251]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Binary Bitwise Operators
  id: totrans-1140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制按位操作符
- en: 'JavaScript has three binary bitwise operators:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有三个二进制按位操作符：
- en: '`number1 & number2` (bitwise And):'
  id: totrans-1142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number1 & number2`（按位与）：'
- en: '[PRE252]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '`number1 | number2` (bitwise Or):'
  id: totrans-1144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number1 | number2`（按位或）：'
- en: '[PRE253]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '`number1 ^ number2` (bitwise Xor; eXclusive Or):'
  id: totrans-1146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number1 ^ number2`（按位异或）：'
- en: '[PRE254]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'There are two ways to intuitively understand binary bitwise operators:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 直观理解二进制按位操作符有两种方式：
- en: One boolean operation per bit
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 每位一个布尔操作。
- en: 'In the following formulas, `n[i]` means bit `i` of number `n` interpreted as
    a boolean (0 is `false`, 1 is `true`). For example, `2[0]` is `false`; `2[1]`
    is `true`:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下公式中，`n[i]`表示将数字`n`的第`i`位解释为布尔值（0为`false`，1为`true`）。例如，`2[0]`为`false`；`2[1]`为`true`：
- en: 'And: `result[i] = number1[i] && number2[i]`'
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: And：`result[i] = number1[i] && number2[i]`
- en: 'Or: `result[i] = number1[i] || number2[i]`'
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或：`result[i] = number1[i] || number2[i]`
- en: 'Xor: `result[i] = number1[i] ^^ number2[i]`'
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xor：`result[i] = number1[i] ^^ number2[i]`
- en: 'The operator `^^` does not exist. If it did, it would work like this (the result
    is `true` if exactly one of the operands is `true`):'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符`^^`不存在。如果存在，它将按照以下方式工作（如果操作数中恰好有一个为`true`，则结果为`true`）：
- en: '[PRE255]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Changing bits of `number1` via `number2`
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`number2`改变`number1`的位
- en: 'And: Keeps only those bits of `number1` that are set in `number2`. This operation
    is also called *masking*, with `number2` being the *mask*.'
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: And：仅保留`number1`中设置的那些位。这个操作也被称为*掩码*，`number2`是*掩码*。
- en: 'Or: Sets all bits of `number1` that are set in `number2` and keeps all other
    bits unchanged.'
  id: totrans-1158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或：设置`number1`中设置的所有位，并保持所有其他位不变。
- en: 'Xor: Inverts all bits of `number1` that are set in `number2` and keeps all
    other bits unchanged.'
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xor：反转`number1`中设置的所有位，并保持所有其他位不变。
- en: Bitwise Shift Operators
  id: totrans-1160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按位移动操作符
- en: 'JavaScript has three bitwise shift operators:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有三个按位移动操作符：
- en: '`number << digitCount` (left shift):'
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number << digitCount`（左移）：'
- en: '[PRE256]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '`number >> digitCount` (signed right shift):'
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number >> digitCount`（有符号右移）：'
- en: 'The 32-bit binary number is interpreted as signed (see the preceding section).
    When shifting right, the sign is preserved:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 32位二进制数被解释为有符号数（参见前面的部分）。向右移动时，符号被保留：
- en: '[PRE257]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: We have right-shifted –2\. The result, –1, is equivalent to a 32-bit integer
    whose digits are all 1 (the twos’ complement of 1). In other words, a signed right
    shift by one digit divides both negative and positive integers by two.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经右移了-2。结果-1等同于一个32位整数，其所有数字都是1（1的补码）。换句话说，向右移动一个数字，负数和正数都会除以2。
- en: 'number >>> digitCount` (unsigned right shift):'
  id: totrans-1168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number >>> digitCount`（无符号右移）：'
- en: '[PRE258]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: As you can see, this operator shifts in zeros from the left.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个操作符从左边补零。
- en: The Function Number
  id: totrans-1171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数数字
- en: 'The function `Number` can be invoked in two ways:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number`函数可以以两种方式调用：'
- en: '`Number(value)`'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number(value)`'
- en: 'As a normal function, it converts `value` to a primitive number (see [Converting
    to Number](ch11.html#tonumber "Converting to Number")):'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为普通函数，它将`value`转换为原始数字（参见[转换为数字](ch11.html#tonumber "Converting to Number"））：
- en: '[PRE259]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '`new Number(num)`'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Number(num)`'
- en: 'As a constructor, it creates a new instance of `Number` (see [Wrapper Objects
    for Primitives](ch08.html#wrapper_objects "Wrapper Objects for Primitives")),
    an object that wraps `num` (after converting it to a number). For example:'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 作为构造函数，它创建一个`Number`的新实例（参见[原始值的包装对象](ch08.html#wrapper_objects "Wrapper Objects
    for Primitives"）），一个将`num`（在转换为数字后）包装的对象。例如：
- en: '[PRE260]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: The former invocation is the common one.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 前一种调用是常见的。
- en: Number Constructor Properties
  id: totrans-1180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字构造函数属性
- en: 'The object `Number` has the following properties:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`Number`具有以下属性：
- en: '`Number.MAX_VALUE`'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.MAX_VALUE`'
- en: 'The largest positive number that can be represented. Internally, all digits
    of its fraction are ones and the exponent is maximal, at 1023\. If you try to
    increment the exponent by multiplying it by two, the result is the error value
    `Infinity` (see [Infinity](ch11.html#infinity "Infinity")):'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 可以表示的最大正数。在内部，其分数的所有数字都是1，指数是最大的，为1023。如果尝试通过将指数乘以2来增加指数，结果将是错误值`Infinity`（参见[Infinity](ch11.html#infinity
    "Infinity")）：
- en: '[PRE261]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '`Number.MIN_VALUE`'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.MIN_VALUE`'
- en: 'The smallest representable positive number (greater than zero, a tiny fraction):'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的可表示正数（大于零，一个微小的分数）：
- en: '[PRE262]'
  id: totrans-1187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '`Number.NaN`'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.NaN`'
- en: The same value as the global `NaN`.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 与全局`NaN`相同的值。
- en: '`Number.NEGATIVE_INFINITY`'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.NEGATIVE_INFINITY`'
- en: 'The same value as `-Infinity`:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 与“-无穷大”相同的值：
- en: '[PRE263]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '`Number.POSITIVE_INFINITY`'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.POSITIVE_INFINITY`'
- en: 'The same value as `Infinity`:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Infinity`相同的值：
- en: '[PRE264]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Number Prototype Methods
  id: totrans-1196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字原型方法
- en: All methods of primitive numbers are stored in `Number.prototype` (see [Primitives
    Borrow Their Methods from Wrappers](ch08.html#primitive_methods_via_wrappers "Primitives
    Borrow Their Methods from Wrappers")).
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原始数字的方法都存储在`Number.prototype`中（参见[Primitives Borrow Their Methods from Wrappers](ch08.html#primitive_methods_via_wrappers
    "Primitives Borrow Their Methods from Wrappers")）。
- en: Number.prototype.toFixed(fractionDigits?)
  id: totrans-1198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Number.prototype.toFixed(fractionDigits?)
- en: '`Number.prototype.toFixed(fractionDigits?)` returns an exponent-free representation
    of the number, rounded to `fractionDigits` digits. If the parameter is omitted,
    the value 0 is used:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.prototype.toFixed(fractionDigits?)`返回一个不带指数的数字表示，四舍五入到`fractionDigits`位。如果省略参数，则使用值0：'
- en: '[PRE265]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'If the number is greater than or equal to 10^(21), then this method works the
    same as `toString()`. You get a number in exponential notation:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字大于或等于10^(21)，那么这个方法的工作方式与`toString()`相同。您会得到一个用指数表示的数字：
- en: '[PRE266]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: Number.prototype.toPrecision(precision?)
  id: totrans-1203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Number.prototype.toPrecision(precision?)
- en: '`Number.prototype.toPrecision(precision?)` prunes the mantissa to `precision`
    digits before using a conversion algorithm similar to `toString()`. If no precision
    is given, `toString()` is used directly:'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.prototype.toPrecision(precision?)`在使用类似于`toString()`的转换算法之前，将尾数修剪为`precision`位数字。如果没有给出精度，则直接使用`toString()`：'
- en: '[PRE267]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: You need the exponential notation to display 1234 with a precision of three
    digits.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要指数表示法来显示1234，精度为三位。
- en: Number.prototype.toString(radix?)
  id: totrans-1207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Number.prototype.toString(radix?)
- en: 'For `Number.prototype.toString(radix?)`, the parameter `radix` indicates the
    base of the system in which the number is to be displayed. The most common radices
    are 10 (decimal), 2 (binary), and 16 (hexadecimal):'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Number.prototype.toString(radix?)`，参数`radix`表示要显示数字的系统的基数。最常见的基数是10（十进制）、2（二进制）和16（十六进制）：
- en: '[PRE268]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'The radix must be at least 2 and at most 36\. Any radix greater than 10 leads
    to alphabetical characters being used as digits, which explains the maximum 36,
    as the Latin alphabet has 26 characters:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 基数必须至少为2，最多为36。任何大于10的基数都会导致字母字符被用作数字，这解释了最大36，因为拉丁字母表有26个字符：
- en: '[PRE269]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'The global function `parseInt` (see [Integers via parseInt()](ch11.html#parseInt
    "Integers via parseInt()")) allows you to convert such notations back to a number:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 全局函数`parseInt`（参见[Integers via parseInt()](ch11.html#parseInt "Integers via
    parseInt()")）允许您将这些表示法转换回数字：
- en: '[PRE270]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: Decimal exponential notation
  id: totrans-1214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 十进制指数表示法
- en: 'For the radix 10, `toString()` uses exponential notation (with a single digit
    before the decimal point) in two cases. First, if there are more than 21 digits
    before the decimal point of a number:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基数10，`toString()`在两种情况下使用指数表示法（小数点前有一个数字）。首先，如果小数点前有超过21位数字：
- en: '[PRE271]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'Second, if a number starts with `0.` followed by more than five zeros and a
    non-zero digit:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果一个数字以`0.`开头，后面跟着超过五个零和一个非零数字：
- en: '[PRE272]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: In all other cases, a fixed notation is used.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有其他情况下，使用固定表示法。
- en: Number.prototype.toExponential(fractionDigits?)
  id: totrans-1220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Number.prototype.toExponential(fractionDigits?)
- en: '`Number.prototype.toExponential(fractionDigits?)` forces a number to be expressed
    in exponential notation. `fractionDigits` is a number between 0 and 20 that determines
    how many digits should be shown after the decimal point. If it is omitted, then
    as many significant digits are included as necessary to uniquely specify the number.'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.prototype.toExponential(fractionDigits?)`强制一个数字以指数表示。`fractionDigits`是一个介于0和20之间的数字，用于确定小数点后应显示多少位数字。如果省略，则包括尽可能多的有效数字以唯一指定数字。'
- en: 'In this example, we force more precision when `toString()` would also use exponential
    notation. Results are mixed, because we reach the limits of the precision that
    can be achieved when converting binary numbers to a decimal notation:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当`toString()`也使用指数表示时，我们强制更多的精度。结果是混合的，因为当将二进制数字转换为十进制表示时，我们达到了可以实现的精度限制：
- en: '[PRE273]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'In this example, the magnitude of the number is not large enough for an exponent
    being displayed by `toString()`. However, `toExponential()` does display an exponent:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，数字的数量级不够大，无法通过`toString()`显示指数。然而，`toExponential()`确实显示了一个指数：
- en: '[PRE274]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'In this example, we get exponential notation when the fraction is not small
    enough:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当分数不够小时，我们得到指数表示法：
- en: '[PRE275]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Functions for Numbers
  id: totrans-1228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字函数
- en: 'The following functions operate on numbers:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数操作数字：
- en: '`isFinite(number)`'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: '`isFinite(number)`'
- en: Checks whether `number` is an actual number (neither `Infinity` nor `NaN`).
    For details, see [Checking for Infinity](ch11.html#isFinite "Checking for Infinity").
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`number`是否是实际数字（既不是`Infinity`也不是`NaN`）。详情请参见[Checking for Infinity](ch11.html#isFinite
    "Checking for Infinity")。
- en: '`isNaN(number)`'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: '`isNaN(number)`'
- en: 'Returns `true` if `number` is `NaN`. For details, see [Pitfall: checking whether
    a value is NaN](ch11.html#isNaN "Pitfall: checking whether a value is NaN").'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '如果`number`是`NaN`，则返回`true`。详情请参见[Pitfall: checking whether a value is NaN](ch11.html#isNaN
    "Pitfall: checking whether a value is NaN")。'
- en: '`parseFloat(str)`'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseFloat(str)`'
- en: Turns `str` into a floating-point number. For details, see [parseFloat()](ch11.html#parseFloat
    "parseFloat()").
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 将`str`转换为浮点数。详情请参见[parseFloat()](ch11.html#parseFloat "parseFloat()")。
- en: '`parseInt(str, radix?)`'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt(str, radix?)`'
- en: Parses `str` as an integer whose base is `radix` (2–36). For details, see [Integers
    via parseInt()](ch11.html#parseInt "Integers via parseInt()").
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 将`str`解析为以`radix`为基数的整数（2-36）。详情请参阅[通过parseInt()获取整数](ch11.html#parseInt "通过parseInt()获取整数")。
- en: Sources for This Chapter
  id: totrans-1238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本章的来源
- en: 'I referred to the following sources while writing this chapter:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本章时，我参考了以下来源：
- en: '[“IEEE Standard 754 Floating Point Numbers”](http://bit.ly/1oOc43P) by Steve
    Hollasch'
  id: totrans-1240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“IEEE标准754浮点数”](http://bit.ly/1oOc43P) 由Steve Hollasch'
- en: '[“Data Types and Scaling (Fixed-Point Blockset)”](http://bit.ly/1oOc83t) in
    the MATLAB documentation'
  id: totrans-1241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“数据类型和缩放（固定点块集）”](http://bit.ly/1oOc83t) 在MATLAB文档中'
- en: '[“IEEE floating point”](http://en.wikipedia.org/wiki/IEEE_754) on Wikipedia'
  id: totrans-1242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“IEEE浮点”](http://en.wikipedia.org/wiki/IEEE_754) 在维基百科上'
- en: '* * *'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[12](#id995098)]) Source: Brendan Eich, [http://bit.ly/1lKzQeC](http://bit.ly/1lKzQeC).'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[12](#id995098)]) 来源：Brendan Eich，[http://bit.ly/1lKzQeC](http://bit.ly/1lKzQeC)。
- en: ^([[13](#id1001327)]) Béla Varga (@netzzwerg) pointed out that IEEE 754 specifies
    NaN as not equal to itself.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[13](#id1001327)]) Béla Varga（@netzzwerg）指出IEEE 754规定NaN不等于自身。
- en: Chapter 12. Strings
  id: totrans-1246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章.字符串
- en: Strings are immutable sequences of JavaScript characters. Each such character
    is a 16-bit UTF-16 code unit. That means that a single Unicode character is represented
    by either one or two JavaScript characters. You mainly need to worry about the
    two-character case whenever you are counting characters or splitting strings (see
    [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript")).
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是JavaScript字符的不可变序列。每个字符都是一个16位的UTF-16代码单元。这意味着一个Unicode字符由一个或两个JavaScript字符表示。当您计算字符数或拆分字符串时，您主要需要考虑两个字符的情况（参见[第24章](ch24.html
    "第24章.Unicode和JavaScript")）。
- en: String Literals
  id: totrans-1248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串文字
- en: 'Both single and double quotes can be used to delimit string literals:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号和双引号都可以用来界定字符串文字：
- en: '[PRE276]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'Thus, you are free to use either kind of quote. There are several considerations,
    though:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以自由地使用任何一种引号。不过，有几点需要考虑：
- en: The most common style in the community is to use double quotes for HTML and
    single quotes for JavaScript.
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区中最常见的风格是在HTML中使用双引号，在JavaScript中使用单引号。
- en: On the other hand, double quotes are used exclusively for strings in some languages
    (e.g., C and Java). Therefore, it may make sense to use them in a multilanguage
    code base.
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，某些语言（例如C和Java）中双引号专门用于字符串。因此，在多语言代码库中使用它们可能是有意义的。
- en: For JSON (discussed in [Chapter 22](ch22.html "Chapter 22. JSON")), you must
    use double quotes.
  id: totrans-1254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于JSON（在[第22章](ch22.html "第22章.JSON")中讨论），您必须使用双引号。
- en: Your code will look cleaner if you quote consistently. But sometimes, a different
    quote means that you don’t have to escape, which can justify your being less consistent
    (e.g., you may normally use single quotes, but temporarily switch to double quotes
    to write the last one of the preceding examples).
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一贯使用引号，您的代码看起来会更整洁。但有时，不同的引号意味着您不必转义，这可以证明您不那么一致是合理的（例如，您可能通常使用单引号，但暂时切换到双引号来编写前面例子的最后一个）。
- en: Escaping in String Literals
  id: totrans-1256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串文字中的转义
- en: 'Most characters in string literals simply represent themselves. The backslash
    is used for *escaping* and enables several special features:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串文字中的大多数字符只是代表它们自己。反斜杠用于*转义*并启用了一些特殊功能：
- en: Line continuations
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 行继续
- en: 'You can spread a string over multiple lines by escaping the end of the line
    (the line-terminating character, the *line terminator*) with a backslash:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过用反斜杠转义行尾（行终止字符，*行终止符*）来将字符串分布在多行上：
- en: '[PRE277]'
  id: totrans-1260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'An alternative is to use the plus operator to concatenate:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用加号运算符进行连接：
- en: '[PRE278]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: Character escape sequences
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 字符转义序列
- en: 'These sequences start with a backslash:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些序列以反斜杠开头：
- en: 'Control characters: `\b` is a backspace, `\f` is a form feed, `\n` is a line
    feed (newline), `\r` is a carriage return, `\t` is a horizontal tab, and `\v`
    is a vertical tab.'
  id: totrans-1265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制字符：`\b`是一个退格，`\f`是一个换页符，`\n`是一个换行符（新行），`\r`是一个回车，`\t`是一个水平制表符，`\v`是一个垂直制表符。
- en: 'Escaped characters that represent themselves: `\''` is a single quote, `\"`
    is a double quote, and `\\` is a backslash. All characters except `b f n r t v
    x u` and decimal digits represent themselves, too. Here are two examples:'
  id: totrans-1266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转义字符代表它们自己：`\'`是一个单引号，`\"`是一个双引号，`\\`是一个反斜杠。除了`b f n r t v x u`和十进制数字之外，所有字符也代表它们自己。以下是两个例子：
- en: '[PRE279]'
  id: totrans-1267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: NUL character (Unicode code point 0)
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: NUL字符（Unicode代码点0）
- en: This character is represented by `\0`.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符由`\0`表示。
- en: Hexadecimal escape sequences
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制转义序列
- en: '`\xHH` (`HH` are two hexadecimal digits) specifies a character via an ASCII
    code. For example:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: '`\xHH`（`HH`是两个十六进制数字）指定了一个ASCII码的字符。例如：'
- en: '[PRE280]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: Unicode escape sequences
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode转义序列
- en: '`\uHHHH` (`HHHH` are four hexadecimal digits) specifies a UTF-16 code unit
    (see [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript")). Here are two
    examples:'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: '`\uHHHH`（`HHHH`是四个十六进制数字）指定了一个UTF-16代码单元（参见[第24章](ch24.html "第24章.Unicode和JavaScript")）。以下是两个例子：'
- en: '[PRE281]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: Character Access
  id: totrans-1276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符访问
- en: 'There are two operations that return the *n*th character of a string.^([[14](#ftn.id925641)])
    Note that JavaScript does not have a special data type for characters; these operations
    return strings:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个操作可以返回字符串的第*n*个字符。请注意，JavaScript没有专门的字符数据类型；这些操作返回字符串：
- en: '[PRE282]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: Some older browsers don’t support the array-like access to characters via square
    brackets.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 一些较旧的浏览器不支持通过方括号进行类似数组的字符访问。
- en: Converting to String
  id: totrans-1280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为字符串
- en: 'Values are converted to a string as follows:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 值将按以下方式转换为字符串：
- en: '| Value | Result |'
  id: totrans-1282
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 结果 |'
- en: '| --- | --- |'
  id: totrans-1283
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `undefined` | `''undefined''` |'
  id: totrans-1284
  prefs: []
  type: TYPE_TB
  zh: '`undefined` → `''undefined''`'
- en: '| `null` | `''null''` |'
  id: totrans-1285
  prefs: []
  type: TYPE_TB
  zh: '`null` → `''null''`'
- en: '| A boolean | `false` → `''false''` |'
  id: totrans-1286
  prefs: []
  type: TYPE_TB
  zh: 布尔值 `false` → `'false'`
- en: '|  | `true` → `''true''` |'
  id: totrans-1287
  prefs: []
  type: TYPE_TB
  zh: '|  | `true` → `''true''` |'
- en: '| A number | The number as a string (e.g., `3.141` → `''3.141''`) |'
  id: totrans-1288
  prefs: []
  type: TYPE_TB
  zh: '| 一个数字 | 作为字符串的数字（例如，`3.141` → `''3.141''`） |'
- en: '| A string | Same as input (nothing to convert) |'
  id: totrans-1289
  prefs: []
  type: TYPE_TB
  zh: '| 一个字符串 | 与输入相同（无需转换） |'
- en: '| An object | Call `ToPrimitive(value, String)` (see [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")) and convert the resulting primitive. |'
  id: totrans-1290
  prefs: []
  type: TYPE_TB
  zh: '| 一个对象 | 调用`ToPrimitive(value, String)`（请参阅[算法：ToPrimitive()——将值转换为原始值](ch08.html#toprimitive
    "算法：ToPrimitive()——将值转换为原始值")）并转换生成的原始值。 |'
- en: Manually Converting to String
  id: totrans-1291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动转换为字符串
- en: 'The three most common ways to convert any value to a string are:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 将三种将任何值转换为字符串的最常见方法是：
- en: '| `String(value)` | (Invoked as a function, not as a constructor) |'
  id: totrans-1293
  prefs: []
  type: TYPE_TB
  zh: '| `String(value)` | （作为函数调用，而不是作为构造函数） |'
- en: '| `''''+value` |  |'
  id: totrans-1294
  prefs: []
  type: TYPE_TB
  zh: '| `''''+value` |  |'
- en: '| `value.toString()` | (Does not work for `undefined` and `null`!) |'
  id: totrans-1295
  prefs: []
  type: TYPE_TB
  zh: '| `value.toString()` | （对于`undefined`和`null`不起作用！） |'
- en: 'I prefer `String()`, because it is more descriptive. Here are some examples:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢`String()`，因为它更具描述性。以下是一些示例：
- en: '[PRE283]'
  id: totrans-1297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'Note that for displaying data, `JSON.stringify()` ([JSON.stringify(value, replacer?,
    space?)](ch22.html#JSON.stringify "JSON.stringify(value, replacer?, space?)"))
    often works better than the canonical conversion to string:'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于显示数据，`JSON.stringify()`（[JSON.stringify(value, replacer?, space?)](ch22.html#JSON.stringify
    "JSON.stringify(value, replacer?, space?)")）通常比规范的字符串转换效果更好：
- en: '[PRE284]'
  id: totrans-1299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Naturally, you have to be aware of the limitations of `JSON.stringify()`—it
    doesn’t always show everything. For example, it hides properties whose values
    it can’t handle (functions and more!). On the plus side, its output can be parsed
    by `eval()` and it can display deeply nested data as nicely formatted trees.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您必须意识到`JSON.stringify()`的局限性——它并不总是显示所有内容。例如，它隐藏了它无法处理的属性的值（函数等！）。另一方面，它的输出可以被`eval()`解析，并且可以将深度嵌套的数据显示为格式良好的树。
- en: 'Pitfall: conversion is not invertible'
  id: totrans-1301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：转换不可逆
- en: 'Given how often JavaScript automatically converts, it is a shame that the conversion
    isn’t always invertible, especially with regard to booleans:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到JavaScript自动转换的频率，遗憾的是转换并不总是可逆的，特别是在布尔值方面：
- en: '[PRE285]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: For `undefined` and `null`, we face similar problems.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`undefined`和`null`，我们面临类似的问题。
- en: Comparing Strings
  id: totrans-1305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较字符串
- en: 'There are two ways of comparing strings. First, you can use the comparison
    operators: `<`, `>`, `===`, `<=`, `>=`. They have the following drawbacks:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种比较字符串的方法。首先，您可以使用比较运算符：`<`，`>`，`===`，`<=`，`>=`。它们有以下缺点：
- en: 'They’re case-sensitive:'
  id: totrans-1307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们区分大小写：
- en: '[PRE286]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'They don’t handle umlauts and accents well:'
  id: totrans-1309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能很好地处理变音符和重音符号：
- en: '[PRE287]'
  id: totrans-1310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'Second, you can use `String.prototype.localeCompare(other)`, which tends to
    fare better, but isn’t always supported (consult [Search and Compare](ch12.html#String.prototype.localeCompare
    "Search and Compare") for details). The following is an interaction in Firefox’s
    console:'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您可以使用`String.prototype.localeCompare(other)`，这往往更好，但并不总是受支持（有关详细信息，请参阅[搜索和比较](ch12.html#String.prototype.localeCompare
    "搜索和比较")）。以下是Firefox控制台中的交互：
- en: '[PRE288]'
  id: totrans-1312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: A result less than zero means that the receiver is “smaller” than the argument.
    A result greater than zero means that the receiver is “larger” than the argument.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 小于零的结果意味着接收器“小于”参数。大于零的结果意味着接收器“大于”参数。
- en: Concatenating Strings
  id: totrans-1314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接字符串
- en: There are two main approaches for concatenating strings.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要的字符串连接方法。
- en: 'Concatenation: The Plus (+) Operator'
  id: totrans-1316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接：加号（+）运算符
- en: 'The operator `+` does string concatenation as soon as one of its operands is
    a string. If you want to collect string pieces in a variable, the compound assignment
    operator `+=` is useful:'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符`+`在其操作数之一是字符串时进行字符串连接。如果要在变量中收集字符串片段，则复合赋值运算符`+=`很有用：
- en: '[PRE289]'
  id: totrans-1318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'Concatenation: Joining an Array of String Fragments'
  id: totrans-1319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接：连接字符串片段的数组
- en: 'It may seem that the previous approach creates a new string whenever a piece
    is added to `str`. Older JavaScript engines do it that way, which means that you
    can improve the performance of string concatenation by collecting all the pieces
    in an array first and joining them as a last step:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎以前的方法每次添加一个片段到`str`时都会创建一个新的字符串。旧的JavaScript引擎是这样做的，这意味着您可以通过首先将所有片段收集到一个数组中，然后作为最后一步连接它们来提高字符串连接的性能：
- en: '[PRE290]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: However, newer engines optimize string concatenation via `+` and use a similar
    method internally. Therefore, the plus operator is faster on those engines.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，较新的引擎通过`+`优化字符串连接，并在内部使用类似的方法。因此，在这些引擎上，加号运算符的速度更快。
- en: The Function String
  id: totrans-1323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串函数
- en: 'The function `String` can be invoked in two ways:'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`String`可以以两种方式调用：
- en: '`String(value)`'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '`String(value)`'
- en: 'As a normal function, it converts `value` to a primitive string (see [Converting
    to String](ch12.html#tostring "Converting to String")):'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为普通函数，它将`value`转换为原始字符串（请参阅[转换为字符串](ch12.html#tostring "转换为字符串")）：
- en: '[PRE291]'
  id: totrans-1327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '`new String(str)`'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: '`new String(str)`'
- en: 'As a constructor, it creates a new instance of `String` (see [Wrapper Objects
    for Primitives](ch08.html#wrapper_objects "Wrapper Objects for Primitives")),
    an object that wraps `str` (nonstrings are coerced to string). For example:'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 作为构造函数，它创建`String`的新实例（请参阅[原始值的包装对象](ch08.html#wrapper_objects "原始值的包装对象")），一个包装`str`的对象（非字符串被强制转换为字符串）。例如：
- en: '[PRE292]'
  id: totrans-1330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: The former invocation is the common one.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 前一种调用是常见的。
- en: String Constructor Method
  id: totrans-1332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串构造函数方法
- en: '`String.fromCharCode(codeUnit1, codeUnit2, ...)` produces a string whose characters
    are the UTF-16 code units specified by the 16-bit unsigned integers `codeUnit1`,
    `codeUnit2`, and so on. For example:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.fromCharCode(codeUnit1, codeUnit2, ...)` 生成一个字符串，其字符由16位无符号整数`codeUnit1`，`codeUnit2`等指定的UTF-16代码单元组成。例如：'
- en: '[PRE293]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'If you want to turn an array of numbers into a string, you can do so via `apply()`
    (see [func.apply(thisValue, argArray)](ch15.html#functional_apply "func.apply(thisValue,
    argArray)")):'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将数字数组转换为字符串，可以通过`apply()`（请参阅[func.apply(thisValue, argArray)](ch15.html#functional_apply
    "func.apply(thisValue, argArray")）来实现：
- en: '[PRE294]'
  id: totrans-1336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: The inverse of `String.fromCharCode()` is `String.prototype.charCodeAt()`.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.fromCharCode()`的反函数是`String.prototype.charCodeAt()`。'
- en: String Instance Property length
  id: totrans-1338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串实例属性长度
- en: 'The `length` property indicates the number of JavaScript characters in the
    string and is immutable:'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: '`length`属性指示字符串中的JavaScript字符数，并且是不可变的：'
- en: '[PRE295]'
  id: totrans-1340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: String Prototype Methods
  id: totrans-1341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串原型方法
- en: All methods of primitive strings are stored in `String.prototype` (refer back
    to [Primitives Borrow Their Methods from Wrappers](ch08.html#primitive_methods_via_wrappers
    "Primitives Borrow Their Methods from Wrappers")). Next, I describe how they work
    for primitive strings, not for instances of `String`.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串的所有原始字符串方法都存储在`String.prototype`中（参见[原始通过包装器借用其方法](ch08.html#primitive_methods_via_wrappers
    "原始通过包装器借用其方法")）。接下来，我描述了它们如何用于原始字符串，而不是`String`的实例。
- en: Extract Substrings
  id: totrans-1343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取子字符串
- en: 'The following methods extract substrings from the receiver:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法从接收者中提取子字符串：
- en: '`String.prototype.charAt(pos)`'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.charAt(pos)`'
- en: 'Returns a string with the character at position `pos`. For example:'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 返回位置`pos`处的字符。例如：
- en: '[PRE296]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'The following two expressions return the same result, but some older JavaScript
    engines support only `charAt()` for accessing characters:'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个表达式返回相同的结果，但一些较旧的JavaScript引擎只支持使用`charAt()`来访问字符：
- en: '[PRE297]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '`String.prototype.charCodeAt(pos)`'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.charCodeAt(pos)`'
- en: Returns the code (a 16-bit unsigned integer) of the JavaScript character (a
    UTF-16 code unit; see [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript"))
    at position `pos`.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 返回JavaScript字符（UTF-16代码单元；参见[第24章](ch24.html "第24章. Unicode and JavaScript")）在位置`pos`处的代码（一个16位无符号整数）。
- en: 'This is how you create an array of character codes:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何创建字符代码数组的：
- en: '[PRE298]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: The inverse of `charCodeAt()` is `String.fromCharCode()`.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: '`charCodeAt()`的反函数是`String.fromCharCode()`。'
- en: '`String.prototype.slice(start, end?)`'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.slice(start, end?)`'
- en: 'Returns the substring starting at position `start` up to and excluding position
    `end`. Both of the two parameters can be negative, and then the `length` of the
    string is added to them:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从位置`start`开始到位置`end`之前的子字符串。这两个参数都可以是负数，然后它们的长度将被添加到它们中：
- en: '[PRE299]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '`String.prototype.substring(start, end?)`'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.substring(start, end?)`'
- en: Should be avoided in favor of `slice()`, which is similar, but can handle negative
    positions and is implemented more consistently across browsers.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 应该避免使用`slice()`，它类似，但可以处理负位置，并且在各个浏览器中实现更一致。
- en: '`String.prototype.split(separator?, limit?)`'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.split(separator?, limit?)`'
- en: 'Extracts the substrings of the receiver that are delimited by `separator` and
    returns them in an array. The method has two parameters:'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 提取由`separator`分隔的接收者的子字符串，并将它们作为数组返回。该方法有两个参数：
- en: '`separator`: Either a string or a regular expression. If missing, the complete
    string is returned, wrapped in an array.'
  id: totrans-1362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`separator`：要么是一个字符串，要么是一个正则表达式。如果缺失，将返回完整的字符串，包裹在一个数组中。'
- en: '`limit`: If given, the returned array contains at most `limit` elements.'
  id: totrans-1363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`：如果给定，返回的数组最多包含`limit`个元素。'
- en: 'Here are some examples:'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE300]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'If there is a group, then the matches are also returned as array elements:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个组，那么匹配项也会作为数组元素返回：
- en: '[PRE301]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'Use `''''` (empty string) as a separator to produce an array with the characters
    of a string:'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`''`（空字符串）作为分隔符，以产生一个包含字符串字符的数组：
- en: '[PRE302]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: Transform
  id: totrans-1370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换
- en: 'While the previous section was about extracting substrings, this section is
    about transforming a given string into a new one. These methods are typically
    used as follows:'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节是关于提取子字符串，而这一节是关于将给定的字符串转换为新字符串。这些方法通常如下使用：
- en: '[PRE303]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: 'In other words, the original string is discarded after it has been (nondestructively)
    transformed:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，原始字符串在（非破坏性地）转换后被丢弃：
- en: '`String.prototype.trim()`'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.trim()`'
- en: 'Removes all whitespace from the beginning and the end of the string:'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串的开头和结尾删除所有空格：
- en: '[PRE304]'
  id: totrans-1376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '`String.prototype.concat(str1?, str2?, ...)`'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.concat(str1?, str2?, ...)`'
- en: 'Returns the concatenation of the receiver and `str1`, `str2`, etc.:'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 返回接收者和`str1`、`str2`等的连接：
- en: '[PRE305]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '`String.prototype.toLowerCase()`'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.toLowerCase()`'
- en: 'Creates a new string with all of the original string’s characters converted
    to lowercase:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新字符串，其中包含所有原始字符串的字符转换为小写：
- en: '[PRE306]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '`String.prototype.toLocaleLowerCase()`'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.toLocaleLowerCase()`'
- en: 'Works the same as `toLowerCase()`, but respects the rules of the current locale.
    According to the ECMAScript spec: “There will only be a difference in the few
    cases (such as Turkish) where the rules for that language conflict with the regular
    Unicode case mappings.”'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 与`toLowerCase()`相同，但遵守当前区域设置的规则。根据ECMAScript规范：“只有在少数情况下（如土耳其语）语言的规则与常规Unicode大小写映射冲突时才会有差异。”
- en: '`String.prototype.toUpperCase()`'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.toUpperCase()`'
- en: 'Creates a new string with all of the original string’s characters converted
    to uppercase:'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新字符串，其中包含所有原始字符串的字符转换为大写：
- en: '[PRE307]'
  id: totrans-1387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '`String.prototype.toLocaleUpperCase()`'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.toLocaleUpperCase()`'
- en: Works the same as `toUpperCase()`, but respects the rules of the current locale.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 与`toUpperCase()`相同，但遵守当前区域设置的规则。
- en: Search and Compare
  id: totrans-1390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索和比较
- en: 'The following methods are used for searching and comparing strings:'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法用于搜索和比较字符串：
- en: '`String.prototype.indexOf(searchString, position?)`'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.indexOf(searchString, position?)`'
- en: 'Searches for `searchString` starting at `position` (the default is 0). It returns
    the position where `searchString` has been found or –1 if it can’t be found:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 从`position`（默认为0）开始搜索`searchString`。它返回`searchString`被找到的位置，或者-1（如果找不到）：
- en: '[PRE308]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'Note that when it comes to finding text inside a string, a regular expression
    works just as well. For example, the following two expressions are equivalent:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当涉及在字符串中查找文本时，正则表达式同样有效。例如，以下两个表达式是等价的：
- en: '[PRE309]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '`String.prototype.lastIndexOf(searchString, position?)`'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.lastIndexOf(searchString, position?)`'
- en: 'Searches for `searchString`, starting at `position` (the default is the end),
    backward. It returns the position where `searchString` has been found or –1 if
    it can’t be found:'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 从`position`（默认为末尾）开始向后搜索`searchString`。它返回`searchString`被找到的位置，或者-1（如果找不到）：
- en: '[PRE310]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '`String.prototype.localeCompare(other)`'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.localeCompare(other)`'
- en: 'Performs a locale-sensitive comparison of the string with `other`. It returns
    a number:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符串与`other`进行区域敏感比较。它返回一个数字：
- en: < 0 if the string comes before `other`
  id: totrans-1402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: < 0 如果字符串在`other`之前
- en: = 0 if the string is equivalent to `other`
  id: totrans-1403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: = 0 如果字符串等同于`other`
- en: 0 if the string comes after `other`
  id: totrans-1404
  prefs:
  - PREF_UL
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果字符串在`other`之后
- en: 'For example:'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE311]'
  id: totrans-1406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: Warning
  id: totrans-1407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Not all JavaScript engines implement this method properly. Some just base it
    on the comparison operators. However, the ECMAScript Internationalization API
    (see [The ECMAScript Internationalization API](ch30.html#i18n_api "The ECMAScript
    Internationalization API")) does provide a Unicode-aware implementation. That
    is, if that API is available in an engine, `localeCompare()` will work.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有JavaScript引擎都正确实现了这种方法。有些只是基于比较运算符。然而，ECMAScript国际化API（参见[ECMAScript国际化API](ch30.html#i18n_api
    "ECMAScript国际化API")）提供了一个基于Unicode的实现。也就是说，如果引擎中有这个API，`localeCompare()`将起作用。
- en: If it is supported, `localeCompare()` is a better choice for comparing strings
    than the comparison operators. Consult [Comparing Strings](ch12.html#comparing_strings
    "Comparing Strings") for more information.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果支持，`localeCompare()`比比较运算符更适合比较字符串。请参阅[比较字符串](ch12.html#comparing_strings
    "比较字符串")了解更多信息。
- en: Test, Match, and Replace with Regular Expressions
  id: totrans-1410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用正则表达式进行测试、匹配和替换
- en: 'The following methods work with regular expressions:'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法适用于正则表达式：
- en: '`String.prototype.search(regexp)` (more thoroughly explained in [String.prototype.search:
    At What Index Is There a Match?](ch19.html#String.prototype.search "String.prototype.search:
    At What Index Is There a Match?"))'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.search(regexp)`（在[字符串原型搜索：有匹配的索引是什么？](ch19.html#String.prototype.search
    "字符串原型搜索：有匹配的索引是什么？")中更详细地解释）'
- en: 'Returns the first index at which `regexp` matches in the receiver (or –1 if
    it doesn’t):'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`regexp`在接收者中匹配的第一个索引（如果没有匹配，则返回-1）：
- en: '[PRE312]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '`String.prototype.match(regexp)` (more thoroughly explained in [String.prototype.match:
    Capture Groups or Return All Matching Substrings](ch19.html#String.prototype.match
    "String.prototype.match: Capture Groups or Return All Matching Substrings"))'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.match(regexp)`（在[字符串原型匹配：捕获组或返回所有匹配的子字符串](ch19.html#String.prototype.match
    "字符串原型匹配：捕获组或返回所有匹配的子字符串")中更详细地解释）'
- en: 'Matches the given regular expression against the receiver. It returns a match
    object for the first match if the flag `/g` of `regexp` is not set:'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配给定的正则表达式与接收者。如果未设置`regexp`的标志`/g`，则返回第一个匹配的匹配对象：
- en: '[PRE313]'
  id: totrans-1417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: 'If the flag `/g` is set, then all complete matches (group 0) are returned in
    an array:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标志`/g`被设置，那么所有完整的匹配（第0组）将以数组的形式返回：
- en: '[PRE314]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '`String.prototype.replace(search, replacement)` (more thoroughly explained
    in [String.prototype.replace: Search and Replace](ch19.html#String.prototype.replace
    "String.prototype.replace: Search and Replace"))'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.prototype.replace(search, replacement)`（在[字符串原型替换：搜索和替换](ch19.html#String.prototype.replace
    "字符串原型替换：搜索和替换")中更详细地解释）'
- en: 'Searches for `search` and replaces it with `replacement`. `search` can be a
    string or a regular expression, and `replacement` can be a string or a function.
    Unless you use a regular expression as `search` whose flag `/g` is set, only the
    first occurrence will be replaced:'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索`search`并用`replacement`替换它。`search`可以是一个字符串或一个正则表达式，`replacement`可以是一个字符串或一个函数。除非您使用一个设置了标志`/g`的正则表达式作为`search`，否则只会替换第一个出现的：
- en: '[PRE315]'
  id: totrans-1422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'A dollar sign (`$`) in a replacement string allows you to refer to the complete
    match or a captured group:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字符串中的美元符号（`$`）允许您引用完整的匹配或捕获的组：
- en: '[PRE316]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: 'You can also compute a replacement via a function:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过函数计算替换：
- en: '[PRE317]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '* * *'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[14](#id925641)]) Strictly speaking, a JavaScript string consists of a sequence
    of UTF-16 code units. That is, JavaScript characters are Unicode code units (see
    [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript")).
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[14](#id925641)]) 严格来说，JavaScript字符串由一系列UTF-16代码单元组成。也就是说，JavaScript字符是Unicode代码单元（参见[第24章](ch24.html
    "第24章. Unicode and JavaScript")）。
- en: Chapter 13. Statements
  id: totrans-1429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13章。语句
- en: 'This chapter covers JavaScript’s statements: variable declarations, loops,
    conditionals, and others.'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了JavaScript的语句：变量声明、循环、条件语句等。
- en: Declaring and Assigning Variables
  id: totrans-1431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明和赋值变量
- en: '`var` is used to *declare* a variable, which creates the variable and enables
    you to work with it. The equals operator (`=`) is used to assign a value to it:'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`用于*声明*一个变量，它创建变量并使您能够使用它。等号（`=`）用于给它赋值：'
- en: '[PRE318]'
  id: totrans-1433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '`var` also lets you combine the preceding two statements into a single one:'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`还允许您将前面的两个语句合并为一个：'
- en: '[PRE319]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'Finally, you can also combine multiple `var` statements into one:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以将多个`var`语句合并为一个：
- en: '[PRE320]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'Read more about how variables work in [Chapter 16](ch16.html "Chapter 16. Variables:
    Scopes, Environments, and Closures").'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 了解有关变量如何工作的更多信息，请阅读[第16章](ch16.html "第16章. 变量：作用域、环境和闭包")。
- en: The Bodies of Loops and Conditionals
  id: totrans-1439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环和条件语句的主体
- en: 'Compound statements such as loops and conditionals have one or more “bodies”
    embedded—for example, the `while` loop:'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 复合语句，如循环和条件语句，嵌入了一个或多个“主体”——例如，`while`循环：
- en: '[PRE321]'
  id: totrans-1441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'For the body `«statement»`, you have a choice. You can either use a single
    statement:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`«statement»`主体，您有选择。您可以使用单个语句：
- en: '[PRE322]'
  id: totrans-1443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'or you can use a block (which counts as a single statement):'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用一个块（它算作一个单独的语句）：
- en: '[PRE323]'
  id: totrans-1445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: You need to use a block if you want the body to comprise multiple statements.
    Unless the complete compound statement can be written in a single line, I recommend
    using a block.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使主体包含多个语句，您需要使用一个块。除非完整的复合语句可以写在一行中，否则我建议使用一个块。
- en: Loops
  id: totrans-1447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: This section explores JavaScript’s loop statements.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了JavaScript的循环语句。
- en: Mechanisms to Be Used with Loops
  id: totrans-1449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与循环一起使用的机制
- en: 'The following mechanisms can be used with all loops:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 以下机制可以与所有循环一起使用：
- en: '`break ⟦«label»⟧`'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: '`break ⟦«label»⟧`'
- en: Exit from a loop.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 退出循环。
- en: '`continue ⟦«label»⟧`'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue ⟦«label»⟧`'
- en: Stop the current loop iteration, and immediately continue with the next one.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 停止当前循环迭代，并立即继续下一个。
- en: Labels
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 标签
- en: 'A label is an identifier followed by a colon. In front of a loop, a label allows
    you to break or continue that loop even from a loop nested inside of it. In front
    of a block, you can break out of that block. In both cases, the name of the label
    becomes an argument of `break` or `continue`. Here’s an example of breaking out
    of a block:'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是一个标识符，后面跟着一个冒号。在循环前，标签允许您即使从嵌套在其中的循环中也可以中断或继续该循环。在块的前面，您可以跳出该块。在这两种情况下，标签的名称成为`break`或`continue`的参数。这是一个打破块的例子：
- en: '[PRE324]'
  id: totrans-1457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: while
  id: totrans-1458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当
- en: 'A `while` loop:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`while`循环：
- en: '[PRE325]'
  id: totrans-1460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'executes `statement` as long as `condition` holds. If `condition` is always
    `true`, you get an infinite loop:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`condition`成立，就执行`statement`。如果`condition`始终为`true`，则会得到一个无限循环：
- en: '[PRE326]'
  id: totrans-1462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'In the following example, we remove all elements of an array and log them to
    the console:'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们删除数组的所有元素并将它们记录到控制台：
- en: '[PRE327]'
  id: totrans-1464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'Here is the output:'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE328]'
  id: totrans-1466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: do-while
  id: totrans-1467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: do-while
- en: 'A `do-while` loop:'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`do-while`循环：
- en: '[PRE329]'
  id: totrans-1469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'executes `statement` at least once and then as long as `condition` holds. For
    example:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 至少执行`statement`一次，然后只要`condition`成立。例如：
- en: '[PRE330]'
  id: totrans-1471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: for
  id: totrans-1472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为了
- en: 'In a `for` loop:'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中：
- en: '[PRE331]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '`init` is executed once before the loop, which continues as long as `condition`
    is `true`. You can use `var` in `init` to declare variables, but the scope of
    those variables is always the complete surrounding function. `post_iteration`
    is executed after each iteration of the loop. Taking all of this into consideration,
    the preceding loop is equivalent to the following `while` loop:'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`在循环之前执行一次，只要`condition`为`true`，循环就会继续。您可以在`init`中使用`var`声明变量，但是这些变量的作用域始终是完整的周围函数。`post_iteration`在循环的每次迭代之后执行。考虑到所有这些，前面的循环等同于以下`while`循环：'
- en: '[PRE332]'
  id: totrans-1476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'The following example is the traditional way of iterating over arrays (other
    possibilities are described in [Best Practices: Iterating over Arrays](ch18.html#array_iteration
    "Best Practices: Iterating over Arrays")):'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是迭代数组的传统方法（其他可能性在[最佳实践：迭代数组](ch18.html#array_iteration "最佳实践：迭代数组")中描述）：
- en: '[PRE333]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'A `for` loop becomes infinite if you omit all parts of the head:'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您省略头部的所有部分，`for`循环将变得无限：
- en: '[PRE334]'
  id: totrans-1480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: for-in
  id: totrans-1481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于
- en: 'A `for-in` loop:'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`for-in`循环：
- en: '[PRE335]'
  id: totrans-1483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'iterates over all property keys of `object`, including inherited ones. However,
    properties that are marked as not enumerable are ignored (see [Property Attributes
    and Property Descriptors](ch17_split_000.html#property_attributes "Property Attributes
    and Property Descriptors")). The following rules apply to `for-in` loops:'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历`object`的所有属性键，包括继承的属性。但是，标记为不可枚举的属性将被忽略（参见[属性属性和属性描述符](ch17_split_000.html#property_attributes
    "属性属性和属性描述符")）。以下规则适用于`for-in`循环：
- en: You can use `var` to declare variables, but the scope of those variables is
    always the complete surrounding function.
  id: totrans-1485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`var`声明变量，但是这些变量的作用域始终是完整的周围函数。
- en: Properties can be deleted during iteration.
  id: totrans-1486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在迭代期间可以删除属性。
- en: 'Best practice: don’t use for-in for arrays'
  id: totrans-1487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最佳实践：不要对数组使用for-in
- en: 'Don’t use `for-in` to iterate over arrays. First, it iterates over indices,
    not over values:'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`for-in`来遍历数组。首先，它遍历索引，而不是值：
- en: '[PRE336]'
  id: totrans-1489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'Second, it also iterates over all (nonindex) property keys. The following example
    illustrates what happens when you add a property `foo` to an array:'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它还遍历所有（非索引）属性键。以下示例说明了当您向数组添加属性`foo`时会发生什么：
- en: '[PRE337]'
  id: totrans-1491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'Thus, you are better off with a normal `for` loop or the array method `forEach()`
    (see [Best Practices: Iterating over Arrays](ch18.html#array_iteration "Best Practices:
    Iterating over Arrays")).'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好使用普通的`for`循环或数组方法`forEach()`（参见[最佳实践：迭代数组](ch18.html#array_iteration "最佳实践：迭代数组")）。
- en: 'Best practice: be careful with for-in for objects'
  id: totrans-1493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最佳实践：小心使用对象的for-in
- en: 'The `for-in` loop iterates over *all* (enumerable) properties, including inherited
    ones. That may not be what you want. Let’s use the following constructor to illustrate
    the problem:'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-in`循环遍历*所有*（可枚举）属性，包括继承的属性。这可能不是您想要的。让我们使用以下构造函数来说明问题：'
- en: '[PRE338]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: 'Instances of `Person` inherit the property `describe` from `Person.prototype`,
    which is seen by `for-in`:'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`的实例从`Person.prototype`继承了属性`describe`，这是由`for-in`看到的：'
- en: '[PRE339]'
  id: totrans-1497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'Here is the output:'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE340]'
  id: totrans-1499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'Normally, the best way to use `for-in` is to skip inherited properties via
    `hasOwnProperty()`:'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用`for-in`的最佳方法是通过`hasOwnProperty()`跳过继承的属性：
- en: '[PRE341]'
  id: totrans-1501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: 'And here is the output:'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE342]'
  id: totrans-1503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: 'There is one last caveat: `person` may have a property `hasOwnProperty`, which
    would prevent the check from working. To be safe, you have to refer to the generic
    method (see [Generic Methods: Borrowing Methods from Prototypes](ch17_split_001.html#generic_method
    "Generic Methods: Borrowing Methods from Prototypes")) `Object.prototype.hasOwnProperty`
    directly:'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个最后的警告：`person`可能有一个`hasOwnProperty`属性，这将阻止检查起作用。为了安全起见，您必须直接引用通用方法（参见[通用方法：从原型中借用方法](ch17_split_001.html#generic_method
    "通用方法：从原型中借用方法")）`Object.prototype.hasOwnProperty`：
- en: '[PRE343]'
  id: totrans-1505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'There are other, more comfortable, means for iterating over property keys,
    which are described in [Best Practices: Iterating over Own Properties](ch17_split_000.html#object_iteration
    "Best Practices: Iterating over Own Properties").'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他更舒适的方法可以遍历属性键，这些方法在[最佳实践：遍历自有属性](ch17_split_000.html#object_iteration "最佳实践：遍历自有属性")中有描述。
- en: for each-in
  id: totrans-1507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于每个-在
- en: This loop exists only on Firefox. Don’t use it.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环只存在于Firefox上。不要使用它。
- en: Conditionals
  id: totrans-1509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件
- en: This section covers JavaScript’s conditional statements.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了JavaScript的条件语句。
- en: if-then-else
  id: totrans-1511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if-then-else
- en: 'In an `if-then-else` statement:'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if-then-else`语句中：
- en: '[PRE344]'
  id: totrans-1513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '`then_branch` and `else_branch` can be either single statements or blocks of
    statements (see [The Bodies of Loops and Conditionals](ch13.html#loops_conditionals_bodies
    "The Bodies of Loops and Conditionals")).'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: '`then_branch`和`else_branch`可以是单个语句或语句块（参见[循环和条件的主体](ch13.html#loops_conditionals_bodies
    "循环和条件的主体")）。'
- en: Chaining if statements
  id: totrans-1515
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链接if语句
- en: 'You can chain several `if` statements:'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以链接几个`if`语句：
- en: '[PRE345]'
  id: totrans-1517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: Note that in the preceding example, all the `else` branches are single statements
    (`if` statements). Programming languages that only allow blocks for `else` branches
    need some kind of `else-if` branch for chaining.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的例子中，所有的`else`分支都是单个语句（`if`语句）。只允许`else`分支为块的编程语言需要一些类似`else-if`分支的东西来进行链接。
- en: 'Pitfall: dangling else'
  id: totrans-1519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：悬空的else
- en: 'The `else` branch of the following example is called *dangling*, because it
    is not clear to which of the two `if` statements it belongs:'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例的`else`分支被称为“悬空”，因为不清楚它属于两个`if`语句中的哪一个：
- en: '[PRE346]'
  id: totrans-1521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: 'Here’s a simple rule: use braces. The preceding snippet is equivalent to the
    following code (where it is obvious who the `else` belongs to):'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的规则：使用大括号。前面的片段等同于以下代码（在这里很明显`else`属于谁）：
- en: '[PRE347]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: switch
  id: totrans-1524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: switch
- en: 'A `switch` statement:'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`switch`语句：
- en: '[PRE348]'
  id: totrans-1526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: evaluates `expression` and then jumps to the `case` clause whose label matches
    the result. If no label matches, `switch` jumps to the `default` clause if it
    exists or does nothing otherwise.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 评估`expression`，然后跳转到与结果匹配的`case`子句。如果没有匹配的标签，`switch`会跳转到`default`子句（如果存在）或者不执行任何操作。
- en: The “operand” after `case` can be any expression; it is compared via `===` with
    the parameter of `switch`.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`后的“操作数”可以是任何表达式；它通过`===`与`switch`的参数进行比较。'
- en: If you don’t finish a clause with a terminating statement, execution continues
    into the next clause. The most frequently used terminating statement is `break`.
    But `return` and `throw` also work, even though they normally leave more than
    just the `switch` statement.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用终止语句结束子句，执行将继续到下一个子句。最常用的终止语句是`break`。但是`return`和`throw`也可以工作，尽管它们通常不仅仅离开`switch`语句。
- en: 'The following example illustrates that you don’t need to `break` if you use
    `throw` or `return`:'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如果使用`throw`或`return`，则不需要`break`：
- en: '[PRE349]'
  id: totrans-1531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: 'In this example, there is no `default` clause. Therefore, nothing happens if
    `fruit` matches none of the `case` labels:'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，没有`default`子句。因此，如果`fruit`不匹配任何`case`标签，则什么也不会发生：
- en: '[PRE350]'
  id: totrans-1533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: 'Here, there are multiple `case` labels in a row:'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有多个连续的`case`标签：
- en: '[PRE351]'
  id: totrans-1535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: 'This example demonstrates that the value after `case` can be an arbitrary expression:'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了`case`后面的值可以是任意表达式：
- en: '[PRE352]'
  id: totrans-1537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: 'The preceding `switch` statement looks for a match for its parameter `true`
    by going through the `case` clauses. If one of the `case` expressions evaluates
    to `true`, the corresponding `case` body is executed. Therefore, the preceding
    code is equivalent to the following `if` statement:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`switch`语句通过遍历`case`子句来寻找其参数`true`的匹配项。如果其中一个`case`表达式求值为`true`，则执行相应的`case`主体。因此，前面的代码等同于以下`if`语句：
- en: '[PRE353]'
  id: totrans-1539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: You normally should prefer the latter solution; it is more self-explanatory.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 通常应该更喜欢后一种解决方案；它更加自解释。
- en: The with Statement
  id: totrans-1541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`with`语句'
- en: This section explains how the `with` statement works in JavaScript and why its
    use is discouraged.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了`with`语句在JavaScript中的工作原理以及为什么不鼓励使用它。
- en: Syntax and Semantics
  id: totrans-1543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法和语义
- en: 'The syntax of the `with` statement is as follows:'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句的语法如下：'
- en: '[PRE354]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'It turns the properties of `object` into local variables for `statement`. For
    example:'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 它将`object`的属性转换为`statement`的局部变量。例如：
- en: '[PRE355]'
  id: totrans-1547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'Its intended use is to avoid redundancy when accessing an object several times.
    The following is an example of code with redundancies:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 它的预期用途是在多次访问对象时避免冗余。以下是一个带有冗余的代码示例：
- en: '[PRE356]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '`with` makes this shorter:'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`使这更短：'
- en: '[PRE357]'
  id: totrans-1551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: The with Statement Is Deprecated
  id: totrans-1552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`with`语句已被弃用'
- en: 'The use of the `with` statement is generally discouraged (the next section
    explains why). For example, it is forbidden in strict mode:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不鼓励使用`with`语句（下一节解释了原因）。例如，在严格模式下是禁止的：
- en: '[PRE358]'
  id: totrans-1554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: Techniques for avoiding the with statement
  id: totrans-1555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 避免使用`with`语句的技巧
- en: 'Avoid code like this:'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这样的代码：
- en: '[PRE359]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'Instead, use a temporary variable with a short name:'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 而是使用一个短名称的临时变量：
- en: '[PRE360]'
  id: totrans-1559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: 'If you don’t want to expose the temporary variable `b` to the current scope,
    you can use an IIFE (see [Introducing a New Scope via an IIFE](ch16.html#iife
    "Introducing a New Scope via an IIFE")):'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想将临时变量`b`暴露给当前作用域，可以使用IIFE（参见[通过IIFE引入新作用域](ch16.html#iife "通过IIFE引入新作用域")）：
- en: '[PRE361]'
  id: totrans-1561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: 'You also have the option of making the object that you want to access a parameter
    of the IIFE:'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择将要访问的对象作为IIFE的参数：
- en: '[PRE362]'
  id: totrans-1563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: The Rationale for the Deprecation
  id: totrans-1564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弃用的原因
- en: 'To understand why `with` is deprecated, look at the following example and notice
    how the function’s argument completely changes how it works:'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么`with`被弃用，请看下面的例子，并注意函数的参数如何完全改变了它的工作方式：
- en: '[PRE363]'
  id: totrans-1566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: 'If `opts` has a property `msg`, then the statement in line (1) doesn’t access
    the parameter `msg` anymore. It accesses the property:'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`opts`有一个`msg`属性，那么第（1）行的语句不再访问参数`msg`。它访问属性：
- en: '[PRE364]'
  id: totrans-1568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'There are three problems that the `with` statement causes:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句引起了三个问题：'
- en: Performance suffers
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 性能下降
- en: Variable lookup becomes slower, because an object is temporarily inserted into
    the scope chain.
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 变量查找变慢，因为对象被临时插入到作用域链中。
- en: Code becomes less predictable
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 代码变得不太可预测
- en: 'You cannot determine what an identifier refers to by looking at its syntactic
    surroundings (its lexical context). According to [Brendan Eich](http://bit.ly/1jCrTKj),
    that was the actual reason why `with` was deprecated, not performance considerations:'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法通过查看其语法环境（其词法上下文）来确定标识符指的是什么。根据[Brendan Eich](http://bit.ly/1jCrTKj)的说法，这才是`with`被弃用的实际原因，而不是性能考虑：
- en: '`with` violates lexical scope, making program analysis (e.g. for security)
    hard to infeasible.'
  id: totrans-1574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`with`违反了词法作用域，使程序分析（例如安全性）变得困难或不可行。'
- en: Minifiers (described in [Chapter 32](ch32.html "Chapter 32. More Tools")) can’t
    shorten variable names
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小器（在[第32章](ch32.html "第32章。更多工具")中描述）无法缩短变量名
- en: Inside a `with` statement, you can’t statically determine whether a name refers
    to a variable or a property. Only variables can be renamed by minifiers.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with`语句内部，无法静态确定名称是指变量还是属性。缩小器只能重命名变量。
- en: 'Here is an example of `with` making code brittle:'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`with`使代码变得脆弱的示例：
- en: '[PRE365]'
  id: totrans-1578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: You can prevent the function call in line (3) from working, even if you don’t
    have access to the array `myData`.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您无法访问数组`myData`，也可以阻止行（3）中的函数调用起作用。
- en: 'How? By adding a property `values` to `Array.prototype`. For example:'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 如何？通过向`Array.prototype`添加一个属性`values`。例如：
- en: '[PRE366]'
  id: totrans-1581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: Now the code in line (2) calls `someArray.values.someMethod()` instead of `values.someMethod()`.
    The reason is that, inside the `with` statement, `values` now refers to `someArray.values`
    and not the local variable from line (1) anymore.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，行（2）中的代码调用`someArray.values.someMethod()`而不是`values.someMethod()`。原因是，在`with`语句内，`values`现在指的是`someArray.values`，而不再是行（1）中的局部变量。
- en: 'This is not just a thought experiment: the array method `values()` was added
    to Firefox and broke the TYPO3 content management system. [Brandon Benvie figured
    out what went wrong](http://mzl.la/1jCrXti).'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是一个思想实验：数组方法`values()`已添加到Firefox并破坏了TYPO3内容管理系统。[Brandon Benvie找出了问题所在](http://mzl.la/1jCrXti)。
- en: The debugger Statement
  id: totrans-1584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试器语句
- en: 'The syntax for the `debugger` statement is as follows:'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: '`debugger`语句的语法如下：'
- en: '[PRE367]'
  id: totrans-1586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: If a debugger is active, this statement functions as a breakpoint; if not, it
    has no observable effect.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调试器处于活动状态，此语句将作为断点；如果没有，它没有可观察的效果。
- en: Chapter 14. Exception Handling
  id: totrans-1588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第14章。异常处理
- en: This chapter describes how JavaScript’s exception handling works. It begins
    with a general explanation of what exception handling is.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了JavaScript的异常处理工作原理。它从异常处理的一般解释开始。
- en: What Is Exception Handling?
  id: totrans-1590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是异常处理？
- en: In exception handling, you often group statements that are tightly coupled.
    If, while you are executing those statements, one of them causes an error, then
    it makes no sense to continue with the remaining statements. Instead, you try
    to recover from the error as gracefully as you can. This is loosely reminiscent
    of transactions (but without the atomicity).
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常处理中，通常会将紧密耦合的语句分组在一起。如果在执行这些语句时，其中一个导致错误，那么继续执行剩余的语句就没有意义了。相反，您尝试尽可能优雅地从错误中恢复。这在某种程度上类似于事务（但没有原子性）。
- en: 'Let’s look at code without exception handling:'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下没有异常处理的代码：
- en: '[PRE368]'
  id: totrans-1593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'What is the best way to react to an error in `openFile()` at (2)? Clearly,
    the statement (1) should not be executed anymore. But we wouldn’t want to abort
    `extractAllEntries()`, either. Instead, it is enough to skip the current file
    and continue with the next one. To do that, we add exception handling to the previous
    code:'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 在（2）处的`openFile()`中，对错误做出反应的最佳方法是什么？显然，不应再执行语句（1）。但我们也不想中止`extractAllEntries()`。相反，足够的是跳过当前文件并继续下一个。为此，我们在先前的代码中添加异常处理：
- en: '[PRE369]'
  id: totrans-1595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: 'There are two aspects to exception handling:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理有两个方面：
- en: If there is a problem that can’t be handled meaningfully where it occurs, throw
    an exception.
  id: totrans-1597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在发生错误的地方无法有意义地处理问题，请抛出异常。
- en: 'Find a place where errors can be handled: catch exceptions.'
  id: totrans-1598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到可以处理错误的地方：捕获异常。
- en: 'At (1), the following constructs are active:'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 在（1）处，以下结构是活动的：
- en: '[PRE370]'
  id: totrans-1600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: The `throw` statement at (1) walks up that tree and leaves all constructs until
    it encounters an active `try` statement. It then invokes that statement’s `catch`
    block and passes it the exception value.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 在（1）处的`throw`语句沿着树向上走，并离开所有结构，直到遇到一个活动的`try`语句。然后调用该语句的`catch`块并将异常值传递给它。
- en: Exception Handling in JavaScript
  id: totrans-1602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript中的异常处理
- en: 'Exception handling in JavaScript works like in most programming languages:
    a `try` statement groups statements and lets you intercept exceptions in those
    statements.'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的异常处理与大多数编程语言一样：`try`语句将语句分组，并允许您拦截这些语句中的异常。
- en: throw
  id: totrans-1604
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: throw
- en: 'The syntax of `throw` is as follows:'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`的语法如下：'
- en: '[PRE371]'
  id: totrans-1606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: 'Any JavaScript value can be thrown. For simplicity’s sake, many JavaScript
    programs just throw strings:'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 任何JavaScript值都可以被抛出。为了简单起见，许多JavaScript程序只抛出字符串：
- en: '[PRE372]'
  id: totrans-1608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'Don’t do this. JavaScript has special constructors for exception objects (see
    [Error Constructors](ch14.html#error_constructors "Error Constructors")). Use
    those or subclass them (see [Chapter 28](ch28.html "Chapter 28. Subclassing Built-ins")).
    Their advantage is that JavaScript automatically adds a stack trace (on most engines)
    and that they have room for additional context-specific properties. The simplest
    solution is to use the built-in constructor `Error()`:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 不要这样做。JavaScript有专门的异常对象构造函数（参见[错误构造函数](ch14.html#error_constructors "错误构造函数")）。使用它们或对其进行子类化（参见[第28章](ch28.html
    "第28章。内置子类")）。它们的优势是JavaScript会自动添加堆栈跟踪（在大多数引擎上），并且它们有额外的上下文特定属性的空间。最简单的解决方案是使用内置构造函数`Error()`：
- en: '[PRE373]'
  id: totrans-1610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: try-catch-finally
  id: totrans-1611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: try-catch-finally
- en: 'The syntax of `try-catch-finally` looks as follows. `try` is mandatory, and
    at least one of `catch` and `finally` must be there, too:'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: '`try-catch-finally`的语法如下。`try`是必需的，`catch`和`finally`至少有一个也必须存在：'
- en: '[PRE374]'
  id: totrans-1613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: 'Here’s how it works:'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的：
- en: '`catch` catches any exception that is thrown in `try_statements`, whether directly
    or in functions they invoke. Tip: If you want to distinguish between different
    kinds of exceptions, you can use the `constructor` property to switch over the
    exceptions’ constructors (see [Use cases for the constructor property](ch17_split_001.html#switch_constructor
    "Use cases for the constructor property")).'
  id: totrans-1615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch`捕获在`try_statements`中抛出的任何异常，无论是直接抛出还是在它们调用的函数中。提示：如果要区分不同类型的异常，可以使用`constructor`属性来切换异常的构造函数（请参阅[构造函数属性的用例](ch17_split_001.html#switch_constructor
    "构造函数属性的用例")）。'
- en: '`finally` is always executed, no matter what happens in `try_statements` (or
    in functions they invoke). Use it for clean-up operations that should always be
    performed, no matter what happens in `try_statements`:'
  id: totrans-1616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finally`总是被执行，无论`try_statements`中发生了什么（或者它们调用的函数中发生了什么）。用它来进行应该始终执行的清理操作，无论`try_statements`中发生了什么：'
- en: '[PRE375]'
  id: totrans-1617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: If one of the `try_statements` is a `return`, then the `try` block is executed
    afterward (immediately before leaving the function or method; see the examples
    that follow).
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`try_statements`中有一个`return`，则`try`块会在之后执行（在离开函数或方法之前立即执行；请参阅接下来的示例）。
- en: Examples
  id: totrans-1619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 例子
- en: 'Any value can be thrown:'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 任何值都可以被抛出：
- en: '[PRE376]'
  id: totrans-1621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: 'Here is the interaction:'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE377]'
  id: totrans-1623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '`finally` is always executed:'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`总是被执行：'
- en: '[PRE378]'
  id: totrans-1625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: 'Here is the interaction:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE379]'
  id: totrans-1627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '`finally` is executed *after* a `return` statement:'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`在`return`语句之后执行：'
- en: '[PRE380]'
  id: totrans-1629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'Here is the interaction:'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE381]'
  id: totrans-1631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: 'The return value is queued before executing `finally`:'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`finally`之前，返回值已排队：
- en: '[PRE382]'
  id: totrans-1633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'By the time statement (1) is executed, the value of `count` has already been
    queued for returning:'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行语句（1）时，`count`的值已经排队返回：
- en: '[PRE383]'
  id: totrans-1635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: Error Constructors
  id: totrans-1636
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误构造函数
- en: 'ECMAScript standardizes the following error constructors. The descriptions
    are quoted from the ECMAScript 5 specification:'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript标准化以下错误构造函数。描述摘自ECMAScript 5规范：
- en: '`Error` is a generic constructor for errors. All other error constructors mentioned
    here are subconstructors.'
  id: totrans-1638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Error`是错误的通用构造函数。这里提到的所有其他错误构造函数都是子构造函数。'
- en: '`EvalError` “is not currently used within this specification. This object remains
    for compatibility with previous editions of this specification.”'
  id: totrans-1639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EvalError`“在本规范中当前未使用。此对象保留用于与本规范先前版本的兼容性。”'
- en: '`RangeError` “indicates a numeric value has exceeded the allowable range.”
    For example:'
  id: totrans-1640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RangeError`“表示数字值超出了允许的范围。”例如：'
- en: '[PRE384]'
  id: totrans-1641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '`ReferenceError` “indicates that an invalid reference value has been detected.”
    Usually, this is an unknown variable. For example:'
  id: totrans-1642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReferenceError`“表示检测到无效引用值。”通常，这是一个未知的变量。例如：'
- en: '[PRE385]'
  id: totrans-1643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '`SyntaxError` “indicates that a parsing error has occurred”—for example, while
    parsing code via `eval()`:'
  id: totrans-1644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SyntaxError`“表示发生了解析错误”——例如，通过`eval()`解析代码时：'
- en: '[PRE386]'
  id: totrans-1645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '`TypeError` “indicates the actual type of an operand is different than the
    expected type.” For example:'
  id: totrans-1646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeError`“表示操作数的实际类型与预期类型不同。”例如：'
- en: '[PRE387]'
  id: totrans-1647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '`URIError` “indicates that one of the global URI handling functions was used
    in a way that is incompatible with its definition.” For example:'
  id: totrans-1648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URIError`“表示以与其定义不兼容的方式使用了全局URI处理函数之一。”例如：'
- en: '[PRE388]'
  id: totrans-1649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: 'Here are the properties of errors:'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是错误的属性：
- en: '`message`'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: '`message`'
- en: The error message.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息。
- en: '`name`'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`'
- en: The name of the error.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的名称。
- en: '`stack`'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: '`stack`'
- en: A stack trace. This is nonstandard, but is available on many platforms—for example,
    Chrome, Node.js, and Firefox.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪。这是非标准的，但在许多平台上都可用，例如Chrome，Node.js和Firefox。
- en: Stack Traces
  id: totrans-1657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈跟踪
- en: 'The usual sources of errors are either external (wrong input, missing file,
    etc.) or internal (a bug in the program). Especially in the latter case, you will
    get unexpected exceptions and need to debug. Often you don’t have a debugger running.
    For “manual” debugging, two pieces of information are helpful:'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的常见来源要么是外部的（错误的输入，丢失的文件等），要么是内部的（程序中的错误）。特别是在后一种情况下，您将收到意外的异常并需要进行调试。通常情况下，您没有运行调试器。对于“手动”调试，有两条信息是有帮助的：
- en: 'Data: What values do variables have?'
  id: totrans-1659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据：变量具有什么值？
- en: 'Execution: In what line did the exception happen, and what function calls were
    active?'
  id: totrans-1660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行：异常发生在哪一行，活动的函数调用是什么？
- en: 'You can put some of the first item (data) into either the message or the properties
    of an exception object. The second item (execution) is supported on many JavaScript
    engines via *stack traces*, snapshots of the call stack when the exception objects
    were created. The following example prints a stack trace:'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将第一项（数据）的一些内容放入消息或异常对象的属性中。第二项（执行）在许多JavaScript引擎上通过*堆栈跟踪*得到支持，这是在创建异常对象时调用堆栈的快照。以下示例打印堆栈跟踪：
- en: '[PRE389]'
  id: totrans-1662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: 'Here’s the interaction:'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE390]'
  id: totrans-1664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: Implementing Your Own Error Constructor
  id: totrans-1665
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现您自己的错误构造函数
- en: If you want stack traces, you need the services of the built-in error constructors.
    You can use an existing constructor and attach your own data to it. Or you can
    create a subconstructor, whose instances can be distinguished from those of other
    error constructors via `instanceof`. Alas, doing so (for built-in constructors)
    is complicated; see [Chapter 28](ch28.html "Chapter 28. Subclassing Built-ins")
    to learn how to do it.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要堆栈跟踪，您需要内置错误构造函数的服务。您可以使用现有构造函数并将自己的数据附加到其中。或者您可以创建一个子构造函数，其实例可以通过`instanceof`与其他错误构造函数的实例区分开来。然而，这样做（对于内置构造函数）是复杂的；请参阅[第28章](ch28.html
    "第28章。内置子类")以了解如何做到这一点。
- en: Chapter 15. Functions
  id: totrans-1667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15章。函数
- en: 'Functions are values that can be called. One way of defining a function is
    called a *function declaration*. For example, the following code defines the function
    `id` that has a single parameter, `x`:'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是可以调用的值。定义函数的一种方式称为*函数声明*。例如，以下代码定义了具有单个参数`x`的函数`id`：
- en: '[PRE391]'
  id: totrans-1669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: 'The `return` statement returns a value from `id`. You can call a function by
    mentioning its name, followed by arguments in parentheses:'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句从`id`返回一个值。您可以通过提及其名称，后跟括号中的参数来调用函数：'
- en: '[PRE392]'
  id: totrans-1671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'If you don’t return anything from a function, `undefined` is returned (implicitly):'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从函数中不返回任何内容，则返回`undefined`（隐式）：
- en: '[PRE393]'
  id: totrans-1673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: This section showed just one way of defining and one way of calling a function.
    Others are described later.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅展示了定义函数的一种方式和调用函数的一种方式。其他方式将在后面描述。
- en: The Three Roles of Functions in JavaScript
  id: totrans-1675
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript中函数的三种角色
- en: 'Once you have defined a function as just shown, it can play several roles:'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您像刚才所示那样定义了一个函数，它可以扮演多种角色：
- en: Nonmethod function (“normal function”)
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 非方法函数（“普通函数”）
- en: 'You can call a function directly. Then it works as a normal function. Here’s
    an example invocation:'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接调用函数。然后它将作为普通函数工作。以下是一个示例调用：
- en: '[PRE394]'
  id: totrans-1679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: By convention, the names of normal functions start with lowercase letters.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，普通函数的名称以小写字母开头。
- en: Constructor
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'You can invoke a function via the `new` operator. Then it becomes a constructor,
    a factory for objects. Here’s an example invocation:'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`new`运算符调用函数。然后它变成一个构造函数，一个对象的工厂。以下是一个示例调用：
- en: '[PRE395]'
  id: totrans-1683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: By convention, the names of constructors start with uppercase letters.
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，构造函数的名称以大写字母开头。
- en: Method
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 方法
- en: 'You can store a function in a property of an object, which turns it into a
    *method* that you can invoke via that object. Here’s an example invocation:'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将函数存储在对象的属性中，这将使其成为一个*方法*，您可以通过该对象调用它。以下是一个示例调用：
- en: '[PRE396]'
  id: totrans-1687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: By convention, the names of methods start with lowercase letters.
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，方法的名称以小写字母开头。
- en: Nonmethod functions are explained in this chapter; constructors and methods
    are explained in [Chapter 17](ch17_split_000.html "Chapter 17. Objects and Inheritance").
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 非方法函数在本章中有解释；构造函数和方法在[第17章](ch17_split_000.html "第17章。对象和继承")中有解释。
- en: 'Terminology: “Parameter” Versus “Argument”'
  id: totrans-1690
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语：“参数”与“参数”
- en: The terms *parameter* and *argument* are often used interchangeably, because
    the context usually makes it clear what the intended meaning is. The following
    is a rule of thumb for distinguishing them.
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*参数*和*参数*通常可以互换使用，因为上下文通常可以清楚地表明所需的含义。以下是区分它们的一个经验法则。
- en: '*Parameters* are used to define a function. They are also called formal parameters
    and formal arguments. In the following example, `param1` and `param2` are parameters:'
  id: totrans-1692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数*用于定义函数。它们也被称为形式参数和形式参数。在下面的例子中，`param1`和`param2`是参数：'
- en: '[PRE397]'
  id: totrans-1693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '*Arguments* are used to invoke a function. They are also called actual parameters
    and actual arguments. In the following example, `3` and `7` are arguments:'
  id: totrans-1694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数*用于调用函数。它们也被称为实际参数和实际参数。在下面的例子中，`3`和`7`是参数：'
- en: '[PRE398]'
  id: totrans-1695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: Defining Functions
  id: totrans-1696
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义函数
- en: 'This section describes three ways to create a function:'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了创建函数的三种方法：
- en: Via a function expression
  id: totrans-1698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过函数表达式
- en: Via a function declaration
  id: totrans-1699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过函数声明
- en: Via the constructor `Function()`
  id: totrans-1700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构造函数`Function()`
- en: 'All functions are objects, instances of `Function`:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数都是对象，是`Function`的实例：
- en: '[PRE399]'
  id: totrans-1702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Therefore, functions get their methods from `Function.prototype`.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数从`Function.prototype`获取它们的方法。
- en: Function Expressions
  id: totrans-1704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数表达式
- en: 'A function expression produces a value—a function object. For example:'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式产生一个值 - 一个函数对象。例如：
- en: '[PRE400]'
  id: totrans-1706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: The preceding code assigned the result of a function expression to the variable
    `add` and called it via that variable. The value produced by a function expression
    can be assigned to a variable (as shown in the last example), passed as an argument
    to another function, and more. Because normal function expressions don’t have
    a name, they are also called *anonymous function expressions*.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将函数表达式的结果分配给变量`add`，并通过该变量调用它。函数表达式产生的值可以分配给一个变量（如最后一个例子中所示），作为另一个函数的参数传递，等等。因为普通函数表达式没有名称，它们也被称为*匿名函数表达式*。
- en: Named function expressions
  id: totrans-1708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命名函数表达式
- en: 'You can give a function expression a name. *Named function expressions* allow
    a function expression to refer to itself, which is useful for self-recursion:'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以给函数表达式一个名称。*命名函数表达式*允许函数表达式引用自身，这对于自我递归很有用：
- en: '[PRE401]'
  id: totrans-1710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: Note
  id: totrans-1711
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The name of a named function expression is only accessible inside the function
    expression:'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数表达式的名称只能在函数表达式内部访问：
- en: '[PRE402]'
  id: totrans-1713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: Function Declarations
  id: totrans-1714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数声明
- en: 'The following is a function declaration:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个函数声明：
- en: '[PRE403]'
  id: totrans-1716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: 'The preceding looks like a function expression, but it is a statement (see
    [Expressions Versus Statements](ch07.html#expr_vs_stmt "Expressions Versus Statements")).
    It is roughly equivalent to the following code:'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码看起来像一个函数表达式，但它是一个语句（参见[表达式与语句](ch07.html#expr_vs_stmt "表达式与语句")）。它大致相当于以下代码：
- en: '[PRE404]'
  id: totrans-1718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: In other words, a function declaration declares a new variable, creates a function
    object, and assigns it to the variable.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，函数声明声明一个新变量，创建一个函数对象，并将其分配给变量。
- en: The Function Constructor
  id: totrans-1720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数构造函数
- en: 'The constructor `Function()` evaluates JavaScript code stored in strings. For
    example, the following code is equivalent to the previous example:'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数`Function()`评估存储在字符串中的JavaScript代码。例如，以下代码等同于前面的例子：
- en: '[PRE405]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: However, this way of defining a function is slow and keeps code in strings (inaccessible
    to tools). Therefore, it is much better to use a function expression or a function
    declaration if possible. [Evaluating Code Using new Function()](ch23.html#function_constructor
    "Evaluating Code Using new Function()") explains `Function()` in more detail;
    it works similarly to `eval()`.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种定义函数的方式很慢，并且将代码保留在字符串中（无法访问工具）。因此，最好尽可能使用函数表达式或函数声明。[使用new Function()评估代码](ch23.html#function_constructor
    "使用new Function()评估代码")更详细地解释了`Function()`；它的工作方式类似于`eval()`。
- en: Hoisting
  id: totrans-1724
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升
- en: '*Hoisting* means “moving to the beginning of a scope.” Function declarations
    are hoisted completely, variable declarations only partially.'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: '*提升*意味着“移动到作用域的开头”。函数声明完全提升，变量声明只部分提升。'
- en: 'Function declarations are completely hoisted. That allows you to call a function
    before it has been declared:'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明完全被提升。这允许您在声明之前调用函数：
- en: '[PRE406]'
  id: totrans-1727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: 'The reason the preceding code works is that JavaScript engines move the declaration
    of `foo` to the beginning of the scope. They execute the code as if it looked
    like this:'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码之所以有效是因为JavaScript引擎将`foo`的声明移动到作用域的开头。它们执行代码，就好像它看起来是这样的：
- en: '[PRE407]'
  id: totrans-1729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '`var` declarations are hoisted, too, but only the declarations, not assignments
    made with them. Therefore, using a `var` declaration and a function expression
    similarly to the previous example results in an error:'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`声明也会被提升，但只有声明，而不是使用它们进行的赋值。因此，类似于前面的例子使用`var`声明和函数表达式会导致错误：'
- en: '[PRE408]'
  id: totrans-1731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: 'Only the variable declaration is hoisted. The engine executes the preceding
    code as:'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: 只有变量声明被提升。引擎执行前面的代码如下：
- en: '[PRE409]'
  id: totrans-1733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: The Name of a Function
  id: totrans-1734
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的名称
- en: 'Most JavaScript engines support the nonstandard property `name` for function
    objects. Function declarations have it:'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JavaScript引擎支持函数对象的非标准属性`name`。函数声明具有它：
- en: '[PRE410]'
  id: totrans-1736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: 'The name of anonymous function expressions is the empty string:'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数表达式的名称是空字符串：
- en: '[PRE411]'
  id: totrans-1738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: 'Named function expressions, however, do have a name:'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，命名函数表达式确实有一个名称：
- en: '[PRE412]'
  id: totrans-1740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: The name of a function is useful for debugging. Some people always give their
    function expressions names for that reason.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的名称对于调试很有用。有些人总是给他们的函数表达式命名。
- en: 'Which Is Better: A Function Declaration or a Function Expression?'
  id: totrans-1742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪个更好：函数声明还是函数表达式？
- en: Should you prefer a function declaration like the following?
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否更喜欢以下的函数声明？
- en: '[PRE413]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: Or the equivalent combination of a `var` declaration plus a function expression?
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 或者等效的`var`声明加上函数表达式的组合？
- en: '[PRE414]'
  id: totrans-1746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: 'They are basically the same, but function declarations have two advantages
    over function expressions:'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 它们基本上是相同的，但是函数声明比函数表达式有两个优点：
- en: They are hoisted (see [Hoisting](ch15.html#function_hoisting "Hoisting")), so
    you can call them before they appear in the source code.
  id: totrans-1748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们被提升（参见[提升](ch15.html#function_hoisting "Hoisting")），因此您可以在它们出现在源代码中之前调用它们。
- en: They have a name (see [The Name of a Function](ch15.html#function_names "The
    Name of a Function")). However, JavaScript engines are getting better at inferring
    the names of anonymous function expressions.
  id: totrans-1749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个名称（请参见[函数的名称](ch15.html#function_names "函数的名称"））。但是，JavaScript引擎正在更好地推断匿名函数表达式的名称。
- en: 'More Control over Function Calls: call(), apply(), and bind()'
  id: totrans-1750
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对函数调用的更多控制：call()，apply()和bind()
- en: '`call()`, `apply()`, and `bind()` are methods that all functions have (remember
    that functions are objects and therefore have methods). They can supply a value
    for `this` when invoking a method and thus are mainly interesting in an object-oriented
    context (see [Calling Functions While Setting this: call(), apply(), and bind()](ch17_split_000.html#oop_call_apply_bind
    "Calling Functions While Setting this: call(), apply(), and bind()")). This section
    explains two use cases for nonmethods.'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: '`call()`，`apply()`和`bind()`是所有函数都具有的方法（请记住函数是对象，因此具有方法）。它们可以在调用方法时提供`this`的值，因此主要在面向对象的上下文中很有趣（参见[调用函数时设置this：call()，apply()和bind()](ch17_split_000.html#oop_call_apply_bind
    "调用函数时设置this：call()，apply()和bind()"））。本节解释了非方法的两种用法。'
- en: func.apply(thisValue, argArray)
  id: totrans-1752
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: func.apply(thisValue, argArray)
- en: 'This method uses the elements of `argArray` as arguments while calling the
    function `func`; that is, the following two expressions are equivalent:'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在调用函数`func`时使用`argArray`的元素作为参数；也就是说，以下两个表达式是等价的：
- en: '[PRE415]'
  id: totrans-1754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '`thisValue` is the value that `this` has while executing `func`. It is not
    needed in a non-object-oriented setting and is thus `null` here.'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: '`thisValue`是在执行`func`时`this`的值。在非面向对象的设置中不需要它，因此在这里是`null`。'
- en: '`apply()` is useful whenever a function accepts multiple arguments in an array-like
    manner, but not an array.'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()`在函数以类似数组的方式接受多个参数时很有用，但不是一个数组。'
- en: 'Thanks to `apply()`, we can use `Math.max()` (see [Other Functions](ch21.html#Math_max
    "Other Functions")) to determine the maximum element of an array:'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`apply()`，我们可以使用`Math.max()`（参见[其他函数](ch21.html#Math_max "其他函数"））来确定数组的最大元素：
- en: '[PRE416]'
  id: totrans-1758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: func.bind(thisValue, arg1, ..., argN)
  id: totrans-1759
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: func.bind(thisValue, arg1, ..., argN)
- en: 'This performs *partial function application*—a new function is created that
    calls `func` with `this` set to `thisValue` and the following arguments: first
    `arg1` until `argN`, and then the actual arguments of the new function. `thisValue`
    is not needed in the following non-object-oriented setting, which is why it is
    `null`.'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 这执行*部分函数应用* - 创建一个新函数，该函数使用`thisValue`调用`func`，并使用以下参数：从`arg1`到`argN`，然后是新函数的实际参数。在以下非面向对象的设置中，不需要`thisValue`，这就是为什么它在这里是`null`。
- en: 'Here, we use `bind()` to create a new function `plus1()` that is like `add()`,
    but only requires the parameter `y`, because `x` is always 1:'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`bind()`创建一个新函数`plus1()`，它类似于`add()`，但只需要参数`y`，因为`x`始终为1：
- en: '[PRE417]'
  id: totrans-1762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: 'In other words, we have created a new function that is equivalent to the following
    code:'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们已经创建了一个等效于以下代码的新函数：
- en: '[PRE418]'
  id: totrans-1764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: Handling Missing or Extra Parameters
  id: totrans-1765
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理缺失或额外的参数
- en: 'JavaScript does not enforce a function’s arity: you can call it with any number
    of actual parameters, independent of what formal parameters have been defined.
    Hence, the number of actual parameters and formal parameters can differ in two
    ways:'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript不强制函数的arity：您可以使用任意数量的实际参数调用它，而不受已定义的形式参数的限制。因此，实际参数和形式参数的数量可以以两种方式不同：
- en: More actual parameters than formal parameters
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 实际参数比形式参数多
- en: The extra parameters are ignored but can be retrieved via the special array-like
    variable `arguments` (discussed momentarily).
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的参数将被忽略，但可以通过特殊的类数组变量`arguments`检索（稍后讨论）。
- en: Fewer actual parameters than formal parameters
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 实际参数比形式参数少
- en: The missing formal parameters all have the value `undefined`.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 所有缺失的形式参数都具有值`undefined`。
- en: 'All Parameters by Index: The Special Variable arguments'
  id: totrans-1771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按索引获取所有参数：特殊变量arguments
- en: 'The special variable `arguments` exists only inside functions (including methods).
    It is an array-like object that holds all of the actual parameters of the current
    function call. The following code uses it:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊变量`arguments`仅存在于函数内（包括方法）。它是一个类似数组的对象，保存当前函数调用的所有实际参数。以下代码使用它：
- en: '[PRE419]'
  id: totrans-1773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: 'And here is the interaction:'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE420]'
  id: totrans-1775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '`arguments` has the following characteristics:'
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`具有以下特点：'
- en: It is array-like, but not an array. On one hand, it has a property `length`,
    and individual parameters can be read and written by index.
  id: totrans-1777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它类似于数组，但不是数组。一方面，它有一个`length`属性，可以通过索引读取和写入单个参数。
- en: On the other hand, `arguments` is not an array, it is only similar to one. It
    has none of the array methods (`slice()`, `forEach()`, etc.). Thankfully, you
    can borrow array methods or convert `arguments` to an array, as explained in [Array-Like
    Objects and Generic Methods](ch17_split_001.html#array-like_objects "Array-Like
    Objects and Generic Methods").
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`arguments`不是一个数组，它只是类似于数组。它没有任何数组方法（`slice()`，`forEach()`等）。幸运的是，您可以借用数组方法或将`arguments`转换为数组，如[类数组对象和通用方法](ch17_split_001.html#array-like_objects
    "类数组对象和通用方法")中所述。
- en: 'It is an object, so all object methods and operators are available. For example,
    you can use the `in` operator ([Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")) to check whether `arguments` “has” a
    given index:'
  id: totrans-1779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个对象，因此所有对象方法和运算符都是可用的。例如，你可以使用`in`运算符（[迭代和属性检测](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")）来检查`arguments`是否“有”给定的索引：
- en: '[PRE421]'
  id: totrans-1780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: 'You can use `hasOwnProperty()` ([Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")) in a similar manner:'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以类似的方式使用`hasOwnProperty()`（[迭代和属性检测](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")）：
- en: '[PRE422]'
  id: totrans-1782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: Deprecated features of arguments
  id: totrans-1783
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 已弃用的`arguments`特性
- en: 'Strict mode drops several of the more unusual features of `arguments`:'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式下会取消`arguments`的一些更不寻常的特性：
- en: '`arguments.callee` refers to the current function. It is mainly used to do
    self-recursion in anonymous functions, and is not allowed in strict mode. As a
    workaround, use a named function expression (see [Named function expressions](ch15.html#named_function_expression
    "Named function expressions")), which can refer to itself via its name.'
  id: totrans-1785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments.callee`指的是当前函数。它主要用于在匿名函数中进行自递归，并且在严格模式下是不允许的。作为一种解决方法，可以使用命名函数表达式（参见[命名函数表达式](ch15.html#named_function_expression
    "Named function expressions")），它可以通过其名称引用自身。'
- en: 'In nonstrict mode, `arguments` stays up-to-date if you change a parameter:'
  id: totrans-1786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非严格模式下，如果更改参数，`arguments`会保持最新：
- en: '[PRE423]'
  id: totrans-1787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: 'But this kind of updating is not done in strict mode:'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在严格模式下不会进行这种更新：
- en: '[PRE424]'
  id: totrans-1789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: Strict mode forbids assigning to the variable `arguments` (e.g., via `arguments++`).
    Assigning to elements and properties is still allowed.
  id: totrans-1790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格模式禁止对变量`arguments`进行赋值（例如通过`arguments++`）。仍然允许对元素和属性进行赋值。
- en: Mandatory Parameters, Enforcing a Minimum Arity
  id: totrans-1791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制参数，强制最小数量
- en: 'There are three ways to find out whether a parameter is missing. First, you
    can check if it is `undefined`:'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以找出参数是否缺失。首先，你可以检查它是否为`undefined`：
- en: '[PRE425]'
  id: totrans-1793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: 'Second, you can interpret the parameter as a boolean. Then `undefined` is considered
    `false`. However, there is a caveat: several other values are also considered
    `false` (see [Truthy and Falsy Values](ch10.html#truthy_falsy "Truthy and Falsy
    Values")), so the check cannot distinguish between, say, `0` and a missing parameter:'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你可以将参数解释为布尔值。然后`undefined`被视为`false`。但是，有一个警告：其他几个值也被视为`false`（参见[真值和假值](ch10.html#truthy_falsy
    "Truthy and Falsy Values")），因此检查无法区分，比如`0`和缺少的参数：
- en: '[PRE426]'
  id: totrans-1795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: 'Third, you can also check the length of `arguments` to enforce a minimum arity:'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你也可以检查`arguments`的长度以强制最小arity：
- en: '[PRE427]'
  id: totrans-1797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'The last approach differs from the other ones:'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法与其他方法不同：
- en: The first two approaches don’t distinguish between `foo()` and `foo(undefined)`.
    In both cases, an exception is thrown.
  id: totrans-1799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两种方法不区分`foo()`和`foo(undefined)`。在这两种情况下，都会抛出异常。
- en: The third approach throws an exception for `foo()` and sets `optional` to `undefined`
    for `foo(undefined)`.
  id: totrans-1800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种方法对`foo()`抛出异常，并对`foo(undefined)`将`optional`设置为`undefined`。
- en: Optional Parameters
  id: totrans-1801
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选参数
- en: If a parameter is optional, it means that you give it a default value if it
    is missing. Similarly to mandatory parameters, there are four alternatives.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是可选的，这意味着如果缺少参数，则给它一个默认值。与强制参数类似，有四种替代方案。
- en: 'First, check for `undefined`:'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查`undefined`：
- en: '[PRE428]'
  id: totrans-1804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: 'Second, interpret `optional` as a boolean:'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，将`optional`解释为布尔值：
- en: '[PRE429]'
  id: totrans-1806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: 'Third, you can use the Or operator `||` (see [Logical Or (||)](ch10.html#logical_or
    "Logical Or (||)")), which returns the left operand, if it isn’t falsy. Otherwise,
    it returns the right operand:'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你可以使用或运算符`||`（参见[逻辑或(||)](ch10.html#logical_or "Logical Or (||)")），如果左操作数不是假值，则返回左操作数。否则，返回右操作数：
- en: '[PRE430]'
  id: totrans-1808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: 'Fourth, you can check a function’s arity via `arguments.length`:'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，你可以通过`arguments.length`检查函数的arity：
- en: '[PRE431]'
  id: totrans-1810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: 'Again, the last approach differs from the other ones:'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，最后一种方法与其他方法不同：
- en: The first three approaches don’t distinguish between `bar(1, 2)` and `bar(1,
    2, undefined)`. In both cases, `optional` is `'default value'`.
  id: totrans-1812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前三种方法不区分`bar(1, 2)`和`bar(1, 2, undefined)`。在这两种情况下，`optional`都是`'default value'`。
- en: The fourth approach sets `optional` to `'default value'` for `bar(1, 2)` and
    leaves it `undefined` (i.e., unchanged) for `bar(1, 2, undefined)`.
  id: totrans-1813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四种方法为`bar(1, 2)`设置`optional`为`'default value'`，并且对于`bar(1, 2, undefined)`保持`undefined`（即不变）。
- en: Another possibility is to hand in optional parameters as *named parameters*,
    as properties of an object literal (see [Named Parameters](ch15.html#named_parameters
    "Named Parameters")).
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是将可选参数作为*命名参数*传递，作为对象字面量的属性（参见[命名参数](ch15.html#named_parameters "Named
    Parameters")）。
- en: Simulating Pass-by-Reference Parameters
  id: totrans-1815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟通过引用传递参数
- en: In JavaScript, you cannot pass parameters by reference; that is, if you pass
    a variable to a function, its value is copied and handed to the function (pass
    by value). Therefore, the function can’t change the variable. If you need to do
    so, you must wrap the value of the variable in an array.
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你不能通过引用传递参数；也就是说，如果你将一个变量传递给一个函数，它的值会被复制并传递给函数（按值传递）。因此，函数无法更改变量。如果需要这样做，必须将变量的值封装在数组中。
- en: 'This example demonstates a function that increments a variable:'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了一个增加变量的函数：
- en: '[PRE432]'
  id: totrans-1818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: 'Pitfall: Unexpected Optional Parameters'
  id: totrans-1819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 陷阱：意外的可选参数
- en: 'If you hand a function `c` as a parameter to another function `f`, then you
    have to be aware of two signatures:'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将函数`c`作为参数传递给另一个函数`f`，则必须了解两个签名：
- en: The signature that `f` expects its parameter to have. `f` might provide several
    parameters, and `c` can decide how many (if any) of them to use.
  id: totrans-1821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`期望其参数具有的签名。`f`可能提供多个参数，而`c`可以决定使用其中的多少（如果有的话）。'
- en: The actual signature of `c`. For example, it might support optional parameters.
  id: totrans-1822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`的实际签名。例如，它可能支持可选参数。'
- en: 'If the two diverge, then you can get unexpected results: `c` could have optional
    parameters that you don’t know about and that would interpret additional arguments
    provided by `f` incorrectly.'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两者不一致，那么您可能会得到意想不到的结果：`c`可能具有您不知道的可选参数，并且会错误地解释`f`提供的附加参数。
- en: 'As an example, consider the array method `map()` (see [Transformation Methods](ch18.html#Array.prototype.map
    "Transformation Methods")) whose parameter is normally a function with a single
    parameter:'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑数组方法`map()`（参见[转换方法](ch18.html#Array.prototype.map "转换方法"）），其参数通常是一个带有单个参数的函数：
- en: '[PRE433]'
  id: totrans-1825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: 'One function that you could pass as an argument is `parseInt()` (see [Integers
    via parseInt()](ch11.html#parseInt "Integers via parseInt()")):'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`parseInt()`作为参数传递给一个函数（参见[通过parseInt()获取整数](ch11.html#parseInt "通过parseInt()获取整数"））：
- en: '[PRE434]'
  id: totrans-1827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: 'You may (incorrectly) think that `map()` provides only a single argument and
    that `parseInt()` accepts only a single argument. Then you would be surprised
    by the following result:'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能（错误地）认为`map()`只提供了一个参数，而`parseInt()`只接受了一个参数。然后您会对以下结果感到惊讶：
- en: '[PRE435]'
  id: totrans-1829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '`map()` expects a function with the following signature:'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`期望具有以下签名的函数：'
- en: '[PRE436]'
  id: totrans-1831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: 'But `parseInt()` has the following signature:'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`parseInt()`具有以下签名：
- en: '[PRE437]'
  id: totrans-1833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'Thus, `map()` not only fills in `string` (via `element`), but also `radix`
    (via `index`). That means that the values of the preceding array are produced
    as follows:'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`map()`不仅填充了`string`（通过`element`），还填充了`radix`（通过`index`）。这意味着前面数组的值是这样产生的：
- en: '[PRE438]'
  id: totrans-1835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: 'To sum up, be careful with functions and methods whose signature you are not
    sure about. If you use them, it often makes sense to be explicit about what parameters
    are received and what parameters are passed on. That is achieved via a callback:'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，对于您不确定其签名的函数和方法要小心。如果使用它们，明确指定接收了哪些参数并传递了哪些参数通常是有意义的。这是通过回调函数实现的：
- en: '[PRE439]'
  id: totrans-1837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: Named Parameters
  id: totrans-1838
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名参数
- en: 'When calling a function (or method) in a programming language, you must map
    the actual parameters (specified by the caller) to the formal parameters (of a
    function definition). There are two common ways to do so:'
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用编程语言中的函数（或方法）时，您必须将实际参数（由调用者指定）映射到函数定义的形式参数。有两种常见的方法来实现这一点：
- en: '*Positional parameters* are mapped by position. The first actual parameter
    is mapped to the first formal parameter, the second actual to the second formal,
    and so on.'
  id: totrans-1840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*位置参数*按位置进行映射。第一个实际参数映射到第一个形式参数，第二个实际参数映射到第二个形式参数，依此类推。'
- en: '*Named parameters* use *names* (labels) to perform the mapping. Names are associated
    with formal parameters in a function definition and label actual parameters in
    a function call. It does not matter in which order named parameters appear, as
    long as they are correctly labeled.'
  id: totrans-1841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命名参数*使用*名称*（标签）执行映射。名称与函数定义中的形式参数相关联，并标记函数调用中的实际参数。命名参数出现的顺序并不重要，只要它们被正确标记。'
- en: 'Named parameters have two main benefits: they provide descriptions for arguments
    in function calls and they work well for optional parameters. I’ll first explain
    the benefits and then show you how to simulate named parameters in JavaScript
    via object literals.'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数有两个主要好处：它们为函数调用中的参数提供描述，并且对于可选参数也很有效。我将首先解释这些好处，然后向您展示如何通过对象字面量在JavaScript中模拟命名参数。
- en: Named Parameters as Descriptions
  id: totrans-1843
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名参数作为描述
- en: 'As soon as a function has more than one parameter, you might get confused about
    what each parameter is used for. For example, let’s say you have a function, `selectEntries()`,
    that returns entries from a database. Given the following function call:'
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数有多个参数，您可能会对每个参数的用途感到困惑。例如，假设您有一个名为`selectEntries()`的函数，它从数据库中返回条目。给定以下函数调用：
- en: '[PRE440]'
  id: totrans-1845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: 'what do these two numbers mean? Python supports named parameters, and they
    make it easy to figure out what is going on:'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个数字代表什么？Python支持命名参数，这使得很容易弄清楚发生了什么：
- en: '[PRE441]'
  id: totrans-1847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: Optional Named Parameters
  id: totrans-1848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选命名参数
- en: 'Optional positional parameters work well only if they are omitted at the end.
    Anywhere else, you have to insert placeholders such as `null` so that the remaining
    parameters have correct positions. With optional named parameters, that is not
    an issue. You can easily omit any of them. Here are some examples:'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 可选位置参数仅在末尾省略时才有效。在其他任何地方，您必须插入占位符，例如`null`，以便剩余参数具有正确的位置。对于可选命名参数，这不是问题。您可以轻松地省略其中任何一个。以下是一些示例：
- en: '[PRE442]'
  id: totrans-1850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: Simulating Named Parameters in JavaScript
  id: totrans-1851
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在JavaScript中模拟命名参数
- en: 'JavaScript does not have native support for named parameters like Python and
    many other languages. But there is a reasonably elegant simulation: name parameters
    via an object literal, passed as a single actual parameter. When you use this
    technique, an invocation of `selectEntries()` looks like:'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript不像Python和许多其他语言那样原生支持命名参数。但是有一个相当优雅的模拟方法：通过对象字面量命名参数，作为单个实际参数传递。当您使用这种技术时，`selectEntries()`的调用看起来像：
- en: '[PRE443]'
  id: totrans-1853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: 'The function receives an object with the properties `start`, `end`, and `step`.
    You can omit any of them:'
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接收一个具有属性`start`、`end`和`step`的对象。您可以省略其中任何一个：
- en: '[PRE444]'
  id: totrans-1855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: 'You could implement `selectEntries()` as follows:'
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`selectEntries()`实现如下：
- en: '[PRE445]'
  id: totrans-1857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: 'You can also combine positional parameters with named parameters. It is customary
    for the latter to come last:'
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将位置参数与命名参数结合使用。后者通常出现在最后：
- en: '[PRE446]'
  id: totrans-1859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: Note
  id: totrans-1860
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In JavaScript, the pattern for named parameters shown here is sometimes called
    *options* or *option object* (e.g., by the jQuery documentation).
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，这里显示的命名参数模式有时被称为*选项*或*选项对象*（例如，由jQuery文档）。
- en: 'Chapter 16. Variables: Scopes, Environments, and Closures'
  id: totrans-1862
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16章。变量：作用域、环境和闭包
- en: This chapter first explains how to use variables and then goes into detail on
    how they work (environments, closures, etc.).
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先解释了如何使用变量，然后详细介绍了它们的工作方式（环境、闭包等）。
- en: Declaring a Variable
  id: totrans-1864
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'In JavaScript, you declare a variable via a `var` statement before you use
    it:'
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，您在使用变量之前通过`var`语句声明变量：
- en: '[PRE447]'
  id: totrans-1866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: 'You can also combine a declaration with an assignment, to immediately initialize
    a variable:'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将声明与赋值结合在一起，立即初始化变量：
- en: '[PRE448]'
  id: totrans-1868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: 'The value of an uninitialized variable is `undefined`:'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 未初始化变量的值为`undefined`：
- en: '[PRE449]'
  id: totrans-1870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: 'Background: Static Versus Dynamic'
  id: totrans-1871
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景：静态与动态
- en: 'There are two angles from which you can examine the workings of a program:'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从两个角度来检查程序的工作方式：
- en: Statically (or lexically)
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 静态（或词法）
- en: 'You examine the program as it exists in source code, without running it. Given
    the following code, we can make the static assertion that function `g` is nested
    inside function `f`:'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 您在不运行程序的情况下检查程序的存在。给定以下代码，我们可以得出静态断言，即函数“g”嵌套在函数“f”内部：
- en: '[PRE450]'
  id: totrans-1875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: The adjective *lexical* is used synonymously with *static*, because both pertain
    to the *lexicon* (the words, the source) of the program.
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: 形容词*词法*与*静态*是同义词，因为两者都与程序的*词汇*（单词，源代码）有关。
- en: Dynamically
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 动态
- en: 'You examine what happens while executing the program (“at runtime”). Given
    the following code:'
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 您在执行程序时检查发生的情况（“在运行时”）。给定以下代码：
- en: '[PRE451]'
  id: totrans-1879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: when we call `f()`, it calls `g()`. During runtime, `g` being called by `f`
    represents a dynamic relationship.
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`f()`时，它调用`g()`。在运行时，`g`被`f`调用表示动态关系。
- en: 'Background: The Scope of a Variable'
  id: totrans-1881
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景：变量的范围
- en: 'For the rest of this chapter, you should understand the following concepts:'
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，您应该了解以下概念：
- en: The scope of a variable
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的范围
- en: 'The scope of a variable are the locations where it is accessible. For example:'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的范围是它可访问的位置。例如：
- en: '[PRE452]'
  id: totrans-1885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: Here, the *direct scope* of `x` is the function `foo()`.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“x”的*直接作用域*是函数“foo()”。
- en: Lexical scoping
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 词法作用域
- en: Variables in JavaScript are *lexically scoped*, so the static structure of a
    program determines the scope of a variable (it is not influenced by, say, where
    a function is called from).
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的变量是*词法作用域*的，因此程序的静态结构决定了变量的作用域（不受例如函数从何处调用的影响）。
- en: Nested scopes
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套范围
- en: 'If scopes are nested within the direct scope of a variable, then the variable
    is accessible in all of those scopes:'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作用域嵌套在变量的直接作用域内，则该变量在所有这些作用域中都是可访问的：
- en: '[PRE453]'
  id: totrans-1891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: The direct scope of `arg` is `foo()`, but it is also accessible in the nested
    scope `bar()`. With regard to nesting, `foo()` is the *outer scope* and `bar()`
    is the *inner scope*.
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: “arg”的直接范围是“foo()”，但它也可以在嵌套范围“bar()”中访问。就嵌套而言，“foo()”是*外部范围*，“bar()”是*内部范围*。
- en: Shadowing
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 遮蔽
- en: 'If a scope declares a variable that has the same name as one in a surrounding
    scope, access to the outer variable is blocked in the inner scope and all scopes
    nested inside it. Changes to the inner variable do not affect the outer variable,
    which is accessible again after the inner scope is left:'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作用域声明了与外部作用域中的变量同名的变量，则内部作用域中将阻止对外部变量的访问，并且所有嵌套在其中的作用域。对内部变量的更改不会影响外部变量，在离开内部作用域后，外部变量再次可访问：
- en: '[PRE454]'
  id: totrans-1895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: Inside the function `f()`, the global `x` is shadowed by a local `x`.
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数“f()”内部，全局“x”被本地“x”遮蔽。
- en: Variables Are Function-Scoped
  id: totrans-1897
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量是函数作用域的
- en: 'Most mainstream languages are *block-scoped*: variables “live inside” the innermost
    surrounding code block. Here is an example from Java:'
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数主流语言都是*块作用域*的：变量“存在于”最内部的周围代码块中。以下是Java的一个例子：
- en: '[PRE455]'
  id: totrans-1899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: In the preceding code, the variable `foo` is accessible only inside the block
    that directly surrounds it. If we try to access it after the end of the block,
    we get a compilation error.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，变量`foo`只能在直接包围它的块内部访问。如果我们在块结束后尝试访问它，将会得到编译错误。
- en: 'In contrast, JavaScript’s variables are *function-scoped*: only functions introduce
    new scopes; blocks are ignored when it comes to scoping. For example:'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，JavaScript的变量是*函数作用域*的：只有函数引入新的作用域；在作用域方面忽略了块。例如：
- en: '[PRE456]'
  id: totrans-1902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: Put another way, `foo` is accessible within all of `main()`, not just inside
    the block.
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，“foo”在“main()”中是可访问的，而不仅仅是在块内部。
- en: Variable Declarations Are Hoisted
  id: totrans-1904
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量声明被提升
- en: 'JavaScript *hoists* all variable declarations, it moves them to the beginning
    of their direct scopes. This makes it clear what happens if a variable is accessed
    before it has been declared:'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript *提升*所有变量声明，将它们移动到其直接作用域的开头。这样可以清楚地说明如果在声明之前访问变量会发生什么：
- en: '[PRE457]'
  id: totrans-1906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: 'We can see that the variable `bar` already exists in the first line of `f()`,
    but it does not have a value yet; that is, the declaration has been hoisted, but
    not the assignment. JavaScript executes `f()` as if its code were:'
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到变量“bar”已经存在于“f()”的第一行，但它还没有值；也就是说，声明已经被提升，但赋值没有。JavaScript执行`f()`时，就好像它的代码是：
- en: '[PRE458]'
  id: totrans-1908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: 'If you declare a variable that has already been declared, nothing happens (the
    variable’s value is unchanged):'
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声明已经声明了一个变量，那么什么也不会发生（变量的值不变）：
- en: '[PRE459]'
  id: totrans-1910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: Each function declaration is also hoisted, but in a slightly different manner.
    The complete function is hoisted, not just the creation of the variable in which
    it is stored (see [Hoisting](ch15.html#function_hoisting "Hoisting")).
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数声明也会被提升，但方式略有不同。完整的函数会被提升，而不仅仅是存储它的变量的创建（参见[提升](ch15.html#function_hoisting
    "提升")）。
- en: 'Best practice: be aware of hoisting, but don’t be scared of it'
  id: totrans-1912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践：了解提升，但不要害怕它
- en: Some JavaScript style guides recommend that you only put variable declarations
    at the beginning of a function, in order to avoid being tricked by hoisting. If
    your function is relatively small (which it should be anyway), then you can afford
    to relax that rule a bit and declare variables close to where they are used (e.g.,
    inside a `for` loop). That better encapsulates pieces of code. Obviously, you
    should be aware that that encapsulation is only conceptual, because function-wide
    hoisting still happens.
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: 一些JavaScript风格指南建议您只在函数开头放置变量声明，以避免被提升所欺骗。如果您的函数相对较小（无论如何都应该是这样），那么您可以放松这个规则，将变量声明在使用它们的地方附近（例如，在`for`循环内部）。这样更好地封装了代码片段。显然，您应该意识到这种封装只是概念上的，因为函数范围的提升仍然会发生。
- en: 'Pitfall: Assigning to an Undeclared Variable Makes It Global'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 陷阱：给未声明的变量赋值会使其成为全局变量
- en: 'In sloppy mode, assigning to a variable that hasn’t been declared via `var`
    creates a global variable:'
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: 在松散模式下，对未经`var`声明的变量进行赋值会创建一个全局变量：
- en: '[PRE460]'
  id: totrans-1916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: 'Thankfully, strict mode throws an exception when that happens:'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，严格模式在发生这种情况时会抛出异常：
- en: '[PRE461]'
  id: totrans-1918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: Introducing a New Scope via an IIFE
  id: totrans-1919
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过IIFE引入新的作用域
- en: 'You typically introduce a new scope to restrict the lifetime of a variable.
    One example where you may want to do so is the “then” part of an `if` statement:
    it is executed only if the condition holds; and if it exclusively uses helper
    variables, we don’t want them to “leak out” into the surrounding scope:'
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会引入新的作用域来限制变量的生命周期。一个例子是您可能希望在`if`语句的“then”部分中这样做：只有在条件成立时才执行；如果它专门使用辅助变量，我们不希望它们“泄漏”到周围的作用域中：
- en: '[PRE462]'
  id: totrans-1921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: 'If you want to introduce a new scope for the `then` block, you can define a
    function and immediately invoke it. This is a workaround, a simulation of block
    scoping:'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要为`then`块引入新的作用域，可以定义一个函数并立即调用它。这是一种解决方法，模拟块作用域：
- en: '[PRE463]'
  id: totrans-1923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: 'This is a common pattern in JavaScript. Ben Alman suggested it be called [*immediately
    invoked function expression*](http://bit.ly/i-ife) (IIFE, pronounced “iffy”).
    In general, an IIFE looks like this:'
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JavaScript中的一种常见模式。Ben Alman建议将其称为[*立即调用函数表达式*](http://bit.ly/i-ife)（IIFE，发音为“iffy”）。一般来说，IIFE看起来像这样：
- en: '[PRE464]'
  id: totrans-1925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: 'Here are some things to note about an IIFE:'
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于IIFE的一些注意事项：
- en: It is immediately invoked
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 它立即被调用
- en: The parentheses following the closing brace of the function immediately invoke
    it. That means its body is executed right away.
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的闭括号后面的括号立即调用它。这意味着它的主体立即执行。
- en: It must be an expression
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须是一个表达式
- en: If a statement starts with the keyword `function`, the parser expects it to
    be a function declaration (see [Expressions Versus Statements](ch07.html#expr_vs_stmt
    "Expressions Versus Statements")). But a function declaration cannot be immediately
    invoked. Thus, we tell the parser that the keyword `function` is the beginning
    of a function expression by starting the statement with an open parenthesis. Inside
    parentheses, there can only be expressions.
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语句以关键字`function`开头，解析器会期望它是一个函数声明（参见[Expressions Versus Statements](ch07.html#expr_vs_stmt
    "Expressions Versus Statements")）。但是函数声明不能立即调用。因此，我们通过以开括号开始语句来告诉解析器关键字`function`是函数表达式的开始。在括号内，只能有表达式。
- en: The trailing semicolon is required
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: 需要分号
- en: 'If you forget it between two IIFEs, then your code won’t work anymore:'
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在两个IIFE之间忘记了它，那么您的代码将不再起作用：
- en: '[PRE465]'
  id: totrans-1933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: The preceding code is interpreted as a function call—the first IIFE (including
    the parentheses) is the function to be called, and the second IIFE is the parameter.
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码被解释为函数调用——第一个IIFE（包括括号）是要调用的函数，第二个IIFE是参数。
- en: Note
  id: totrans-1935
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An IIFE incurs costs (both cognitively and performance-wise), so it rarely makes
    sense to use it inside an `if` statement. The preceding example was chosen for
    didactic reasons.
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: IIFE会产生成本（在认知和性能方面），因此在`if`语句内部使用它很少有意义。上面的例子是为了教学目的而选择的。
- en: 'IIFE Variation: Prefix Operators'
  id: totrans-1937
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IIFE变体：前缀运算符
- en: 'You can also enforce the expression context via prefix operators. For example,
    you can do so via the logical Not operator:'
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过前缀运算符强制执行表达式上下文。例如，您可以通过逻辑非运算符这样做：
- en: '[PRE466]'
  id: totrans-1939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: 'or via the `void` operator (see [The void Operator](ch09.html#void_operator
    "The void Operator")):'
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 或通过`void`运算符（参见[The void Operator](ch09.html#void_operator "The void Operator")）：
- en: '[PRE467]'
  id: totrans-1941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: The advantage of using prefix operators is that forgetting the terminating semicolon
    does not cause trouble.
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前缀运算符的优点是忘记结束分号不会引起麻烦。
- en: 'IIFE Variation: Already Inside Expression Context'
  id: totrans-1943
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IIFE变体：已经在表达式上下文中
- en: 'Note that enforcing the expression context for an IIFE is not necessary, if
    you are already in the expression context. Then you need no parentheses or prefix
    operators. For example:'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您已经处于表达式上下文中，则不需要强制执行IIFE的表达式上下文。然后您不需要括号或前缀运算符。例如：
- en: '[PRE468]'
  id: totrans-1945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: In the preceding example, there are two different variables that have the name
    `File`. On one hand, there is the function that is only directly accessible inside
    the IIFE. On the other hand, there is the variable that is declared in the first
    line. It is assigned the value that is returned in the IIFE.
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，有两个不同的变量名为`File`。一方面，有一个函数，只能直接在IIFE内部访问。另一方面，在第一行声明的变量。它被赋予在IIFE中返回的值。
- en: 'IIFE Variation: An IIFE with Parameters'
  id: totrans-1947
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IIFE变体：带参数的IIFE
- en: 'You can use parameters to define variables for the inside of the IIFE:'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用参数来定义IIFE内部的变量：
- en: '[PRE469]'
  id: totrans-1949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: 'This is similar to:'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于：
- en: '[PRE470]'
  id: totrans-1951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: IIFE Applications
  id: totrans-1952
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IIFE应用
- en: 'An IIFE enables you to attach private data to a function. Then you don’t have
    to declare a global variable and can tightly package the function with its state.
    You avoid polluting the global namespace:'
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: IIFE使您能够将私有数据附加到函数上。然后，您就不必声明全局变量，并且可以将函数与其状态紧密打包。您避免了污染全局命名空间：
- en: '[PRE471]'
  id: totrans-1954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: 'Other applications of IIFEs are mentioned elsewhere in this book:'
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: IIFE的其他应用在本书的其他地方提到：
- en: 'Avoiding global variables; hiding variables from global scope (see [Best Practice:
    Avoid Creating Global Variables](ch16.html#avoid_global_variables "Best Practice:
    Avoid Creating Global Variables"))'
  id: totrans-1956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '避免全局变量；隐藏全局范围内的变量（参见[Best Practice: Avoid Creating Global Variables](ch16.html#avoid_global_variables
    "Best Practice: Avoid Creating Global Variables")）'
- en: 'Creating fresh environments; avoiding sharing (see [Pitfall: Inadvertently
    Sharing an Environment](ch16.html#inadvertently_sharing_environments "Pitfall:
    Inadvertently Sharing an Environment"))'
  id: totrans-1957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '创建新的环境；避免共享（参见[Pitfall: Inadvertently Sharing an Environment](ch16.html#inadvertently_sharing_environments
    "Pitfall: Inadvertently Sharing an Environment")）'
- en: Keeping global data private to all of a constructor (see [Keeping global data
    private to all of a constructor](ch17_split_001.html#private_data_complete_constructor
    "Keeping global data private to all of a constructor"))
  id: totrans-1958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将全局数据私有化到所有构造函数中（参见[Keeping global data private to all of a constructor](ch17_split_001.html#private_data_complete_constructor
    "Keeping global data private to all of a constructor")）
- en: Attaching global data to a singleton object (see [Attaching private global data
    to a singleton object](ch17_split_001.html#private_data_singleton "Attaching private
    global data to a singleton object"))
  id: totrans-1959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将全局数据附加到单例对象上（参见[将私有全局数据附加到单例对象](ch17_split_001.html#private_data_singleton
    "将私有全局数据附加到单例对象"）
- en: Attaching global data to a method (see [Attaching global data to a method](ch17_split_001.html#private_data_method
    "Attaching global data to a method"))
  id: totrans-1960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将全局数据附加到方法（参见[将全局数据附加到方法](ch17_split_001.html#private_data_method "将全局数据附加到方法"）
- en: Global Variables
  id: totrans-1961
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'The scope containing all of a program is called *global scope* or *program
    scope*. This is the scope you are in when entering a script (be it a `<script>`
    tag in a web page or be it a *.js* file). Inside the global scope, you can create
    a nested scope by defining a function. Inside such a function, you can again nest
    scopes. Each scope has access to its own variables and to the variables in the
    scopes that surround it. As the global scope surrounds all other scopes, its variables
    can be accessed everywhere:'
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 包含程序的所有范围称为*全局范围*或*程序范围*。这是当进入脚本时所在的范围（无论是网页中的`<script>`标签还是*.js*文件）。在全局范围内，你可以通过定义一个函数来创建一个嵌套作用域。在这样的函数内部，你可以再次嵌套作用域。每个作用域都可以访问自己的变量以及包围它的作用域中的变量。由于全局范围包围所有其他作用域，它的变量可以在任何地方访问：
- en: '[PRE472]'
  id: totrans-1963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: 'Best Practice: Avoid Creating Global Variables'
  id: totrans-1964
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践：避免创建全局变量
- en: Global variables have two disadvantages. First, pieces of software that rely
    on global variables are subject to side effects; they are less robust, behave
    less predictably, and are less reusable.
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量有两个缺点。首先，依赖全局变量的软件部分会受到副作用的影响；它们不够健壮，行为不够可预测，也不够可重用。
- en: 'Second, all of the JavaScript on a web page shares the same global variables:
    your code, built-ins, analytics code, social media buttons, and so on. That means
    that name clashes can become a problem. That is why it is best to hide as many
    variables from the global scope as possible. For example, don’t do this:'
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，网页上的所有JavaScript共享相同的全局变量：你的代码，内置函数，分析代码，社交媒体按钮等等。这意味着名称冲突可能会成为一个问题。这就是为什么最好尽可能隐藏全局范围内的变量。例如，不要这样做：
- en: '[PRE473]'
  id: totrans-1967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: 'The variable `tmp` becomes global, because its declaration is executed in global
    scope. But it is only used locally. Hence, we can use an IIFE (see [Introducing
    a New Scope via an IIFE](ch16.html#iife "Introducing a New Scope via an IIFE"))
    to hide it inside a nested scope:'
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`tmp`变成了全局变量，因为它的声明是在全局范围内执行的。但它只在本地使用。因此，我们可以使用IIFE（参见[通过IIFE引入新作用域](ch16.html#iife
    "通过IIFE引入新作用域"））将其隐藏在嵌套作用域中：
- en: '[PRE474]'
  id: totrans-1969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: Module Systems Lead to Fewer Globals
  id: totrans-1970
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块系统导致全局变量减少
- en: Thankfully, module systems (see [Module Systems](ch31.html#module_systems "Module
    Systems")) mostly eliminate the problem of global variables, because modules don’t
    interface via the global scope and because each module has its own scope for module-global
    variables.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，模块系统（参见[模块系统](ch31.html#module_systems "模块系统"））大多消除了全局变量的问题，因为模块不通过全局范围进行接口，并且每个模块都有自己的模块全局变量的作用域。
- en: The Global Object
  id: totrans-1972
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局对象
- en: 'The ECMAScript specification uses the internal data structure *environment*
    to store variables (see [Environments: Managing Variables](ch16.html#environments
    "Environments: Managing Variables")). The language has the somewhat unusual feature
    of making the environment for global variables accessible via an object, the so-called
    *global object*. The global object can be used to create, read, and change global
    variables. In global scope, `this` points to it:'
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript规范使用内部数据结构*环境*来存储变量（参见[环境：管理变量](ch16.html#environments "环境：管理变量"））。该语言具有一个有点不寻常的特性，即通过对象（所谓的*全局对象*）使全局变量的环境可访问。全局对象可用于创建、读取和更改全局变量。在全局范围内，`this`指向它：
- en: '[PRE475]'
  id: totrans-1974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: 'Note that the global object has prototypes. If you want to list all of its
    (own and inherited) properties, you need a function such as `getAllPropertyNames()`
    from [Listing All Property Keys](ch17_split_000.html#getAllPropertyNames "Listing
    All Property Keys"):'
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，全局对象具有原型。如果你想列出它的（自己的和继承的）所有属性，你需要一个诸如`getAllPropertyNames()`的函数，来自[列出所有属性键](ch17_split_000.html#getAllPropertyNames
    "列出所有属性键"）：
- en: '[PRE476]'
  id: totrans-1976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: JavaScript creator Brendan Eich considers the global object one of his [“biggest
    regrets”](http://mzl.la/1oOeCif). It affects performance negatively, makes the
    implementation of variable scoping more complicated, and leads to less modular
    code.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的创造者Brendan Eich认为全局对象是他的[“最大遗憾”](http://mzl.la/1oOeCif)之一。它对性能产生负面影响，使变量作用域的实现更加复杂，并导致代码模块化程度降低。
- en: Cross-Platform Considerations
  id: totrans-1978
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨平台考虑
- en: 'Browsers and Node.js have global variables for referring to the global object.
    Unfortunately, they are different:'
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器和Node.js都有用于引用全局对象的全局变量。不幸的是，它们是不同的：
- en: Browsers include `window`, which is standardized as part of the Document Object
    Model (DOM), not as part of ECMAScript 5\. There is one global object per frame
    or window.
  id: totrans-1980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器包含`window`，它作为文档对象模型（DOM）的一部分进行了标准化，而不是作为ECMAScript 5的一部分。每个框架或窗口都有一个全局对象。
- en: Node.js contains `global`, which is a Node.js-specific variable. Each module
    has its own scope in which `this` points to an object with that scopes variables.
    Accordingly, `this` and `global` are different inside modules.
  id: totrans-1981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js包含`global`，这是一个特定于Node.js的变量。每个模块都有自己的作用域，其中`this`指向具有该作用域变量的对象。因此，在模块内部，`this`和`global`是不同的。
- en: 'On both platforms, `this` refers to the global object, but only when you are
    in global scope. That is almost never the case on Node.js. If you want to access
    the global object in a cross-platform manner, you can use a pattern such as the
    following:'
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个平台上，`this`都指向全局对象，但只有在全局范围内才是如此。这在Node.js上几乎从不会发生。如果你想以跨平台的方式访问全局对象，可以使用以下模式：
- en: '[PRE477]'
  id: totrans-1983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: From now on, I use `window` to refer to the global object, but in cross-platform
    code, you should use the preceding pattern and `glob` instead.
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我使用`window`来指代全局对象，但在跨平台代码中，你应该使用前面的模式和`glob`。
- en: Use Cases for window
  id: totrans-1985
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`window`的用例
- en: 'This section describes use cases for accessing global variables via `window`.
    But the general rule is: avoid doing that as much as you can.'
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了通过`window`访问全局变量的用例。但一般规则是：尽量避免这样做。
- en: 'Use case: marking global variables'
  id: totrans-1987
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用情况：标记全局变量
- en: 'The prefix `window` is a visual clue that code is referring to a global variable
    and not to a local one:'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀`window`是代码引用全局变量而不是局部变量的视觉线索：
- en: '[PRE478]'
  id: totrans-1989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: 'However, this makes your code brittle. It ceases to work as soon as you move
    `foo` from global scope to another surrounding scope:'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这会使您的代码变得脆弱。一旦您将`foo`从全局范围移动到另一个周围范围，它就会停止工作：
- en: '[PRE479]'
  id: totrans-1991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: 'Thus, it is better to refer to `foo` as a variable, not as a property of `window`.
    If you want to make it obvious that `foo` is a global or global-like variable,
    you can add a name prefix such as `g_`:'
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好将`foo`作为变量而不是`window`的属性引用。如果您想明显地表明`foo`是全局或类似全局的变量，可以添加一个名称前缀，例如`g_`：
- en: '[PRE480]'
  id: totrans-1993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: 'Use case: built-ins'
  id: totrans-1994
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用情况：内置
- en: 'I prefer not to refer to built-in global variables via `window`. They are well-known
    names, so you gain little from an indicator that they are global. And the prefixed
    `window` adds clutter:'
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: 我不喜欢通过`window`引用内置全局变量。它们是众所周知的名称，因此从指示它们是全局的角度获得的帮助很少。而且前缀的`window`会增加混乱：
- en: '[PRE481]'
  id: totrans-1996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: 'Use case: style checkers'
  id: totrans-1997
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用情况：样式检查器
- en: When you are working with a style checking tool such as JSLint and JSHint, using
    `window` means that you don’t get an error when referring to a global variable
    that is not declared in the current file. However, both tools provide ways to
    tell them about such variables and prevent such errors (search for “global variable”
    in their documentation).
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用诸如JSLint和JSHint之类的样式检查工具时，使用`window`意味着在引用当前文件中未声明的全局变量时不会出错。但是，这两个工具都提供了方法来告诉它们这样的变量，并防止出现此类错误（在其文档中搜索“全局变量”）。
- en: 'Use case: checking whether a global variable exists'
  id: totrans-1999
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用情况：检查全局变量是否存在
- en: 'It’s not a frequent use case, but shims and polyfills especially (see [Shims
    Versus Polyfills](ch30.html#shim_vs_polyfill "Shims Versus Polyfills")) need to
    check whether a global variable `someVariable` exists. In that case, `window`
    helps:'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个常见的用例，但是shim和polyfill特别需要检查全局变量`someVariable`是否存在（请参阅[Shims Versus Polyfills](ch30.html#shim_vs_polyfill
    "Shims Versus Polyfills")）。在这种情况下，`window`有所帮助：
- en: '[PRE482]'
  id: totrans-2001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: 'This is a safe way of performing this check. The following statement throws
    an exception if `someVariable` has not been declared:'
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行此检查的安全方式。如果`someVariable`未声明，则以下语句会引发异常：
- en: '[PRE483]'
  id: totrans-2003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: 'There are two additional ways in which you can check via `window`; they are
    roughly equivalent, but a little more explicit:'
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`window`进行两种额外的检查方式；它们大致等效，但更加明确：
- en: '[PRE484]'
  id: totrans-2005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: 'The general way of checking whether a variable exists (and has a value) is
    via `typeof` (see [typeof: Categorizing Primitives](ch09.html#typeof "typeof:
    Categorizing Primitives")):'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: '检查变量是否存在（并具有值）的一般方法是通过`typeof`（请参阅[typeof: Categorizing Primitives](ch09.html#typeof
    "typeof: Categorizing Primitives")）：'
- en: '[PRE485]'
  id: totrans-2007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: 'Use case: creating things in global scope'
  id: totrans-2008
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用情况：在全局范围创建事物
- en: '`window` lets you add things to the global scope (even if you are in a nested
    scope), and it lets you do so conditionally:'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: '`window`允许您将事物添加到全局范围（即使您处于嵌套范围），并且它允许您有条件地这样做：'
- en: '[PRE486]'
  id: totrans-2010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: It is normally best to add things to the global scope via `var`, while you are
    in the global scope. However, `window` provides a clean way of making additions
    conditionally.
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好通过`var`将事物添加到全局范围，而您处于全局范围。但是，`window`提供了一种有条件地进行添加的清晰方式。
- en: 'Environments: Managing Variables'
  id: totrans-2012
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境：管理变量
- en: Tip
  id: totrans-2013
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Environments are an advanced topic. They are a detail of JavaScript’s internals.
    Read this section if you want to get a deeper understanding of how variables work.
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: 环境是一个高级主题。它们是JavaScript内部的细节。如果您想更深入地了解变量的工作原理，请阅读本节。
- en: Variables come into existence when program execution enters their scope. Then
    they need storage space. The data structure that provides that storage space is
    called an *environment* in JavaScript. It maps variable names to values. Its structure
    is very similar to that of JavaScript objects. Environments sometimes live on
    after you leave their scope. Therefore, they are stored on a heap, not on a stack.
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行进入其作用域时，变量就会出现。然后它们需要存储空间。提供该存储空间的数据结构在JavaScript中称为*环境*。它将变量名映射到值。其结构与JavaScript对象的结构非常相似。环境有时会在您离开其作用域后继续存在。因此，它们存储在堆上，而不是栈上。
- en: 'Variables are passed on in two ways. There are two dimensions to them, if you
    will:'
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: 变量以两种方式传递。如果您愿意的话，它们有两个维度：
- en: 'Dynamic dimension: invoking functions'
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: 动态维度：调用函数
- en: 'Every time a function is invoked, it needs new storage for its parameters and
    variables. After it is finished, that storage can usually be reclaimed. As an
    example, take the following implementation of the faculty function. It calls itself
    recursively several times and each time, it needs fresh storage for `n`:'
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用函数时，它都需要为其参数和变量提供新的存储空间。完成后，该存储通常可以被回收。例如，考虑阶乘函数的以下实现。它递归调用自身多次，每次都需要`n`的新存储空间：
- en: '[PRE487]'
  id: totrans-2019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: 'Lexical (static) dimension: staying connected to your surrounding scopes'
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
  zh: 词法（静态）维度：保持与周围作用域的连接
- en: 'No matter how often a function is called, it always needs access to both its
    own (fresh) local variables and the variables of the surrounding scopes. For example,
    the following function, `doNTimes`, has a helper function, `doNTimesRec`, inside
    it. When `doNTimesRec` calls itself several times, a new environment is created
    each time. However, `doNTimesRec` also stays connected to the single environment
    of `doNTimes` during those calls (similar to all functions sharing a single global
    environment). `doNTimesRec` needs that connection to access `action` in line (1):'
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 无论函数被调用多少次，它总是需要访问自己（新鲜的）局部变量和周围作用域的变量。例如，以下函数`doNTimes`内部有一个辅助函数`doNTimesRec`。当`doNTimesRec`多次调用自身时，每次都会创建一个新的环境。但是，在这些调用期间，`doNTimesRec`也保持与`doNTimes`的单个环境的连接（类似于所有函数共享单个全局环境）。`doNTimesRec`需要该连接来访问（1）行中的`action`：
- en: '[PRE488]'
  id: totrans-2022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: 'These two dimensions are handled as follows:'
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个维度的处理方式如下：
- en: 'Dynamic dimension: stack of execution contexts'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 动态维度：执行上下文的堆栈
- en: Each time a function is invoked, a new *environment* is created to map identifiers
    (of parameters and variables) to values. To handle recursion, *execution contexts*—references
    to environments—are managed in a stack. That stack mirrors the call stack.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用函数时，都会创建一个新的*环境*，用于将标识符（参数和变量）映射到值。为了处理递归，*执行上下文*——对环境的引用——在堆栈中进行管理。该堆栈反映了调用堆栈。
- en: 'Lexical dimension: chain of environments'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: 词法维度：环境链
- en: To support this dimension, a function records the scope it was created in via
    the internal property `[[Scope]]`. When a function is called, an environment is
    created for the new scope that is entered. That environment has a field called
    `outer` that points to the outer scope’s environment and is set up via `[[Scope]]`.
    Therefore, there is always a chain of environments, starting with the currently
    active environment, continuing with its outer environment, and so on. Every chain
    ends with the global environment (the scope of all initially invoked functions).
    The field `outer` of the global environment is `null`.
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个维度，函数通过内部属性`[[Scope]]`记录了它被创建时的作用域。当调用函数时，会为进入的新作用域创建一个环境。该环境有一个称为`outer`的字段，指向外部作用域的环境，并通过`[[Scope]]`设置。因此，始终存在一条环境链，从当前活动环境开始，继续到它的外部环境，依此类推。每条链以全局环境结束（最初调用函数的作用域）。全局环境的`outer`字段为`null`。
- en: To resolve an identifier, the complete environment chain is traversed, starting
    with the active environment.
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析标识符，会遍历完整的环境链，从活动环境开始。
- en: 'Let’s look at an example:'
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE489]'
  id: totrans-2030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '![The dynamic dimension of variables is handled via a stack of execution contexts,
    and the static dimension is handled by chaining environments. The active execution
    contexts, environments, and functions are highlighted. Step 1 shows those data
    structures before the function call myFunction(abc). Step 2 shows them during
    the function call.](images/spjs_2001.png)Figure 16-1. The dynamic dimension of
    variables is handled via a stack of execution contexts, and the static dimension
    is handled by chaining environments. The active execution contexts, environments,
    and functions are highlighted. Step 1 shows those data structures before the function
    call myFunction(*abc*). Step 2 shows them during the function call.'
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: '![变量的动态维度通过执行上下文的堆栈处理，静态维度通过环境链处理。活动的执行上下文、环境和函数被突出显示。步骤1显示了在调用myFunction(abc)函数之前这些数据结构。步骤2显示了在函数调用期间。](images/spjs_2001.png)图16-1.
    变量的动态维度通过执行上下文的堆栈处理，静态维度通过环境链处理。活动的执行上下文、环境和函数被突出显示。步骤1显示了在调用myFunction(*abc*)函数之前这些数据结构。步骤2显示了在函数调用期间。'
- en: '[Figure 16-1](ch16.html#figenv_intro "Figure 16-1. The dynamic dimension of
    variables is handled via a stack of execution contexts, and the static dimension
    is handled by chaining environments. The active execution contexts, environments,
    and functions are highlighted. Step 1 shows those data structures before the function
    call myFunction(abc). Step 2 shows them during the function call.") illustrates
    what happens when the preceding code is executed:'
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-1](ch16.html#figenv_intro "图16-1. 变量的动态维度通过执行上下文的堆栈处理，静态维度通过环境链处理。活动的执行上下文、环境和函数被突出显示。步骤1显示了在调用myFunction(abc)函数之前这些数据结构。步骤2显示了在函数调用期间。")说明了在执行前述代码时会发生什么：'
- en: '`myFunction` and `myFloat` have been stored in the global environment (#0).
    Note that the `function` object referred to by `myFunction` points to its scope
    (the global scope) via the internal property `[[Scope]]`.'
  id: totrans-2033
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`myFunction`和`myFloat`已经存储在全局环境（#0）中。请注意，由`myFunction`引用的`function`对象通过内部属性`[[Scope]]`指向它的作用域（全局作用域）。'
- en: For the execution of `myFunction('abc')`, a new environment (#1) is created
    that holds the parameter and the local variable. It refers to its outer environment
    via `outer` (which is initialized from `myFunction.[[Scope]]`). Thanks to the
    outer environment, `myFunction` can access `myFloat`.
  id: totrans-2034
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于执行`myFunction('abc')`，会创建一个新的环境（#1），其中包含参数和局部变量。它通过`outer`（从`myFunction.[[Scope]]`初始化）引用其外部环境。由于外部环境，`myFunction`可以访问`myFloat`。
- en: 'Closures: Functions Stay Connected to Their Birth Scopes'
  id: totrans-2035
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包：函数保持与它们诞生作用域的连接
- en: 'If a function leaves the scope in which it was created, it stays connected
    to the variables of that scope (and of the surrounding scopes). For example:'
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数离开了它被创建的作用域，它仍然与该作用域（以及周围作用域）的变量保持连接。例如：
- en: '[PRE490]'
  id: totrans-2037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: 'The function returned by `createInc()` does not lose its connection to `startValue`—the
    variable provides the function with state that persists across function calls:'
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: '`createInc()`返回的函数不会失去与`startValue`的连接——该变量为函数提供了跨函数调用持续存在的状态：'
- en: '[PRE491]'
  id: totrans-2039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: A *closure* is a function plus the connection to the scope in which the function
    was created. The name stems from the fact that a closure “closes over” the free
    variables of a function. A variable is free if it is not declared within the function—that
    is, if it comes “from outside.”
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
  zh: '*闭包*是一个函数加上它被创建时的作用域的连接。这个名字源于闭包“封闭”了函数的自由变量。如果一个变量不是在函数内声明的，即来自“外部”，那么它就是自由的。'
- en: Handling Closures via Environments
  id: totrans-2041
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过环境处理闭包
- en: Tip
  id: totrans-2042
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'This is an advanced section that goes deeper into how closures work. You should
    be familiar with environments (review [Environments: Managing Variables](ch16.html#environments
    "Environments: Managing Variables")).'
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个深入探讨闭包工作原理的高级部分。您应该熟悉环境（请查看[环境：管理变量](ch16.html#environments "环境：管理变量")）。
- en: 'A closure is an example of an environment surviving after execution has left
    its scope. To illustrate how closures work, let’s examine the previous interaction
    with `createInc()` and split it up into four steps (during each step, the active
    execution context and its environment are highlighted; if a function is active,
    it is highlighted, too):'
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是执行离开其范围后仍然存在的环境的一个例子。为了说明闭包的工作原理，让我们将之前与`createInc()`的交互分解为四个步骤（在每个步骤中，突出显示活动执行上下文及其环境；如果函数是活动的，它也会被突出显示）：
- en: This step takes place before the interaction, and after the evaluation of the
    function declaration of `createInc`. An entry for `createInc` has been added to
    the global environment (#0) and points to a function object.
  id: totrans-2045
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一步发生在交互之前，并且在评估`createInc`的函数声明之后。`createInc`的条目已添加到全局环境（＃0）中，并指向一个函数对象。
- en: '![image with no caption](images/spjs_20in01.png)'
  id: totrans-2046
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](images/spjs_20in01.png)'
- en: This step occurs during the execution of the function call `createInc(5)`. A
    fresh environment (#1) for `createInc` is created and pushed onto the stack. Its
    outer environment is the global environment (the same as `createInc.[[Scope]]`).
    The environment holds the parameter `startValue`.
  id: totrans-2047
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一步发生在函数调用`createInc(5)`期间。为`createInc`创建了一个新的环境（＃1）并推送到堆栈上。它的外部环境是全局环境（与`createInc.[[Scope]]`相同）。该环境保存了参数`startValue`。
- en: '![image with no caption](images/spjs_20in02.png)'
  id: totrans-2048
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](images/spjs_20in02.png)'
- en: This step happens after the assignment to `inc`. After we returned from `createInc`,
    the execution context pointing to its environment was removed from the stack,
    but the environment still exists on the heap, because `inc.[[Scope]]` refers to
    it. `inc` is a closure (function plus birth environment).
  id: totrans-2049
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一步发生在对`inc`进行赋值之后。当我们从`createInc`返回时，指向其环境的执行上下文已从堆栈中移除，但是环境仍然存在于堆中，因为`inc.[[Scope]]`引用它。`inc`是一个闭包（函数加出生环境）。
- en: '![image with no caption](images/spjs_20in03.png)'
  id: totrans-2050
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](images/spjs_20in03.png)'
- en: This step takes place during the execution of `inc(1)`. A new environment (#1)
    has been created and an execution context pointing to it has been pushed onto
    the stack. Its outer environment is the `[[Scope]]` of `inc`. The outer environment
    gives `inc` access to `startValue`.
  id: totrans-2051
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一步发生在执行`inc(1)`期间。已创建了一个新的环境（＃1），并且指向它的执行上下文已被推送到堆栈上。它的外部环境是`inc`的`[[Scope]]`。外部环境使`inc`可以访问`startValue`。
- en: '![image with no caption](images/spjs_20in04.png)'
  id: totrans-2052
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](images/spjs_20in04.png)'
- en: This step happens after the execution of `inc(1)`. No reference (execution context,
    `outer` field, or `[[Scope]]`) points to `inc`’s environment, anymore. It is therefore
    not needed and can be removed from the heap.
  id: totrans-2053
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一步发生在执行`inc(1)`之后。不再有引用（执行上下文，`outer`字段或`[[Scope]]`）指向`inc`的环境。因此它不再需要，并且可以从堆中删除。
- en: '![image with no caption](images/spjs_20in03.png)'
  id: totrans-2054
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](images/spjs_20in03.png)'
- en: 'Pitfall: Inadvertently Sharing an Environment'
  id: totrans-2055
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 陷阱：无意中共享环境
- en: 'Sometimes the behavior of functions you create is influenced by a variable
    in the current scope. In JavaScript, that can be problematic, because each function
    should work with the value that the variable had when the function was created.
    However, due to functions being closures, the function will always work with the
    *current* value of the variable. In `for` loops, that can prevent things from
    working properly. An example will make things clearer:'
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您创建的函数的行为受当前范围内的变量的影响。在JavaScript中，这可能会有问题，因为每个函数应该使用函数创建时变量的值。但是，由于函数是闭包，函数将始终使用变量的*当前*值。在`for`循环中，这可能会导致事情无法正常工作。通过示例可以更清楚地说明：
- en: '[PRE492]'
  id: totrans-2057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '`f` returns an array with three functions in it. All of these functions can
    still access the environment of `f` and thus `i`. In fact, they share the same
    environment. Alas, after the loop is finished, `i` has the value 3 in that environment.
    Therefore, all functions return `3`.'
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
  zh: '`f`返回一个包含三个函数的数组。所有这些函数仍然可以访问`f`的环境，因此也可以访问`i`。实际上，它们共享相同的环境。然而，在循环结束后，`i`在该环境中的值为3。因此，所有函数都返回`3`。'
- en: 'This is not what we want. To fix things, we need to make a snapshot of the
    index `i` before creating a function that uses it. In other words, we want to
    package each function with the value that `i` had at the time of the function’s
    creation. We therefore take the following steps:'
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们想要的。为了解决问题，我们需要在创建使用它的函数之前对索引`i`进行快照。换句话说，我们希望将每个函数与函数创建时`i`的值打包在一起。因此，我们采取以下步骤：
- en: Create a new environment for each function in the returned array.
  id: totrans-2060
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为返回的数组中的每个函数创建一个新的环境。
- en: Store (a copy of) the current value of *i* in that environment.
  id: totrans-2061
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该环境中存储（复制）*i*的当前值。
- en: 'Only functions create environments, so we use an IIFE (see [Introducing a New
    Scope via an IIFE](ch16.html#iife "Introducing a New Scope via an IIFE")) to accomplish
    step 1:'
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: 只有函数创建环境，因此我们使用IIFE（参见[通过IIFE引入新作用域](ch16.html#iife "通过IIFE引入新作用域")）来完成第1步：
- en: '[PRE493]'
  id: totrans-2063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: Note that the example has real-world relevance, because similar scenarios arise
    when you add event handlers to DOM elements via loops.
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该示例具有现实世界的相关性，因为在通过循环向DOM元素添加事件处理程序时会出现类似的情况。
- en: Chapter 17. Objects and Inheritance
  id: totrans-2065
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第17章。对象和继承
- en: 'There are several layers to object-oriented programming (OOP) in JavaScript:'
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的面向对象编程（OOP）有几个层次：
- en: 'Layer 1: Object-orientation with single objects (covered in [Layer 1: Single
    Objects](ch17_split_000.html#single_objects "Layer 1: Single Objects"))'
  id: totrans-2067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1层：使用单个对象的面向对象（在[第1层：单个对象](ch17_split_000.html#single_objects "第1层：单个对象")中介绍）
- en: 'Layer 2: Prototype chains of objects (described in [Layer 2: The Prototype
    Relationship Between Objects](ch17_split_000.html#prototype_relationship "Layer
    2: The Prototype Relationship Between Objects"))'
  id: totrans-2068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二层：对象的原型链（在[第二层：对象之间的原型关系](ch17_split_000.html#prototype_relationship "第二层：对象之间的原型关系")中描述）
- en: 'Layer 3: Constructors as factories for instances, similar to classes in other
    languages (discussed in [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances"))'
  id: totrans-2069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3层：构造函数作为实例的工厂，类似于其他语言中的类（在[第3层：构造函数—实例的工厂](ch17_split_001.html#constructors
    "第3层：构造函数—实例的工厂")中讨论）
- en: 'Layer 4: Subclassing, creating new constructors by inheriting from existing
    ones (covered in [Layer 4: Inheritance Between Constructors](ch17_split_001.html#constructor_inheritance
    "Layer 4: Inheritance Between Constructors"))'
  id: totrans-2070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4层：子类化，通过从现有构造函数继承创建新的构造函数（在[第4层：构造函数之间的继承](ch17_split_001.html#constructor_inheritance
    "第4层：构造函数之间的继承")中讨论）
- en: Each new layer only depends on prior ones, enabling you to learn JavaScript
    OOP incrementally. Layers 1 and 2 form a simple core that you can refer back to
    whenever you are getting confused by the more complicated layers 3 and 4.
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新层只依赖于之前的层，使您能够逐步学习JavaScript OOP。第1层和第2层形成一个简单的核心，您可以在更复杂的第3层和第4层让您感到困惑时进行参考。
- en: 'Layer 1: Single Objects'
  id: totrans-2072
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1层：单个对象
- en: Roughly, all objects in JavaScript are maps (dictionaries) from strings to values.
    A (key, value) entry in an object is called a *property*. The key of a property
    is always a text string. The value of a property can be any JavaScript value,
    including a function. *Methods* are properties whose values are functions.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 大致上，JavaScript中的所有对象都是从字符串到值的映射（字典）。对象中的（键，值）条目称为*属性*。属性的键始终是文本字符串。属性的值可以是任何JavaScript值，包括函数。*方法*是其值为函数的属性。
- en: Kinds of Properties
  id: totrans-2074
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性的种类
- en: 'There are three kinds of properties:'
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种属性：
- en: Properties (or named data properties)
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 属性（或命名数据属性）
- en: Normal properties in an object—that is, mappings from string keys to values.
    Named data properties include methods. This is by far the most common kind of
    property.
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: 对象中的普通属性—即从字符串键到值的映射。命名数据属性包括方法。这是最常见的属性类型。
- en: Accessors (or named accessor properties)
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器（或命名访问器属性）
- en: Special methods whose invocations look like reading or writing properties. Normal
    properties are storage locations for property values; accessors allow you to compute
    the values of properties. They are virtual properties, if you will. See [Accessors
    (Getters and Setters)](ch17_split_000.html#getters_setters "Accessors (Getters
    and Setters)") for details.
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法的调用看起来像是读取或写入属性。普通属性是属性值的存储位置；访问器允许您计算属性的值。如果你愿意，它们是虚拟属性。有关详细信息，请参见[访问器（getter和setter）](ch17_split_000.html#getters_setters
    "访问器（getter和setter）")。
- en: Internal properties
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: 内部属性
- en: Exist only in the ECMAScript language specification. They are not directly accessible
    from JavaScript, but there might be indirect ways of accessing them. The specification
    writes the keys of internal properties in brackets. For example, `[[Prototype]]`
    holds the prototype of an object and is readable via `Object.getPrototypeOf()`.
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: 仅存在于ECMAScript语言规范中。它们无法直接从JavaScript中访问，但可能有间接访问它们的方法。规范使用方括号写入内部属性的键。例如，`[[Prototype]]`保存对象的原型，并且可以通过`Object.getPrototypeOf()`读取。
- en: Object Literals
  id: totrans-2082
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象字面量
- en: 'JavaScript’s *object literals* allow you to directly create *plain objects*
    (direct instances of `Object`). The following code uses an object literal to assign
    an object to the variable `jane`. The object has the two properties: `name` and
    `describe`. `describe` is a method:'
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的*对象字面量*允许您直接创建*普通对象*（`Object`的直接实例）。以下代码使用对象字面量将对象分配给变量`jane`。对象具有两个属性：`name`和`describe`。`describe`是一个方法：
- en: '[PRE494]'
  id: totrans-2084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: Use `this` in methods to refer to the current object (also called the *receiver*
    of a method invocation).
  id: totrans-2085
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法中使用`this`来引用当前对象（也称为方法调用的*接收者*）。
- en: ECMAScript 5 allows a trailing comma (after the last property) in an object
    literal. Alas, not all older browsers support it. A trailing comma is useful,
    because you can rearrange properties without having to worry which property is
    last.
  id: totrans-2086
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ECMAScript 5允许在对象字面量中使用尾随逗号（在最后一个属性之后）。遗憾的是，并非所有旧版浏览器都支持它。尾随逗号很有用，因为您可以重新排列属性，而不必担心哪个属性是最后一个。
- en: 'You may get the impression that objects are *only* maps from strings to values.
    But they are more than that: they are real general-purpose objects. For example,
    you can use inheritance between objects (see [Layer 2: The Prototype Relationship
    Between Objects](ch17_split_000.html#prototype_relationship "Layer 2: The Prototype
    Relationship Between Objects")), and you can protect objects from being changed.
    The ability to directly create objects is one of JavaScript’s standout features:
    you can start with concrete objects (no classes needed!) and introduce abstractions
    later. For example, *constructors*, which are factories for objects (as discussed
    in [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances")), are roughly similar to classes
    in other languages.'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会有这样的印象，即对象*只是*从字符串到值的映射。但它们不仅如此：它们是真正的通用对象。例如，您可以在对象之间使用继承（请参见[第2层：对象之间的原型关系](ch17_split_000.html#prototype_relationship
    "第2层：对象之间的原型关系")），并且可以保护对象免受更改。直接创建对象的能力是JavaScript的一大特点：您可以从具体对象开始（无需类！），然后稍后引入抽象。例如，*构造函数*是对象的工厂（如[第3层：构造函数—实例的工厂](ch17_split_001.html#constructors
    "第3层：构造函数—实例的工厂")中讨论的），大致类似于其他语言中的类。
- en: 'Dot Operator (.): Accessing Properties via Fixed Keys'
  id: totrans-2088
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点运算符（.）：通过固定键访问属性
- en: 'The dot operator provides a compact syntax for accessing properties. The property
    keys must be identifiers (consult [Legal Identifiers](ch07.html#identifiers "Legal
    Identifiers")). If you want to read or write properties with arbitrary names,
    you need to use the bracket operator (see [Bracket Operator ([]): Accessing Properties
    via Computed Keys](ch17_split_000.html#bracket_operator "Bracket Operator ([]):
    Accessing Properties via Computed Keys")).'
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: '点运算符提供了一种紧凑的语法来访问属性。属性键必须是标识符（参见[Legal Identifiers](ch07.html#identifiers "Legal
    Identifiers")）。如果您想要读取或写入具有任意名称的属性，您需要使用括号运算符（参见[Bracket Operator ([]): Accessing
    Properties via Computed Keys](ch17_split_000.html#bracket_operator "Bracket Operator
    ([]): Accessing Properties via Computed Keys")）。'
- en: 'The examples in this section work with the following object:'
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例与以下对象一起使用：
- en: '[PRE495]'
  id: totrans-2091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: Getting properties
  id: totrans-2092
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取属性
- en: 'The dot operator lets you “get” a property (read its value). Here are some
    examples:'
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
  zh: 点运算符允许您“获取”属性（读取其值）。以下是一些示例：
- en: '[PRE496]'
  id: totrans-2094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: 'Getting a property that doesn’t exist returns `undefined`:'
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
  zh: 获取不存在的属性返回`undefined`：
- en: '[PRE497]'
  id: totrans-2096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: Calling methods
  id: totrans-2097
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调用方法
- en: 'The dot operator is also used to call methods:'
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: 点运算符也用于调用方法：
- en: '[PRE498]'
  id: totrans-2099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: Setting properties
  id: totrans-2100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置属性
- en: 'You can use the assignment operator (`=`) to set the value of a property referred
    to via the dot notation. For example:'
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用赋值运算符（`=`）通过点表示法设置属性的值。例如：
- en: '[PRE499]'
  id: totrans-2102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: If a property doesn’t exist yet, setting it automatically creates it. If a property
    already exists, setting it changes its value.
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性尚不存在，则设置它会自动创建它。如果属性已经存在，则设置它会更改其值。
- en: Deleting properties
  id: totrans-2104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除属性
- en: 'The `delete` operator lets you completely remove a property (the whole key-value
    pair) from an object. For example:'
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`运算符允许您完全从对象中删除属性（整个键值对）。例如：'
- en: '[PRE500]'
  id: totrans-2106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: 'If you merely set a property to `undefined`, the property still exists and
    the object still contains its key:'
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仅将属性设置为`undefined`，则该属性仍然存在，对象仍然包含其键：
- en: '[PRE501]'
  id: totrans-2108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: 'If you delete the property, its key is gone, too:'
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果删除属性，则其键也将消失：
- en: '[PRE502]'
  id: totrans-2110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '`delete` affects only the direct (“own,” noninherited) properties of an object.
    Its prototypes are not touched (see [Deleting an inherited property](ch17_split_000.html#delete_inherited_property
    "Deleting an inherited property")).'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`仅影响对象的直接（“自有”，非继承的）属性。其原型不会受到影响（参见[Deleting an inherited property](ch17_split_000.html#delete_inherited_property
    "Deleting an inherited property")）。'
- en: Tip
  id: totrans-2112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Use the `delete` operator sparingly. Most modern JavaScript engines optimize
    the performance of instances created by constructors if their “shape” doesn’t
    change (roughly: no properties are removed or added). Deleting a property prevents
    that optimization.'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎使用`delete`运算符。大多数现代JavaScript引擎会优化通过构造函数创建的实例的性能，如果它们的“形状”不发生变化（大致上：不会删除或添加属性）。删除属性会阻止该优化。
- en: The return value of delete
  id: totrans-2114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`delete`的返回值'
- en: '`delete` returns `false` if the property is an own property, but cannot be
    deleted. It returns `true` in all other cases. Following are some examples.'
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性是自有属性，但无法删除，则`delete`返回`false`。在所有其他情况下，它返回`true`。以下是一些示例。
- en: 'As a preparation, we create one property that can be deleted and another one
    that can’t be deleted ([Getting and Defining Properties via Descriptors](ch17_split_000.html#functions_for_property_descriptors
    "Getting and Defining Properties via Descriptors") explains `Object.defineProperty()`):'
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为准备工作，我们创建一个可以删除的属性和另一个无法删除的属性（[Getting and Defining Properties via Descriptors](ch17_split_000.html#functions_for_property_descriptors
    "Getting and Defining Properties via Descriptors")解释了`Object.defineProperty()`）：
- en: '[PRE503]'
  id: totrans-2117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '`delete` returns `false` for own properties that can’t be deleted:'
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无法删除的自有属性，`delete`返回`false`：
- en: '[PRE504]'
  id: totrans-2119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '`delete` returns `true` in all other cases:'
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有其他情况下，`delete`都会返回`true`：
- en: '[PRE505]'
  id: totrans-2121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '`delete` returns `true` even if it doesn’t change anything (inherited properties
    are never removed):'
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不改变任何内容，`delete`也会返回`true`（继承属性永远不会被删除）：
- en: '[PRE506]'
  id: totrans-2123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: Unusual Property Keys
  id: totrans-2124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不寻常的属性键
- en: 'While you can’t use reserved words (such as `var` and `function`) as variable
    names, you can use them as property keys:'
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您不能将保留字（例如`var`和`function`）用作变量名，但您可以将它们用作属性键：
- en: '[PRE507]'
  id: totrans-2126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: 'Numbers can be used as property keys in object literals, but they are interpreted
    as strings. The dot operator can only access properties whose keys are identifiers.
    Therefore, you need the bracket operator (shown in the following example) to access
    properties whose keys are numbers:'
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: 数字可以在对象文字中用作属性键，但它们被解释为字符串。点运算符只能访问其键为标识符的属性。因此，您需要使用括号运算符（如下例所示）来访问其键为数字的属性：
- en: '[PRE508]'
  id: totrans-2128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: 'Object literals also allow you to use arbitrary strings (that are neither identifiers
    nor numbers) as property keys, but you must quote them. Again, you need the bracket
    operator to access the property values:'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 对象文字还允许您使用任意字符串（既不是标识符也不是数字）作为属性键，但您必须对其进行引用。同样，您需要使用括号运算符来访问属性值：
- en: '[PRE509]'
  id: totrans-2130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: 'Bracket Operator ([]): Accessing Properties via Computed Keys'
  id: totrans-2131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 括号运算符（[]）：通过计算键访问属性
- en: While the dot operator works with fixed property keys, the bracket operator
    allows you to refer to a property via an expression.
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然点运算符适用于固定属性键，但括号运算符允许您通过表达式引用属性。
- en: Getting properties via the bracket operator
  id: totrans-2133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过括号运算符获取属性
- en: 'The bracket operator lets you compute the key of a property, via an expression:'
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: 括号运算符允许您通过表达式计算属性的键：
- en: '[PRE510]'
  id: totrans-2135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: 'That also allows you to access properties whose keys are not identifiers:'
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
  zh: 这也允许您访问其键不是标识符的属性：
- en: '[PRE511]'
  id: totrans-2137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: 'Note that the bracket operator coerces its interior to string. For example:'
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，括号运算符会将其内部强制转换为字符串。例如：
- en: '[PRE512]'
  id: totrans-2139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: Calling methods via the bracket operator
  id: totrans-2140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过括号运算符调用方法
- en: 'Calling methods works as you would expect:'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: 调用方法的工作方式与您期望的一样：
- en: '[PRE513]'
  id: totrans-2142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: Setting properties via the bracket operator
  id: totrans-2143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过括号运算符设置属性
- en: 'Setting properties works analogously to the dot operator:'
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: 设置属性的工作方式与点运算符类似：
- en: '[PRE514]'
  id: totrans-2145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: Deleting properties via the bracket operator
  id: totrans-2146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过括号运算符删除属性
- en: 'Deleting properties also works similarly to the dot operator:'
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 删除属性的工作方式也与点运算符类似：
- en: '[PRE515]'
  id: totrans-2148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: Converting Any Value to an Object
  id: totrans-2149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将任何值转换为对象
- en: 'It’s not a frequent use case, but sometimes you need to convert an arbitrary
    value to an object. `Object()`, used as a function (not as a constructor), provides
    that service. It produces the following results:'
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个常见的用例，但有时你需要将任意值转换为对象。`Object()` 作为函数（而不是构造函数）提供了这种服务。它产生以下结果：
- en: '| Value | Result |'
  id: totrans-2151
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 结果 |'
- en: '| --- | --- |'
  id: totrans-2152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| (Called with no parameters) | `{}` |'
  id: totrans-2153
  prefs: []
  type: TYPE_TB
  zh: '| (不带参数调用) | `{}` |'
- en: '| `undefined` | `{}` |'
  id: totrans-2154
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` | `{}` |'
- en: '| `null` | `{}` |'
  id: totrans-2155
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `{}` |'
- en: '| A boolean `bool` | `new Boolean(bool)` |'
  id: totrans-2156
  prefs: []
  type: TYPE_TB
  zh: 一个布尔值 `bool` | `new Boolean(bool)` |
- en: '| A number `num` | `new Number(num)` |'
  id: totrans-2157
  prefs: []
  type: TYPE_TB
  zh: 一个数字 `num` | `new Number(num)` |
- en: '| A string `str` | `new String(str)` |'
  id: totrans-2158
  prefs: []
  type: TYPE_TB
  zh: 一个字符串 `str` | `new String(str)` |
- en: '| An object `obj` | `obj` (unchanged, nothing to convert) |'
  id: totrans-2159
  prefs: []
  type: TYPE_TB
  zh: 一个对象 `obj` | `obj`（不变，无需转换）|
- en: 'Here are some examples:'
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些例子：
- en: '[PRE516]'
  id: totrans-2161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: 'Tthe following function checks whether `value` is an object:'
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数检查 `value` 是否为对象：
- en: '[PRE517]'
  id: totrans-2163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: 'Note that the preceding function creates an object if `value` isn’t an object.
    You can implement the same function without doing that, via `typeof` (see [Pitfall:
    typeof null](ch09.html#isobject_typeof "Pitfall: typeof null")).'
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，如果 `value` 不是对象，则前面的函数将创建一个对象。你可以通过 `typeof` 实现相同的功能，而不需要这样做（参见[Pitfall:
    typeof null](ch09.html#isobject_typeof "Pitfall: typeof null")）。'
- en: 'You can also invoke `Object` as a constructor, which produces the same results
    as calling it as a function:'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 `Object` 作为构造函数调用，这将产生与作为函数调用相同的结果：
- en: '[PRE518]'
  id: totrans-2166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: Tip
  id: totrans-2167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Avoid the constructor; an empty object literal is almost always a better choice:'
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用构造函数；几乎总是更好的选择是一个空对象字面量：
- en: '[PRE519]'
  id: totrans-2169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: this as an Implicit Parameter of Functions and Methods
  id: totrans-2170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数和方法的隐式参数 `this`
- en: 'When you call a function, `this` is always an (implicit) parameter:'
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个函数时，`this` 总是一个（隐式）参数：
- en: Normal functions in sloppy mode
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: 松散模式下的普通函数
- en: 'Even though normal functions have no use for `this`, it still exists as a special
    variable whose value is always the global object (`window` in browsers; see [The
    Global Object](ch16.html#global_object "The Global Object")):'
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
  zh: 即使普通函数对 `this` 没有用处，它仍然存在作为一个特殊变量，其值始终是全局对象（在浏览器中是 `window`；参见[全局对象](ch16.html#global_object
    "全局对象")）：
- en: '[PRE520]'
  id: totrans-2174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: Normal functions in strict mode
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式下的普通函数
- en: '`this` is always `undefined`:'
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 总是 `undefined`：'
- en: '[PRE521]'
  id: totrans-2177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: Methods
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: 方法
- en: '`this` refers to the object on which the method has been invoked:'
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 指的是调用方法的对象：'
- en: '[PRE522]'
  id: totrans-2180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: In the case of methods, the value of `this` is called the *receiver* of the
    method call.
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的情况下，`this` 的值被称为方法调用的*接收者*。
- en: 'Calling Functions While Setting this: call(), apply(), and bind()'
  id: totrans-2182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在设置 `this` 的情况下调用函数：call()、apply() 和 bind()
- en: 'Remember that functions are also objects. Thus, each function has methods of
    its own. Three of them are introduced in this section and help with calling functions.
    These three methods are used in the following sections to work around some of
    the pitfalls of calling functions. The upcoming examples all refer to the following
    object, `jane`:'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
  zh: 记住函数也是对象。因此，每个函数都有自己的方法。本节介绍了其中三个方法，并帮助调用函数。这三种方法在以下部分中用于解决调用函数的一些陷阱。即将出现的示例都涉及以下对象
    `jane`：
- en: '[PRE523]'
  id: totrans-2184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: Function.prototype.call(thisValue, arg1?, arg2?, ...)
  id: totrans-2185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Function.prototype.call(thisValue, arg1?, arg2?, ...)
- en: 'The first parameter is the value that `this` will have inside the invoked function;
    the remaining parameters are handed over as arguments to the invoked function.
    The following three invocations are equivalent:'
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是被调用函数内部的 `this` 的值；其余参数作为参数传递给被调用的函数。以下三次调用是等价的：
- en: '[PRE524]'
  id: totrans-2187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: For the second invocation, you need to repeat `jane`, because `call()` doesn’t
    know how you got the function that it is invoked on.
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二次调用，你需要重复 `jane`，因为 `call()` 不知道你是如何得到它被调用的函数的。
- en: Function.prototype.apply(thisValue, argArray)
  id: totrans-2189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Function.prototype.apply(thisValue, argArray)
- en: 'The first parameter is the value that `this` will have inside the invoked function;
    the second parameter is an array that provides the arguments for the invocation.
    The following three invocations are equivalent:'
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是被调用函数内部的 `this` 的值；第二个参数是一个提供调用参数的数组。以下三次调用是等价的：
- en: '[PRE525]'
  id: totrans-2191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: For the second invocation, you need to repeat `jane`, because `apply()` doesn’t
    know how you got the function that it is invoked on.
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二次调用，你需要重复 `jane`，因为 `apply()` 不知道你是如何得到它被调用的函数的。
- en: '[apply() for Constructors](ch17_split_000.html#apply_constructors "apply()
    for Constructors") explains how to use `apply()` with constructors.'
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: '[用于构造函数的 apply()](ch17_split_000.html#apply_constructors "用于构造函数的 apply()")
    解释了如何在构造函数中使用 `apply()`。'
- en: Function.prototype.bind(thisValue, arg1?, ..., argN?)
  id: totrans-2194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Function.prototype.bind(thisValue, arg1?, ..., argN?)
- en: 'This method performs *partial function application*—meaning it creates a new
    function that calls the receiver of `bind()` in the following manner: the value
    of `this` is `thisValue` and the arguments start with `arg1` until `argN`, followed
    by the arguments of the new function. In other words, the new function appends
    its arguments to `arg1, ..., argN` when it calls the original function. Let’s
    look at an example:'
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法执行*部分函数应用*——意味着它创建一个新的函数，以以下方式调用 `bind()` 的接收者：`this` 的值是 `thisValue`，参数从
    `arg1` 开始直到 `argN`，然后是新函数的参数。换句话说，当新函数调用原始函数时，它将其参数附加到 `arg1, ..., argN`。让我们看一个例子：
- en: '[PRE526]'
  id: totrans-2196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: 'The array method `slice` is used to convert `arguments` to an array, which
    is necessary for logging it (this operation is explained in [Array-Like Objects
    and Generic Methods](ch17_split_001.html#array-like_objects "Array-Like Objects
    and Generic Methods")). `bound` is a new function. Here’s the interaction:'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: 数组方法 `slice` 用于将 `arguments` 转换为数组，这对于记录它是必要的（这个操作在[类数组对象和通用方法](ch17_split_001.html#array-like_objects
    "类数组对象和通用方法")中有解释）。`bound` 是一个新函数。以下是交互：
- en: '[PRE527]'
  id: totrans-2198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: 'The following three invocations of `sayHelloTo` are all equivalent:'
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三次对 `sayHelloTo` 的调用都是等价的：
- en: '[PRE528]'
  id: totrans-2200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: apply() for Constructors
  id: totrans-2201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于构造函数的 apply()
- en: 'Let’s pretend that JavaScript has a triple dot operator (`...`) that turns
    arrays into actual parameters. Such an operator would allow you to use `Math.max()`
    (see [Other Functions](ch21.html#Math_max "Other Functions")) with arrays. In
    that case, the following two expressions would be equivalent:'
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设JavaScript有一个三个点运算符（`...`），可以将数组转换为实际参数。这样的运算符将允许您使用`Math.max()`（参见[其他函数](ch21.html#Math_max
    "其他函数")）与数组。在这种情况下，以下两个表达式将是等价的：
- en: '[PRE529]'
  id: totrans-2203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: 'For functions, you can achieve the effect of the triple dot operator via `apply()`:'
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数，您可以通过`apply()`实现三个点运算符的效果：
- en: '[PRE530]'
  id: totrans-2205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: 'The triple dot operator would also make sense for constructors:'
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
  zh: 三个点运算符对构造函数也有意义：
- en: '[PRE531]'
  id: totrans-2207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: Alas, here `apply()` does not work, because it helps only with function or method
    calls, not with constructor invocations.
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，这里`apply()`不起作用，因为它只能帮助函数或方法调用，而不能帮助构造函数调用。
- en: Manually simulating an apply() for constructors
  id: totrans-2209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手动模拟构造函数的apply()
- en: We can simulate `apply()` in two steps.
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分两步模拟`apply()`。
- en: Step 1
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤1
- en: 'Pass the arguments to `Date` via a method call (they are not in an array—yet):'
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过方法调用将参数传递给`Date`（它们还不在数组中）：
- en: '[PRE532]'
  id: totrans-2213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: The preceding code uses `bind()` to create a constructor without parameters
    and invokes it via `new`.
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用`bind()`创建一个没有参数的构造函数，并通过`new`调用它。
- en: Step 2
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤2
- en: 'Use `apply()` to hand an array to `bind()`. Because `bind()` is a method call,
    we can use `apply()`:'
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`apply()`将数组传递给`bind()`。因为`bind()`是一个方法调用，所以我们可以使用`apply()`：
- en: '[PRE533]'
  id: totrans-2217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: 'The preceding array still has one element too many, `null`. We can use `concat()`
    to prepend it:'
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数组仍然有一个多余的元素`null`。我们可以使用`concat()`来添加：
- en: '[PRE534]'
  id: totrans-2219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: A library method
  id: totrans-2220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个库方法
- en: 'The preceding manual workaround is inspired by a [library method](http://mzl.la/1oOf7sK)
    published by Mozilla. The following is a slightly edited version of it:'
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的手动解决方法是受到Mozilla发布的[库方法](http://mzl.la/1oOf7sK)的启发。以下是它的一个稍微编辑过的版本：
- en: '[PRE535]'
  id: totrans-2222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: 'Here is the method in use:'
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用的方法：
- en: '[PRE536]'
  id: totrans-2224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: An alternative approach
  id: totrans-2225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 另一种方法
- en: 'An alternative to the previous approach is to create an uninitialized instance
    via `Object.create()` and then call the constructor (as a function) via `apply()`.
    That means that you are effectively reimplementing the `new` operator (some checks
    are omitted):'
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法相比的另一种方法是通过`Object.create()`创建一个未初始化的实例，然后通过`apply()`调用构造函数（作为函数）。这意味着您实际上正在重新实现`new`运算符（一些检查被省略）：
- en: '[PRE537]'
  id: totrans-2227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: Warning
  id: totrans-2228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: The preceding code does not work for most built-in constructors, which always
    produce new instances when called as functions. In other words, the step in line
    (1) doesn’t set up `inst` as desired.
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码对于大多数内置构造函数都不起作用，当作为函数调用时总是产生新的实例。换句话说，(1)处的步骤没有设置`inst`为期望的值。
- en: 'Pitfall: Losing this When Extracting a Method'
  id: totrans-2230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 陷阱：提取方法时丢失this
- en: 'If you extract a method from an object, it becomes a true function again. Its
    connection with the object is severed, and it usually doesn’t work properly anymore.
    Take, for example, the following object, `counter`:'
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从对象中提取一个方法，它将再次成为一个真正的函数。它与对象的连接被切断，通常不再正常工作。例如，考虑以下对象`counter`：
- en: '[PRE538]'
  id: totrans-2232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: 'Extracting `inc` and calling it (as a function!) fails:'
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: 提取`inc`并调用它（作为函数！）失败：
- en: '[PRE539]'
  id: totrans-2234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: 'Here’s the explanation: we have called the value of `counter.inc` as a function.
    Hence, `this` is the global object and we have performed `window.count++`. `window.count`
    does not exist and is `undefined`. Applying the `++` operator to it sets it to
    `NaN`:'
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解释：我们已经将`counter.inc`的值作为函数调用。因此，`this`是全局对象，我们执行了`window.count++`。`window.count`不存在，是`undefined`。对它应用`++`运算符会将其设置为`NaN`：
- en: '[PRE540]'
  id: totrans-2236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: How to get a warning
  id: totrans-2237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何获得警告
- en: 'If method `inc()` is in strict mode, you get a warning:'
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法`inc()`处于严格模式，您会收到一个警告：
- en: '[PRE541]'
  id: totrans-2239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: The reason is that when we call the strict mode function `func2`, `this` is
    `undefined`, resulting in an error.
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是当我们调用严格模式函数`func2`时，`this`是`undefined`，导致错误。
- en: How to properly extract a method
  id: totrans-2241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何正确提取方法
- en: 'Thanks to `bind()`, we can make sure that `inc` doesn’t lose the connection
    with `counter`:'
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`bind()`，我们可以确保`inc`不会失去与`counter`的连接：
- en: '[PRE542]'
  id: totrans-2243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: Callbacks and extracted methods
  id: totrans-2244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 回调和提取的方法
- en: 'In JavaScript, there are many functions and methods that accept callbacks.
    Examples in browsers are `setTimeout()` and event handling. If we pass in `counter.inc`
    as a callback, it is also invoked as a function, resulting in the same problem
    just described. To illustrate this phenomenon, let’s use a simple callback-invoking
    function:'
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，有许多接受回调的函数和方法。浏览器中的示例包括`setTimeout()`和事件处理。如果我们将`counter.inc`作为回调传入，它也会作为函数调用，导致刚才描述的相同问题。为了说明这一现象，让我们使用一个简单的回调调用函数：
- en: '[PRE543]'
  id: totrans-2246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: 'Executing `counter.count` via `callIt` triggers a warning (due to strict mode):'
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`callIt`执行`counter.count`会触发警告（由于严格模式）：
- en: '[PRE544]'
  id: totrans-2248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: 'As before, we fix things via `bind()`:'
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们通过`bind()`来修复问题：
- en: '[PRE545]'
  id: totrans-2250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: Warning
  id: totrans-2251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Each call to `bind()` creates a new function. That has consequences when you’re
    registering and unregistering callbacks (e.g., for event handling). You need to
    store the value you registered somewhere and use it for unregistering, too.
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`bind()`都会创建一个新的函数。这在注册和注销回调时（例如事件处理）会产生后果。您需要将注册的值存储在某个地方，并且也需要用它来进行注销。
- en: 'Pitfall: Functions Inside Methods Shadow this'
  id: totrans-2253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 陷阱：方法内部的函数会遮蔽this
- en: 'You often nest function definitions in JavaScript, because functions can be
    parameters (e.g., callbacks) and because they can be created in place, via function
    expressions. This poses a problem when a method contains a normal function and
    you want to access the former’s `this` inside the latter, because the method’s
    `this` is shadowed by the normal function’s `this` (which doesn’t even have any
    use for its own `this`). In the following example, the function at (1) tries to
    access the method’s `this` at (2):'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常在JavaScript中嵌套函数定义，因为函数可以是参数（例如回调），并且因为它们可以通过函数表达式在原地创建。当一个方法包含一个普通函数并且您想在后者内部访问前者的`this`时，这会导致问题，因为方法的`this`被普通函数的`this`遮蔽了（后者甚至对自己的`this`没有任何用处）。在以下示例中，(1)处的函数尝试访问(2)处的方法的`this`：
- en: '[PRE546]'
  id: totrans-2255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: 'Obviously, this fails, because the function at (1) has its own `this`, which
    is `undefined` here:'
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这会失败，因为函数（1）有自己的`this`，在这里是`undefined`：
- en: '[PRE547]'
  id: totrans-2257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: There are three ways to work around this problem.
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以解决这个问题。
- en: 'Workaround 1: that = this'
  id: totrans-2259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方法1：that = this
- en: 'We assign `this` to a variable that won’t be shadowed inside the nested function:'
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`this`分配给一个不会在嵌套函数中被遮蔽的变量：
- en: '[PRE548]'
  id: totrans-2261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: 'Here’s the interaction:'
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE549]'
  id: totrans-2263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: 'Workaround 2: bind()'
  id: totrans-2264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方法2：bind()
- en: 'We can use `bind()` to give the callback a fixed value for `this`—namely, the
    method’s `this` (line (1)):'
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`bind()`为`this`提供一个固定值，即方法的`this`（行（1））：
- en: '[PRE550]'
  id: totrans-2266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: 'Workaround 3: a thisValue for forEach()'
  id: totrans-2267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方法3：forEach()的thisValue
- en: 'A workaround that is specific to `forEach()` (see [Examination Methods](ch18.html#Array_prototype_forEach
    "Examination Methods")) is to provide a second parameter after the callback that
    becomes the `this` of the callback:'
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
  zh: 针对`forEach()`（参见[检查方法](ch18.html#Array_prototype_forEach "检查方法")）的一个特定解决方法是在回调之后提供第二个参数，该参数成为回调的`this`：
- en: '[PRE551]'
  id: totrans-2269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: 'Layer 2: The Prototype Relationship Between Objects'
  id: totrans-2270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2层：对象之间的原型关系
- en: 'The prototype relationship between two objects is about inheritance: every
    object can have another object as its prototype. Then the former object inherits
    all of its prototype’s properties. An object specifies its prototype via the internal
    property `[[Prototype]]`. Every object has this property, but it can be `null`.
    The chain of objects connected by the `[[Prototype]]` property is called the *prototype
    chain* ([Figure 17-1](ch17_split_000.html#figoo_proto_chain "Figure 17-1. A prototype
    chain.")).'
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象之间的原型关系涉及继承：每个对象都可以有另一个对象作为其原型。然后前一个对象继承其原型的所有属性。对象通过内部属性`[[Prototype]]`指定其原型。每个对象都有这个属性，但它可以是`null`。通过`[[Prototype]]`属性连接的对象链称为*原型链*（[图17-1](ch17_split_000.html#figoo_proto_chain
    "图17-1。原型链。")）。
- en: '![A prototype chain.](images/spjs_2101.png)Figure 17-1. A prototype chain.'
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
  zh: '![原型链。](images/spjs_2101.png)图17-1。原型链。'
- en: 'To see how prototype-based (or *prototypal*) inheritance works, let’s look
    at an example (with invented syntax for specifying the `[[Prototype]]` property):'
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解基于原型（或*原型式*）继承的工作原理，让我们看一个例子（使用虚构的语法来指定`[[Prototype]]`属性）：
- en: '[PRE552]'
  id: totrans-2274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: The object `obj` inherits the property `describe` from `proto`. It also has
    a so-called *own* (noninherited, direct) property, `name`.
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`obj`从`proto`继承了属性`describe`。它还有一个所谓的*自有*（非继承的，直接的）属性，`name`。
- en: Inheritance
  id: totrans-2276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: '`obj` inherits the property `describe`; you can access it as if the object
    itself had that property:'
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj`继承了属性`describe`；您可以像对象本身拥有该属性一样访问它：'
- en: '[PRE553]'
  id: totrans-2278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: 'Whenever you access a property via `obj`, JavaScript starts the search for
    it in that object and continues with its prototype, the prototype’s prototype,
    and so on. That’s why we can access `proto.describe` via `obj.describe`. The prototype
    chain behaves as if it were a single object. That illusion is maintained when
    you call a method: the value of `this` is always the object where the search for
    the method began, not where the method was found. That allows the method to access
    all of the properties of the prototype chain. For example:'
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: 每当通过`obj`访问属性时，JavaScript会从该对象开始搜索，并继续搜索其原型、原型的原型等。这就是为什么我们可以通过`obj.describe`访问`proto.describe`。原型链的行为就像它是一个单一对象一样。当调用方法时，这种幻觉总是保持：`this`的值始终是方法开始搜索的对象，而不是找到方法的对象。这允许方法访问原型链的所有属性。例如：
- en: '[PRE554]'
  id: totrans-2280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: Inside `describe()`, `this` is `obj`, which allows the method to access `obj.name`.
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
  zh: 在`describe()`内部，`this`是`obj`，这允许该方法访问`obj.name`。
- en: Overriding
  id: totrans-2282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖
- en: 'In a prototype chain, a property in an object *overrides* a property with the
    same key in a “later” object: the former property is found first. It hides the
    latter property, which can’t be accessed anymore. As an example, let’s override
    the method `proto.describe()` in `obj`:'
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: 在原型链中，对象中的属性*覆盖*了“后来”对象中具有相同键的属性：首先找到前者属性。它隐藏了后者属性，后者属性无法再被访问。例如，让我们在`obj`中覆盖方法`proto.describe()`：
- en: '[PRE555]'
  id: totrans-2284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: That is similar to how overriding of methods works in class-based languages.
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于类语言中方法覆盖的工作原理。
- en: Sharing Data Between Objects via a Prototype
  id: totrans-2286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过原型在对象之间共享数据
- en: 'Prototypes are great for sharing data between objects: several objects get
    the same prototype, which holds all shared properties. Let’s look at an example.
    The objects `jane` and `tarzan` both contain the same method, `describe()`. That
    is something that we would like to avoid by using sharing:'
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: 原型非常适合在对象之间共享数据：多个对象获得相同的原型，其中包含所有共享的属性。让我们看一个例子。对象`jane`和`tarzan`都包含相同的方法`describe()`。这是我们希望通过共享来避免的事情：
- en: '[PRE556]'
  id: totrans-2288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: Both objects are persons. Their `name` property is different, but we could have
    them share the method `describe`. We do that by creating a common prototype called
    `PersonProto` and putting `describe` into it ([Figure 17-2](ch17_split_000.html#figoo_person_shared
    "Figure 17-2. The objects jane and tarzan share the prototype PersonProto and
    thus the property describe.")).
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象都是人。它们的`name`属性不同，但我们可以让它们共享`describe`方法。我们通过创建一个名为`PersonProto`的共同原型，并将`describe`放入其中来实现这一点（[图17-2](ch17_split_000.html#figoo_person_shared
    "图17-2。对象jane和tarzan共享原型PersonProto，因此共享属性describe。")）。
- en: '![The objects jane and tarzan share the prototype PersonProto and thus the
    property describe.](images/spjs_2102.png)Figure 17-2. The objects jane and tarzan
    share the prototype PersonProto and thus the property describe.'
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: '![对象jane和tarzan共享原型PersonProto，因此共享属性describe。](images/spjs_2102.png)图17-2。对象jane和tarzan共享原型PersonProto，因此共享属性describe。'
- en: 'The following code creates objects `jane` and `tarzan` that share the prototype
    `PersonProto`:'
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了对象`jane`和`tarzan`，它们共享原型`PersonProto`：
- en: '[PRE557]'
  id: totrans-2292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: 'And here is the interaction:'
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE558]'
  id: totrans-2294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: 'This is a common pattern: the data resides in the first object of a prototype
    chain, while methods reside in later objects. JavaScript’s flavor of prototypal
    inheritance is designed to support this pattern: setting a property affects only
    the first object in a prototype chain, whereas getting a property considers the
    complete chain (see [Setting and Deleting Affects Only Own Properties](ch17_split_000.html#setting_properties_proto_chain
    "Setting and Deleting Affects Only Own Properties")).'
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的模式：数据驻留在原型链的第一个对象中，而方法驻留在后来的对象中。JavaScript的原型继承设计支持这种模式：设置属性仅影响原型链中的第一个对象，而获取属性则考虑整个链条（参见[设置和删除仅影响自有属性](ch17_split_000.html#setting_properties_proto_chain
    "设置和删除仅影响自有属性")）。
- en: Getting and Setting the Prototype
  id: totrans-2296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取和设置原型
- en: So far, we have pretended that you can access the internal property `[[Prototype]]`
    from JavaScript. But the language does not let you do that. Instead, there are
    functions for reading the prototype and for creating a new object with a given
    prototype.
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假装你可以从JavaScript中访问内部属性`[[Prototype]]`。但是语言不允许你这样做。相反，有用于读取原型和创建具有给定原型的新对象的函数。
- en: Creating a new object with a given prototype
  id: totrans-2298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建具有给定原型的新对象
- en: 'This invocation:'
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用：
- en: '[PRE559]'
  id: totrans-2300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: 'creates an object whose prototype is `proto`. Optionally, properties can be
    added via descriptors (which are explained in [Property Descriptors](ch17_split_000.html#property_descriptors
    "Property Descriptors")). In the following example, object `jane` gets the prototype
    `PersonProto` and a mutable property `name` whose value is `''Jane''` (as specified
    via a property descriptor):'
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个原型为`proto`的对象。可以通过描述符添加属性（在[属性描述符](ch17_split_000.html#property_descriptors
    "属性描述符")中有解释）。在以下示例中，对象`jane`获得了原型`PersonProto`和一个可变属性`name`，其值为'Jane'（通过属性描述符指定）：
- en: '[PRE560]'
  id: totrans-2302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: 'Here is the interaction:'
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE561]'
  id: totrans-2304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: 'But you frequently just create an empty object and then manually add properties,
    because descriptors are verbose:'
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你经常只是创建一个空对象，然后手动添加属性，因为描述符太啰嗦了：
- en: '[PRE562]'
  id: totrans-2306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: Reading the prototype of an object
  id: totrans-2307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取对象的原型
- en: 'This method call:'
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法调用：
- en: '[PRE563]'
  id: totrans-2309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: 'returns the prototype of `obj`. Continuing the preceding example:'
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`obj`的原型。继续前面的例子：
- en: '[PRE564]'
  id: totrans-2311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: Checking whether one object a prototype of another one
  id: totrans-2312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查一个对象是否是另一个对象的原型
- en: 'This syntax:'
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法：
- en: '[PRE565]'
  id: totrans-2314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: 'checks whether the receiver of the method is a (direct or indirect) prototype
    of `obj`. In other words: are the receiver and `obj` in the same prototype chain,
    and does `obj` come before the receiver? For example:'
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
  zh: 检查方法的接收者是否是`obj`的（直接或间接）原型。换句话说：接收者和`obj`是否在同一个原型链中，`obj`是否在接收者之前？例如：
- en: '[PRE566]'
  id: totrans-2316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: Finding the object where a property is defined
  id: totrans-2317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找定义属性的对象
- en: 'The following function iterates over the property chain of an object `obj`.
    It returns the first object that has an own property with the key `propKey`, or
    `null` if there is no such object:'
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数遍历对象`obj`的属性链。它返回第一个具有键`propKey`的自有属性的对象，如果没有这样的对象，则返回`null`：
- en: '[PRE567]'
  id: totrans-2319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: 'In the preceding code, we called the method `Object.prototype.hasOwnProperty`
    generically (see [Generic Methods: Borrowing Methods from Prototypes](ch17_split_001.html#generic_method
    "Generic Methods: Borrowing Methods from Prototypes")).'
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通用地调用了方法`Object.prototype.hasOwnProperty`（参见[通用方法：从原型中借用方法](ch17_split_001.html#generic_method
    "通用方法：从原型中借用方法")）。
- en: The Special Property __proto__
  id: totrans-2321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊属性__proto__
- en: 'Some JavaScript engines have a special property for getting and setting the
    prototype of an object: `__proto__`. It brings direct access to `[[Prototype]]`
    to the language:'
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: 一些JavaScript引擎有一个特殊的属性，用于获取和设置对象的原型：`__proto__`。它为语言带来了对`[[Prototype]]`的直接访问：
- en: '[PRE568]'
  id: totrans-2323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: 'There are several things you need to know about `__proto__`:'
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事情你需要知道关于`__proto__`：
- en: '`__proto__` is pronounced “dunder proto,” an abbreviation of “double underscore
    proto.” That pronunciation has been borrowed from the Python programming language
    (as [suggested by Ned Batchelder](http://bit.ly/1fwlzN8) in 2006). Special variables
    with double underscores are quite frequent in Python.'
  id: totrans-2325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__proto__`的发音是“dunder proto”，是“double underscore proto”的缩写。这种发音是从Python编程语言中借来的（如Ned
    Batchelder在2006年所建议的）。在Python中，双下划线的特殊变量非常频繁。'
- en: '`__proto__` is not part of the ECMAScript 5 standard. Therefore, you must not
    use it if you want your code to conform to that standard and run reliably across
    current JavaScript engines.'
  id: totrans-2326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__proto__`不是ECMAScript 5标准的一部分。因此，如果您希望您的代码符合该标准并且可以在当前的JavaScript引擎中可靠运行，那么您不应该使用它。'
- en: However, more and more engines are adding support for `__proto__` and it will
    be part of ECMAScript 6.
  id: totrans-2327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，越来越多的引擎正在添加对`__proto__`的支持，它将成为ECMAScript 6的一部分。
- en: 'The following expression checks whether an engine supports `__proto__` as a
    special property:'
  id: totrans-2328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下表达式检查引擎是否支持`__proto__`作为特殊属性：
- en: '[PRE569]'
  id: totrans-2329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: Setting and Deleting Affects Only Own Properties
  id: totrans-2330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置和删除仅影响自有属性
- en: Only getting a property considers the complete prototype chain of an object.
    Setting and deleting ignores inheritance and affects only own properties.
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
  zh: 只有获取属性才会考虑对象的完整原型链。设置和删除会忽略继承，只影响自有属性。
- en: Setting a property
  id: totrans-2332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置属性
- en: 'Setting a property creates an own property, even if there is an inherited property
    with that key. For example, given the following source code:'
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
  zh: 设置属性会创建一个自有属性，即使存在具有该键的继承属性。例如，给定以下源代码：
- en: '[PRE570]'
  id: totrans-2334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '`obj` inherits `foo` from `proto`:'
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj`从`proto`继承了`foo`： '
- en: '[PRE571]'
  id: totrans-2336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: 'Setting `foo` has the desired result:'
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`foo`会产生期望的结果：
- en: '[PRE572]'
  id: totrans-2338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: 'However, we have created an own property and not changed `proto.foo`:'
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们创建了一个自有属性，而没有改变`proto.foo`：
- en: '[PRE573]'
  id: totrans-2340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: The rationale is that prototype properties are meant to be shared by several
    objects. This approach allows us to nondestructively “change” them—only the current
    object is affected.
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: 其原因是原型属性应该被多个对象共享。这种方法允许我们非破坏性地“改变”它们——只有当前对象受到影响。
- en: Deleting an inherited property
  id: totrans-2342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除继承属性
- en: 'You can only delete own properties. Let’s again set up an object, `obj`, with
    a prototype, `proto`:'
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能删除自有属性。让我们再次设置一个对象`obj`，并具有原型`proto`：
- en: '[PRE574]'
  id: totrans-2344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: 'Deleting the inherited property `foo` has no effect:'
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 删除继承的属性`foo`没有效果：
- en: '[PRE575]'
  id: totrans-2346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: For more information on the `delete` operator, consult [Deleting properties](ch17_split_000.html#operator_delete
    "Deleting properties").
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`delete`运算符的更多信息，请参阅[删除属性](ch17_split_000.html#operator_delete "删除属性")。
- en: Changing properties anywhere in the prototype chain
  id: totrans-2348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在原型链的任何位置更改属性
- en: 'If you want to change an inherited property, you first have to find the object
    that owns it (see [Finding the object where a property is defined](ch17_split_000.html#code_getDefiningObject
    "Finding the object where a property is defined")) and then perform the change
    on that object. For example, let’s delete the property `foo` from the previous
    example:'
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要更改继承的属性，首先必须找到拥有该属性的对象（参见[查找定义属性的对象](ch17_split_000.html#code_getDefiningObject
    "查找定义属性的对象")），然后在该对象上执行更改。例如，让我们从前面的示例中删除属性`foo`：
- en: '[PRE576]'
  id: totrans-2350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: Iteration and Detection of Properties
  id: totrans-2351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性的迭代和检测
- en: 'Operations for iterating over and detecting properties are influenced by:'
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代和检测属性的操作受以下因素的影响：
- en: Inheritance (own properties versus inherited properties)
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
  zh: 继承（自有属性与继承属性）
- en: An own property of an object is stored directly in that object. An inherited
    property is stored in one of its prototypes.
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的自有属性直接存储在该对象中。继承的属性存储在其原型之一中。
- en: Enumerability (enumerable properties versus nonenumerable properties)
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
  zh: 可枚举性（可枚举属性与不可枚举属性）
- en: 'The enumerability of a property is an *attribute* (see [Property Attributes
    and Property Descriptors](ch17_split_000.html#property_attributes "Property Attributes
    and Property Descriptors")), a flag that can be `true` or `false`. Enumerability
    rarely matters and can normally be ignored (see [Enumerability: Best Practices](ch17_split_001.html#enumerability_best_practices
    "Enumerability: Best Practices")).'
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的可枚举性是一个*属性*（参见[属性特性和属性描述符](ch17_split_000.html#property_attributes "属性特性和属性描述符")），一个可以是`true`或`false`的标志。可枚举性很少重要，通常可以忽略（参见[可枚举性：最佳实践](ch17_split_001.html#enumerability_best_practices
    "可枚举性：最佳实践")）。
- en: You can list own property keys, list all enumerable property keys, and check
    whether a property exists. The following subsections show how.
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以列出自有属性键，列出所有可枚举属性键，并检查属性是否存在。以下各小节显示了如何操作。
- en: Listing Own Property Keys
  id: totrans-2358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出自有属性键
- en: 'You can either list all own property keys, or only enumerable ones:'
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以列出所有自有属性键，或仅列出可枚举的属性键：
- en: '`Object.getOwnPropertyNames(obj)` returns the keys of all own properties of
    `obj`.'
  id: totrans-2360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertyNames(obj)`返回`obj`的所有自有属性的键。'
- en: '`Object.keys(obj)` returns the keys of all enumerable own properties of `obj`.'
  id: totrans-2361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.keys(obj)`返回`obj`的所有可枚举自有属性的键。'
- en: 'Note that properties are normally enumerable (see [Enumerability: Best Practices](ch17_split_001.html#enumerability_best_practices
    "Enumerability: Best Practices")), so you can use `Object.keys()`, especially
    for objects that you have created.'
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，属性通常是可枚举的（参见[可枚举性：最佳实践](ch17_split_001.html#enumerability_best_practices
    "可枚举性：最佳实践")），因此您可以使用`Object.keys()`，特别是对于您创建的对象。
- en: Listing All Property Keys
  id: totrans-2363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出所有属性键
- en: If you want to list all properties (both own and inherited ones) of an object,
    then you have two options.
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要列出对象的所有属性（自有和继承的属性），则有两种选择。
- en: 'Option 1 is to use the loop:'
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
  zh: 选项1是使用循环：
- en: '[PRE577]'
  id: totrans-2366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: to iterate over the keys of all enumerable properties of `object`. See [for-in](ch13.html#for-in
    "for-in") for a more thorough description.
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历`object`的所有可枚举属性的键。有关更详细的描述，请参见[for-in](ch13.html#for-in "for-in")。
- en: 'Option 2 is to implement a function yourself that iterates over all properties
    (not just enumerable ones). For example:'
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
  zh: 选项2是自己实现一个函数，该函数迭代所有属性（而不仅仅是可枚举的属性）。例如：
- en: '[PRE578]'
  id: totrans-2369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: Checking Whether a Property Exists
  id: totrans-2370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查属性是否存在
- en: 'You can check whether an object has a property, or whether a property exists
    directly inside an object:'
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查对象是否具有属性，或者属性是否直接存在于对象内部：
- en: '`propKey in obj`'
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
  zh: '`propKey in obj`'
- en: Returns `true` if `obj` has a property whose key is `propKey`. Inherited properties
    are included in this test.
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`obj`具有键为`propKey`的属性，则返回`true`。继承的属性也包括在此测试中。
- en: '`Object.prototype.hasOwnProperty(propKey)`'
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.prototype.hasOwnProperty(propKey)`'
- en: Returns `true` if the receiver (`this`) has an own (noninherited) property whose
    key is `propKey`.
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收者（`this`）具有键为`propKey`的自有（非继承）属性，则返回`true`。
- en: Warning
  id: totrans-2376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: 'Avoid invoking `hasOwnProperty()` directly on an object, as it may be overridden
    (e.g., by an own property whose key is `hasOwnProperty`):'
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
  zh: 避免直接在对象上调用`hasOwnProperty()`，因为它可能被覆盖（例如，由一个键为`hasOwnProperty`的自有属性）：
- en: '[PRE579]'
  id: totrans-2378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: 'Instead, it is better to call it generically (see [Generic Methods: Borrowing
    Methods from Prototypes](ch17_split_001.html#generic_method "Generic Methods:
    Borrowing Methods from Prototypes")):'
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，最好通用调用它（参见[通用方法：从原型中借用方法](ch17_split_001.html#generic_method "通用方法：从原型中借用方法")）：
- en: '[PRE580]'
  id: totrans-2380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: Examples
  id: totrans-2381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'The following examples are based on these definitions:'
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例基于这些定义：
- en: '[PRE581]'
  id: totrans-2383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '`Object.defineProperties()` is explained in [Getting and Defining Properties
    via Descriptors](ch17_split_000.html#functions_for_property_descriptors "Getting
    and Defining Properties via Descriptors"), but it should be fairly obvious how
    it works: `proto` has the own properties `protoEnumTrue` and `protoEnumFalse`
    and `obj` has the own properties `objEnumTrue` and `objEnumFalse` (and inherits
    all of `proto`’s properties).'
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.defineProperties()`在[通过描述符获取和定义属性](ch17_split_000.html#functions_for_property_descriptors
    "通过描述符获取和定义属性")中有解释，但它的工作原理应该是相当明显的：`proto`具有自有属性`protoEnumTrue`和`protoEnumFalse`，`obj`具有自有属性`objEnumTrue`和`objEnumFalse`（并继承了`proto`的所有属性）。'
- en: Note
  id: totrans-2385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that objects (such as `proto` in the preceding example) normally have
    at least the prototype `Object.prototype` (where standard methods such as `toString()`
    and `hasOwnProperty()` are defined):'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对象（例如前面示例中的`proto`）通常至少具有原型`Object.prototype`（其中定义了标准方法，如`toString()`和`hasOwnProperty()`）：
- en: '[PRE582]'
  id: totrans-2387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: The effects of enumerability
  id: totrans-2388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可枚举性的影响
- en: Among property-related operations, enumberability only influences the `for-in`
    loop and `Object.keys()` (it also influences `JSON.stringify()`, see [JSON.stringify(value,
    replacer?, space?)](ch22.html#JSON.stringify "JSON.stringify(value, replacer?,
    space?)")).
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性相关的操作中，可枚举性只影响`for-in`循环和`Object.keys()`（它也影响`JSON.stringify()`，参见[JSON.stringify(value,
    replacer?, space?)](ch22.html#JSON.stringify "JSON.stringify(value, replacer?,
    space?)")）。
- en: 'The `for-in` loop iterates over the keys of all enumerable properties, including
    inherited ones (note that none of the nonenumerable properties of `Object.prototype`
    show up):'
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-in`循环遍历所有可枚举属性的键，包括继承的属性（注意`Object.prototype`的不可枚举属性都不会显示）：'
- en: '[PRE583]'
  id: totrans-2391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '`Object.keys()` returns the keys of all own (noninherited) enumerable properties:'
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.keys()`返回所有自有（非继承的）可枚举属性的键：'
- en: '[PRE584]'
  id: totrans-2393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: 'If you want the keys of all own properties, you need to use `Object.getOwnPropertyNames()`:'
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要所有自有属性的键，你需要使用`Object.getOwnPropertyNames()`：
- en: '[PRE585]'
  id: totrans-2395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: The effects of inheritance
  id: totrans-2396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 继承的影响
- en: 'Only the `for-in` loop (see the previous example) and the `in` operator consider
    inheritance:'
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`for-in`循环（参见上面的示例）和`in`运算符考虑继承：
- en: '[PRE586]'
  id: totrans-2398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: Computing the number of own properties of an object
  id: totrans-2399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算对象的自有属性数量
- en: 'Objects don’t have a method such as `length` or `size`, so you have to use
    the following workaround:'
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
  zh: 对象没有`length`或`size`这样的方法，所以你必须使用以下的解决方法：
- en: '[PRE587]'
  id: totrans-2401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: 'Best Practices: Iterating over Own Properties'
  id: totrans-2402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践：遍历自有属性
- en: 'To iterate over property keys:'
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历属性键：
- en: 'Combine `for-in` with `hasOwnProperty()`, in the manner described in [for-in](ch13.html#for-in
    "for-in"). This works even on older JavaScript engines. For example:'
  id: totrans-2404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合`for-in`和`hasOwnProperty()`，以[for-in](ch13.html#for-in "for-in")中描述的方式。这甚至可以在旧的JavaScript引擎上工作。例如：
- en: '[PRE588]'
  id: totrans-2405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: 'Combine `Object.keys()` or `Object.getOwnPropertyNames()` with `forEach()`
    array iteration:'
  id: totrans-2406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合`Object.keys()`或`Object.getOwnPropertyNames()`与`forEach()`数组迭代：
- en: '[PRE589]'
  id: totrans-2407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: 'To iterate over property values or over (key, value) pairs:'
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历属性值或(key, value)对：
- en: Iterate over the keys, and use each key to retrieve the corresponding value.
    Other languages make this simpler, but not JavaScript.
  id: totrans-2409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历键，并使用每个键检索相应的值。其他语言可能会更简单，但JavaScript不会。
- en: Accessors (Getters and Setters)
  id: totrans-2410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问器（Getters和Setters）
- en: ECMAScript 5 lets you write methods whose invocations look like you are getting
    or setting a property. That means that a property is virtual and not storage space.
    You could, for example, forbid setting a property and always compute the value
    returned when reading it.
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 5允许你编写方法，其调用看起来像是在获取或设置属性。这意味着属性是虚拟的，而不是存储空间。例如，你可以禁止设置属性，并且总是在读取时计算返回的值。
- en: Defining Accessors via an Object Literal
  id: totrans-2412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过对象字面量定义访问器
- en: 'The following example uses an object literal to define a setter and a getter
    for property `foo`:'
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用对象字面量为属性`foo`定义了一个setter和一个getter：
- en: '[PRE590]'
  id: totrans-2414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: 'Here’s the interaction:'
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE591]'
  id: totrans-2416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: Defining Accessors via Property Descriptors
  id: totrans-2417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过属性描述符定义访问器
- en: 'An alternate way to specify getters and setters is via property descriptors
    (see [Property Descriptors](ch17_split_000.html#property_descriptors "Property
    Descriptors")). The following code defines the same object as the preceding literal:'
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
  zh: 指定getter和setter的另一种方式是通过属性描述符（参见[属性描述符](ch17_split_000.html#property_descriptors
    "属性描述符")）。以下代码定义了与前面的字面量相同的对象：
- en: '[PRE592]'
  id: totrans-2419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: Accessors and Inheritance
  id: totrans-2420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问器和继承
- en: 'Getters and setters are inherited from prototypes:'
  id: totrans-2421
  prefs: []
  type: TYPE_NORMAL
  zh: Getter和setter是从原型继承的：
- en: '[PRE593]'
  id: totrans-2422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: Property Attributes and Property Descriptors
  id: totrans-2423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性属性和属性描述符
- en: Tip
  id: totrans-2424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Property attributes and property descriptors are an advanced topic. You normally
    don’t need to know how they work.
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
  zh: 属性属性和属性描述符是一个高级主题。通常你不需要知道它们是如何工作的。
- en: 'In this section, we’ll look at the internal structure of properties:'
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下属性的内部结构：
- en: '*Property attributes* are the atomic building blocks of properties.'
  id: totrans-2427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性属性*是属性的原子构建块。'
- en: A *property descriptor* is a data structure for working programmatically with
    attributes.
  id: totrans-2428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性描述符*是一个用于以编程方式处理属性的数据结构。'
- en: Property Attributes
  id: totrans-2429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性属性
- en: All of a property’s state, both its data and its metadata, is stored in *attributes*.
    They are fields that a property has, much like an object has properties. Attribute
    keys are often written in double brackets. Attributes matter for normal properties
    and for accessors (getters and setters).
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的所有状态，包括其数据和元数据，都存储在*属性*中。它们是属性具有的字段，就像对象具有属性一样。属性键通常用双括号写入。属性对于普通属性和访问器（getter和setter）都很重要。
- en: 'The following attributes are specific to normal properties:'
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
  zh: 以下属性是特定于普通属性的：
- en: '`[[Value]]` holds the property’s value, its data.'
  id: totrans-2432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[Value]]`保存属性的值，它的数据。'
- en: '`[[Writable]]` holds a boolean indicating whether the value of a property can
    be changed.'
  id: totrans-2433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[Writable]]`保存一个布尔值，指示属性的值是否可以被更改。'
- en: 'The following attributes are specific to accessors:'
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: 以下属性是特定于访问器的：
- en: '`[[Get]]` holds the getter, a function that is called when a property is read.
    The function computes the result of the read access.'
  id: totrans-2435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[Get]]`保存getter，当属性被读取时调用的函数。该函数计算读取访问的结果。'
- en: '`[[Set]]` holds the setter, a function that is called when a property is set
    to a value. The function receives that value as a parameter.'
  id: totrans-2436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[Set]]`保存setter，当属性被设置为一个值时调用的函数。该函数将该值作为参数接收。'
- en: 'All properties have the following attributes:'
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属性都具有以下属性：
- en: '`[[Enumerable]]` holds a boolean. Making a property nonenumerable hides it
    from some operations (see [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")).'
  id: totrans-2438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[Enumerable]]`保存一个布尔值。使属性不可枚举会隐藏它，使其无法被某些操作检测到（参见[属性的迭代和检测](ch17_split_000.html#iterate_and_detect_properties
    "属性的迭代和检测")）。'
- en: '`[[Configurable]]` holds a boolean. If it is `false`, you cannot delete a property,
    change any of its attributes (except `[[Value]]`), or convert it from a data property
    to an accessor property or vice versa. In other words, `[[Configurable]]` controls
    the writability of a property’s metadata. There is one exception to this rule—JavaScript
    allows you to change an unconfigurable property from writable to read-only, for
    [historic reasons](http://bit.ly/1fwlIQI); the property `length` of arrays has
    always been writable and unconfigurable. Without this exception, you wouldn’t
    be able to freeze (see [Freezing](ch17_split_001.html#freezing_objects "Freezing"))
    arrays.'
  id: totrans-2439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[可配置]]`保存一个布尔值。如果它是`false`，您不能删除属性，更改其任何属性（除了`[[值]]`），或者将其从数据属性转换为访问器属性，反之亦然。换句话说，`[[可配置]]`控制属性元数据的可写性。有一个例外规则
    - JavaScript允许您将不可配置的属性从可写更改为只读，出于[历史原因](http://bit.ly/1fwlIQI)；数组的属性`length`一直是可写的且不可配置的。没有这个例外，您将无法冻结（参见[冻结](ch17_split_001.html#freezing_objects
    "冻结")）数组。'
- en: Default values
  id: totrans-2440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 默认值
- en: 'If you don’t specify attributes, the following defaults are used:'
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不指定属性，则使用以下默认值：
- en: '| Attribute key | Default value |'
  id: totrans-2442
  prefs: []
  type: TYPE_TB
  zh: '| 属性键 | 默认值 |'
- en: '| --- | --- |'
  id: totrans-2443
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `[[Value]]` | `undefined` |'
  id: totrans-2444
  prefs: []
  type: TYPE_TB
  zh: '| `[[值]]` | `undefined` |'
- en: '| `[[Get]]` | `undefined` |'
  id: totrans-2445
  prefs: []
  type: TYPE_TB
  zh: '| `[[获取]]` | `undefined` |'
- en: '| `[[Set]]` | `undefined` |'
  id: totrans-2446
  prefs: []
  type: TYPE_TB
  zh: '| `[[设置]]` | `undefined` |'
- en: '| `[[Writable]]` | `false` |'
  id: totrans-2447
  prefs: []
  type: TYPE_TB
  zh: '| `[[可写]]` | `false` |'
- en: '| `[[Enumerable]]` | `false` |'
  id: totrans-2448
  prefs: []
  type: TYPE_TB
  zh: '| `[[可枚举]]` | `false` |'
- en: '| `[[Configurable]]` | `false` |'
  id: totrans-2449
  prefs: []
  type: TYPE_TB
  zh: '| `[[可配置]]` | `false` |'
- en: These defaults are important when you are creating properties via property descriptors
    (see the following section).
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过属性描述符创建属性时，这些默认值非常重要（请参阅下一节）。
- en: Property Descriptors
  id: totrans-2451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性描述符
- en: 'A property descriptor is a data structure for working programmatically with
    attributes. It is an object that encodes the attributes of a property. Each of
    a descriptor’s properties corresponds to an attribute. For example, the following
    is the descriptor of a read-only property whose value is 123:'
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
  zh: 属性描述符是用于以编程方式处理属性的数据结构。它是一个编码属性的属性的对象。描述符的每个属性对应一个属性。例如，以下是值为123的只读属性的描述符：
- en: '[PRE594]'
  id: totrans-2453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: 'You can achieve the same goal, immutability, via accessors. Then the descriptor
    looks as follows:'
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问器实现相同的目标，即不可变性。然后描述符如下所示：
- en: '[PRE595]'
  id: totrans-2455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: Getting and Defining Properties via Descriptors
  id: totrans-2456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过描述符获取和定义属性
- en: 'Property descriptors are used for two kinds of operations:'
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
  zh: 属性描述符用于两种操作：
- en: Getting a property
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
  zh: 获取属性
- en: All attributes of a property are returned as a descriptor.
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的所有属性都作为描述符返回。
- en: Defining a property
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: 定义属性
- en: 'Defining a property means something different depending on whether a property
    already exists:'
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
  zh: 定义属性意味着根据属性是否已存在而有所不同：
- en: 'If a property does not exist, create a new property whose attributes are as
    specified by the descriptor. If an attribute has no corresponding property in
    the descriptor, then use the default value. The defaults are dictated by what
    the attribute names mean. They are the opposite of the values that are used when
    creating a property via assignment (then the property is writable, enumerable,
    and configurable). For example:'
  id: totrans-2462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性不存在，则创建一个新属性，其属性由描述符指定。如果描述符中没有相应的属性，则使用默认值。默认值由属性名称的含义决定。它们与通过赋值创建属性时使用的值相反（然后属性是可写的，可枚举的和可配置的）。例如：
- en: '[PRE596]'
  id: totrans-2463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: I usually don’t rely on the defaults and explicitly state all attributes, to
    be completely clear.
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常不依赖默认值，并明确声明所有属性，以确保完全清晰。
- en: 'If a property already exists, update the attributes of the property as specified
    by the descriptor. If an attribute has no corresponding property in the descriptor,
    then don’t change it. Here is an example (continued from the previous one):'
  id: totrans-2465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性已经存在，则根据描述符指定的属性更新属性的属性。如果描述符中没有相应的属性，则不要更改它。这是一个例子（从上一个例子继续）：
- en: '[PRE597]'
  id: totrans-2466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: 'The following operations allow you to get and set a property’s attributes via
    property descriptors:'
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作允许您通过属性描述符获取和设置属性的属性：
- en: '`Object.getOwnPropertyDescriptor(obj, propKey)`'
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertyDescriptor(obj, propKey)`'
- en: 'Returns the descriptor of the own (noninherited) property of `obj` whose key
    is `propKey`. If there is no such property, `undefined` is returned:'
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`obj`的自有（非继承的）属性的描述符，其键为`propKey`。如果没有这样的属性，则返回`undefined`：
- en: '[PRE598]'
  id: totrans-2470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '`Object.defineProperty(obj, propKey, propDesc)`'
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.defineProperty(obj, propKey, propDesc)`'
- en: 'Create or change a property of `obj` whose key is `propKey` and whose attributes
    are specified via `propDesc`. Return the modified object. For example:'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: 创建或更改`obj`的属性，其键为`propKey`，其属性通过`propDesc`指定。返回修改后的对象。例如：
- en: '[PRE599]'
  id: totrans-2473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '`Object.defineProperties(obj, propDescObj)`'
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.defineProperties(obj, propDescObj)`'
- en: 'The batch version of `Object.defineProperty()`. Each property of `propDescObj`
    holds a property descriptor. The keys of the properties and their values tell
    `Object.defineProperties` what properties to create or change on `obj`. For example:'
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.defineProperty()`的批量版本。`propDescObj`的每个属性都保存一个属性描述符。属性的键和它们的值告诉`Object.defineProperties`在`obj`上创建或更改哪些属性。例如：'
- en: '[PRE600]'
  id: totrans-2476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '`Object.create(proto, propDescObj?)`'
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.create(proto, propDescObj?)`'
- en: 'First, create an object whose prototype is `proto`. Then, if the optional parameter
    `propDescObj` has been specified, add properties to it—in the same manner as `Object.defineProperties`.
    Finally, return the result. For example, the following code snippet produces the
    same result as the previous snippet:'
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个原型为`proto`的对象。然后，如果已指定可选参数`propDescObj`，则以与`Object.defineProperties`相同的方式向其添加属性。最后，返回结果。例如，以下代码片段产生与上一个片段相同的结果：
- en: '[PRE601]'
  id: totrans-2479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: Copying an Object
  id: totrans-2480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制对象
- en: 'To create an identical copy of an object, you need to get two things right:'
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建对象的相同副本，您需要正确获取两件事：
- en: 'The copy must have the same prototype (see [Layer 2: The Prototype Relationship
    Between Objects](ch17_split_000.html#prototype_relationship "Layer 2: The Prototype
    Relationship Between Objects")) as the original.'
  id: totrans-2482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制必须具有与原始对象相同的原型（参见[第2层：对象之间的原型关系](ch17_split_000.html#prototype_relationship
    "第2层：对象之间的原型关系")）。
- en: The copy must have the same properties, with the same attributes as the original.
  id: totrans-2483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制必须具有与原始对象相同的属性，并且具有相同的属性。
- en: 'The following function performs such a copy:'
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数执行这样的复制：
- en: '[PRE602]'
  id: totrans-2485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: 'The properties are copied from `orig` to `copy` via this function:'
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
  zh: 属性通过这个函数从`orig`复制到`copy`。
- en: '[PRE603]'
  id: totrans-2487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: 'These are the steps involved:'
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的步骤如下：
- en: Get an array with the keys of all own properties of `source`.
  id: totrans-2489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个包含`source`的所有自有属性键的数组。
- en: Iterate over those keys.
  id: totrans-2490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历这些键。
- en: Retrieve a property descriptor.
  id: totrans-2491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索属性描述符。
- en: Use that property descriptor to create an own property in `target`.
  id: totrans-2492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该属性描述符在`target`中创建一个自有属性。
- en: Note that this function is very similar to the function [`_.extend()`](http://underscorejs.org/#extend)
    in the Underscore.js library.
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个函数与Underscore.js库中的函数[`_.extend()`](http://underscorejs.org/#extend)非常相似。
- en: 'Properties: Definition Versus Assignment'
  id: totrans-2494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性：定义与赋值
- en: 'The following two operations are very similar:'
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个操作非常相似：
- en: Defining a property via `defineProperty()` and `defineProperties()` (see [Getting
    and Defining Properties via Descriptors](ch17_split_000.html#functions_for_property_descriptors
    "Getting and Defining Properties via Descriptors")).
  id: totrans-2496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`defineProperty()`和`defineProperties()`（参见[通过描述符获取和定义属性](ch17_split_000.html#functions_for_property_descriptors
    "通过描述符获取和定义属性")）定义属性。
- en: Assigning to a property via `=`.
  id: totrans-2497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`=`对属性进行赋值。
- en: 'There are, however, a few subtle differences:'
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些微妙的差异：
- en: '*Defining a property* means creating a new own property or updating the attributes
    of an existing own property. In both cases, the prototype chain is completely
    ignored.'
  id: totrans-2499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义属性*意味着创建一个新的自有属性或更新现有自有属性的属性。在这两种情况下，原型链完全被忽略。'
- en: '*Assigning to a property* `prop` means changing an existing property. The process
    is as follows:'
  id: totrans-2500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对属性进行赋值* `prop`意味着改变现有属性。过程如下：'
- en: If `prop` is a setter (own or inherited), call that setter.
  id: totrans-2501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`prop`是一个setter（自有或继承的），调用该setter。
- en: Otherwise, if `prop` is read-only (own or inherited), throw an exception (in
    strict mode) or do nothing (in sloppy mode). The next section explains this (slightly
    unexpected) phenomenon in more detail.
  id: totrans-2502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果`prop`是只读的（自有或继承的），抛出异常（在严格模式下）或不做任何操作（在松散模式下）。下一节将更详细地解释这个（稍微意外的）现象。
- en: Otherwise, if `prop` is own (and writable), change the value of that property.
  id: totrans-2503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果`prop`是自有的（并且可写的），改变该属性的值。
- en: Otherwise, there either is no property `prop`, or it is inherited and writable.
    In both cases, define an own property `prop` that is writable, configurable, and
    enumerable. In the latter case, we have just overridden an inherited property
    (nondestructively changed it). In the former case, a missing property has been
    defined automatically. This kind of autodefining is problematic, because typos
    in assignments can be hard to detect.
  id: totrans-2504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，要么没有属性`prop`，要么它是继承的并且可写的。在这两种情况下，定义一个可写、可配置和可枚举的自有属性`prop`。在后一种情况下，我们刚刚覆盖了一个继承的属性（非破坏性地改变了它）。在前一种情况下，一个丢失的属性已经被自动定义。这种自动定义是有问题的，因为在赋值中的拼写错误可能很难检测到。
- en: Inherited Read-Only Properties Can’t Be Assigned To
  id: totrans-2505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承的只读属性不能被赋值。
- en: 'If an object, `obj`, inherits a property, `foo`, from a prototype and `foo`
    is not writable, then you can’t assign to `obj.foo`:'
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象`obj`从原型继承了属性`foo`，并且`foo`不可写，那么你不能对`obj.foo`进行赋值：
- en: '[PRE604]'
  id: totrans-2507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '`obj` inherits the read-only property `foo` from `proto`. In sloppy mode, setting
    the property has no effect:'
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj`从`proto`继承了只读属性`foo`。在松散模式下，设置属性没有效果。'
- en: '[PRE605]'
  id: totrans-2509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: 'In strict mode, you get an exception:'
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，会抛出异常：
- en: '[PRE606]'
  id: totrans-2511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: This fits with the idea that assignment changes inherited properties, but nondestructively.
    If an inherited property is read-only, you want to forbid all changes, even nondestructive
    ones.
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
  zh: 这符合继承属性会改变，但是非破坏性的想法。如果继承属性是只读的，你希望禁止所有更改，甚至是非破坏性的更改。
- en: 'Note that you can circumvent this protection by defining an own property (see
    the previous subsection for the difference between definition and assignment):'
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以通过定义一个自有属性来规避此保护（请参阅前一小节了解定义和赋值之间的区别）：
- en: '[PRE607]'
  id: totrans-2514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: 'Enumerability: Best Practices'
  id: totrans-2515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举性：最佳实践
- en: 'The general rule is that properties created by the system are nonenumerable,
    while properties created by users are enumerable:'
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是系统创建的属性是不可枚举的，而用户创建的属性是可枚举的：
- en: '[PRE608]'
  id: totrans-2517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: 'This is especially true for the methods of the built-in instance prototypes:'
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于内置实例原型的方法特别适用：
- en: '[PRE609]'
  id: totrans-2519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: The main purpose of enumerability is to tell the `for-in` loop which properties
    it should ignore. As we have seen just now when we looked at instances of built-in
    constructors, everything not created by the user is hidden from `for-in`.
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举性的主要目的是告诉`for-in`循环它应该忽略哪些属性。正如我们刚才在查看内置构造函数的实例时所看到的，用户未创建的所有内容都会被`for-in`隐藏。
- en: 'The only operations affected by enumerability are:'
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 受枚举性影响的唯一操作是：
- en: The `for-in` loop
  id: totrans-2522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for-in`循环'
- en: '`Object.keys()` ([Listing Own Property Keys](ch17_split_000.html#Object.keys
    "Listing Own Property Keys"))'
  id: totrans-2523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.keys()`（[列出自有属性键](ch17_split_000.html#Object.keys "列出自有属性键")）'
- en: '`JSON.stringify()` ([JSON.stringify(value, replacer?, space?)](ch22.html#JSON.stringify
    "JSON.stringify(value, replacer?, space?)"))'
  id: totrans-2524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON.stringify()`（[JSON.stringify(value, replacer?, space?)](ch22.html#JSON.stringify
    "JSON.stringify(value, replacer?, space?)")）'
- en: 'Here are some best practices to keep in mind:'
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要牢记的最佳实践：
- en: 'For your own code, you can usually ignore enumerability and should avoid the
    `for-in` loop ([Best Practices: Iterating over Arrays](ch18.html#array_iteration
    "Best Practices: Iterating over Arrays")).'
  id: totrans-2526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于你自己的代码，通常可以忽略枚举性，并且应该避免使用`for-in`循环（[最佳实践：遍历数组](ch18.html#array_iteration
    "最佳实践：遍历数组")）。
- en: You normally shouldn’t add properties to built-in prototypes and objects. But
    if you do, you should make them nonenumerable to avoid breaking existing code.
  id: totrans-2527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常不应向内置原型和对象添加属性。但如果您这样做，应该使它们不可枚举，以避免破坏现有代码。
- en: Protecting Objects
  id: totrans-2528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护对象
- en: 'There are three levels of protecting an object, listed here from weakest to
    strongest:'
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
  zh: 保护对象有三个级别，从弱到强依次列出：
- en: Preventing extensions
  id: totrans-2530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止扩展
- en: Sealing
  id: totrans-2531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封印
- en: Freezing
  id: totrans-2532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冻结
- en: Preventing Extensions
  id: totrans-2533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止扩展
- en: 'Preventing extensions via:'
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式防止扩展：
- en: '[PRE610]'
  id: totrans-2535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: 'makes it impossible to add properties to `obj`. For example:'
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
  zh: 使向`obj`添加属性变得不可能。例如：
- en: '[PRE611]'
  id: totrans-2537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: 'Now adding a property fails silently in sloppy mode:'
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在松散模式下，添加属性会悄悄失败：
- en: '[PRE612]'
  id: totrans-2539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: 'and throws an error in strict mode:'
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: 并在严格模式下抛出错误：
- en: '[PRE613]'
  id: totrans-2541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: 'You can still delete properties, though:'
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以删除属性：
- en: '[PRE614]'
  id: totrans-2543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: 'You check whether an object is extensible via:'
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下方式检查对象是否可扩展：
- en: '[PRE615]'
  id: totrans-2545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: Sealing
  id: totrans-2546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 封印
- en: 'Sealing via:'
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式封印：
- en: '[PRE616]'
  id: totrans-2548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: prevents extensions and makes all properties “unconfigurable.” The latter means
    that the attributes (see [Property Attributes and Property Descriptors](ch17_split_000.html#property_attributes
    "Property Attributes and Property Descriptors")) of properties can’t be changed
    anymore. For example, read-only properties stay read-only forever.
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
  zh: 防止扩展并使所有属性“不可配置”。后者意味着属性的属性（参见[属性属性和属性描述符](ch17_split_000.html#property_attributes
    "属性属性和属性描述符")）不能再改变。例如，只读属性将永远保持只读。
- en: 'The following example demonstrates that sealing makes all properties unconfigurable:'
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了封印使所有属性都不可配置：
- en: '[PRE617]'
  id: totrans-2551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: 'You can still change the property `foo`:'
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以改变属性`foo`：
- en: '[PRE618]'
  id: totrans-2553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: 'but you can’t change its attributes:'
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
  zh: 但你不能改变它的属性：
- en: '[PRE619]'
  id: totrans-2555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: 'You check whether an object is sealed via:'
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下方式检查对象是否被封闭：
- en: '[PRE620]'
  id: totrans-2557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: Freezing
  id: totrans-2558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冻结
- en: 'Freezing is performed via:'
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式进行冻结：
- en: '[PRE621]'
  id: totrans-2560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: 'It makes all properties nonwritable and seals `obj`. In other words, `obj`
    is not extensible and all properties are read-only, and there is no way to change
    that. Let’s look at an example:'
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
  zh: 它使所有属性都不可写，并封闭`obj`。换句话说，`obj`不可扩展，所有属性都是只读的，没有办法改变。让我们看一个例子：
- en: '[PRE622]'
  id: totrans-2562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: 'Once again, you get silent failures in sloppy mode:'
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
  zh: 在松散模式下再次出现悄悄失败：
- en: '[PRE623]'
  id: totrans-2564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: 'And you get errors in strict mode:'
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下会出现错误：
- en: '[PRE624]'
  id: totrans-2566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: 'You check whether an object is frozen via:'
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下方式检查对象是否被冻结：
- en: '[PRE625]'
  id: totrans-2568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: 'Pitfall: Protection Is Shallow'
  id: totrans-2569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 陷阱：保护是浅层的
- en: 'Protecting an object is *shallow*: it affects the own properties, but not the
    values of those properties. For example, consider the following object:'
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
  zh: 保护对象是*浅层*的：它影响自有属性，但不影响这些属性的值。例如，考虑以下对象：
- en: '[PRE626]'
  id: totrans-2571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: 'Even though you have frozen `obj`, it is not completely immutable—you can change
    the (mutable) value of property `bar`:'
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您已经冻结了`obj`，它并不是完全不可变的——您可以改变属性`bar`的（可变）值：
- en: '[PRE627]'
  id: totrans-2573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: Additionally, `obj` has the prototype `Object.prototype`, which is also mutable.
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`obj`具有原型`Object.prototype`，它也是可变的。
- en: 'Layer 3: Constructors—Factories for Instances'
  id: totrans-2575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三层：构造函数——实例的工厂
- en: 'A *constructor function* (short: *constructor*) helps with producing objects
    that are similar in some way. It is a normal function, but it is named, set up,
    and invoked differently. This section explains how constructors work. They correspond
    to classes in other languages.'
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
  zh: '*构造函数*（简称*构造函数*）有助于生成某种相似的对象。它是一个普通函数，但是命名、设置和调用方式都不同。本节解释了构造函数的工作原理。它们对应于其他语言中的类。'
- en: 'We have already seen an example of two objects that are similar (in [Sharing
    Data Between Objects via a Prototype](ch17_split_000.html#sharing_via_prototype
    "Sharing Data Between Objects via a Prototype")):'
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两个相似的对象的例子（在[通过原型在对象之间共享数据](ch17_split_000.html#sharing_via_prototype
    "通过原型在对象之间共享数据")中）：
- en: '[PRE628]'
  id: totrans-2578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: 'The objects `jane` and `tarzan` are both considered “persons” and share the
    prototype object `PersonProto`. Let’s turn that prototype into a constructor `Person`
    that creates objects like `jane` and `tarzan`. The objects a constructor creates
    are called its *instances*. Such instances have the same structure as `jane` and
    `tarzan`, consisting of two parts:'
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`jane`和`tarzan`都被认为是“人”，并共享原型对象`PersonProto`。让我们将该原型转换为一个构造函数`Person`，用于创建像`jane`和`tarzan`这样的对象。构造函数创建的对象称为它的*实例*。这样的实例与`jane`和`tarzan`具有相同的结构，由两部分组成：
- en: Data is instance-specific and stored in the own properties of the instance objects
    (`jane` and `tarzan` in the preceding example).
  id: totrans-2580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据是特定于实例的，并存储在实例对象的自有属性中（在前面的例子中是`jane`和`tarzan`）。
- en: Behavior is shared by all instances—they have a common prototype object with
    methods (`PersonProto` in the preceding example).
  id: totrans-2581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有实例共享行为——它们有一个共同的原型对象和方法（在前面的例子中是`PersonProto`）。
- en: 'A constructor is a function that is invoked via the `new` operator. By convention,
    the names of constructors start with uppercase letters, while the names of normal
    functions and methods start with lowercase letters. The function itself sets up
    part 1:'
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是通过`new`运算符调用的函数。按照惯例，构造函数的名称以大写字母开头，而普通函数和方法的名称以小写字母开头。函数本身设置了第一部分：
- en: '[PRE629]'
  id: totrans-2583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: 'The object in `Person.prototype` becomes the prototype of all instances of
    `Person`. It contributes part 2:'
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person.prototype`中的对象成为`Person`的所有实例的原型。它贡献了第二部分：'
- en: '[PRE630]'
  id: totrans-2585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: 'Let’s create and use an instance of `Person`:'
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建并使用`Person`的一个实例：
- en: '[PRE631]'
  id: totrans-2587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: 'We can see that `Person` is a normal function. It only becomes a constructor
    when it is invoked via `new`. The `new` operator performs the following steps:'
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Person`是一个普通函数。只有当通过`new`调用它时，它才成为构造函数。`new`运算符执行以下步骤：
- en: 'First the behavior is set up: a new object is created whose prototype is `Person.`
    `prototype`.'
  id: totrans-2589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先设置行为：创建一个新对象，其原型是`Person.prototype`。
- en: 'Then the data is set up: `Person` receives that object as the implicit parameter
    `this` and adds instance properties.'
  id: totrans-2590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后数据设置完成：`Person`接收该对象作为隐式参数`this`并添加实例属性。
- en: '[Figure 17-3](ch17_split_001.html#figoo_person_instance "Figure 17-3. jane
    is an instance of the constructor Person; its prototype is the object Person.prototype.")
    shows what the instance `jane` looks like. The property `constructor` of `Person.prototype`
    points back to the constructor and is explained in [The constructor Property of
    Instances](ch17_split_001.html#constructor_property "The constructor Property
    of Instances").'
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-3](ch17_split_001.html#figoo_person_instance "图17-3. jane是构造函数Person的一个实例；它的原型是对象Person.prototype。")展示了实例`jane`的样子。`Person.prototype`的`constructor`属性指向构造函数，并在[实例的构造函数属性](ch17_split_001.html#constructor_property
    "实例的构造函数属性")中有解释。'
- en: '![jane is an instance of the constructor Person; its prototype is the object
    Person.prototype.](images/spjs_2103.png)Figure 17-3. jane is an instance of the
    constructor Person; its prototype is the object Person.prototype.'
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
  zh: '![jane是构造函数Person的一个实例；它的原型是对象Person.prototype。](images/spjs_2103.png)图17-3. jane是构造函数Person的一个实例；它的原型是对象Person.prototype。'
- en: 'The `instanceof` operator allows us to check whether an object is an instance
    of a given constructor:'
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`运算符允许我们检查一个对象是否是给定构造函数的实例：'
- en: '[PRE632]'
  id: totrans-2594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: The new Operator Implemented in JavaScript
  id: totrans-2595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript中实现的`new`运算符
- en: 'If you were to manually implement the `new` operator, it would look roughly
    as follows:'
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手动实现`new`运算符，它看起来大致如下：
- en: '[PRE633]'
  id: totrans-2597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: In line (1), you can see that the prototype of an instance created by a constructor
    `Constr` is `Constr.prototype`.
  id: totrans-2598
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（1）行，你可以看到由构造函数`Constr`创建的实例的原型是`Constr.prototype`。
- en: 'Line (2) reveals another feature of the `new` operator: you can return an arbitrary
    object from a constructor and it becomes the result of the `new` operator. This
    is useful if you want a constructor to return an instance of a subconstructor
    (an example is given in [Returning arbitrary objects from a constructor](ch17_split_001.html#constructor_arbitrary_objects
    "Returning arbitrary objects from a constructor")).'
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
  zh: 第（2）行揭示了`new`运算符的另一个特性：你可以从构造函数中返回任意对象，并且它将成为`new`运算符的结果。如果你希望构造函数返回一个子构造函数的实例，这是很有用的（一个例子在[从构造函数返回任意对象](ch17_split_001.html#constructor_arbitrary_objects
    "从构造函数返回任意对象")中给出）。
- en: 'Terminology: The Two Prototypes'
  id: totrans-2600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 术语：两个原型
- en: 'Unfortunately, the term *prototype* is used ambiguously in JavaScript:'
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在JavaScript中术语*prototype*被使用得含糊不清：
- en: 'Prototype 1: The prototype relationship'
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
  zh: 原型1：原型关系
- en: 'An object can be the prototype of another object:'
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象可以是另一个对象的原型：
- en: '[PRE634]'
  id: totrans-2604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: In the preceding example, `proto` is the prototype of `obj`.
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`proto`是`obj`的原型。
- en: 'Prototype 2: The value of the property `prototype`'
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
  zh: 原型2：属性`prototype`的值
- en: 'Each constructor `C` has a `prototype` property that refers to an object. That
    object becomes the prototype of all instances of `C`:'
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
  zh: 每个构造函数`C`都有一个指向对象的`prototype`属性。这个对象成为`C`的所有实例的原型：
- en: '[PRE635]'
  id: totrans-2608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: 'Usually the context makes it clear which of the two prototypes is meant. Should
    disambiguation be necessary, then we are stuck with *prototype* to describe the
    relationship between objects, because that name has made it into the standard
    library via `getPrototypeOf` and `isPrototypeOf`. We thus need to find a different
    name for the object referenced by the `prototype` property. One possibility is
    *constructor prototype*, but that is problematic because constructors have prototypes,
    too:'
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
  zh: 通常上下文会清楚表明是指两个原型中的哪一个。如果需要消除歧义，那么我们就需要使用*prototype*来描述对象之间的关系，因为这个名称已经通过`getPrototypeOf`和`isPrototypeOf`进入了标准库。因此，我们需要为`prototype`属性引用的对象找到一个不同的名称。一个可能的选择是*constructor
    prototype*，但这是有问题的，因为构造函数也有原型：
- en: '[PRE636]'
  id: totrans-2610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: Thus, *instance prototype* is the best option.
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*instance prototype*是最佳选择。
- en: The constructor Property of Instances
  id: totrans-2612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例的构造函数属性
- en: 'By default, each function `C` contains an instance prototype object `C.prototype`
    whose property `constructor` points back to `C`:'
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个函数`C`都包含一个实例原型对象`C.prototype`，它的`constructor`属性指向`C`：
- en: '[PRE637]'
  id: totrans-2614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: 'Because the `constructor` property is inherited from the prototype by each
    instance, you can use it to get the constructor of an instance:'
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个实例都从原型继承了`constructor`属性，所以你可以使用它来获取实例的构造函数：
- en: '[PRE638]'
  id: totrans-2616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: Use cases for the constructor property
  id: totrans-2617
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构造函数属性的用例
- en: Switching over an object’s constructor
  id: totrans-2618
  prefs: []
  type: TYPE_NORMAL
  zh: 切换对象的构造函数
- en: 'In the following `catch` clause, we take different actions, depending on the
    constructor of the caught exception:'
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的`catch`子句中，我们根据捕获的异常的构造函数采取不同的操作：
- en: '[PRE639]'
  id: totrans-2620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: Warning
  id: totrans-2621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: This approach detects only direct instances of a given constructor. In contrast,
    `instanceof` detects both direct instances and instances of all subconstructors.
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法只能检测给定构造函数的直接实例。相比之下，`instanceof`可以检测直接实例和所有子构造函数的实例。
- en: Determining the name of an object’s constructor
  id: totrans-2623
  prefs: []
  type: TYPE_NORMAL
  zh: 确定对象的构造函数名称
- en: 'For example:'
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE640]'
  id: totrans-2625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: Warning
  id: totrans-2626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Not all JavaScript engines support the property `name` for functions.
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的JavaScript引擎都支持函数的`name`属性。
- en: Creating similar objects
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类似的对象
- en: 'This is how you create a new object, `y`, that has the same constructor as
    an existing object, `x`:'
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何创建一个新对象`y`，它具有与现有对象`x`相同的构造函数：
- en: '[PRE641]'
  id: totrans-2630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: 'This trick is handy for a method that must work for instances of subconstructors
    and wants to create a new instance that is similar to `this`. Then you can’t use
    a fixed constructor:'
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧对于一个必须适用于子构造函数的实例并且想要创建一个类似于`this`的新实例的方法非常有用。然后你就不能使用一个固定的构造函数：
- en: '[PRE642]'
  id: totrans-2632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: Referring to a superconstructor
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
  zh: 引用超级构造函数
- en: 'Some inheritance libraries assign the superprototype to a property of a subconstructor.
    For example, the YUI framework provides subclassing via [`Y.extend`](http://yuilibrary.com/yui/docs/yui/yui-extend.html):'
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
  zh: 一些继承库将超级原型分配给子构造函数的一个属性。例如，YUI框架通过[`Y.extend`](http://yuilibrary.com/yui/docs/yui/yui-extend.html)提供子类化：
- en: '[PRE643]'
  id: totrans-2635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: The call in line (1) works, because `extend` sets `Sub.superclass` to `Super.prototype`.
    Thanks to the `constructor` property, you can call the superconstructor as a method.
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（1）行的调用有效，因为`extend`将`Sub.superclass`设置为`Super.prototype`。由于`constructor`属性，你可以将超级构造函数作为方法调用。
- en: Note
  id: totrans-2637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `instanceof` operator (see [The instanceof Operator](ch17_split_001.html#operator_instanceof
    "The instanceof Operator")) does not rely on the property `constructor`.
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`运算符（参见[The instanceof Operator](ch17_split_001.html#operator_instanceof
    "The instanceof Operator")）不依赖于`constructor`属性。'
- en: Best practice
  id: totrans-2639
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Make sure that for each constructor `C`, the following assertion holds:'
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
  zh: 确保对于每个构造函数`C`，以下断言成立：
- en: '[PRE644]'
  id: totrans-2641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: 'By default, every function `f` already has a property `prototype` that is set
    up correctly:'
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个函数`f`已经有一个正确设置的属性`prototype`：
- en: '[PRE645]'
  id: totrans-2643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: 'You should thus avoid replacing this object and only add properties to it:'
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该避免替换这个对象，只向它添加属性：
- en: '[PRE646]'
  id: totrans-2645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: 'If you do replace it, you should manually assign the correct value to `constructor`:'
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你替换它，你应该手动将正确的值赋给`constructor`：
- en: '[PRE647]'
  id: totrans-2647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: Note that nothing crucial in JavaScript depends on the `constructor` property;
    but it is good style to set it up, because it enables the techniques mentioned
    in this section.
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JavaScript中没有任何关键的东西取决于`constructor`属性；但是设置它是一个好的风格，因为它可以启用本节中提到的技术。
- en: The instanceof Operator
  id: totrans-2649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: instanceof运算符
- en: 'The `instanceof` operator:'
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`运算符：'
- en: '[PRE648]'
  id: totrans-2651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: 'determines whether `value` has been created by the constructor `Constr` or
    a subconstructor. It does so by checking whether `Constr.prototype` is in the
    prototype chain of `value`. Therefore, the following two expressions are equivalent:'
  id: totrans-2652
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查`Constr.prototype`是否在`value`的原型链中，确定`value`是由构造函数`Constr`或子构造函数创建的。因此，以下两个表达式是等价的：
- en: '[PRE649]'
  id: totrans-2653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: 'Here are some examples:'
  id: totrans-2654
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些例子：
- en: '[PRE650]'
  id: totrans-2655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: 'As expected, `instanceof` is always `false` for primitive values:'
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的是，对于原始值，`instanceof`总是`false`：
- en: '[PRE651]'
  id: totrans-2657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: 'Finally, `instanceof` throws an exception if its right side isn’t a function:'
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果它的右侧不是一个函数，`instanceof`会抛出一个异常：
- en: '[PRE652]'
  id: totrans-2659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: 'Pitfall: objects that are not instances of Object'
  id: totrans-2660
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：不是`Object`的实例的对象
- en: 'Almost all objects are instances of `Object`, because `Object.prototype` is
    in their prototype chain. But there are also objects where that is not the case.
    Here are two examples:'
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的对象都是`Object`的实例，因为它们的原型链中有`Object.prototype`。但也有一些对象不是这样。以下是两个例子：
- en: '[PRE653]'
  id: totrans-2662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: 'The former object is explained in more detail in [The dict Pattern: Objects
    Without Prototypes Are Better Maps](ch17_split_001.html#dict_pattern "The dict
    Pattern: Objects Without Prototypes Are Better Maps"). The latter object is where
    most prototype chains end (and they must end somewhere). Neither object has a
    prototype:'
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
  zh: '前一个对象在[The dict Pattern: Objects Without Prototypes Are Better Maps](ch17_split_001.html#dict_pattern
    "The dict Pattern: Objects Without Prototypes Are Better Maps")中有更详细的解释。后一个对象是大多数原型链的终点（它们必须在某个地方结束）。两个对象都没有原型：'
- en: '[PRE654]'
  id: totrans-2664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: 'But `typeof` correctly classifies them as objects:'
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`typeof`正确地将它们分类为对象：
- en: '[PRE655]'
  id: totrans-2666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: This pitfall is not a deal-breaker for most use cases for `instanceof`, but
    you have to be aware of it.
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`instanceof`的大多数用例来说，这个陷阱并不是一个断点，但你必须意识到它。
- en: 'Pitfall: crossing realms (frames or windows)'
  id: totrans-2668
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱：跨越领域（框架或窗口）
- en: 'In web browsers, each frame and window has its own *realm* with separate global
    variables. That prevents `instanceof` from working for objects that cross realms.
    To see why, look at the following code:'
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web浏览器中，每个框架和窗口都有自己的*领域*，具有单独的全局变量。这可以防止`instanceof`对跨越领域的对象起作用。要了解原因，请看下面的代码：
- en: '[PRE656]'
  id: totrans-2670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: 'If `myvar` is an array from a different realm, then its prototype is the `Array.prototype`
    from that realm. Therefore, `instanceof` will not find the `Array.prototype` of
    the current realm in the prototype chain of `myvar` and will return `false`. ECMAScript 5
    has the function `Array.isArray()`, which always works:'
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`myvar`是来自不同领域的数组，那么它的原型是该领域的`Array.prototype`。因此，`instanceof`不会在`myvar`的原型链中找到当前领域的`Array.prototype`，并且会返回`false`。ECMAScript
    5有一个函数`Array.isArray()`，它总是有效的：
- en: '[PRE657]'
  id: totrans-2672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: Obviously, this is also an issue with non-built-in constructors.
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这也是非内置构造函数的问题。
- en: 'Apart from using `Array.isArray()`, there are several things you can do to
    work around this problem:'
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`Array.isArray()`，还有几件事情可以解决这个问题：
- en: Avoid objects crossing realms. Browsers have the [`postMessage()`](http://mzl.la/1fwmNrL)
    method, which can copy an object to another realm instead of passing a reference.
  id: totrans-2675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免对象跨越领域。浏览器有[`postMessage()`](http://mzl.la/1fwmNrL)方法，可以将一个对象复制到另一个领域，而不是传递一个引用。
- en: 'Check the name of the constructor of an instance (only works on engines that
    support the property `name` for functions):'
  id: totrans-2676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查实例的构造函数的名称（仅适用于支持函数`name`属性的引擎）：
- en: '[PRE658]'
  id: totrans-2677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: 'Use a prototype property to mark instances as belonging to a type `T`. There
    are several ways in which you can do so. The checks for whether `value` is an
    instance of `T` look as follows:'
  id: totrans-2678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型属性标记实例属于类型`T`。有几种方法可以这样做。检查`value`是否是`T`的实例如下：
- en: '`value.isT()`: The prototype of `T` instances must return `true` from this
    method; a common superconstructor should return the default value, `false`.'
  id: totrans-2679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value.isT()`: `T`实例的原型必须从这个方法返回`true`；一个常见的超级构造函数应该返回默认值`false`。'
- en: '`''T'' in value`: You must tag the prototype of `T` instances with a property
    whose key is `''T''` (or something more unique).'
  id: totrans-2680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''T'' in value`: 你必须用一个属性标记`T`实例的原型，其键是`''T''`（或者更独特的东西）。'
- en: '`value.TYPE_NAME === ''T''`: Every relevant prototype must have a `TYPE_NAME`
    property with an appropriate value.'
  id: totrans-2681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value.TYPE_NAME === ''T''`: 每个相关的原型必须有一个`TYPE_NAME`属性，具有适当的值。'
- en: Tips for Implementing Constructors
  id: totrans-2682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现构造函数的提示
- en: This section gives a few tips for implementing constructors.
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一些实现构造函数的提示。
- en: 'Protection against forgetting new: strict mode'
  id: totrans-2684
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 防止忘记新的：严格模式
- en: 'If you forget `new` when you use a constructor, you are calling it as a function
    instead of as a constructor. In sloppy mode, you don’t get an instance and global
    variables are created. Unfortunately, all of this happens without a warning:'
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用构造函数时忘记了`new`，你是将它作为函数而不是构造函数来调用。在松散模式下，你不会得到一个实例，全局变量会被创建。不幸的是，所有这些都是没有警告发生的：
- en: '[PRE659]'
  id: totrans-2686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: 'In strict mode, you get an exception:'
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，你会得到一个异常：
- en: '[PRE660]'
  id: totrans-2688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: Returning arbitrary objects from a constructor
  id: totrans-2689
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从构造函数返回任意对象
- en: 'In many object-oriented languages, constructors can produce only direct instances.
    For example, consider Java: let’s say you want to implement a class `Expression`
    that has the subclasses `Addition` and `Multiplication`. Parsing produces direct
    instances of the latter two classes. You can’t implement it as a constructor of
    `Expression`, because that constructor can produce only direct instances of `Expression`.
    As a workaround, static factory methods are used in Java:'
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多面向对象的语言中，构造函数只能生成直接实例。例如，考虑Java：假设您想要实现一个类`Expression`，它有子类`Addition`和`Multiplication`。解析会生成后两个类的直接实例。您不能将其实现为`Expression`的构造函数，因为该构造函数只能生成`Expression`的直接实例。作为解决方法，在Java中使用静态工厂方法：
- en: '[PRE661]'
  id: totrans-2691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: 'In JavaScript, you can simply return whatever object you need from a constructor.
    Thus, the JavaScript version of the preceding code would look like:'
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，您可以从构造函数中简单地返回您需要的任何对象。因此，前面代码的JavaScript版本看起来像：
- en: '[PRE662]'
  id: totrans-2693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: 'That is good news: JavaScript constructors don’t lock you in, so you can always
    change your mind as to whether a constructor should return a direct instance or
    something else.'
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个好消息：JavaScript构造函数不会将你锁定，因此您可以随时改变构造函数是否应返回直接实例或其他内容的想法。
- en: Data in Prototype Properties
  id: totrans-2695
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型属性中的数据
- en: This section explains that in most cases, you should not put data in prototype
    properties. There are, however, a few exceptions to that rule.
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了在大多数情况下，您不应该将数据放在原型属性中。然而，这个规则也有一些例外。
- en: Avoid Prototype Properties with Initial Values for Instance Properties
  id: totrans-2697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免具有实例属性初始值的原型属性
- en: Prototypes contain properties that are shared by several objects. Hence, they
    work well for methods. Additionally, with a technique that is described next,
    you can also use them to provide initial values for instance properties. I’ll
    later explain why that is not recommended.
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
  zh: 原型包含多个对象共享的属性。因此，它们非常适用于方法。此外，通过下面描述的一种技术，您还可以使用它们来为实例属性提供初始值。稍后我会解释为什么不建议这样做。
- en: 'A constructor usually sets instance properties to initial values. If one such
    value is a default, then you don’t need to create an instance property. You only
    need a prototype property with the same key whose value is the default. For example:'
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数通常将实例属性设置为初始值。如果其中一个值是默认值，那么您不需要创建实例属性。您只需要一个具有相同键的原型属性，其值是默认值。例如：
- en: '[PRE663]'
  id: totrans-2700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: The parameter `data` is optional. If it is missing, the instance does not get
    a property `data`, but inherits `Names.prototype.data` instead.
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`data`是可选的。如果缺少它，实例将不会获得属性`data`，而是继承`Names.prototype.data`。
- en: 'This approach mostly works: you can create an instance `n` of `Names`. Getting
    `n.data` reads `Names.prototype.data`. Setting `n.data` creates a new own property
    in `n` and preserves the shared default value in the prototype. We only have a
    problem if we *change* the default value (instead of replacing it with a new value):'
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法基本上有效：您可以创建`Names`的实例`n`。获取`n.data`会读取`Names.prototype.data`。设置`n.data`会在`n`中创建一个新的自有属性，并保留原型中的共享默认值。我们只有一个问题，如果我们*更改*默认值（而不是用新值替换它）：
- en: '[PRE664]'
  id: totrans-2703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: In the preceding example, `push()` changed the array in `Names.prototype.data`.
    Since that array is shared by all instances without an own property `data`, `n2.data`’s
    initial value has changed, too.
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`push()`改变了`Names.prototype.data`中的数组。由于该数组被所有没有自有属性`data`的实例共享，因此`n2.data`的初始值也发生了变化。
- en: 'Best practice: don’t share default values'
  id: totrans-2705
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最佳实践：不要共享默认值
- en: 'Given what we’ve just discussed, it is better to not share default values and
    to always create new ones:'
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们刚刚讨论的内容，最好不要共享默认值，并且始终创建新的默认值：
- en: '[PRE665]'
  id: totrans-2707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: 'Obviously, the problem of modifying a shared default value does not arise if
    that value is immutable (as all primitives are; see [Primitive Values](ch08.html#primitive_values
    "Primitive Values")). But for consistency’s sake, it’s best to stick to a single
    way of setting up properties. I also prefer to maintain the usual separation of
    concerns (see [Layer 3: Constructors—Factories for Instances](ch17_split_001.html#constructors
    "Layer 3: Constructors—Factories for Instances")): the constructor sets up the
    instance properties, and the prototype contains the methods.'
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
  zh: '显然，如果该值是不可变的（就像所有原始值一样；请参阅[Primitive Values](ch08.html#primitive_values "Primitive
    Values")），那么修改共享默认值的问题就不会出现。但为了保持一致性，最好坚持一种设置属性的方式。我也更喜欢保持通常的关注点分离（参见[Layer 3:
    Constructors—Factories for Instances](ch17_split_001.html#constructors "Layer
    3: Constructors—Factories for Instances")）：构造函数设置实例属性，原型包含方法。'
- en: ECMAScript 6 will make this even more of a best practice, because constructor
    parameters can have default values and you can define prototype methods via classes,
    but not prototype properties with data.
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6将使这更加成为最佳实践，因为构造函数参数可以具有默认值，并且您可以通过类定义原型方法，但不能定义具有数据的原型属性。
- en: Creating instance properties on demand
  id: totrans-2710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按需创建实例属性
- en: 'Occasionally, creating a property value is an expensive operation (computationally
    or storage-wise). In that case, you can create an instance property on demand:'
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，创建属性值是一个昂贵的操作（在计算或存储方面）。在这种情况下，您可以按需创建实例属性：
- en: '[PRE666]'
  id: totrans-2712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: 'We can’t add the property `data` to the instance via assignment, because JavaScript
    would complain about a missing setter (which it does when it only finds a getter).
    Therefore, we add it via `Object.defineProperty()`. Consult [Properties: Definition
    Versus Assignment](ch17_split_000.html#definition_vs_assignment "Properties: Definition
    Versus Assignment") to review the differences between defining and assigning.
    In line (1), we are ensuring that the property `constructor` is set up properly
    (see [The constructor Property of Instances](ch17_split_001.html#constructor_property
    "The constructor Property of Instances")).'
  id: totrans-2713
  prefs: []
  type: TYPE_NORMAL
  zh: '我们无法通过赋值向实例添加属性`data`，因为JavaScript会抱怨缺少setter（当它只找到getter时会这样做）。因此，我们通过`Object.defineProperty()`来添加它。请参阅[Properties:
    Definition Versus Assignment](ch17_split_000.html#definition_vs_assignment "Properties:
    Definition Versus Assignment")来查看定义和赋值之间的区别。在第（1）行，我们确保属性`constructor`被正确设置（参见[The
    constructor Property of Instances](ch17_split_001.html#constructor_property "The
    constructor Property of Instances")）。'
- en: Obviously, that is quite a bit of work, so you have to be sure it is worth it.
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是相当多的工作，所以你必须确保它是值得的。
- en: Avoid Nonpolymorphic Prototype Properties
  id: totrans-2715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免非多态原型属性
- en: If the same property (same key, same semantics, generally different values),
    exists in several prototypes, it is called *polymorphic*. Then the result of reading
    the property via an instance is dynamically determined via that instance’s prototype.
    Prototype properties that are not used polymorphically can be replaced by variables
    (which better reflects their nonpolymorphic nature).
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相同的属性（相同的键，相同的语义，通常不同的值）存在于几个原型中，则称为*多态*。然后，通过实例读取属性的结果是通过该实例的原型动态确定的。未多态使用的原型属性可以被变量替换（这更好地反映了它们的非多态性质）。
- en: 'For example, you can store a constant in a prototype property and access it
    via `this`:'
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将常量存储在原型属性中，并通过`this`访问它：
- en: '[PRE667]'
  id: totrans-2718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: 'This constant is not polymorphic. Therefore, you can just as well access it
    via a variable:'
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
  zh: 这个常量不是多态的。因此，你可以通过变量访问它：
- en: '[PRE668]'
  id: totrans-2720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: Polymorphic Prototype Properties
  id: totrans-2721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多态原型属性
- en: 'Here is an example of polymorphic prototype properties with immutable data.
    Tagging instances of a constructor via prototype properties enables you to tell
    them apart from instances of a different constructor:'
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有不可变数据的多态原型属性的示例。通过原型属性标记构造函数的实例，可以将它们与不同构造函数的实例区分开来：
- en: '[PRE669]'
  id: totrans-2723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: 'Thanks to the polymorphic “tag” `TYPE_NAME`, you can distinguish the instances
    of `ConstrA` and `ConstrB` even when they cross realms (then `instanceof` does
    not work; see [Pitfall: crossing realms (frames or windows)](ch17_split_001.html#cross-realm_instanceof
    "Pitfall: crossing realms (frames or windows)")).'
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多态的“标签”`TYPE_NAME`，即使它们跨越领域（然后`instanceof`不起作用；参见[陷阱：跨领域（帧或窗口）](ch17_split_001.html#cross-realm_instanceof
    "陷阱：跨领域（帧或窗口）")），你也可以区分`ConstrA`和`ConstrB`的实例。
- en: Keeping Data Private
  id: totrans-2725
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持数据私有
- en: 'JavaScript does not have dedicated means for managing private data for an object.
    This section will describe three techniques for working around that limitation:'
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有专门的手段来管理对象的私有数据。本节将描述三种解决这个限制的技术：
- en: Private data in the environment of a constructor
  id: totrans-2727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数环境中的私有数据
- en: Private data in properties with marked keys
  id: totrans-2728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标记键在属性中存储私有数据
- en: Private data in properties with reified keys
  id: totrans-2729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用具体键在属性中存储私有数据
- en: Additionally, I will explain how to keep global data private via IIFEs.
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我将解释如何通过IIFE保持全局数据私有。
- en: Private Data in the Environment of a Constructor (Crockford Privacy Pattern)
  id: totrans-2731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数环境中的私有数据（Crockford隐私模式）
- en: 'When a constructor is invoked, two things are created: the constructor’s instance
    and an environment (see [Environments: Managing Variables](ch16.html#environments
    "Environments: Managing Variables")). The instance is to be initialized by the
    constructor. The environment holds the constructor’s parameters and local variables.
    Every function (which includes methods) created inside the constructor will retain
    a reference to the environment—the environment in which it was created. Thanks
    to that reference, it will always have access to the environment, even after the
    constructor is finished. This combination of function and environment is called
    a *closure* ([Closures: Functions Stay Connected to Their Birth Scopes](ch16.html#closures
    "Closures: Functions Stay Connected to Their Birth Scopes")). The constructor’s
    environment is thus data storage that is independent of the instance and related
    to it only because the two are created at the same time. To properly connect them,
    we must have functions that live in both worlds. Using [Douglas Crockford’s terminology](http://www.crockford.com/javascript/private.html),
    an instance can have three kinds of values associated with it (see [Figure 17-4](ch17_split_001.html#figprivate_data
    "Figure 17-4. When a constructor Constr is invoked, two data structures are created:
    an environment for parameters and local variables and an instance to be initialized.")):'
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用构造函数时，会创建两个东西：构造函数的实例和一个环境（参见[环境：管理变量](ch16.html#environments "环境：管理变量")）。实例由构造函数初始化。环境保存构造函数的参数和局部变量。在构造函数内部创建的每个函数（包括方法）都将保留对环境的引用——它被创建的环境。由于这个引用，即使构造函数完成后，它仍然可以访问环境。这种函数和环境的组合被称为*闭包*（[闭包：函数保持与它们的诞生作用域连接](ch16.html#closures
    "闭包：函数保持与它们的诞生作用域连接")）。构造函数的环境因此是独立于实例的数据存储，与实例只有因为它们同时创建而相关。为了正确连接它们，我们必须有生活在两个世界中的函数。使用[Douglas
    Crockford的术语](http://www.crockford.com/javascript/private.html)，一个实例可以有三种与之关联的值（参见[图17-4](ch17_split_001.html#figprivate_data
    "图17-4. 当构造函数Constr被调用时，会创建两个数据结构：用于参数和局部变量的环境和要初始化的实例。")）：
- en: Public properties
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
  zh: 公共属性
- en: Values stored in properties (either in the instance or in its prototype) are
    publicly accessible.
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在属性中的值（无论是在实例中还是在其原型中）都是公开可访问的。
- en: Private values
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
  zh: 私有值
- en: Data and functions stored in the environment are *private*—only accessible to
    the constructor and to the functions it created.
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在环境中的数据和函数是*私有的*——只能由构造函数和它创建的函数访问。
- en: Privileged methods
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
  zh: 特权方法
- en: Private functions can access public properties, but public methods in the prototype
    can’t access private data. We thus need *privileged* methods—public methods in
    the instance. Privileged methods are public and can be called by everyone, but
    they also have access to private values, because they were created in the constructor.
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
  zh: 私有函数可以访问公共属性，但原型中的公共方法无法访问私有数据。因此，我们需要*特权*方法——实例中的公共方法。特权方法是公共的，可以被所有人调用，但它们也可以访问私有值，因为它们是在构造函数中创建的。
- en: '![When a constructor Constr is invoked, two data structures are created: an
    environment for parameters and local variables and an instance to be initialized.](images/spjs_2104.png)Figure 17-4. When
    a constructor Constr is invoked, two data structures are created: an environment
    for parameters and local variables and an instance to be initialized.'
  id: totrans-2739
  prefs: []
  type: TYPE_NORMAL
  zh: '![当构造函数Constr被调用时，会创建两个数据结构：参数和局部变量的环境以及要初始化的实例。](images/spjs_2104.png)图17-4.
    当构造函数Constr被调用时，会创建两个数据结构：参数和局部变量的环境以及要初始化的实例。'
- en: The following sections explain each kind of value in more detail.
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节详细解释了每种值。
- en: Public properties
  id: totrans-2741
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 公共属性
- en: 'Remember that given a constructor `Constr`, there are two kinds of properties
    that are *public*, accessible to everyone. First, *prototype properties* are stored
    in `Constr.prototype` and shared by all instances. Prototype properties are usually
    methods:'
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于构造函数`Constr`，有两种*公共*属性可供所有人访问。首先，*原型属性*存储在`Constr.prototype`中，并由所有实例共享。原型属性通常是方法：
- en: '[PRE670]'
  id: totrans-2743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: 'Second, *instance properties* are unique to each instance. They are added in
    the constructor and usually hold data (not methods):'
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，*实例属性*对每个实例都是唯一的。它们在构造函数中添加，通常保存数据（而不是方法）：
- en: '[PRE671]'
  id: totrans-2745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: Private values
  id: totrans-2746
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 私有值
- en: 'The constructor’s environment consists of the parameters and local variables.
    They are accessible only from inside the constructor and thus private to the instance:'
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的环境包括参数和局部变量。它们只能从构造函数内部访问，因此对实例是私有的：
- en: '[PRE672]'
  id: totrans-2748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: Privileged methods
  id: totrans-2749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 特权方法
- en: 'Private data is so safe from outside access that prototype methods can’t access
    it. But then how else would you use it after leaving the constructor? The answer
    is *privileged methods*: functions created in the constructor are added as instance
    methods. That means that, on one hand, they can access private data; on the other
    hand, they are public and therefore seen by prototype methods. In other words,
    they serve as mediators between private data and the public (including prototype
    methods):'
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
  zh: 私有数据是如此安全，以至于原型方法无法访问它。但是离开构造函数后你还能怎么使用它呢？答案是*特权方法*：在构造函数中创建的函数被添加为实例方法。这意味着，一方面，它们可以访问私有数据；另一方面，它们是公共的，因此被原型方法看到。换句话说，它们在私有数据和公共数据（包括原型方法）之间充当中介：
- en: '[PRE673]'
  id: totrans-2751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: An example
  id: totrans-2752
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个例子
- en: 'The following is an implementation of a `StringBuilder`, using the Crockford
    privacy pattern:'
  id: totrans-2753
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Crockford隐私模式实现的`StringBuilder`：
- en: '[PRE674]'
  id: totrans-2754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: 'Here is the interaction:'
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE675]'
  id: totrans-2756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: The pros and cons of the Crockford privacy pattern
  id: totrans-2757
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Crockford隐私模式的利弊
- en: 'Here are some points to consider when you are using the Crockford privacy pattern:'
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Crockford隐私模式时需要考虑的一些要点：
- en: It’s not very elegant
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是很优雅
- en: Mediating access to private data via privileged methods introduces an unnecessary
    indirection. Privileged methods and private functions both destroy the separation
    of concerns between the constructor (setting up instance data) and the instance
    prototype (methods).
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
  zh: 通过特权方法介入私有数据的访问引入了不必要的间接性。特权方法和私有函数都破坏了构造函数（设置实例数据）和实例原型（方法）之间的关注点分离。
- en: It’s completely secure
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: 它是完全安全的
- en: There is no way to access the environment’s data from outside, which makes this
    solution secure if you need that (e.g., for security-critical code). On the other
    hand, private data not being accessible to the outside can also be an inconvenience.
    Sometimes you want to unit-test private functionality. And some temporary quick
    fixes depend on the ability to access private data. This kind of quick fix cannot
    be predicted, so no matter how good your design is, the need can arise.
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
  zh: 无法从外部访问环境的数据，这使得这种解决方案在需要时非常安全（例如，对于安全关键代码）。另一方面，私有数据不可被外部访问也可能会带来不便。有时你想对私有功能进行单元测试。而一些临时的快速修复依赖于访问私有数据的能力。这种快速修复是无法预测的，所以无论你的设计有多好，都可能会出现这种需求。
- en: It may be slower
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会更慢
- en: Accessing properties in the prototype chain is highly optimized in current JavaScript
    engines. Accessing values in the closure may be slower. But these things change
    constantly, so you’ll have to measure should this really matter for your code.
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前JavaScript引擎中，访问原型链中的属性是高度优化的。访问闭包中的值可能会更慢。但这些事情不断变化，所以你必须测量一下，看看这对你的代码是否真的很重要。
- en: It consumes more memory
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: 它会消耗更多的内存
- en: Keeping the environment around and putting privileged methods in instances costs
    memory. Again, be sure it really matters for your code and measure.
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
  zh: 保留环境并将特权方法放在实例中会消耗内存。再次，确保这对你的代码真的很重要，并进行测量。
- en: Private Data in Properties with Marked Keys
  id: totrans-2767
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有标记键的属性中的私有数据
- en: 'For most non-security-critical applications, privacy is more like a hint to
    clients of an API: “You don’t need to see this.” That’s the key benefit of encapsulation—hiding
    complexity. Even though more is going on under the hood, you only need to understand
    the public part of an API. The idea of a naming convention is to let clients know
    about privacy by marking the key of a property. A prefixed underscore is often
    used for this purpose.'
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数非安全关键的应用程序来说，隐私更像是API的一个提示：“你不需要看到这个。”这就是封装的关键好处——隐藏复杂性。尽管底层可能有更多的东西，但你只需要理解API的公共部分。命名约定的想法是通过标记属性的键来让客户端了解隐私。通常会使用前缀下划线来实现这一目的。
- en: 'Let’s rewrite the previous `StringBuilder` example so that the buffer is kept
    in a property `_buffer`, which is private, but by convention only:'
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写先前的`StringBuilder`示例，以便缓冲区保存在名为`_buffer`的私有属性中，但按照惯例而言：
- en: '[PRE676]'
  id: totrans-2770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: 'Here are some pros and cons of privacy via marked property keys:'
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过标记属性键实现隐私的一些利弊：
- en: It offers a more natural coding style
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了更自然的编码风格
- en: Being able to access private and public data in the same manner is more elegant
    than using environments for privacy.
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
  zh: 能够以相同的方式访问私有和公共数据比使用环境实现隐私更加优雅。
- en: It pollutes the namespace of properties
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
  zh: 它污染了属性的命名空间
- en: Properties with marked keys can be seen everywhere. The more people use IDEs,
    the more it will be a nuisance that they are shown alongside public properties,
    in places where they should be hidden. IDEs could, in theory, adapt by recognizing
    naming conventions and by hiding private properties where possible.
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
  zh: 具有标记键的属性可以在任何地方看到。人们使用IDE的越多，它们就会越烦人，因为它们会显示在公共属性旁边，而应该隐藏在那里。理论上，IDE可以通过识别命名约定并在可能的情况下隐藏私有属性来进行适应。
- en: Private properties can be accessed from “outside”
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从“外部”访问私有属性
- en: That can be useful for unit tests and quick fixes. Additionally, subconstructors
    and helper functions (so-called “friend functions”) can profit from easier access
    to private data. The environment approach doesn’t offer this kind of flexibility;
    private data can be accessed only from within the constructor.
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
  zh: 这对单元测试和快速修复很有用。此外，子构造函数和辅助函数（所谓的“友元函数”）可以更轻松地访问私有数据。环境方法不提供这种灵活性；私有数据只能从构造函数内部访问。
- en: It can lead to key clashes
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能导致关键冲突
- en: Keys of private properties can clash. This is already an issue for subconstructors,
    but it is even more problematic if you work with multiple inheritance (as enabled
    by some libraries). With the environment approach, there are never any clashes.
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
  zh: 私有属性的键可能会发生冲突。这已经是子构造函数的一个问题，但如果您使用多重继承（某些库允许的），这将更加棘手。通过环境方法，就不会发生任何冲突。
- en: Private Data in Properties with Reified Keys
  id: totrans-2780
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用具体化键在属性中保持私有数据
- en: 'One problem with a naming convention for private properties is that keys might
    clash (e.g., a key from a constructor with a key from a subconstructor, or a key
    from a mixin with a key from a constructor). You can make such clashes less likely
    by using longer keys, that, for example, include the name of the constructor.
    Then, in the previous case, the private property `_buffer` would be called `_StringBuilder_buffer`.
    If such a key is too long for your taste, you have the option of *reifying it*,
    of storing it in a variable:'
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
  zh: 私有属性的一个问题是，键可能会发生冲突（例如，来自构造函数的键与来自子构造函数的键，或来自混入的键与来自构造函数的键）。通过使用更长的键，例如包含构造函数名称的键，可以减少这种冲突的可能性。然后，在前面的情况下，私有属性`_buffer`将被称为`_StringBuilder_buffer`。如果这样的键对您来说太长，您可以选择*具体化它*，将其存储在变量中：
- en: '[PRE677]'
  id: totrans-2782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: 'We now access the private data via `this[KEY_BUFFER]`:'
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过`this[KEY_BUFFER]`访问私有数据。
- en: '[PRE678]'
  id: totrans-2784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: We have wrapped an IIFE around `StringBuilder` so that the constant `KEY_BUFFER`
    stays local and doesn’t pollute the global namespace.
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将IIFE包装在`StringBuilder`周围，以便常量`KEY_BUFFER`保持本地化，不会污染全局命名空间。
- en: 'Reified property keys enable you to use UUIDs (universally unique identifiers)
    in keys. For example, via Robert Kieffer’s [node-uuid](https://github.com/broofa/node-uuid):'
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
  zh: 具体化的属性键使您能够在键中使用UUID（通用唯一标识符）。例如，通过Robert Kieffer的[node-uuid](https://github.com/broofa/node-uuid)：
- en: '[PRE679]'
  id: totrans-2787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '`KEY_BUFFER` has a different value each time the code runs. It may, for example,
    look like this:'
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
  zh: 每次代码运行时，`KEY_BUFFER`的值都不同。例如，可能如下所示：
- en: '[PRE680]'
  id: totrans-2789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: Long keys with UUIDs make key clashes virtually impossible.
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
  zh: 具有UUID的长键使关键冲突几乎不可能发生。
- en: Keeping Global Data Private via IIFEs
  id: totrans-2791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过IIFE将全局数据保持私有
- en: 'This subsection explains how to keep global data private to singleton objects,
    constructors, and methods, via IIFEs (see [Introducing a New Scope via an IIFE](ch16.html#iife
    "Introducing a New Scope via an IIFE")). Those IIFEs create new environments (refer
    back to [Environments: Managing Variables](ch16.html#environments "Environments:
    Managing Variables")), which is where you put the private data.'
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节解释了如何通过IIFE（请参阅[通过IIFE引入新作用域](ch16.html#iife "通过IIFE引入新作用域")）将全局数据保持私有，以供单例对象、构造函数和方法使用。这些IIFE创建新环境（请参阅[环境：管理变量](ch16.html#environments
    "环境：管理变量")），您可以在其中放置私有数据。
- en: Attaching private global data to a singleton object
  id: totrans-2793
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将私有全局数据附加到单例对象
- en: 'You don’t need a constructor to associate an object with private data in an
    environment. The following example shows how to use an IIFE for the same purpose,
    by wrapping it around a singleton object:'
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要构造函数来将对象与环境中的私有数据关联起来。以下示例显示了如何使用IIFE来实现相同的目的，方法是将其包装在单例对象周围：
- en: '[PRE681]'
  id: totrans-2795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: Keeping global data private to all of a constructor
  id: totrans-2796
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将全局数据保持私有以供所有构造函数使用
- en: 'Some global data is relevant only for a constructor and the prototype methods.
    By wrapping an IIFE around both, you can hide it from public view. [Private Data
    in Properties with Reified Keys](ch17_split_001.html#private_data_reified_keys
    "Private Data in Properties with Reified Keys") gave an example: the constructor
    `StringBuilder` and its prototype methods use the constant `KEY_BUFFER`, which
    contains a property key. That constant is stored in the environment of an IIFE:'
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
  zh: 某些全局数据仅适用于构造函数和原型方法。通过同时将IIFE包装在两者周围，可以将其隐藏起来，不让公众看到。[使用具体化键在属性中保持私有数据](ch17_split_001.html#private_data_reified_keys
    "使用具体化键在属性中保持私有数据")举例说明：构造函数`StringBuilder`及其原型方法使用常量`KEY_BUFFER`，其中包含属性键。该常量存储在IIFE的环境中：
- en: '[PRE682]'
  id: totrans-2798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: Note that if you are using a module system (see [Chapter 31](ch31.html "Chapter 31. Module
    Systems and Package Managers")), you can achieve the same effect with cleaner
    code by putting the constructor plus methods in a module.
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您使用模块系统（请参阅[第31章](ch31.html "第31章。模块系统和包管理器")），您可以通过将构造函数加上方法放入模块中，以更干净的代码实现相同的效果。
- en: Attaching global data to a method
  id: totrans-2800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将全局数据附加到方法
- en: 'Sometimes you only need global data for a single method. You can keep it private
    by putting it in the environment of an IIFE that you wrap around the method. For
    example:'
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您只需要单个方法的全局数据。通过将其放在您包装在方法周围的IIFE的环境中，可以使其保持私有。例如：
- en: '[PRE683]'
  id: totrans-2802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: 'Here is the interaction:'
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE684]'
  id: totrans-2804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: 'Layer 4: Inheritance Between Constructors'
  id: totrans-2805
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4层：构造函数之间的继承
- en: 'In this section, we examine how constructors can be inherited from: given a
    constructor `Super`, how can we write a new constructor, `Sub`, that has all the
    features of `Super` plus some features of its own? Unfortunately, JavaScript does
    not have a built-in mechanism for performing this task. Hence, we’ll have to do
    some manual work.'
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究如何从构造函数中继承：给定一个构造函数`Super`，我们如何编写一个新的构造函数`Sub`，它具有`Super`的所有特性以及一些自己的特性？不幸的是，JavaScript没有内置的机制来执行这个任务。因此，我们需要做一些手动工作。
- en: '[Figure 17-5](ch17_split_001.html#figoo_subclassing_idea "Figure 17-5. Sub
    should inherit from Super: it should have all of Super’s prototype properties
    and all of Super’s instance properties in addition to its own. Note that methodB
    overrides Super’s methodB.") illustrates the idea: the subconstructor `Sub` should
    have all of the properties of `Super` (both prototype properties and instance
    properties) in addition to its own. Thus, we have a rough idea of what `Sub` should
    look like, but don’t know how to get there. There are several things we need to
    figure out, which I’ll explain next:'
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-5](ch17_split_001.html#figoo_subclassing_idea "图17-5. Sub应该从Super继承：它应该具有Super的所有原型属性和所有Super的实例属性，另外还有自己的。请注意，methodB覆盖了Super的methodB。")说明了这个想法：子构造函数`Sub`应该具有`Super`的所有属性（原型属性和实例属性），另外还有自己的。因此，我们对`Sub`应该是什么样子有了一个大致的想法，但不知道如何实现。我们需要弄清楚几件事情，接下来我会解释：'
- en: Inheriting instance properties.
  id: totrans-2808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承实例属性。
- en: Inheriting prototype properties.
  id: totrans-2809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承原型属性。
- en: 'Ensuring that `instanceof` works: if `sub` is an instance of `Sub`, we also
    want `sub instanceof Super` to be true.'
  id: totrans-2810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保`instanceof`的工作：如果`sub`是`Sub`的一个实例，我们也希望`sub instanceof Super`为真。
- en: Overriding a method to adapt one of `Super`’s methods in `Sub`.
  id: totrans-2811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖方法以适应`Sub`中的`Super`方法之一。
- en: 'Making supercalls: if we have overridden one of `Super`’s methods, we may need
    to call the original method from `Sub`.'
  id: totrans-2812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行超级调用：如果我们覆盖了`Super`的一个方法，我们可能需要从`Sub`中调用原始方法。
- en: '![Sub should inherit from Super: it should have all of Super’s prototype properties
    and all of Super’s instance properties in addition to its own. Note that methodB
    overrides Super’s methodB.](images/spjs_2105.png)Figure 17-5. Sub should inherit
    from Super: it should have all of Super’s prototype properties and all of Super’s
    instance properties in addition to its own. Note that methodB overrides Super’s
    methodB.'
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
  zh: '![Sub应该从Super继承：它应该具有Super的所有原型属性和所有Super的实例属性，另外还有自己的。请注意，methodB覆盖了Super的methodB。](images/spjs_2105.png)图17-5.
    Sub应该从Super继承：它应该具有Super的所有原型属性和所有Super的实例属性，另外还有自己的。请注意，methodB覆盖了Super的methodB。'
- en: Inheriting Instance Properties
  id: totrans-2814
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承实例属性
- en: 'Instance properties are set up in the constructor itself, so inheriting the
    superconstructor’s instance properties involves calling that constructor:'
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
  zh: 实例属性是在构造函数本身中设置的，因此继承超级构造函数的实例属性涉及调用该构造函数：
- en: '[PRE685]'
  id: totrans-2816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: When `Sub` is invoked via `new`, its implicit parameter `this` refers to a fresh
    instance. It first passes that instance on to `Super` (1), which adds its instance
    properties. Afterward, `Sub` sets up its own instance properties (2,3). The trick
    is not to invoke `Super` via `new`, because that would create a fresh superinstance.
    Instead, we call `Super` as a function and hand in the current (sub)instance as
    the value of `this`.
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过`new`调用`Sub`时，它的隐式参数`this`指向一个新实例。它首先将该实例传递给`Super`（1），后者添加其实例属性。之后，`Sub`设置自己的实例属性（2,3）。关键是不要通过`new`调用`Super`，因为那样会创建一个新的超级实例。相反，我们将`Super`作为一个函数调用，并将当前（子）实例作为`this`的值传递进去。
- en: Inheriting Prototype Properties
  id: totrans-2818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承原型属性
- en: Shared properties such as methods are kept in the instance prototype. Thus,
    we need to find a way for `Sub.prototype` to inherit all of `Super.prototype`’s
    properties. The solution is to give `Sub.prototype` the prototype `Super.prototype`.
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如方法之类的共享属性保存在实例原型中。因此，我们需要找到一种方法，让`Sub.prototype`继承`Super.prototype`的所有属性。解决方案是将`Sub.prototype`设置为`Super.prototype`的原型。
- en: Confused by the two kinds of prototypes?
  id: totrans-2820
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对两种原型感到困惑吗？
- en: 'Yes, JavaScript terminology is confusing here. If you feel lost, consult [Terminology:
    The Two Prototypes](ch17_split_001.html#two_prototypes "Terminology: The Two Prototypes"),
    which explains how they differ.'
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，JavaScript术语在这里很令人困惑。如果你感到迷茫，请参阅[术语：两个原型](ch17_split_001.html#two_prototypes
    "术语：两个原型")，其中解释了它们的区别。
- en: 'This is the code that achieves that:'
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现这一点的代码：
- en: '[PRE686]'
  id: totrans-2823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '`Object.create()` produces a fresh object whose prototype is `Super.prototype`.
    Afterward, we add `Sub`’s methods. As explained in [The constructor Property of
    Instances](ch17_split_001.html#constructor_property "The constructor Property
    of Instances"), we also need to set up the property `constructor`, because we
    have replaced the original instance prototype where it had the correct value.'
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.create()`生成一个原型为`Super.prototype`的新对象。之后，我们添加`Sub`的方法。正如在[实例的构造函数属性](ch17_split_001.html#constructor_property
    "实例的构造函数属性")中解释的那样，我们还需要设置`constructor`属性，因为我们已经替换了原始实例原型，其中它具有正确的值。'
- en: '[Figure 17-6](ch17_split_001.html#figoo_sub_constructor "Figure 17-6. The constructor
    Sub inherits the constructor Super by calling it and by making Sub.prototype a
    prototypee of Super.prototype.") shows how `Sub` and `Super` are related now.
    `Sub`’s structure does resemble what I have sketched in [Figure 17-5](ch17_split_001.html#figoo_subclassing_idea
    "Figure 17-5. Sub should inherit from Super: it should have all of Super’s prototype
    properties and all of Super’s instance properties in addition to its own. Note
    that methodB overrides Super’s methodB."). The diagram does not show the instance
    properties, which are set up by the function call mentioned in the diagram.'
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-6](ch17_split_001.html#figoo_sub_constructor "图17-6. 构造函数Sub通过调用它并使Sub.prototype成为Super.prototype的原型来继承构造函数Super。")显示了现在`Sub`和`Super`的关系。`Sub`的结构确实类似于我在[图17-5](ch17_split_001.html#figoo_subclassing_idea
    "图17-5. Sub应该从Super继承：它应该具有Super的所有原型属性和所有Super的实例属性，另外还有自己的。请注意，methodB覆盖了Super的methodB。")中所勾画的。该图未显示实例属性，这些属性是由图中提到的函数调用设置的。'
- en: '![The constructor Sub inherits the constructor Super by calling it and by making
    Sub.prototype a prototypee of Super.prototype.](images/spjs_2106.png)Figure 17-6. The
    constructor Sub inherits the constructor Super by calling it and by making Sub.prototype
    a prototypee of Super.prototype.'
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
  zh: '![构造函数Sub通过调用构造函数Super并使Sub.prototype成为Super.prototype的原型而继承了构造函数Super。](images/spjs_2106.png)图17-6.
    构造函数Sub通过调用构造函数Super并使Sub.prototype成为Super.prototype的原型而继承了构造函数Super。'
- en: Ensuring That instanceof Works
  id: totrans-2827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保`instanceof`的工作
- en: '“Ensuring that `instanceof` works” means that every instance of `Sub` must
    also be an instance of `Super`. [Figure 17-7](ch17_split_001.html#figoo_sub_instance
    "Figure 17-7. subInstance has been created by the constructor Sub. It has the
    two prototypes Sub.prototype and Super.prototype.") shows what the prototype chain
    of `subInstance`, an instance of `Sub`, looks like: its first prototype is `Sub.prototype`,
    and its second prototype is `Super.prototype`.'
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
  zh: “确保`instanceof`的工作”意味着`Sub`的每个实例也必须是`Super`的实例。[图17-7](ch17_split_001.html#figoo_sub_instance
    "图17-7. subInstance是由构造函数Sub创建的。它具有两个原型Sub.prototype和Super.prototype。")显示了`Sub`的实例`subInstance`的原型链的样子：它的第一个原型是`Sub.prototype`，第二个原型是`Super.prototype`。
- en: '![subInstance has been created by the constructor Sub. It has the two prototypes
    Sub.prototype and Super.prototype.](images/spjs_2107.png)Figure 17-7. subInstance
    has been created by the constructor Sub. It has the two prototypes Sub.prototype
    and Super.prototype.'
  id: totrans-2829
  prefs: []
  type: TYPE_NORMAL
  zh: '![subInstance是由构造函数Sub创建的。它具有两个原型Sub.prototype和Super.prototype。](images/spjs_2107.png)图17-7.
    subInstance是由构造函数Sub创建的。它具有两个原型Sub.prototype和Super.prototype。'
- en: 'Let’s start with an easier question: is `subInstance` an instance of `Sub`?
    Yes, it is, because the following two assertions are equivalent (the latter can
    be considered the definition of the former):'
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个更简单的问题开始：`subInstance`是`Sub`的一个实例吗？是的，因为以下两个断言是等价的（后者可以被视为前者的定义）：
- en: '[PRE687]'
  id: totrans-2831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: 'As mentioned before, `Sub.prototype` is one of the prototypes of `subInstance`,
    so both assertions are true. Similarly, `subInstance` is also an instance of `Super`,
    because the following two assertions hold:'
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Sub.prototype`是`subInstance`的原型之一，因此两个断言都为真。同样，`subInstance`也是`Super`的一个实例，因为以下两个断言成立：
- en: '[PRE688]'
  id: totrans-2833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: Overriding a Method
  id: totrans-2834
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重写一个方法
- en: 'We override a method in `Super.prototype` by adding a method with the same
    name to `Sub.prototype`. `methodB` is an example and in [Figure 17-7](ch17_split_001.html#figoo_sub_instance
    "Figure 17-7. subInstance has been created by the constructor Sub. It has the
    two prototypes Sub.prototype and Super.prototype."), we can see why it works:
    the search for `methodB` begins in `subInstance` and finds `Sub.prototype.methodB`
    before `Super.prototype.methodB`.'
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`Sub.prototype`中添加与相同名称的方法来重写`Super.prototype`中的方法。`methodB`就是一个例子，在[图17-7](ch17_split_001.html#figoo_sub_instance
    "图17-7. subInstance是由构造函数Sub创建的。它具有两个原型Sub.prototype和Super.prototype。")中，我们可以看到它为什么有效：对`methodB`的搜索始于`subInstance`，在找到`Super.prototype.methodB`之前找到了`Sub.prototype.methodB`。
- en: Making a Supercall
  id: totrans-2836
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行超级调用
- en: 'To understand supercalls, you need to know the term *home object*. The home
    object of a method is the object that owns the property whose value is the method.
    For example, the home object of `Sub.prototype.methodB` is `Sub.prototype`. Supercalling
    a method `foo` involves three steps:'
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解超级调用，您需要了解术语*主对象*。方法的主对象是拥有其值为方法的属性的对象。例如，`Sub.prototype.methodB`的主对象是`Sub.prototype`。超级调用方法`foo`涉及三个步骤：
- en: Start your search “after” (in the prototype of) the home object of the current
    method.
  id: totrans-2838
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从当前方法的主对象的原型“之后”（在原型中）开始搜索。
- en: Look for a method whose name is `foo`.
  id: totrans-2839
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找一个名为`foo`的方法。
- en: Invoke that method with the current `this`. The rationale is that the supermethod
    must work with the same instance as the current method; it must be able to access
    the same instance properties.
  id: totrans-2840
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用当前的`this`调用该方法。其理由是超级方法必须与当前方法使用相同的实例；它必须能够访问相同的实例属性。
- en: 'Therefore, the code of the submethod looks as follows. It supercalls itself,
    it calls the method it has overridden:'
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，子方法的代码如下所示。它超级调用自己，调用它已经重写的方法：
- en: '[PRE689]'
  id: totrans-2842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: 'One way of reading the supercall at (1) is as follows: refer to the supermethod
    directly and call it with the current `this`. However, if we split it into three
    parts, we find the aforementioned steps:'
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读（1）处的超级调用的一种方式是：直接引用超级方法并使用当前的`this`调用它。但是，如果我们将其分为三个部分，我们会发现上述步骤：
- en: '`Super.prototype`: Start your search in `Super.prototype`, the prototype of
    `Sub.prototype` (the home object of the current method `Sub.prototype.methodB`).'
  id: totrans-2844
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Super.prototype`：从`Super.prototype`开始搜索，即`Sub.prototype`的原型（当前方法`Sub.prototype.methodB`的主对象）。'
- en: '`methodB`: Look for a method with the name `methodB`.'
  id: totrans-2845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`methodB`：查找一个名为`methodB`的方法。'
- en: '`call(this, ...)`: Call the method found in the previous step, and maintain
    the current `this`.'
  id: totrans-2846
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`call(this, ...)`：调用在上一步中找到的方法，并保持当前的`this`。'
- en: Avoiding Hardcoding the Name of the Superconstructor
  id: totrans-2847
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免硬编码超级构造函数的名称
- en: 'Until now, we have always referred to supermethods and superconstructors by
    mentioning the superconstructor name. This kind of hardcoding makes your code
    less flexible. You can avoid it by assigning the superprototype to a property
    of `Sub`:'
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们总是通过提及超级构造函数名称来引用超级方法和超级构造函数。这种硬编码使您的代码不够灵活。您可以通过将超级原型分配给`Sub`的属性来避免这种情况：
- en: '[PRE690]'
  id: totrans-2849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: 'Then calling the superconstructor and a supermethod looks as follows:'
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用超级构造函数和超级方法如下所示：
- en: '[PRE691]'
  id: totrans-2851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: 'Setting up `Sub._super` is usually handled by a utility function that also
    connects the subprototype to the superprototype. For example:'
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`Sub._super`通常由一个实用函数处理，该函数还将子原型连接到超级原型。例如：
- en: '[PRE692]'
  id: totrans-2853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: This code uses the helper function `copyOwnPropertiesFrom()`, which is shown
    and explained in [Copying an Object](ch17_split_000.html#code_copyOwnPropertiesFrom
    "Copying an Object").
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用了辅助函数`copyOwnPropertiesFrom()`，该函数在[复制对象](ch17_split_000.html#code_copyOwnPropertiesFrom
    "复制对象")中显示并解释。
- en: Tip
  id: totrans-2855
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Read “subclasses” as a verb: `SubC` *subclasses* `SuperC`. Such a utility function
    can take some of the pain out of creating a subconstructor: there are fewer things
    to do manually, and the name of the superconstructor is never mentioned redundantly.
    The following example demonstrates how it simplifies code.'
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
  zh: 将“子类”解释为一个动词：`SubC` *子类* `SuperC`。这样一个实用函数可以减轻创建子构造函数的痛苦：手动操作的事情更少，而且不会多次提及超级构造函数的名称。以下示例演示了它如何简化代码。
- en: 'Example: Constructor Inheritance in Use'
  id: totrans-2857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：使用中的构造函数继承
- en: 'As a concrete example, let’s assume that the constructor `Person` already exists:'
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
  zh: 具体示例，假设构造函数`Person`已经存在：
- en: '[PRE693]'
  id: totrans-2859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: 'We now want to create the constructor `Employee` as a subconstructor of `Person`.
    We do so manually, which looks like this:'
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要创建构造函数`Employee`作为`Person`的子构造函数。我们手动这样做，看起来像这样：
- en: '[PRE694]'
  id: totrans-2861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: 'Here is the interaction:'
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE695]'
  id: totrans-2863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: 'The utility function `subclasses()` from the previous section makes the code
    of `Employee` slightly simpler and avoids hardcoding the superconstructor `Person`:'
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节的实用函数`subclasses()`使`Employee`的代码稍微简化，并避免了硬编码超级构造函数`Person`：
- en: '[PRE696]'
  id: totrans-2865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: 'Example: The Inheritance Hierarchy of Built-in Constructors'
  id: totrans-2866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：内置构造函数的继承层次结构
- en: 'Built-in constructors use the same subclassing approach described in this section.
    For example, `Array` is a subconstructor of `Object`. Therefore, the prototype
    chain of an instance of `Array` looks like this:'
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
  zh: 内置构造函数使用本节描述的相同子类化方法。例如，`Array`是`Object`的子构造函数。因此，`Array`的实例的原型链如下所示：
- en: '[PRE697]'
  id: totrans-2868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: 'Antipattern: The Prototype Is an Instance of the Superconstructor'
  id: totrans-2869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反模式：原型是超级构造函数的实例
- en: 'Before ECMAScript 5 and `Object.create()`, an often-used solution was to create
    the subprototype by invoking the superconstructor:'
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 5和`Object.create()`之前，经常使用的解决方案是通过调用超级构造函数来创建子原型：
- en: '[PRE698]'
  id: totrans-2871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: This is not recommended under ECMAScript 5\. The prototype will have all of
    `Super`’s instance properties, which it has no use for. Therefore, it is better
    to use the aforementioned pattern (involving `Object.create()`).
  id: totrans-2872
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 5下不推荐这样做。原型将具有所有`Super`的实例属性，而它没有用处。因此，最好使用上述模式（涉及`Object.create()`）。
- en: Methods of All Objects
  id: totrans-2873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有对象的方法
- en: 'Almost all objects have `Object.prototype` in their prototype chain:'
  id: totrans-2874
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有对象的原型链中都有`Object.prototype`：
- en: '[PRE699]'
  id: totrans-2875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: The following subsections describe the methods that `Object.prototype` provides
    for its prototypees.
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各小节描述了`Object.prototype`为其原型提供的方法。
- en: Conversion to Primitive
  id: totrans-2877
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换为原始值
- en: 'The following two methods are used to convert an object to a primitive value:'
  id: totrans-2878
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两种方法用于将对象转换为原始值：
- en: '`Object.prototype.toString()`'
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.prototype.toString()`'
- en: 'Returns a string representation of an object:'
  id: totrans-2880
  prefs: []
  type: TYPE_NORMAL
  zh: 返回对象的字符串表示：
- en: '[PRE700]'
  id: totrans-2881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: '`Object.prototype.valueOf()`'
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.prototype.valueOf()`'
- en: 'This is the preferred way of converting an object to a number. The default
    implementation returns `this`:'
  id: totrans-2883
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将对象转换为数字的首选方法。默认实现返回`this`：
- en: '[PRE701]'
  id: totrans-2884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: '`valueOf` is overridden by wrapper constructors to return the wrapped primitive:'
  id: totrans-2885
  prefs: []
  type: TYPE_NORMAL
  zh: '`valueOf`被包装构造函数覆盖以返回包装的原始值：'
- en: '[PRE702]'
  id: totrans-2886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: 'The conversion to number and string (whether implicit or explicit) builds on
    the conversion to primitive (for details, see [Algorithm: ToPrimitive()—Converting
    a Value to a Primitive](ch08.html#toprimitive "Algorithm: ToPrimitive()—Converting
    a Value to a Primitive")). That is why you can use the aforementioned two methods
    to configure those conversions. `valueOf()` is preferred by the conversion to
    number:'
  id: totrans-2887
  prefs: []
  type: TYPE_NORMAL
  zh: 数字和字符串的转换（无论是隐式还是显式）都建立在原始值的转换基础上（有关详细信息，请参见[算法：ToPrimitive()—将值转换为原始值](ch08.html#toprimitive
    "算法：ToPrimitive()—将值转换为原始值")）。这就是为什么您可以使用上述两种方法来配置这些转换。`valueOf()` 是数字转换的首选方法：
- en: '[PRE703]'
  id: totrans-2888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: '`toString()` is preferred by the conversion to string:'
  id: totrans-2889
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString()` 是首选的字符串转换方法：'
- en: '[PRE704]'
  id: totrans-2890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: The conversion to boolean is not configurable; objects are always considered
    to be `true` (see [Converting to Boolean](ch10.html#toboolean "Converting to Boolean")).
  id: totrans-2891
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔转换不可配置；对象始终被视为`true`（参见[转换为布尔值](ch10.html#toboolean "转换为布尔值")）。
- en: Object.prototype.toLocaleString()
  id: totrans-2892
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Object.prototype.toLocaleString()
- en: This method returns a locale-specific string representation of an object. The
    default implementation calls `toString()`. Most engines don’t go beyond this support
    for this method. However, the ECMAScript Internationalization API (see [The ECMAScript
    Internationalization API](ch30.html#i18n_api "The ECMAScript Internationalization
    API")), which is supported by many modern engines, overrides it for several built-in
    constructors.
  id: totrans-2893
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回对象的区域特定的字符串表示。默认实现调用`toString()`。大多数引擎对于此方法的支持不会超出此范围。然而，ECMAScript国际化API（参见[ECMAScript国际化API](ch30.html#i18n_api
    "ECMAScript国际化API")）由许多现代引擎支持，它为几个内置构造函数覆盖了此方法。
- en: Prototypal Inheritance and Properties
  id: totrans-2894
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原型继承和属性
- en: 'The following methods help with prototypal inheritance and properties:'
  id: totrans-2895
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法有助于原型继承和属性：
- en: '`Object.prototype.isPrototypeOf(obj)`'
  id: totrans-2896
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.prototype.isPrototypeOf(obj)`'
- en: 'Returns `true` if the receiver is part of the prototype chain of `obj`:'
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收者是`obj`的原型链的一部分，则返回`true`：
- en: '[PRE705]'
  id: totrans-2898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: '`Object.prototype.hasOwnProperty(key)`'
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.prototype.hasOwnProperty(key)`'
- en: Returns `true` if `this` owns a property whose key is `key`. “Own” means that
    the property exists in the object itself and not in one of its prototypes.
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`this`拥有一个键为`key`的属性，则返回`true`。“拥有”意味着属性存在于对象本身，而不是其原型链中的一个。
- en: Warning
  id: totrans-2901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: 'You normally should invoke this method generically (not directly), especially
    on objects whose properties you don’t know statically. Why and how is explained
    in [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties"):'
  id: totrans-2902
  prefs: []
  type: TYPE_NORMAL
  zh: 通常应该通用地调用此方法（而不是直接调用），特别是在静态不知道属性的对象上。为什么以及如何在[迭代和检测属性](ch17_split_000.html#iterate_and_detect_properties
    "迭代和检测属性")中有解释：
- en: '[PRE706]'
  id: totrans-2903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: '`Object.prototype.propertyIsEnumerable(propKey)`'
  id: totrans-2904
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.prototype.propertyIsEnumerable(propKey)`'
- en: 'Returns `true` if the receiver has a property with the key `propKey` that is
    enumerable and `false` otherwise:'
  id: totrans-2905
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收者具有具有可枚举键`propKey`的属性，则返回`true`，否则返回`false`：
- en: '[PRE707]'
  id: totrans-2906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: 'Generic Methods: Borrowing Methods from Prototypes'
  id: totrans-2907
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用方法：从原型中借用方法
- en: 'Sometimes instance prototypes have methods that are useful for more objects
    than those that inherit from them. This section explains how to use the methods
    of a prototype without inheriting from it. For example, the instance prototype
    `Wine.prototype` has the method `incAge()`:'
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
  zh: 有时实例原型具有对更多对象有用的方法，而不仅仅是继承自它们的对象。本节解释了如何使用原型的方法而不继承它。例如，实例原型`Wine.prototype`具有方法`incAge()`：
- en: '[PRE708]'
  id: totrans-2909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: 'The interaction is as follows:'
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
  zh: 交互如下：
- en: '[PRE709]'
  id: totrans-2911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: 'The method `incAge()` works for any object that has the property `age`. How
    can we invoke it on an object that is not an instance of `Wine`? Let’s look at
    the preceding method call:'
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
  zh: '`incAge()`方法适用于具有`age`属性的任何对象。我们如何在不是`Wine`实例的对象上调用它？让我们看看前面的方法调用：'
- en: '[PRE710]'
  id: totrans-2913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: 'There are actually two arguments:'
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有两个参数：
- en: '`chablis` is the receiver of the method call, passed to `incAge` via `this`.'
  id: totrans-2915
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chablis`是方法调用的接收器，通过`this`传递给`incAge`。'
- en: '`1` is an argument, passed to `incAge` via `years`.'
  id: totrans-2916
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1`是一个参数，通过`years`传递给`incAge`。'
- en: 'We can’t replace the former with an arbitrary object—the receiver must be an
    instance of `Wine`. Otherwise, the method `incAge` is not found. But the preceding
    method call is equivalent to (refer back to [Calling Functions While Setting this:
    call(), apply(), and bind()](ch17_split_000.html#oop_call_apply_bind "Calling
    Functions While Setting this: call(), apply(), and bind()")):'
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
  zh: '我们不能用任意对象替换前者——接收器必须是`Wine`的实例。否则，找不到方法`incAge`。但前面的方法调用等同于（参见[Calling Functions
    While Setting this: call(), apply(), and bind()](ch17_split_000.html#oop_call_apply_bind
    "Calling Functions While Setting this: call(), apply(), and bind()")）：'
- en: '[PRE711]'
  id: totrans-2918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: 'With the preceding pattern, we can make an object the receiver (first argument
    of `call`) that is not an instance of `Wine`, because the receiver isn’t used
    to find the method `Wine.prototype.incAge`. In the following example, we apply
    the method `incAge()` to the object `john`:'
  id: totrans-2919
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的模式，我们可以使一个对象成为接收器（`call`的第一个参数），而不是`Wine`的实例，因为接收器不用于查找方法`Wine.prototype.incAge`。在下面的例子中，我们将方法`incAge()`应用于对象`john`：
- en: '[PRE712]'
  id: totrans-2920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: A function that can be used in this manner is called a *generic method*; it
    must be prepared for `this` not being an instance of “its” constructor. Thus,
    not all methods are generic; the ECMAScript language specification explicitly
    states which ones are (see [A List of All Generic Methods](ch17_split_001.html#list_of_generic_methods
    "A List of All Generic Methods")).
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以这种方式使用的函数称为*通用方法*；它必须准备好`this`不是“它”的构造函数的实例。因此，并非所有方法都是通用的；ECMAScript语言规范明确规定了哪些方法是通用的（参见[A
    List of All Generic Methods](ch17_split_001.html#list_of_generic_methods "A List
    of All Generic Methods")）。
- en: Accessing Object.prototype and Array.prototype via Literals
  id: totrans-2922
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过文字直接访问Object.prototype和Array.prototype
- en: 'Calling a method generically is quite verbose:'
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
  zh: 通用调用方法相当冗长：
- en: '[PRE713]'
  id: totrans-2924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: 'You can make this shorter by accessing `hasOwnProperty` via an instance of
    `Object`, as created by an empty object literal `{}`:'
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问空对象文字创建的Object实例来更简洁地访问`hasOwnProperty`：
- en: '[PRE714]'
  id: totrans-2926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: 'Similarly, the following two expressions are equivalent:'
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下两个表达式是等价的：
- en: '[PRE715]'
  id: totrans-2928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: The advantage of this pattern is that it is less verbose. But it is also less
    self-explanatory. Performance should not be an issue (at least long term), as
    engines can statically determine that the literals should not create objects.
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的优势在于它不太啰嗦。但它也不太容易理解。性能不应该是一个问题（至少从长远来看），因为引擎可以静态确定文字不应该创建对象。
- en: Examples of Calling Methods Generically
  id: totrans-2930
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用调用方法的示例
- en: 'These are a few examples of generic methods in use:'
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些通用方法的使用示例：
- en: 'Use `apply()`(see [Function.prototype.apply(thisValue, argArray)](ch17_split_000.html#oop_apply
    "Function.prototype.apply(thisValue, argArray)")) to push an array (instead of
    individual elements; see [Adding and Removing Elements (Destructive)](ch18.html#Array.prototype.push
    "Adding and Removing Elements (Destructive)")):'
  id: totrans-2932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`apply()`（参见[Function.prototype.apply(thisValue, argArray)](ch17_split_000.html#oop_apply
    "Function.prototype.apply(thisValue, argArray)")）来推送一个数组（而不是单个元素；参见[Adding and
    Removing Elements (Destructive)](ch18.html#Array.prototype.push "Adding and Removing
    Elements (Destructive)")）：
- en: '[PRE716]'
  id: totrans-2933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: This example is about turning an array into arguments, not about borrowing a
    method from another constructor.
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是关于将数组转换为参数，而不是从另一个构造函数中借用方法。
- en: 'Apply the array method `join()` to a string (which is not an array):'
  id: totrans-2935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数组方法`join()`应用于字符串（不是数组）：
- en: '[PRE717]'
  id: totrans-2936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: Apply the array method `map()` to a string:^([[15](ch17_split_001.html#ftn.id1038112)])
  id: totrans-2937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数组方法`map()`应用于字符串:^([[15](ch17_split_001.html#ftn.id1038112)])
- en: '[PRE718]'
  id: totrans-2938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: 'Using `map()` generically is more efficient than using `split('''')`, which
    creates an intermediate array:'
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
  zh: 通用地使用`map()`比使用`split('')`更有效，后者会创建一个中间数组：
- en: '[PRE719]'
  id: totrans-2940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: 'Apply a string method to nonstrings. `toUpperCase()` converts the receiver
    to a string and uppercases the result:'
  id: totrans-2941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串方法应用于非字符串。`toUpperCase()`将接收器转换为字符串并将结果大写：
- en: '[PRE720]'
  id: totrans-2942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: 'Using generic array methods on plain objects gives you insight into how they
    work:'
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通对象上使用通用数组方法可以让您了解它们的工作原理：
- en: 'Invoke an array method on a fake array:'
  id: totrans-2944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在伪数组上调用数组方法：
- en: '[PRE721]'
  id: totrans-2945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: 'See how an array method transforms an object that it treats like an array:'
  id: totrans-2946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看数组方法如何转换一个被视为数组的对象：
- en: '[PRE722]'
  id: totrans-2947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: Array-Like Objects and Generic Methods
  id: totrans-2948
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类似数组的对象和通用方法
- en: 'There are some objects in JavaScript that feel like an array, but actually
    aren’t. That means that while they have indexed access and a `length` property,
    they don’t have any of the array methods (`forEach()`, `push`, `concat()`, etc.).
    This is unfortunate, but as we will see, generic array methods enable a workaround.
    Examples of array-like objects include:'
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中有一些感觉像数组但实际上不是的对象。这意味着它们具有索引访问和`length`属性，但它们没有任何数组方法（`forEach()`，`push`，`concat()`等）。这很不幸，但正如我们将看到的，通用数组方法可以实现一种解决方法。类似数组的对象的示例包括：
- en: 'The special variable `arguments` (see [All Parameters by Index: The Special
    Variable arguments](ch15.html#arguments_variable "All Parameters by Index: The
    Special Variable arguments")), which is an important array-like object, because
    it is such a fundamental part of JavaScript. `arguments` looks like an array:'
  id: totrans-2950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '特殊变量`arguments`（参见[All Parameters by Index: The Special Variable arguments](ch15.html#arguments_variable
    "All Parameters by Index: The Special Variable arguments")），它是一个重要的类数组对象，因为它是JavaScript的一个基本部分。`arguments`看起来像一个数组：'
- en: '[PRE723]'
  id: totrans-2951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: 'But none of the array methods are available:'
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
  zh: 但是没有任何数组方法可用：
- en: '[PRE724]'
  id: totrans-2953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: 'That’s because `arrayLike` is not an instance of `Array` (and `Array.prototype`
    is not in the prototype chain):'
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`arrayLike`不是`Array`的实例（并且`Array.prototype`不在原型链中）：
- en: '[PRE725]'
  id: totrans-2955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: 'Browser DOM node lists, which are returned by `document.getElementsBy*()` (e.g.,
    `getElementsByTagName()`), `document.forms`, and so on:'
  id: totrans-2956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器DOM节点列表，由`document.getElementsBy*()`（例如`getElementsByTagName()`）、`document.forms`等返回：
- en: '[PRE726]'
  id: totrans-2957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: 'Strings, which are array-like, too:'
  id: totrans-2958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串也是类数组的：
- en: '[PRE727]'
  id: totrans-2959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: 'The term *array-like* can also be seen as a contract between generic array
    methods and objects. The objects have to fulfill certain requirements; otherwise,
    the methods won’t work on them. The requirements are:'
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*类数组*也可以被视为通用数组方法和对象之间的契约。对象必须满足某些要求；否则，这些方法将无法在它们上面工作。这些要求是：
- en: 'The elements of an array-like object must be accessible via square brackets
    and integer indices starting at 0\. All methods need read access, and some methods
    additionally need write access. Note that all objects support this kind of indexing:
    an index in brackets is converted to a string and used as a key to look up a property
    value:'
  id: totrans-2961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类数组对象的元素必须可以通过方括号和从0开始的整数索引访问。所有方法都需要读取访问权限，一些方法还需要写入访问权限。请注意，所有对象都支持这种索引：方括号中的索引被转换为字符串并用作查找属性值的键：
- en: '[PRE728]'
  id: totrans-2962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: An array-like object must have a `length` property whose value is the number
    of its elements. Some methods require `length` to be mutable (for example, `reverse()`).
    Values whose lengths are immutable (for example, strings) cannot be used with
    those methods.
  id: totrans-2963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类数组对象必须有一个`length`属性，其值是其元素的数量。一些方法要求`length`是可变的（例如`reverse()`）。长度不可变的值（例如字符串）不能与这些方法一起使用。
- en: Patterns for working with array-like objects
  id: totrans-2964
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理类数组对象的模式
- en: 'The following patterns are useful for working with array-like objects:'
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模式对处理类数组对象很有用：
- en: 'Turn an array-like object into an array:'
  id: totrans-2966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类数组对象转换为数组：
- en: '[PRE729]'
  id: totrans-2967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: 'The method `slice()` (see [Concatenating, Slicing, Joining (Nondestructive)](ch18.html#Array.prototype.slice
    "Concatenating, Slicing, Joining (Nondestructive)")) without any arguments creates
    a copy of an array-like receiver:'
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`slice()`（参见[Concatenating, Slicing, Joining (Nondestructive)](ch18.html#Array.prototype.slice
    "Concatenating, Slicing, Joining (Nondestructive")）没有任何参数时会创建一个数组接收者的副本：
- en: '[PRE730]'
  id: totrans-2969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: 'To iterate over all elements of an array-like object, you can use a simple
    `for` loop:'
  id: totrans-2970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要遍历类数组对象的所有元素，可以使用简单的`for`循环：
- en: '[PRE731]'
  id: totrans-2971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: 'But you can also borrow `Array.prototype.forEach()`:'
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也可以借用`Array.prototype.forEach()`：
- en: '[PRE732]'
  id: totrans-2973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: 'In both cases, the interaction looks as follows:'
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，交互如下：
- en: '[PRE733]'
  id: totrans-2975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: A List of All Generic Methods
  id: totrans-2976
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用方法列表
- en: 'The following list includes all methods that are generic, as mentioned in the
    ECMAScript language specification:'
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包括所有在ECMAScript语言规范中提到的通用方法：
- en: '`Array.prototype` (see [Array Prototype Methods](ch18.html#array_prototype_methods
    "Array Prototype Methods")):'
  id: totrans-2978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype`（参见[Array Prototype Methods](ch18.html#array_prototype_methods
    "Array Prototype Methods")）：'
- en: '`concat`'
  id: totrans-2979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat`'
- en: '`every`'
  id: totrans-2980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`every`'
- en: '`filter`'
  id: totrans-2981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`'
- en: '`forEach`'
  id: totrans-2982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach`'
- en: '`indexOf`'
  id: totrans-2983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOf`'
- en: '`join`'
  id: totrans-2984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join`'
- en: '`lastIndexOf`'
  id: totrans-2985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastIndexOf`'
- en: '`map`'
  id: totrans-2986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`'
- en: '`pop`'
  id: totrans-2987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop`'
- en: '`push`'
  id: totrans-2988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push`'
- en: '`reduce`'
  id: totrans-2989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`'
- en: '`reduceRight`'
  id: totrans-2990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduceRight`'
- en: '`reverse`'
  id: totrans-2991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse`'
- en: '`shift`'
  id: totrans-2992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shift`'
- en: '`slice`'
  id: totrans-2993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice`'
- en: '`some`'
  id: totrans-2994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`some`'
- en: '`sort`'
  id: totrans-2995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`'
- en: '`splice`'
  id: totrans-2996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splice`'
- en: '`toLocaleString`'
  id: totrans-2997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toLocaleString`'
- en: '`toString`'
  id: totrans-2998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString`'
- en: '`unshift`'
  id: totrans-2999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unshift`'
- en: '`Date.prototype` (see [Date Prototype Methods](ch20.html#date_prototype_methods
    "Date Prototype Methods"))'
  id: totrans-3000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype`（参见[Date Prototype Methods](ch20.html#date_prototype_methods
    "Date Prototype Methods")）'
- en: '`toJSON`'
  id: totrans-3001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toJSON`'
- en: '`Object.prototype` (see [Methods of All Objects](ch17_split_001.html#methods_of_all_objects
    "Methods of All Objects"))'
  id: totrans-3002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype`（参见[Methods of All Objects](ch17_split_001.html#methods_of_all_objects
    "Methods of All Objects")）'
- en: (All `Object` methods are automatically generic—they have to work for all objects.)
  id: totrans-3003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （所有`Object`方法都自动是通用的——它们必须适用于所有对象。）
- en: '`String.prototype` (see [String Prototype Methods](ch12.html#string_prototype_methods
    "String Prototype Methods"))'
  id: totrans-3004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype`（参见[String Prototype Methods](ch12.html#string_prototype_methods
    "String Prototype Methods")）'
- en: '`charAt`'
  id: totrans-3005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`charAt`'
- en: '`charCodeAt`'
  id: totrans-3006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`charCodeAt`'
- en: '`concat`'
  id: totrans-3007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat`'
- en: '`indexOf`'
  id: totrans-3008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOf`'
- en: '`lastIndexOf`'
  id: totrans-3009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastIndexOf`'
- en: '`localeCompare`'
  id: totrans-3010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localeCompare`'
- en: '`match`'
  id: totrans-3011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match`'
- en: '`replace`'
  id: totrans-3012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`'
- en: '`search`'
  id: totrans-3013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search`'
- en: '`slice`'
  id: totrans-3014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice`'
- en: '`split`'
  id: totrans-3015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split`'
- en: '`substring`'
  id: totrans-3016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`substring`'
- en: '`toLocaleLowerCase`'
  id: totrans-3017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toLocaleLowerCase`'
- en: '`toLocaleUpperCase`'
  id: totrans-3018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toLocaleUpperCase`'
- en: '`toLowerCase`'
  id: totrans-3019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toLowerCase`'
- en: '`toUpperCase`'
  id: totrans-3020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toUpperCase`'
- en: '`trim`'
  id: totrans-3021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trim`'
- en: 'Pitfalls: Using an Object as a Map'
  id: totrans-3022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 陷阱：使用对象作为映射
- en: Since JavaScript has no built-in data structure for maps, objects are often
    used as maps from strings to values. Alas, that is more error-prone than it seems.
    This section explains three pitfalls that are involved in this task.
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript没有内置的映射数据结构，对象经常被用作从字符串到值的映射。然而，这比看起来更容易出错。本节解释了在这个任务中涉及的三个陷阱。
- en: 'Pitfall 1: Inheritance Affects Reading Properties'
  id: totrans-3024
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 陷阱1：继承影响属性读取
- en: 'The operations that read properties can be partitioned into two kinds:'
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
  zh: 读取属性的操作可以分为两种：
- en: Some operations consider the whole prototype chain and see inherited properties.
  id: totrans-3026
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些操作会考虑整个原型链并查看继承的属性。
- en: Other operations access only the *own* (noninherited) properties of an object.
  id: totrans-3027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他操作只访问对象的*自有*（非继承的）属性。
- en: 'You need to choose carefully between these kinds of operations when you read
    the entries of an object-as-map. To see why, consider the following example:'
  id: totrans-3028
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读取对象作为映射的条目时，你需要仔细选择这些操作。为了理解原因，考虑以下示例：
- en: '[PRE734]'
  id: totrans-3029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: '`obj` is an object with one own property whose prototype is `proto`, which
    also has one own property. `proto` has the prototype `Object.prototype`, like
    all objects that are created by object literals. Thus, `obj` inherits properties
    from both `proto` and `Object.` `prototype`.'
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj`是一个具有一个自有属性的对象，其原型是`proto`，`proto`也有一个自有属性。`proto`的原型是`Object.prototype`，就像所有通过对象文字创建的对象一样。因此，`obj`从`proto`和`Object.`继承属性。'
- en: 'We want `obj` to be interpreted as a map with the single entry:'
  id: totrans-3031
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`obj`被解释为具有单个条目的映射：
- en: '[PRE735]'
  id: totrans-3032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: That is, we want to ignore inherited properties and only consider own properties.
    Let’s see which read operations interpret `obj` in this manner and which don’t.
    Note that for objects-as-maps, we normally want to use arbitrary property keys,
    stored in variables. That rules out dot notation.
  id: totrans-3033
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们希望忽略继承的属性，只考虑自有属性。让我们看看哪些读取操作以这种方式解释`obj`，哪些不是。请注意，对于对象作为映射，我们通常希望使用存储在变量中的任意属性键。这排除了点表示法。
- en: Checking whether a property exists
  id: totrans-3034
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查属性是否存在
- en: 'The `in` operator checks whether an object has a property with a given key,
    but it considers inherited properties:'
  id: totrans-3035
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符检查对象是否具有给定键的属性，但它会考虑继承的属性：'
- en: '[PRE736]'
  id: totrans-3036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: 'We need the check to ignore inherited properties. `hasOwnProperty()` does what
    we want:'
  id: totrans-3037
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查以忽略继承的属性。`hasOwnProperty()`正是我们想要的：
- en: '[PRE737]'
  id: totrans-3038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: Collecting property keys
  id: totrans-3039
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 收集属性键
- en: 'What operations can we use to find all of the keys of `obj`, while honoring
    our interpretation of it as a map? `for-in` looks like it might work. But, alas,
    it doesn’t:'
  id: totrans-3040
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用什么操作来找到`obj`的所有键，同时又尊重我们对其作为映射的解释？`for-in`看起来可能有效。但是，不幸的是，它不行：
- en: '[PRE738]'
  id: totrans-3041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: It considers inherited enumerable properties. The reason that no properties
    of `Object.prototype` show up here is that all of them are nonenumerable.
  id: totrans-3042
  prefs: []
  type: TYPE_NORMAL
  zh: 它会考虑继承的可枚举属性。`Object.prototype`的属性没有显示在这里的原因是它们都是不可枚举的。
- en: 'In contrast, `Object.keys()` lists only own properties:'
  id: totrans-3043
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`Object.keys()`只列出自有属性：
- en: '[PRE739]'
  id: totrans-3044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: This method returns only enumerable own properties; `ownProp` has been added
    via assignment and is thus enumerable by default. If you want to list all own
    properties, you need to use `Object.getOwnPropertyNames()`.
  id: totrans-3045
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只返回可枚举的自有属性；`ownProp`是通过赋值添加的，因此默认情况下是可枚举的。如果你想列出所有自有属性，你需要使用`Object.getOwnPropertyNames()`。
- en: Getting a property value
  id: totrans-3046
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取属性值
- en: 'For reading the value of a property, we can only choose between the dot operator
    and the bracket operator. We can’t use the former, because we have arbitrary keys,
    stored in variables. That leaves us with the bracket operator, which considers
    inherited properties:'
  id: totrans-3047
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读取属性值，我们只能在点运算符和括号运算符之间进行选择。我们不能使用前者，因为我们有存储在变量中的任意键。这就只剩下了括号运算符，它会考虑继承的属性：
- en: '[PRE740]'
  id: totrans-3048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: 'This is not what we want. There is no built-in operation for reading only own
    properties, but you can easily implement one yourself:'
  id: totrans-3049
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们想要的。没有内置操作可以只读取自有属性，但你可以很容易地自己实现一个：
- en: '[PRE741]'
  id: totrans-3050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: 'With that function, the inherited property `toString` is ignored:'
  id: totrans-3051
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个函数，继承的属性`toString`被忽略了：
- en: '[PRE742]'
  id: totrans-3052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: 'Pitfall 2: Overriding Affects Invoking Methods'
  id: totrans-3053
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 陷阱2：覆盖影响调用方法
- en: 'The function `getOwnProperty()` invoked the method `hasOwnProperty()` on `obj`.
    Normally, that is fine:'
  id: totrans-3054
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`getOwnProperty()`在`obj`上调用了方法`hasOwnProperty()`。通常情况下，这是可以的：
- en: '[PRE743]'
  id: totrans-3055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: 'However, if you add a property to `obj` whose key is `hasOwnProperty`, then
    that property overrides the method `Object.prototype.hasOwnProperty()` and `getOwnProperty()`
    ceases to work:'
  id: totrans-3056
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你向`obj`添加一个键为`hasOwnProperty`的属性，那么该属性将覆盖方法`Object.prototype.hasOwnProperty()`，`getOwnProperty()`将不起作用：
- en: '[PRE744]'
  id: totrans-3057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: 'You can fix this problem by directly referring to `hasOwnProperty()`. This
    avoids going through `obj` to find it:'
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过直接引用`hasOwnProperty()`来解决这个问题。这避免了通过`obj`来查找它：
- en: '[PRE745]'
  id: totrans-3059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: 'We have called `hasOwnProperty()` generically (see [Generic Methods: Borrowing
    Methods from Prototypes](ch17_split_001.html#generic_method "Generic Methods:
    Borrowing Methods from Prototypes")).'
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通用地调用了`hasOwnProperty()`（参见[通用方法：从原型中借用方法](ch17_split_001.html#generic_method
    "通用方法：从原型中借用方法")）。
- en: 'Pitfall 3: The Special Property __proto__'
  id: totrans-3061
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 陷阱3：特殊属性__proto__
- en: 'In many JavaScript engines, the property `__proto__` (see [The Special Property
    __proto__](ch17_split_000.html#proto "The Special Property __proto__")) is special:
    getting it retrieves the prototype of an object, and setting it changes the prototype
    of an object. This is why the object can’t store map data in a property whose
    key is `''__proto__''`. If you want to allow the map key `''__proto__''`, you
    must escape it before using it as a property key:'
  id: totrans-3062
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多JavaScript引擎中，属性`__proto__`（参见[特殊属性__proto__](ch17_split_000.html#proto "特殊属性__proto__")）是特殊的：获取它会检索对象的原型，设置它会改变对象的原型。这就是为什么对象不能在键为`'__proto__'`的属性中存储映射数据。如果你想允许映射键`'__proto__'`，你必须在使用它作为属性键之前对其进行转义：
- en: '[PRE746]'
  id: totrans-3063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: We also need to escape the escaped version of `'__proto__'` (etc.) to avoid
    clashes; that is, if we escape the key `'__proto__'` as `'__proto__%'`, then we
    also need to escape the key `'__proto__%'` so that it doesn’t replace a `'__proto__'`
    entry. That’s what happens in line (1).
  id: totrans-3064
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要转义`'__proto__'`（等等）的转义版本，以避免冲突；也就是说，如果我们将键`'__proto__'`转义为`'__proto__%'`，那么我们还需要转义键`'__proto__%'`，以免它替换`'__proto__'`条目。这就是第（1）行发生的情况。
- en: 'Mark S. Miller mentions the real-world implications of this pitfall in [an
    email](http://mzl.la/1fwnd1l):'
  id: totrans-3065
  prefs: []
  type: TYPE_NORMAL
  zh: Mark S. Miller在[一封电子邮件](http://mzl.la/1fwnd1l)中提到了这个陷阱的现实影响：
- en: Think this exercise is academic and doesn’t arise in real systems? As observed
    at a support thread, until recently, on all non-IE browsers, if you typed “__proto__”
    at the beginning of a new Google Doc, your Google Doc would hang. This was tracked
    down to such a buggy use of an object as a string map.
  id: totrans-3066
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 认为这个练习是学术性的，不会在实际系统中出现吗？正如在一个支持主题中观察到的，直到最近，在所有非IE浏览器上，如果你在新的Google Doc开头输入“__proto__”，你的Google
    Doc会卡住。这是因为将对象作为字符串映射的错误使用。
- en: 'The dict Pattern: Objects Without Prototypes Are Better Maps'
  id: totrans-3067
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: dict模式：没有原型的对象更适合作为映射
- en: 'You create an object without a prototype like this:'
  id: totrans-3068
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样创建一个没有原型的对象：
- en: '[PRE747]'
  id: totrans-3069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: Such an object is a better map (dictionary) than a normal object, which is why
    this pattern is sometimes called the *dict pattern* (*dict* for *dictionary*).
    Let’s first examine normal objects and then find out why prototype-less objects
    are better maps.
  id: totrans-3070
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的对象比普通对象更好的映射（字典），这就是为什么有时这种模式被称为*dict模式*（*dict*代表*dictionary*）。让我们首先检查普通对象，然后找出为什么无原型对象是更好的映射。
- en: Normal objects
  id: totrans-3071
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 普通对象
- en: 'Usually, each object you create in JavaScript has at least `Object.prototype`
    in its prototype chain. The prototype of `Object.prototype` is `null`, so that’s
    where most prototype chains end:'
  id: totrans-3072
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您在JavaScript中创建的每个对象至少都有`Object.prototype`在其原型链中。`Object.prototype`的原型是`null`，因此大多数原型链都在这里结束：
- en: '[PRE748]'
  id: totrans-3073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: Prototype-less objects
  id: totrans-3074
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无原型对象
- en: 'Prototype-less objects have two advantages as maps:'
  id: totrans-3075
  prefs: []
  type: TYPE_NORMAL
  zh: 无原型对象作为映射有两个优点：
- en: 'Inherited properties (pitfall #1) are not an issue anymore, simply because
    there are none. Therefore, you can now freely use the `in` operator to detect
    whether a property exists and brackets to read properties.'
  id: totrans-3076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承的属性（陷阱＃1）不再是问题，因为根本没有。因此，您现在可以自由使用`in`运算符来检测属性是否存在，并使用括号来读取属性。
- en: Soon, `__proto__` will be disabled. In ECMAScript 6, the special property `__proto__`
    will be disabled if `Object.prototype` is not in the prototype chain of an object.
    You can expect JavaScript engines to slowly migrate to this behavior, but it is
    not yet very common.
  id: totrans-3077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很快，`__proto__`将被禁用。在ECMAScript 6中，如果`Object.prototype`不在对象的原型链中，特殊属性`__proto__`将被禁用。您可以期望JavaScript引擎慢慢迁移到这种行为，但目前还不太常见。
- en: 'The only disadvantage is that you’ll lose the services provided by `Object.prototype`.
    For example, a dict object can’t be automatically converted to a string anymore:'
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的缺点是您将失去`Object.prototype`提供的服务。例如，dict对象不再可以自动转换为字符串：
- en: '[PRE749]'
  id: totrans-3079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: But that is not a real disadvantage, because it isn’t safe to directly invoke
    methods on a dict object anyway.
  id: totrans-3080
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是真正的缺点，因为直接在dict对象上调用方法是不安全的。
- en: Recommendation
  id: totrans-3081
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 推荐
- en: Use the dict pattern for quick hacks and as a foundation for libraries. In (nonlibrary)
    production code, a library is preferable, because you can be sure to avoid all
    pitfalls. The next section lists a few such libraries.
  id: totrans-3082
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速的hack和库的基础上使用dict模式。在（非库）生产代码中，库更可取，因为您可以确保避免所有陷阱。下一节列出了一些这样的库。
- en: Best Practices
  id: totrans-3083
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'There are many applications for using objects as maps. If all property keys
    are known statically (at development time), then you just need to make sure that
    you ignore inheritance and look only at own properties. If arbitrary keys can
    be used, you should turn to a library to avoid the pitfalls mentioned in this
    section. Here are two examples:'
  id: totrans-3084
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象作为映射有许多应用。如果所有属性键在开发时已经静态知道，那么你只需要确保忽略继承，只查看自有属性。如果可以使用任意键，你应该转向库，以避免本节中提到的陷阱。以下是两个例子：
- en: '[StringMap.js](http://bit.ly/1fwnp0E) by Google’s [es-lab](http://code.google.com/p/es-lab/)'
  id: totrans-3085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Google的es-lab](http://code.google.com/p/es-lab/)的[StringMap.js](http://bit.ly/1fwnp0E)'
- en: '[stringmap.js](https://github.com/olov/stringmap) by Olov Lassus'
  id: totrans-3086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Olov Lassus](https://github.com/olov/stringmap)的[stringmap.js](https://github.com/olov/stringmap)'
- en: 'Cheat Sheet: Working with Objects'
  id: totrans-3087
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速查表：使用对象
- en: This section is a quick reference with pointers to more thorough explanations.
  id: totrans-3088
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是一个快速参考，指向更详细的解释。
- en: 'Object literals (see [Object Literals](ch17_split_000.html#object_literals
    "Object Literals")):'
  id: totrans-3089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象字面量（参见[对象字面量](ch17_split_000.html#object_literals "Object Literals")）：
- en: '[PRE750]'
  id: totrans-3090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: 'Dot operator (.) (see [Dot Operator (.): Accessing Properties via Fixed Keys](ch17_split_000.html#dot_operator
    "Dot Operator (.): Accessing Properties via Fixed Keys")):'
  id: totrans-3091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '点运算符（.）（参见[点运算符（.）：通过固定键访问属性](ch17_split_000.html#dot_operator "Dot Operator
    (.): Accessing Properties via Fixed Keys")）：'
- en: '[PRE751]'
  id: totrans-3092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: 'Bracket operator ([]) (see [Bracket Operator ([]): Accessing Properties via
    Computed Keys](ch17_split_000.html#bracket_operator "Bracket Operator ([]): Accessing
    Properties via Computed Keys")):'
  id: totrans-3093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '括号运算符（[]）（参见[括号运算符（[]）：通过计算键访问属性](ch17_split_000.html#bracket_operator "Bracket
    Operator ([]): Accessing Properties via Computed Keys")）：'
- en: '[PRE752]'
  id: totrans-3094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: 'Getting and setting the prototype (see [Getting and Setting the Prototype](ch17_split_000.html#get_set_prototype
    "Getting and Setting the Prototype")):'
  id: totrans-3095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和设置原型（参见[获取和设置原型](ch17_split_000.html#get_set_prototype "Getting and Setting
    the Prototype")）：
- en: '[PRE753]'
  id: totrans-3096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: 'Iteration and detection of properties (see [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")):'
  id: totrans-3097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的迭代和检测（参见[属性的迭代和检测](ch17_split_000.html#iterate_and_detect_properties "Iteration
    and Detection of Properties")）：
- en: '[PRE754]'
  id: totrans-3098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: 'Getting and defining properties via descriptors (see [Getting and Defining
    Properties via Descriptors](ch17_split_000.html#functions_for_property_descriptors
    "Getting and Defining Properties via Descriptors")):'
  id: totrans-3099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过描述符获取和定义属性（参见[通过描述符获取和定义属性](ch17_split_000.html#functions_for_property_descriptors
    "Getting and Defining Properties via Descriptors")）：
- en: '[PRE755]'
  id: totrans-3100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: 'Protecting objects (see [Protecting Objects](ch17_split_001.html#protecting_objects
    "Protecting Objects")):'
  id: totrans-3101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护对象（参见[保护对象](ch17_split_001.html#protecting_objects "Protecting Objects")）：
- en: '[PRE756]'
  id: totrans-3102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: 'Methods of all objects (see [Methods of All Objects](ch17_split_001.html#methods_of_all_objects
    "Methods of All Objects")):'
  id: totrans-3103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有对象的方法（参见[所有对象的方法](ch17_split_001.html#methods_of_all_objects "Methods of All
    Objects")）：
- en: '[PRE757]'
  id: totrans-3104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: '* * *'
  id: totrans-3105
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[15](ch17_split_001.html#id1038112)]) Using `map()` in this manner is a tip
    by Brandon Benvie (@benvie).
  id: totrans-3106
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[15](ch17_split_001.html#id1038112)])通过这种方式使用`map()`是Brandon Benvie（@benvie）的一个提示。
- en: Chapter 18. Arrays
  id: totrans-3107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第18章。数组
- en: An array is a map from indices (natural numbers, starting at zero) to arbitrary
    values. The values (the range of the map) are called the array’s *elements*. The
    most convenient way of creating an array is via an array literal. Such a literal
    enumerates the array elements; an element’s position implicitly specifies its
    index.
  id: totrans-3108
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是从索引（从零开始的自然数）到任意值的映射。值（映射的范围）称为数组的*元素*。创建数组的最方便的方法是通过数组字面量。这样的字面量列举了数组元素；元素的位置隐含地指定了它的索引。
- en: In this chapter, I will first cover basic array mechanisms, such as indexed
    access and the `length` property, and then go over array methods.
  id: totrans-3109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将首先介绍基本的数组机制，如索引访问和`length`属性，然后再介绍数组方法。
- en: Overview
  id: totrans-3110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: This section provides a quick overview of arrays. Details are explained later.
  id: totrans-3111
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了数组的快速概述。详细内容将在后面解释。
- en: 'As a first example, we create an array `arr` via an array literal (see [Creating
    Arrays](ch18.html#creating_arrays "Creating Arrays")) and access elements (see
    [Array Indices](ch18.html#array_indices "Array Indices")):'
  id: totrans-3112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，我们通过数组字面量创建一个数组 `arr`（参见[创建数组](ch18.html#creating_arrays "Creating Arrays"））并访问元素（参见[数组索引](ch18.html#array_indices
    "Array Indices"）：
- en: '[PRE758]'
  id: totrans-3113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: 'We can use the array property `length` (see [length](ch18.html#array_length
    "length")) to remove and append elements:'
  id: totrans-3114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用数组属性 `length`（参见[length](ch18.html#array_length "length")）来删除和追加元素：
- en: '[PRE759]'
  id: totrans-3115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: 'The array method `push()` provides another way of appending an element:'
  id: totrans-3116
  prefs: []
  type: TYPE_NORMAL
  zh: 数组方法 `push()` 提供了另一种追加元素的方式：
- en: '[PRE760]'
  id: totrans-3117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: Arrays Are Maps, Not Tuples
  id: totrans-3118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组是映射，不是元组
- en: 'The ECMAScript standard specifies arrays as maps (dictionaries) from indices
    to values. In other words, arrays may not be contiguous and can have holes in
    them. For example:'
  id: totrans-3119
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 标准将数组规定为从索引到值的映射（字典）。换句话说，数组可能不是连续的，并且可能有空洞。例如：
- en: '[PRE761]'
  id: totrans-3120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: 'The preceding array has a hole: there is no element at index 1\. [Holes in
    Arrays](ch18.html#array_holes "Holes in Arrays") explains holes in more detail.'
  id: totrans-3121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数组有一个空洞：索引 1 处没有元素。[数组中的空洞](ch18.html#array_holes "Holes in Arrays") 更详细地解释了空洞。
- en: Note that most JavaScript engines optimize arrays without holes internally and
    store them contiguously.
  id: totrans-3122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大多数 JavaScript 引擎会在内部优化没有空洞的数组，并将它们连续存储。
- en: Arrays Can Also Have Properties
  id: totrans-3123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组也可以有属性
- en: 'Arrays are still objects and can have object properties. Those are not considered
    part of the actual array; that is, they are not considered array elements:'
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
  zh: 数组仍然是对象，可以有对象属性。这些属性不被视为实际数组的一部分；也就是说，它们不被视为数组元素：
- en: '[PRE762]'
  id: totrans-3125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: Creating Arrays
  id: totrans-3126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数组
- en: 'You create an array via an array literal:'
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过数组字面量创建一个数组：
- en: '[PRE763]'
  id: totrans-3128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: 'Trailing commas in arrays are ignored:'
  id: totrans-3129
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的尾随逗号会被忽略：
- en: '[PRE764]'
  id: totrans-3130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: The Array Constructor
  id: totrans-3131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组构造函数
- en: 'There are two ways to use the constructor `Array`: you can create an empty
    array with a given length or an array whose elements are the given values. For
    this constructor, `new` is optional: invoking it as a normal function (without
    `new`) does the same as invoking it as a constructor.'
  id: totrans-3132
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种使用构造函数 `Array` 的方式：可以创建一个给定长度的空数组，或者数组的元素是给定的值。对于这个构造函数，`new` 是可选的：以普通函数的方式调用它（不带
    `new`）与以构造函数的方式调用它是一样的。
- en: Creating an empty array with a given length
  id: totrans-3133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个给定长度的空数组
- en: 'An empty array with a given length has only holes in it! Thus, it rarely makes
    sense to use this version of the constructor:'
  id: totrans-3134
  prefs: []
  type: TYPE_NORMAL
  zh: 给定长度的空数组中只有空洞！因此，很少有意义使用这个版本的构造函数：
- en: '[PRE765]'
  id: totrans-3135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: Some engines may preallocate contiguous memory when you call `Array()` in this
    manner, which may slightly improve performance. However, be sure that the increased
    verbosity and redundancy is worth it!
  id: totrans-3136
  prefs: []
  type: TYPE_NORMAL
  zh: 一些引擎在以这种方式调用 `Array()` 时可能会预先分配连续的内存，这可能会稍微提高性能。但是，请确保增加的冗余性值得！
- en: Initializing an array with elements (avoid!)
  id: totrans-3137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化带有元素的数组（避免！）
- en: 'This way of invoking `Array` is similar to an array literal:'
  id: totrans-3138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调用 `Array` 的方式类似于数组字面量：
- en: '[PRE766]'
  id: totrans-3139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: 'The problem is that you can’t create arrays with a single number in them, because
    that is interpreted as creating an array whose `length` is the number:'
  id: totrans-3140
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于你不能创建只有一个数字的数组，因为那会被解释为创建一个 `length` 为该数字的数组：
- en: '[PRE767]'
  id: totrans-3141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: Multidimensional Arrays
  id: totrans-3142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'If you need multiple dimensions for elements, you must nest arrays. When you
    create such nested arrays, the innermost arrays can grow as needed. But if you
    want direct access to elements, you need to at least create the outer arrays.
    In the following example, I create a three-by-three matrix for Tic-tac-toe. The
    matrix is completely filled with data (as opposed to letting rows grow as needed):'
  id: totrans-3143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为元素创建多个维度，你必须嵌套数组。当你创建这样的嵌套数组时，最内层的数组可以根据需要增长。但是，如果你想直接访问元素，你至少需要创建外部数组。在下面的例子中，我为井字游戏创建了一个三乘三的矩阵。该矩阵完全填满了数据（而不是让行根据需要增长）：
- en: '[PRE768]'
  id: totrans-3144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: 'Here is the output:'
  id: totrans-3145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE769]'
  id: totrans-3146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: 'I wanted the example to demonstrate the general case. Obviously, if a matrix
    is so small and has fixed dimensions, you can set it up via an array literal:'
  id: totrans-3147
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这个例子能够演示一般情况。显然，如果矩阵很小并且具有固定的维度，你可以通过数组字面量来设置它：
- en: '[PRE770]'
  id: totrans-3148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: Array Indices
  id: totrans-3149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组索引
- en: 'When you are working with array indices, you must keep in mind the following
    limits:'
  id: totrans-3150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用数组索引时，你必须牢记以下限制：
- en: Indices are numbers *i* in the range 0 ≤ `i` < 2^(32)−1.
  id: totrans-3151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引是范围在 0 ≤ `i` < 2^(32)−1 的数字 *i*。
- en: The maximum length is 2^(32)−1.
  id: totrans-3152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大长度为 2^(32)−1。
- en: 'Indices that are out of range are treated as normal property keys (strings!).
    They don’t show up as array elements and they don’t influence the property `length`.
    For example:'
  id: totrans-3153
  prefs: []
  type: TYPE_NORMAL
  zh: 超出范围的索引被视为普通的属性键（字符串！）。它们不会显示为数组元素，也不会影响属性 `length`。例如：
- en: '[PRE771]'
  id: totrans-3154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: The in Operator and Indices
  id: totrans-3155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`in` 操作符和索引'
- en: 'The `in` operator detects whether an object has a property with a given key.
    But it can also be used to determine whether a given element index exists in an
    array. For example:'
  id: totrans-3156
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 操作符用于检测对象是否具有给定键的属性。但它也可以用于确定数组中是否存在给定的元素索引。例如：'
- en: '[PRE772]'
  id: totrans-3157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: Deleting Array Elements
  id: totrans-3158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除数组元素
- en: 'In addition to deleting properties, the `delete` operator also deletes array
    elements. Deleting elements creates holes (the `length` property is not updated):'
  id: totrans-3159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了删除属性之外，`delete` 操作符还可以删除数组元素。删除元素会创建空洞（`length` 属性不会更新）：
- en: '[PRE773]'
  id: totrans-3160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: 'You can also delete trailing array elements by decreasing an array’s length
    (see [length](ch18.html#array_length "length") for details). To remove elements
    without creating holes (i.e., the indices of subsequent elements are decremented),
    you use `Array.prototype.splice()` (see [Adding and Removing Elements (Destructive)](ch18.html#Array.prototype.push
    "Adding and Removing Elements (Destructive)")). In this example, we remove two
    elements at index 1:'
  id: totrans-3161
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过减少数组的长度来删除尾随的数组元素（参见[length](ch18.html#array_length "length")了解详情）。要删除元素而不创建空洞（即，后续元素的索引被减少），你可以使用
    `Array.prototype.splice()`（参见[添加和删除元素（破坏性）](ch18.html#Array.prototype.push "Adding
    and Removing Elements (Destructive)")）。在这个例子中，我们删除索引为 1 的两个元素：
- en: '[PRE774]'
  id: totrans-3162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: Array Indices in Detail
  id: totrans-3163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组索引详解
- en: Tip
  id: totrans-3164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is an advanced section. You normally don’t need to know the details explained
    here.
  id: totrans-3165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高级部分。通常情况下，您不需要知道这里解释的细节。
- en: '*Array indices are not what they seem.* Until now, I have pretended that array
    indices are numbers. And that is how JavaScript engines implement arrays, internally.
    However, the ECMAScript specification sees indices differently. Paraphrasing [Section
    15.4](http://bit.ly/1fwoCFg):'
  id: totrans-3166
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组索引并非看起来那样。* 到目前为止，我一直假装数组索引是数字。这也是JavaScript引擎在内部实现数组的方式。然而，ECMAScript规范对索引的看法不同。引用[第15.4节](http://bit.ly/1fwoCFg)的话来说：'
- en: A property key `P` (a string) is an *array index* if and only if `ToString``(ToUint32(P))`
    is equal to `P` and `ToUint32(P)` is not equal to 2^(32)−1\. What this means is
    explained momentarily.
  id: totrans-3167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果且仅当`ToString``(ToUint32(P))`等于`P`且`ToUint32(P)`不等于2^(32)−1时，属性键`P`（一个字符串）才是*数组索引*。这意味着什么将在下面解释。
- en: An array property whose key is an array index is called an *element*.
  id: totrans-3168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性键为数组索引的数组属性称为*元素*。
- en: 'In other words, in the world of the spec all values in brackets are converted
    to strings and interpreted as property keys, even numbers. The following interaction
    demonstrates this:'
  id: totrans-3169
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在规范中，括号中的所有值都被转换为字符串，并解释为属性键，甚至是数字。以下互动演示了这一点：
- en: '[PRE775]'
  id: totrans-3170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE775]'
- en: 'To be an array index, a property key `P` (a string!) must be equal to the result
    of the following computation:'
  id: totrans-3171
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为数组索引，属性键`P`（一个字符串！）必须等于以下计算结果：
- en: Convert `P` to a number.
  id: totrans-3172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`P`转换为数字。
- en: Convert the number to a 32-bit unsigned integer.
  id: totrans-3173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数字转换为32位无符号整数。
- en: Convert the integer to a string.
  id: totrans-3174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整数转换为字符串。
- en: That means that an array index must be a stringified integer *i* in the 32-bit
    range 0 ≤ *i* < 2^(32)−1\. The upper limit has been explicitly excluded in the
    spec (as quoted previously). It is reserved for the maximum length. To see how
    this definition works, let’s use the function `ToUint32()` from [32-bit Integers
    via Bitwise Operators](ch11.html#integers_via_bitwise_operators "32-bit Integers
    via Bitwise Operators").
  id: totrans-3175
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着数组索引必须是32位范围内的字符串化整数*i*，其中0 ≤ *i* < 2^(32)−1。规范明确排除了上限（如前面引用的）。它保留给了最大长度。要了解这个定义是如何工作的，让我们使用[通过位运算符实现32位整数](ch11.html#integers_via_bitwise_operators
    "通过位运算符实现32位整数")中的`ToUint32()`函数。
- en: 'First, a string that doesn’t contain a number is always converted to 0, which,
    after stringification, is not equal to the string:'
  id: totrans-3176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，不包含数字的字符串总是转换为0，这在字符串化后不等于字符串：
- en: '[PRE776]'
  id: totrans-3177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: 'Second, a stringified integer that is out of range is also converted to a completely
    different integer, which is not equal to the string, after stringification:'
  id: totrans-3178
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，超出范围的字符串化整数也会转换为完全不同的整数，与字符串化后不相等：
- en: '[PRE777]'
  id: totrans-3179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE777]'
- en: 'Third, stringified noninteger numbers are converted to integers, which are,
    again, different:'
  id: totrans-3180
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，字符串化的非整数数字会转换为整数，这些整数又是不同的：
- en: '[PRE778]'
  id: totrans-3181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: 'Note that the specification also enforces that array indices don’t have exponents:'
  id: totrans-3182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，规范还强制规定数组索引不得具有指数：
- en: '[PRE779]'
  id: totrans-3183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: 'And that they don’t have leading zeros:'
  id: totrans-3184
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不包含前导零：
- en: '[PRE780]'
  id: totrans-3185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: length
  id: totrans-3186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长度
- en: 'The basic function of the `length` property is to track the highest index in
    an array:'
  id: totrans-3187
  prefs: []
  type: TYPE_NORMAL
  zh: '`length`属性的基本功能是跟踪数组中的最高索引：'
- en: '[PRE781]'
  id: totrans-3188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: 'Thus, `length` does not count the number of elements, so you’d have to write
    your own function for doing so. For example:'
  id: totrans-3189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`length`不计算元素的数量，因此您必须编写自己的函数来执行此操作。例如：
- en: '[PRE782]'
  id: totrans-3190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: 'To count elements (nonholes), we have used the fact that `forEach` skips holes.
    Here is the interaction:'
  id: totrans-3191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算元素（非空洞），我们已经利用了`forEach`跳过空洞的事实。以下是互动：
- en: '[PRE783]'
  id: totrans-3192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: Manually Increasing the Length of an Array
  id: totrans-3193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动增加数组的长度
- en: 'Manually increasing the length of an array has remarkably little effect on
    an array; it only creates holes:'
  id: totrans-3194
  prefs: []
  type: TYPE_NORMAL
  zh: 手动增加数组的长度对数组几乎没有影响；它只会创建空洞：
- en: '[PRE784]'
  id: totrans-3195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: The last result has two commas at the end, because a trailing comma is optional
    and thus always ignored.
  id: totrans-3196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的结果末尾有两个逗号，因为尾随逗号是可选的，因此总是被忽略。
- en: 'What we just did did not add any elements:'
  id: totrans-3197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做的并没有添加任何元素：
- en: '[PRE785]'
  id: totrans-3198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: 'However, the `length` property does act as a pointer indicating where to insert
    new elements. For example:'
  id: totrans-3199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`length`属性确实作为指针，指示在哪里插入新元素。例如：
- en: '[PRE786]'
  id: totrans-3200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: 'Thus, setting the initial length of an array via the `Array` constructor creates
    an array that is completely empty:'
  id: totrans-3201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过`Array`构造函数设置数组的初始长度会创建一个完全空的数组：
- en: '[PRE787]'
  id: totrans-3202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: Decreasing the Length of an Array
  id: totrans-3203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少数组的长度
- en: 'If you decrease the length of an array, all elements at the new length and
    above are deleted:'
  id: totrans-3204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您减少数组的长度，则新长度及以上的所有元素都将被删除：
- en: '[PRE788]'
  id: totrans-3205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: Clearing an array
  id: totrans-3206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清除数组
- en: 'If you set an array’s length to 0, then it becomes empty. That allows you to
    clear an array for someone else. For example:'
  id: totrans-3207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将数组的长度设置为0，则它将变为空。这样可以清除数组。例如：
- en: '[PRE789]'
  id: totrans-3208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: 'Here’s the interaction:'
  id: totrans-3209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是互动：
- en: '[PRE790]'
  id: totrans-3210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: 'Note, however, that this approach can be slow, because each array element is
    explicitly deleted. Ironically, creating a new empty array is often faster:'
  id: totrans-3211
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，这种方法可能会很慢，因为每个数组元素都会被显式删除。具有讽刺意味的是，创建一个新的空数组通常更快：
- en: '[PRE791]'
  id: totrans-3212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: Clearing shared arrays
  id: totrans-3213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清除共享数组
- en: 'You need to be aware of the fact that setting an array’s length to zero affects
    everybody who shares the array:'
  id: totrans-3214
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要知道的是，将数组的长度设置为零会影响共享数组的所有人：
- en: '[PRE792]'
  id: totrans-3215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: 'In contrast, assigning an empty array doesn’t:'
  id: totrans-3216
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，分配一个空数组不会：
- en: '[PRE793]'
  id: totrans-3217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: The Maximum Length
  id: totrans-3218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最大长度
- en: 'The maximum array length is 2^(32)−1:'
  id: totrans-3219
  prefs: []
  type: TYPE_NORMAL
  zh: 最大数组长度为2^(32)−1：
- en: '[PRE794]'
  id: totrans-3220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: Holes in Arrays
  id: totrans-3221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组中的空洞
- en: Arrays are maps from indices to values. That means that arrays can have *holes*,
    indices smaller than the length that are missing in the array. Reading an element
    at one of those indices returns `undefined`.
  id: totrans-3222
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是从索引到值的映射。这意味着数组可以有*空洞*，即长度小于数组中缺失的索引。在这些索引中读取元素会返回`undefined`。
- en: Tip
  id: totrans-3223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'It is recommended that you avoid holes in arrays. JavaScript handles them inconsistently
    (i.e., some methods ignore them, other don’t). Thankfully, you normally don’t
    need to know how holes are handled: they are rarely useful and affect performance
    negatively.'
  id: totrans-3224
  prefs: []
  type: TYPE_NORMAL
  zh: 建议避免数组中的空洞。JavaScript对它们的处理不一致（即，一些方法忽略它们，其他方法不会）。幸运的是，通常你不需要知道如何处理空洞：它们很少有用，并且会对性能产生负面影响。
- en: Creating Holes
  id: totrans-3225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建空洞
- en: 'You can create holes by assigning to array indices:'
  id: totrans-3226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给数组索引赋值可以创建空洞：
- en: '[PRE795]'
  id: totrans-3227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: 'You can also create holes by omitting values in array literals:'
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过在数组字面量中省略值来创建空洞：
- en: '[PRE796]'
  id: totrans-3229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: Warning
  id: totrans-3230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: 'You need two trailing commas to create a trailing hole, because the last comma
    is always ignored:'
  id: totrans-3231
  prefs: []
  type: TYPE_NORMAL
  zh: 需要两个尾随逗号来创建尾随的空洞，因为最后一个逗号总是被忽略：
- en: '[PRE797]'
  id: totrans-3232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE797]'
- en: Sparse Arrays Versus Dense Arrays
  id: totrans-3233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 稀疏数组与密集数组
- en: This section examines the differences between a hole and `undefined` as an element.
    Given that reading a hole returns `undefined`, both are very similar.
  id: totrans-3234
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将检查空洞和`undefined`作为元素之间的区别。鉴于读取空洞会返回`undefined`，两者非常相似。
- en: 'An array with holes is called *sparse*. An array without holes is called *dense*.
    Dense arrays are contiguous and have an element at each index—starting at zero,
    and ending at `length` − 1\. Let’s compare the following two arrays, a sparse
    array and a dense array. The two are very similar:'
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
  zh: 带有空洞的数组称为*稀疏*数组。没有空洞的数组称为*密集*数组。密集数组是连续的，并且在每个索引处都有一个元素——从零开始，到`length`-1结束。让我们比较以下两个数组，一个是稀疏数组，一个是密集数组。这两者非常相似：
- en: '[PRE798]'
  id: totrans-3236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: 'A hole is almost like having the element `undefined` at the same index. Both
    arrays have the same length:'
  id: totrans-3237
  prefs: []
  type: TYPE_NORMAL
  zh: 空洞几乎就像在相同索引处有一个`undefined`元素。两个数组的长度都是一样的：
- en: '[PRE799]'
  id: totrans-3238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE799]'
- en: 'But the sparse array does not have an element at index 0:'
  id: totrans-3239
  prefs: []
  type: TYPE_NORMAL
  zh: 但是稀疏数组没有索引为0的元素：
- en: '[PRE800]'
  id: totrans-3240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: 'Iteration via `for` is the same for both arrays:'
  id: totrans-3241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`for`进行迭代对两个数组来说是一样的：
- en: '[PRE801]'
  id: totrans-3242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE801]'
- en: 'Iteration via `forEach` skips the holes, but not the undefined elements:'
  id: totrans-3243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`forEach`进行迭代会跳过空洞，但不会跳过未定义的元素：
- en: '[PRE802]'
  id: totrans-3244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: Which Operations Ignore Holes, and Which Consider Them?
  id: totrans-3245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哪些操作会忽略空洞，哪些会考虑它们？
- en: Some operations involving arrays ignore holes, while others consider them. This
    sections explains the details.
  id: totrans-3246
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及数组的一些操作会忽略空洞，而另一些会考虑它们。本节解释了细节。
- en: Array iteration methods
  id: totrans-3247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组迭代方法
- en: '`forEach()` skips holes:'
  id: totrans-3248
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach()`会跳过空洞：'
- en: '[PRE803]'
  id: totrans-3249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: '`every()` also skips holes (similarly: `some()`):'
  id: totrans-3250
  prefs: []
  type: TYPE_NORMAL
  zh: '`every()`也会跳过空洞（类似的：`some()`）：'
- en: '[PRE804]'
  id: totrans-3251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: '`map()` skips, but preserves holes:'
  id: totrans-3252
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`会跳过，但保留空洞：'
- en: '[PRE805]'
  id: totrans-3253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE805]'
- en: '`filter()` eliminates holes:'
  id: totrans-3254
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`消除空洞：'
- en: '[PRE806]'
  id: totrans-3255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: Other array methods
  id: totrans-3256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他数组方法
- en: '`join()` converts holes, `undefined`s, and `null`s to empty strings:'
  id: totrans-3257
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`将空洞、`undefined`和`null`转换为空字符串：'
- en: '[PRE807]'
  id: totrans-3258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: '`sort()` preserves holes while sorting:'
  id: totrans-3259
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`在排序时保留空洞：'
- en: '[PRE808]'
  id: totrans-3260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: The for-in loop
  id: totrans-3261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: for-in循环
- en: 'The `for-in` loop correctly lists property keys (which are a superset of array
    indices):'
  id: totrans-3262
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-in`循环正确列出属性键（它们是数组索引的超集）：'
- en: '[PRE809]'
  id: totrans-3263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: Function.prototype.apply()
  id: totrans-3264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Function.prototype.apply()
- en: '`apply()` turns each hole into an argument whose value is `undefined`. The
    following interaction demonstrates this: function `f()` returns its arguments
    as an array. When we pass `apply()` an array with three holes in order to invoke
    `f()`, the latter receives three `undefined` arguments:'
  id: totrans-3265
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()`将每个空洞转换为一个值为`undefined`的参数。以下交互演示了这一点：函数`f()`将其参数作为数组返回。当我们传递一个带有三个空洞的数组给`apply()`以调用`f()`时，后者接收到三个`undefined`参数：'
- en: '[PRE810]'
  id: totrans-3266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: 'That means that we can use `apply()` to create an array with `undefined`s:'
  id: totrans-3267
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以使用`apply()`来创建一个带有`undefined`的数组：
- en: '[PRE811]'
  id: totrans-3268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE811]'
- en: Warning
  id: totrans-3269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '`apply()` translates holes to `undefined`s in empty arrays, but it can’t be
    used to plug holes in arbitrary arrays (which may or may not contain holes). Take,
    for example, the arbitrary array `[2]`:'
  id: totrans-3270
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()`将空洞转换为`undefined`在空数组中，但不能用于在任意数组中填补空洞（可能包含或不包含空洞）。例如，任意数组`[2]`：'
- en: '[PRE812]'
  id: totrans-3271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: The array does not contain any holes, so `apply()` should return the same array.
    Instead, it returns an empty array with length 2 (all it contains are two holes).
    That is because `Array()` interprets single numbers as array lengths, not as array
    elements.
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
  zh: 数组不包含任何空洞，所以`apply()`应该返回相同的数组。但实际上它返回一个长度为2的空数组（它只包含两个空洞）。这是因为`Array()`将单个数字解释为数组长度，而不是数组元素。
- en: Removing Holes from Arrays
  id: totrans-3273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从数组中移除空洞
- en: 'As we have seen, `filter()` removes holes:'
  id: totrans-3274
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`filter()`会移除空洞：
- en: '[PRE813]'
  id: totrans-3275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE813]'
- en: 'Use a custom function to convert holes to `undefined`s in arbitrary arrays:'
  id: totrans-3276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义函数将任意数组中的空洞转换为`undefined`：
- en: '[PRE814]'
  id: totrans-3277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: 'Using the function:'
  id: totrans-3278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该函数：
- en: '[PRE815]'
  id: totrans-3279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE815]'
- en: Array Constructor Method
  id: totrans-3280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组构造方法
- en: '`Array.isArray(obj)`'
  id: totrans-3281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.isArray(obj)`'
- en: 'Returns `true` if `obj` is an array. It correctly handles objects that cross
    *realms* (windows or frames)—as opposed to `instanceof` (see [Pitfall: crossing
    realms (frames or windows)](ch17_split_001.html#cross-realm_instanceof "Pitfall:
    crossing realms (frames or windows)")).'
  id: totrans-3282
  prefs: []
  type: TYPE_NORMAL
  zh: '如果`obj`是数组则返回`true`。它正确处理跨*realms*（窗口或框架）的对象——与`instanceof`相反（参见[Pitfall: crossing
    realms (frames or windows)](ch17_split_001.html#cross-realm_instanceof "Pitfall:
    crossing realms (frames or windows)")）。'
- en: Array Prototype Methods
  id: totrans-3283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组原型方法
- en: In the following sections, array prototype methods are grouped by functionality.
    For each of the subsections, I mention whether the methods are *destructive* (they
    change the arrays that they are invoked on) or *nondestructive* (they don’t modify
    their receivers; such methods often return new arrays).
  id: totrans-3284
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，数组原型方法按功能分组。对于每个子章节，我会提到这些方法是*破坏性*的（它们会改变被调用的数组）还是*非破坏性*的（它们不会修改它们的接收者；这样的方法通常会返回新的数组）。
- en: Adding and Removing Elements (Destructive)
  id: totrans-3285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和删除元素（破坏性）
- en: 'All of the methods in this section are destructive:'
  id: totrans-3286
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有方法都是破坏性的：
- en: '`Array.prototype.shift()`'
  id: totrans-3287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.shift()`'
- en: 'Removes the element at index 0 and returns it. The indices of subsequent elements
    are decremented by 1:'
  id: totrans-3288
  prefs: []
  type: TYPE_NORMAL
  zh: 删除索引为0的元素并返回它。随后元素的索引减1：
- en: '[PRE816]'
  id: totrans-3289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE816]'
- en: '`Array.prototype.unshift(elem1?, elem2?, ...)`'
  id: totrans-3290
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.unshift(elem1?, elem2?, ...)`'
- en: 'Prepends the given elements to the array. It returns the new length:'
  id: totrans-3291
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定的元素添加到数组的开头。它返回新的长度：
- en: '[PRE817]'
  id: totrans-3292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: '`Array.prototype.pop()`'
  id: totrans-3293
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.pop()`'
- en: 'Removes the last element of the array and returns it:'
  id: totrans-3294
  prefs: []
  type: TYPE_NORMAL
  zh: 移除数组的最后一个元素并返回它：
- en: '[PRE818]'
  id: totrans-3295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE818]'
- en: '`Array.prototype.push(elem1?, elem2?, ...)`'
  id: totrans-3296
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.push(elem1?, elem2?, ...)`'
- en: 'Adds the given elements to the end of the array. It returns the new length:'
  id: totrans-3297
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定的元素添加到数组的末尾。它返回新的长度：
- en: '[PRE819]'
  id: totrans-3298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: '`apply()` (see [Function.prototype.apply(thisValue, argArray)](ch17_split_000.html#oop_apply
    "Function.prototype.apply(thisValue, argArray)")) enables you to destructively
    append an array `arr2` to another array `arr1`:'
  id: totrans-3299
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()`（参见[Function.prototype.apply(thisValue, argArray)](ch17_split_000.html#oop_apply
    "Function.prototype.apply(thisValue, argArray)")）使您能够破坏性地将数组`arr2`附加到另一个数组`arr1`：'
- en: '[PRE820]'
  id: totrans-3300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: '`Array.prototype.splice(start, deleteCount?, elem1?, elem2?, ...)`'
  id: totrans-3301
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.splice(start, deleteCount?, elem1?, elem2?, ...)`'
- en: 'Starting at `start`, removes `deleteCount` elements and inserts the elements
    given. In other words, you are replacing the `deleteCount` elements at position
    `start` with `elem1`, `elem2`, and so on. The method returns the elements that
    have been removed:'
  id: totrans-3302
  prefs: []
  type: TYPE_NORMAL
  zh: 从`start`开始，删除`deleteCount`个元素并插入给定的元素。换句话说，您正在用`elem1`、`elem2`等替换位置`start`处的`deleteCount`个元素。该方法返回已被移除的元素：
- en: '[PRE821]'
  id: totrans-3303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: 'Special parameter values:'
  id: totrans-3304
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的参数值：
- en: '`start` can be negative, in which case it is added to the length to determine
    the start index. Thus, `-1` refers the last element, and so on.'
  id: totrans-3305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`可以为负数，这种情况下它将被加到长度以确定起始索引。因此，`-1`指的是最后一个元素，依此类推。'
- en: '`deleteCount` is optional. If it is omitted (along with all subsequent arguments),
    then all elements at and after index `start` are removed.'
  id: totrans-3306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteCount`是可选的。如果省略（以及所有后续参数），则删除从索引`start`开始的所有元素及之后的所有元素。'
- en: 'In this example, we remove all elements after and including the second-to-last
    index:'
  id: totrans-3307
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们删除最后两个索引后的所有元素：
- en: '[PRE822]'
  id: totrans-3308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE822]'
- en: Sorting and Reversing Elements (Destructive)
  id: totrans-3309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和颠倒元素（破坏性）
- en: 'These methods are also destructive:'
  id: totrans-3310
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法也是破坏性的：
- en: '`Array.prototype.reverse()`'
  id: totrans-3311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.reverse()`'
- en: 'Reverses the order of the elements in the array and returns a reference to
    the original (modified) array:'
  id: totrans-3312
  prefs: []
  type: TYPE_NORMAL
  zh: 颠倒数组中元素的顺序并返回对原始（修改后的）数组的引用：
- en: '[PRE823]'
  id: totrans-3313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE823]'
- en: '`Array.prototype.sort(compareFunction?)`'
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.sort(compareFunction?)`'
- en: 'Sorts the array and returns it:'
  id: totrans-3315
  prefs: []
  type: TYPE_NORMAL
  zh: 对数组进行排序并返回它：
- en: '[PRE824]'
  id: totrans-3316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE824]'
- en: 'Keep in mind that sorting compares values by converting them to strings, which
    means that numbers are not sorted numerically:'
  id: totrans-3317
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，排序通过将值转换为字符串进行比较，这意味着数字不会按数字顺序排序：
- en: '[PRE825]'
  id: totrans-3318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE825]'
- en: 'You can fix this by providing the optional parameter `compareFunction`, which
    controls how sorting is done. It has the following signature:'
  id: totrans-3319
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过提供可选参数`compareFunction`来解决这个问题，它控制排序的方式。它具有以下签名：
- en: '[PRE826]'
  id: totrans-3320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE826]'
- en: 'This function compares `a` and `b` and returns:'
  id: totrans-3321
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数比较`a`和`b`并返回：
- en: An integer less than zero (e.g., `-1`) if `a` is less than `b`
  id: totrans-3322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a`小于`b`，则返回小于零的整数（例如，`-1`）
- en: Zero if `a` is equal to `b`
  id: totrans-3323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a`等于`b`，则返回零
- en: An integer greater than zero (e.g., `1`) if `a` is greater than `b`
  id: totrans-3324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a`大于`b`，则返回大于零的整数（例如，`1`）
- en: Comparing Numbers
  id: totrans-3325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较数字
- en: 'For numbers, you can simply return `a-b`, but that can cause numeric overflow.
    To prevent that from happening, you need more verbose code:'
  id: totrans-3326
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数字，您可以简单地返回`a-b`，但这可能会导致数值溢出。为了防止这种情况发生，您需要更冗长的代码：
- en: '[PRE827]'
  id: totrans-3327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE827]'
- en: 'I don’t like nested conditional operators. But in this case, the code is so
    much less verbose that I’m tempted to recommend it:'
  id: totrans-3328
  prefs: []
  type: TYPE_NORMAL
  zh: 我不喜欢嵌套的条件运算符。但在这种情况下，代码要简洁得多，我很想推荐它：
- en: '[PRE828]'
  id: totrans-3329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE828]'
- en: 'Using the function:'
  id: totrans-3330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该函数：
- en: '[PRE829]'
  id: totrans-3331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE829]'
- en: Comparing Strings
  id: totrans-3332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较字符串
- en: 'For strings, you can use `String.prototype.localeCompare` (see [Comparing Strings](ch12.html#comparing_strings
    "Comparing Strings")):'
  id: totrans-3333
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串，您可以使用`String.prototype.localeCompare`（参见[比较字符串](ch12.html#comparing_strings
    "比较字符串")）：
- en: '[PRE830]'
  id: totrans-3334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE830]'
- en: Comparing Objects
  id: totrans-3335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较对象
- en: 'The parameter `compareFunction` is also useful for sorting objects:'
  id: totrans-3336
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`compareFunction`对于排序对象也很有用：
- en: '[PRE831]'
  id: totrans-3337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE831]'
- en: 'With `compareNames` as the compare function, `arr` is sorted by `name`:'
  id: totrans-3338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`compareNames`作为比较函数，`arr`按`name`排序：
- en: '[PRE832]'
  id: totrans-3339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE832]'
- en: Concatenating, Slicing, Joining (Nondestructive)
  id: totrans-3340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接、切片、连接（非破坏性）
- en: 'The following methods perform various nondestructive operations on arrays:'
  id: totrans-3341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法对数组执行各种非破坏性操作：
- en: '`Array.prototype.concat(arr1?, arr2?, ...)`'
  id: totrans-3342
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.concat(arr1?, arr2?, ...)`'
- en: 'Creates a new array that contains all the elements of the receiver, followed
    by all the elements of the array `arr1`, and so on. If one of the parameters is
    not an array, then it is added to the result as an element (for example, the first
    argument, `''c''`, here):'
  id: totrans-3343
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新数组，其中包含接收器的所有元素，后跟数组`arr1`的所有元素，依此类推。如果其中一个参数不是数组，则将其作为元素添加到结果中（例如，这里的第一个参数`'c'`）：
- en: '[PRE833]'
  id: totrans-3344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE833]'
- en: 'The array that `concat()` is invoked on is not changed:'
  id: totrans-3345
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`concat()`的数组不会改变：
- en: '[PRE834]'
  id: totrans-3346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE834]'
- en: '`Array.prototype.slice(begin?, end?)`'
  id: totrans-3347
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.slice(begin?, end?)`'
- en: 'Copies array elements into a new array, starting at `begin`, until and excluding
    the element at `end`:'
  id: totrans-3348
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组元素复制到一个新数组中，从`begin`开始，直到`end`之前的元素：
- en: '[PRE835]'
  id: totrans-3349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE835]'
- en: 'If `end` is missing, the array length is used:'
  id: totrans-3350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少`end`，则使用数组长度：
- en: '[PRE836]'
  id: totrans-3351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE836]'
- en: 'If both indices are missing, the array is copied:'
  id: totrans-3352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个索引都缺失，则复制数组：
- en: '[PRE837]'
  id: totrans-3353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE837]'
- en: 'If either of the indices is negative, the array length is added to it. Thus,
    `-1` refers to the last element, and so on:'
  id: totrans-3354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任一索引为负数，则将数组长度加上它。因此，`-1`指的是最后一个元素，依此类推：
- en: '[PRE838]'
  id: totrans-3355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE838]'
- en: '`Array.prototype.join(separator?)`'
  id: totrans-3356
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.join(separator?)`'
- en: 'Creates a string by applying `toString()` to all array elements and putting
    the string in `separator` between the results. If `separator` is omitted, `'',''`
    is used:'
  id: totrans-3357
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对所有数组元素应用`toString()`并在结果之间放置`separator`字符串来创建一个字符串。如果省略`separator`，则使用`,`：
- en: '[PRE839]'
  id: totrans-3358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE839]'
- en: '`join()` converts `undefined` and `null` to empty strings:'
  id: totrans-3359
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`将`undefined`和`null`转换为空字符串：'
- en: '[PRE840]'
  id: totrans-3360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE840]'
- en: 'Holes in arrays are also converted to empty strings:'
  id: totrans-3361
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的空位也会转换为空字符串：
- en: '[PRE841]'
  id: totrans-3362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE841]'
- en: Searching for Values (Nondestructive)
  id: totrans-3363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索值（非破坏性）
- en: 'The following methods search for values in arrays:'
  id: totrans-3364
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法在数组中搜索值：
- en: '`Array.prototype.indexOf(searchValue, startIndex?)`'
  id: totrans-3365
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.indexOf(searchValue, startIndex?)`'
- en: 'Searches the array for `searchValue`, starting at `startIndex`. It returns
    the index of the first occurrence or –1 if nothing is found. If `startIndex` is
    negative, the array length is added to it; if it is missing, the whole array is
    searched:'
  id: totrans-3366
  prefs: []
  type: TYPE_NORMAL
  zh: 从`startIndex`开始搜索数组中的`searchValue`。它返回第一次出现的索引，如果找不到则返回-1。如果`startIndex`为负数，则将数组长度加上它；如果缺少`startIndex`，则搜索整个数组：
- en: '[PRE842]'
  id: totrans-3367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE842]'
- en: 'Strict equality (seev[Equality Operators: === Versus ==](ch09.html#equality_operators
    "Equality Operators: === Versus ==")) is used for the search, which means that
    `indexOf()` can’t find `NaN`:'
  id: totrans-3368
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索时使用严格相等（参见[相等运算符：===与==](ch09.html#equality_operators "相等运算符：===与==")），这意味着`indexOf()`无法找到`NaN`：
- en: '[PRE843]'
  id: totrans-3369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE843]'
- en: '`Array.prototype.lastIndexOf(searchElement, startIndex?)`'
  id: totrans-3370
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.lastIndexOf(searchElement, startIndex?)`'
- en: 'Searches the array for `searchElement`, starting at `startIndex`, backward.
    It returns the index of the first occurrence or –1 if nothing is found. If `startIndex`
    is negative, the array length is added to it; if it is missing, the whole array
    is searched. Strict equality (see [Equality Operators: === Versus ==](ch09.html#equality_operators
    "Equality Operators: === Versus ==")) is used for the search:'
  id: totrans-3371
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startIndex`开始向后搜索`searchElement`，返回第一次出现的索引或-1（如果找不到）。如果`startIndex`为负数，则将数组长度加上它；如果缺失，则搜索整个数组。搜索时使用严格相等（参见[相等运算符：===与==](ch09.html#equality_operators
    "相等运算符：===与==")）：
- en: '[PRE844]'
  id: totrans-3372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE844]'
- en: Iteration (Nondestructive)
  id: totrans-3373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代（非破坏性）
- en: 'Iteration methods use a function to iterate over an array. I distinguish three
    kinds of iteration methods, all of which are nondestructive: *examination methods*
    mainly observe the content of an array; *transformation methods* derive a new
    array from the receiver; and *reduction methods* compute a result based on the
    receiver’s elements.'
  id: totrans-3374
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代方法使用一个函数来迭代数组。我区分三种迭代方法，它们都是非破坏性的：*检查方法*主要观察数组的内容；*转换方法*从接收器派生一个新数组；*减少方法*基于接收器的元素计算结果。
- en: Examination Methods
  id: totrans-3375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查方法
- en: 'Each method described in this section looks like this:'
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的每个方法都是这样的：
- en: '[PRE845]'
  id: totrans-3377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE845]'
- en: 'Such a method takes the following parameters:'
  id: totrans-3378
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的方法需要以下参数：
- en: '`callback` is its first parameter, a function that it calls. Depending on the
    examination method, the callback returns a boolean or nothing. It has the following
    signature:'
  id: totrans-3379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback`是它的第一个参数，一个它调用的函数。根据检查方法的不同，回调返回布尔值或无返回值。它具有以下签名：'
- en: '[PRE846]'
  id: totrans-3380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE846]'
- en: '`element` is an array element for `callback` to process, `index` is the element’s
    index, and `array` is the array that `examinationMethod` has been invoked on.'
  id: totrans-3381
  prefs: []
  type: TYPE_NORMAL
  zh: '`element`是`callback`要处理的数组元素，`index`是元素的索引，`array`是调用`examinationMethod`的数组。'
- en: '`thisValue` allows you to configure the value of `this` inside `callback`.'
  id: totrans-3382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thisValue`允许您配置`callback`内部的`this`的值。'
- en: 'And now for the examination methods whose signatures I have just described:'
  id: totrans-3383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我刚刚描述的检查方法的签名：
- en: '`Array.prototype.forEach(callback, thisValue?)`'
  id: totrans-3384
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.forEach(callback, thisValue?)`'
- en: 'Iterates over the elements of an array:'
  id: totrans-3385
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代数组的元素：
- en: '[PRE847]'
  id: totrans-3386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE847]'
- en: '`Array.prototype.every(callback, thisValue?)`'
  id: totrans-3387
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.every(callback, thisValue?)`'
- en: Returns `true` if the callback returns `true` for every element. It stops iteration
    as soon as the callback returns `false`. Note that not returning a value leads
    to an implicit return of `undefined`, which `every()` interprets as `false`. `every()`
    works like the universal quantifier (“for all”).
  id: totrans-3388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回调对每个元素返回`true`，则返回`true`。一旦回调返回`false`，迭代就会停止。请注意，不返回值会导致隐式返回`undefined`，`every()`将其解释为`false`。`every()`的工作方式类似于全称量词（“对于所有”）。
- en: 'This example checks whether every number in the array is even:'
  id: totrans-3389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子检查数组中的每个数字是否都是偶数：
- en: '[PRE848]'
  id: totrans-3390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE848]'
- en: 'If the array is empty, the result is `true` (and `callback` is not called):'
  id: totrans-3391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组为空，则结果为`true`（并且不调用`callback`）：
- en: '[PRE849]'
  id: totrans-3392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE849]'
- en: '`Array.prototype.some(callback, thisValue?)`'
  id: totrans-3393
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.some(callback, thisValue?)`'
- en: Returns `true` if the callback returns `true` for at least one element. It stops
    iteration as soon as the callback returns `true`. Note that not returning a value
    leads to an implicit return of `undefined`, which `some` interprets as `false`.
    `some()` works like the existential quantifier (“there exists”).
  id: totrans-3394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回调对至少一个元素返回`true`，则返回`true`。一旦回调返回`true`，迭代就会停止。请注意，不返回值会导致隐式返回`undefined`，`some()`将其解释为`false`。`some()`的工作方式类似于存在量词（“存在”）。
- en: 'This example checks whether there is an even number in the array:'
  id: totrans-3395
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子检查数组中是否有偶数：
- en: '[PRE850]'
  id: totrans-3396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE850]'
- en: 'If the array is empty, the result is `false` (and `callback` is not called):'
  id: totrans-3397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组为空，则结果为`false`（并且不调用`callback`）：
- en: '[PRE851]'
  id: totrans-3398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE851]'
- en: 'One potential pitfall of `forEach()` is that it does not support `break` or
    something similar to prematurely abort the loop. If you need to do that, you can
    use `some()`:'
  id: totrans-3399
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach()`的一个潜在陷阱是它不支持`break`或类似的东西来提前中止循环。如果你需要这样做，可以使用`some()`：'
- en: '[PRE852]'
  id: totrans-3400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE852]'
- en: '`some()` returns `true` if a break happened, and `false` otherwise. This allows
    you to react differently depending on whether iterating finished successfully
    (something that is slightly tricky with `for` loops).'
  id: totrans-3401
  prefs: []
  type: TYPE_NORMAL
  zh: '`some()`如果发生了中断，则返回`true`，否则返回`false`。这使您可以根据迭代是否成功完成（这在`for`循环中有点棘手）做出不同的反应。'
- en: Transformation Methods
  id: totrans-3402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换方法
- en: 'Transformation methods take an input array and produce an output array, while
    the callback controls how the output is produced. The callback has the same signature
    as for examination:'
  id: totrans-3403
  prefs: []
  type: TYPE_NORMAL
  zh: 转换方法接受一个输入数组并产生一个输出数组，而回调控制输出的产生方式。回调的签名与检查方法相同：
- en: '[PRE853]'
  id: totrans-3404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE853]'
- en: 'There are two transformation methods:'
  id: totrans-3405
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种转换方法：
- en: '`Array.prototype.map(callback, thisValue?)`'
  id: totrans-3406
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.map(callback, thisValue?)`'
- en: 'Each output array element is the result of applying `callback` to an input
    element. For example:'
  id: totrans-3407
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输出数组元素是将`callback`应用于输入元素的结果。例如：
- en: '[PRE854]'
  id: totrans-3408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE854]'
- en: '`Array.prototype.filter(callback, thisValue?)`'
  id: totrans-3409
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.filter(callback, thisValue?)`'
- en: 'The output array contains only those input elements for which `callback` returns
    `true`. For example:'
  id: totrans-3410
  prefs: []
  type: TYPE_NORMAL
  zh: 输出数组仅包含那些`callback`返回`true`的输入元素。例如：
- en: '[PRE855]'
  id: totrans-3411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE855]'
- en: Reduction Methods
  id: totrans-3412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少方法
- en: 'For reducing, the callback has a different signature:'
  id: totrans-3413
  prefs: []
  type: TYPE_NORMAL
  zh: 对于减少，回调具有不同的签名：
- en: '[PRE856]'
  id: totrans-3414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE856]'
- en: 'The parameter `previousValue` is the value previously returned by the callback.
    When the callback is first called, there are two possibilities (the descriptions
    are for `Array.prototype.reduce()`; differences with `reduceRight()` are mentioned
    in parentheses):'
  id: totrans-3415
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`previousValue`是回调先前返回的值。当首次调用回调时，有两种可能性（描述适用于`Array.prototype.reduce()`；与`reduceRight()`的差异在括号中提到）：
- en: 'An explicit `initialValue` has been provided. Then `previousValue` is `initialValue`,
    and `currentElement` is the first array element (`reduceRight`: the last array
    element).'
  id: totrans-3416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了明确的`initialValue`。然后`previousValue`是`initialValue`，`currentElement`是第一个数组元素（`reduceRight`：最后一个数组元素）。
- en: 'No explicit `initialValue` has been provided. Then `previousValue` is the first
    array element, and `currentElement` is the second array element (`reduceRight`:
    the last array element and second-to-last array element).'
  id: totrans-3417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有提供明确的`initialValue`。然后`previousValue`是第一个数组元素，`currentElement`是第二个数组元素（`reduceRight`：最后一个数组元素和倒数第二个数组元素）。
- en: 'There are two reduction methods:'
  id: totrans-3418
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种减少的方法：
- en: '`Array.prototype.reduce(callback, initialValue?)`'
  id: totrans-3419
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.reduce(callback, initialValue?)`'
- en: 'Iterates from left to right and invokes the callback as previously sketched.
    The result of the method is the last value returned by the callback. This example
    computes the sum of all array elements:'
  id: totrans-3420
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右迭代，并像之前描述的那样调用回调。该方法的结果是回调返回的最后一个值。此示例计算所有数组元素的总和：
- en: '[PRE857]'
  id: totrans-3421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE857]'
- en: 'If you invoke `reduce` on an array with a single element, that element is returned:'
  id: totrans-3422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个只有一个元素的数组上调用`reduce`，那么该元素会被返回：
- en: '[PRE858]'
  id: totrans-3423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE858]'
- en: 'If you invoke `reduce` on an empty array, you must specify `initialValue`,
    otherwise you get an exception:'
  id: totrans-3424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个空数组上调用`reduce`，你必须指定`initialValue`，否则你会得到一个异常：
- en: '[PRE859]'
  id: totrans-3425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE859]'
- en: '`Array.prototype.reduceRight(callback, initialValue?)`'
  id: totrans-3426
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.reduceRight(callback, initialValue?)`'
- en: Works the same as `reduce()`, but iterates from right to left.
  id: totrans-3427
  prefs: []
  type: TYPE_NORMAL
  zh: 与`reduce()`相同，但从右到左迭代。
- en: Note
  id: totrans-3428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In many functional programming languages, `reduce` is known as `fold` or `foldl`
    (left fold) and `reduceRight` is known as `foldr` (right fold).
  id: totrans-3429
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多函数式编程语言中，`reduce`被称为`fold`或`foldl`（左折叠），`reduceRight`被称为`foldr`（右折叠）。
- en: 'Another way to look at the `reduce` method is that it implements an n-ary operator
    `OP`:'
  id: totrans-3430
  prefs: []
  type: TYPE_NORMAL
  zh: 看`reduce`方法的另一种方式是它实现了一个n元运算符`OP`：
- en: '`OP[1≤i≤n]` x[i]'
  id: totrans-3431
  prefs: []
  type: TYPE_NORMAL
  zh: '`OP[1≤i≤n]` x[i]'
- en: 'via a series of applications of a binary operator `op2`:'
  id: totrans-3432
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一系列二元运算符`op2`的应用：
- en: (...(x[1] `op2` x[2]) `op2` ...) `op2` x[n]
  id: totrans-3433
  prefs: []
  type: TYPE_NORMAL
  zh: (...(x[1] `op2` x[2]) `op2` ...) `op2` x[n]
- en: 'That’s what happened in the previous code example: we implemented an n-ary
    sum operator for arrays via JavaScript’s binary plus operator.'
  id: totrans-3434
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面代码示例中发生的事情：我们通过JavaScript的二进制加法运算符实现了一个数组的n元求和运算符。
- en: 'As an example, let’s examine the two iteration directions via the following
    function:'
  id: totrans-3435
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们通过以下函数来检查两个迭代方向：
- en: '[PRE860]'
  id: totrans-3436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE860]'
- en: 'As expected, `reduce()` iterates from left to right:'
  id: totrans-3437
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`reduce()`从左到右迭代：
- en: '[PRE861]'
  id: totrans-3438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE861]'
- en: 'And `reduceRight()` iterates from right to left:'
  id: totrans-3439
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduceRight()`从右到左迭代：'
- en: '[PRE862]'
  id: totrans-3440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE862]'
- en: 'Pitfall: Array-Like Objects'
  id: totrans-3441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 陷阱：类数组对象
- en: Some objects in JavaScript look like an array, but they aren’t one. That usually
    means that they have indexed access and a `length` property, but none of the array
    methods. Examples include the special variable `arguments`, DOM node lists, and
    strings. [Array-Like Objects and Generic Methods](ch17_split_001.html#array-like_objects
    "Array-Like Objects and Generic Methods") gives tips for working with array-like
    objects.
  id: totrans-3442
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的一些对象看起来像数组，但它们并不是数组。这通常意味着它们具有索引访问和`length`属性，但没有数组方法。例子包括特殊变量`arguments`，DOM节点列表和字符串。[类数组对象和通用方法](ch17_split_001.html#array-like_objects
    "类数组对象和通用方法")提供了处理类数组对象的提示。
- en: 'Best Practices: Iterating over Arrays'
  id: totrans-3443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践：迭代数组
- en: 'To iterate over an array `arr`, you have two options:'
  id: totrans-3444
  prefs: []
  type: TYPE_NORMAL
  zh: 要迭代一个数组`arr`，你有两个选择：
- en: 'A simple `for` loop (see [for](ch13.html#for_loop "for")):'
  id: totrans-3445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的`for`循环（参见[for](ch13.html#for_loop "for")）：
- en: '[PRE863]'
  id: totrans-3446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE863]'
- en: 'One of the array iteration methods (see [Iteration (Nondestructive)](ch18.html#array_iteration_methods
    "Iteration (Nondestructive)")). For example, `forEach()`:'
  id: totrans-3447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组迭代方法之一（参见[迭代（非破坏性）](ch18.html#array_iteration_methods "迭代（非破坏性）")）。例如，`forEach()`：
- en: '[PRE864]'
  id: totrans-3448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE864]'
- en: Do not use the `for-in` loop (see [for-in](ch13.html#for-in "for-in")) to iterate
    over arrays. It iterates over indices, not over values. And it includes the keys
    of normal properties while doing so, including inherited ones.
  id: totrans-3449
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`for-in`循环（参见[for-in](ch13.html#for-in "for-in")）来迭代数组。它遍历索引，而不是值。在这样做的同时，它包括正常属性的键，包括继承的属性。
- en: Chapter 19. Regular Expressions
  id: totrans-3450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第19章。正则表达式
- en: 'This chapter gives an overview of the JavaScript API for regular expressions.
    It assumes that you are roughly familiar with how they work. If you are not, there
    are many good tutorials on the Web. Two examples are:'
  id: totrans-3451
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了正则表达式的JavaScript API。它假定你对它们的工作原理有一定了解。如果你不了解，网上有很多好的教程。其中两个例子是：
- en: '[Regular-Expressions.info](http://www.regular-expressions.info/) by Jan Goyvaerts'
  id: totrans-3452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Regular-Expressions.info](http://www.regular-expressions.info/) by Jan Goyvaerts'
- en: '[JavaScript Regular Expression Enlightenment](http://bit.ly/1fwoQMs) by Cody
    Lindley'
  id: totrans-3453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Cody Lindley的JavaScript正则表达式启示](http://bit.ly/1fwoQMs)'
- en: Regular Expression Syntax
  id: totrans-3454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式语法
- en: The terms used here closely reflect the grammar in the ECMAScript specification.
    I sometimes deviate to make things easier to understand.
  id: totrans-3455
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的术语与ECMAScript规范中的语法非常接近。我有时会偏离以使事情更容易理解。
- en: 'Atoms: General'
  id: totrans-3456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原子：一般
- en: 'The syntax for general atoms is as follows:'
  id: totrans-3457
  prefs: []
  type: TYPE_NORMAL
  zh: 一般原子的语法如下：
- en: Special characters
  id: totrans-3458
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊字符
- en: 'All of the following characters have special meaning:'
  id: totrans-3459
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有字符都具有特殊含义：
- en: '[PRE865]'
  id: totrans-3460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE865]'
- en: 'You can escape them by prefixing a backslash. For example:'
  id: totrans-3461
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在前面加上反斜杠来转义它们。例如：
- en: '[PRE866]'
  id: totrans-3462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE866]'
- en: 'Additional special characters are:'
  id: totrans-3463
  prefs: []
  type: TYPE_NORMAL
  zh: 其他特殊字符包括：
- en: 'Inside a character class `[...]`:'
  id: totrans-3464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字符类`[...]`中：
- en: '[PRE867]'
  id: totrans-3465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE867]'
- en: 'Inside a group that starts with a question mark `(?...)`:'
  id: totrans-3466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以问号`(?...)`开头的组内：
- en: '[PRE868]'
  id: totrans-3467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE868]'
- en: The angle brackets are used only by the XRegExp library (see [Chapter 30](ch30.html
    "Chapter 30. Libraries")), to name groups.
  id: totrans-3468
  prefs: []
  type: TYPE_NORMAL
  zh: 尖括号仅由XRegExp库（参见[第30章](ch30.html "第30章。库")）使用，用于命名组。
- en: Pattern characters
  id: totrans-3469
  prefs: []
  type: TYPE_NORMAL
  zh: 模式字符
- en: All characters except the aforementioned special ones match themselves.
  id: totrans-3470
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的特殊字符之外，所有字符都与它们自己匹配。
- en: '`.` (dot)'
  id: totrans-3471
  prefs: []
  type: TYPE_NORMAL
  zh: '`.`（点）'
- en: 'Matches any JavaScript character (UTF-16 code unit) except line terminators
    (newline, carriage return, etc.). To really match any character, use `[\s\S]`.
    For example:'
  id: totrans-3472
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配任何JavaScript字符（UTF-16代码单元），除了行终止符（换行符、回车符等）。要真正匹配任何字符，请使用`[\s\S]`。例如：
- en: '[PRE869]'
  id: totrans-3473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE869]'
- en: Character escapes (match single characters)
  id: totrans-3474
  prefs: []
  type: TYPE_NORMAL
  zh: 字符转义（匹配单个字符）
- en: Specific control characters include `\f` (form feed), `\n` (line feed, newline),
    `\r` (carriage return), `\t` (horizontal tab), and `\v` (vertical tab).
  id: totrans-3475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定的控制字符包括`\f`（换页符）、`\n`（换行符、新行）、`\r`（回车符）、`\t`（水平制表符）和`\v`（垂直制表符）。
- en: '`\0` matches the NUL character (`\u0000`).'
  id: totrans-3476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\0`匹配NUL字符（`\u0000`）。'
- en: 'Any control character: `\cA` – `\cZ`.'
  id: totrans-3477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何控制字符：`\cA` – `\cZ`。
- en: 'Unicode character escapes: `\u0000` – `\xFFFF` (Unicode code units; see [Chapter 24](ch24.html
    "Chapter 24. Unicode and JavaScript")).'
  id: totrans-3478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode字符转义：`\u0000` – `\xFFFF`（Unicode代码单元；参见[第24章](ch24.html "第24章。Unicode和JavaScript")）。
- en: 'Hexadecimal character escapes: `\x00` – `\xFF`.'
  id: totrans-3479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制字符转义：`\x00` – `\xFF`。
- en: Character class escapes (match one of a set of characters)
  id: totrans-3480
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类转义（匹配一组字符中的一个）
- en: 'Digits: `\d` matches any digit (same as `[0-9]`); `\D` matches any nondigit
    (same as `[^0-9]`).'
  id: totrans-3481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：`\d`匹配任何数字（与`[0-9]`相同）；`\D`匹配任何非数字（与`[^0-9]`相同）。
- en: 'Alphanumeric characters: `\w` matches any Latin alphanumeric character plus
    underscore (same as `[A-Za-z0-9_]`); `\W` matches all characters not matched by
    `\w`.'
  id: totrans-3482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母数字字符：`\w`匹配任何拉丁字母数字字符加下划线（与`[A-Za-z0-9_]`相同）；`\W`匹配所有未被`\w`匹配的字符。
- en: 'Whitespace: `\s` matches whitespace characters (space, tab, line feed, carriage
    return, form feed, all Unicode spaces, etc.); `\S` matches all nonwhitespace characters.'
  id: totrans-3483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白：`\s`匹配空白字符（空格、制表符、换行符、回车符、换页符、所有Unicode空格等）；`\S`匹配所有非空白字符。
- en: 'Atoms: Character Classes'
  id: totrans-3484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原子：字符类
- en: 'The syntax for character classes is as follows:'
  id: totrans-3485
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类的语法如下：
- en: '`[«charSpecs»]` matches any single character that matches at least one of the
    `charSpecs`.'
  id: totrans-3486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[«charSpecs»]`匹配至少一个`charSpecs`中的任何一个的单个字符。'
- en: '`[^«charSpecs»]` matches any single character that does not match any of the
    `charSpecs`.'
  id: totrans-3487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^«charSpecs»]`匹配任何不匹配`charSpecs`中任何一个的单个字符。'
- en: 'The following constructs are all character specifications:'
  id: totrans-3488
  prefs: []
  type: TYPE_NORMAL
  zh: 以下构造都是字符规范：
- en: 'Source characters match themselves. Most characters are source characters (even
    many characters that are special elsewhere). Only three characters are not:'
  id: totrans-3489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源字符匹配它们自己。大多数字符都是源字符（甚至许多在其他地方是特殊的字符）。只有三个字符不是：
- en: '[PRE870]'
  id: totrans-3490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE870]'
- en: As usual, you escape via a backslash. If you want to match a dash without escaping
    it, it must be the first character after the opening bracket or the right side
    of a range, as described shortly.
  id: totrans-3491
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，您可以通过反斜杠进行转义。如果要匹配破折号而不进行转义，它必须是方括号打开后的第一个字符，或者是范围的右侧，如下所述。
- en: 'Class escapes: Any of the character escapes and character class escapes listed
    previously are allowed. There is one additional escape:'
  id: totrans-3492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类转义：允许使用先前列出的任何字符转义和字符类转义。还有一个额外的转义：
- en: 'Backspace (`\b`): Outside a character class, `\b` matches word boundaries.
    Inside a character class, it matches the control character *backspace*.'
  id: totrans-3493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退格（`\b`）：在字符类之外，`\b`匹配单词边界。在字符类内，它匹配控制字符*退格*。
- en: Ranges comprise a source character or a class escape, followed by a dash (`-`),
    followed by a source character or a class escape.
  id: totrans-3494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围包括源字符或类转义，后跟破折号（`-`），后跟源字符或类转义。
- en: 'To demonstrate using character classes, this example parses a date formatted
    in the ISO 8601 standard:'
  id: totrans-3495
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示使用字符类，此示例解析了按照ISO 8601标准格式化的日期：
- en: '[PRE871]'
  id: totrans-3496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE871]'
- en: 'And here is the interaction:'
  id: totrans-3497
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE872]'
  id: totrans-3498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE872]'
- en: 'Atoms: Groups'
  id: totrans-3499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原子：组
- en: 'The syntax for groups is as follows:'
  id: totrans-3500
  prefs: []
  type: TYPE_NORMAL
  zh: 组的语法如下：
- en: '`(«pattern»)` is a capturing group. Whatever is matched by `pattern` can be
    accessed via backreferences or as the result of a match operation.'
  id: totrans-3501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(«pattern»)`是一个捕获组。由`pattern`匹配的任何内容都可以通过反向引用或作为匹配操作的结果来访问。'
- en: '`(?:«pattern»)` is a noncapturing group. `pattern` is still matched against
    the input, but not saved as a capture. Therefore, the group does not have a number
    you can refer to (e.g., via a backreference).'
  id: totrans-3502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(?:«pattern»)`是一个非捕获组。`pattern`仍然与输入匹配，但不保存为捕获。因此，该组没有您可以引用的编号（例如，通过反向引用）。'
- en: '`\1`, `\2`, and so on are known as *backreferences*; they refer back to a previously
    matched group. The number after the backslash can be any integer greater than
    or equal to 1, but the first digit must not be 0.'
  id: totrans-3503
  prefs: []
  type: TYPE_NORMAL
  zh: '`\1`、`\2`等被称为*反向引用*；它们指回先前匹配的组。反斜杠后面的数字可以是大于或等于1的任何整数，但第一个数字不能是0。'
- en: 'In this example, a backreference guarantees the same amount of a’s before and
    after the dash:'
  id: totrans-3504
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，反向引用保证了破��号之前和之后的a的数量相同：
- en: '[PRE873]'
  id: totrans-3505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE873]'
- en: 'This example uses a backreference to match an HTML tag (obviously, you should
    normally use a proper parser to process HTML):'
  id: totrans-3506
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用反向引用来匹配HTML标签（显然，通常应使用适当的解析器来处理HTML）：
- en: '[PRE874]'
  id: totrans-3507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE874]'
- en: Quantifiers
  id: totrans-3508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 量词
- en: 'Any atom (including character classes and groups) can be followed by a quantifier:'
  id: totrans-3509
  prefs: []
  type: TYPE_NORMAL
  zh: 任何原子（包括字符类和组）都可以后跟一个量词：
- en: '`?` means match never or once.'
  id: totrans-3510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`表示匹配零次或一次。'
- en: '`*` means match zero or more times.'
  id: totrans-3511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`表示匹配零次或多次。'
- en: '`+` means match one or more times.'
  id: totrans-3512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`表示匹配一次或多次。'
- en: '`{n}` means match exactly `n` times.'
  id: totrans-3513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n}`表示精确匹配`n`次。'
- en: '`{n,}` means match `n` or more times.'
  id: totrans-3514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n,}`表示匹配`n`次或更多次。'
- en: '`{n,m}` means match at least `n`, at most `m`, times.'
  id: totrans-3515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n,m}`表示至少匹配`n`次，最多匹配`m`次。'
- en: 'By default, quantifiers are *greedy*; that is, they match as much as possible.
    You can get *reluctant* matching (as little as possible) by suffixing any of the
    preceding quantifiers (including the ranges in curly braces) with a question mark
    (`?`). For example:'
  id: totrans-3516
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，量词是*贪婪*的；也就是说，它们尽可能多地匹配。您可以通过在任何前述量词（包括大括号中的范围）后加上问号（`?`）来获得*勉强*匹配（尽可能少）。例如：
- en: '[PRE875]'
  id: totrans-3517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE875]'
- en: 'Thus, `.*?` is a useful pattern for matching everything until the next occurrence
    of the following atom. For example, the following is a more compact version of
    the regular expression for HTML tags just shown (which used `[^<]*` instead of
    `.*?`):'
  id: totrans-3518
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`.*?`是一个用于匹配直到下一个原子出现的有用模式。例如，以下是刚刚显示的HTML标签的正则表达式的更紧凑版本（使用`[^<]*`代替`.*?`）：
- en: '[PRE876]'
  id: totrans-3519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE876]'
- en: Assertions
  id: totrans-3520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: 'Assertions, shown in the following list, are checks about the current position
    in the input:'
  id: totrans-3521
  prefs: []
  type: TYPE_NORMAL
  zh: 断言，如下列表所示，是关于输入中当前位置的检查：
- en: '| `^` | Matches only at the beginning of the input. |'
  id: totrans-3522
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 仅在输入的开头匹配。 |'
- en: '| `$` | Matches only at the end of the input. |'
  id: totrans-3523
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 仅在输入的末尾匹配。 |'
- en: '| `\b` | Matches only at a word boundary. Don’t confuse with `[\b]`, which
    matches a backspace. |'
  id: totrans-3524
  prefs: []
  type: TYPE_TB
  zh: \b：仅在单词边界处匹配。不要与[\b]混淆，它匹配退格。
- en: '| `\B` | Matches only if not at a word boundary. |'
  id: totrans-3525
  prefs: []
  type: TYPE_TB
  zh: \B：仅当不在单词边界时匹配。
- en: '| `(?=«pattern»)` | Positive lookahead: Matches only if `pattern` matches what
    comes next. `pattern` is used only to look ahead, but otherwise ignored. |'
  id: totrans-3526
  prefs: []
  type: TYPE_TB
  zh: 正向预查：仅当“模式”匹配接下来的内容时才匹配。“模式”仅用于向前查看，否则会被忽略。
- en: '| `(?!«pattern»)` | Negative lookahead: Matches only if `pattern` does not
    match what comes next. `pattern` is used only to look ahead, but otherwise ignored.
    |'
  id: totrans-3527
  prefs: []
  type: TYPE_TB
  zh: (?!«pattern»)：负向预查：仅当“模式”不匹配接下来的内容时才匹配。“模式”仅用于向前查看，否则会被忽略。
- en: 'This example matches a word boundary via `\b`:'
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例通过\b匹配单词边界：
- en: '[PRE877]'
  id: totrans-3529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE877]'
- en: 'This example matches the inside of a word via `\B`:'
  id: totrans-3530
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例通过\B匹配单词内部：
- en: '[PRE878]'
  id: totrans-3531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE878]'
- en: Note
  id: totrans-3532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Lookbehind is not supported. [Manually Implementing Lookbehind](ch19.html#regexp-look-behind
    "Manually Implementing Lookbehind") explains how to implement it manually.
  id: totrans-3533
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持后行断言。[手动实现后行断言](ch19.html#regexp-look-behind "手动实现后行断言")解释了如何手动实现它。
- en: Disjunction
  id: totrans-3534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分歧
- en: A disjunction operator (`|`) separates two alternatives; either of the alternatives
    must match for the disjunction to match. The alternatives are atoms (optionally
    including quantifiers).
  id: totrans-3535
  prefs: []
  type: TYPE_NORMAL
  zh: 分歧运算符（|）分隔两个选择；任一选择必须匹配分歧才能匹配。这些选择是原子（可选包括量词）。
- en: 'The operator binds very weakly, so you have to be careful that the alternatives
    don’t extend too far. For example, the following regular expression matches all
    strings that either start with `aa` or end with `bb`:'
  id: totrans-3536
  prefs: []
  type: TYPE_NORMAL
  zh: 该运算符的绑定非常弱，因此您必须小心，以确保选择不会延伸太远。例如，以下正则表达式匹配所有以'aa'开头或以'bb'结尾的字符串：
- en: '[PRE879]'
  id: totrans-3537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE879]'
- en: 'In other words, the disjunction binds more weakly than even `^` and `$` and
    the two alternatives are `^aa` and `bb$`. If you want to match the two strings
    `''aa''` and `''bb''`, you need parentheses:'
  id: totrans-3538
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，分歧比甚至^和$都要弱，两个选择是^aa和bb$。如果要匹配两个字符串'aa'和'bb'，则需要括号：
- en: '[PRE880]'
  id: totrans-3539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE880]'
- en: 'Similarly, if you want to match the strings `''aab''` and `''abb''`:'
  id: totrans-3540
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果要匹配字符串'aab'和'abb'：
- en: '[PRE881]'
  id: totrans-3541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE881]'
- en: Unicode and Regular Expressions
  id: totrans-3542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unicode和正则表达式
- en: JavaScript’s regular expressions have only very limited support for Unicode.
    Especially when it comes to code points in the astral planes, you have to be careful.
    [Chapter 24](ch24.html "Chapter 24. Unicode and JavaScript") explains the details.
  id: totrans-3543
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的正则表达式对Unicode的支持非常有限。特别是当涉及到星际飞船中的代码点时，您必须小心。[第24章](ch24.html "第24章.
    Unicode and JavaScript")解释了详细信息。
- en: Creating a Regular Expression
  id: totrans-3544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建正则表达式
- en: You can create a regular expression via either a literal or a constructor and
    configure how it works via flags.
  id: totrans-3545
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过文字或构造函数创建正则表达式，并通过标志配置其工作方式。
- en: Literal Versus Constructor
  id: totrans-3546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文字与构造函数
- en: 'There are two ways to create a regular expression: you can use a literal or
    the constructor `RegExp`:'
  id: totrans-3547
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以创建正则表达式：您可以使用文字或构造函数RegExp：
- en: '| Literal | `/xyz/i` | Compiled at load time |'
  id: totrans-3548
  prefs: []
  type: TYPE_TB
  zh: 文字：/xyz/i：在加载时编译
- en: '| Constructor (second argument is optional) | `new RegExp(''xyz'', ''i'')`
    | Compiled at runtime |'
  id: totrans-3549
  prefs: []
  type: TYPE_TB
  zh: 构造函数（第二个参数是可选的）：new RegExp('xyz'，'i')：在运行时编译
- en: 'A literal and a constructor differ in when they are compiled:'
  id: totrans-3550
  prefs: []
  type: TYPE_NORMAL
  zh: 文字和构造函数在编译时不同：
- en: 'The literal is compiled at load time. The following code will cause an exception
    when it is evaluated:'
  id: totrans-3551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字在加载时编译。在评估时，以下代码将引发异常：
- en: '[PRE882]'
  id: totrans-3552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE882]'
- en: 'The constructor compiles the regular expression when it is called. The following
    code will not cause an exception, but calling `foo()` will:'
  id: totrans-3553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数在调用时编译正则表达式。以下代码不会引发异常，但调用foo()会：
- en: '[PRE883]'
  id: totrans-3554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE883]'
- en: Thus, you should normally use literals, but you need the constructor if you
    want to dynamically assemble a regular expression.
  id: totrans-3555
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常应使用文字，但如果要动态组装正则表达式，则需要构造函数。
- en: Flags
  id: totrans-3556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标志
- en: 'Flags are a suffix of regular expression literals and a parameter of regular
    expression constructors; they modify the matching behavior of regular expressions.
    The following flags exist:'
  id: totrans-3557
  prefs: []
  type: TYPE_NORMAL
  zh: 标志是正则表达式文字的后缀和正则表达式构造函数的参数；它们修改正则表达式的匹配行为。存在以下标志：
- en: '| Short name | Long name | Description |'
  id: totrans-3558
  prefs: []
  type: TYPE_TB
  zh: 短名称：长名称：描述：
- en: '| --- | --- | --- |'
  id: totrans-3559
  prefs: []
  type: TYPE_TB
  zh: '---：---：---'
- en: '| `g` | `global` | The given regular expression is matched multiple times.
    Influences several methods, especially `replace()`. |'
  id: totrans-3560
  prefs: []
  type: TYPE_TB
  zh: g：全局：给定的正则表达式多次匹配。影响几种方法，特别是replace()。
- en: '| `i` | `ignoreCase` | Case is ignored when trying to match the given regular
    expression. |'
  id: totrans-3561
  prefs: []
  type: TYPE_TB
  zh: i：ignoreCase：在尝试匹配给定的正则表达式时忽略大小写。
- en: '| `m` | `multiline` | In multiline mode, the begin operator `^` and the end
    operator `$` match each line, instead of the complete input string. |'
  id: totrans-3562
  prefs: []
  type: TYPE_TB
  zh: m：多行模式：在多行模式下，开始运算符^和结束运算符$匹配每一行，而不是完整的输入字符串。
- en: The short name is used for literal prefixes and constructor parameters (see
    examples in the next section). The long name is used for properties of a regular
    expression that indicate what flags were set during its creation.
  id: totrans-3563
  prefs: []
  type: TYPE_NORMAL
  zh: 短名称用于文字前缀和构造函数参数（请参见下一节中的示例）。长名称用于正则表达式的属性，指示在创建期间设置了哪些标志。
- en: Instance Properties of Regular Expressions
  id: totrans-3564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式的实例属性
- en: 'Regular expressions have the following instance properties:'
  id: totrans-3565
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式具有以下实例属性：
- en: 'Flags: boolean values indicating what flags are set:'
  id: totrans-3566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志：表示设置了哪些标志的布尔值：
- en: '`global`: Is flag `/g` set?'
  id: totrans-3567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局：标志/g设置了吗？
- en: '`ignoreCase`: Is flag `/i` set?'
  id: totrans-3568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ignoreCase：标志/i设置了吗？
- en: '`multiline`: Is flag `/m` set?'
  id: totrans-3569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行：标志/m设置了吗？
- en: 'Data for matching multiple times (flag `/g` is set):'
  id: totrans-3570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于多次匹配的数据（设置了/g标志）：
- en: '`lastIndex` is the index where to continue the search next time.'
  id: totrans-3571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lastIndex是下次继续搜索的索引。
- en: 'The following is an example of accessing the instance properties for flags:'
  id: totrans-3572
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是访问标志的实例属性的示例：
- en: '[PRE884]'
  id: totrans-3573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE884]'
- en: Examples of Creating Regular Expressions
  id: totrans-3574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建正则表达式的示例
- en: 'In this example, we create the same regular expression first with a literal,
    then with a constructor, and use the `test()` method to determine whether it matches
    a string:'
  id: totrans-3575
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先使用文字创建相同的正则表达式，然后使用构造函数，并使用`test()`方法来确定它是否匹配一个字符串：
- en: '[PRE885]'
  id: totrans-3576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE885]'
- en: 'In this example, we create a regular expression that ignores case (flag `/i`):'
  id: totrans-3577
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建一个忽略大小写的正则表达式（标志`/i`）：
- en: '[PRE886]'
  id: totrans-3578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE886]'
- en: 'RegExp.prototype.test: Is There a Match?'
  id: totrans-3579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RegExp.prototype.test：是否有匹配？
- en: 'The `test()` method checks whether a regular expression, `regex`, matches a
    string, `str`:'
  id: totrans-3580
  prefs: []
  type: TYPE_NORMAL
  zh: '`test()`方法检查正则表达式`regex`是否匹配字符串`str`：'
- en: '[PRE887]'
  id: totrans-3581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE887]'
- en: '`test()` operates differently depending on whether the flag `/g` is set or
    not.'
  id: totrans-3582
  prefs: []
  type: TYPE_NORMAL
  zh: '`test()`的操作方式取决于标志`/g`是否设置。'
- en: 'If the flag `/g` is not set, then the method checks whether there is a match
    somewhere in `str`. For example:'
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标志`/g`未设置，则该方法检查`str`中是否有匹配。例如：
- en: '[PRE888]'
  id: totrans-3584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE888]'
- en: 'If the flag `/g` is set, then the method returns `true` as many times as there
    are matches for `regex` in `str`. The property `regex.lastIndex` contains the
    index after the last match:'
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了标志`/g`，则该方法返回`true`，直到`str`中`regex`的匹配次数。属性`regex.lastIndex`包含最后匹配后的索引：
- en: '[PRE889]'
  id: totrans-3586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE889]'
- en: 'String.prototype.search: At What Index Is There a Match?'
  id: totrans-3587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: String.prototype.search：有匹配的索引吗？
- en: 'The `search()` method looks for a match with `regex` within `str`:'
  id: totrans-3588
  prefs: []
  type: TYPE_NORMAL
  zh: '`search()`方法在`str`中查找与`regex`匹配的内容：'
- en: '[PRE890]'
  id: totrans-3589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE890]'
- en: If there is a match, the index where it was found is returned. Otherwise, the
    result is `-1`. The properties `global` and `lastIndex` of `regex` are ignored
    as the search is performed (and `lastIndex` is not changed).
  id: totrans-3590
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有匹配，返回找到匹配的索引。否则，结果为`-1`。`regex`的`global`和`lastIndex`属性在执行搜索时被忽略（`lastIndex`不会改变）。
- en: 'For example:'
  id: totrans-3591
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE891]'
  id: totrans-3592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE891]'
- en: 'If the argument of `search()` is not a regular expression, it is converted
    to one:'
  id: totrans-3593
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`search()`的参数不是正则表达式，则会转换为正则表达式：
- en: '[PRE892]'
  id: totrans-3594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE892]'
- en: 'RegExp.prototype.exec: Capture Groups'
  id: totrans-3595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RegExp.prototype.exec：捕获组
- en: 'The following method call captures groups while matching `regex` against `str`:'
  id: totrans-3596
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法调用在匹配`regex`和`str`时捕获组：
- en: '[PRE893]'
  id: totrans-3597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE893]'
- en: 'If there was no match, `matchData` is `null`. Otherwise, `matchData` is a *match
    result*, an array with two additional properties:'
  id: totrans-3598
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配，`matchData`为`null`。否则，`matchData`是一个*匹配结果*，一个带有两个额外属性的数组：
- en: Array elements
  id: totrans-3599
  prefs: []
  type: TYPE_NORMAL
  zh: 数组元素
- en: Element 0 is the match for the complete regular expression (group 0, if you
    will).
  id: totrans-3600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素0是完整正则表达式的匹配（如果愿意的话，是第0组）。
- en: Element *n* > 1 is the capture of group *n*.
  id: totrans-3601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素*n* > 1是第*n*组的捕获。
- en: Properties
  id: totrans-3602
  prefs: []
  type: TYPE_NORMAL
  zh: 属性
- en: '`input` is the complete input string.'
  id: totrans-3603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input`是完整的输入字符串。'
- en: '`index` is the index where the match was found.'
  id: totrans-3604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`是找到匹配的索引。'
- en: First Match (Flag /g Not Set)
  id: totrans-3605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一个匹配（标志/g未设置）
- en: 'If the flag `/g` is not set, only the first match is returned:'
  id: totrans-3606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标志`/g`未设置，则只返回第一个匹配：
- en: '[PRE894]'
  id: totrans-3607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE894]'
- en: All Matches (Flag /g Set)
  id: totrans-3608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有匹配（标志/g设置）
- en: 'If the flag `/g` is set, all matches are returned if you invoke `exec()` repeatedly.
    The return value `null` signals that there are no more matches. The property `lastIndex`
    indicates where matching will continue next time:'
  id: totrans-3609
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了标志`/g`，则如果反复调用`exec()`，所有匹配都会被返回。返回值`null`表示没有更多的匹配。属性`lastIndex`指示下次匹配将继续的位置：
- en: '[PRE895]'
  id: totrans-3610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE895]'
- en: 'Here we loop over matches:'
  id: totrans-3611
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们循环匹配：
- en: '[PRE896]'
  id: totrans-3612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE896]'
- en: 'and we get the following output:'
  id: totrans-3613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE897]'
  id: totrans-3614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE897]'
- en: 'String.prototype.match: Capture Groups or Return All Matching Substrings'
  id: totrans-3615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: String.prototype.match：捕获组或返回所有匹配的子字符串
- en: 'The following method call matches `regex` against `str`:'
  id: totrans-3616
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法调用匹配`regex`和`str`：
- en: '[PRE898]'
  id: totrans-3617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE898]'
- en: 'If the flag `/g` of `regex` is not set, this method works like `RegExp.prototype.exec()`:'
  id: totrans-3618
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`regex`的标志`/g`未设置，此方法的工作方式类似于`RegExp.prototype.exec()`：
- en: '[PRE899]'
  id: totrans-3619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE899]'
- en: 'If the flag is set, then the method returns an array with all matching substrings
    in `str` (i.e., group 0 of every match) or `null` if there is no match:'
  id: totrans-3620
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了标志，则该方法返回一个包含`str`中所有匹配子字符串的数组（即每次匹配的第0组），如果没有匹配则返回`null`：
- en: '[PRE900]'
  id: totrans-3621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE900]'
- en: 'String.prototype.replace: Search and Replace'
  id: totrans-3622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: String.prototype.replace：搜索和替换
- en: 'The `replace()` method searches a string, `str`, for matches with `search`
    and replaces them with `replacement`:'
  id: totrans-3623
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace()`方法搜索字符串`str`，找到与`search`匹配的内容，并用`replacement`替换它们：'
- en: '[PRE901]'
  id: totrans-3624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE901]'
- en: 'There are several ways in which the two parameters can be specified:'
  id: totrans-3625
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以指定这两个参数：
- en: '`search`'
  id: totrans-3626
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`'
- en: 'Either a string or a regular expression:'
  id: totrans-3627
  prefs: []
  type: TYPE_NORMAL
  zh: 可以是字符串或正则表达式：
- en: 'String: To be found literally in the input string. Be warned that only the
    first occurrence of a string is replaced. If you want to replace multiple occurrences,
    you must use a regular expression with a `/g` flag. This is unexpected and a major
    pitfall.'
  id: totrans-3628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：在输入字符串中直接查找。请注意，只有第一次出现的字符串会被替换。如果要替换多个出现，必须使用带有`/g`标志的正则表达式。这是一个意外和一个主要的陷阱。
- en: 'Regular expression: To be matched against the input string. Warning: Use the
    `global` flag, otherwise only one attempt is made to match the regular expression.'
  id: totrans-3629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式：与输入字符串匹配。警告：使用`global`标志，否则只会尝试一次匹配正则表达式。
- en: '`replacement`'
  id: totrans-3630
  prefs: []
  type: TYPE_NORMAL
  zh: '`replacement`'
- en: 'Either a string or a function:'
  id: totrans-3631
  prefs: []
  type: TYPE_NORMAL
  zh: 可以是字符串或函数：
- en: 'String: Describes how to replace what has been found.'
  id: totrans-3632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：描述如何替换已找到的内容。
- en: 'Function: Computes a replacement and is given matching information via parameters.'
  id: totrans-3633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能：通过参数提供匹配信息来计算替换。
- en: Replacement Is a String
  id: totrans-3634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换是一个字符串
- en: 'If `replacement` is a string, its content is used verbatim to replace the match.
    The only exception is the special character dollar sign (`$`), which starts so-called
    *replacement directives*:'
  id: totrans-3635
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`replacement`是一个字符串，它的内容将被直接使用来替换匹配。唯一的例外是特殊字符美元符号（`$`），它启动所谓的*替换指令*：
- en: 'Groups: `$n` inserts group n from the match. `n` must be at least 1 (`$0` has
    no special meaning).'
  id: totrans-3636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：`$n`插入匹配中的第n组。`n`必须至少为1（`$0`没有特殊含义）。
- en: 'The matching substring:'
  id: totrans-3637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配的子字符串：
- en: '`$`` (backtick) inserts the text before the match.'
  id: totrans-3638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$``（反引号）插入匹配前的文本。'
- en: '`$&` inserts the complete match.'
  id: totrans-3639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$&`插入完整的匹配。'
- en: '`$''` (apostrophe) inserts the text after the match.'
  id: totrans-3640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$''`（撇号）插入匹配后的文本。'
- en: '`$$` inserts a single `$`.'
  id: totrans-3641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$$`插入一个单独的`$`。'
- en: 'This example refers to the matching substring and its prefix and suffix:'
  id: totrans-3642
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子涉及匹配的子字符串及其前缀和后缀：
- en: '[PRE902]'
  id: totrans-3643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE902]'
- en: 'This example refers to a group:'
  id: totrans-3644
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子涉及到一个组：
- en: '[PRE903]'
  id: totrans-3645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE903]'
- en: Replacement Is a Function
  id: totrans-3646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换是一个函数
- en: 'If `replacement` is a function, it computes the string that is to replace the
    match. This function has the following signature:'
  id: totrans-3647
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`replacement`是一个函数，它会计算要替换匹配的字符串。此函数具有以下签名：
- en: '[PRE904]'
  id: totrans-3648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE904]'
- en: '`completeMatch` is the same as `$&` previously, `offset` indicates where the
    match was found, and `inputStr` is what is being matched against. Thus, you can
    use the special variable `arguments` to access groups (group 1 via `arguments[1]`,
    and so on). For example:'
  id: totrans-3649
  prefs: []
  type: TYPE_NORMAL
  zh: '`completeMatch`与以前的`$&`相同，`offset`指示找到匹配的位置，`inputStr`是正在匹配的内容。因此，您可以使用特殊变量`arguments`来访问组（通过`arguments[1]`访问第1组，依此类推）。例如：'
- en: '[PRE905]'
  id: totrans-3650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE905]'
- en: Problems with the Flag /g
  id: totrans-3651
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标志`/g`的问题
- en: 'Regular expressions whose `/g` flag is set are problematic if a method invoked
    on them must be invoked multiple times to return all results. That’s the case
    for two methods:'
  id: totrans-3652
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了`/g`标志的正则表达式如果必须多次调用才能返回所有结果，则存在问题。这适用于两种方法：
- en: '`RegExp.prototype.test()`'
  id: totrans-3653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegExp.prototype.test()`'
- en: '`RegExp.prototype.exec()`'
  id: totrans-3654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegExp.prototype.exec()`'
- en: 'Then JavaScript abuses the regular expression as an iterator, as a pointer
    into the sequence of results. That causes problems:'
  id: totrans-3655
  prefs: []
  type: TYPE_NORMAL
  zh: 然后JavaScript滥用正则表达式作为迭代器，作为结果序列的指针。这会导致问题：
- en: 'Problem 1: `/g` regular expressions can’t be inlined'
  id: totrans-3656
  prefs: []
  type: TYPE_NORMAL
  zh: 问题1：无法内联`/g`正则表达式
- en: 'For example:'
  id: totrans-3657
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE906]'
  id: totrans-3658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE906]'
- en: 'The preceding loop is infinite, because a new regular expression is created
    for each loop iteration, which restarts the iteration over the results. Therefore,
    the code must be rewritten:'
  id: totrans-3659
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的循环是无限的，因为每次循环迭代都会创建一个新的正则表达式，从而重新开始结果的迭代。因此，必须重写代码：
- en: '[PRE907]'
  id: totrans-3660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE907]'
- en: 'Here is another example:'
  id: totrans-3661
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子：
- en: '[PRE908]'
  id: totrans-3662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE908]'
- en: 'Calling the preceding function will again result in an infinite loop. The correct
    version is (why `lastIndex` is set to 0 is explained shortly):'
  id: totrans-3663
  prefs: []
  type: TYPE_NORMAL
  zh: 调用前面的函数将再次导致无限循环。正确的版本是（为什么`lastIndex`设置为0很快就会解释）：
- en: '[PRE909]'
  id: totrans-3664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE909]'
- en: 'Using the function:'
  id: totrans-3665
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该函数：
- en: '[PRE910]'
  id: totrans-3666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE910]'
- en: Tip
  id: totrans-3667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It’s a best practice not to inline anyway (then you can give regular expressions
    descriptive names). But you have to be aware that you can’t do it, not even in
    quick hacks.
  id: totrans-3668
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是不要内联（然后您可以给正则表达式起一个描述性的名称）。但是您必须意识到您不能这样做，即使是在快速的hack中也不行。
- en: 'Problem 2: `/g` regular expressions as parameters'
  id: totrans-3669
  prefs: []
  type: TYPE_NORMAL
  zh: 问题2：`/g`正则表达式作为参数
- en: Code that wants to invoke `test()` and `exec()` multiple times must be careful
    with a regular expression handed to it as a parameter. Its flag `/g` must active
    and, to be safe, its `lastIndex` should be set to zero (an explanation is offered
    in the next example).
  id: totrans-3670
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`test()`和`exec()`多次的代码在作为参数传递给它的正则表达式时必须小心。它的标志`/g`必须激活，并且为了安全起见，它的`lastIndex`应该设置为零（下一个示例中提供了解释）。
- en: 'Problem 3: Shared `/g` regular expressions (e.g., constants)'
  id: totrans-3671
  prefs: []
  type: TYPE_NORMAL
  zh: 问题3：共享的`/g`正则表达式（例如，常量）
- en: Whenever you are referring to a regular expression that has not been freshly
    created, you should set its `lastIndex` property to zero, before using it as an
    iterator (an explanation is offered in the next example). As iteration depends
    on `lastIndex`, such a regular expression can’t be used in more than one iteration
    at the same time.
  id: totrans-3672
  prefs: []
  type: TYPE_NORMAL
  zh: 每当引用尚未新创建的正则表达式时，您应该在将其用作迭代器之前将其`lastIndex`属性设置为零（下一个示例中提供了解释）。由于迭代取决于`lastIndex`，因此这样的正则表达式不能同时在多个迭代中使用。
- en: 'The following example illustrates problem 2\. It is a naive implementation
    of a function that counts how many matches there are for the regular expression
    `regex` in the string `str`:'
  id: totrans-3673
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了问题2。这是一个简单的实现函数，用于计算字符串`str`中正则表达式`regex`的匹配次数：
- en: '[PRE911]'
  id: totrans-3674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE911]'
- en: 'Here’s an example of using this function:'
  id: totrans-3675
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用此函数的示例：
- en: '[PRE912]'
  id: totrans-3676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE912]'
- en: 'The first problem is that this function goes into an infinite loop if the regular
    expression’s `/g` flag is not set. For example:'
  id: totrans-3677
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是，如果正则表达式的`/g`标志未设置，此函数将进入无限循环。例如：
- en: '[PRE913]'
  id: totrans-3678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE913]'
- en: 'The second problem is that the function doesn’t work correctly if `regex.lastIndex`
    isn’t 0, because that property indicates where to start the search. For example:'
  id: totrans-3679
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是，如果`regex.lastIndex`不是0，函数将无法正确工作，因为该属性指示从哪里开始搜索。例如：
- en: '[PRE914]'
  id: totrans-3680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE914]'
- en: 'The following implementation fixes the two problems:'
  id: totrans-3681
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现解决了两个问题：
- en: '[PRE915]'
  id: totrans-3682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE915]'
- en: 'A simpler alternative is to use `match()`:'
  id: totrans-3683
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的替代方法是使用`match()`：
- en: '[PRE916]'
  id: totrans-3684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE916]'
- en: 'There’s one possible pitfall: `str.match()` returns `null` if the `/g` flag
    is set and there are no matches. We avoid that pitfall in the preceding code by
    using `[]` if the result of `match()` isn’t truthy.'
  id: totrans-3685
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个可能的陷阱：如果设置了`/g`标志并且没有匹配项，`str.match()`将返回`null`。在前面的代码中，我们通过使用`[]`来避免这种陷阱，如果`match()`的结果不是真值。
- en: Tips and Tricks
  id: totrans-3686
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: This section gives a few tips and tricks for working with regular expressions
    in JavaScript.
  id: totrans-3687
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一些在JavaScript中使用正则表达式的技巧和窍门。
- en: Quoting Text
  id: totrans-3688
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用文本
- en: 'Sometimes, when you assemble a regular expression manually, you want to use
    a given string verbatim. That means that none of the special characters (e.g.,
    `*`, `[`) should be interpreted as such—all of them need to be escaped. JavaScript
    has no built-in means for this kind of quoting, but you can program your own function,
    `quoteText`, that would work as follows:'
  id: totrans-3689
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当手动组装正则表达式时，您希望逐字使用给定的字符串。这意味着不能解释任何特殊字符（例如，`*`，`[`）-所有这些字符都需要转义。JavaScript没有内置的方法来进行这种引用，但是您可以编写自己的函数`quoteText`，它将按以下方式工作：
- en: '[PRE917]'
  id: totrans-3690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE917]'
- en: 'Such a function is especially handy if you need to do a search and replace
    with multiple occurrences. Then the value to search for must be a regular expression
    with the `global` flag set. With `quoteText()`, you can use arbitrary strings.
    The function looks like this:'
  id: totrans-3691
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要进行多次搜索和替换，则此函数特别方便。然后要搜索的值必须是设置了`global`标志的正则表达式。使用`quoteText()`，您可以使用任意字符串。该函数如下所示：
- en: '[PRE918]'
  id: totrans-3692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE918]'
- en: All special characters are escaped, because you may want to quote several characters
    inside parentheses or square brackets.
  id: totrans-3693
  prefs: []
  type: TYPE_NORMAL
  zh: 所有特殊字符都被转义，因为您可能希望在括号或方括号内引用多个字符。
- en: 'Pitfall: Without an Assertion (e.g., ^, $), a Regular Expression Is Found Anywhere'
  id: totrans-3694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 陷阱：没有断言（例如，^，$），正则表达式可以在任何地方找到
- en: 'If you don’t use assertions such as `^` and `$`, most regular expression methods
    find a pattern anywhere. For example:'
  id: totrans-3695
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用`^`和`$`等断言，大多数正则表达式方法会在任何地方找到模式。例如：
- en: '[PRE919]'
  id: totrans-3696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE919]'
- en: Matching Everything or Nothing
  id: totrans-3697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配一切或什么都不匹配
- en: It’s a rare use case, but sometimes you need a regular expression that matches
    everything or nothing. For example, a function may have a parameter with a regular
    expression that is used for filtering. If that parameter is missing, you give
    it a default value, a regular expression that matches everything.
  id: totrans-3698
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个罕见的用例，但有时您需要一个正则表达式，它匹配一切或什么都不匹配。例如，一个函数可能有一个用于过滤的正则表达式参数。如果该参数缺失，您可以给它一个默认值，一个匹配一切的正则表达式。
- en: Matching everything
  id: totrans-3699
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 匹配一切
- en: 'The empty regular expression matches everything. We can create an instance
    of `RegExp` based on that regular expression like this:'
  id: totrans-3700
  prefs: []
  type: TYPE_NORMAL
  zh: 空正则表达式匹配一切。我们可以基于该正则表达式创建一个`RegExp`的实例，就像这样：
- en: '[PRE920]'
  id: totrans-3701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE920]'
- en: 'However, the empty regular expression literal would be `//`, which is interpreted
    as a comment by JavaScript. Therefore, the following is the closest you can get
    via a literal: `/(?:)/` (empty noncapturing group). The group matches everything,
    while not capturing anything, which the group from influencing the result returned
    by `exec()`. Even JavaScript itself uses the preceding representation when displaying
    an empty regular expression:'
  id: totrans-3702
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，空正则表达式文字将是`//`，这在JavaScript中被解释为注释。因此，以下是通过文字获得的最接近的：`/(?:)/`（空的非捕获组）。该组匹配一切，同时不捕获任何内容，这个组不会影响`exec()`返回的结果。即使JavaScript本身在显示空正则表达式时也使用前面的表示：
- en: '[PRE921]'
  id: totrans-3703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE921]'
- en: Matching nothing
  id: totrans-3704
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 匹配什么都不匹配
- en: 'The empty regular expression has an inverse—the regular expression that matches
    nothing:'
  id: totrans-3705
  prefs: []
  type: TYPE_NORMAL
  zh: 空正则表达式具有一个反义词——匹配什么都不匹配的正则表达式：
- en: '[PRE922]'
  id: totrans-3706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE922]'
- en: Manually Implementing Lookbehind
  id: totrans-3707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动实现后行断言
- en: Lookbehind is an assertion. Similar to lookahead, a pattern is used to check
    something about the current position in the input, but otherwise ignored. In contrast
    to lookahead, the match for the pattern has to *end* at the current position (not
    start at it).
  id: totrans-3708
  prefs: []
  type: TYPE_NORMAL
  zh: 后行断言是一种断言。与先行断言类似，模式用于检查输入中当前位置的某些内容，但在其他情况下被忽略。与先行断言相反，模式的匹配必须*结束*在当前位置（而不是从当前位置开始）。
- en: 'The following function replaces each occurrence of the string `''NAME''` with
    the value of the parameter `name`, but only if the occurrence is not preceded
    by a quote. We handle the quote by “manually” checking the character before the
    current match:'
  id: totrans-3709
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将字符串`'NAME'`的每个出现替换为参数`name`的值，但前提是该出现不是由引号引导的。我们通过“手动”检查当前匹配之前的字符来处理引号：
- en: '[PRE923]'
  id: totrans-3710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE923]'
- en: '[PRE924]'
  id: totrans-3711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE924]'
- en: 'An alternative is to include the characters that may escape in the regular
    expression. Then you have to temporarily add a prefix to the string you are searching
    in; otherwise, you’d miss matches at the beginning of that string:'
  id: totrans-3712
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在正则表达式中包含可能转义的字符。然后，您必须临时向您正在搜索的字符串添加前缀；否则，您将错过该字符串开头的匹配：
- en: '[PRE925]'
  id: totrans-3713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE925]'
- en: Regular Expression Cheat Sheet
  id: totrans-3714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式速查表
- en: 'Atoms (see [Atoms: General](ch19.html#regex_atoms_general "Atoms: General")):'
  id: totrans-3715
  prefs: []
  type: TYPE_NORMAL
  zh: 原子（参见[原子：一般](ch19.html#regex_atoms_general "原子：一般")）：
- en: '`.` (dot) matches everything except line terminators (e.g., newlines). Use
    `[\s\S]` to really match everything.'
  id: totrans-3716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`（点）匹配除行终止符（例如换行符）之外的所有内容。使用`[\s\S]`来真正匹配一切。'
- en: 'Character class escapes:'
  id: totrans-3717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符类转义：
- en: '`\d` matches digits (`[0-9]`); `\D` matches nondigits (`[^0-9]`).'
  id: totrans-3718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d`匹配数字（`[0-9]`）；`\D`匹配非数字（`[^0-9]`）。'
- en: '`\w` matches Latin alphanumeric characters plus underscore (`[A-Za-z0-9_]`);
    `\W` matches all other characters.'
  id: totrans-3719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w`匹配拉丁字母数字字符加下划线（`[A-Za-z0-9_]`）；`\W`匹配所有其他字符。'
- en: '`\s` matches all whitespace characters (space, tab, line feed, etc.); `\S`
    matches all nonwhitespace characters.'
  id: totrans-3720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s`匹配所有空白字符（空格、制表符、换行符等）；`\S`匹配所有非空白字符。'
- en: 'Character class (set of characters): `[...]` and `[^...]`'
  id: totrans-3721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符类（字符集）：`[...]`和`[^...]`
- en: 'Source characters: `[abc]` (all characters except `\ ] -` match themselves)'
  id: totrans-3722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源字符：`[abc]`（除`\ ] -`之外的所有字符都与它们自身匹配）
- en: 'Character class escapes (see previous): `[\d\w]`'
  id: totrans-3723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符类转义（参见前文）：`[\d\w]`
- en: 'Ranges: `[A-Za-z0-9]`'
  id: totrans-3724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：`[A-Za-z0-9]`
- en: 'Groups:'
  id: totrans-3725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：
- en: 'Capturing group: `(...)`; backreference: `\1`'
  id: totrans-3726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获组：`(...)`；反向引用：`\1`
- en: 'Noncapturing group: `(?:...)`'
  id: totrans-3727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非捕获组：`(?:...)`
- en: 'Quantifiers (see [Quantifiers](ch19.html#regexp_quantifiers "Quantifiers")):'
  id: totrans-3728
  prefs: []
  type: TYPE_NORMAL
  zh: 量词（参见[量词](ch19.html#regexp_quantifiers "量词")）：
- en: 'Greedy:'
  id: totrans-3729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪婪：
- en: '`? * +`'
  id: totrans-3730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`? * +`'
- en: '`{n} {n,} {n,m}`'
  id: totrans-3731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n} {n,} {n,m}`'
- en: 'Reluctant: Put a `?` after any of the greedy quantifiers.'
  id: totrans-3732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 勉强：在任何贪婪量词后面加上`?`。
- en: 'Assertions (see [Assertions](ch19.html#regexp_assertions "Assertions")):'
  id: totrans-3733
  prefs: []
  type: TYPE_NORMAL
  zh: 断言（参见[断言](ch19.html#regexp_assertions "断言")）：
- en: 'Beginning of input, end of input: `^ $`'
  id: totrans-3734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入的开始，输入的结束：`^ $`
- en: 'At a word boundary, not at a word boundary: `\b \B`'
  id: totrans-3735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在词边界处，不在词边界处：`\b \B`
- en: 'Positive lookahead: `(?=...)` (pattern must come next, but is otherwise ignored)'
  id: totrans-3736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正向先行断言：`(?=...)`（模式必须紧跟其后，但在其他情况下被忽略）
- en: 'Negative lookahead: `(?!...)` (pattern must not come next, but is otherwise
    ignored)'
  id: totrans-3737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负向先行断言：`(?!...)`（模式不能紧跟其后，但在其他情况下被忽略）
- en: 'Disjunction: `|`'
  id: totrans-3738
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：`|`
- en: 'Creating a regular expression (see [Creating a Regular Expression](ch19.html#creating_regexps
    "Creating a Regular Expression")):'
  id: totrans-3739
  prefs: []
  type: TYPE_NORMAL
  zh: 创建正则表达式（参见[创建正则表达式](ch19.html#creating_regexps "创建正则表达式")）：
- en: 'Literal: `/xyz/i` (compiled at load time)'
  id: totrans-3740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面量：`/xyz/i`（在加载时编译）
- en: 'Constructor: `new RegExp(''xzy'', ''i'')` (compiled at runtime)'
  id: totrans-3741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数：`new RegExp('xzy', 'i')`（在运行时编译）
- en: 'Flags (see [Flags](ch19.html#regexp_flags "Flags")):'
  id: totrans-3742
  prefs: []
  type: TYPE_NORMAL
  zh: 标志（参见[标志](ch19.html#regexp_flags "标志")）：
- en: 'global: `/g` (influences several regular expression methods)'
  id: totrans-3743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局：`/g`（影响几种正则表达式方法）
- en: 'ignoreCase: `/i`'
  id: totrans-3744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ignoreCase：`/i`
- en: 'multiline: `/m` (`^` and `$` match per line, as opposed to the complete input)'
  id: totrans-3745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行：`/m`（`^`和`$`按行匹配，而不是完整的输入）
- en: 'Methods:'
  id: totrans-3746
  prefs: []
  type: TYPE_NORMAL
  zh: 方法：
- en: '`regex.test(str)`: Is there a match (see [RegExp.prototype.test: Is There a
    Match?](ch19.html#RegExp.prototype.test "RegExp.prototype.test: Is There a Match?"))?'
  id: totrans-3747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regex.test(str)`: 是否有匹配（参见[RegExp.prototype.test: 是否有匹配？](ch19.html#RegExp.prototype.test
    "RegExp.prototype.test: 是否有匹配？")）？'
- en: '`/g` is not set: Is there a match somewhere?'
  id: totrans-3748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/g`未设置：是否有匹配？'
- en: '`/g` is set: Return `true` as many times as there are matches.'
  id: totrans-3749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/g`被设置：返回与匹配次数相同的`true`。'
- en: '`str.search(regex)`: At what index is there a match (see [String.prototype.search:
    At What Index Is There a Match?](ch19.html#String.prototype.search "String.prototype.search:
    At What Index Is There a Match?"))?'
  id: totrans-3750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str.search(regex)`: 有匹配项的索引是什么（参见[String.prototype.search: At What Index Is
    There a Match?](ch19.html#String.prototype.search "String.prototype.search: At
    What Index Is There a Match?")）？'
- en: '`regex.exec(str)`: Capture groups (see the section [RegExp.prototype.exec:
    Capture Groups](ch19.html#RegExp.prototype.exec "RegExp.prototype.exec: Capture
    Groups"))?'
  id: totrans-3751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regex.exec(str)`: 捕获组（参见章节[RegExp.prototype.exec: Capture Groups](ch19.html#RegExp.prototype.exec
    "RegExp.prototype.exec: Capture Groups")）？'
- en: '`/g` is not set: Capture groups of first match only (invoked once)'
  id: totrans-3752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/g`未设置：仅捕获第一个匹配项的组（仅调用一次）'
- en: '`/g` is set: Capture groups of all matches (invoked repeatedly; returns `null`
    if there are no more matches)'
  id: totrans-3753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/g`已设置：捕获所有匹配项的组（重复调用；如果没有更多匹配项，则返回`null`）'
- en: '`str.match(regex)`: Capture groups or return all matching substrings (see [String.prototype.match:
    Capture Groups or Return All Matching Substrings](ch19.html#String.prototype.match
    "String.prototype.match: Capture Groups or Return All Matching Substrings"))'
  id: totrans-3754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str.match(regex)`: 捕获组或返回所有匹配的子字符串（参见[String.prototype.match: Capture Groups
    or Return All Matching Substrings](ch19.html#String.prototype.match "String.prototype.match:
    Capture Groups or Return All Matching Substrings")）'
- en: '`/g` is not set: Capture groups'
  id: totrans-3755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/g`未设置：捕获组'
- en: '`/g` is set: Return all matching substrings in an array'
  id: totrans-3756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/g`已设置：返回数组中所有匹配的子字符串'
- en: '`str.replace(search, replacement)`: Search and replace (see [String.prototype.replace:
    Search and Replace](ch19.html#String.prototype.replace "String.prototype.replace:
    Search and Replace"))'
  id: totrans-3757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str.replace(search, replacement)`: 搜索和替换（参见[String.prototype.replace: Search
    and Replace](ch19.html#String.prototype.replace "String.prototype.replace: Search
    and Replace")）'
- en: '`search`: String or regular expression (use the latter, set `/g`!)'
  id: totrans-3758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search`：字符串或正则表达式（使用后者，设置`/g`！）'
- en: '`replacement`: String (with `$1`, etc.) or function (`arguments[1]` is group
    1, etc.) that returns a string'
  id: totrans-3759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replacement`：字符串（带有`$1`等）或函数（`arguments[1]`是第1组等），返回一个字符串'
- en: For tips on using the flag `/g`, see [Problems with the Flag /g](ch19.html#tips_flag_g
    "Problems with the Flag /g").
  id: totrans-3760
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用标志`/g`的提示，请参阅[Problems with the Flag /g](ch19.html#tips_flag_g "Problems
    with the Flag /g")。
- en: Acknowledgments
  id: totrans-3761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 致谢
- en: Mathias Bynens (@mathias) and Juan Ignacio Dopazo (@juandopazo) recommended
    using `match()` and `test()` for counting occurrences, and Šime Vidas (@simevidas)
    warned me about being careful with `match()` if there are no matches. The pitfall
    of the global flag causing infinite loops comes from a [talk by Andrea Giammarchi](http://bit.ly/1fwpdXv)
    (@webreflection). Claude Pache told me to escape more characters in `quoteText()`.
  id: totrans-3762
  prefs: []
  type: TYPE_NORMAL
  zh: Mathias Bynens（@mathias）和Juan Ignacio Dopazo（@juandopazo）建议使用`match()`和`test()`来计算出现次数，Šime
    Vidas（@simevidas）警告我在没有匹配项时要小心使用`match()`。全局标志导致无限循环的陷阱来自[Andrea Giammarchi的演讲](http://bit.ly/1fwpdXv)（@webreflection）。Claude
    Pache告诉我在`quoteText()`中转义更多字符。
- en: Chapter 20. Dates
  id: totrans-3763
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第20章。日期
- en: JavaScript’s `Date` constructor helps with parsing, managing, and displaying
    dates. This chapter describes how it works.
  id: totrans-3764
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的`Date`构造函数有助于解析、管理和显示日期。本章描述了它的工作原理。
- en: The date API uses the term *UTC* (Coordinated Universal Time). For most purposes,
    UTC is a synonym for GMT (Greenwich Mean Time) and roughly means the time zone
    of London, UK.
  id: totrans-3765
  prefs: []
  type: TYPE_NORMAL
  zh: 日期API使用术语*UTC*（协调世界时）。在大多数情况下，UTC是GMT（格林尼治标准时间）的同义词，大致意味着伦敦，英国的时区。
- en: The Date Constructor
  id: totrans-3766
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期构造函数
- en: 'There are four ways of invoking the constructor of `Date`:'
  id: totrans-3767
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种调用`Date`构造函数的方法：
- en: '`new Date(year, month, date?, hours?, minutes?, seconds?, milliseconds?)`'
  id: totrans-3768
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Date(year, month, date?, hours?, minutes?, seconds?, milliseconds?)`'
- en: 'Constructs a new date from the given data. The time is interpreted relative
    to the current time zone. `Date.UTC()` provides similar functionality, but relative
    to UTC. The parameters have the following ranges:'
  id: totrans-3769
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定数据构造一个新的日期。时间相对于当前时区进行解释。`Date.UTC()`提供了类似的功能，但是相对于UTC。参数具有以下范围：
- en: '`year`: For 0 ≤ `year` ≤ 99, 1900 is added.'
  id: totrans-3770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`year`：对于0 ≤ `year` ≤ 99，将添加1900。'
- en: '`month`: 0–11 (0 is January, 1 is February, etc.)'
  id: totrans-3771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`month`：0-11（0是一月，1是二月，依此类推）'
- en: '`date`: 1–31'
  id: totrans-3772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`：1-31'
- en: '`hours`: 0–23'
  id: totrans-3773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hours`：0-23'
- en: '`minutes`: 0–59'
  id: totrans-3774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minutes`：0-59'
- en: '`seconds`: 0–59'
  id: totrans-3775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seconds`：0-59'
- en: '`milliseconds`: 0–999'
  id: totrans-3776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`milliseconds`：0-999'
- en: 'Here are some examples:'
  id: totrans-3777
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE926]'
  id: totrans-3778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE926]'
- en: As an aside, JavaScript has inherited the slightly weird convention of interpreting
    0 as January, 1 as February, and so on, from Java.
  id: totrans-3779
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，JavaScript继承了略微奇怪的约定，将0解释为一月，1解释为二月，依此类推，这一点来自Java。
- en: '`new Date(dateTimeStr)`'
  id: totrans-3780
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Date(dateTimeStr)`'
- en: 'This is a date time string that is converted into a number, with which `new
    Date(number)` is invoked. [Date Time Formats](ch20.html#date_time_formats "Date
    Time Formats") explains the date time formats. For example:'
  id: totrans-3781
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将日期时间字符串转换为数字的过程，然后调用`new Date(number)`。[日期时间格式](ch20.html#date_time_formats
    "日期时间格式")解释了日期时间格式。例如：
- en: '[PRE927]'
  id: totrans-3782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE927]'
- en: Illegal date time strings lead to `NaN` being passed to `new Date(number)`.
  id: totrans-3783
  prefs: []
  type: TYPE_NORMAL
  zh: 非法的日期时间字符串导致将`NaN`传递给`new Date(number)`。
- en: '`new Date(timeValue)`'
  id: totrans-3784
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Date(timeValue)`'
- en: 'Creates a date as specified in the number of milliseconds since 1 January 1970
    00:00:00 UTC. For example:'
  id: totrans-3785
  prefs: []
  type: TYPE_NORMAL
  zh: 根据自1970年1月1日00:00:00 UTC以来的毫秒数创建日期。例如：
- en: '[PRE928]'
  id: totrans-3786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE928]'
- en: 'The inverse of this constructor is the `getTime()` method, which returns the
    milliseconds:'
  id: totrans-3787
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数的反函数是`getTime()`方法，它返回毫秒数：
- en: '[PRE929]'
  id: totrans-3788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE929]'
- en: 'You can use `NaN` as an argument, which produces a special instance of `Date`,
    an “invalid date”:'
  id: totrans-3789
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`NaN`作为参数，这将产生`Date`的一个特殊实例，即“无效日期”：
- en: '[PRE930]'
  id: totrans-3790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE930]'
- en: '`new Date()`'
  id: totrans-3791
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Date()`'
- en: Creates an object for the current date and time; it works the same as `new Date(Date.now())`.
  id: totrans-3792
  prefs: []
  type: TYPE_NORMAL
  zh: 创建当前日期和时间的对象；它与`new Date(Date.now())`的作用相同。
- en: Date Constructor Methods
  id: totrans-3793
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期构造函数方法
- en: 'The constructor `Date` has the following methods:'
  id: totrans-3794
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数`Date`有以下方法：
- en: '`Date.now()`'
  id: totrans-3795
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date.now()`'
- en: Returns the current date and time in milliseconds (since 1 January 1970, 00:00:00
    UTC). It produces the same result as `new Date().getTime()`.
  id: totrans-3796
  prefs: []
  type: TYPE_NORMAL
  zh: 以毫秒为单位返回当前日期和时间（自1970年1月1日00:00:00 UTC起）。它产生与`new Date().getTime()`相同的结果。
- en: '`Date.parse(dateTimeString)`'
  id: totrans-3797
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date.parse(dateTimeString)`'
- en: 'Converts `dateTimeString` to milliseconds since 1 January 1970, 00:00:00 UTC.
    [Date Time Formats](ch20.html#date_time_formats "Date Time Formats") explains
    the format of `dateTimeString`. The result can be used to invoke `new Date(number)`.
    Here are some examples:'
  id: totrans-3798
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `dateTimeString` 转换为自 1970 年 1 月 1 日 00:00:00 UTC 以来的毫秒数。[日期时间格式](ch20.html#date_time_formats
    "日期时间格式")解释了 `dateTimeString` 的格式。结果可用于调用 `new Date(number)`。以下是一些示例：
- en: '[PRE931]'
  id: totrans-3799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE931]'
- en: 'If it can’t parse a string, this method returns `NaN`:'
  id: totrans-3800
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法解析字符串，此方法将返回 `NaN`：
- en: '[PRE932]'
  id: totrans-3801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE932]'
- en: '`Date.UTC(year, month, date?, hours?, minutes?, seconds?, milliseconds?)`'
  id: totrans-3802
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date.UTC(year, month, date?, hours?, minutes?, seconds?, milliseconds?)`'
- en: 'Converts the given data to milliseconds since 1 January 1970 00:00:00 UTC.
    It differs from the `Date` constructor with the same arguments in two ways:'
  id: totrans-3803
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定数据转换为自 1970 年 1 月 1 日 00:00:00 UTC 以来的毫秒数。它与具有相同参数的 `Date` 构造函数有两种不同之处：
- en: It returns a number, not a new date object.
  id: totrans-3804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回一个数字，而不是一个新的日期对象。
- en: It interprets the arguments as UTC, rather than as local time.
  id: totrans-3805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将参数解释为世界协调时间，而不是本地时间。
- en: Date Prototype Methods
  id: totrans-3806
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期原型方法
- en: This section covers the methods of `Date.prototype`.
  id: totrans-3807
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了 `Date.prototype` 的方法。
- en: Time Unit Getters and Setters
  id: totrans-3808
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间单位的获取器和设置器
- en: 'Time unit getters and setters are available with the following signatures:'
  id: totrans-3809
  prefs: []
  type: TYPE_NORMAL
  zh: 时间单位的获取器和设置器可使用以下签名：
- en: 'Local time:'
  id: totrans-3810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地时间：
- en: '`Date.prototype.get«Unit»()` returns `Unit`, according to local time.'
  id: totrans-3811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.get«Unit»()` 返回根据本地时间的 `Unit`。'
- en: '`Date.prototype.set«Unit»(number)` sets `Unit`, according to local time.'
  id: totrans-3812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.set«Unit»(number)` 根据本地时间设置 `Unit`。'
- en: 'Universal time:'
  id: totrans-3813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 世界协调时间：
- en: '`Date.prototype.getUTC«Unit»()` returns `Unit`, according to universal time.'
  id: totrans-3814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.getUTC«Unit»()` 返回根据世界协调时间的 `Unit`。'
- en: '`Date.prototype.setUTC«Unit»(number)` sets `Unit`, according to universal time.'
  id: totrans-3815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.setUTC«Unit»(number)` 根据世界协调时间设置 `Unit`。'
- en: '`Unit` is one of the following words:'
  id: totrans-3816
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unit` 是以下单词之一：'
- en: '`FullYear`: Usually four digits'
  id: totrans-3817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FullYear`：通常是四位数'
- en: '`Month`: Month (0–11)'
  id: totrans-3818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Month`：月份（0-11）'
- en: '`Date`: Day of the month (1–31)'
  id: totrans-3819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date`：月份中的某一天（1-31）'
- en: '`Day` (getter only): Day of the week (0–6); 0 is Sunday'
  id: totrans-3820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Day`（仅获取器）：星期几（0-6）；0 代表星期日'
- en: '`Hours`: Hour (0–23)'
  id: totrans-3821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hours`：小时（0-23）'
- en: '`Minutes`: Minutes (0–59)'
  id: totrans-3822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Minutes`：分钟（0-59）'
- en: '`Seconds`: Seconds (0–59)'
  id: totrans-3823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Seconds`：秒（0-59）'
- en: '`Milliseconds`: Milliseconds (0–999)'
  id: totrans-3824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Milliseconds`：毫秒（0-999）'
- en: 'For example:'
  id: totrans-3825
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE933]'
  id: totrans-3826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE933]'
- en: Various Getters and Setters
  id: totrans-3827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 各种获取器和设置器
- en: 'The following methods enable you to get and set the time in milliseconds since
    1 January 1970 and more:'
  id: totrans-3828
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法使您能够获取和设置自 1970 年 1 月 1 日以来的毫秒数以及更多内容：
- en: '`Date.prototype.getTime()` returns the milliseconds since 1 January 1970 00:00:00
    UTC (see [Time Values: Dates as Milliseconds Since 1970-01-01](ch20.html#date_milliseconds
    "Time Values: Dates as Milliseconds Since 1970-01-01")).'
  id: totrans-3829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.getTime()` 返回自 1970 年 1 月 1 日 00:00:00 UTC 以来的毫秒数（参见[时间值：日期作为自
    1970-01-01 以来的毫秒数](ch20.html#date_milliseconds "时间值：日期作为自 1970-01-01 以来的毫秒数")）。'
- en: '`Date.prototype.setTime(timeValue)` sets the date as specified in milliseconds
    since 1 January 1970 00:00:00 UTC (see [Time Values: Dates as Milliseconds Since
    1970-01-01](ch20.html#date_milliseconds "Time Values: Dates as Milliseconds Since
    1970-01-01")).'
  id: totrans-3830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.setTime(timeValue)` 根据自 1970 年 1 月 1 日 00:00:00 UTC 以来的毫秒数设置日期（参见[时间值：日期作为自
    1970-01-01 以来的毫秒数](ch20.html#date_milliseconds "时间值：日期作为自 1970-01-01 以来的毫秒数")）。'
- en: '`Date.prototype.valueOf()` is the same as `getTime()`. This method is called
    when a date is converted to a number.'
  id: totrans-3831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.valueOf()` 与 `getTime()` 相同。当日期转换为数字时，将调用此方法。'
- en: '`Date.prototype.getTimezoneOffset()` returns the difference between local time
    and UTC time in minutes.'
  id: totrans-3832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.getTimezoneOffset()` 返回本地时间和世界协调时间之间的差异（以分钟为单位）。'
- en: 'The unit `Year` has been deprecated in favor of `FullYear`:'
  id: totrans-3833
  prefs: []
  type: TYPE_NORMAL
  zh: '`Year` 单位已被弃用，推荐使用 `FullYear`：'
- en: '`Date.prototype.getYear()` is deprecated; use `getFullYear()` instead.'
  id: totrans-3834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.getYear()` 已被弃用；请改用 `getFullYear()`。'
- en: '`Date.prototype.setYear(number)` is deprecated; use `setFullYear()` instead.'
  id: totrans-3835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.setYear(number)` 已被弃用；请改用 `setFullYear()`。'
- en: Convert a Date to a String
  id: totrans-3836
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将日期转换为字符串
- en: 'Note that conversion to a string is highly implementation-dependent. The following
    date is used to compute the output in the following examples (in Firefox, which
    had the most complete support when this book was written):'
  id: totrans-3837
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，转换为字符串高度依赖于实现。以下日期用于计算以下示例中的输出（在撰写本书时，Firefox 的支持最完整）：
- en: '[PRE934]'
  id: totrans-3838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE934]'
- en: Time (human-readable)
  id: totrans-3839
  prefs: []
  type: TYPE_NORMAL
  zh: 时间（可读）
- en: '`Date.prototype.toTimeString()`:'
  id: totrans-3840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toTimeString()`：'
- en: '[PRE935]'
  id: totrans-3841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE935]'
- en: The time, in the current time zone.
  id: totrans-3842
  prefs: []
  type: TYPE_NORMAL
  zh: 以当前时区的时间显示。
- en: '`Date.prototype.toLocaleTimeString()`:'
  id: totrans-3843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toLocaleTimeString()`：'
- en: '[PRE936]'
  id: totrans-3844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE936]'
- en: The time in a locale-specific format. This method is provided by the ECMAScript
    Internationalization API (see [The ECMAScript Internationalization API](ch30.html#i18n_api
    "The ECMAScript Internationalization API")) and does not make much sense without
    it.
  id: totrans-3845
  prefs: []
  type: TYPE_NORMAL
  zh: 以特定于区域的格式显示的时间。此方法由 ECMAScript 国际化 API（参见[ECMAScript 国际化 API](ch30.html#i18n_api
    "ECMAScript 国际化 API")）提供，并且如果没有它，就没有太多意义。
- en: Date (human-readable)
  id: totrans-3846
  prefs: []
  type: TYPE_NORMAL
  zh: 日期（可读）
- en: '`Date.prototype.toDateString()`:'
  id: totrans-3847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toDateString()`：'
- en: '[PRE937]'
  id: totrans-3848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE937]'
- en: The date.
  id: totrans-3849
  prefs: []
  type: TYPE_NORMAL
  zh: 日期。
- en: '`Date.prototype.toLocaleDateString()`:'
  id: totrans-3850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toLocaleDateString()`：'
- en: '[PRE938]'
  id: totrans-3851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE938]'
- en: The date, in a locale-specific format. This method is provided by the ECMAScript
    Internationalization API (see [The ECMAScript Internationalization API](ch30.html#i18n_api
    "The ECMAScript Internationalization API")) and does not make much sense without
    it.
  id: totrans-3852
  prefs: []
  type: TYPE_NORMAL
  zh: 以特定于区域的格式显示的日期。此方法由 ECMAScript 国际化 API（参见[ECMAScript 国际化 API](ch30.html#i18n_api
    "ECMAScript 国际化 API")）提供，并且如果没有它，就没有太多意义。
- en: Date and time (human-readable)
  id: totrans-3853
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间（可读）
- en: '`Date.prototype.toString()`:'
  id: totrans-3854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toString()`：'
- en: '[PRE939]'
  id: totrans-3855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE939]'
- en: 'Date and time, in the current time zone. For any `Date` instance that has no
    milliseconds (i.e., the second is full), the following expression is true:'
  id: totrans-3856
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间，以当前时区的时间。对于没有毫秒的任何 `Date` 实例（即秒数已满），以下表达式为真：
- en: '[PRE940]'
  id: totrans-3857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE940]'
- en: '`Date.prototype.toLocaleString()`:'
  id: totrans-3858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toLocaleString()`：'
- en: '[PRE941]'
  id: totrans-3859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE941]'
- en: Date and time in a locale-specific format. This method is provided by the ECMAScript
    Internationalization API (see [The ECMAScript Internationalization API](ch30.html#i18n_api
    "The ECMAScript Internationalization API")) and does not make much sense without
    it.
  id: totrans-3860
  prefs: []
  type: TYPE_NORMAL
  zh: 以区域特定格式的日期和时间。此方法由ECMAScript国际化API提供（请参见[ECMAScript国际化API](ch30.html#i18n_api
    "ECMAScript国际化API")），如果没有它，这个方法就没有太多意义。
- en: '`Date.prototype.toUTCString()`:'
  id: totrans-3861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toUTCString()`：'
- en: '[PRE942]'
  id: totrans-3862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE942]'
- en: Date and time, in UTC.
  id: totrans-3863
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间，使用UTC。
- en: '`Date.prototype.toGMTString()`:'
  id: totrans-3864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toGMTString()`：'
- en: Deprecated; use `toUTCString()` instead.
  id: totrans-3865
  prefs: []
  type: TYPE_NORMAL
  zh: 已弃用；请改用`toUTCString()`。
- en: Date and time (machine-readable)
  id: totrans-3866
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间（机器可读）
- en: '`Date.prototype.toISOString()`:'
  id: totrans-3867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toISOString()`：'
- en: '[PRE943]'
  id: totrans-3868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE943]'
- en: All internal properties show up in the returned string. The format is in accordance
    with [Date Time Formats](ch20.html#date_time_formats "Date Time Formats"); the
    time zone is always `Z`.
  id: totrans-3869
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内部属性都显示在返回的字符串中。格式符合[日期时间格式](ch20.html#date_time_formats "日期时间格式")；时区始终为`Z`。
- en: '`Date.prototype.toJSON()`:'
  id: totrans-3870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toJSON()`：'
- en: This method internally calls `toISOString()`. It is used by `JSON.stringify()`
    (see [JSON.stringify(value, replacer?, space?)](ch22.html#JSON.stringify "JSON.stringify(value,
    replacer?, space?)")) to convert date objects to JSON strings.
  id: totrans-3871
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法内部调用`toISOString()`。它被`JSON.stringify()`（参见[JSON.stringify(value, replacer?,
    space?)](ch22.html#JSON.stringify "JSON.stringify(value, replacer?, space?)")）用于将日期对象转换为JSON字符串。
- en: Date Time Formats
  id: totrans-3872
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期时间格式
- en: 'This section describes formats for expressing points in time as strings. There
    are many ways of doing so: indicating just the date, including a time of day,
    omitting the time zone, specifying the time zone, and more. In its support for
    date time formats, ECMAScript 5 closely follows the standard ISO 8601 Extended
    Format. JavaScript engines implement the ECMAScript specification relatively completely,
    but there are still some variations, so you have to be vigilant.'
  id: totrans-3873
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了以字符串形式表示时间点的格式。有许多方法可以这样做：仅指示日期，包括一天中的时间，省略时区，指定时区等。在支持日期时间格式方面，ECMAScript
    5紧密遵循标准ISO 8601扩展格式。JavaScript引擎相对完全地实现了ECMAScript规范，但仍然存在一些变化，因此您必须保持警惕。
- en: 'The longest date time format is:'
  id: totrans-3874
  prefs: []
  type: TYPE_NORMAL
  zh: 最长的日期时间格式是：
- en: '[PRE944]'
  id: totrans-3875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE944]'
- en: 'Each part stands for several decimal digits of date time data. For example,
    `YYYY` means that the format starts with a four-digit year. The following subsections
    explain what each part means. Formats are relevant for the following methods:'
  id: totrans-3876
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分代表日期时间数据的几个十进制数字。例如，`YYYY`表示格式以四位数年份开头。以下各小节解释了每个部分的含义。这些格式与以下方法相关：
- en: '`Date.parse()` can parse the formats.'
  id: totrans-3877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.parse()` 可以解析这些格式。'
- en: '`new Date()` can parse the formats.'
  id: totrans-3878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new Date()`可以解析这些格式。'
- en: '`Date.prototype.toISOString()` creates a string in the aforementioned “full”
    format:'
  id: totrans-3879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toISOString()`创建了上述“完整”格式的字符串：'
- en: '[PRE945]'
  id: totrans-3880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE945]'
- en: Date Formats (No Time)
  id: totrans-3881
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期格式（无时间）
- en: 'The following date formats are available:'
  id: totrans-3882
  prefs: []
  type: TYPE_NORMAL
  zh: 以下日期格式可用：
- en: '[PRE946]'
  id: totrans-3883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE946]'
- en: 'They include the following parts:'
  id: totrans-3884
  prefs: []
  type: TYPE_NORMAL
  zh: 它们包括以下部分：
- en: '`YYYY` refers to year (Gregorian calendar).'
  id: totrans-3885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YYYY` 指的是年份（公历）。'
- en: '`MM` refers to month, from 01 to 12.'
  id: totrans-3886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MM`指的是月份，从01到12。'
- en: '`DD` refers to day, from 01 to 31.'
  id: totrans-3887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DD` 指的是日期，从01到31。'
- en: 'For example:'
  id: totrans-3888
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE947]'
  id: totrans-3889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE947]'
- en: Time Formats (No Date)
  id: totrans-3890
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间格式（无日期）
- en: 'The following time formats are available. As you can see, time zone information
    `Z` is optional:'
  id: totrans-3891
  prefs: []
  type: TYPE_NORMAL
  zh: 以下时间格式可用。如您所见，时区信息`Z`是可选的：
- en: '[PRE948]'
  id: totrans-3892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE948]'
- en: 'They include the following parts:'
  id: totrans-3893
  prefs: []
  type: TYPE_NORMAL
  zh: 它们包括以下部分：
- en: '`T` is the prefix of the time part of a format (a literal `T`, not a digit).'
  id: totrans-3894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`是格式时间部分的前缀（字面上的`T`，而不是数字）。'
- en: '`HH` refers to hour, from 00 to 23\. You can use 24 as a value for `HH` (which
    refers to hour 00 of the following day), but then all remaining parts must be
    0.'
  id: totrans-3895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HH`指的是小时，从00到23。您可以使用24作为`HH`的值（指的是第二天的00小时），但是接下来的所有部分都必须为0。'
- en: '`mm` indicates the minute, from 00 to 59.'
  id: totrans-3896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mm` 表示分钟，从00到59。'
- en: '`ss` indicates the second, from 00 to 59.'
  id: totrans-3897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ss` 表示秒，从00到59。'
- en: '`sss` indicates the millisecond, from 000 to 999.'
  id: totrans-3898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sss` 表示毫秒，从000到999。'
- en: '`Z` refers to time zone, either of the following two:'
  id: totrans-3899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Z`指的是时区，以下两者之一：'
- en: “`Z`” for UTC
  id: totrans-3900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “`Z`”表示UTC
- en: “`+`” or “`-`” followed by a time “`hh:mm`”
  id: totrans-3901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “`+`”或“`-`”后跟时间“`hh:mm`”
- en: 'Some JavaScript engines allow you to specify only a time (others require a
    date):'
  id: totrans-3902
  prefs: []
  type: TYPE_NORMAL
  zh: 一些JavaScript引擎允许您仅指定时间（其他需要日期）：
- en: '[PRE949]'
  id: totrans-3903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE949]'
- en: Date Time Formats
  id: totrans-3904
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期时间格式
- en: 'Date formats and time formats can also be combined. In date time formats, you
    can use a date or a date and a time (or, in some engines, just the time). For
    example:'
  id: totrans-3905
  prefs: []
  type: TYPE_NORMAL
  zh: 日期格式和时间格式也可以结合使用。在日期时间格式中，您可以使用日期或日期和时间（或在某些引擎中仅使用时间）。例如：
- en: '[PRE950]'
  id: totrans-3906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE950]'
- en: 'Time Values: Dates as Milliseconds Since 1970-01-01'
  id: totrans-3907
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间值：自1970-01-01以来的毫秒数
- en: What the date API calls `time` is called a *time value* by the ECMAScript specification.
    It is a primitive number that encodes a date as milliseconds since 1 January 1970
    00:00:00 UTC. Each date object stores its state as a time value, in the internal
    property `[[PrimitiveValue]]` (the same property that instances of the wrapper
    constructors `Boolean`, `Number`, and `String` use to store their wrapped primitive
    values).
  id: totrans-3908
  prefs: []
  type: TYPE_NORMAL
  zh: 日期API称之为`time`的东西在ECMAScript规范中被称为*时间值*。它是一个原始数字，以自1970年1月1日00:00:00 UTC以来的毫秒数编码日期。每个日期对象都将其状态存储为时间值，在内部属性`[[PrimitiveValue]]`中（与包装构造函数`Boolean`，`Number`和`String`的实例用于存储其包装的原始值的相同属性）。
- en: Warning
  id: totrans-3909
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Leap seconds are ignored in time values.
  id: totrans-3910
  prefs: []
  type: TYPE_NORMAL
  zh: 时间值中忽略了闰秒。
- en: 'The following methods work with time values:'
  id: totrans-3911
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法适用于时间值：
- en: '`new Date(timeValue)` uses a time value to create a date.'
  id: totrans-3912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new Date(timeValue)` 使用时间值创建日期。'
- en: '`Date.parse(dateTimeString)` parses a string with a date time string and returns
    a time value.'
  id: totrans-3913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.parse(dateTimeString)`解析带有日期时间字符串的字符串并返回时间值。'
- en: '`Date.now()` returns the current date time as a time value.'
  id: totrans-3914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.now()`返回当前日期时间作为时间值。'
- en: '`Date.UTC(year, month, date?, hours?, minutes?, seconds?, milliseconds?)` interprets
    the parameters relative to UTC and returns a time value.'
  id: totrans-3915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.UTC(year, month, date?, hours?, minutes?, seconds?, milliseconds?)` 解释参数相对于UTC并返回时间值。'
- en: '`Date.prototype.getTime()` returns the time value stored in the receiver.'
  id: totrans-3916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.getTime()` 返回接收器中存储的时间值。'
- en: '`Date.prototype.setTime(timeValue)` changes the date as specified via a time
    value.'
  id: totrans-3917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.setTime(timeValue)`根据指定的时间值更改日期。'
- en: '`Date.prototype.valueOf()` returns the time value stored in the receiver. This
    method determines how dates are converted to primitives, as explained in the next
    subsection.'
  id: totrans-3918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.valueOf()`返回接收者中存储的时间值。该方法确定了如何将日期转换为原始值，如下一小节所述。'
- en: The range of JavaScript integers (53 bits plus a sign) is large enough that
    a time span can be represented that starts at approximately 285,616 years before
    1970 and ends at approximately 285,616 years after 1970.
  id: totrans-3919
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript整数的范围（53位加上一个符号）足够大，可以表示从1970年前约285,616年开始到1970年后约285,616年结束的时间跨度。
- en: 'Here are a few examples of converting dates to time values:'
  id: totrans-3920
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将日期转换为时间值的几个示例：
- en: '[PRE951]'
  id: totrans-3921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE951]'
- en: 'The `Date` constructor enables you to convert times values to dates:'
  id: totrans-3922
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`构造函数使您能够将时间值转换为日期：'
- en: '[PRE952]'
  id: totrans-3923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE952]'
- en: Converting a Date to a Number
  id: totrans-3924
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将日期转换为数字
- en: 'A date is converted to a number via `Date.prototype.valueOf()`, which returns
    a time value. This allows you to compare dates:'
  id: totrans-3925
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Date.prototype.valueOf()`将日期转换为数字，返回一个时间值。这使您能够比较日期：
- en: '[PRE953]'
  id: totrans-3926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE953]'
- en: 'You can also perform arithmetic, but beware that leap seconds are ignored:'
  id: totrans-3927
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以进行算术运算，但要注意闰秒被忽略：
- en: '[PRE954]'
  id: totrans-3928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE954]'
- en: Warning
  id: totrans-3929
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: 'Using the plus operator (`+`) to add a date to another date or a number results
    in a string, because the default for the conversion to primitive is to convert
    dates to strings (consult [The Plus Operator (+)](ch09.html#plus_operator "The
    Plus Operator (+)") for an explanation of how the plus operator works):'
  id: totrans-3930
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加号运算符（`+`）将日期加到另一个日期或数字会得到一个字符串，因为将日期转换为原始值的默认方式是将日期转换为字符串（请参阅[加号运算符（+）](ch09.html#plus_operator
    "The Plus Operator (+)")了解加号运算符的工作原理）：
- en: '[PRE955]'
  id: totrans-3931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE955]'
- en: Chapter 21. Math
  id: totrans-3932
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第21章。数学
- en: The `Math` object is used as a namespace for several math functions. This chapter
    provides an overview.
  id: totrans-3933
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`对象用作多个数学函数的命名空间。本章提供了一个概述。'
- en: Math Properties
  id: totrans-3934
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学属性
- en: 'The properties of `Math` are as follows:'
  id: totrans-3935
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`的属性如下：'
- en: '`Math.E`'
  id: totrans-3936
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.E`'
- en: Euler’s constant (e)
  id: totrans-3937
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉常数（e）
- en: '`Math.LN2`'
  id: totrans-3938
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.LN2`'
- en: Natural logarithm of 2
  id: totrans-3939
  prefs: []
  type: TYPE_NORMAL
  zh: 2的自然对数
- en: '`Math.LN10`'
  id: totrans-3940
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.LN10`'
- en: Natural logarithm of 10
  id: totrans-3941
  prefs: []
  type: TYPE_NORMAL
  zh: 10的自然对数
- en: '`Math.LOG2E`'
  id: totrans-3942
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.LOG2E`'
- en: Base 2 logarithm of e
  id: totrans-3943
  prefs: []
  type: TYPE_NORMAL
  zh: e的底数2对数
- en: '`Math.LOG10E`'
  id: totrans-3944
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.LOG10E`'
- en: Base 10 logarithm of e
  id: totrans-3945
  prefs: []
  type: TYPE_NORMAL
  zh: e的十进制对数
- en: '`Math.PI`'
  id: totrans-3946
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.PI`'
- en: The ratio of the circumference of a circle to its diameter (3.14159 ...), π
  id: totrans-3947
  prefs: []
  type: TYPE_NORMAL
  zh: 圆的周长与直径的比值（3.14159 ...），π
- en: '`Math.SQRT1_2`'
  id: totrans-3948
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.SQRT1_2`'
- en: The square root of one-half, ![](inleq_2101.png)
  id: totrans-3949
  prefs: []
  type: TYPE_NORMAL
  zh: 一半的平方根，![](inleq_2101.png)
- en: '`Math.SQRT2`'
  id: totrans-3950
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.SQRT2`'
- en: The square root of two, ![](inleq_2102.png)
  id: totrans-3951
  prefs: []
  type: TYPE_NORMAL
  zh: 二的平方根，![](inleq_2102.png)
- en: Numerical Functions
  id: totrans-3952
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值函数
- en: 'The numerical functions of `Math` include the following:'
  id: totrans-3953
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`的数值函数包括以下内容：'
- en: '`Math.abs(x)`'
  id: totrans-3954
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.abs(x)`'
- en: Returns the absolute value of `x`.
  id: totrans-3955
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`x`的绝对值。
- en: '`Math.ceil(x)`'
  id: totrans-3956
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.ceil(x)`'
- en: 'Returns the smallest integer ≥ `x`:'
  id: totrans-3957
  prefs: []
  type: TYPE_NORMAL
  zh: 返回大于等于`x`的最小整数：
- en: '[PRE956]'
  id: totrans-3958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE956]'
- en: For more on converting floating-point numbers to integers, see [Converting to
    Integer](ch11.html#converting_to_integer "Converting to Integer").
  id: totrans-3959
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将浮点数转换为整数的更多信息，请参阅[转换为整数](ch11.html#converting_to_integer "Converting to Integer")。
- en: '`Math.exp(x)`'
  id: totrans-3960
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.exp(x)`'
- en: Returns e^x where e is Euler’s constant (`Math.E`). This is the inverse of `Math.log()`.
  id: totrans-3961
  prefs: []
  type: TYPE_NORMAL
  zh: 返回e^x，其中e是欧拉常数（`Math.E`）。这是`Math.log()`的反函数。
- en: '`Math.floor(x)`'
  id: totrans-3962
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.floor(x)`'
- en: 'Returns the largest integer ≤ `x`:'
  id: totrans-3963
  prefs: []
  type: TYPE_NORMAL
  zh: 返回小于等于`x`的最大整数：
- en: '[PRE957]'
  id: totrans-3964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE957]'
- en: For more on converting floating-point numbers to integers, see [Converting to
    Integer](ch11.html#converting_to_integer "Converting to Integer").
  id: totrans-3965
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将浮点数转换为整数的更多信息，请参阅[转换为整数](ch11.html#converting_to_integer "Converting to Integer")。
- en: '`Math.log(x)`'
  id: totrans-3966
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.log(x)`'
- en: Returns the natural (base is Euler’s constant) logarithm ln(`x`) of `x`. This
    is the inverse of `Math.exp()`.
  id: totrans-3967
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`x`的自然（以e为底）对数ln(`x`)。这是`Math.exp()`的反函数。
- en: '`Math.pow(x, y)`'
  id: totrans-3968
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.pow(x, y)`'
- en: 'Returns x^y, `x` raised to the power of `y`:'
  id: totrans-3969
  prefs: []
  type: TYPE_NORMAL
  zh: 返回x^y，`x`的`y`次幂：
- en: '[PRE958]'
  id: totrans-3970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE958]'
- en: '`Math.round(x)`'
  id: totrans-3971
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.round(x)`'
- en: 'Returns `x` rounded to the nearest integer (the greater one if it is between
    two integers):'
  id: totrans-3972
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`x`四舍五入到最接近的整数（如果在两个整数之间，则为较大的整数）：
- en: '[PRE959]'
  id: totrans-3973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE959]'
- en: For more on converting floating-point numbers to integers, see [Converting to
    Integer](ch11.html#converting_to_integer "Converting to Integer").
  id: totrans-3974
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将浮点数转换为整数的更多信息，请参阅[转换为整数](ch11.html#converting_to_integer "Converting to Integer")。
- en: '`Math.sqrt(x)`'
  id: totrans-3975
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.sqrt(x)`'
- en: 'Returns ![](inleq_2103.png), the square root of `x`:'
  id: totrans-3976
  prefs: []
  type: TYPE_NORMAL
  zh: 返回![](inleq_2103.png)，`x`的平方根：
- en: '[PRE960]'
  id: totrans-3977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE960]'
- en: Trigonometric Functions
  id: totrans-3978
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三角函数
- en: 'The trigonometric methods accept and return angles as radians. The following
    functions show you how you could implement conversions, should you need to:'
  id: totrans-3979
  prefs: []
  type: TYPE_NORMAL
  zh: 三角函数方法接受弧度作为角度并返回。以下函数向您展示了如何实现转换，如果需要的话：
- en: 'From degrees to radians:'
  id: totrans-3980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从度到弧度：
- en: '[PRE961]'
  id: totrans-3981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE961]'
- en: 'Here is the interaction:'
  id: totrans-3982
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE962]'
  id: totrans-3983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE962]'
- en: 'From radians to degrees:'
  id: totrans-3984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从弧度到度：
- en: '[PRE963]'
  id: totrans-3985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE963]'
- en: 'Here is the interaction:'
  id: totrans-3986
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE964]'
  id: totrans-3987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE964]'
- en: 'The trigonometric methods are as follows:'
  id: totrans-3988
  prefs: []
  type: TYPE_NORMAL
  zh: 三角函数方法如下：
- en: '`Math.acos(x)`'
  id: totrans-3989
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.acos(x)`'
- en: Returns the arc cosine of `x`.
  id: totrans-3990
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`x`的反余弦值。
- en: '`Math.asin(x)`'
  id: totrans-3991
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.asin(x)`'
- en: Returns the arc sine of `x`.
  id: totrans-3992
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`x`的反正弦值。
- en: '`Math.atan(x)`'
  id: totrans-3993
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.atan(x)`'
- en: Returns the arc tangent of `x`.
  id: totrans-3994
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`x`的反正切值。
- en: '`Math.atan2(y, x)`'
  id: totrans-3995
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.atan2(y, x)`'
- en: Returns the arc tangent of the quotient ![](inleq_2104.png).
  id: totrans-3996
  prefs: []
  type: TYPE_NORMAL
  zh: 返回商的反正切值![](inleq_2104.png)。
- en: '`Math.cos(x)`'
  id: totrans-3997
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.cos(x)`'
- en: Returns the cosine of `x`.
  id: totrans-3998
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`x`的余弦值。
- en: '`Math.sin(x)`'
  id: totrans-3999
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.sin(x)`'
- en: Returns the sine of `x`.
  id: totrans-4000
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`x`的正弦值。
- en: '`Math.tan(x)`'
  id: totrans-4001
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.tan(x)`'
- en: Returns the tangent of `x`.
  id: totrans-4002
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`x`的正切值。
- en: Other Functions
  id: totrans-4003
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他函数
- en: 'Following are the remaining `Math` functions:'
  id: totrans-4004
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是剩余的`Math`函数：
- en: '`min(x1?, x2?, ...)`'
  id: totrans-4005
  prefs: []
  type: TYPE_NORMAL
  zh: '`min(x1?, x2?, ...)`'
- en: 'Returns the smallest number among the parameters:'
  id: totrans-4006
  prefs: []
  type: TYPE_NORMAL
  zh: 返回参数中的最小数：
- en: '[PRE965]'
  id: totrans-4007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE965]'
- en: 'Use it on arrays via `apply()` (see [func.apply(thisValue, argArray)](ch15.html#functional_apply
    "func.apply(thisValue, argArray)")):'
  id: totrans-4008
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`apply()`在数组上使用它（参见[func.apply(thisValue, argArray)](ch15.html#functional_apply
    "func.apply(thisValue, argArray)")）：
- en: '[PRE966]'
  id: totrans-4009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE966]'
- en: '`max(x1?, x2?, ...)`'
  id: totrans-4010
  prefs: []
  type: TYPE_NORMAL
  zh: '`max(x1?, x2?, ...)`'
- en: 'Returns the largest number among the parameters:'
  id: totrans-4011
  prefs: []
  type: TYPE_NORMAL
  zh: 返回参数中的最大数：
- en: '[PRE967]'
  id: totrans-4012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE967]'
- en: 'Use it on arrays via `apply()` (see [func.apply(thisValue, argArray)](ch15.html#functional_apply
    "func.apply(thisValue, argArray)")):'
  id: totrans-4013
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`apply()`在数组上使用它（参见[func.apply(thisValue, argArray)](ch15.html#functional_apply
    "func.apply(thisValue, argArray)")）：
- en: '[PRE968]'
  id: totrans-4014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE968]'
- en: '`Math.random()`'
  id: totrans-4015
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.random()`'
- en: 'Returns a pseudorandom number `r`, 0 ≤ `r` < 1. The following function uses
    `Math.random()` to compute a random integer:'
  id: totrans-4016
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: '[PRE969]'
  id: totrans-4017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE969]'
- en: Chapter 22. JSON
  id: totrans-4018
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: JSON (JavaScript Object Notation) is a plain-text format for data storage. It
    has become quite popular as a data interchange format for web services, for configuration
    files, and more. ECMAScript 5 has an API for converting from a string in JSON
    format to a JavaScript value (*parsing*) and vice versa (*stringifying*).
  id: totrans-4019
  prefs: []
  type: TYPE_NORMAL
  zh: Douglas Crockford创建了一张JSON名片，正面有一个徽标（参见[图22-1](ch22.html#figjson_business_card_front_25
    "图22-1. JSON名片的正面显示了一个徽标（来源：Eric Miraglia）。")），背面有完整的语法（参见[图22-2](ch22.html#figjson_business_card_back_25
    "图22-2. JSON名片的背面包含完整的语法（来源：Eric Miraglia）。")）。这使得JSON的简单性在视觉上显而易见。
- en: Background
  id: totrans-4020
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: This section explains what JSON is and how it was created.
  id: totrans-4021
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Crockford希望JSON有一个名字叫*JavaScript标记语言*，但是JSML的首字母缩写已经被[JSpeech标记语言](http://www.w3.org/TR/jsml/)使用了。
- en: Data Format
  id: totrans-4022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: 'JSON stores data as plain text. Its grammar is a subset of the grammar of JavaScript
    expressions. For example:'
  id: totrans-4023
  prefs: []
  type: TYPE_NORMAL
  zh: '`[` `]`'
- en: '[PRE970]'
  id: totrans-4024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE970]'
- en: 'JSON uses the following constructs from JavaScript expressions:'
  id: totrans-4025
  prefs: []
  type: TYPE_NORMAL
  zh: 整数
- en: Compound
  id: totrans-4026
  prefs: []
  type: TYPE_NORMAL
  zh: 字符 字符
- en: Objects of JSON data and arrays of JSON data
  id: totrans-4027
  prefs: []
  type: TYPE_NORMAL
  zh: JSON数据的对象和JSON数据的数组
- en: Atomic
  id: totrans-4028
  prefs: []
  type: TYPE_NORMAL
  zh: '![JSON名片的背面包含完整的语法（来源：Eric Miraglia）。](images/spjs_2602.png.jpg)图22-2. JSON名片的背面包含完整的语法（来源：[Eric
    Miraglia](http://www.flickr.com/photos/equanimity/3763158824/)）。'
- en: Strings, numbers, booleans, and `null`
  id: totrans-4029
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `}`'
- en: 'It adheres to these rules:'
  id: totrans-4030
  prefs: []
  type: TYPE_NORMAL
  zh: 它遵循以下规则：
- en: Strings must always be double-quoted; string literals such as `'mystr'` are
    illegal.
  id: totrans-4031
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串必须始终用双引号括起来；例如，像`'mystr'`这样的字符串字面量是非法的。
- en: Property keys must be double-quoted.
  id: totrans-4032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数
- en: History
  id: totrans-4033
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 历史
- en: 'Douglas Crockford discovered JSON in 2001\. He gave it a name and put up a
    specification at [http://json.org](http://json.org):'
  id: totrans-4034
  prefs: []
  type: TYPE_NORMAL
  zh: '`-` 数字'
- en: I discovered JSON. I do not claim to have invented JSON, because it already
    existed in nature. What I did was I found it, I named it, I described how it was
    useful. I don’t claim to be the first person to have discovered it; I know that
    there are other people who discovered it at least a year before I did. The earliest
    occurrence I’ve found was, there was someone at Netscape who was using JavaScript
    array literals for doing data communication as early as 1996, which was at least
    five years before I stumbled onto the idea.
  id: totrans-4035
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 复合
- en: Initially, Crockford wanted JSON to have the name *JavaScript Markup Language*,
    but the acronym JSML was already taken by the [JSpeech Markup Language](http://www.w3.org/TR/jsml/).
  id: totrans-4036
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: The JSON specification has been translated to many human languages, and there
    are now libraries for many programming languages that support parsing and generating
    JSON.
  id: totrans-4037
  prefs: []
  type: TYPE_NORMAL
  zh: JSON规范已经被翻译成许多人类语言，现在有许多编程语言的库支持解析和生成JSON。
- en: Grammar
  id: totrans-4038
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`\" \\ \/ \b \f \n \r \t`'
- en: 'Douglas Crockford created a JSON business card with a logo on the front (see
    [Figure 22-1](ch22.html#figjson_business_card_front_25 "Figure 22-1. The front
    side of the JSON business card shows a logo (source: Eric Miraglia).")) and the
    full grammar on the back (see [Figure 22-2](ch22.html#figjson_business_card_back_25
    "Figure 22-2. The back side of the JSON business card contains the complete grammar
    (source: Eric Miraglia).")). That makes it visually obvious how positively simple
    JSON is.'
  id: totrans-4039
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`'
- en: '![The front side of the JSON business card shows a logo (source: Eric Miraglia).](images/spjs_2601.png.jpg)Figure 22-1. The
    front side of the JSON business card shows a logo (source: [Eric Miraglia](http://www.flickr.com/photos/equanimity/3762360637/)).![The
    back side of the JSON business card contains the complete grammar (source: Eric
    Miraglia).](images/spjs_2602.png.jpg)Figure 22-2. The back side of the JSON business
    card contains the complete grammar (source: [Eric Miraglia](http://www.flickr.com/photos/equanimity/3763158824/)).'
  id: totrans-4040
  prefs: []
  type: TYPE_NORMAL
  zh: '![JSON名片的正面显示了一个徽标（来源：Eric Miraglia）。](images/spjs_2601.png.jpg)图22-1. JSON名片的正面显示了一个徽标（来源：[Eric
    Miraglia](http://www.flickr.com/photos/equanimity/3762360637/)）。'
- en: 'The grammar can be transcribed as follows:'
  id: totrans-4041
  prefs: []
  type: TYPE_NORMAL
  zh: 数据格式
- en: object
  id: totrans-4042
  prefs: []
  type: TYPE_NORMAL
  zh: 值 `,` 元素
- en: '`{` `}`'
  id: totrans-4043
  prefs: []
  type: TYPE_NORMAL
  zh: 整数 指数
- en: '`{` members `}`'
  id: totrans-4044
  prefs: []
  type: TYPE_NORMAL
  zh: 数字1-9 数字
- en: members
  id: totrans-4045
  prefs: []
  type: TYPE_NORMAL
  zh: 数组
- en: pair
  id: totrans-4046
  prefs: []
  type: TYPE_NORMAL
  zh: 数字
- en: pair `,` members
  id: totrans-4047
  prefs: []
  type: TYPE_NORMAL
  zh: 值
- en: pair
  id: totrans-4048
  prefs: []
  type: TYPE_NORMAL
  zh: 对
- en: string `:` value
  id: totrans-4049
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 `:` 值
- en: array
  id: totrans-4050
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `,` 成员
- en: '`[` `]`'
  id: totrans-4051
  prefs: []
  type: TYPE_NORMAL
  zh: 除了"或\或控制字符之外的任何Unicode字符
- en: '`[` elements `]`'
  id: totrans-4052
  prefs: []
  type: TYPE_NORMAL
  zh: '`[` 元素 `]`'
- en: elements
  id: totrans-4053
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量`JSON`用作生成和解析带有JSON数据的字符串的函数的命名空间。
- en: value
  id: totrans-4054
  prefs: []
  type: TYPE_NORMAL
  zh: 数字
- en: value `,` elements
  id: totrans-4055
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: value
  id: totrans-4056
  prefs: []
  type: TYPE_NORMAL
  zh: 值
- en: string
  id: totrans-4057
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: number
  id: totrans-4058
  prefs: []
  type: TYPE_NORMAL
  zh: '`.` 数字'
- en: object
  id: totrans-4059
  prefs: []
  type: TYPE_NORMAL
  zh: 对
- en: array
  id: totrans-4060
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串、数字、布尔值和`null`
- en: '`true`'
  id: totrans-4061
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数`replacer`用于在对其进行字符串化之前更改`value`。它可以是：
- en: '`false`'
  id: totrans-4062
  prefs: []
  type: TYPE_NORMAL
  zh: 成员
- en: '`null`'
  id: totrans-4063
  prefs: []
  type: TYPE_NORMAL
  zh: JSON将数据存储为纯文本。它的语法是JavaScript表达式语法的子集。例如：
- en: string
  id: totrans-4064
  prefs: []
  type: TYPE_NORMAL
  zh: 整数
- en: '`""`'
  id: totrans-4065
  prefs: []
  type: TYPE_NORMAL
  zh: JSON（JavaScript对象表示）是一种用于数据存储的纯文本格式。它已经成为Web服务、配置文件等数据交换格式的一种流行选择。ECMAScript
    5有一个API，用于将JSON格式的字符串转换为JavaScript值（*解析*）以及反之（*字符串化*）。
- en: '`"` chars `"`'
  id: totrans-4066
  prefs: []
  type: TYPE_NORMAL
  zh: 元素
- en: chars
  id: totrans-4067
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`'
- en: char
  id: totrans-4068
  prefs: []
  type: TYPE_NORMAL
  zh: Douglas Crockford于2001年发现了JSON。他给它起了个名字，并在[http://json.org](http://json.org)上发布了一个规范：
- en: char chars
  id: totrans-4069
  prefs: []
  type: TYPE_NORMAL
  zh: 语法可以转录如下：
- en: char
  id: totrans-4070
  prefs: []
  type: TYPE_NORMAL
  zh: 对象
- en: any-Unicode-character-except-"-or-\-or-control-character
  id: totrans-4071
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个伪随机数`r`，0 ≤ `r` < 1。以下函数使用`Math.random()`来计算一个随机整数：
- en: '`\" \\ \/ \b \f \n \r \t`'
  id: totrans-4072
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` 成员 `}`'
- en: '`\u` four-hex-digits'
  id: totrans-4073
  prefs: []
  type: TYPE_NORMAL
  zh: '`\u` 四个十六进制数字'
- en: number
  id: totrans-4074
  prefs: []
  type: TYPE_NORMAL
  zh: e
- en: int
  id: totrans-4075
  prefs: []
  type: TYPE_NORMAL
  zh: 原子
- en: int frac
  id: totrans-4076
  prefs: []
  type: TYPE_NORMAL
  zh: JSON使用JavaScript表达式中的以下构造：
- en: int exp
  id: totrans-4077
  prefs: []
  type: TYPE_NORMAL
  zh: 整数 分数
- en: int frac exp
  id: totrans-4078
  prefs: []
  type: TYPE_NORMAL
  zh: '`""`'
- en: int
  id: totrans-4079
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.stringify(value, replacer?, space?)`将JavaScript值`value`转换为JSON格式的字符串。它有两个可选参数。'
- en: digit
  id: totrans-4080
  prefs: []
  type: TYPE_NORMAL
  zh: 数字
- en: digit1-9 digits
  id: totrans-4081
  prefs: []
  type: TYPE_NORMAL
  zh: '`"` 字符 `"`'
- en: '`-` digit'
  id: totrans-4082
  prefs: []
  type: TYPE_NORMAL
  zh: '`-` 数字1-9 数字'
- en: '`-` digit1-9 digits'
  id: totrans-4083
  prefs: []
  type: TYPE_NORMAL
  zh: 属性键必须用双引号括起来。
- en: frac
  id: totrans-4084
  prefs: []
  type: TYPE_NORMAL
  zh: 分数
- en: '`.` digits'
  id: totrans-4085
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: exp
  id: totrans-4086
  prefs: []
  type: TYPE_NORMAL
  zh: JSON.stringify(value, replacer?, space?)
- en: e digits
  id: totrans-4087
  prefs: []
  type: TYPE_NORMAL
  zh: e 个数字
- en: digits
  id: totrans-4088
  prefs: []
  type: TYPE_NORMAL
  zh: 数字
- en: digit
  id: totrans-4089
  prefs: []
  type: TYPE_NORMAL
  zh: 数字
- en: digit digits
  id: totrans-4090
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 数字
- en: e
  id: totrans-4091
  prefs: []
  type: TYPE_NORMAL
  zh: 第22章 JSON
- en: '`e e+ e-`'
  id: totrans-4092
  prefs: []
  type: TYPE_NORMAL
  zh: e e+ e-
- en: '`E E+ E-`'
  id: totrans-4093
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了JSON是什么以及它是如何创建的。
- en: The global variable `JSON` serves as a namespace for functions that produce
    and parse strings with JSON data.
  id: totrans-4094
  prefs: []
  type: TYPE_NORMAL
  zh: '`false`'
- en: JSON.stringify(value, replacer?, space?)
  id: totrans-4095
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我发现了JSON。我不主张发明JSON，因为它已经存在于自然界中。我所做的是发现它，我给它起了名字，我描述了它的有用之处。我不主张自己是第一个发现它的人；我知道至少有其他人在我之前至少一年发现了它。我发现的最早的情况是，Netscape有人在至少1996年就开始使用JavaScript数组文字进行数据通信，而这至少比我想到这个想法早了五年。
- en: '`JSON.stringify(value, replacer?, space?)` translates the JavaScript value
    `value` to a string in JSON format. It has two optional arguments.'
  id: totrans-4096
  prefs: []
  type: TYPE_NORMAL
  zh: 语法
- en: 'The optional parameter `replacer` is used to change the `value` before stringifying
    it. It can be:'
  id: totrans-4097
  prefs: []
  type: TYPE_NORMAL
  zh: 整数 分数 指数
- en: 'A *node visitor* (see [Transforming Data via Node Visitors](ch22.html#node_visitors
    "Transforming Data via Node Visitors")) that transforms the tree of values before
    it is stringified. For example:'
  id: totrans-4098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*节点访问者*（参见[通过节点访问者转换数据](ch22.html#node_visitors "通过节点访问者转换数据")）在将其字符串化之前转换值树。例如：
- en: '[PRE971]'
  id: totrans-4099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE971]'
- en: 'Using the replacer:'
  id: totrans-4100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用replacer：
- en: '[PRE972]'
  id: totrans-4101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE972]'
- en: 'A whitelist of property keys that hides all properties (of nonarray objects)
    whose keys are not in the list. For example:'
  id: totrans-4102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏所有不在列表中的属性键（非数组对象的属性）的属性白名单。例如：
- en: '[PRE973]'
  id: totrans-4103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE973]'
- en: 'The whitelist has no effect on arrays:'
  id: totrans-4104
  prefs: []
  type: TYPE_NORMAL
  zh: 白名单对数组没有影响：
- en: '[PRE974]'
  id: totrans-4105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE974]'
- en: 'The optional parameter `space` influences the formatting of the output. Without
    this parameter, the result of `stringify` is a single line of text:'
  id: totrans-4106
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数`space`影响输出的格式。如果没有这个参数，`stringify`的结果将是单行文本：
- en: '[PRE975]'
  id: totrans-4107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE975]'
- en: 'With it, newlines are inserted and each level of nesting via arrays and objects
    increases indentation. There are two ways to specify how to indent:'
  id: totrans-4108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它，可以插入换行符，并且通过数组和对象的每个嵌套级别增加缩进。有两种指定缩进方式的方法：
- en: A number
  id: totrans-4109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字
- en: 'Multiply the number by the level of indentation and indent the line by as many
    spaces. Numbers smaller than 0 are interpreted as 0; numbers larger than 10 are
    interpreted as 10:'
  id: totrans-4110
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字乘以缩进级别并将行缩进为相同数量的空格。小于0的数字被解释为0；大于10的数字被解释为10：
- en: '[PRE976]'
  id: totrans-4111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE976]'
- en: A string
  id: totrans-4112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串
- en: 'To indent, repeat the given string once for each level of indentation. Only
    the first 10 characters of the string are used:'
  id: totrans-4113
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩进，重复给定的字符串以表示每个缩进级别。只使用字符串的前10个字符：
- en: '[PRE977]'
  id: totrans-4114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE977]'
- en: 'Therefore, the following invocation of `JSON.stringify()` prints an object
    as a nicely formatted tree:'
  id: totrans-4115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下对`JSON.stringify()`的调用会将对象打印为一个格式良好的树：
- en: '[PRE978]'
  id: totrans-4116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE978]'
- en: Data Ignored by JSON.stringify()
  id: totrans-4117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON.stringify()忽略的数据
- en: 'In objects, `JSON.stringify()` only considers enumerable own properties (see
    [Property Attributes and Property Descriptors](ch17_split_000.html#property_attributes
    "Property Attributes and Property Descriptors")). The following example demonstrates
    the nonenumerable own property `obj.foo` being ignored:'
  id: totrans-4118
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象中，`JSON.stringify()`只考虑可枚举的自有属性（参见[属性特性和属性描述符](ch17_split_000.html#property_attributes
    "属性特性和属性描述符")）。以下示例演示了忽略了不可枚举的自有属性`obj.foo`：
- en: '[PRE979]'
  id: totrans-4119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE979]'
- en: 'How `JSON.stringify()` handles values that are not supported by JSON (such
    as functions and `undefined`) depends on where it encounters them. An unsupported
    value itself leads to `stringify()` returning `undefined` instead of a string:'
  id: totrans-4120
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.stringify()`处理不受JSON支持的值（例如函数和`undefined`）的方式取决于它们遇到的位置。不支持的值本身导致`stringify()`返回`undefined`而不是字符串：'
- en: '[PRE980]'
  id: totrans-4121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE980]'
- en: 'Properties whose values are unsupported are simply ignored:'
  id: totrans-4122
  prefs: []
  type: TYPE_NORMAL
  zh: 其值不受支持的属性将被简单地忽略：
- en: '[PRE981]'
  id: totrans-4123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE981]'
- en: 'Unsupported values in arrays are stringified as `null`s:'
  id: totrans-4124
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中不支持的值将被字符串化为`null`：
- en: '[PRE982]'
  id: totrans-4125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE982]'
- en: The toJSON() Method
  id: totrans-4126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: toJSON()方法
- en: 'If `JSON.stringify()` encounters an object that has a `toJSON` method, it uses
    that method to obtain a value to be stringified. For example:'
  id: totrans-4127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`JSON.stringify()`遇到具有`toJSON`方法的对象，则使用该方法获取要字符串化的值。例如：
- en: '[PRE983]'
  id: totrans-4128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE983]'
- en: 'Dates already have a `toJSON` method that produces an ISO 8601 date string:'
  id: totrans-4129
  prefs: []
  type: TYPE_NORMAL
  zh: 日期已经有一个产生ISO 8601日期字符串的`toJSON`方法：
- en: '[PRE984]'
  id: totrans-4130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE984]'
- en: 'The full signature of a `toJSON` method is as follows:'
  id: totrans-4131
  prefs: []
  type: TYPE_NORMAL
  zh: '`toJSON`方法的完整签名如下：'
- en: '[PRE985]'
  id: totrans-4132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE985]'
- en: 'The `key` parameter allows you to stringify differently, depending on context.
    It is always a string and indicates where your object was found in the parent
    object:'
  id: totrans-4133
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`参数允许您根据上下文以不同方式进行字符串化。它始终是一个字符串，并指示在父对象中找到您的对象的位置：'
- en: Root position
  id: totrans-4134
  prefs: []
  type: TYPE_NORMAL
  zh: 根位置
- en: The empty string
  id: totrans-4135
  prefs: []
  type: TYPE_NORMAL
  zh: 空字符串
- en: Property value
  id: totrans-4136
  prefs: []
  type: TYPE_NORMAL
  zh: 属性值
- en: The property key
  id: totrans-4137
  prefs: []
  type: TYPE_NORMAL
  zh: 属性键
- en: Array element
  id: totrans-4138
  prefs: []
  type: TYPE_NORMAL
  zh: 数组元素
- en: The element’s index as a string
  id: totrans-4139
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的索引作为字符串
- en: 'I’ll demonstrate `toJSON()` via the following object:'
  id: totrans-4140
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过以下对象演示`toJSON()`：
- en: '[PRE986]'
  id: totrans-4141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE986]'
- en: 'If you use `JSON.stringify()`, each occurrence of `obj` is replaced with `0`.
    The `toJSON()` method is notified that `obj` was encountered at the property key
    `''foo''` and at the array index 0:'
  id: totrans-4142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`JSON.stringify()`，则每次出现`obj`都会被替换为`0`。通知`toJSON()`方法在属性键`'foo'`和数组索引0处遇到了`obj`：
- en: '[PRE987]'
  id: totrans-4143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE987]'
- en: 'The built-in `toJSON()` methods are as follows:'
  id: totrans-4144
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`toJSON()`方法如下：
- en: '`Boolean.prototype.toJSON()`'
  id: totrans-4145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean.prototype.toJSON()`'
- en: '`Number.prototype.toJSON()`'
  id: totrans-4146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.prototype.toJSON()`'
- en: '`String.prototype.toJSON()`'
  id: totrans-4147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.toJSON()`'
- en: '`Date.prototype.toJSON()`'
  id: totrans-4148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toJSON()`'
- en: JSON.parse(text, reviver?)
  id: totrans-4149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON.parse(text, reviver?)
- en: '`JSON.parse(text, reviver?)` parses the JSON data in `text` and returns a JavaScript
    value. Here are some examples:'
  id: totrans-4150
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.parse(text, reviver?)`解析`text`中的JSON数据并返回JavaScript值。以下是一些示例：'
- en: '[PRE988]'
  id: totrans-4151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE988]'
- en: 'The optional parameter `reviver` is a *node visitor* (see [Transforming Data
    via Node Visitors](ch22.html#node_visitors "Transforming Data via Node Visitors"))
    and can be used to transform the parsed data. In this example, we are translating
    date strings to date objects:'
  id: totrans-4152
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数`reviver`是一个*节点访问者*（参见[通过节点访问者转换数据](ch22.html#node_visitors "通过节点访问者转换数据")），可用于转换解析后的数据。在此示例中，我们将日期字符串转换为日期对象：
- en: '[PRE989]'
  id: totrans-4153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE989]'
- en: 'And here is the interaction:'
  id: totrans-4154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE990]'
  id: totrans-4155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE990]'
- en: Transforming Data via Node Visitors
  id: totrans-4156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过节点访问者转换数据
- en: 'Both `JSON.stringify()` and `JSON.parse()` let you transform JavaScript data
    by passing in a function:'
  id: totrans-4157
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.stringify()`和`JSON.parse()`都允许您通过传递函数来转换JavaScript数据：'
- en: '`JSON.stringify()` lets you change the JavaScript data before turning it into
    JSON.'
  id: totrans-4158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON.stringify()`允许您在将其转换为JSON之前更改JavaScript数据。'
- en: '`JSON.parse()` parses JSON and then lets you post-process the resulting JavaScript
    data.'
  id: totrans-4159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON.parse()`解析JSON，然后让您对生成的JavaScript数据进行后处理。'
- en: 'The JavaScript data is a tree whose compound nodes are arrays and objects and
    whose leaves are primitive values (booleans, numbers, strings, `null`). Let’s
    use the name *node visitor* for the transformation function that you pass in.
    The methods iterate over the tree and call the visitor for each node. It then
    has the option to replace or delete the node. The node visitor has the signature:'
  id: totrans-4160
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript数据是一个树，其复合节点是数组和对象，其叶子是原始值（布尔值，数字，字符串，`null`）。让我们将传递的转换函数称为*节点访问者*。这些方法遍历树并为每个节点调用访问者。然后可以选择替换或删除节点。节点访问者的签名如下：
- en: '[PRE991]'
  id: totrans-4161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE991]'
- en: 'The parameters are:'
  id: totrans-4162
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是：
- en: '`this`'
  id: totrans-4163
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`'
- en: The parent of the current node.
  id: totrans-4164
  prefs: []
  type: TYPE_NORMAL
  zh: 当前节点的父节点。
- en: '`key`'
  id: totrans-4165
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`'
- en: A key where the current node is located inside its parent. `key` is always a
    string.
  id: totrans-4166
  prefs: []
  type: TYPE_NORMAL
  zh: 当前节点位于其父节点内的键。`key` 总是一个字符串。
- en: '`value`'
  id: totrans-4167
  prefs: []
  type: TYPE_NORMAL
  zh: '`值`'
- en: The current node.
  id: totrans-4168
  prefs: []
  type: TYPE_NORMAL
  zh: 当前节点。
- en: 'The root node `root` has no parent. When `root` is visited, a pseudoparent
    is created for it and the parameters have the following values:'
  id: totrans-4169
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点 `root` 没有父节点。当访问 `root` 时，为其创建了一个伪父节点，并且参数具有以下值：
- en: '`this` is `{ '''': root }`.'
  id: totrans-4170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this` 是 `{ '''': root }`。'
- en: '`key` is `''''`.'
  id: totrans-4171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key` 是 `''''`。'
- en: '`value` is `root`.'
  id: totrans-4172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value` 是 `root`。'
- en: 'The node visitor has three options for returning a value:'
  id: totrans-4173
  prefs: []
  type: TYPE_NORMAL
  zh: 节点访问者有三种返回值的选项：
- en: Return `value` as it is. Then no change is performed.
  id: totrans-4174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 `value`，然后不执行任何更改。
- en: Return a different value. Then the current node is replaced with it.
  id: totrans-4175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回不同的值。然后当前节点被替换。
- en: Return `undefined`. Then the node is removed.
  id: totrans-4176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 `undefined`。然后移除节点。
- en: The following is an example of a node visitor. It logs what values have been
    passed to it.
  id: totrans-4177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是节点访问者的示例。它记录了传递给它的值。
- en: '[PRE992]'
  id: totrans-4178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE992]'
- en: Let’s use this function to examine how the JSON methods iterate over JavaScript
    data.
  id: totrans-4179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用此函数来检查 JSON 方法如何迭代 JavaScript 数据。
- en: JSON.stringify()
  id: totrans-4180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON.stringify()
- en: 'The special root node comes first, in a prefix iteration (parent before children).
    The first node that is visited is always the pseudoroot. The last line that is
    displayed after each call is the string returned by `stringify()`:'
  id: totrans-4181
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的根节点首先出现在前缀迭代中（父节点在子节点之前）。访问的第一个节点始终是伪根。在每次调用后显示的最后一行是 `stringify()` 返回的字符串：
- en: '[PRE993]'
  id: totrans-4182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE993]'
- en: JSON.parse()
  id: totrans-4183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON.parse()
- en: 'The leaves come first, in a postfix iteration (children before parent). The
    last node that is visited is always the pseudoroot. The last line that is displayed
    after each call is the JavaScript value returned by `parse()`:'
  id: totrans-4184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是叶子节点，在后缀迭代中（子节点在父节点之前）。访问的最后一个节点始终是伪根。在每次调用后显示的最后一行是 `parse()` 返回的 JavaScript
    值：
- en: '[PRE994]'
  id: totrans-4185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE994]'
- en: Chapter 23. Standard Global Variables
  id: totrans-4186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 23 章。标准全局变量
- en: This chapter is a reference for the global variables standardized by the ECMAScript
    specification. Web browsers have more global variables, which are [listed on MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window).
    All global variables are (own or inherited) properties of the global object (`window`
    in browsers; see [The Global Object](ch16.html#global_object "The Global Object")).
  id: totrans-4187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是 ECMAScript 规范标准化的全局变量的参考。Web 浏览器有更多全局变量，这些变量在 [MDN 上列出](https://developer.mozilla.org/en-US/docs/Web/API/Window)。所有全局变量都是全局对象的（自有或继承的）属性（在浏览器中是
    `window`；参见 [全局对象](ch16.html#global_object "全局对象")）。
- en: Constructors
  id: totrans-4188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'For details on the following constructors, see the sections indicated in parentheses:'
  id: totrans-4189
  prefs: []
  type: TYPE_NORMAL
  zh: 有关以下构造函数的详细信息，请参见括号中指示的部分：
- en: '`Array` ([The Array Constructor](ch18.html#array_constructor "The Array Constructor"))'
  id: totrans-4190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array`（[数组构造函数](ch18.html#array_constructor "数组构造函数"））'
- en: '`Boolean` ([Wrapper Objects for Primitives](ch08.html#wrapper_objects "Wrapper
    Objects for Primitives"))'
  id: totrans-4191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`（[原始值的包装对象](ch08.html#wrapper_objects "原始值的包装对象"））'
- en: '`Date` ([The Date Constructor](ch20.html#date_constructors "The Date Constructor"))'
  id: totrans-4192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date`（[日期构造函数](ch20.html#date_constructors "日期构造函数"））'
- en: '`Function` ([Evaluating Code Using new Function()](ch23.html#function_constructor
    "Evaluating Code Using new Function()"))'
  id: totrans-4193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Function`（[使用 new Function() 评估代码](ch23.html#function_constructor "使用 new
    Function() 评估代码"））'
- en: '`Number` ([Wrapper Objects for Primitives](ch08.html#wrapper_objects "Wrapper
    Objects for Primitives"))'
  id: totrans-4194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number`（[原始值的包装对象](ch08.html#wrapper_objects "原始值的包装对象"））'
- en: '`Object` ([Converting Any Value to an Object](ch17_split_000.html#toobject
    "Converting Any Value to an Object"))'
  id: totrans-4195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`对象`（[将任何值转换为对象](ch17_split_000.html#toobject "将任何值转换为对象"））'
- en: '`RegExp` ([Creating a Regular Expression](ch19.html#creating_regexps "Creating
    a Regular Expression"))'
  id: totrans-4196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegExp`（[创建正则表达式](ch19.html#creating_regexps "创建正则表达式"））'
- en: '`String` ([Wrapper Objects for Primitives](ch08.html#wrapper_objects "Wrapper
    Objects for Primitives"))'
  id: totrans-4197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`（[原始值的包装对象](ch08.html#wrapper_objects "原始值的包装对象"））'
- en: Error Constructors
  id: totrans-4198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误构造函数
- en: 'For details on these constructors, see [Error Constructors](ch14.html#error_constructors
    "Error Constructors"):'
  id: totrans-4199
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些构造函数的详细信息，请参见 [错误构造函数](ch14.html#error_constructors "错误构造函数"）：
- en: '`Error`'
  id: totrans-4200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Error`'
- en: '`EvalError`'
  id: totrans-4201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EvalError`'
- en: '`RangeError`'
  id: totrans-4202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RangeError`'
- en: '`ReferenceError`'
  id: totrans-4203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReferenceError`'
- en: '`SyntaxError`'
  id: totrans-4204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SyntaxError`'
- en: '`TypeError`'
  id: totrans-4205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeError`'
- en: '`URIError`'
  id: totrans-4206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URIError`'
- en: Nonconstructor Functions
  id: totrans-4207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非构造函数
- en: Several global functions are not constructors. They are listed in this section.
  id: totrans-4208
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个全局函数不是构造函数。它们在本节中列出。
- en: Encoding and Decoding Text
  id: totrans-4209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码和解码文本
- en: 'The following functions handle several ways of URI encoding and decoding:'
  id: totrans-4210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数处理 URI 编码和解码的几种方式：
- en: '`encodeURI(uri)`'
  id: totrans-4211
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodeURI(uri)`'
- en: 'Percent-encodes special characters in `uri`. Special characters are all Unicode
    characters except for the following ones:'
  id: totrans-4212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `uri` 中对特殊字符进行百分比编码。特殊字符是除以下字符外的所有 Unicode 字符：
- en: '| URI characters: | `; , / ? : @ & = + $ #` |'
  id: totrans-4213
  prefs: []
  type: TYPE_TB
  zh: '| URI 字符： | `; , / ? : @ & = + $ #` |'
- en: '| Not encoded either: | `a-z A-Z 0-9 - _ . ! ~ * '' ( )` |'
  id: totrans-4214
  prefs: []
  type: TYPE_TB
  zh: '| 未编码： | `a-z A-Z 0-9 - _ . ! ~ * '' ( )` |'
- en: 'For example:'
  id: totrans-4215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE995]'
  id: totrans-4216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE995]'
- en: '`encodeURIComponent(uriComponent)`'
  id: totrans-4217
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodeURIComponent(uriComponent)`'
- en: 'Percent-encodes all characters in `uriComponent`, except for:'
  id: totrans-4218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `uriComponent` 中对所有字符进行百分比编码，除了：
- en: '| Not encoded: | `a-z A-Z 0-9 - _ . ! ~ * '' ( )` |'
  id: totrans-4219
  prefs: []
  type: TYPE_TB
  zh: '| 未编码： | `a-z A-Z 0-9 - _ . ! ~ * '' ( )` |'
- en: 'In contrast to `encodeURI`, characters that are significant in URLs and filenames
    are encoded, too. You can thus use this function to turn any text into a legal
    filename or URL path segment. For example:'
  id: totrans-4220
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `encodeURI` 相反，URL 和文件名中有意义的字符也被编码了。因此，您可以使用此函数将任何文本转换为合法的文件名或 URL 路径段。例如：
- en: '[PRE996]'
  id: totrans-4221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE996]'
- en: '`decodeURI(encodedURI)`'
  id: totrans-4222
  prefs: []
  type: TYPE_NORMAL
  zh: '`decodeURI(encodedURI)`'
- en: 'Decodes a percent-encoded URI that has been produced by `encodeURI`:'
  id: totrans-4223
  prefs: []
  type: TYPE_NORMAL
  zh: 解码由 `encodeURI` 生成的百分比编码的 URI：
- en: '[PRE997]'
  id: totrans-4224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE997]'
- en: '`encodeURI` does not encode URI characters and `decodeURI` does not decode
    them, even if they have been correctly encoded:'
  id: totrans-4225
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodeURI` 不会对 URI 字符进行编码，`decodeURI` 也不会对其进行解码，即使它们已经被正确编码：'
- en: '[PRE998]'
  id: totrans-4226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE998]'
- en: '`decodeURIComponent(encodedURIComponent)`'
  id: totrans-4227
  prefs: []
  type: TYPE_NORMAL
  zh: '`decodeURIComponent(encodedURIComponent)`'
- en: 'Decodes a percent-encoded URI component that has been produced by `encodeURIComponent`.
    In contrast to `decodeURI`, all percent-encoded characters are decoded:'
  id: totrans-4228
  prefs: []
  type: TYPE_NORMAL
  zh: 解码由 `encodeURIComponent` 生成的百分比编码的 URI 组件。与 `decodeURI` 相反，所有百分比编码的字符都被解码：
- en: '[PRE999]'
  id: totrans-4229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE999]'
- en: 'The following are deprecated:'
  id: totrans-4230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容已被弃用：
- en: '`escape(str)` percent-encodes `str`. It is deprecated because it does not handle
    non-ASCII characters properly. Use `encodeURIComponent()` instead.'
  id: totrans-4231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`escape(str)`对`str`进行百分比编码。它已被弃用，因为它不能正确处理非ASCII字符。请改用`encodeURIComponent()`。'
- en: '`unescape(str)` percent-decodes `str`. It is deprecated because it does not
    handle non-ASCII characters properly. Use `decodeURIComponent()` instead.'
  id: totrans-4232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unescape(str)`对`str`进行百分比解码。它已被弃用，因为它不能正确处理非ASCII字符。请改用`decodeURIComponent()`。'
- en: Categorizing and Parsing Numbers
  id: totrans-4233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对数字进行分类和解析
- en: 'The following methods help with categorizing and parsing numbers:'
  id: totrans-4234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法有助于对数字进行分类和解析：
- en: '`isFinite(number)` ([Checking for Infinity](ch11.html#isFinite "Checking for
    Infinity"))'
  id: totrans-4235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFinite(number)` ([检查是否为无穷大](ch11.html#isFinite "检查是否为无穷大"))'
- en: '`isNaN(value)` ([Pitfall: checking whether a value is NaN](ch11.html#isNaN
    "Pitfall: checking whether a value is NaN"))'
  id: totrans-4236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNaN(value)` ([陷阱：检查值是否为NaN](ch11.html#isNaN "陷阱：检查值是否为NaN"))'
- en: '`parseFloat(string)` ([parseFloat()](ch11.html#parseFloat "parseFloat()"))'
  id: totrans-4237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseFloat(string)` ([parseFloat()](ch11.html#parseFloat "parseFloat()"))'
- en: '`parseInt(string, radix)` ([Integers via parseInt()](ch11.html#parseInt "Integers
    via parseInt()"))'
  id: totrans-4238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseInt(string, radix)` ([通过parseInt()获取整数](ch11.html#parseInt "通过parseInt()获取整数"))'
- en: Dynamically Evaluating JavaScript Code via eval() and new Function()
  id: totrans-4239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过eval()和new Function()动态评估JavaScript代码
- en: This section examines how one can dynamically evaluate code in JavaScript.
  id: totrans-4240
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍如何在JavaScript中动态评估代码。
- en: Evaluating Code Using eval()
  id: totrans-4241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用eval()评估代码
- en: 'The function call:'
  id: totrans-4242
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用：
- en: '[PRE1000]'
  id: totrans-4243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1000]'
- en: 'evaluates the JavaScript code in `str`. For example:'
  id: totrans-4244
  prefs: []
  type: TYPE_NORMAL
  zh: 评估`str`中的JavaScript代码。例如：
- en: '[PRE1001]'
  id: totrans-4245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1001]'
- en: 'Note that `eval()` parses in statement context (see [Expressions Versus Statements](ch07.html#expr_vs_stmt
    "Expressions Versus Statements")):'
  id: totrans-4246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`eval()`在语句上下文中解析（参见[表达式与语句](ch07.html#expr_vs_stmt "表达式与语句")）：
- en: '[PRE1002]'
  id: totrans-4247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1002]'
- en: Use eval() in strict mode
  id: totrans-4248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在严格模式下使用eval()
- en: 'For `eval()`, you really should use strict mode (see [Strict Mode](ch07.html#strict_mode
    "Strict Mode")). In sloppy mode, evaluated code can create local variables in
    the surrounding scope:'
  id: totrans-4249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`eval()`，您确实应该使用严格模式（参见[严格模式](ch07.html#strict_mode "严格模式")）。在松散模式下，评估的代码可以在周围范围内创建局部变量：
- en: '[PRE1003]'
  id: totrans-4250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1003]'
- en: 'That can’t happen in strict mode:'
  id: totrans-4251
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下无法发生：
- en: '[PRE1004]'
  id: totrans-4252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1004]'
- en: However, even in strict mode, evaluated code still has read and write access
    to variables in surrounding scopes. To prevent such access, you need to call `eval()`
    indirectly.
  id: totrans-4253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在严格模式下，评估的代码仍然可以读取和写入周围范围内的变量。要防止这种访问，您需要间接调用`eval()`。
- en: Indirect eval() evaluates in global scope
  id: totrans-4254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 间接eval()在全局范围内进行评估
- en: 'There are two ways to invoke `eval()`:'
  id: totrans-4255
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种调用`eval()`的方法：
- en: '[Directly](http://ecma-international.org/ecma-262/5.1/#sec-15.1.2.1.1). Via
    a direct call to a function whose name is “eval.”'
  id: totrans-4256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[直接](http://ecma-international.org/ecma-262/5.1/#sec-15.1.2.1.1)。通过直接调用名称为“eval”的函数。'
- en: Indirectly. In some other way (via `call()`, as a method of `window`, by storing
    it under a different name and calling it there, etc.).
  id: totrans-4257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间接调用。以其他方式（通过`call()`，作为`window`的方法，通过在不同名称下存储它并在那里调用等）。
- en: 'As we have already seen, direct `eval()` executes code in the current scope:'
  id: totrans-4258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，直接`eval()`在当前范围内执行代码：
- en: '[PRE1005]'
  id: totrans-4259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1005]'
- en: 'Conversely, indirect `eval()` executes it in global scope:'
  id: totrans-4260
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，间接`eval()`在全局范围内执行它：
- en: '[PRE1006]'
  id: totrans-4261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1006]'
- en: 'Explanation of (1): When you refer to a variable via its name, the initial
    result is a so-called [*reference*](http://ecma-international.org/ecma-262/5.1/#sec-8.7),
    a data structure with two main fields:'
  id: totrans-4262
  prefs: []
  type: TYPE_NORMAL
  zh: （1）的解释：当您通过名称引用变量时，初始结果是所谓的[*引用*](http://ecma-international.org/ecma-262/5.1/#sec-8.7)，一个具有两个主要字段的数据结构：
- en: '`base` points to the *environment*, the data structure in which the variable’s
    value is stored.'
  id: totrans-4263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base`指向*环境*，即变量值存储的数据结构。'
- en: '`referencedName` is the name of the variable.'
  id: totrans-4264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`referencedName`是变量的名称。'
- en: During an `eval()` function call, the function call operator (the parentheses)
    encounters a reference to `eval` and can determine the name of the function to
    be called. Therefore, such a function call triggers a direct `eval()`. You can,
    however, force an indirect `eval()` by not giving the call operator a reference.
    That is achieved by retrieving the value of the reference before applying the
    operator. The comma operator does that for us in line (1). This operator evaluates
    the first operand and returns the result of evaluating the second operand. The
    evaluation always produces values, which means that references are resolved and
    function names are lost.
  id: totrans-4265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`eval()`函数调用期间，函数调用运算符（括号）遇到对`eval`的引用，并且可以确定要调用的函数的名称。因此，这样的函数调用触发了直接的`eval()`。但是，您可以通过不给出调用运算符的引用来强制间接`eval()`。这是通过在应用运算符之前检索引用的值来实现的。逗号运算符在第（1）行为我们执行此操作。此运算符评估第一个操作数并返回评估第二个操作数的结果。评估始终产生值，这意味着引用被解析并丢失了函数名称。
- en: 'Indirectly evaluated code is always sloppy. That is a consequence of the code
    being evaluated independently of its current surroundings:'
  id: totrans-4266
  prefs: []
  type: TYPE_NORMAL
  zh: 间接评估的代码总是松散的。这是代码独立于其当前环境进行评估的结果：
- en: '[PRE1007]'
  id: totrans-4267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1007]'
- en: Evaluating Code Using new Function()
  id: totrans-4268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用new Function()评估代码
- en: 'The constructor `Function()` has the signature:'
  id: totrans-4269
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数`Function()`的签名为：
- en: '[PRE1008]'
  id: totrans-4270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1008]'
- en: 'It creates a function whose zero or more parameters have the names `param1`,
    `parem2`, and so on, and whose body is `funcBody`; that is, the created function
    looks like this:'
  id: totrans-4271
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个函数，其零个或多个参数的名称为`param1`，`parem2`等，其主体为`funcBody`；也就是说，创建的函数如下所示：
- en: '[PRE1009]'
  id: totrans-4272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1009]'
- en: 'Let’s use `new Function()` to create a function `f` that returns the sum of
    its parameters:'
  id: totrans-4273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`new Function()`创建一个函数`f`，它返回其参数的总和：
- en: '[PRE1010]'
  id: totrans-4274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1010]'
- en: Similar to indirect `eval()`, `new Function()` creates functions whose scope
    is global:^([[16](#ftn.id1065911)])
  id: totrans-4275
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于间接`eval()`，`new Function()`创建其作用域为全局的函数:^([[16](#ftn.id1065911)])
- en: '[PRE1011]'
  id: totrans-4276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1011]'
- en: 'Such functions are also sloppy by default:'
  id: totrans-4277
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数默认情况下也是松散的：
- en: '[PRE1012]'
  id: totrans-4278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1012]'
- en: eval() Versus new Function()
  id: totrans-4279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: eval()与new Function()
- en: 'Normally, it is better to use `new Function()` than `eval()` in order to evaluate
    code: the function parameters provide a clear interface to the evaluated code
    and you don’t need the slightly awkward syntax of indirect `eval()` to ensure
    that the evaluated code can access only global variables (in addition to its own).'
  id: totrans-4280
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好使用`new Function()`而不是`eval()`来评估代码：函数参数为评估的代码提供了清晰的接口，而且你不需要间接`eval()`的略显笨拙的语法来确保评估的代码只能访问全局变量（除了它自己的变量）。
- en: Best Practices
  id: totrans-4281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践
- en: You should avoid `eval()` and `new Function()`. Dynamically evaluating code
    is slow and a potential security risk. It also prevents most tools (such as IDEs)
    that use static analysis from considering the code.
  id: totrans-4282
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该使用`eval()`和`new Function()`。动态评估代码很慢，而且存在潜在的安全风险。它还会阻止大多数使用静态分析的工具（如IDE）考虑代码。
- en: 'Often, there are better alternatives. For example, Brendan Eich recently [tweeted](http://bit.ly/1fwpWrB)
    an antipattern used by programmers who want to access a property whose name is
    stored in a variable `propName`:'
  id: totrans-4283
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有更好的替代方案。例如，Brendan Eich最近在推特上[发推文](http://bit.ly/1fwpWrB)指出了程序员们使用的反模式，他们想要访问存储在变量`propName`中的属性：
- en: '[PRE1013]'
  id: totrans-4284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1013]'
- en: 'The idea makes sense: the dot operator only supports fixed, statically provided
    property keys. In this case, the property key is only known at runtime, which
    is why `eval()` is needed in order to use that operator. Luckily, JavaScript also
    has the bracket operator, which does accept dynamic property keys. Therefore,
    the following is a better version of the preceding code:'
  id: totrans-4285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是有道理的：点运算符只支持固定的，静态提供的属性键。在这种情况下，属性键只在运行时知道，这就是为什么需要`eval()`来使用该运算符。幸运的是，JavaScript还有方括号运算符，它接受动态属性键。因此，以下是前面代码的更好版本：
- en: '[PRE1014]'
  id: totrans-4286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1014]'
- en: You also shouldn’t use `eval()` or `new Function()` to parse JSON data. That
    is unsafe. Either rely on ECMAScript 5’s built-in support for JSON (see [Chapter 22](ch22.html
    "Chapter 22. JSON")) or use a library.
  id: totrans-4287
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不应该使用`eval()`或`new Function()`来解析JSON数据。这是不安全的。要么依赖ECMAScript 5对JSON的内置支持（参见[第22章](ch22.html
    "第22章.JSON")），要么使用一个库。
- en: Legitimate use cases
  id: totrans-4288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 合法的用例
- en: 'There are a few legitimate, albeit advanced, use cases for `eval()` and `new
    Function()`: configuration data with functions (which JSON does not allow), template
    libraries, interpreters, command lines, and module systems.'
  id: totrans-4289
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()`和`new Function()`有一些合法的，尽管是高级的用例：带有函数的配置数据（JSON不允许），模板库，解释器，命令行和模块系统。'
- en: Conclusion
  id: totrans-4290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: This was a relatively high-level overview of dynamically evaluating code in
    JavaScript. If you want to dig deeper, you can take a look at the article [“Global
    eval. What are the options?”](http://perfectionkills.com/global-eval-what-are-the-options/)
    by kangax.
  id: totrans-4291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JavaScript动态评估代码的一个相对高级的概述。如果你想深入了解，可以查看kangax的文章[“全局eval。有哪些选项？”](http://perfectionkills.com/global-eval-what-are-the-options/)。
- en: The Console API
  id: totrans-4292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制台API
- en: In most JavaScript engines, there is a global object, `console`, with methods
    for logging and debugging. That object is not part of the language proper, but
    has become a de facto standard. Since their main purpose is debugging, the `console`
    methods will most frequently be used during development and rarely in deployed
    code.
  id: totrans-4293
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数JavaScript引擎中，有一个全局对象`console`，其中包含用于记录和调试的方法。该对象不是语言本身的一部分，但已成为事实上的标准。由于它们的主要目的是调试，`console`方法在开发过程中最常用，而在部署的代码中很少使用。
- en: This section provides an overview of the console API. It documents the status
    quo as of Chrome 32, Firebug 1.12, Firefox 25, Internet Explorer 11, Node.js 0.10.22,
    and Safari 7.0.
  id: totrans-4294
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了控制台API。它记录了Chrome 32、Firebug 1.12、Firefox 25、Internet Explorer 11、Node.js
    0.10.22和Safari 7.0的现状。
- en: How Standardized Is the Console API Across Engines?
  id: totrans-4295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制台API在各种引擎之间的标准化程度如何？
- en: 'The implementations of the console API vary greatly and are constantly changing.
    If you want authoritative documentation, you have two options. First, you can
    look at standard-like overviews of the API:'
  id: totrans-4296
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台API的实现差异很大，而且不断变化。如果你想要权威的文档，你有两个选择。首先，你可以查看API的标准概述：
- en: Firebug first implemented the console API, and the [documentation](http://bit.ly/1fwq1vk)
    in its wiki is the closest thing to a standard there currently is.
  id: totrans-4297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebug首先实现了控制台API，其在其维基中的[文档](http://bit.ly/1fwq1vk)是目前最接近标准的东西。
- en: Additionally, Brian Kardell and Paul Irish are working on a [specification](http://bit.ly/1fwq7mX)
    for the API, which should lead to more consistent behavior.
  id: totrans-4298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，Brian Kardell和Paul Irish正在制定[API规范](http://bit.ly/1fwq7mX)，这应该会导致更一致的行为。
- en: 'Second, you can look at the documentation of various engines:'
  id: totrans-4299
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你可以查看各种引擎的文档：
- en: '[Chrome](https://developers.google.com/chrome-developer-tools/docs/console-api/)'
  id: totrans-4300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Chrome](https://developers.google.com/chrome-developer-tools/docs/console-api/)'
- en: '[Firebug](https://getfirebug.com/wiki/index.php/Console_API)'
  id: totrans-4301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Firebug](https://getfirebug.com/wiki/index.php/Console_API)'
- en: '[Firefox](https://developer.mozilla.org/en-US/docs/Web/API/console)'
  id: totrans-4302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Firefox](https://developer.mozilla.org/en-US/docs/Web/API/console)'
- en: '[Internet Explorer](http://msdn.microsoft.com/en-us/library/ie/hh772183.aspx)'
  id: totrans-4303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Internet Explorer](http://msdn.microsoft.com/en-us/library/ie/hh772183.aspx)'
- en: '[Node.js](http://nodejs.org/api/stdio.html)'
  id: totrans-4304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Node.js](http://nodejs.org/api/stdio.html)'
- en: '[Safari](http://bit.ly/1fwq9er)'
  id: totrans-4305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Safari](http://bit.ly/1fwq9er)'
- en: Warning
  id: totrans-4306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: There is a bug in Internet Explorer 9\. In that browser, the `console` object
    exists only if the developer tools were open at least once. That means that you
    get a `ReferenceError` if you refer to `console` and the tools weren’t open before.
    As a workaround, you can check whether `console` exists and create a dummy implementation
    if it doesn’t.
  id: totrans-4307
  prefs: []
  type: TYPE_NORMAL
  zh: 在Internet Explorer 9中存在一个错误。在该浏览器中，只有开发者工具至少打开过一次，`console`对象才存在。这意味着如果在工具打开之前引用`console`，你会得到一个`ReferenceError`。作为一种解决方法，你可以检查`console`是否存在，如果不存在则创建一个虚拟实现。
- en: Simple Logging
  id: totrans-4308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的日志记录
- en: 'The console API includes the following logging methods:'
  id: totrans-4309
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台API包括以下记录方法：
- en: '`console.clear()`'
  id: totrans-4310
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.clear()`'
- en: Clear the console.
  id: totrans-4311
  prefs: []
  type: TYPE_NORMAL
  zh: 清除控制台。
- en: '`console.debug(object1, object2?, ...)`'
  id: totrans-4312
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.debug(object1, object2?, ...)`'
- en: Prefer `console.log()`, which does the same as this method.
  id: totrans-4313
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用`console.log()`，它与此方法相同。
- en: '`console.error(object1, object2?, ...)`'
  id: totrans-4314
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.error(object1, object2?, ...)`'
- en: Log the parameters to the console. In browsers, the logged content may be marked
    by an “error” icon and/or include a stack trace or a link to the code.
  id: totrans-4315
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数记录到控制台。在浏览器中，记录的内容可能会被“错误”图标标记，和/或包括堆栈跟踪或代码链接。
- en: '`console.exception(errorObject, object1?, ...])` [Firebug-only]'
  id: totrans-4316
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.exception(errorObject, object1?, ...])` [仅限Firebug]'
- en: Log `object1` etc. and show an interactive stack trace.
  id: totrans-4317
  prefs: []
  type: TYPE_NORMAL
  zh: 记录`object1`等，并显示交互式堆栈跟踪。
- en: '`console.info(object1?, object2?, ...)`'
  id: totrans-4318
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.info(object1?, object2?, ...)`'
- en: Log the parameters to the console. In browsers, the logged content may be marked
    by an “info” icon and/or include a stack trace or a link to the code.
  id: totrans-4319
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数记录到控制台。在浏览器中，记录的内容可能会被“信息”图标标记，和/或包括堆栈跟踪或代码链接。
- en: '`console.log(object1?, object2?, ...)`'
  id: totrans-4320
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(object1?, object2?, ...)`'
- en: 'Log the parameters to the console. If the first parameter is a `printf`-style
    format string, use it to print the remaining parameters. For example (Node.js
    REPL):'
  id: totrans-4321
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数记录到控制台。如果第一个参数是`printf`风格的格式字符串，则使用它来打印其余的参数。例如（Node.js REPL）：
- en: '[PRE1015]'
  id: totrans-4322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1015]'
- en: The only dependable cross-platform formatting directive is `%s`. Node.js supports
    `%j` to format data as JSON; browsers tend to support directives that log something
    interactive to the console.
  id: totrans-4323
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一可靠的跨平台格式化指令是`%s`。Node.js支持`%j`以将数据格式化为JSON；浏览器倾向于支持记录交互内容的指令。
- en: '`console.trace()`'
  id: totrans-4324
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.trace()`'
- en: Logs a stack trace (which is interactive in many browsers).
  id: totrans-4325
  prefs: []
  type: TYPE_NORMAL
  zh: 记录堆栈跟踪（在许多浏览器中是交互式的）。
- en: '`console.warn(object1?, object2?, ...)`'
  id: totrans-4326
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.warn(object1?, object2?, ...)`'
- en: Log the parameters to the console. In browsers, the logged content may be marked
    by a “warning” icon and/or include a stack trace or a link to the code.
  id: totrans-4327
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数记录到控制台。在浏览器中，记录的内容可能会被“警告”图标标记，和/或包括堆栈跟踪或代码链接。
- en: 'Support on various platforms is indicated in the following table:'
  id: totrans-4328
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表中指出了各种平台的支持：
- en: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
  id: totrans-4329
  prefs: []
  type: TYPE_TB
  zh: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-4330
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| `clear` | ✓ | ✓ |  | ✓ |  | ✓ |'
  id: totrans-4331
  prefs: []
  type: TYPE_TB
  zh: '| `clear` | ✓ | ✓ |  | ✓ |  | ✓ |'
- en: '| `debug` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
  id: totrans-4332
  prefs: []
  type: TYPE_TB
  zh: '| `debug` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
- en: '| `error` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4333
  prefs: []
  type: TYPE_TB
  zh: '| `error` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| *`exception`* |  | ✓ |  |  |  |  |'
  id: totrans-4334
  prefs: []
  type: TYPE_TB
  zh: '| *`exception`* |  | ✓ |  |  |  |  |'
- en: '| `info` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4335
  prefs: []
  type: TYPE_TB
  zh: '| `info` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| `log` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4336
  prefs: []
  type: TYPE_TB
  zh: '| `log` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| `trace` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4337
  prefs: []
  type: TYPE_TB
  zh: '| `trace` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| `warn` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4338
  prefs: []
  type: TYPE_TB
  zh: '| `warn` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '`exception` has been typeset in italics, because it is supported only on a
    single platform.'
  id: totrans-4339
  prefs: []
  type: TYPE_NORMAL
  zh: '`exception`以斜体排版，因为它只在单个平台上受支持。'
- en: Checking and Counting
  id: totrans-4340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查和计数
- en: 'The console API includes the following checking and counting methods:'
  id: totrans-4341
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台API包括以下检查和计数方法：
- en: '`console.assert(expr, obj?)`'
  id: totrans-4342
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.assert(expr, obj?)`'
- en: If `expr` is `false`, log `obj` to the console and throw an exception. If it
    is `true`, do nothing.
  id: totrans-4343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`expr`为`false`，则将`obj`记录到控制台并抛出异常。如果为`true`，则什么也不做。
- en: '`console.count(label?)`'
  id: totrans-4344
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.count(label?)`'
- en: Count how many times the line with this statement is executed with this label.
  id: totrans-4345
  prefs: []
  type: TYPE_NORMAL
  zh: 计算带有此语句的行被执行的次数。
- en: 'Support on various platforms is indicated in the following table:'
  id: totrans-4346
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表中指出了各种平台的支持：
- en: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
  id: totrans-4347
  prefs: []
  type: TYPE_TB
  zh: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-4348
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| `assert` | ✓ | ✓ |  | ✓ | ✓ | ✓ |'
  id: totrans-4349
  prefs: []
  type: TYPE_TB
  zh: '| `assert` | ✓ | ✓ |  | ✓ | ✓ | ✓ |'
- en: '| `count` | ✓ | ✓ |  | ✓ |  | ✓ |'
  id: totrans-4350
  prefs: []
  type: TYPE_TB
  zh: '| `count` | ✓ | ✓ |  | ✓ |  | ✓ |'
- en: Formatted Logging
  id: totrans-4351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化日志
- en: 'The console API includes the following methods for formatted logging:'
  id: totrans-4352
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台API包括以下格式化日志的方法：
- en: '`console.dir(object)`'
  id: totrans-4353
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.dir(object)`'
- en: Print a representation of the object to the console. In browsers, that representation
    can be explored interactively.
  id: totrans-4354
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象的表示打印到控制台。在浏览器中，该表示可以交互地进行探索。
- en: '`console.dirxml(object)`'
  id: totrans-4355
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.dirxml(object)`'
- en: Print the XML source tree of an HTML or XML element.
  id: totrans-4356
  prefs: []
  type: TYPE_NORMAL
  zh: 打印HTML或XML元素的XML源树。
- en: '`console.group(object1?, object2?, ...)`'
  id: totrans-4357
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.group(object1?, object2?, ...)`'
- en: Log the objects to the console and open a nested block that contains all future
    logged content. Close the block by calling `console.groupEnd()`. The block is
    initially expanded, but can be collapsed.
  id: totrans-4358
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象记录到控制台并打开一个包含所有未来记录内容的嵌套块。通过调用`console.groupEnd()`来关闭该块。该块最初是展开的，但可以折叠。
- en: '`console.groupCollapsed(object1?, object2?, ...)`'
  id: totrans-4359
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.groupCollapsed(object1?, object2?, ...)`'
- en: Works like `console.group()`, but the block is initially collapsed.
  id: totrans-4360
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`console.group()`，但是该块最初是折叠的。
- en: '`console.groupEnd()`'
  id: totrans-4361
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.groupEnd()`'
- en: Close a group that has been opened by `console.group()` or `console.group` `Collapsed()`.
  id: totrans-4362
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭由`console.group()`或`console.groupCollapsed()`打开的组。
- en: '`console.table(data, columns?)`'
  id: totrans-4363
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.table(data, columns?)`'
- en: 'Print an array as a table, one element per row. The optional parameter `columns`
    specifies which properties/array indices are shown in the columns. If that parameter
    is missing, all property keys are used as table columns. Missing properties and
    array elements show up as `undefined` in columns:'
  id: totrans-4364
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组打印为表格，每行一个元素。可选参数`columns`指定在列中显示哪些属性/数组索引。如果缺少该参数，则所有属性键都将用作表格列。缺少的属性和数组元素显示为列中的`undefined`：
- en: '[PRE1016]'
  id: totrans-4365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1016]'
- en: 'The resulting table is as follows:'
  id: totrans-4366
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表如下：
- en: '| (index) | firstName | lastName | age |'
  id: totrans-4367
  prefs: []
  type: TYPE_TB
  zh: '| (索引) | 名字 | 姓氏 | 年龄 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-4368
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | “Jane” | “Bond” | undefined |'
  id: totrans-4369
  prefs: []
  type: TYPE_TB
  zh: '| 0 | “Jane” | “Bond” | undefined |'
- en: '| 1 | “Lars” | “Croft” | 72 |'
  id: totrans-4370
  prefs: []
  type: TYPE_TB
  zh: '| 1 | “Lars” | “Croft” | 72 |'
- en: 'Support on various platforms is indicated in the following table:'
  id: totrans-4371
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表中指出了各种平台的支持：
- en: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
  id: totrans-4372
  prefs: []
  type: TYPE_TB
  zh: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-4373
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| `dir` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4374
  prefs: []
  type: TYPE_TB
  zh: '| `dir` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| `dirxml` | ✓ | ✓ |  | ✓ |  | ✓ |'
  id: totrans-4375
  prefs: []
  type: TYPE_TB
  zh: '| `dirxml` | ✓ | ✓ |  | ✓ |  | ✓ |'
- en: '| `group` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
  id: totrans-4376
  prefs: []
  type: TYPE_TB
  zh: '| `group` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
- en: '| `groupCollapsed` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
  id: totrans-4377
  prefs: []
  type: TYPE_TB
  zh: '| `groupCollapsed` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
- en: '| `groupEnd` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
  id: totrans-4378
  prefs: []
  type: TYPE_TB
  zh: '| `groupEnd` | ✓ | ✓ | ✓ | ✓ |  | ✓ |'
- en: '| `table` | ✓ | ✓ |  |  |  |  |'
  id: totrans-4379
  prefs: []
  type: TYPE_TB
  zh: '| `table` | ✓ | ✓ |  |  |  |  |'
- en: Profiling and Timing
  id: totrans-4380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析和计时
- en: 'The console API includes the following methods for profiling and timing:'
  id: totrans-4381
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台API包括以下用于分析和计时的方法：
- en: '`console.markTimeline(label)` [Safari-only]'
  id: totrans-4382
  prefs: []
  type: TYPE_NORMAL
  zh: '`控制台.标记时间线（标签）` [仅限Safari]'
- en: The same as `console.timeStamp`.
  id: totrans-4383
  prefs: []
  type: TYPE_NORMAL
  zh: 与`console.timeStamp`相同。
- en: '`console.profile(title?)`'
  id: totrans-4384
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台.性能（标题？）
- en: Turn on profiling. The optional `title` is used for the profile report.
  id: totrans-4385
  prefs: []
  type: TYPE_NORMAL
  zh: 打开分析。可选的`title`用于分析报告。
- en: '`console.profileEnd()`'
  id: totrans-4386
  prefs: []
  type: TYPE_NORMAL
  zh: '`控制台.分析结束()`'
- en: Stop profiling and print the profile report.
  id: totrans-4387
  prefs: []
  type: TYPE_NORMAL
  zh: 停止分析并打印分析报告。
- en: '`console.time(label)`'
  id: totrans-4388
  prefs: []
  type: TYPE_NORMAL
  zh: '`控制台.时间（标签）`'
- en: Start a timer whose label is `label`.
  id: totrans-4389
  prefs: []
  type: TYPE_NORMAL
  zh: 启动标签为`label`的计时器。
- en: '`console.timeEnd(label)`'
  id: totrans-4390
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台.时间结束（标签）
- en: Stop the timer whose label is `label` and print the time that has elapsed since
    starting it.
  id: totrans-4391
  prefs: []
  type: TYPE_NORMAL
  zh: 停止标签为`label`的计时器并打印自启动以来经过的时间。
- en: '`console.timeStamp(label?)`'
  id: totrans-4392
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台.时间戳（标签？）
- en: Log a timestamp with the given `label`. May be logged to the console or a timeline.
  id: totrans-4393
  prefs: []
  type: TYPE_NORMAL
  zh: 记录具有给定`label`的时间戳。可以记录到控制台或时间轴。
- en: 'Support on various platforms is indicated in the following table:'
  id: totrans-4394
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了各种平台上的支持：
- en: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
  id: totrans-4395
  prefs: []
  type: TYPE_TB
  zh: '|  | Chrome | Firebug | Firefox | IE | Node.js | Safari |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-4396
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| *`markTimeline`* |  |  |  |  |  | ✓ |'
  id: totrans-4397
  prefs: []
  type: TYPE_TB
  zh: '| *`markTimeline`* |  |  |  |  |  | ✓ |'
- en: '| `profile` | ✓ | ✓ | (devtools) | ✓ |  | ✓ |'
  id: totrans-4398
  prefs: []
  type: TYPE_TB
  zh: '| `profile` | ✓ | ✓ | (devtools) | ✓ |  | ✓ |'
- en: '| `profileEnd` | ✓ | ✓ | (devtools) | ✓ |  | ✓ |'
  id: totrans-4399
  prefs: []
  type: TYPE_TB
  zh: '| `profileEnd` | ✓ | ✓ | (devtools) | ✓ |  | ✓ |'
- en: '| `time` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4400
  prefs: []
  type: TYPE_TB
  zh: '| `time` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| `timeEnd` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-4401
  prefs: []
  type: TYPE_TB
  zh: '| `timeEnd` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| `timeStamp` | ✓ | ✓ |  |  |  |  |'
  id: totrans-4402
  prefs: []
  type: TYPE_TB
  zh: '| `timeStamp` | ✓ | ✓ |  |  |  |  |'
- en: '`markTimeline` has been typeset in italics, because it is supported only on
    a single platform. The (devtools) designation means that the developer tools must
    be open in order for the method to work.^([[17](#ftn.id1069062)])'
  id: totrans-4403
  prefs: []
  type: TYPE_NORMAL
  zh: '`markTimeline`以斜体排版，因为它仅在单个平台上受支持。 （devtools）表示必须打开开发人员工具才能使该方法起作用。^([[17](#ftn.id1069062)])'
- en: Namespaces and Special Values
  id: totrans-4404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间和特殊值
- en: 'The following global variables serve as namespaces for functions. For details,
    see the material indicated in parentheses:'
  id: totrans-4405
  prefs: []
  type: TYPE_NORMAL
  zh: 以下全局变量用作函数的命名空间。有关详细信息，请参阅括号中指示的材料：
- en: '`JSON`'
  id: totrans-4406
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON`'
- en: JSON API functionality ([Chapter 22](ch22.html "Chapter 22. JSON"))
  id: totrans-4407
  prefs: []
  type: TYPE_NORMAL
  zh: JSON API功能（[第22章](ch22.html "第22章.JSON"））
- en: '`Math`'
  id: totrans-4408
  prefs: []
  type: TYPE_NORMAL
  zh: '`数学`'
- en: Math API functionality ([Chapter 21](ch21.html "Chapter 21. Math"))
  id: totrans-4409
  prefs: []
  type: TYPE_NORMAL
  zh: 数学API功能（[第21章](ch21.html "第21章.数学"））
- en: '`Object`'
  id: totrans-4410
  prefs: []
  type: TYPE_NORMAL
  zh: '`对象`'
- en: 'Metaprogramming functionality ([Cheat Sheet: Working with Objects](ch17_split_001.html#oop_cheat_sheet
    "Cheat Sheet: Working with Objects"))'
  id: totrans-4411
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程功能（[对象操作小抄：使用对象](ch17_split_001.html#oop_cheat_sheet "对象操作小抄：使用对象"））
- en: 'The following global variables contain special values. For more on them, review
    the material indicated in parentheses:'
  id: totrans-4412
  prefs: []
  type: TYPE_NORMAL
  zh: 以下全局变量包含特殊值。有关更多信息，请查看括号中指示的材料：
- en: '`undefined`'
  id: totrans-4413
  prefs: []
  type: TYPE_NORMAL
  zh: '`未定义`'
- en: 'A value expressing that something does not exist ([undefined and null](ch08.html#undefined_null
    "undefined and null")):'
  id: totrans-4414
  prefs: []
  type: TYPE_NORMAL
  zh: 表示某物不存在的值（[未定义和null](ch08.html#undefined_null "未定义和null"）：
- en: '[PRE1017]'
  id: totrans-4415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1017]'
- en: '`NaN`'
  id: totrans-4416
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`'
- en: 'A value expressing that something is “not a number” ([NaN](ch11.html#nan "NaN")):'
  id: totrans-4417
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表示某物是“非数字”（[NaN](ch11.html#nan "NaN"）的值：
- en: '[PRE1018]'
  id: totrans-4418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1018]'
- en: '`Infinity`'
  id: totrans-4419
  prefs: []
  type: TYPE_NORMAL
  zh: '`无穷大`'
- en: 'A value denoting numeric infinity ∞ ([Infinity](ch11.html#infinity "Infinity")):'
  id: totrans-4420
  prefs: []
  type: TYPE_NORMAL
  zh: 表示数值无穷大∞的值（[无穷大](ch11.html#infinity "无穷大"）：
- en: '[PRE1019]'
  id: totrans-4421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1019]'
- en: '* * *'
  id: totrans-4422
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[16](#id1065911)]) Mariusz Nowak (@medikoo) told me that code evaluated by
    `Function` is sloppy by default, everywhere.
  id: totrans-4423
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[16](#id1065911)]) Mariusz Nowak（@medikoo）告诉我，由`Function`评估的代码默认情况下在任何地方都是松散的。
- en: ^([[17](#id1069062)]) Thanks to Matthias Reuter (@gweax) and Philipp Kyeck (@pkyeck),
    who contributed to this section.
  id: totrans-4424
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[17](#id1069062)]) 感谢Matthias Reuter（@gweax）和Philipp Kyeck（@pkyeck）对本节的贡献。
- en: Chapter 24. Unicode and JavaScript
  id: totrans-4425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第24章. Unicode和JavaScript
- en: This chapter is a brief introduction to Unicode and how it is handled in JavaScript.
  id: totrans-4426
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对Unicode及其在JavaScript中的处理的简要介绍。
- en: Unicode History
  id: totrans-4427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unicode历史
- en: 'Unicode was started in 1987, by Joe Becker (Xerox), Lee Collins (Apple), and
    Mark Davis (Apple). The idea was to create a universal character set, as there
    were many incompatible standards for encoding plain text at that time: numerous
    variations of 8-bit ASCII, Big Five (Traditional Chinese), GB 2312 (Simplified
    Chinese), and more. Before Unicode, no standard for multilingual plain text existed,
    but there were rich-text systems (such as Apple’s WorldScript) that allowed you
    to combine multiple encodings.'
  id: totrans-4428
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode始于1987年，由Joe Becker（施乐），Lee Collins（苹果）和Mark Davis（苹果）发起。其想法是创建一个通用字符集，因为当时对于编码纯文本存在许多不兼容的标准：许多变体的8位ASCII，Big
    Five（繁体中文），GB 2312（简体中文）等。在Unicode之前，没有多语言纯文本的标准，但有丰富的文本系统（例如苹果的WorldScript），允许您组合多个编码。
- en: 'The first Unicode draft proposal was published in 1988\. Work continued afterward
    and the working group expanded. The [*Unicode Consortium*](http://www.unicode.org/consortium/consort.html)
    was incorporated on January 3, 1991:'
  id: totrans-4429
  prefs: []
  type: TYPE_NORMAL
  zh: 第一份Unicode草案提案于1988年发布。此后继续工作并扩大工作组。[*Unicode联盟*](http://www.unicode.org/consortium/consort.html)于1991年1月3日成立：
- en: The Unicode Consortium is a non-profit corporation devoted to developing, maintaining,
    and promoting software internationalization standards and data, particularly the
    Unicode Standard [...]
  id: totrans-4430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Unicode联盟是一家致力于开发、维护和推广软件国际化标准和数据的非营利性公司，特别是Unicode标准[...]
- en: The first volume of the Unicode 1.0 standard was published in October 1991,
    and the second in June 1992.
  id: totrans-4431
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 1.0标准的第一卷于1991年10月出版，第二卷于1992年6月出版。
- en: Important Unicode Concepts
  id: totrans-4432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重要的Unicode概念
- en: 'The idea of a character may seem a simple one, but there are many aspects to
    it. That’s why Unicode is such a complex standard. The following are important
    basic concepts:'
  id: totrans-4433
  prefs: []
  type: TYPE_NORMAL
  zh: 字符的概念可能看起来很简单，但它有许多方面。这就是为什么Unicode是一个如此复杂的标准。以下是重要的基本概念：
- en: Characters and graphemes
  id: totrans-4434
  prefs: []
  type: TYPE_NORMAL
  zh: 字符和字形
- en: These two terms mean something quite similar. Characters are digital entities,
    while graphemes are atomic units of written languages (alphabetic letters, typographic
    ligatures, Chinese characters, punctuation marks, etc.). Programmers think in
    characters, but users think in graphemes. Sometimes several characters are used
    to represent a single grapheme. For example, we can produce the single grapheme
    ô by combining the character *o* and the character ^ (the circumflex accent).
  id: totrans-4435
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个术语的意思相似。字符是数字实体，而字形是书面语言的原子单位（字母、印刷连字、中文字符、标点符号等）。程序员以字符为思考单位，而用户以字形为思考单位。有时需要使用多个字符来表示单个字形。例如，我们可以通过组合字符*o*和字符^（抑扬符）来产生单个字形ô。
- en: Glyph
  id: totrans-4436
  prefs: []
  type: TYPE_NORMAL
  zh: 字形
- en: This is a concrete way of displaying a grapheme. Sometimes, the same grapheme
    is displayed differently, depending on its context or other factors. For example,
    the graphemes *f* and *i* can be presented as a glyph *f* and a glyph *i*, connected
    by a ligature glyph, or without a ligature.
  id: totrans-4437
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种显示字形的具体方式。有时，相同的字形在不同的上下文或其他因素下显示方式不同。例如，字形*f*和*i*可以呈现为字形*f*和字形*i*，通过连字字形连接，或者没有连字。
- en: Code points
  id: totrans-4438
  prefs: []
  type: TYPE_NORMAL
  zh: 代码点
- en: Unicode represents the characters it supports via numbers called *code points*.
    The hexadecimal range of code points is 0x0 to 0x10FFFF (17 times 16 bits).
  id: totrans-4439
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode通过称为*代码点*的数字来表示它支持的字符。代码点的十六进制范围是0x0到0x10FFFF（17倍16位）。
- en: Code units
  id: totrans-4440
  prefs: []
  type: TYPE_NORMAL
  zh: 代码单元
- en: To store or transmit code points, we encode them as *code units*, pieces of
    data with a fixed length. The length is measured in bits and determined by an
    encoding scheme, of which Unicode has several—for example, UTF-8 and UTF-16\.
    The number in the name indicates the length of the code unit, in bits. If a code
    point is too large to fit into a single code unit, it must be broken up into multiple
    units; that is, the number of code units needed to represent a single code point
    can vary.
  id: totrans-4441
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储或传输代码点，我们将它们编码为*代码单元*，这是具有固定长度的数据片段。长度以位为单位，并由编码方案确定，Unicode有几种编码方案，例如UTF-8和UTF-16。名称中的数字表示代码单元的长度，以位为单位。如果一个代码点太大而无法适应单个代码单元，它必须被分解为多个单元；也就是说，表示单个代码点所需的代码单元数量可能会有所不同。
- en: BOM (byte order mark)
  id: totrans-4442
  prefs: []
  type: TYPE_NORMAL
  zh: BOM（字节顺序标记）
- en: 'If a code unit is larger than a single byte, byte ordering matters. The BOM
    is a single pseudocharacter (possibly encoded as multiple code units) at the beginning
    of a text that indicates whether the code units are *big endian* (most significant
    bytes come first) or *little endian* (least significant bytes come first). The
    default for texts without a BOM is big endian. The BOM also indicates the encoding
    that is used; it is different for UTF-8, UTF-16, and so on. Additionally, it serves
    as a marker for Unicode if web browsers have no other information regarding the
    encoding of a text. However, the BOM is not used very often, for several reasons:'
  id: totrans-4443
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个代码单元大于一个字节，字节顺序很重要。BOM是文本开头的一个伪字符（可能被编码为多个代码单元），指示代码单元是*大端*（最重要的字节在前）还是*小端*（最不重要的字节在前）。没有BOM的文本的默认值是大端。BOM还指示所使用的编码；对于UTF-8、UTF-16等编码是不同的。此外，如果Web浏览器没有关于文本编码的其他信息，它还可以作为Unicode的标记。然而，由于几个原因，BOM并不经常使用：
- en: UTF-8 is by far the most popular Unicode encoding and does not need a BOM, because
    there is only one way of ordering bytes.
  id: totrans-4444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF-8是迄今为止最流行的Unicode编码，不需要BOM，因为只有一种字节排序方式。
- en: Several character encodings specify a fixed byte ordering. Then a BOM must not
    be used. Examples include UTF-16BE (UTF-16 big endian), UTF-16LE, UTF-32BE, and
    UTF-32LE. This is a safer way of handling byte ordering, because metadata and
    data stay separate and can’t be mixed up.
  id: totrans-4445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几种字符编码规定了固定的字节顺序。那么就不应该使用BOM。例如UTF-16BE（UTF-16大端）、UTF-16LE、UTF-32BE和UTF-32LE。这是处理字节顺序的更安全的方式，因为元数据和数据保持分开，不会混淆。
- en: Normalization
  id: totrans-4446
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化
- en: Sometimes the same grapheme can be represented in several ways. For example,
    the grapheme ö can be represented as a single code point or as an *o* followed
    by a combining character ¨ (diaeresis, double dot). Normalization is about translating
    a text to a canonical representation; equivalent code points and sequences of
    code points are all translated to the same code point (or sequence of code points).
    That is useful for text processing (e.g., to search for text). Unicode specifies
    several normalizations.
  id: totrans-4447
  prefs: []
  type: TYPE_NORMAL
  zh: 有时相同的字形可以用几种方式表示。例如，字形ö可以表示为单个代码点，也可以表示为一个*o*后跟一个组合字符¨（分音符，双点）。规范化是将文本转换为规范表示的过程；等效的代码点和代码点序列都被转换为相同的代码点（或代码点序列）。这对于文本处理（例如搜索文本）很有用。Unicode规定了几种规范化。
- en: Character properties
  id: totrans-4448
  prefs: []
  type: TYPE_NORMAL
  zh: 字符属性
- en: 'Each Unicode character is assigned several properties by the specification,
    some of which are listed here:'
  id: totrans-4449
  prefs: []
  type: TYPE_NORMAL
  zh: 规范指定了规范的几个属性，其中一些列在这里：
- en: '*Name*. An English name, composed of uppercase letters A–Z, digits 0–9, hyphen
    (-), and <space>. Two examples:'
  id: totrans-4450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*名称*。一个由大写字母A-Z，数字0-9，连字符(-)和<空格>组成的英文名称。两个例子：'
- en: “λ” has the name “GREEK SMALL LETTER LAMBDA.”
  id: totrans-4451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “λ”的名称是“希腊小写字母λ”。
- en: “!” has the name “EXCLAMATION MARK.”
  id: totrans-4452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “!”的名称是“感叹号”。
- en: '[*General category*](http://bit.ly/1fwsjL9). Partitions characters into categories
    such as letter, uppercase letter, number, and punctuation.'
  id: totrans-4453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*一般类别*](http://bit.ly/1fwsjL9)。将字符分成字母、大写字母、数字和标点等类别。'
- en: '*Age*. With what version of Unicode was the character introduced (1.0, 1.1.,
    2.0, etc.)?'
  id: totrans-4454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*年龄*。该字符是在哪个版本的Unicode中引入的（1.0、1.1、2.0等）？'
- en: '*Deprecated*. Is the use of the character discouraged?'
  id: totrans-4455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*已弃用*。是否不鼓励使用该字符？'
- en: '*And many more*.'
  id: totrans-4456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*以及更多*。'
- en: Code Points
  id: totrans-4457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码点
- en: 'The range of the code points was initially 16 bits. With Unicode version 2.0
    (July 1996), it was expanded: it is now divided into 17 *planes*, numbered from
    0 to 16\. Each plane comprises 16 bits (in hexadecimal notation: 0x0000–0xFFFF).
    Thus, in the hexadecimal ranges that follow, digits beyond the four bottom ones
    contain the number of the plane.'
  id: totrans-4458
  prefs: []
  type: TYPE_NORMAL
  zh: 代码点的范围最初是16位。随着Unicode版本2.0（1996年7月）的扩展，它现在被分成了17个*平面*，编号从0到16。每个平面包括16位（十六进制表示法：0x0000–0xFFFF）。因此，在接下来的十六进制范围中，四个底部以外的数字包含了平面的编号。
- en: 'Plane 0, Basic Multilingual Plane (BMP): 0x0000–0xFFFF'
  id: totrans-4459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第0平面，基本多文种平面（BMP）：0x0000–0xFFFF
- en: 'Plane 1, Supplementary Multilingual Plane (SMP): 0x10000–0x1FFFF'
  id: totrans-4460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1平面，补充多语种平面（SMP）：0x10000–0x1FFFF
- en: 'Plane 2, Supplementary Ideographic Plane (SIP): 0x20000–0x2FFFF'
  id: totrans-4461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2平面，补充表意文字平面（SIP）：0x20000–0x2FFFF
- en: Planes 3–13, Unassigned
  id: totrans-4462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3–13平面，未分配
- en: 'Plane 14, Supplementary Special-Purpose Plane (SSP): 0xE0000–0xEFFFF'
  id: totrans-4463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第14平面，补充特殊用途平面（SSP）：0xE0000–0xEFFFF
- en: 'Planes 15–16, Supplementary Private Use Area (S PUA A/B): 0x0F0000–0x10FFFF'
  id: totrans-4464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第15–16平面，补充专用区域（S PUA A/B）：0x0F0000–0x10FFFF
- en: Planes 1–16 are called *supplementary planes* or *astral planes*.
  id: totrans-4465
  prefs: []
  type: TYPE_NORMAL
  zh: 第1–16平面称为*补充平面*或*星际平面*。
- en: Unicode Encodings
  id: totrans-4466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unicode编码
- en: '*UTF-32* (Unicode Transformation Format 32) is a format with 32-bit code units.
    Any code point can be encoded by a single code unit, making this the only fixed-length
    encoding; for other encodings, the number of units needed to encode a point varies.'
  id: totrans-4467
  prefs: []
  type: TYPE_NORMAL
  zh: '*UTF-32*（Unicode转换格式32）是一种具有32位代码单元的格式。任何代码点都可以由单个代码单元编码，使得这是唯一的固定长度编码；对于其他编码，编码一个点所需的单元数量是变化的。'
- en: '*UTF-16* is a format with 16-bit code units that needs one to two units to
    represent a code point. BMP code points can be represented by single code units.
    Higher code points are 20 bit (16 times 16 bits), after 0x10000 (the range of
    the BMP) is subtracted. These bits are encoded as two code units (a so-called
    *surrogate pair*):'
  id: totrans-4468
  prefs: []
  type: TYPE_NORMAL
  zh: '*UTF-16*是一种具有16位代码单元的格式，需要一个到两个单元来表示一个代码点。BMP代码点可以由单个代码单元表示。高代码点是20位（16乘以16位），在减去0x10000（BMP的范围）后。这些位被编码为两个代码单元（所谓的*代理对*）：'
- en: Leading surrogate
  id: totrans-4469
  prefs: []
  type: TYPE_NORMAL
  zh: 领先代理
- en: 'Most significant 10 bits: stored in the range 0xD800–0xDBFF. Also called *high-surrogate
    code unit*.'
  id: totrans-4470
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的10位：存储在范围0xD800–0xDBFF中。也称为*高代理代码单元*。
- en: Trailing surrogate
  id: totrans-4471
  prefs: []
  type: TYPE_NORMAL
  zh: 尾随代理
- en: 'Least significant 10 bits: stored in the range 0xDC00–0xDFFF. Also called *low-surrogate
    code unit*.'
  id: totrans-4472
  prefs: []
  type: TYPE_NORMAL
  zh: 最不重要的10位：存储在范围0xDC00–0xDFFF中。也称为*低代理代码单元*。
- en: 'The following table (adapted from Unicode Standard 6.2.0, Table 3-5) visualizes
    how the bits are distributed:'
  id: totrans-4473
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格（改编自Unicode标准6.2.0，表3-5）可视化了位的分布：
- en: '| Code point | UTF-16 code unit(s) |'
  id: totrans-4474
  prefs: []
  type: TYPE_TB
  zh: '| 代码点 | UTF-16代码单元 |'
- en: '| --- | --- |'
  id: totrans-4475
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| xxxxxxxxxxxxxxxx (16 bits) | xxxxxxxxxxxxxxxx |'
  id: totrans-4476
  prefs: []
  type: TYPE_TB
  zh: '| xxxxxxxxxxxxxxxx（16位）| xxxxxxxxxxxxxxxx |'
- en: '| pppppxxxxxxyyyyyyyyyy (21 bits = 5+6+10 bits) | 110110qqqqxxxxxx 110111yyyyyyyyyy
    (qqqq = ppppp − 1) |'
  id: totrans-4477
  prefs: []
  type: TYPE_TB
  zh: '| pppppxxxxxxyyyyyyyyyy（21位=5+6+10位）| 110110qqqqxxxxxx 110111yyyyyyyyyy（qqqq
    = ppppp − 1）|'
- en: 'To enable this encoding scheme, the BMP has a hole with unused code points
    whose range is 0xD800–0xDFFF. Therefore, the ranges of leading surrogates, trailing
    surrogates, and BMP code points are disjoint, making decoding robust in the face
    of errors. The following function encodes a code point as UTF-16 (later we’ll
    see an example of using it):'
  id: totrans-4478
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用这种编码方案，BMP有一个未使用的代码点范围为0xD800–0xDFFF的空隙。因此，领先代理、尾随代理和BMP代码点的范围是不相交的，使得在面对错误时解码更加健壮。以下函数将代码点编码为UTF-16（稍后我们将看到一个使用它的示例）：
- en: '[PRE1020]'
  id: totrans-4479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1020]'
- en: '*UCS-2*, a deprecated format, uses 16-bit code units to represent (only!) the
    code points of the BMP. When the range of Unicode code points expanded beyond
    16 bits, UTF-16 replaced UCS-2.'
  id: totrans-4480
  prefs: []
  type: TYPE_NORMAL
  zh: '*UCS-2*，一种已弃用的格式，使用16位代码单元来表示（仅！）BMP的代码点。当Unicode代码点的范围扩展到16位之外时，UTF-16取代了UCS-2。'
- en: '*UTF-8* has 8-bit code units. It builds a bridge between the legacy ASCII encoding
    and Unicode. ASCII has only 128 characters, whose numbers are the same as the
    first 128 Unicode code points. UTF-8 is backward compatible, because all ASCII
    codes are valid code units. In other words, a single code unit in the range 0–127
    encodes a single code point in the same range. Such code units are marked by their
    highest bit being zero. If, on the other hand, the highest bit is one, then more
    units will follow, to provide the additional bits for the higher code points.
    That leads to the following encoding scheme:'
  id: totrans-4481
  prefs: []
  type: TYPE_NORMAL
  zh: '*UTF-8*具有8位代码单元。它在传统ASCII编码和Unicode之间架起了一座桥梁。ASCII只有128个字符，其编号与前128个Unicode代码点相同。UTF-8是向后兼容的，因为所有ASCII代码都是有效的代码单元。换句话说，在范围0–127的单个代码单元中编码了相同范围内的单个代码点。这些代码单元的最高位为零。另一方面，如果最高位为1，则会跟随更多的单元，以为更高的代码点提供额外的位。这导致了以下编码方案：'
- en: '0000–007F: 0xxxxxxx (7 bits, stored in 1 byte)'
  id: totrans-4482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0000–007F：0xxxxxxx（7位，存储在1字节中）
- en: '0080–07FF: 110xxxxx, 10xxxxxx (5+6 bits = 11 bits, stored in 2 bytes)'
  id: totrans-4483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0080–07FF：110xxxxx，10xxxxxx（5+6位=11位，存储在2字节中）
- en: '0800–FFFF: 1110xxxx, 10xxxxxx, 10xxxxxx (4+6+6 bits = 16 bits, stored in 3
    bytes)'
  id: totrans-4484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0800–FFFF：1110xxxx，10xxxxxx，10xxxxxx（4+6+6位=16位，存储在3字节中）
- en: '10000–1FFFFF: 11110xxx, 10xxxxxx, 10xxxxxx, 10xxxxxx (3+6+6+6 bits = 21 bits,
    stored in 4 bytes). The highest code point is 10FFFF, so UTF-8 has some extra
    room.'
  id: totrans-4485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10000–1FFFFF：11110xxx，10xxxxxx，10xxxxxx，10xxxxxx（3+6+6+6位=21位，存储在4字节中）。最高代码点是10FFFF，因此UTF-8有一些额外的空间。
- en: If the highest bit is not 0, then the number of ones before the zero indicates
    how many code units there are in a sequence. All code units after the initial
    one have the bit prefix 10\. Therefore, the ranges of initial code units and subsequent
    code units are disjoint, which helps with recovering from encoding errors.
  id: totrans-4486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最高位不为0，则零之前的1的数量表示序列中有多少个代码单元。初始单元之后的所有单元都具有位前缀10。因此，初始代码单元和后续代码单元的范围是不相交的，这有助于从编码错误中恢复。
- en: UTF-8 has become the most popular Unicode format. Initially, its popularity
    was due to its backward compatibility with ASCII. Later, it gained traction because
    of its broad and consistent support across operating systems, programming environments,
    and applications.
  id: totrans-4487
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8已成为最流行的Unicode格式。最初，它之所以受欢迎，是因为它与ASCII的向后兼容性。后来，它因其在操作系统、编程环境和应用程序中的广泛和一致的支持而受到青睐。
- en: JavaScript Source Code and Unicode
  id: totrans-4488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript源代码和Unicode
- en: 'There are two ways in which JavaScript handles Unicode source code: internally
    (during parsing) and externally (while loading a file).'
  id: totrans-4489
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript处理Unicode源代码有两种方式：内部（在解析期间）和外部（在加载文件时）。
- en: Source Code Internally
  id: totrans-4490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内部源代码
- en: 'Internally, JavaScript source code is treated as a sequence of UTF-16 code
    units. According to [Section 6](http://ecma-international.org/ecma-262/5.1/#sec-6)
    of the EMCAScript specification:'
  id: totrans-4491
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，JavaScript源代码被视为一系列UTF-16代码单元。根据[第6节](http://ecma-international.org/ecma-262/5.1/#sec-6)的EMCAScript规范：
- en: ECMAScript source text is represented as a sequence of characters in the Unicode
    character encoding, version 3.0 or later. [...] ECMAScript source text is assumed
    to be a sequence of 16-bit code units for the purposes of this specification.
    [...] If an actual source text is encoded in a form other than 16-bit code units,
    it must be processed as if it was first converted to UTF-16.
  id: totrans-4492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ECMAScript源文本以Unicode字符编码的形式表示，版本为3.0或更高。[...] ECMAScript源文本被假定为本规范的目的是一系列16位代码单元。[...]
    如果实际源文本以除16位代码单元以外的形式编码，必须处理为首先转换为UTF-16。
- en: 'In identifiers, string literals, and regular expression literals, any code
    unit can also be expressed via a Unicode escape sequence `\uHHHH`, where `HHHH`
    are four hexadecimal digits. For example:'
  id: totrans-4493
  prefs: []
  type: TYPE_NORMAL
  zh: 在标识符、字符串文字和正则表达式文字中，任何代码单元也可以通过Unicode转义序列`\uHHHH`来表示，其中`HHHH`是四个十六进制数字。例如：
- en: '[PRE1021]'
  id: totrans-4494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1021]'
- en: That means that you can use Unicode characters in literals and variable names,
    without leaving the ASCII range in the source code.
  id: totrans-4495
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以在源代码中使用Unicode字符的文字和变量名，而不会离开ASCII范围。
- en: 'In string literals, an additional kind of escape is available: *hexadecimal
    escape sequences* with two-digit hexadecimal numbers that represent code units
    in the range 0x00–0xFF. For example:'
  id: totrans-4496
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串文字中，还有一种额外的转义可用：用两位十六进制数字表示的*十六进制转义序列*，表示范围在0x00-0xFF的代码单元。例如：
- en: '[PRE1022]'
  id: totrans-4497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1022]'
- en: Source Code Externally
  id: totrans-4498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部源代码
- en: 'While UTF-16 is used internally, JavaScript source code is usually not stored
    in that format. When a web browser loads a source file via a `<script>` tag, it
    determines the encoding [as follows](http://bit.ly/1fwstC9):'
  id: totrans-4499
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然内部使用UTF-16，但JavaScript源代码通常不以该格式存储。当Web浏览器通过`<script>`标签加载源文件时，它会确定编码[如下](http://bit.ly/1fwstC9)：
- en: If the file starts with a BOM, the encoding is a UTF variant, depending on what
    BOM is used.
  id: totrans-4500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件以BOM开头，则编码是UTF变体，取决于使用的BOM。
- en: 'Otherwise, if the file is loaded via HTTP(S), then the `Content-Type` header
    can specify an encoding, via the `charset` parameter. For example:'
  id: totrans-4501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果文件是通过HTTP(S)加载的，那么`Content-Type`头可以通过`charset`参数指定编码。例如：
- en: '[PRE1023]'
  id: totrans-4502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1023]'
- en: Tip
  id: totrans-4503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The correct *media type* (formerly known as *MIME type*) for JavaScript files
    is `application/javascript`. However, older browsers (e.g., Internet Explorer
    8 and earlier) work most reliably with `text/javascript`. Unfortunately, the [default
    value](http://bit.ly/1fwsvKe) for the attribute `type` of `<script>` tags is `text/javascript`.
    At least you can omit that attribute for JavaScript; there is no benefit in including
    it.
  id: totrans-4504
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript文件的正确*媒体类型*（以前称为*MIME类型*）是`application/javascript`。但是，较旧的浏览器（例如Internet
    Explorer 8及更早版本）最可靠地使用`text/javascript`。不幸的是，`<script>`标签的`type`属性的[默认值](http://bit.ly/1fwsvKe)是`text/javascript`。至少对于JavaScript，您可以省略该属性；包含它没有好处。
- en: Otherwise, if the `<script>` tag has the attribute `charset`, then that encoding
    is used. Even though the attribute `type` holds a valid media type, that type
    must not have the parameter `charset` (like in the aforementioned `Content-Type`
    header). That ensures that the values of `charset` and `type` don’t clash.
  id: totrans-4505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果`<script>`标签具有`charset`属性，则将使用该编码。即使属性`type`包含有效的媒体类型，该类型也不得具有参数`charset`（就像前述的`Content-Type`头）。这确保了`charset`和`type`的值不会冲突。
- en: 'Otherwise, the encoding of the document is used, in which the `<script>` tag
    resides. For example, this is the beginning of an HTML5 document, where a `<meta>`
    tag declares that the document is encoded as UTF-8:'
  id: totrans-4506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，使用包含`<script>`标签的文档的编码。例如，这是HTML5文档的开头，其中`<meta>`标签声明文档编码为UTF-8：
- en: '[PRE1024]'
  id: totrans-4507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1024]'
- en: It is highly recommended that you always specify an encoding. If you don’t,
    a locale-specific [default encoding](http://bit.ly/1oODGWp) is used. In other
    words, people will see the file differently in different countries. Only the lowest
    7 bits are relatively stable across locales.
  id: totrans-4508
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您始终指定编码。如果不指定，将使用特定于区域设置的[默认编码](http://bit.ly/1oODGWp)。换句话说，在不同国家，人们将以不同方式看待文件。只有最低的7位在各个区域设置中相对稳定。
- en: 'My recommendations can be summarized as follows:'
  id: totrans-4509
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议可以总结如下：
- en: For your own application, you can use Unicode. But you must specify the encoding
    of the app’s HTML page as UTF-8.
  id: totrans-4510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于您自己的应用程序，您可以使用Unicode。但必须将应用程序的HTML页面的编码指定为UTF-8。
- en: For libraries, it’s safest to release code that is ASCII (7 bit).
  id: totrans-4511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于库，最安全的做法是发布ASCII（7位）代码。
- en: 'Some minification tools can translate source with Unicode code points beyond
    7 bit to source that is “7-bit clean.” They do so by replacing non-ASCII characters
    with Unicode escapes. For example, the following invocation of [UglifyJS](https://github.com/mishoo/UglifyJS2)
    translates the file *test.js*:'
  id: totrans-4512
  prefs: []
  type: TYPE_NORMAL
  zh: 一些缩小工具可以将具有超出7位的Unicode代码点的源代码转换为“7位干净”的源代码。它们通过用Unicode转义替换非ASCII字符来实现。例如，以下调用[UglifyJS](https://github.com/mishoo/UglifyJS2)将文件*test.js*翻译为：
- en: '[PRE1025]'
  id: totrans-4513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1025]'
- en: 'The file *test.js* looks like this:'
  id: totrans-4514
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*test.js*如下所示：
- en: '[PRE1026]'
  id: totrans-4515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1026]'
- en: 'The output of UglifyJS looks like this:'
  id: totrans-4516
  prefs: []
  type: TYPE_NORMAL
  zh: UglifyJS的输出如下：
- en: '[PRE1027]'
  id: totrans-4517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1027]'
- en: 'Consider the following negative example. For a while, the library D3.js was
    published in UTF-8\. That caused an [error](https://github.com/mbostock/d3/issues/1195)
    when it was loaded from a page whose encoding was not UTF-8, because the code
    contained statements such as:'
  id: totrans-4518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1028]'
  id: totrans-4519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1028]'
- en: 'The identifiers π and ε were not decoded correctly and not recognized as valid
    variable names. Additionally, some string literals with code points beyond 7 bit
    weren’t decoded correctly either. As a workaround, you could load the code by
    adding the appropriate `charset` attribute to the `<script>` tag:'
  id: totrans-4520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1029]'
  id: totrans-4521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1029]'
- en: JavaScript Strings and Unicode
  id: totrans-4522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JavaScript string is a sequence of UTF-16 code units. According to the ECMAScript
    specification, [Section 8.4](http://ecma-international.org/ecma-262/5.1/#sec-8.4):'
  id: totrans-4523
  prefs: []
  type: TYPE_NORMAL
- en: When a String contains actual textual data, each element is considered to be
    a single UTF-16 code unit.
  id: totrans-4524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Escape Sequences
  id: totrans-4525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned before, you can use Unicode escape sequences and hexadecimal escape
    sequences in string literals. For example, you can produce the character ö by
    combining an *o* with a diaeresis (code point 0x0308):'
  id: totrans-4526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1030]'
  id: totrans-4527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1030]'
- en: This works in JavaScript command lines, such as web browser consoles and the
    Node.js REPL. You can also insert this kind of string into the DOM of a web page.
  id: totrans-4528
  prefs: []
  type: TYPE_NORMAL
- en: Refering to Astral Plane Characters via Escapes
  id: totrans-4529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many nice Unicode symbol tables on the Web. Take a look at Tim Whitlock’s
    [“Emoji Unicode Tables”](http://apps.timwhitlock.info/emoji/tables/unicode) and
    be amazed by how many symbols there are in modern Unicode fonts. None of the symbols
    in the table are images; they are all font glyphs. Let’s assume you want to display
    a Unicode character via JavaScript that is in an astral plane (obviously, there
    is a risk when doing so: not all fonts support all such characters). For example,
    consider a cow, code point 0x1F404: ![](images/spjs_24in01.png.jpg).'
  id: totrans-4530
  prefs: []
  type: TYPE_NORMAL
- en: 'You can copy the character and paste it directly into your Unicode-encoded
    JavaScript source:'
  id: totrans-4531
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/spjs_24in02.png)'
  id: totrans-4532
  prefs: []
  type: TYPE_IMG
- en: 'JavaScript engines will decode the source (which is most often in UTF-8) and
    create a string with two UTF-16 code units. Alternatively, you can compute the
    two code units yourself and use Unicode escape sequences. There are web apps that
    perform this computation, such as:'
  id: totrans-4533
  prefs: []
  type: TYPE_NORMAL
- en: '[UTF Converter](http://macchiato.com/unicode/convert.html)'
  id: totrans-4534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“JavaScript escapes”](http://mothereff.in/js-escapes) by Mathias Bynens'
  id: totrans-4535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The previously defined function `toUTF16` performs it, too:'
  id: totrans-4536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1031]'
  id: totrans-4537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1031]'
- en: 'The UTF-16 surrogate pair (0xD83D, 0xDC04) does indeed encode the cow:'
  id: totrans-4538
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/spjs_24in03.png)'
  id: totrans-4539
  prefs: []
  type: TYPE_IMG
- en: Counting Characters
  id: totrans-4540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a string contains a surrogate pair (two code units encoding a single code
    point), then the `length` property doesn’t count graphemes anymore. It counts
    code units:'
  id: totrans-4541
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/spjs_24in04.png)'
  id: totrans-4542
  prefs: []
  type: TYPE_IMG
- en: 'This can be fixed via libraries, such as Mathias Bynens’s [Punycode.js](https://github.com/bestiejs/punycode.js),
    which is bundled with Node.js:'
  id: totrans-4543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1032]'
  id: totrans-4544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1032]'
- en: Unicode Normalization
  id: totrans-4545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to search in strings or compare them, then you need to normalize—for
    example, via the library [unorm](https://github.com/walling/unorm) (by Bjarke
    Walling).
  id: totrans-4546
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Regular Expressions and Unicode
  id: totrans-4547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Support for Unicode in JavaScript’s regular expressions (see [Chapter 19](ch19.html
    "Chapter 19. Regular Expressions")) is very limited. For example, there is no
    way to match Unicode categories such as “uppercase letter.”
  id: totrans-4548
  prefs: []
  type: TYPE_NORMAL
- en: 'Line terminators influence matching. A line terminator is one of four characters,
    specified in the following table:'
  id: totrans-4549
  prefs: []
  type: TYPE_NORMAL
- en: '| Code unit | Name | Character escape sequence |'
  id: totrans-4550
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-4551
  prefs: []
  type: TYPE_TB
- en: '| \u000A | Line feed | `\n` |'
  id: totrans-4552
  prefs: []
  type: TYPE_TB
- en: '| \u000D | Carriage return | `\r` |'
  id: totrans-4553
  prefs: []
  type: TYPE_TB
- en: '| \u2028 | Line separator |  |'
  id: totrans-4554
  prefs: []
  type: TYPE_TB
- en: '| \u2029 | Paragraph separator |  |'
  id: totrans-4555
  prefs: []
  type: TYPE_TB
- en: 'The following regular expression constructs are based on Unicode:'
  id: totrans-4556
  prefs: []
  type: TYPE_NORMAL
- en: '`\s \S` (whitespace, nonwhitespace) have Unicode-based definitions:'
  id: totrans-4557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1033]'
  id: totrans-4558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1033]'
- en: '`.` (dot) matches all code units (not code points!) except line terminators.
    See the next section to learn how to match any code point.'
  id: totrans-4559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiline mode `/m`: In multiline mode, the assertion `^` matches at the beginning
    of the input and after line terminators. The assertion `$` matches before line
    terminators and at the end of the input. In nonmultiline mode, they match only
    at the beginning or the end of the input, respectively.'
  id: totrans-4560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other important character classes have definitions that are based on ASCII,
    not on Unicode:'
  id: totrans-4561
  prefs: []
  type: TYPE_NORMAL
- en: '`\d \D` (digits, nondigits): A digit is equivalent to `[0-9]`.'
  id: totrans-4562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\w \W` (word characters, nonword characters): A word character is equivalent
    to `[A-Za-z0-9_]`.'
  id: totrans-4563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\b \B` (at word breaks, inside words): Words are sequences of word characters
    (`[A-Za-z0-9_]`). For example, in the string `''über''`, the character class escape
    `\b` sees the character *b* as starting a word:'
  id: totrans-4564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1034]'
  id: totrans-4565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1034]'
- en: Matching Any Code Unit and Any Code Point
  id: totrans-4566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To match any code unit, you can use `[\s\S]`; see [Atoms: General](ch19.html#regex_atoms_general
    "Atoms: General").'
  id: totrans-4567
  prefs: []
  type: TYPE_NORMAL
- en: To match any code point, you need to use:^([[18](#ftn.id1072129)])
  id: totrans-4568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1035]'
  id: totrans-4569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1035]'
- en: 'The preceding pattern works like this:'
  id: totrans-4570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1036]'
  id: totrans-4571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1036]'
- en: As all of these ranges are disjoint, the pattern will correctly match code points
    in well-formed UTF-16 strings.
  id: totrans-4572
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  id: totrans-4573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A few libraries help with handling Unicode in JavaScript:'
  id: totrans-4574
  prefs: []
  type: TYPE_NORMAL
- en: '[Regenerate](https://github.com/mathiasbynens/regenerate) helps with generating
    ranges like the preceding one, for matching any code unit. It is meant to be used
    as part of a build tool, but also works dynamically, for trying out things.'
  id: totrans-4575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[XRegExp](http://xregexp.com) is a regular expression library that has an [official
    add-on](http://xregexp.com/plugins/#unicode) for matching Unicode categories,
    scripts, blocks, and properties via one of the following three constructs:'
  id: totrans-4576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1037]'
  id: totrans-4577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1037]'
- en: For example, `\p{Letter}` matches letters in various alphabets while `\p{^Letter}`
    and `\P{Letter}` both match all other code points. [Chapter 30](ch30.html "Chapter 30. Libraries")
    contains a brief overview of XRegExp.
  id: totrans-4578
  prefs: []
  type: TYPE_NORMAL
- en: The ECMAScript Internationalization API (see [The ECMAScript Internationalization
    API](ch30.html#i18n_api "The ECMAScript Internationalization API")) provides Unicode-aware
    collation (sorting and searching of strings) and more.
  id: totrans-4579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommended Reading and Chapter Sources
  id: totrans-4580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on Unicode, see the following:'
  id: totrans-4581
  prefs: []
  type: TYPE_NORMAL
- en: Wikipedia has several good entries on [Unicode](http://en.wikipedia.org/wiki/Unicode)
    and its terminology.
  id: totrans-4582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Unicode.org](http://www.unicode.org/), the official website of the Unicode
    Consortium, and its [FAQ](http://www.unicode.org/faq/) are also good resources.'
  id: totrans-4583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joel Spolsky’s introductory article [“The Absolute Minimum Every Software Developer
    Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)”](http://www.joelonsoftware.com/articles/Unicode.html)
    is helpful.
  id: totrans-4584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For information on Unicode support in JavaScript, see:'
  id: totrans-4585
  prefs: []
  type: TYPE_NORMAL
- en: '[“JavaScript’s internal character encoding: UCS-2 or UTF-16?”](http://mathiasbynens.be/notes/javascript-encoding)
    by Mathias Bynens'
  id: totrans-4586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“JavaScript, Regex, and Unicode”](http://bit.ly/1oOE0oh) by Steven Levithan'
  id: totrans-4587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acknowledgments
  id: totrans-4588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following people contributed to this chapter: Mathias Bynens (@mathias),
    Anne van Kesteren ‏(@annevk), and Calvin Metcalf ‏(@CWMma).'
  id: totrans-4589
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-4590
  prefs: []
  type: TYPE_NORMAL
- en: ^([[18](#id1072129)]) Strictly speaking, any [Unicode scalar value](http://www.unicode.org/glossary/#unicode_scalar_value).
  id: totrans-4591
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 25. New in ECMAScript 5
  id: totrans-4592
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter lists features that are available only in ECMAScript 5\. Should
    you have to work with older JavaScript engines, you should avoid these features
    or enable some of them via a library (how is described later). Note that normally,
    this book assumes that you are working with modern engines, which fully support
    ECMAScript 5.
  id: totrans-4593
  prefs: []
  type: TYPE_NORMAL
- en: 'The ECMAScript 5 specification contains the following description of its scope:'
  id: totrans-4594
  prefs: []
  type: TYPE_NORMAL
- en: The fifth edition of ECMAScript (published as ECMA-262 5th edition)
  id: totrans-4595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-4596
  prefs: []
  type: TYPE_NORMAL
- en: codifies de facto interpretations of the language specification that have become
    common among browser implementations and
  id: totrans-4597
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: adds support for new features that have emerged since the publication of the
    third edition. Such features include
  id: totrans-4598
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '>'
  id: totrans-4599
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-4600
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-4601
  prefs: []
  type: TYPE_NORMAL
- en: accessor properties,
  id: totrans-4602
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: reflective creation and inspection of objects,
  id: totrans-4603
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: program control of property attributes,
  id: totrans-4604
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: additional array manipulation functions,
  id: totrans-4605
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: support for the JSON object encoding format, and
  id: totrans-4606
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a strict mode that provides enhanced error checking and program security.
  id: totrans-4607
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: New Features
  id: totrans-4608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new features included in ECMAScript 5 are as follows:'
  id: totrans-4609
  prefs: []
  type: TYPE_NORMAL
- en: Strict mode (see [Strict Mode](ch07.html#strict_mode "Strict Mode"))
  id: totrans-4610
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting the following line first in a file or a function switches on the so-called
    *strict mode* that makes JavaScript a cleaner language by forbidding some features,
    performing more checks, and throwing more exceptions:'
  id: totrans-4611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1038]'
  id: totrans-4612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1038]'
- en: Accessors (see [Accessors (Getters and Setters)](ch17_split_000.html#getters_setters
    "Accessors (Getters and Setters)"))
  id: totrans-4613
  prefs: []
  type: TYPE_NORMAL
- en: 'Getters and setters allow you to implement the getting and setting of a property
    via methods. For example, the following object `obj` contains a getter for the
    property `foo`:'
  id: totrans-4614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1039]'
  id: totrans-4615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1039]'
- en: Syntactic Changes
  id: totrans-4616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ECMAScript 5 includes the following syntactic changes:'
  id: totrans-4617
  prefs: []
  type: TYPE_NORMAL
- en: Reserved words as property keys
  id: totrans-4618
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use reserved words (such as `new` and `function`) after the dot operator
    and as unquoted property keys in object literals:'
  id: totrans-4619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1040]'
  id: totrans-4620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1040]'
- en: Legal trailing commas
  id: totrans-4621
  prefs: []
  type: TYPE_NORMAL
- en: Trailing commas in object literals and array literals are legal.
  id: totrans-4622
  prefs: []
  type: TYPE_NORMAL
- en: Multiline string literals
  id: totrans-4623
  prefs: []
  type: TYPE_NORMAL
- en: String literals can span multiple lines if you escape the end of the line via
    a backslash.
  id: totrans-4624
  prefs: []
  type: TYPE_NORMAL
- en: New Functionality in the Standard Library
  id: totrans-4625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 5 brought several additions to JavaScript’s standard library. This
    section lists them by category.
  id: totrans-4626
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming
  id: totrans-4627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Getting and setting prototypes (see [Getting and Setting the Prototype](ch17_split_000.html#get_set_prototype
    "Getting and Setting the Prototype")):'
  id: totrans-4628
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.create()`'
  id: totrans-4629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.getPrototypeOf()`'
  id: totrans-4630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing property attributes via property descriptors (see [Property Descriptors](ch17_split_000.html#property_descriptors
    "Property Descriptors")):'
  id: totrans-4631
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.defineProperty()`'
  id: totrans-4632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.defineProperties()`'
  id: totrans-4633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.create()`'
  id: totrans-4634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.getOwnPropertyDescriptor()`'
  id: totrans-4635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Listing properties (see [Iteration and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties")):'
  id: totrans-4636
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.keys()`'
  id: totrans-4637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.getOwnPropertyNames()`'
  id: totrans-4638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Protecting objects (see [Protecting Objects](ch17_split_001.html#protecting_objects
    "Protecting Objects")):'
  id: totrans-4639
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.preventExtensions()`'
  id: totrans-4640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.isExtensible()`'
  id: totrans-4641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.seal()`'
  id: totrans-4642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.isSealed()`'
  id: totrans-4643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.freeze()`'
  id: totrans-4644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.isFrozen()`'
  id: totrans-4645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New `Function` method (see [Function.prototype.bind(thisValue, arg1?, ...,
    argN?)](ch17_split_000.html#Function.prototype.bind "Function.prototype.bind(thisValue,
    arg1?, ..., argN?)")):'
  id: totrans-4646
  prefs: []
  type: TYPE_NORMAL
- en: '`Function.prototype.bind()`'
  id: totrans-4647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New Methods
  id: totrans-4648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings (see [Chapter 12](ch12.html "Chapter 12. Strings")):'
  id: totrans-4649
  prefs: []
  type: TYPE_NORMAL
- en: New method `String.prototype.trim()`
  id: totrans-4650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access characters via the bracket operator `[...]`
  id: totrans-4651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New `Array` methods (see [Array Prototype Methods](ch18.html#array_prototype_methods
    "Array Prototype Methods")):'
  id: totrans-4652
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.isArray()`'
  id: totrans-4653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.every()`'
  id: totrans-4654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.filter()`'
  id: totrans-4655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.forEach()`'
  id: totrans-4656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.indexOf()`'
  id: totrans-4657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.lastIndexOf()`'
  id: totrans-4658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.map()`'
  id: totrans-4659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.reduce()`'
  id: totrans-4660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.some()`'
  id: totrans-4661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New `Date` methods (see [Date Prototype Methods](ch20.html#date_prototype_methods
    "Date Prototype Methods")):'
  id: totrans-4662
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.now()`'
  id: totrans-4663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toISOString()`'
  id: totrans-4664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON
  id: totrans-4665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Support for JSON (see [Chapter 22](ch22.html "Chapter 22. JSON")):'
  id: totrans-4666
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON.parse()` (see [JSON.parse(text, reviver?)](ch22.html#JSON.parse "JSON.parse(text,
    reviver?)"))'
  id: totrans-4667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON.stringify()` (see [JSON.stringify(value, replacer?, space?)](ch22.html#JSON.stringify
    "JSON.stringify(value, replacer?, space?)"))'
  id: totrans-4668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some built-in objects have special `toJSON()` methods:'
  id: totrans-4669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean.prototype.toJSON()`'
  id: totrans-4670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.prototype.toJSON()`'
  id: totrans-4671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.toJSON()`'
  id: totrans-4672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toJSON()`'
  id: totrans-4673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips for Working with Legacy Browsers
  id: totrans-4674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following resources will be useful if you need to work with legacy browsers:'
  id: totrans-4675
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要与旧版浏览器一起工作，以下资源将非常有用：
- en: A [compatibility table](http://kangax.github.io/es5-compat-table/) by Juriy
    Zaytsev (“kangax”) shows how much of ECMAScript 5 is supported by various versions
    of various browsers.
  id: totrans-4676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Juriy Zaytsev（“kangax”）的[兼容性表](http://kangax.github.io/es5-compat-table/)显示了各种浏览器的各个版本支持
    ECMAScript 5 的程度。
- en: '[es5-shim](https://github.com/kriskowal/es5-shim/) brings most (but not all)
    of ECMAScript 5’s functionality to browsers that support only ECMAScript 3.'
  id: totrans-4677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[es5-shim](https://github.com/kriskowal/es5-shim/) 将 ECMAScript 5 的大部分（但不是全部）功能带到只支持
    ECMAScript 3 的浏览器中。'

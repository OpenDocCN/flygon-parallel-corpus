- en: Part IV. Tips, Tools, and Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分。提示，工具和库
- en: This part gives tips for using JavaScript (best practices, advanced techniques,
    and learning resources) and describes a few important tools and libraries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分提供了使用JavaScript的技巧（最佳实践，高级技术和学习资源），并描述了一些重要的工具和库。
- en: Chapter 26. A Meta Code Style Guide
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第26章。元代码风格指南
- en: JavaScript has many great style guides. Thus, there is no need to write yet
    another one. Instead, this chapter describes meta style rules and surveys existing
    style guides and established best practices. It also mentions practices I like
    that are more controversial. The idea is to complement existing style guides rather
    than to replace them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有许多优秀的风格指南。因此，没有必要再写一个。相反，本章描述了元风格规则，并调查了现有的风格指南和已建立的最佳实践。它还提到了我喜欢的一些更有争议的做法。这个想法是为了补充现有的风格指南，而不是取代它们。
- en: Existing Style Guides
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现有的风格指南
- en: 'These are style guides that I like:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我喜欢的风格指南：
- en: '[Idiomatic.js: Principles of Writing Consistent, Idiomatic JavaScript](https://github.com/rwaldron/idiomatic.js/)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Idiomatic.js：编写一致的、惯用的JavaScript的原则](https://github.com/rwaldron/idiomatic.js/)'
- en: '[Google JavaScript Style Guide](http://bit.ly/1oOEfQ7)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Google JavaScript风格指南](http://bit.ly/1oOEfQ7)'
- en: '[jQuery JavaScript Style Guide](http://contribute.jquery.org/style-guide/js/)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[jQuery JavaScript风格指南](http://contribute.jquery.org/style-guide/js/)'
- en: '[Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Airbnb JavaScript风格指南](https://github.com/airbnb/javascript)'
- en: 'Additionally, there are two style guides that go meta:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个元风格指南：
- en: '[Popular Conventions on GitHub](http://sideeffect.kr/popularconvention/) analyzes
    GitHub code to find out which coding conventions are most frequently used.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GitHub上的流行约定](http://sideeffect.kr/popularconvention/)分析GitHub代码，找出最常用的编码约定。'
- en: '[JavaScript, the winning style](http://seravo.fi/2013/javascript-the-winning-style)
    examines what the majority of several popular style guides recommend.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JavaScript，获胜的风格](http://seravo.fi/2013/javascript-the-winning-style)检查了几种流行风格指南的大多数推荐。'
- en: General Tips
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般提示
- en: This section will cover some general code writing tips.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖一些一般的代码编写技巧。
- en: Code Should Be Consistent
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码应该一致
- en: 'There are two important rules for writing consistent code. The first rule is
    that, if you start a new project, you should come up with a style, document it,
    and follow it everywhere. The larger the team, the more important it is to check
    for adherence to the style automatically, via tools such as JSHint. When it comes
    to style, there are many decisions to make. Most of them have generally agreed-upon
    answers. Others have to be defined per project. For example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一致代码的两个重要规则。第一条规则是，如果你开始一个新项目，你应该想出一个风格，记录下来，并在任何地方都遵循它。团队越大，检查对风格的自动遵循就越重要，可以通过诸如JSHint之类的工具实现。在风格方面，有许多决定要做。其中大多数都有普遍认可的答案。其他必须根据项目定义。例如：
- en: How much whitespace (after parentheses, between statements, etc.)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少空格（括号后，语句之间等）
- en: Indentation (e.g., how many spaces per level of indentation)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进（例如，每级缩进多少空格）
- en: How and where to write `var` statements
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在哪里编写`var`语句
- en: The second rule is that, if you are joining an existing project, you should
    follow its rules rigorously (even if you don’t agree with them).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则是，如果你加入一个现有项目，你应该严格遵循它的规则（即使你不同意它们）。
- en: Code Should Be Easy to Understand
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码应该易于理解
- en: Everyone knows that debugging is twice as hard as writing a program in the first
    place. So if you are as clever as you can be when you write it, how will you ever
    debug it? —Brian Kernighan
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个人都知道调试比一开始编写程序要困难两倍。因此，如果你在编写时越聪明，那么你将如何调试呢？ ——Brian Kernighan
- en: 'For most code, the time used for reading it is much greater than the time used
    for writing it. It is thus important to make the former as easy as possible. Here
    are some guidelines for doing that:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数代码，用于阅读的时间远远大于用于编写的时间。因此，使前者尽可能简单非常重要。以下是一些指导方针：
- en: Shorter isn’t always better
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 更短并不总是更好
- en: Sometimes writing *more* means that things are actually faster to read. Let’s
    consider two examples. First, familiar things are easier to understand. That can
    mean that using familiar, slightly more verbose, constructs can be preferable.
    Second, humans read tokens, not characters. Therefore, `redBalloon` is easier
    to read than `rdBlln`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时写*更多*意味着事情实际上更容易阅读。让我们考虑两个例子。首先，熟悉的事物更容易理解。这意味着使用熟悉的、稍微更冗长的结构可能更可取。其次，人类读取标记，而不是字符。因此，`redBalloon`比`rdBlln`更容易阅读。
- en: Good code is like a textbook
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好的代码就像教科书
- en: 'Most code bases are filled with new ideas and concepts. That means that if
    you want to work with a code base, you need to learn those ideas and concepts.
    In contrast to textbooks, the added challenge with code is that people will not
    read it linearly. They will jump in anywhere and should be able to roughly understand
    what is going on. Three parts of a code base help:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码库都充满了新的想法和概念。这意味着如果你想要使用一个代码库，你需要学习这些想法和概念。与教科书相比，代码的额外挑战在于人们不会线性阅读它。他们会随时跳进来，应该能够大致理解发生了什么。代码库的三个部分有所帮助：
- en: '*Code* should explain *what* is happening; it should be self-explanatory. To
    write such code, use descriptive identifiers and break up long functions (or methods)
    into smaller subfunctions. If those functions are small enough and have meaningful
    names, you can often avoid comments.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码*应该解释*发生了什么；它应该是不言自明的。为了编写这样的代码，使用描述性标识符，并将长函数（或方法）分解为更小的子函数。如果这些函数足够小并且有意义的名称，你通常可以避免注释。'
- en: '*Comments* should explain *why* things are happening. If you need to know a
    concept to understand the code, you can either include the name of the concept
    in an identifier or mention it in a comment. Someone reading the code can then
    turn to the documentation to find out more about the concept.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注释*应该解释*为什么*事情发生。如果你需要了解一个概念才能理解代码，你可以在标识符中包含该概念的名称，或者在注释中提到它。阅读代码的人可以查阅文档，了解更多关于该概念的信息。'
- en: '*Documentation* should fill in the blanks left by the code and the comments.
    It should tell you how to get started with the code base and provide you with
    the big picture. It should also contain a glossary for all important concepts.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文档*应填补代码和注释留下的空白。它应该告诉你如何开始使用代码库，并为你提供大局观。它还应包含所有重要概念的词汇表。'
- en: Don’t be clever; don’t make me think
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不要聪明；不要让我思考
- en: There is a lot of clever code out there that uses in-depth knowledge of the
    language to achieve impressive terseness. Such code is usually like a puzzle and
    difficult to figure out. You will encounter the opinion that if people don’t understand
    such code, maybe they should really learn JavaScript first. But that’s not what
    this is about. No matter how clever you are, entering other people’s mental universes
    is always challenging. So simple code is not stupid, it’s code where most of the
    effort went into making everything easy to understand. Note that “other people”
    includes your future selves. I often find that clever thoughts I had in the past
    don’t make sense to my present self.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多巧妙的代码利用对语言的深入了解来实现令人印象深刻的简洁性。这样的代码通常像一个谜题，很难理解。你会遇到这样的观点，如果人们不理解这样的代码，也许他们真的应该先学习JavaScript。但这不是这篇文章要讨论的。无论你有多聪明，进入其他人的思维世界总是具有挑战性的。所以简单的代码并不愚蠢，它是大部分努力都花在让一切易于理解的代码。
- en: Avoid optimizing for speed or code size
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 避免为速度或代码大小进行优化
- en: Much cleverness is directed at these optimizations. However, you normally don’t
    need them. On one hand, JavaScript engines are becoming increasingly smart and
    automatically optimize the speed of code that follows established patterns. On
    the other hand, minification tools ([Chapter 32](ch32.html "Chapter 32. More Tools"))
    rewrite your code so that it is as small as possible. In both cases, tools are
    clever for you, so that you don’t have to be.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 许多巧妙的技巧都是针对这些优化的。然而，你通常不需要它们。一方面，JavaScript引擎变得越来越智能，自动优化遵循已建立模式的代码的速度。另一方面，缩小工具（[第32章](ch32.html
    "第32章。更多工具")）重写你的代码，使其尽可能小。在这两种情况下，工具都是为你聪明的，这样你就不必自己聪明了。
- en: Sometimes you have no choice but to optimize the performance of your code. If
    you do, be sure to measure and optimize the right pieces. In browsers, the problems
    are often related to DOM and HTML and not the language proper.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你别无选择，只能优化代码的性能。如果你这样做，请确保测量和优化正确的部分。在浏览器中，问题通常与DOM和HTML相关，而不是语言本身。
- en: Commonly Accepted Best Practices
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的最佳实践
- en: 'A majority of JavaScript programmers agree on the following best practices:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JavaScript程序员都同意以下最佳实践：
- en: Use strict mode. It makes JavaScript a cleaner language (see [Strict Mode](ch07.html#strict_mode
    "Strict Mode")).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用严格模式。它使JavaScript成为一种更清洁的语言（参见[严格模式](ch07.html#strict_mode "严格模式")）。
- en: Always use semicolons. Avoid the pitfalls of automatic semicolon insertion (see
    [Automatic Semicolon Insertion](ch07.html#automatic_semicolon_insertion "Automatic
    Semicolon Insertion")).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用分号。避免自动分号插入的陷阱（参见[自动分号插入](ch07.html#automatic_semicolon_insertion "自动分号插入")）。
- en: 'Always use strict equality (`===`) and strict inequality (`!==`). I recommend
    never deviating from this rule. I even prefer the first of the following two conditions,
    even though they are equivalent:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用严格相等（`===`）和严格不等（`!==`）。我建议永远不要偏离这个规则。即使它们是等价的，我甚至更喜欢以下两个条件中的第一个：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Either use only spaces or only tabs for indentation, but don’t mix them.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么只使用空格，要么只使用制表符进行缩进，但不要混合使用它们。
- en: 'Quoting strings: You can write string literals with either single quotes or
    double quotes in JavaScript. Single quotes are more common. They make it easier
    to work with HTML code (which normally has attribute values in double quotes).
    Other considerations are mentioned in [String Literals](ch12.html#quoting_strings
    "String Literals").'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用字符串：在JavaScript中，你可以用单引号或双引号写字符串文字。单引号更常见。它们使得处理HTML代码更容易（通常HTML代码中的属性值是双引号）。其他考虑因素在[字符串文字](ch12.html#quoting_strings
    "字符串文字")中提到。
- en: 'Avoid global variables ([Best Practice: Avoid Creating Global Variables](ch16.html#avoid_global_variables
    "Best Practice: Avoid Creating Global Variables")).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免全局变量（[最佳实践：避免创建全局变量](ch16.html#avoid_global_variables "最佳实践：避免创建全局变量")）。
- en: Brace Styles
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 括号样式
- en: 'In languages where braces delimit blocks of code, a brace style determines
    where you put those braces. Two brace styles are most common in C-like languages
    (such as Java and JavaScript): Allman style and 1TBS.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在大括号界定代码块的语言中，括号样式决定你放置这些括号的位置。在类C语言（如Java和JavaScript）中，有两种最常见的括号样式：Allman样式和1TBS。
- en: Allman style
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Allman样式
- en: 'If a statement contains a block, that block is considered as somewhat separate
    from the head of the statement: its opening brace is in a line of its own, at
    the same indentation level as the head. For example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个语句包含一个块，那么该块被认为与语句的头部有些分离：它的左大括号在自己的一行上，与头部的缩进级别相同。例如：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 1TBS (One True Brace Style)
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1TBS（真正的括号样式）
- en: 'Here, a block is more closely associated with the header of its statement;
    it starts after it, in the same line. The bodies of control flow statements are
    always put in braces, even if there is only a single statement. For example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个块与其语句的标题更紧密地关联在一起；它在同一行之后开始。控制流语句的主体总是放在大括号中，即使只有一个语句。例如：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '1TBS is a variant of the (older) K&R (Kernighan and Ritchie) style.^([[19](#ftn.id1074743)])
    In K&R style, functions are written in Allman style and braces are omitted where
    they are not necessary—for example, around single-statement `then` cases:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 1TBS是(Kernighan和Ritchie)样式的一个变体。在K&R样式中，函数以Allman样式编写，并且在不必要的情况下省略大括号，例如，在单语句`then`情况下：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: JavaScript
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JavaScript
- en: 'The de facto standard in the JavaScript world is 1TBS. It has been inherited
    from Java and most style guides recommend it. One reason for that is objective.
    If you return an object literal, you must put the opening brace in the same line
    as the keyword `return`, like this (otherwise, automatic semicolon insertion inserts
    a semicolon after `return`, meaning that nothing is returned; see [Pitfall: ASI
    can unexpectedly break up statements](ch07.html#asi_after_return "Pitfall: ASI
    can unexpectedly break up statements")):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'JavaScript世界中的事实标准是1TBS。它是从Java继承而来，大多数风格指南都推荐使用它。其中一个原因是客观的。如果你返回一个对象字面量，你必须将开括号放在与关键字`return`相同的行上，就像这样（否则，自动分号插入会在`return`后插入一个分号，意味着什么也没有返回；参见[Pitfall:
    ASI can unexpectedly break up statements](ch07.html#asi_after_return "Pitfall:
    ASI can unexpectedly break up statements")）：'
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Obviously, an object literal is not a code block, but things look more consistent
    and you are less likely to make mistakes if both are formatted the same way.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，对象字面量不是一个代码块，但如果两者格式化方式相同，看起来更一致，你犯错的可能性就更小。
- en: 'My personal style and preference is:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我的个人风格和偏好是：
- en: 1TBS (which implies that you use braces whenever possible).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1TBS（这意味着你应该尽可能使用大括号）。
- en: 'As an exception, I omit braces if a statement can be written in a single line.
    For example:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为例外，如果一个语句可以写在一行上，我会省略大括号。例如：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Prefer Literals to Constructors
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更喜欢字面量而不是构造函数
- en: 'Several literals produce objects that can also be created by constructors.
    However, the latter is normally the better choice:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 几个字面量产生的对象也可以通过构造函数创建。然而，后者通常是更好的选择：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Don’t ever use the constructor `Array` to create an array with given elements.
    [Initializing an array with elements (avoid!)](ch18.html#avoid_array_constructor
    "Initializing an array with elements (avoid!)") explains why:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用构造函数`Array`来创建具有给定元素的数组。[初始化具有元素的数组（避免！）](ch18.html#avoid_array_constructor
    "初始化具有元素的数组（避免！）")解释了原因：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Don’t Be Clever
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要聪明
- en: This section collects examples of unrecommended cleverness.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本节收集了一些不推荐的聪明用法。
- en: Conditional operator
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件运算符
- en: 'Don’t nest the conditional operator:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不要嵌套条件运算符：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Abbreviating if statements
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缩写if语句
- en: 'Don’t abbreviate `if` statements via logical operators:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不要通过逻辑运算符缩写`if`语句：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Increment operator
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 增量运算符
- en: 'If possible, use the increment operator (`++`) and the decrement operator (`--`)
    as statements; don’t use them as expressions. In the latter case, they return
    a value and while there is a mnemonic, you still need to think to figure out what
    is going on:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，使用增量运算符（`++`）和减量运算符（`--`）作为语句；不要将它们用作表达式。在后一种情况下，它们会返回一个值，虽然有一个助记符，但你仍然需要思考来弄清楚发生了什么：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Checking for undefined
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查未定义
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Starting with ECMAScript 5, the second way of checking is better. [Changing
    undefined](ch08.html#changing_undefined "Changing undefined") explains why.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从ECMAScript 5开始，第二种检查方式更好。[更改未定义](ch08.html#changing_undefined "更改未定义")解释了为什么。
- en: Converting a number to an integer
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将数字转换为整数
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The shift operator can be used to convert a number to an integer. However, it
    is usually better to use a more explicit alternative such as `Math.round()`. [Converting
    to Integer](ch11.html#converting_to_integer "Converting to Integer") gives an
    overview of all ways of converting to integer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 移位运算符可以用来将数字转换为整数。然而，通常最好使用更明确的替代方法，比如`Math.round()`。[转换为整数](ch11.html#converting_to_integer
    "转换为整数")概述了所有转换为整数的方法。
- en: Acceptable Cleverness
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可接受的聪明用法
- en: Sometimes you can be clever in JavaScript—if the cleverness has become an established
    pattern.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可以在JavaScript中很聪明——如果这种聪明已经成为一种已经建立的模式。
- en: Default values
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 默认值
- en: 'Using the Or (`||`) operator to provide default values is a common pattern—for
    example, for parameters:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用或（`||`）运算符提供默认值是一种常见的模式——例如，对于参数：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For details and more examples, consult [Pattern: providing a default value](ch10.html#default_via_or
    "Pattern: providing a default value").'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息和更多示例，请参阅[模式：提供默认值](ch10.html#default_via_or "模式：提供默认值")。
- en: Generic methods
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通用方法
- en: 'If you use methods generically, you can abbreviate `Object.prototype` as `{}`.
    The following two expressions are equivalent:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通用地使用方法，你可以将`Object.prototype`缩写为`{}`。以下两个表达式是等价的：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And `Array.prototype` can be abbreviated as `[]`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype`可以缩写为`[]`：'
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I’m ambivalent about this one. It is a hack (you are accessing a prototype property
    via an instance). But it reduces clutter, and I expect engines to eventually optimize
    this pattern.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个持观望态度。这是一个技巧（你正在通过一个实例访问原型属性）。但它减少了混乱，我期望引擎最终会优化这种模式。
- en: 'ECMAScript 5: trailing commas'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ECMAScript 5：尾随逗号
- en: 'Trailing commas in object literals are legal in ECMAScript 5:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 5中，对象字面量中的尾随逗号是合法的：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'ECMAScript 5: reserved words'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ECMAScript 5：保留字
- en: 'ECMAScript 5 also allows you to use reserved words (such as `new`) as property
    keys:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 5还允许你使用保留字（如`new`）作为属性键：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Controversial Rules
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有争议的规则
- en: Let’s look at some conventions I like that are a bit more controversial.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些我喜欢的、有点具有争议的惯例。
- en: Syntax
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法
- en: 'We’ll start with syntactic conventions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从语法惯例开始：
- en: Tight whitespace
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 紧凑的空格
- en: 'I like *relatively* tight whitespace. The model is written English: there are
    no spaces after an opening parenthesis and before a closing parenthesis. And there
    are spaces after commas:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢*相对*紧凑的空格。这个模型是用英语写的：在开括号后和闭括号前没有空格。逗号后有空格：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For anonymous functions, I follow Douglas Crockford’s rule of having a space
    after the keyword `function`. The rationale is that this is what a named function
    expression looks like if you remove the name:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于匿名函数，我遵循道格拉斯·克罗克福德的规则，在关键字`function`后面加一个空格。理由是，如果去掉名字，这就是一个命名函数表达式的样子：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Four spaces per indentation level
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个缩进级别四个空格
- en: Most code I am seeing uses spaces for indentation, because tabs are displayed
    so differently between applications and operating systems. I prefer four spaces
    per level of indentation, because that makes the indentation more visible.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到的大多数代码都使用空格缩进，因为制表符在应用程序和操作系统之间显示的方式有很大不同。我更喜欢每级缩进四个空格，因为这样缩进更加明显。
- en: Put the conditional operator in parentheses
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将条件操作符放在括号中
- en: 'This helps with reading, because it is easier to make out the scope of the
    operator:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于阅读，因为更容易确定操作符的范围：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Variables
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: 'Next, I’ll cover conventions for variables:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将介绍变量的约定：
- en: One variable declaration per line
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每行只声明一个变量
- en: 'I don’t declare multiple variables with a single declaration:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不要用单个声明声明多个变量：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The advantages of this approach are that deleting, inserting, and rearranging
    lines is simpler and the lines are automatically indented correctly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优势在于删除、插入和重新排列行更简单，行也会自动正确缩进。
- en: Keep variable declarations local
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 保持变量声明局部
- en: If your function isn’t too long (which it shouldn’t be, anyway), then you can
    afford to be less careful with regard to hoisting and pretend that `var` declarations
    are block-scoped. In other words, you can declare a variable in the context in
    which it is used (inside a loop, inside a `then` block or an `else` block, etc.).
    This kind of local encapsulation makes a code fragment easier to understand in
    isolation. It is also easier to remove the code fragment or to move it somewhere
    else.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数不太长（无论如何都不应该太长），那么你可以在提升方面放松一些，假装`var`声明是块作用域的。换句话说，你可以在使用变量的上下文中声明变量（在循环内，在`then`块或`else`块内等）。这种局部封装使得代码片段更容易理解。也更容易删除代码片段或将其移动到其他地方。
- en: If you are inside a block, stay inside that block
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个块内，就待在那个块内
- en: 'As an addendum to the previous rule: don’t declare the same variable twice,
    in two different blocks. For example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前一条规则的补充：不要在两个不同的块中声明相同的变量。例如：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code has the same effect and intention as the following code,
    which is why it should be written that way:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码和下面的代码有相同的效果和意图，所以应该这样写：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Object Orientation
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象
- en: Now we’ll cover conventions relating to object orientation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论与面向对象有关的约定。
- en: Prefer constructors over other instance creation patterns
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 优先使用构造函数而不是其他实例创建模式
- en: 'I recommend that you:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你：
- en: Always use constructors.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是使用构造函数。
- en: Always use `new` when creating an instance.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建实例时总是使用`new`。
- en: 'The main advantages of doing so are:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要优势是：
- en: Your code better fits into the JavaScript mainstream and is more likely to be
    portable between frameworks.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码更适合JavaScript主流，更有可能在不同框架之间移植。
- en: In modern engines, using instances of constructors is very fast (e.g., via [hidden
    classes](http://bit.ly/1oOEAlZ)).
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现代引擎中，使用构造函数的实例非常快（例如，通过[hidden classes](http://bit.ly/1oOEAlZ)）。
- en: Classes, the default inheritance construct in the upcoming ECMAScript 6, will
    be based on constructors.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在即将到来的ECMAScript 6中，类将是默认的继承构造。
- en: For constructors, it is important to use strict mode, because it protects you
    against forgetting the `new` operator for instantiation. And you should be aware
    that you can return any object in a constructor. More tips for using constructors
    are mentioned in [Tips for Implementing Constructors](ch17_split_001.html#constructor_tips
    "Tips for Implementing Constructors").
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构造函数，使用严格模式很重要，因为它可以防止你忘记实例化时使用`new`操作符。你应该知道你可以在构造函数中返回任何对象。有关使用构造函数的更多提示，请参阅[实现构造函数的提示](ch17_split_001.html#constructor_tips
    "Tips for Implementing Constructors")。
- en: Avoid closures for private data
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用闭包来处理私有数据
- en: If you want an object’s private data to be completely safe, you have to use
    closures. Otherwise, you can use normal properties. One common practice is to
    prefix the names of private properties with underscores. The problem with closures
    is that code becomes more complicated (unless you put all methods in the instance,
    which is unidiomatic and slow) and slower (accessing data in closures is currently
    slower than accessing properties). [Keeping Data Private](ch17_split_001.html#private_data_for_objects
    "Keeping Data Private") covers this topic in more detail.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望对象的私有数据完全安全，你必须使用闭包。否则，你可以使用普通属性。一个常见的做法是在私有属性的名称前加下划线。闭包的问题在于代码变得更加复杂（除非你将所有方法都放在实例中，这是不符合惯例且慢的），而且速度更慢（访问闭包中的数据目前比访问属性更慢）。[保持数据私有](ch17_split_001.html#private_data_for_objects
    "Keeping Data Private")更详细地介绍了这个主题。
- en: Write parens if a constructor has no arguments
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构造函数没有参数，写括号
- en: 'I find that such a constructor invocation looks cleaner with parentheses:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现这样的构造函数调用用括号看起来更清晰：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Be careful about operator precedence
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 小心操作符优先级
- en: 'Use parens so that two operators don’t compete with each other—the result is
    not always what you might expect:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号，这样两个操作符就不会相互竞争——结果并不总是你所期望的：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`instanceof` is especially tricky:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`特别棘手：'
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, I find method calls after a constructor unproblematic:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我发现构造函数后的方法调用并不成问题：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Miscellaneous
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杂项
- en: 'This section collects various tips:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分收集了各种提示：
- en: Coercing
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 强制转换
- en: 'Coerce a value to a type via `Boolean`, `Number`, `String()`, `Object()` (used
    as functions—never use those functions as constructors). The rationale is that
    this convention is more descriptive:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Boolean`、`Number`、`String()`、`Object()`（作为函数使用——永远不要将这些函数用作构造函数）将值强制转换为类型。理由是这种约定更具描述性：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Avoid `this` as an implicit parameter
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`this`作为隐式参数
- en: '`this` should refer only to the receiver of the current method invocation;
    it should not be abused as an implicit parameter. The rationale is that such functions
    are easier to call and understand. I also like to keep object-oriented and functional
    mechanisms separate:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`应该只指当前方法调用的接收者；不应滥用作为隐式参数。理由是这样的函数更容易调用和理解。我也喜欢保持面向对象和函数机制分开：'
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Check for the existence of a property via `in` and `hasOwnProperty` (see [Iteration
    and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties"))
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'This is more self-explanatory and safer than comparing with `undefined` or
    checking for truthiness:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Fail fast
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: If you can, it’s best to fail fast and to not fail silently. JavaScript is only
    so forgiving (e.g., division by zero), because the first version of ECMAScript
    did not have exceptions. For example, don’t coerce values; throw an exception.
    However, you have to find ways to recover gracefully from failure when your code
    is in production.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever you are considering a style question, ask yourself: what makes my
    code easier to understand? Resist the temptation to be clever and leave most of
    the mechanical cleverness to JavaScript engines and minifiers (see [Chapter 32](ch32.html
    "Chapter 32. More Tools")).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: ^([[19](#id1074743)]) Some people even say that they are synonyms, that 1TBS
    is a way to jokingly refer to K&R.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 27. Language Mechanisms for Debugging
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following three language constructs help with debugging. They should obviously
    be complemented by a proper debugger:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The `debugger` statement behaves like a breakpoint and launches the debugger.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`console.log(x)` logs the value `x` to the console of the JavaScript engine.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`console.trace()` prints a stack trace to the engine’s console.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The console API provides more debugging help and is documented in more detail
    in [The Console API](ch23.html#console_api "The Console API"). Exception handling
    is explained in [Chapter 14](ch14.html "Chapter 14. Exception Handling").
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 28. Subclassing Built-ins
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript’s built-in constructors are difficult to subclass. This chapter explains
    why and presents solutions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the phrase *subclass a built-in* and avoid the term *extend*, because
    it is taken in JavaScript:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing a built-in `A`
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Creating a subconstructor `B` of a given built-in constructor `A`. `B`’s instances
    are also instances of `A`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Extending an object `obj`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Copying one object’s properties to another one. Underscore.js [uses this term](http://underscorejs.org/#extend),
    continuing a tradition established by the Prototype framework.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two obstacles to subclassing a built-in: instances with internal
    properties and a constructor that can’t be called as a function.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Obstacle 1: Instances with Internal Properties'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most built-in constructors have instances with so-called *internal properties*
    (see [Kinds of Properties](ch17_split_000.html#kinds_of_properties "Kinds of Properties")),
    whose names are written in double square brackets, like this: `[[PrimitiveValue]]`.
    Internal properties are managed by the JavaScript engine and usually not directly
    accessible in JavaScript. The normal subclassing technique in JavaScript is to
    call a superconstructor as a function with the `this` of the subconstructor (see
    [Layer 4: Inheritance Between Constructors](ch17_split_001.html#constructor_inheritance
    "Layer 4: Inheritance Between Constructors")):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Most built-ins ignore the subinstance passed in as `this` (2), an obstacle
    that is described in the next section. Furthermore, adding internal properties
    to an existing instance (1) is in general impossible, because they tend to fundamentally
    change the instance’s nature. Hence, the call at (2) can’t be used to add internal
    properties. The following constructors have instances with internal properties:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Wrapper constructors
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Instances of `Boolean`, `Number`, and `String` wrap primitives. They all have
    the internal property `[[PrimitiveValue]]` whose value is returned by `valueOf()`;
    `String` has two additional instance properties:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '`Boolean`: Internal instance property `[[PrimitiveValue]]`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number`: Internal instance property `[[PrimitiveValue]]`.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`: Internal instance property `[[PrimitiveValue]]`, custom internal
    instance method `[[GetOwnProperty]]`, normal instance property `length`. `[[GetOwnProperty]]`
    enables indexed access of characters by reading from the wrapped string when an
    array index is used.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`：内部实例属性`[[PrimitiveValue]]`，自定义内部实例方法`[[GetOwnProperty]]`，普通实例属性`length`。`[[GetOwnProperty]]`使得可以通过使用数组索引时从包装字符串中读取字符来进行索引访问。'
- en: '`Array`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array`'
- en: The custom internal instance method `[[DefineOwnProperty]]` intercepts properties
    being set. It ensures that the `length` property works correctly, by keeping `length`
    up-to-date when array elements are added and by removing excess elements when
    `length` is made smaller.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的内部实例方法`[[DefineOwnProperty]]`拦截正在设置的属性。它确保`length`属性正常工作，通过在添加数组元素时保持`length`的最新状态，并在`length`变小时删除多余的元素。
- en: '`Date`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`'
- en: The internal instance property `[[PrimitiveValue]]` stores the time represented
    by a date instance (as the number of milliseconds since 1 January 1970 00:00:00
    UTC).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 内部实例属性`[[PrimitiveValue]]`存储由日期实例表示的时间（自1970年1月1日00:00:00 UTC以来的毫秒数）。
- en: '`Function`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function`'
- en: The internal instance property `[[Call]]` (the code to execute when an instance
    is called) and possibly others.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 内部实例属性`[[Call]]`（实例被调用时要执行的代码）和可能还有其他属性。
- en: '`RegExp`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegExp`'
- en: 'The internal instance property `[[Match]]`, plus two noninternal instance properties.
    From the ECMAScript specification:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 内部实例属性`[[Match]]`，以及两个非内部实例属性。来自ECMAScript规范：
- en: The value of the `[[Match]]` internal property is an implementation dependent
    representation of the Pattern of the `RegExp` object.
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`[[Match]]`内部属性的值是`RegExp`对象的模式的实现相关表示。'
- en: The only built-in constructors that don’t have internal properties are `Error`
    and `Object`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一没有内部属性的内置构造函数是`Error`和`Object`。
- en: Workaround for Obstacle 1
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决障碍1
- en: '`MyArray` is a subclass of of `Array`. It has a getter `size` that returns
    the actual elements in an array, ignoring holes (where `length` considers holes).
    The trick used to implement `MyArray` is that it creates an array instance and
    copies its methods into it:^([[20](#ftn.id1079971)])'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyArray`是`Array`的子类。它有一个getter `size`，返回数组中的实际元素，忽略了空洞（其中`length`考虑了空洞）。实现`MyArray`的技巧是创建一个数组实例，并将其方法复制到其中：^([[20](#ftn.id1079971)])'
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code uses the helper function `copyOwnPropertiesFrom()`, which is shown
    and explained in [Copying an Object](ch17_split_000.html#code_copyOwnPropertiesFrom
    "Copying an Object").
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用辅助函数`copyOwnPropertiesFrom()`，该函数在[Copying an Object](ch17_split_000.html#code_copyOwnPropertiesFrom
    "Copying an Object")中显示和解释。
- en: 'We do not call the `Array` constructor in line (1), because of a quirk: if
    it is called with a single parameter that is a number, the number does not become
    an element, but determines the length of an empty array (see [Initializing an
    array with elements (avoid!)](ch18.html#avoid_array_constructor "Initializing
    an array with elements (avoid!)")).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第（1）行不调用`Array`构造函数，因为有一个怪癖：如果它以一个数字作为单个参数调用，那么这个数字不会成为一个元素，而是确定一个空数组的长度（参见[Initializing
    an array with elements (avoid!)](ch18.html#avoid_array_constructor "Initializing
    an array with elements (avoid!)")）。
- en: 'Here is the interaction:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Caveats
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'Copying methods to an instance leads to redundancies that could be avoided
    with a prototype (if we had the option to use one). Additionally, `MyArray` creates
    objects that are not its instances:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法复制到实例会导致冗余，如果可以使用原型，则可以避免这种情况。此外，`MyArray`创建的对象不是其实例：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Obstacle 2: A Constructor That Can’t Be Called as a Function'
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 障碍2：无法将构造函数作为函数调用
- en: 'Even though `Error` and subclasses don’t have instances with internal properties,
    you still can’t subclass them easily, because the standard pattern for subclassing
    won’t work (repeated from earlier):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`Error`和子类没有具有内部属性的实例，您仍然无法轻松地对其进行子类化，因为子类化的标准模式不起作用（与之前重复）：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The problem is that `Error` always produces a new instance, even if called
    as a function (1); that is, it ignores the parameter `this` handed to it via `call()`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`Error`总是产生一个新实例，即使作为函数调用（1）；也就是说，它忽略了通过`call()`传递给它的`this`参数：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding interaction, `Error` returns an instance with own properties,
    but it’s a new instance, not `e`. The subclassing pattern would only work if `Error`
    added the own properties to `this` (`e`, in the preceding case).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的交互中，`Error`返回了一个具有自己属性的实例，但它是一个新实例，而不是`e`。如果`Error`将自己的属性添加到`this`（在前面的情况下是`e`），那么子类化模式将起作用。
- en: Workaround for Obstacle 2
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决障碍2
- en: 'Inside the subconstructor, create a new superinstance and copy its own properties
    to the subinstance:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在子构造函数内部，创建一个新的超级实例，并将其自己的属性复制到子实例中：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The helper function `copyOwnPropertiesFrom()` is shown in [Copying an Object](ch17_split_000.html#code_copyOwnPropertiesFrom
    "Copying an Object"). Trying out `MyError`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数`copyOwnPropertiesFrom()`在[Copying an Object](ch17_split_000.html#code_copyOwnPropertiesFrom
    "Copying an Object")中显示。尝试`MyError`：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'here is the output on Node.js:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Node.js上的输出：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `instanceof` relationship is as it should be:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`关系应该是正常的：'
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Another Solution: Delegation'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一种解决方案：委托
- en: 'Delegation is a very clean alternative to subclassing. For example, to create
    your own array constructor, you keep an array in a property:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是子类化的一个非常干净的替代方法。例如，要创建自己的数组构造函数，您可以在属性中保留一个数组：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The obvious limitation is that you can’t access elements of `MyArray` via square
    brackets; you must use methods to do so:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的限制是，您无法通过方括号访问`MyArray`的元素；您必须使用方法来这样做：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Normal methods of `Array.prototype` can be transferred via the following bit
    of metaprogramming:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下元编程的方法传递`Array.prototype`的普通方法：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We derive `MyArray` methods from `Array` methods by invoking them on the array
    `this.array` that is stored in instances of `MyArray`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在存储在`MyArray`实例中的数组`this.array`上调用它们，从`Array`方法派生`MyArray`方法。
- en: 'Using `MyArray`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MyArray`：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '* * *'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[20](#id1079971)]) Inspired by a blog post by [Ben Nadel](http://bit.ly/1oOERFo).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[20](#id1079971)])受[Ben Nadel](http://bit.ly/1oOERFo)的一篇博文的启发。
- en: 'Chapter 29. JSDoc: Generating API Documentation'
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第29章。JSDoc：生成API文档
- en: 'It is a common development problem: you have written JavaScript code that is
    to be used by others and need a nice-looking HTML documentation of its API. The
    de facto standard tool in the JavaScript world for generating API documentation
    is [*JSDoc*](http://usejsdoc.org).^([[21](#ftn.id1082503)]) It is modeled after
    its Java analog, JavaDoc.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的开发问题：您已经编写了JavaScript代码，其他人需要使用它，并且需要一个漂亮的HTML文档来描述其API。在JavaScript世界中生成API文档的事实标准工具是[*JSDoc*](http://usejsdoc.org)。^([[21](#ftn.id1082503)])
    它是模仿其Java模拟品JavaDoc而建立的。
- en: 'JSDoc takes JavaScript code with `/** */` comments (normal block comments that
    start with an asterisk) and produces HTML documentation for it. For example, given
    the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: JSDoc接受带有`/** */`注释的JavaScript代码（以星号开头的普通块注释）并为其生成HTML文档。例如，给定以下代码：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: the generated HTML looks as shown in [Figure 29-1](ch29.html#figjsdoc_screen
    "Figure 29-1. HTML output produced by JSDoc.") in a web browser.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的HTML在Web浏览器中显示如[图 29-1](ch29.html#figjsdoc_screen "图 29-1. JSDoc生成的HTML输出。")所示。
- en: '| ![HTML output produced by JSDoc.](images/spjs_3301.png.jpg) |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| ![JSDoc生成的HTML输出。](images/spjs_3301.png.jpg) |'
- en: Figure 29-1. HTML output produced by JSDoc.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 29-1. JSDoc生成的HTML输出。
- en: The [Readme](http://usejsdoc.org/about-jsdoc3.html) on the JSDoc website explains
    how to install and call this tool.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: JSDoc网站上的[自述文件](http://usejsdoc.org/about-jsdoc3.html)解释了如何安装和调用这个工具。
- en: The Basics of JSDoc
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSDoc的基础知识
- en: JSDoc is all about documenting *entities* (functions, methods, constructors,
    etc.). That is achieved via comments that precede the entities and start with
    `/**`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: JSDoc的全部内容都是关于文档化*实体*（函数、方法、构造函数等）。这是通过在实体之前的注释中实现的，这些注释以`/**`开头。
- en: Syntax
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法
- en: 'Let’s review the comment shown at the beginning:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下开头显示的注释：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This demonstrates some of the JSDoc syntax, which consists of the following
    pieces:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了一些JSDoc的语法，包括以下部分：
- en: JSDoc comment
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: JSDoc注释
- en: This is a JavaScript block comment whose first character is an asterisk. This
    creates the illusion that the token `/**` starts such a comment.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JavaScript块注释，其第一个字符是星号。这会产生一个假象，即`/**`标记开始了这样的注释。
- en: Tags
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 标签
- en: You structure comments by starting lines with *tags*, keywords that are prefixed
    with an @ symbol. `@param` is an example in the preceding code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以@符号为前缀的*标签*开始行来构造注释。在前面的代码中，`@param`就是一个例子。
- en: HTML
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: HTML
- en: You can freely use HTML in JSDoc comments. For example, `<tt>` displays a word
    in a monospaced font.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在JSDoc注释中自由使用HTML。例如，`<tt>`显示单词的等宽字体。
- en: Type annotations
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注释
- en: 'You can document the type of an entity via a type name in braces. Variations
    include:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过大括号中的类型名称来记录实体的类型。变化包括：
- en: 'Single type: `@param {string} name`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一类型：`@param {string} name`
- en: 'Multiple types: `@param {string|number} idCode`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种类型：`@param {string|number} idCode`
- en: 'Arrays of a type: `@param {string[]} names`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为数组：`@param {string[]} names`
- en: Namepaths
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 名称路径
- en: 'Inside JSDoc comments, so-called *namepaths* are used to refer to entities.
    The syntax of such paths is as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSDoc注释中，所谓的*namepaths*用于引用实体。这些路径的语法如下：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Classes* are usually (implemented by) constructors. Static members are, for
    example, properties of constructors. JSDoc has a broad definition of *instance
    member*. It means everything that can be accessed via an instance. Therefore,
    instance members include instance properties and prototype properties.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*类*通常（由）构造函数实现。静态成员是构造函数的属性。JSDoc对*实例成员*有一个广泛的定义。它意味着可以通过实例访问的一切。因此，实例成员包括实例属性和原型属性。'
- en: Naming Types
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名类型
- en: The types of entities are either primitive types or classes. The names of the
    former always start with lowercase letters; the names of the latter always start
    with uppercase letters. In other words, the type names of primitives are `boolean`,
    `number`, and `string`, just like the results returned by the `typeof` operator.
    That way, you cannot confuse strings (primitives) with instances of the constructor
    `String` (objects).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的类型要么是基本类型，要么是类。前者的名称总是以小写字母开头；后者的名称总是以大写字母开头。换句话说，基本类型的类型名称是`boolean`、`number`和`string`，就像`typeof`运算符返回的结果一样。这样，您就不会混淆字符串（基本类型）和构造函数`String`的实例（对象）。
- en: Basic Tags
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本标签
- en: 'Following are the basic metadata tags:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基本的元数据标签：
- en: '`@fileOverview description`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`@fileOverview description`'
- en: 'Marks a JSDoc comment that describes the whole file. For example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 标记描述整个文件的JSDoc注释。例如：
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`@author`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`@author`'
- en: Refers to who has written the entity being documented.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 指的是谁编写了正在被记录的实体。
- en: '`@deprecated`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`@deprecated`'
- en: Indicates that the entity is not supported anymore. It is a good practice to
    document what to use instead.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 指示实体不再受支持。记录应该使用什么是一个很好的做法。
- en: '`@example`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`@example`'
- en: 'Contains a code example illustrating how the given entity should be used:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一个代码示例，说明给定的实体应该如何使用：
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Basic tags for linking are as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 用于链接的基本标签如下：
- en: '`@see`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`@see`'
- en: 'Points to a related resource:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 指向相关资源：
- en: '[PRE50]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`{@link ...}`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`{@link ...}`'
- en: Works like `@see`, but can be used inside other tags.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 像`@see`一样工作，但可以在其他标签内使用。
- en: '`@requires resourceDescription`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`@requires resourceDescription`'
- en: Indicates a resource that the documented entity needs. The resource description
    is either a namepath or a natural language description.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 指示文档实体需要的资源。资源描述可以是名称路径或自然语言描述。
- en: 'Versioning tags include the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 版本标签包括以下内容：
- en: '`@version versionNumber`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`@version versionNumber`'
- en: 'Indicates the version of the documented entity. For example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 指示文档实体的版本。例如：
- en: '[PRE51]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`@since versionNumber`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`@since versionNumber`'
- en: 'Indicates since which version the documented entity has been available. For
    example:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 指示文档实体可用的版本。例如：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Documenting Functions and Methods
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档化函数和方法
- en: 'For functions and methods, you can document parameters, return values, and
    exceptions they may throw:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数和方法，您可以记录参数、返回值和可能抛出的异常：
- en: '`@param {paramType} paramName description`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`@param {paramType} paramName description`'
- en: 'Describes the parameter whose name is `paramName`. Type and description are
    optional. Here are some examples:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 描述了参数的名称为`paramName`。类型和描述是可选的。以下是一些例子：
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Advanced features:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 高级特性：
- en: 'Optional parameter:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数：
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Optional parameter with default value:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有默认值的可选参数：
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`@returns {returnType} description`'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`@returns {returnType} description`'
- en: Describes the return value of the function or method. Either type or description
    can be omitted.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 描述函数或方法的返回值。类型或描述可以省略。
- en: '`@throws {exceptionType} description`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`@throws {exceptionType} description`'
- en: Describes an exception that might be thrown during the execution of the function
    or method. Either type or description can be omitted.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 描述在函数或方法执行过程中可能抛出的异常。类型或描述可以省略。
- en: Inline Type Information (“Inline Doc Comments”)
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联类型信息（“内联文档注释”）
- en: 'There are two ways of providing type information for parameters and return
    values. First, you can add type annotations to `@param` and `@returns`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为参数和返回值提供类型信息有两种方式。首先，您可以在`@param`和`@returns`中添加类型注释：
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Second, you can inline the type information:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您可以内联类型信息：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Documenting Variables, Parameters, and Instance Properties
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录变量、参数和实例属性
- en: 'The following tags are used for documenting variables, parameters, and instance
    properties:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标签用于记录变量、参数和实例属性：
- en: '`@type {typeName}`'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`@type {typeName}`'
- en: 'What type does the documented variable have? For example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 所记录的变量的类型是什么？例如：
- en: '[PRE58]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This tag can also be used to document the return type of functions, but `@returns`
    is preferable in this case.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此标签也可用于记录函数的返回类型，但在这种情况下，`@returns`更可取。
- en: '`@constant`'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`@constant`'
- en: A flag that indicates that the documented variable has a constant value.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 指示所记录的变量具有常量值的标志。
- en: '[PRE59]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`@property {propType} propKey description`'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`@property {propType} propKey description`'
- en: 'Document an instance property in the constructor comment. For example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数注释中记录实例属性。例如：
- en: '[PRE60]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Alternatively, instance properties can be documented as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，实例属性可以如下记录：
- en: '[PRE61]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Which one of those styles to use is a matter of personal preference.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哪种风格取决于个人偏好。
- en: '`@default defaultValue`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`@default defaultValue`'
- en: 'What is the default value of a parameter or instance property? For example:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 参数或实例属性的默认值是什么？例如：
- en: '[PRE62]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Documenting Classes
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录类
- en: 'JSDoc distinguishes between classes and constructors. The former concept is
    more like a type, while a constructor is one way of implementing a class. JavaScript’s
    built-in means for defining classes are limited, which is why there are many APIs
    that help with this task. These APIs differ, often radically, so you have to help
    JSDoc with figuring out what is going on. The following tags let you do that:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: JSDoc区分类和构造函数。前者更像是一种类型，而构造函数是实现类的一种方式。JavaScript内置的定义类的方法有限，这就是为什么有许多API来帮助完成这个任务。这些API有所不同，通常差异很大，因此您必须帮助JSDoc弄清楚发生了什么。以下标签让您可以做到这一点：
- en: '`@constructor`'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`@constructor`'
- en: Marks a function as a constructor.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数标记为构造函数。
- en: '`@class`'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`@class`'
- en: Marks a variable or a function as a class. In the latter case, `@class` is a
    synonym for `@constructor`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量或函数标记为类。在后一种情况下，`@class`是`@constructor`的同义词。
- en: '`@constructs`'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`@constructs`'
- en: Records that a method sets up the instance data. If such a method exists, the
    class is documented there.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 记录方法设置实例数据。如果存在这样的方法，则在该类中记录。
- en: '`@lends namePath`'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`@lends namePath`'
- en: Specifies to which class the following object literal contributes. There are
    two ways of contributing.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 指定以下对象文字贡献给哪个类。有两种贡献的方式。
- en: '`@lends Person#`: The object literal contributes instance members to `Person`.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@lends Person#`：对象文字为`Person`贡献实例成员。'
- en: '`@lends Person`: The object literal contributes static members to `Person`.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@lends Person`：对象文字为`Person`贡献静态成员。'
- en: '`@memberof parentNamePath`'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`@memberof parentNamePath`'
- en: The documented entity is a member of the specified object. `@lends MyClass#`,
    applied to an object literal, has the same effect as marking each property of
    that literal with `@memberof MyClass#`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 所记录的实体是指定对象的成员。`@lends MyClass#`，应用于对象文字，与使用`@memberof MyClass#`标记该文字的每个属性具有相同的效果。
- en: 'The most common ways of defining a class are: via a constructor function, via
    an object literal, and via an object literal that has an `@constructs` method.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类最常见的方式是：通过构造函数、通过对象文字以及通过具有`@constructs`方法的对象文字。
- en: Defining a Class via a Constructor Function
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过构造函数定义类
- en: 'To define a class via a constructor function, you must mark the constructor
    function; otherwise, it will not be documented as a class. Capitalization alone
    does not mark a function as a constructor:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过构造函数定义类，必须标记构造函数；否则，它将不会被文档化为类。仅仅大小写不足以标记函数为构造函数：
- en: '[PRE63]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Defining a Class via an Object Literal
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过对象文字定义类
- en: 'To define a class via an object literal, you need two markers. First, you need
    to tell JSDoc that a given variable holds a class. Second, you need to mark an
    object literal as defining a class. You do the latter via the `@lends` tag:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过对象文字定义类，需要两个标记。首先，您需要告诉JSDoc给定的变量持有一个类。其次，您需要标记一个对象文字为定义类。您可以通过`@lends`标签来实现后者：
- en: '[PRE64]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Defining a Class via an Object Literal with an @constructs Method
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过具有@constructs方法的对象文字定义类
- en: 'If an object literal has an `@constructs` method, you need to tell JSDoc about
    it, so that it can find the documentation for the instance properties. The documentation
    of the class moves to that method:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象文字有一个`@constructs`方法，您需要告诉JSDoc关于它，这样它才能找到实例属性的文档。类的文档移到该方法中：
- en: '[PRE65]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you omit the `@lends`, you must specify which class the methods belong to:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略`@lends`，则必须指定方法属于哪个类：
- en: '[PRE66]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Subclassing
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子类化
- en: 'JavaScript has no built-in support for subclassing. When you subclass in your
    code (be it manually, be it via a library), you have to tell JSDoc what is going
    on:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有内置的子类化支持。当您在代码中进行子类化（无论是手动还是通过库），您必须告诉JSDoc发生了什么：
- en: '`@extends namePath`'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`@extends namePath`'
- en: 'Indicates that the documented class is the subclass of another one. For example:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 指示所记录的类是另一个类的子类的标志。例如：
- en: '[PRE67]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Other Useful Tags
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他有用的标签
- en: 'All of these tags are documented at the [JSDoc website](http://usejsdoc.org/):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些标签都在[JSDoc网站](http://usejsdoc.org/)上有文档：
- en: 'Modularity: `@module`, `@exports`, `@namespace`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom types (for virtual entities such as callbacks, whose signature you can
    document): `@typedef`, `@callback`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Legal matters: `@copyright`, `@license`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Various kinds of objects: `@mixin`, `@enum`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: ^([[21](#id1082503)]) The JSDoc website is the main source of this chapter;
    some examples are borrowed from it.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 30. Libraries
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter covers JavaScript libraries. It first explains what shims and polyfills
    are, two special kinds of libraries. Then it lists a few core libraries. Lastly,
    it points to additional library-related resources.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Shims Versus Polyfills
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shims and polyfills are libraries that retrofit newer functionality on older
    JavaScript engines:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: A *shim* is a library that brings a new API to an older environment, using only
    the means of that environment.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *polyfill* is a shim for a browser API. It typically checks if a browser
    supports an API. If it doesn’t, the polyfill installs its own implementation.
    That allows you to use the API in either case. The term *polyfill* comes from
    a home improvement product; according to [Remy Sharp](http://bit.ly/MmZZmZ):'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Polyfilla is a UK product known as Spackling Paste in the US. With that in
    mind: think of the browsers as a wall with cracks in it. These [polyfills] help
    smooth out the cracks and give us a nice smooth wall of browsers to work with.'
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examples include:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[“HTML5 Cross Browser Polyfills”](http://bit.ly/1oOGuTE): A list compiled by
    Paul Irish.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[es5-shim](http://bit.ly/1oOGxi4) is a (nonpolyfill) shim that retrofits ECMAScript 5
    features on ECMAScript 3 engines. It is purely language-related and makes just
    as much sense on Node.js as it does on browsers.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four Language Libraries
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following libraries are quite established and close to the language. It
    is useful to be aware of them:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'The ECMAScript Internationalization API helps with tasks related to internationalization:
    collation (sorting and searching strings), number formatting, and date and time
    formatting. The next section explains this API in more detail.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Underscore.js](http://underscorejs.org) complements JavaScript’s relatively
    sparse standard library with tool functions for arrays, objects, functions, and
    more. As Underscore predates ECMAScript 5, there is some overlap with the standard
    library. That is, however, a feature: on older browsers, you get functionality
    that is normally ECMAScript-5-only; on ECMAScript 5, the relevant functions simply
    forward to the standard library.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lo-Dash](http://lodash.com) is an alternative implementation of the Underscore.js
    API, with a few additional features. Check out the website to find out if it suits
    you better than Underscore.js.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[XRegExp](http://xregexp.com) is a regular expression library with several
    advanced features such as named captures and free-spacing (which allows you to
    spread out a regular expression across multiple lines and document per line).
    Behind the scenes, enhanced regular expressions are translated to normal regular
    expressions, meaning that you don’t pay a performance penalty for using XRegExp.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ECMAScript Internationalization API
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ECMAScript Internationalization API is a standard JavaScript API that helps
    with tasks related to internationalization: collation (sorting and searching strings),
    number formatting, and date and time formatting. This section gives a brief overview
    and points you to more reading material.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: The ECMAScript Internationalization API, Edition 1
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first edition of the API provides the following services:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '*Collation* supports two scenarios: sorting a set of strings and searching
    within a set of strings. Collation is parameterized by locale and aware of Unicode.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Number formatting*. Parameters include:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Style of formatting: decimal, currency (which one and how to refer to it is
    determined by other parameters), percent'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locale (directly specified or best fit, searched for via a matcher object)
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbering system (Western digits, Arabic digits, Thai digits, etc.)
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precision: number of integer digits, fraction digits, significant digits'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping separators on or off
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Date and time formatting*. Parameters include:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What information to format and in which style (short, long, numeric, etc.)
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A locale
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A time zone
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of the functionality is accessed via an object in the global variable
    `Intl`, but the API also augments the following methods:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.localeCompare`'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.prototype.toLocaleString`'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toLocaleString`'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toLocaleDateString`'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toLocaleTimeString`'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Kind of Standard Is It?
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The number of the standard “ECMAScript Internationalization API” (EIA) is ECMA-402\.
    It is hosted by Ecma International, the association that also hosts EMCA-262,
    the ECMAScript language specification. Both standards are maintained by TC39\.
    Therefore, EIA is as close to the language as you can get without being part of
    ECMA-262\. The API has been designed to work with both ECMAScript 5 and ECMAScript 6.
    A set of conformance tests complements the standard and ensures that the various
    implementations of the API are compatible (ECMA-262 has a similar test suite).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: When Can I Use It?
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most modern browsers already support it or are in the process of supporting
    it. David Storey has created a detailed [compatibility table](http://bit.ly/1oOGIdo)
    (indicating which browsers support which locales and more).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [specification](http://bit.ly/1oOGQth) of the ECMAScript Internationalization
    API is edited by Norbert Lindenberg. It is available in PDF, HTML, and EPUB format.
    Additionally, there are several comprehensive introductory articles:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[“The ECMAScript Internationalization API”](http://bit.ly/1oOGT8C) by Norbert
    Lindenberg'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“ECMAScript Internationalization API”](http://bit.ly/1oOGYcc) by David Storey'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Using the JavaScript Internationalization API”](http://bit.ly/1oOH2sz) by
    Marcos Caceres'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directories for JavaScript Resources
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section describes sites that collect information on JavaScript resources.
    There are several kinds of such directories.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a list of general directories for JavaScript:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[“JavaScriptOO: Every JavaScript project you should be looking into”](http://www.javascriptoo.com/)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JSDB](http://www.jsdb.io/): A collection of the best JavaScript libraries'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JSter](http://jster.net/): A catalog of JavaScript libraries and tools for
    development'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Master List of HTML5, JavaScript, and CSS Resources”](http://bit.ly/1oOH7MW)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specialized directories include:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[“Microjs: Fantastic Micro-Frameworks and Micro-libraries for Fun and Profit”](http://microjs.com/)'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Unheap: A tidy repository of jQuery plugins”](http://www.unheap.com/)'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Obviously, you can always directly browse the registries of package managers:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[npm](https://npmjs.org/) (Node Packaged Modules)'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bower](http://bower.io/)'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Directories for CDNs (content delivery networks) and CDN content include:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[jsDelivr](http://www.jsdelivr.com/): Free CDNs for JavaScript libraries, jQuery
    plug-ins, CSS frameworks, fonts, and more'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“cdnjs: The missing CDN for JavaScript and CSS”](http://cdnjs.com/) (hosts
    less popular libraries)'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acknowledgments
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following people contributed to this section: Kyle Simpson (@getify), Gildas
    Lormeau (@check_ca), Fredrik Sogaard (@fredrik_sogaard), Gene Loparco (@gloparco),
    Manuel Strehl (@m_strehl), and Elijah Manor (@elijahmanor).'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 31. Module Systems and Package Managers
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript does not have built-in support for modules, but the community has
    created impressive workarounds. To manage modules, you can use so-called *package
    managers*, which handle discovery, installation, dependency management, and more.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Module Systems
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two most important (and unfortunately incompatible) standards for JavaScript
    modules are:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS Modules (CJS)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'The dominant incarnation of this standard is [Node.js modules](http://nodejs.org/api/modules.html)
    (Node.js modules have a few features that go beyond CJS). Its characteristics
    include:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Compact syntax
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designed for synchronous loading
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Main use: server'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous Module Definition (AMD)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular implementation of this standard is [RequireJS](http://requirejs.org/).
    Its characteristics include:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Slightly more complicated syntax, enabling AMD to work without `eval()` or a
    static compilation step
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designed for asynchronous loading
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Main use: browsers'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package Managers
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to package managers, [npm](https://npmjs.org) (Node Packaged
    Modules) is the canonical choice for Node.js. For browsers, two options are popular
    (among others):'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[Bower](http://bower.io) is a package manager for the Web that supports both
    AMD and CJS.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Browserify](http://browserify.org) is a tool based on npm that compiles npm
    packages to something you can use in a browser.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick and Dirty Modules
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For normal web development, you should use a module system such as RequireJS
    or Browserify. However, sometimes you just want to put together a quick hack.
    Then the following simple module pattern can help:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The preceding is a module that is stored in the global variable `moduleName`.
    It does the following:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly imports a dependency (the module `otherModule`)
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a private function, `privateFunction`
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exports `publicFunction`
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the module on a web page, simply load its file and the files of its
    dependencies via `<script>` tags:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If no other module is accessed while a module is loaded (which is the case for
    `moduleName`), then the order in which modules are loaded does not matter.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are my comments and recommendations:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: I’ve used this module pattern for a while, until I found out that I hadn’t invented
    it and that it had an official name. Christian Heilmann popularized it and called
    it the [“revealing module pattern”](http://bit.ly/1c1InUg).
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use this pattern, keep it simple. Feel free to pollute the global scope
    with module names, but do try to find unique names. It’s only for hacks, so there
    is no need to get fancy (nested namespaces, modules split across multiple files,
    etc.).
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 32. More Tools
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Module systems and package managers are covered in [Chapter 31](ch31.html "Chapter 31. Module
    Systems and Package Managers"). But there are additional important categories
    of tools:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Linting
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'Lint tools analyze source code and report potential problems and style violations.
    Three popular ones are:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[JSLint](http://www.jslint.com) by Douglas Crockford'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JSHint](http://www.jshint.com) by Anton Kovalyov'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ESLint](https://github.com/nzakas/eslint) by Nicholas Zakas'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, a unit test framework runs on both of the two large JavaScript platforms—the
    browser and Node.js. Two important frameworks that do are:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[Jasmine](http://pivotal.github.io/jasmine/)'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[mocha](http://visionmedia.github.io/mocha/)'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minification
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript source code usually wastes space—variable names are longer than
    need be, there are comments, extra whitespace, and so on. A minification tool
    removes the waste and compiles code to smaller code. Some parts of the removal
    process are relatively complex (e.g., the renaming of variables to short names).
    Three popular minification tools are:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[UglifyJS](https://github.com/mishoo/UglifyJS2/)'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[YUI Compressor](https://github.com/yui/yuicompressor)'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Closure Compiler](https://developers.google.com/closure/compiler/)'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'For most projects, there are many operations that you need to apply to their
    artifacts: lint the code, compile code (compilation happens even in web projects—for
    example, to compile a CSS language such as LESS or Sass to plain CSS), minify
    code, and more. Build tools help you do that. Two classic examples are make for
    Unix and Ant for Java. Two popular build tools for JavaScript are [Grunt](http://gruntjs.com)
    and [Gulp](http://gulpjs.com/). One of their most intriguing features is that
    you can stay in JavaScript while working with them; they are both based on Node.js.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: A scaffolding tool sets up an empty project, preconfigures build files, and
    more. [Yo](https://github.com/yeoman/yo) is one such tool. It is part of the [Yeoman](http://yeoman.io)
    suite of tools for web development, which bundles yo, Bower, and Grunt.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 33. What to Do Next
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you know the JavaScript language, how do you proceed? What is the
    best way to get to know the whole ecosystem? Here are some suggestions:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[Frontend Rescue](http://uptodate.frontendrescue.org) is a site with tips to
    get you started with browser development.'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JSbooks](http://jsbooks.revolunet.com) links to a variety of free books on
    JavaScript and related technologies.'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twitter is a good tool for staying up-to-date with web development. Start with
    famous JavaScript people you know (e.g., the creator of your framework of choice)
    and continue from there; sooner or later, you will get plenty of ideas for who
    to follow next.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JSMentors](https://groups.google.com/forum/#!forum/jsmentors) is a forum dedicated
    to “helping developers become better JavaScript coders in a professional & non-confrontational
    environment.”'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from Twitter, there are many other interesting news sources to explore.
    The following are a few examples:'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Echo JS](http://www.echojs.com) is a community-driven news site focused on
    JavaScript and HTML5.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cooper Press](https://cooperpress.com) publishes several web-development-related
    email newsletters (disclaimer: I’m editor of the “JavaScript Weekly” newsletter).'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Open Web Platform Daily Digest](http://webplatformdaily.org/) contains daily
    lists of newsworthy links.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Best of JavaScript, HTML & CSS](http://flippinawesome.org/category/news/best-of/)
    is a weekly list of links.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JavaScript user groups](http://communityjs.org) are a fun and educational
    way of meeting like-minded people. Most of them assemble regularly, with talks
    and more.'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JavaScript conferences](http://lanyrd.com/topics/javascript/) are another
    good source of information. Many of them publish freely accessible videos of their
    talks online.'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you can also take a look at the book’s companion website, [SpeakingJS.com](http://speakingjs.com/),
    where I’ll occasionally publish material related to this book.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL

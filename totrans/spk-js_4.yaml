- en: Part IV. Tips, Tools, and Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part gives tips for using JavaScript (best practices, advanced techniques,
    and learning resources) and describes a few important tools and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 26. A Meta Code Style Guide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has many great style guides. Thus, there is no need to write yet
    another one. Instead, this chapter describes meta style rules and surveys existing
    style guides and established best practices. It also mentions practices I like
    that are more controversial. The idea is to complement existing style guides rather
    than to replace them.
  prefs: []
  type: TYPE_NORMAL
- en: Existing Style Guides
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are style guides that I like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Idiomatic.js: Principles of Writing Consistent, Idiomatic JavaScript](https://github.com/rwaldron/idiomatic.js/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Google JavaScript Style Guide](http://bit.ly/1oOEfQ7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[jQuery JavaScript Style Guide](http://contribute.jquery.org/style-guide/js/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are two style guides that go meta:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Popular Conventions on GitHub](http://sideeffect.kr/popularconvention/) analyzes
    GitHub code to find out which coding conventions are most frequently used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JavaScript, the winning style](http://seravo.fi/2013/javascript-the-winning-style)
    examines what the majority of several popular style guides recommend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General Tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will cover some general code writing tips.
  prefs: []
  type: TYPE_NORMAL
- en: Code Should Be Consistent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two important rules for writing consistent code. The first rule is
    that, if you start a new project, you should come up with a style, document it,
    and follow it everywhere. The larger the team, the more important it is to check
    for adherence to the style automatically, via tools such as JSHint. When it comes
    to style, there are many decisions to make. Most of them have generally agreed-upon
    answers. Others have to be defined per project. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: How much whitespace (after parentheses, between statements, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indentation (e.g., how many spaces per level of indentation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How and where to write `var` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second rule is that, if you are joining an existing project, you should
    follow its rules rigorously (even if you don’t agree with them).
  prefs: []
  type: TYPE_NORMAL
- en: Code Should Be Easy to Understand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Everyone knows that debugging is twice as hard as writing a program in the first
    place. So if you are as clever as you can be when you write it, how will you ever
    debug it? —Brian Kernighan
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For most code, the time used for reading it is much greater than the time used
    for writing it. It is thus important to make the former as easy as possible. Here
    are some guidelines for doing that:'
  prefs: []
  type: TYPE_NORMAL
- en: Shorter isn’t always better
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes writing *more* means that things are actually faster to read. Let’s
    consider two examples. First, familiar things are easier to understand. That can
    mean that using familiar, slightly more verbose, constructs can be preferable.
    Second, humans read tokens, not characters. Therefore, `redBalloon` is easier
    to read than `rdBlln`.
  prefs: []
  type: TYPE_NORMAL
- en: Good code is like a textbook
  prefs: []
  type: TYPE_NORMAL
- en: 'Most code bases are filled with new ideas and concepts. That means that if
    you want to work with a code base, you need to learn those ideas and concepts.
    In contrast to textbooks, the added challenge with code is that people will not
    read it linearly. They will jump in anywhere and should be able to roughly understand
    what is going on. Three parts of a code base help:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code* should explain *what* is happening; it should be self-explanatory. To
    write such code, use descriptive identifiers and break up long functions (or methods)
    into smaller subfunctions. If those functions are small enough and have meaningful
    names, you can often avoid comments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Comments* should explain *why* things are happening. If you need to know a
    concept to understand the code, you can either include the name of the concept
    in an identifier or mention it in a comment. Someone reading the code can then
    turn to the documentation to find out more about the concept.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Documentation* should fill in the blanks left by the code and the comments.
    It should tell you how to get started with the code base and provide you with
    the big picture. It should also contain a glossary for all important concepts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t be clever; don’t make me think
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of clever code out there that uses in-depth knowledge of the
    language to achieve impressive terseness. Such code is usually like a puzzle and
    difficult to figure out. You will encounter the opinion that if people don’t understand
    such code, maybe they should really learn JavaScript first. But that’s not what
    this is about. No matter how clever you are, entering other people’s mental universes
    is always challenging. So simple code is not stupid, it’s code where most of the
    effort went into making everything easy to understand. Note that “other people”
    includes your future selves. I often find that clever thoughts I had in the past
    don’t make sense to my present self.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid optimizing for speed or code size
  prefs: []
  type: TYPE_NORMAL
- en: Much cleverness is directed at these optimizations. However, you normally don’t
    need them. On one hand, JavaScript engines are becoming increasingly smart and
    automatically optimize the speed of code that follows established patterns. On
    the other hand, minification tools ([Chapter 32](ch32.html "Chapter 32. More Tools"))
    rewrite your code so that it is as small as possible. In both cases, tools are
    clever for you, so that you don’t have to be.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you have no choice but to optimize the performance of your code. If
    you do, be sure to measure and optimize the right pieces. In browsers, the problems
    are often related to DOM and HTML and not the language proper.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly Accepted Best Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A majority of JavaScript programmers agree on the following best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: Use strict mode. It makes JavaScript a cleaner language (see [Strict Mode](ch07.html#strict_mode
    "Strict Mode")).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use semicolons. Avoid the pitfalls of automatic semicolon insertion (see
    [Automatic Semicolon Insertion](ch07.html#automatic_semicolon_insertion "Automatic
    Semicolon Insertion")).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Always use strict equality (`===`) and strict inequality (`!==`). I recommend
    never deviating from this rule. I even prefer the first of the following two conditions,
    even though they are equivalent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Either use only spaces or only tabs for indentation, but don’t mix them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quoting strings: You can write string literals with either single quotes or
    double quotes in JavaScript. Single quotes are more common. They make it easier
    to work with HTML code (which normally has attribute values in double quotes).
    Other considerations are mentioned in [String Literals](ch12.html#quoting_strings
    "String Literals").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid global variables ([Best Practice: Avoid Creating Global Variables](ch16.html#avoid_global_variables
    "Best Practice: Avoid Creating Global Variables")).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brace Styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In languages where braces delimit blocks of code, a brace style determines
    where you put those braces. Two brace styles are most common in C-like languages
    (such as Java and JavaScript): Allman style and 1TBS.'
  prefs: []
  type: TYPE_NORMAL
- en: Allman style
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a statement contains a block, that block is considered as somewhat separate
    from the head of the statement: its opening brace is in a line of its own, at
    the same indentation level as the head. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 1TBS (One True Brace Style)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here, a block is more closely associated with the header of its statement;
    it starts after it, in the same line. The bodies of control flow statements are
    always put in braces, even if there is only a single statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '1TBS is a variant of the (older) K&R (Kernighan and Ritchie) style.^([[19](#ftn.id1074743)])
    In K&R style, functions are written in Allman style and braces are omitted where
    they are not necessary—for example, around single-statement `then` cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The de facto standard in the JavaScript world is 1TBS. It has been inherited
    from Java and most style guides recommend it. One reason for that is objective.
    If you return an object literal, you must put the opening brace in the same line
    as the keyword `return`, like this (otherwise, automatic semicolon insertion inserts
    a semicolon after `return`, meaning that nothing is returned; see [Pitfall: ASI
    can unexpectedly break up statements](ch07.html#asi_after_return "Pitfall: ASI
    can unexpectedly break up statements")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, an object literal is not a code block, but things look more consistent
    and you are less likely to make mistakes if both are formatted the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'My personal style and preference is:'
  prefs: []
  type: TYPE_NORMAL
- en: 1TBS (which implies that you use braces whenever possible).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an exception, I omit braces if a statement can be written in a single line.
    For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Prefer Literals to Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several literals produce objects that can also be created by constructors.
    However, the latter is normally the better choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t ever use the constructor `Array` to create an array with given elements.
    [Initializing an array with elements (avoid!)](ch18.html#avoid_array_constructor
    "Initializing an array with elements (avoid!)") explains why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Don’t Be Clever
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section collects examples of unrecommended cleverness.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Don’t nest the conditional operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Abbreviating if statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Don’t abbreviate `if` statements via logical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Increment operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If possible, use the increment operator (`++`) and the decrement operator (`--`)
    as statements; don’t use them as expressions. In the latter case, they return
    a value and while there is a mnemonic, you still need to think to figure out what
    is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Checking for undefined
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Starting with ECMAScript 5, the second way of checking is better. [Changing
    undefined](ch08.html#changing_undefined "Changing undefined") explains why.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a number to an integer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The shift operator can be used to convert a number to an integer. However, it
    is usually better to use a more explicit alternative such as `Math.round()`. [Converting
    to Integer](ch11.html#converting_to_integer "Converting to Integer") gives an
    overview of all ways of converting to integer.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptable Cleverness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you can be clever in JavaScript—if the cleverness has become an established
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Default values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using the Or (`||`) operator to provide default values is a common pattern—for
    example, for parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For details and more examples, consult [Pattern: providing a default value](ch10.html#default_via_or
    "Pattern: providing a default value").'
  prefs: []
  type: TYPE_NORMAL
- en: Generic methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you use methods generically, you can abbreviate `Object.prototype` as `{}`.
    The following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And `Array.prototype` can be abbreviated as `[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I’m ambivalent about this one. It is a hack (you are accessing a prototype property
    via an instance). But it reduces clutter, and I expect engines to eventually optimize
    this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'ECMAScript 5: trailing commas'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Trailing commas in object literals are legal in ECMAScript 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'ECMAScript 5: reserved words'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ECMAScript 5 also allows you to use reserved words (such as `new`) as property
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Controversial Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at some conventions I like that are a bit more controversial.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll start with syntactic conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: Tight whitespace
  prefs: []
  type: TYPE_NORMAL
- en: 'I like *relatively* tight whitespace. The model is written English: there are
    no spaces after an opening parenthesis and before a closing parenthesis. And there
    are spaces after commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For anonymous functions, I follow Douglas Crockford’s rule of having a space
    after the keyword `function`. The rationale is that this is what a named function
    expression looks like if you remove the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Four spaces per indentation level
  prefs: []
  type: TYPE_NORMAL
- en: Most code I am seeing uses spaces for indentation, because tabs are displayed
    so differently between applications and operating systems. I prefer four spaces
    per level of indentation, because that makes the indentation more visible.
  prefs: []
  type: TYPE_NORMAL
- en: Put the conditional operator in parentheses
  prefs: []
  type: TYPE_NORMAL
- en: 'This helps with reading, because it is easier to make out the scope of the
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, I’ll cover conventions for variables:'
  prefs: []
  type: TYPE_NORMAL
- en: One variable declaration per line
  prefs: []
  type: TYPE_NORMAL
- en: 'I don’t declare multiple variables with a single declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The advantages of this approach are that deleting, inserting, and rearranging
    lines is simpler and the lines are automatically indented correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Keep variable declarations local
  prefs: []
  type: TYPE_NORMAL
- en: If your function isn’t too long (which it shouldn’t be, anyway), then you can
    afford to be less careful with regard to hoisting and pretend that `var` declarations
    are block-scoped. In other words, you can declare a variable in the context in
    which it is used (inside a loop, inside a `then` block or an `else` block, etc.).
    This kind of local encapsulation makes a code fragment easier to understand in
    isolation. It is also easier to remove the code fragment or to move it somewhere
    else.
  prefs: []
  type: TYPE_NORMAL
- en: If you are inside a block, stay inside that block
  prefs: []
  type: TYPE_NORMAL
- en: 'As an addendum to the previous rule: don’t declare the same variable twice,
    in two different blocks. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code has the same effect and intention as the following code,
    which is why it should be written that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Object Orientation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll cover conventions relating to object orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer constructors over other instance creation patterns
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend that you:'
  prefs: []
  type: TYPE_NORMAL
- en: Always use constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use `new` when creating an instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main advantages of doing so are:'
  prefs: []
  type: TYPE_NORMAL
- en: Your code better fits into the JavaScript mainstream and is more likely to be
    portable between frameworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In modern engines, using instances of constructors is very fast (e.g., via [hidden
    classes](http://bit.ly/1oOEAlZ)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes, the default inheritance construct in the upcoming ECMAScript 6, will
    be based on constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For constructors, it is important to use strict mode, because it protects you
    against forgetting the `new` operator for instantiation. And you should be aware
    that you can return any object in a constructor. More tips for using constructors
    are mentioned in [Tips for Implementing Constructors](ch17_split_001.html#constructor_tips
    "Tips for Implementing Constructors").
  prefs: []
  type: TYPE_NORMAL
- en: Avoid closures for private data
  prefs: []
  type: TYPE_NORMAL
- en: If you want an object’s private data to be completely safe, you have to use
    closures. Otherwise, you can use normal properties. One common practice is to
    prefix the names of private properties with underscores. The problem with closures
    is that code becomes more complicated (unless you put all methods in the instance,
    which is unidiomatic and slow) and slower (accessing data in closures is currently
    slower than accessing properties). [Keeping Data Private](ch17_split_001.html#private_data_for_objects
    "Keeping Data Private") covers this topic in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Write parens if a constructor has no arguments
  prefs: []
  type: TYPE_NORMAL
- en: 'I find that such a constructor invocation looks cleaner with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Be careful about operator precedence
  prefs: []
  type: TYPE_NORMAL
- en: 'Use parens so that two operators don’t compete with each other—the result is
    not always what you might expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`instanceof` is especially tricky:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, I find method calls after a constructor unproblematic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Miscellaneous
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section collects various tips:'
  prefs: []
  type: TYPE_NORMAL
- en: Coercing
  prefs: []
  type: TYPE_NORMAL
- en: 'Coerce a value to a type via `Boolean`, `Number`, `String()`, `Object()` (used
    as functions—never use those functions as constructors). The rationale is that
    this convention is more descriptive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Avoid `this` as an implicit parameter
  prefs: []
  type: TYPE_NORMAL
- en: '`this` should refer only to the receiver of the current method invocation;
    it should not be abused as an implicit parameter. The rationale is that such functions
    are easier to call and understand. I also like to keep object-oriented and functional
    mechanisms separate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Check for the existence of a property via `in` and `hasOwnProperty` (see [Iteration
    and Detection of Properties](ch17_split_000.html#iterate_and_detect_properties
    "Iteration and Detection of Properties"))
  prefs: []
  type: TYPE_NORMAL
- en: 'This is more self-explanatory and safer than comparing with `undefined` or
    checking for truthiness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Fail fast
  prefs: []
  type: TYPE_NORMAL
- en: If you can, it’s best to fail fast and to not fail silently. JavaScript is only
    so forgiving (e.g., division by zero), because the first version of ECMAScript
    did not have exceptions. For example, don’t coerce values; throw an exception.
    However, you have to find ways to recover gracefully from failure when your code
    is in production.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever you are considering a style question, ask yourself: what makes my
    code easier to understand? Resist the temptation to be clever and leave most of
    the mechanical cleverness to JavaScript engines and minifiers (see [Chapter 32](ch32.html
    "Chapter 32. More Tools")).'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[19](#id1074743)]) Some people even say that they are synonyms, that 1TBS
    is a way to jokingly refer to K&R.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 27. Language Mechanisms for Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following three language constructs help with debugging. They should obviously
    be complemented by a proper debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: The `debugger` statement behaves like a breakpoint and launches the debugger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`console.log(x)` logs the value `x` to the console of the JavaScript engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`console.trace()` prints a stack trace to the engine’s console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The console API provides more debugging help and is documented in more detail
    in [The Console API](ch23.html#console_api "The Console API"). Exception handling
    is explained in [Chapter 14](ch14.html "Chapter 14. Exception Handling").
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 28. Subclassing Built-ins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript’s built-in constructors are difficult to subclass. This chapter explains
    why and presents solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the phrase *subclass a built-in* and avoid the term *extend*, because
    it is taken in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing a built-in `A`
  prefs: []
  type: TYPE_NORMAL
- en: Creating a subconstructor `B` of a given built-in constructor `A`. `B`’s instances
    are also instances of `A`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending an object `obj`
  prefs: []
  type: TYPE_NORMAL
- en: Copying one object’s properties to another one. Underscore.js [uses this term](http://underscorejs.org/#extend),
    continuing a tradition established by the Prototype framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two obstacles to subclassing a built-in: instances with internal
    properties and a constructor that can’t be called as a function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obstacle 1: Instances with Internal Properties'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most built-in constructors have instances with so-called *internal properties*
    (see [Kinds of Properties](ch17_split_000.html#kinds_of_properties "Kinds of Properties")),
    whose names are written in double square brackets, like this: `[[PrimitiveValue]]`.
    Internal properties are managed by the JavaScript engine and usually not directly
    accessible in JavaScript. The normal subclassing technique in JavaScript is to
    call a superconstructor as a function with the `this` of the subconstructor (see
    [Layer 4: Inheritance Between Constructors](ch17_split_001.html#constructor_inheritance
    "Layer 4: Inheritance Between Constructors")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Most built-ins ignore the subinstance passed in as `this` (2), an obstacle
    that is described in the next section. Furthermore, adding internal properties
    to an existing instance (1) is in general impossible, because they tend to fundamentally
    change the instance’s nature. Hence, the call at (2) can’t be used to add internal
    properties. The following constructors have instances with internal properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapper constructors
  prefs: []
  type: TYPE_NORMAL
- en: 'Instances of `Boolean`, `Number`, and `String` wrap primitives. They all have
    the internal property `[[PrimitiveValue]]` whose value is returned by `valueOf()`;
    `String` has two additional instance properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Boolean`: Internal instance property `[[PrimitiveValue]]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number`: Internal instance property `[[PrimitiveValue]]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`: Internal instance property `[[PrimitiveValue]]`, custom internal
    instance method `[[GetOwnProperty]]`, normal instance property `length`. `[[GetOwnProperty]]`
    enables indexed access of characters by reading from the wrapped string when an
    array index is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array`'
  prefs: []
  type: TYPE_NORMAL
- en: The custom internal instance method `[[DefineOwnProperty]]` intercepts properties
    being set. It ensures that the `length` property works correctly, by keeping `length`
    up-to-date when array elements are added and by removing excess elements when
    `length` is made smaller.
  prefs: []
  type: TYPE_NORMAL
- en: '`Date`'
  prefs: []
  type: TYPE_NORMAL
- en: The internal instance property `[[PrimitiveValue]]` stores the time represented
    by a date instance (as the number of milliseconds since 1 January 1970 00:00:00
    UTC).
  prefs: []
  type: TYPE_NORMAL
- en: '`Function`'
  prefs: []
  type: TYPE_NORMAL
- en: The internal instance property `[[Call]]` (the code to execute when an instance
    is called) and possibly others.
  prefs: []
  type: TYPE_NORMAL
- en: '`RegExp`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The internal instance property `[[Match]]`, plus two noninternal instance properties.
    From the ECMAScript specification:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `[[Match]]` internal property is an implementation dependent
    representation of the Pattern of the `RegExp` object.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The only built-in constructors that don’t have internal properties are `Error`
    and `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: Workaround for Obstacle 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MyArray` is a subclass of of `Array`. It has a getter `size` that returns
    the actual elements in an array, ignoring holes (where `length` considers holes).
    The trick used to implement `MyArray` is that it creates an array instance and
    copies its methods into it:^([[20](#ftn.id1079971)])'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the helper function `copyOwnPropertiesFrom()`, which is shown
    and explained in [Copying an Object](ch17_split_000.html#code_copyOwnPropertiesFrom
    "Copying an Object").
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not call the `Array` constructor in line (1), because of a quirk: if
    it is called with a single parameter that is a number, the number does not become
    an element, but determines the length of an empty array (see [Initializing an
    array with elements (avoid!)](ch18.html#avoid_array_constructor "Initializing
    an array with elements (avoid!)")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Caveats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Copying methods to an instance leads to redundancies that could be avoided
    with a prototype (if we had the option to use one). Additionally, `MyArray` creates
    objects that are not its instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Obstacle 2: A Constructor That Can’t Be Called as a Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though `Error` and subclasses don’t have instances with internal properties,
    you still can’t subclass them easily, because the standard pattern for subclassing
    won’t work (repeated from earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that `Error` always produces a new instance, even if called
    as a function (1); that is, it ignores the parameter `this` handed to it via `call()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding interaction, `Error` returns an instance with own properties,
    but it’s a new instance, not `e`. The subclassing pattern would only work if `Error`
    added the own properties to `this` (`e`, in the preceding case).
  prefs: []
  type: TYPE_NORMAL
- en: Workaround for Obstacle 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the subconstructor, create a new superinstance and copy its own properties
    to the subinstance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper function `copyOwnPropertiesFrom()` is shown in [Copying an Object](ch17_split_000.html#code_copyOwnPropertiesFrom
    "Copying an Object"). Trying out `MyError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'here is the output on Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `instanceof` relationship is as it should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Another Solution: Delegation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Delegation is a very clean alternative to subclassing. For example, to create
    your own array constructor, you keep an array in a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The obvious limitation is that you can’t access elements of `MyArray` via square
    brackets; you must use methods to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Normal methods of `Array.prototype` can be transferred via the following bit
    of metaprogramming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We derive `MyArray` methods from `Array` methods by invoking them on the array
    `this.array` that is stored in instances of `MyArray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `MyArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[20](#id1079971)]) Inspired by a blog post by [Ben Nadel](http://bit.ly/1oOERFo).
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 29. JSDoc: Generating API Documentation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is a common development problem: you have written JavaScript code that is
    to be used by others and need a nice-looking HTML documentation of its API. The
    de facto standard tool in the JavaScript world for generating API documentation
    is [*JSDoc*](http://usejsdoc.org).^([[21](#ftn.id1082503)]) It is modeled after
    its Java analog, JavaDoc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSDoc takes JavaScript code with `/** */` comments (normal block comments that
    start with an asterisk) and produces HTML documentation for it. For example, given
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: the generated HTML looks as shown in [Figure 29-1](ch29.html#figjsdoc_screen
    "Figure 29-1. HTML output produced by JSDoc.") in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '| ![HTML output produced by JSDoc.](images/spjs_3301.png.jpg) |'
  prefs: []
  type: TYPE_TB
- en: Figure 29-1. HTML output produced by JSDoc.
  prefs: []
  type: TYPE_NORMAL
- en: The [Readme](http://usejsdoc.org/about-jsdoc3.html) on the JSDoc website explains
    how to install and call this tool.
  prefs: []
  type: TYPE_NORMAL
- en: The Basics of JSDoc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSDoc is all about documenting *entities* (functions, methods, constructors,
    etc.). That is achieved via comments that precede the entities and start with
    `/**`.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s review the comment shown at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This demonstrates some of the JSDoc syntax, which consists of the following
    pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: JSDoc comment
  prefs: []
  type: TYPE_NORMAL
- en: This is a JavaScript block comment whose first character is an asterisk. This
    creates the illusion that the token `/**` starts such a comment.
  prefs: []
  type: TYPE_NORMAL
- en: Tags
  prefs: []
  type: TYPE_NORMAL
- en: You structure comments by starting lines with *tags*, keywords that are prefixed
    with an @ symbol. `@param` is an example in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: HTML
  prefs: []
  type: TYPE_NORMAL
- en: You can freely use HTML in JSDoc comments. For example, `<tt>` displays a word
    in a monospaced font.
  prefs: []
  type: TYPE_NORMAL
- en: Type annotations
  prefs: []
  type: TYPE_NORMAL
- en: 'You can document the type of an entity via a type name in braces. Variations
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Single type: `@param {string} name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple types: `@param {string|number} idCode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arrays of a type: `@param {string[]} names`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namepaths
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside JSDoc comments, so-called *namepaths* are used to refer to entities.
    The syntax of such paths is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*Classes* are usually (implemented by) constructors. Static members are, for
    example, properties of constructors. JSDoc has a broad definition of *instance
    member*. It means everything that can be accessed via an instance. Therefore,
    instance members include instance properties and prototype properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Naming Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The types of entities are either primitive types or classes. The names of the
    former always start with lowercase letters; the names of the latter always start
    with uppercase letters. In other words, the type names of primitives are `boolean`,
    `number`, and `string`, just like the results returned by the `typeof` operator.
    That way, you cannot confuse strings (primitives) with instances of the constructor
    `String` (objects).
  prefs: []
  type: TYPE_NORMAL
- en: Basic Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the basic metadata tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@fileOverview description`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Marks a JSDoc comment that describes the whole file. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`@author`'
  prefs: []
  type: TYPE_NORMAL
- en: Refers to who has written the entity being documented.
  prefs: []
  type: TYPE_NORMAL
- en: '`@deprecated`'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates that the entity is not supported anymore. It is a good practice to
    document what to use instead.
  prefs: []
  type: TYPE_NORMAL
- en: '`@example`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Contains a code example illustrating how the given entity should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Basic tags for linking are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@see`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Points to a related resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`{@link ...}`'
  prefs: []
  type: TYPE_NORMAL
- en: Works like `@see`, but can be used inside other tags.
  prefs: []
  type: TYPE_NORMAL
- en: '`@requires resourceDescription`'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates a resource that the documented entity needs. The resource description
    is either a namepath or a natural language description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Versioning tags include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@version versionNumber`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indicates the version of the documented entity. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`@since versionNumber`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indicates since which version the documented entity has been available. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Documenting Functions and Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For functions and methods, you can document parameters, return values, and
    exceptions they may throw:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@param {paramType} paramName description`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Describes the parameter whose name is `paramName`. Type and description are
    optional. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Advanced features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Optional parameter with default value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`@returns {returnType} description`'
  prefs: []
  type: TYPE_NORMAL
- en: Describes the return value of the function or method. Either type or description
    can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: '`@throws {exceptionType} description`'
  prefs: []
  type: TYPE_NORMAL
- en: Describes an exception that might be thrown during the execution of the function
    or method. Either type or description can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Inline Type Information (“Inline Doc Comments”)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways of providing type information for parameters and return
    values. First, you can add type annotations to `@param` and `@returns`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, you can inline the type information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Documenting Variables, Parameters, and Instance Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following tags are used for documenting variables, parameters, and instance
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@type {typeName}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'What type does the documented variable have? For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This tag can also be used to document the return type of functions, but `@returns`
    is preferable in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '`@constant`'
  prefs: []
  type: TYPE_NORMAL
- en: A flag that indicates that the documented variable has a constant value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`@property {propType} propKey description`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Document an instance property in the constructor comment. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, instance properties can be documented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Which one of those styles to use is a matter of personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: '`@default defaultValue`'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the default value of a parameter or instance property? For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Documenting Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSDoc distinguishes between classes and constructors. The former concept is
    more like a type, while a constructor is one way of implementing a class. JavaScript’s
    built-in means for defining classes are limited, which is why there are many APIs
    that help with this task. These APIs differ, often radically, so you have to help
    JSDoc with figuring out what is going on. The following tags let you do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@constructor`'
  prefs: []
  type: TYPE_NORMAL
- en: Marks a function as a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`@class`'
  prefs: []
  type: TYPE_NORMAL
- en: Marks a variable or a function as a class. In the latter case, `@class` is a
    synonym for `@constructor`.
  prefs: []
  type: TYPE_NORMAL
- en: '`@constructs`'
  prefs: []
  type: TYPE_NORMAL
- en: Records that a method sets up the instance data. If such a method exists, the
    class is documented there.
  prefs: []
  type: TYPE_NORMAL
- en: '`@lends namePath`'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies to which class the following object literal contributes. There are
    two ways of contributing.
  prefs: []
  type: TYPE_NORMAL
- en: '`@lends Person#`: The object literal contributes instance members to `Person`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@lends Person`: The object literal contributes static members to `Person`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@memberof parentNamePath`'
  prefs: []
  type: TYPE_NORMAL
- en: The documented entity is a member of the specified object. `@lends MyClass#`,
    applied to an object literal, has the same effect as marking each property of
    that literal with `@memberof MyClass#`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common ways of defining a class are: via a constructor function, via
    an object literal, and via an object literal that has an `@constructs` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Class via a Constructor Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To define a class via a constructor function, you must mark the constructor
    function; otherwise, it will not be documented as a class. Capitalization alone
    does not mark a function as a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Defining a Class via an Object Literal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To define a class via an object literal, you need two markers. First, you need
    to tell JSDoc that a given variable holds a class. Second, you need to mark an
    object literal as defining a class. You do the latter via the `@lends` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Defining a Class via an Object Literal with an @constructs Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If an object literal has an `@constructs` method, you need to tell JSDoc about
    it, so that it can find the documentation for the instance properties. The documentation
    of the class moves to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the `@lends`, you must specify which class the methods belong to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Subclassing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has no built-in support for subclassing. When you subclass in your
    code (be it manually, be it via a library), you have to tell JSDoc what is going
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@extends namePath`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indicates that the documented class is the subclass of another one. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Other Useful Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of these tags are documented at the [JSDoc website](http://usejsdoc.org/):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modularity: `@module`, `@exports`, `@namespace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom types (for virtual entities such as callbacks, whose signature you can
    document): `@typedef`, `@callback`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Legal matters: `@copyright`, `@license`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Various kinds of objects: `@mixin`, `@enum`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[21](#id1082503)]) The JSDoc website is the main source of this chapter;
    some examples are borrowed from it.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 30. Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter covers JavaScript libraries. It first explains what shims and polyfills
    are, two special kinds of libraries. Then it lists a few core libraries. Lastly,
    it points to additional library-related resources.
  prefs: []
  type: TYPE_NORMAL
- en: Shims Versus Polyfills
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shims and polyfills are libraries that retrofit newer functionality on older
    JavaScript engines:'
  prefs: []
  type: TYPE_NORMAL
- en: A *shim* is a library that brings a new API to an older environment, using only
    the means of that environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *polyfill* is a shim for a browser API. It typically checks if a browser
    supports an API. If it doesn’t, the polyfill installs its own implementation.
    That allows you to use the API in either case. The term *polyfill* comes from
    a home improvement product; according to [Remy Sharp](http://bit.ly/MmZZmZ):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Polyfilla is a UK product known as Spackling Paste in the US. With that in
    mind: think of the browsers as a wall with cracks in it. These [polyfills] help
    smooth out the cracks and give us a nice smooth wall of browsers to work with.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“HTML5 Cross Browser Polyfills”](http://bit.ly/1oOGuTE): A list compiled by
    Paul Irish.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[es5-shim](http://bit.ly/1oOGxi4) is a (nonpolyfill) shim that retrofits ECMAScript 5
    features on ECMAScript 3 engines. It is purely language-related and makes just
    as much sense on Node.js as it does on browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four Language Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following libraries are quite established and close to the language. It
    is useful to be aware of them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ECMAScript Internationalization API helps with tasks related to internationalization:
    collation (sorting and searching strings), number formatting, and date and time
    formatting. The next section explains this API in more detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Underscore.js](http://underscorejs.org) complements JavaScript’s relatively
    sparse standard library with tool functions for arrays, objects, functions, and
    more. As Underscore predates ECMAScript 5, there is some overlap with the standard
    library. That is, however, a feature: on older browsers, you get functionality
    that is normally ECMAScript-5-only; on ECMAScript 5, the relevant functions simply
    forward to the standard library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lo-Dash](http://lodash.com) is an alternative implementation of the Underscore.js
    API, with a few additional features. Check out the website to find out if it suits
    you better than Underscore.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[XRegExp](http://xregexp.com) is a regular expression library with several
    advanced features such as named captures and free-spacing (which allows you to
    spread out a regular expression across multiple lines and document per line).
    Behind the scenes, enhanced regular expressions are translated to normal regular
    expressions, meaning that you don’t pay a performance penalty for using XRegExp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ECMAScript Internationalization API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ECMAScript Internationalization API is a standard JavaScript API that helps
    with tasks related to internationalization: collation (sorting and searching strings),
    number formatting, and date and time formatting. This section gives a brief overview
    and points you to more reading material.'
  prefs: []
  type: TYPE_NORMAL
- en: The ECMAScript Internationalization API, Edition 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first edition of the API provides the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Collation* supports two scenarios: sorting a set of strings and searching
    within a set of strings. Collation is parameterized by locale and aware of Unicode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Number formatting*. Parameters include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Style of formatting: decimal, currency (which one and how to refer to it is
    determined by other parameters), percent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locale (directly specified or best fit, searched for via a matcher object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbering system (Western digits, Arabic digits, Thai digits, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precision: number of integer digits, fraction digits, significant digits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping separators on or off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Date and time formatting*. Parameters include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What information to format and in which style (short, long, numeric, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A locale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A time zone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of the functionality is accessed via an object in the global variable
    `Intl`, but the API also augments the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.localeCompare`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.prototype.toLocaleString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toLocaleString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toLocaleDateString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toLocaleTimeString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Kind of Standard Is It?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The number of the standard “ECMAScript Internationalization API” (EIA) is ECMA-402\.
    It is hosted by Ecma International, the association that also hosts EMCA-262,
    the ECMAScript language specification. Both standards are maintained by TC39\.
    Therefore, EIA is as close to the language as you can get without being part of
    ECMA-262\. The API has been designed to work with both ECMAScript 5 and ECMAScript 6.
    A set of conformance tests complements the standard and ensures that the various
    implementations of the API are compatible (ECMA-262 has a similar test suite).
  prefs: []
  type: TYPE_NORMAL
- en: When Can I Use It?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most modern browsers already support it or are in the process of supporting
    it. David Storey has created a detailed [compatibility table](http://bit.ly/1oOGIdo)
    (indicating which browsers support which locales and more).
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [specification](http://bit.ly/1oOGQth) of the ECMAScript Internationalization
    API is edited by Norbert Lindenberg. It is available in PDF, HTML, and EPUB format.
    Additionally, there are several comprehensive introductory articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“The ECMAScript Internationalization API”](http://bit.ly/1oOGT8C) by Norbert
    Lindenberg'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“ECMAScript Internationalization API”](http://bit.ly/1oOGYcc) by David Storey'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Using the JavaScript Internationalization API”](http://bit.ly/1oOH2sz) by
    Marcos Caceres'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directories for JavaScript Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section describes sites that collect information on JavaScript resources.
    There are several kinds of such directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a list of general directories for JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“JavaScriptOO: Every JavaScript project you should be looking into”](http://www.javascriptoo.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JSDB](http://www.jsdb.io/): A collection of the best JavaScript libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JSter](http://jster.net/): A catalog of JavaScript libraries and tools for
    development'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Master List of HTML5, JavaScript, and CSS Resources”](http://bit.ly/1oOH7MW)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specialized directories include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“Microjs: Fantastic Micro-Frameworks and Micro-libraries for Fun and Profit”](http://microjs.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Unheap: A tidy repository of jQuery plugins”](http://www.unheap.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Obviously, you can always directly browse the registries of package managers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[npm](https://npmjs.org/) (Node Packaged Modules)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bower](http://bower.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Directories for CDNs (content delivery networks) and CDN content include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[jsDelivr](http://www.jsdelivr.com/): Free CDNs for JavaScript libraries, jQuery
    plug-ins, CSS frameworks, fonts, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“cdnjs: The missing CDN for JavaScript and CSS”](http://cdnjs.com/) (hosts
    less popular libraries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acknowledgments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following people contributed to this section: Kyle Simpson (@getify), Gildas
    Lormeau (@check_ca), Fredrik Sogaard (@fredrik_sogaard), Gene Loparco (@gloparco),
    Manuel Strehl (@m_strehl), and Elijah Manor (@elijahmanor).'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 31. Module Systems and Package Managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript does not have built-in support for modules, but the community has
    created impressive workarounds. To manage modules, you can use so-called *package
    managers*, which handle discovery, installation, dependency management, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Module Systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two most important (and unfortunately incompatible) standards for JavaScript
    modules are:'
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS Modules (CJS)
  prefs: []
  type: TYPE_NORMAL
- en: 'The dominant incarnation of this standard is [Node.js modules](http://nodejs.org/api/modules.html)
    (Node.js modules have a few features that go beyond CJS). Its characteristics
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: Compact syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designed for synchronous loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Main use: server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous Module Definition (AMD)
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular implementation of this standard is [RequireJS](http://requirejs.org/).
    Its characteristics include:'
  prefs: []
  type: TYPE_NORMAL
- en: Slightly more complicated syntax, enabling AMD to work without `eval()` or a
    static compilation step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designed for asynchronous loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Main use: browsers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package Managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to package managers, [npm](https://npmjs.org) (Node Packaged
    Modules) is the canonical choice for Node.js. For browsers, two options are popular
    (among others):'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bower](http://bower.io) is a package manager for the Web that supports both
    AMD and CJS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Browserify](http://browserify.org) is a tool based on npm that compiles npm
    packages to something you can use in a browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick and Dirty Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For normal web development, you should use a module system such as RequireJS
    or Browserify. However, sometimes you just want to put together a quick hack.
    Then the following simple module pattern can help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding is a module that is stored in the global variable `moduleName`.
    It does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly imports a dependency (the module `otherModule`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a private function, `privateFunction`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exports `publicFunction`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the module on a web page, simply load its file and the files of its
    dependencies via `<script>` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If no other module is accessed while a module is loaded (which is the case for
    `moduleName`), then the order in which modules are loaded does not matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are my comments and recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve used this module pattern for a while, until I found out that I hadn’t invented
    it and that it had an official name. Christian Heilmann popularized it and called
    it the [“revealing module pattern”](http://bit.ly/1c1InUg).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use this pattern, keep it simple. Feel free to pollute the global scope
    with module names, but do try to find unique names. It’s only for hacks, so there
    is no need to get fancy (nested namespaces, modules split across multiple files,
    etc.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 32. More Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Module systems and package managers are covered in [Chapter 31](ch31.html "Chapter 31. Module
    Systems and Package Managers"). But there are additional important categories
    of tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Linting
  prefs: []
  type: TYPE_NORMAL
- en: 'Lint tools analyze source code and report potential problems and style violations.
    Three popular ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[JSLint](http://www.jslint.com) by Douglas Crockford'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JSHint](http://www.jshint.com) by Anton Kovalyov'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ESLint](https://github.com/nzakas/eslint) by Nicholas Zakas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, a unit test framework runs on both of the two large JavaScript platforms—the
    browser and Node.js. Two important frameworks that do are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Jasmine](http://pivotal.github.io/jasmine/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[mocha](http://visionmedia.github.io/mocha/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minification
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript source code usually wastes space—variable names are longer than
    need be, there are comments, extra whitespace, and so on. A minification tool
    removes the waste and compiles code to smaller code. Some parts of the removal
    process are relatively complex (e.g., the renaming of variables to short names).
    Three popular minification tools are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[UglifyJS](https://github.com/mishoo/UglifyJS2/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[YUI Compressor](https://github.com/yui/yuicompressor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Closure Compiler](https://developers.google.com/closure/compiler/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building
  prefs: []
  type: TYPE_NORMAL
- en: 'For most projects, there are many operations that you need to apply to their
    artifacts: lint the code, compile code (compilation happens even in web projects—for
    example, to compile a CSS language such as LESS or Sass to plain CSS), minify
    code, and more. Build tools help you do that. Two classic examples are make for
    Unix and Ant for Java. Two popular build tools for JavaScript are [Grunt](http://gruntjs.com)
    and [Gulp](http://gulpjs.com/). One of their most intriguing features is that
    you can stay in JavaScript while working with them; they are both based on Node.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding
  prefs: []
  type: TYPE_NORMAL
- en: A scaffolding tool sets up an empty project, preconfigures build files, and
    more. [Yo](https://github.com/yeoman/yo) is one such tool. It is part of the [Yeoman](http://yeoman.io)
    suite of tools for web development, which bundles yo, Bower, and Grunt.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 33. What to Do Next
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you know the JavaScript language, how do you proceed? What is the
    best way to get to know the whole ecosystem? Here are some suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Frontend Rescue](http://uptodate.frontendrescue.org) is a site with tips to
    get you started with browser development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JSbooks](http://jsbooks.revolunet.com) links to a variety of free books on
    JavaScript and related technologies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twitter is a good tool for staying up-to-date with web development. Start with
    famous JavaScript people you know (e.g., the creator of your framework of choice)
    and continue from there; sooner or later, you will get plenty of ideas for who
    to follow next.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JSMentors](https://groups.google.com/forum/#!forum/jsmentors) is a forum dedicated
    to “helping developers become better JavaScript coders in a professional & non-confrontational
    environment.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from Twitter, there are many other interesting news sources to explore.
    The following are a few examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Echo JS](http://www.echojs.com) is a community-driven news site focused on
    JavaScript and HTML5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cooper Press](https://cooperpress.com) publishes several web-development-related
    email newsletters (disclaimer: I’m editor of the “JavaScript Weekly” newsletter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Open Web Platform Daily Digest](http://webplatformdaily.org/) contains daily
    lists of newsworthy links.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Best of JavaScript, HTML & CSS](http://flippinawesome.org/category/news/best-of/)
    is a weekly list of links.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JavaScript user groups](http://communityjs.org) are a fun and educational
    way of meeting like-minded people. Most of them assemble regularly, with talks
    and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JavaScript conferences](http://lanyrd.com/topics/javascript/) are another
    good source of information. Many of them publish freely accessible videos of their
    talks online.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you can also take a look at the book’s companion website, [SpeakingJS.com](http://speakingjs.com/),
    where I’ll occasionally publish material related to this book.
  prefs: []
  type: TYPE_NORMAL

- en: Preface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software has been an integral part of enterprises and a key contributor to
    their growth. Be it analytics, user experience, social marketing, decision support
    systems, or any other functional domain, software has been used to aid smooth
    and efficient functioning. Enterprises start small and grow over a period of time,
    and so does their software dependency. Enterprise applications are developed over
    a period of time. The following aspects pose certain challenges while dealing
    with enterprise software:'
  prefs: []
  type: TYPE_NORMAL
- en: They are distributed across a set of domains, for example, payroll, inventory,
    reporting, and social integration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these modules might have been developed independent of each other and
    may be on different platforms, for example, employee self-portal in J2EE stack,
    legacy records management on mainframes, CRM system using Salesforce, with some
    real-time application in their proprietary implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These modules need to interact with each other and with external systems as
    well. They may have to consume data from external sources through SOAP services
    or shared files, or they themselves have to share data though one of many data-sharing
    techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As software grows old, we need to introduce new platforms and replace existing
    modules to alleviate the growing maintenance cost. A rip and replace strategy
    would not work; rather, this should be done in a homogenous way without disturbing
    the sanity of existing modules during the transitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration of these modules either inside organizations or with external partners
    is inherently complex, requiring integration of heterogeneous endpoints. This
    is the kind of scenario that Enterprise Application Integration tries to address.
    **Enterprise Integration Patterns** (**EIP**) is a collection of standard enterprise
    challenges and how can they be handled. Spring Integration is one of the implementations
    of the EIP that provides many off-the-shelf components recommended by EIP.
  prefs: []
  type: TYPE_NORMAL
- en: How enterprise integration challenges can be solved
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many approaches have been tried to make the integration simple without compromising
    on vital aspects of enterprise, such as security, transaction, availability, reliability,
    and so on. A few of the prominent methodologies used over time are **Java Connector
    Architecture** (**JCA**), RMI, RPC, and CORBA for platform-agnostic integration,
    message brokers with system adapter, and many more. Under the hood, they try to
    solve integration issues through one of the following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared File**: This is the simplest approach. Systems can write data in a
    predefined format to a file, which can be read by other endpoints. An adapter
    might be needed to convert a format between two different endpoints. Let''s consider
    an example, a daily report used to be generated in a CSV file. Over time, the
    organization established a web presence and reports need to be pushed online now.
    How can this be achieved? The simplest way is to dump it in files that will be
    read by an adapter and fed into the CMS system. A filesystem is simple but not
    the best solution; it is not transactional. What if a particular file is corrupt,
    or what if at poll interval files are not available due to network failure? This
    necessitates the introduction of a complex system that has a retry mechanism,
    filter capabilities, and many more nonfunctional aspects such as secure access,
    archival, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared database**: This addresses a few of the challenges that are addressed
    by the filesystem, such as transactional behavior, role-based access, performance
    tuning, distributed support, and so on. The common mechanism is a set of join
    tables—one application writes data in a schema that is understood by others. On
    the flip side, this introduces tight coupling; if there is a change in schema,
    both the systems need to be updated accordingly. Evolving applications will become
    a challenge, as they will have to factor in the external system limitations. The
    integration effort might itself start with lot of hiccups, for example, compatibility
    issues between the SQL provided by database vendors of the application, data format,
    and types in their table. For example, if one system stores only the date while
    the other stores the date with time stamp, depending on need, at least one will
    have to change format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote procedure calls**: This mechanism introduces a paradigm where each
    system can offer services by publishing the contract. These paradigms can be a
    method, parameters, result, and error. For example, an EJB service or a SOAP service
    can be exposed for providing raw data for a reporting module that renders it in
    multiple formats. The most limiting aspect is synchronous behavior, where systems
    have to wait for the result. There are other challenges such as serialization
    of data, network latency, performance issues of a module, which can bring down
    the whole application, and so on. From a security aspect, exposing the method
    name and parameter invites hackers to exercise their creativity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Messaging**: This introduces the asynchronous model in which two heterogeneous
    modules can interact through data over a predefined connection. The greatest advantage
    is decoupling—none of the systems are dependent on the availability of the other
    and they can participate or withdraw from integration without impacting other
    components. JMS is an example of message-based integration. Spring Integration
    is based on this paradigm where multiple endpoints connect on to a channel, produce
    or consume messages, and perform further processing based on information in a
    message. We will deal with channel, endpoints, message payload, and other concepts
    in the upcoming chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if we use one of the preceding techniques, enterprise systems are way outward
    from each other and all of them might not be working all the time. This necessitated
    the use of middleware that can orchestrate reliable communication between these
    disparate endpoints, typically called an **Enterprise Service Bus** (**ESB**).
    In layman's terms, ESB can be defined as the middle man who enables communication
    to and fro between heterogeneous interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Who are the players?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have been discussing, the problem of enterprise integration is complex
    and many vendors have tried to address it in their own propitiatory ESB framework—earlier
    it used to be dominated by commercial vendors such as Tibco, Vitria, IBM MQSeries,
    Oracle SOA Suite, Microsoft BizTalk, and so on. Over time, the need for open source
    frameworks became evident as smaller organizations grew. Their integration needs
    were limited and were incapable of investing upfront with any of these biggies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the prominent open source integration frameworks, apart from Spring
    Integration, are Camel, Service Mix, Mule ESB, Open ESB, and so on. A comprehensive
    comparison of these frameworks is beyond the scope of this book but a small summary
    of two other major open source frameworks, has been provided here for the sake
    of emphasizing Spring Integration simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mule ESB**: It is a standard server, solutions are developed and deployed
    inside them. Mule is one of the most prominent and stable solutions on the market.
    The point to be observed here is that, it''s a container that holds the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Mix (SM)**: Apache Service Mix is built over JAVA legacy JBI (Java
    Business Integration). Service Mix tries to solve almost all aspects of enterprise
    integration by unifying the features and functionality of ActiveMQ, Camel, CXF,
    ODE, and Karaf. It provides a complete, enterprise-ready ESB, exclusively powered
    by OSGi. Since it tries to address a lot of modules, it is pretty bulky compared
    to Spring Integration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Spring Integration?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Integration is an open source effort to address integration challenges;
    it is based on the Spring Framework, which is the most widely used Java-based
    framework in organizations. It introduces the simple POJO-based programming model
    to support standard integration patterns.
  prefs: []
  type: TYPE_NORMAL
- en: It's lightweight; all it needs is couple of jars for which Maven targets are
    readily available. A quick comparison shows that the Service Mix download is around
    55 MB while Spring Integration is just 14 MB in size.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Integration is just a set of standard Java libraries; the solution gets
    deployed in the application instead of that application getting deployed in some
    containers, as in the case of SM and Mule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For enterprises that are already using Java and Spring, it eases the integration
    effort as it follows the same idioms and patterns of the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: What this book covers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](part0018_split_000.html#page "Chapter 1. Getting Started"), *Getting
    Started*, explains how to set up the Eclipse IDE, a "Hello World" program, and
    a brief introduction of how Spring ROO can ease the configuration aspects even
    further. This will help overcome configuration nightmares and warm up developers
    to a hands-on experience.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](part0023_split_000.html#page "Chapter 2. Message Ingestion"), *Message
    Ingestion*, introduces channels through which messages can be read and processed.
    It describes the point-to-point and pub-sub models, which one is best suited for
    a given scenario, how errors can be handled in a decoupled manner on a channel,
    and finally how in-memory channels can be backed up with persistence for failover
    and recovery solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](part0031_split_000.html#page "Chapter 3. Message Processing"),
    *Message Processing*, explains how to define components that can apply business
    logic on messages, introduces decoupled logging that can used for auditing, and
    discusses adding transactional behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](part0037_split_000.html#page "Chapter 4. Message Transformers"),
    *Message Transformers*, deals with processing message formats, its conversion
    to a homogenous format, and how annotations can help keep the configurations clean.
    Messages can be introduced in heterogeneous formats such as XML, JSON, and so
    on that need to be converted to a format understood by the system.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](part0044_split_000.html#page "Chapter 5. Message Flow"), *Message
    Flow*, will introduce flow aspects to messages such as filtering messages that
    do not comply to validation rules, routing them to an error branch, splitting
    messages, and redirecting them to components appropriate for their processing—waiting
    for incomplete payloads, aggregating partial messages, and finally the chaining
    of business processing handlers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](part0052_split_000.html#page "Chapter 6. Integration with External
    Systems"), *Integration with External Systems*, will give a hands-on overview
    of integration points. Integration with external systems is the most interesting
    and powerful aspect of Spring Integration—interaction with external systems is
    a matter of a few lines of configuration. Spring Integration has introduced adapters,
    gateways, and other components that make it a breeze to interact with filesystems,
    SQL, NoSQL persistence store, HTTP services, and other widely used external entities
    such as different servers, social media, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](part0061_split_000.html#page "Chapter 7. Integration with Spring
    Batch"), *Integration with Spring Batch*, will introduce how to use Spring Integration
    and batch module for scheduling, triggering, and monitoring batch jobs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](part0065_split_000.html#page "Chapter 8. Testing Support"), *Testing
    Support*, will explain how to leverage the readily available mocks for different
    components, what to test, and how much to test.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](part0072_split_000.html#page "Chapter 9. Monitoring, Management,
    and Scaling Up"), *Monitoring, Management, and Scaling Up*, will cover using Spring
    Integration configuration to leverage JMX to get performance statistics of different
    configured components in the system. We will also peek into ways to scale up Spring
    Integration components.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](part0075_split_000.html#page "Chapter 10. An End-to-End Example"),
    *An End-to-End Example*, has an end-to-end hands-on example that will help you
    to recollect concepts introduced in different chapters and reassert their understanding.
    Code will be pushed to a social repository as GitHub, but this chapter will give
    users enough instructions to use it and run it.'
  prefs: []
  type: TYPE_NORMAL
- en: What you need for this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need a Java-based IDE, and Spring STS is recommended. JDK 1.6 and above
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: Who this book is for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is for developers who are already familiar with basic Java and Spring
    concepts. Concepts of Enterprise Integration Patterns would be helpful but not
    mandatory. The book has been presented in a hands-on manner; an end-to-end working
    example has been picked, implemented, and explained throughout the chapters. This
    book would serve as a strong companion for new developers trying out their hand
    on integration aspects, and as a hands-on guide on how to use Spring Integration
    components for developers already familiar with these challenges and looking for
    quick samples.
  prefs: []
  type: TYPE_NORMAL
- en: Conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, you will find a number of styles of text that distinguish between
    different kinds of information. Here are some examples of these styles, and an
    explanation of their meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code words in text, database table names, folder names, filenames, file extensions,
    pathnames, dummy URLs, user input, and Twitter handles are shown as follows: "Create
    a Spring Integration project by navigating to **File** | **Spring Project**, as
    shown in the following screenshot:".'
  prefs: []
  type: TYPE_NORMAL
- en: 'A block of code is set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we wish to draw your attention to a particular part of a code block, the
    relevant lines or items are set in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**New terms** and **important words** are shown in bold. Words that you see
    on the screen, in menus or dialog boxes for example, appear in the text like this:
    "clicking the **Next** button moves you to the next screen".'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warnings or important notes appear in a box like this.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tips and tricks appear like this.
  prefs: []
  type: TYPE_NORMAL

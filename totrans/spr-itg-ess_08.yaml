- en: Chapter 8. Testing Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Test Driven** **Development** (**TDD**) has revolutionized the way software
    is developed and deployed, and why not, every customer wants working software—and
    the best way to prove that it''s working is to test it! Spring Integration is
    no exception—so how can we test that each of the "units" are working in isolation?—in
    fact it''s even more important to test the units so that any integration issues
    can be easily isolated. For example, an FTP inbound gateway is dependent on external
    factors such as user roles on the FTP server, performance of the FTP server, network
    latency, and so on. How can we validate that the consumer connected to an FTP
    inbound gateway can process files without actually connecting to an FTP server?
    We can send "mock" messages to the channel, which will be treated by the consumer
    as though it arrived from an FTP server! All we want to prove is that, given that
    files arrive on the channel, the listener will do its job.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will cover aspects of Spring Integration testing—and mostly,
    it''s going to be a "show me the code" chapter! Here is the broad outline of topics
    covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing splitters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So what is needed for testing? JUnit of course! What else? The Spring framework
    and Spring Integration itself provide many mocks and support classes, which help
    in testing the application. Let''s add maven dependencies for these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Testing messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Integration provides a class that can help to build certain payloads
    such as the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These messages can be put on the channel by grabbing the handle of an actual
    channel definition. This can be used for negative as well as positive testing.
    For example, if a service activator listening on the channel expects a message
    with the payload type `File`, then putting a message with a payload `String` should
    indicate an error. Let''s write a quick test for our transformer, which accepts
    `Message` with the payload `SyndEntry` and converts it to `SoFeed`. The following
    code snippet is our transformer class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, it gets a message having a payload of the type `SyndEntry`. Let''s
    write a simple test case that will pass only if the conversion from `SyndEntry`
    to `SoFeed` is successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the `@ContextConfiguration` annotation is used to load the context
    information. By default, it will look for a file name such as `<classname>-context.xml`
    and Java configuration classes annotated with `@Configuration`. In our case, it
    is `TestSoDBFeedTransformer-context.xml`. This contains information required to
    run the test, such as channel, services definitions, and others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The components covered in this code are explained in detail in the following
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RunWith(SpringJUnit4ClassRunner.class)`: This defines which engine to run
    the tests on—nothing specific to Spring Integration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Autowired MessageChannel filteredFeedChannel`: This autowires the channel
    definition from the context file—no need to explicitly load it to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Autowired QueueChannel transformedChannel`: This is similar to the preceding
    point and this autowires other channels as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring configuration prepares all the required elements—now let''s take a look
    at what the test class does:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a dummy `SyndEntry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It creates an expected `SoFeed` based on that `SyndEntry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It builds a message with a payload of the type `SyndEntry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It grabs the handle of the channel on which the transformer is plugged and puts
    the payload on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is where the transformer is tested, and an actual instance of transformer
    (and not a mocked one) that is listening on the channel is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Transformer does the transformation and puts the result on the output channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The test class grabs the handle of the output channel and reads the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual transformed message on the output channel must match the expected
    message constructed.
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding steps, we are able to test an actual transformer, the logic
    written without worrying much about the channels, or other Spring Integration
    elements that are in any way external to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Testing headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we tested the payload, it''s fairly easy to test headers. Let''s write a
    header enricher and then a test case to validate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Headers will be added to any message that is put on `filteredFeedChannel`.
    The following code snippet is the test to verify whether these headers are added
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we build up a test message and put it on a channel. A header enricher
    is plugged in to the input channel, which adds a header to the payload. We verified
    this by extracting the message from the output channel.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far so good, how about handling error scenarios? How to test negative use
    cases and what to do with the failed test case? The following code snippet will
    help us in these matters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The input channel expects a message with the payload type `SyndEntry`, but if
    a message with a `String` payload is sent—this must throw an exception. This is
    what has been tested. This can be further enhanced to monitor certain types of
    exception on channels with the ability to validate user-defined propagated messages.
  prefs: []
  type: TYPE_NORMAL
- en: Testing filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have defined a filter that filters out all messages except java feed. What
    is so special about filters that we want to discuss them separately? If you remember,
    filters always return a Boolean value, indicating whether to pass on the message
    or drop it, based on whether or not it satisfies the condition. For ease of reference,
    the following code snippet is the filter that we have defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a test context class to test this. It's always better to have a
    separate context class to test, so that it does not mess up the actual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we write our test cases—the first one is to validate that all the messages
    with the type `java` are allowed to pass through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Splitter test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss the last test—which is for splitters. The splitter that we defined
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet represents our test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This test is pretty self-explanatory. As expected by the original splitter defined
    in the preceding code, when a payload with `SyndEntry` having a list of categories
    is put on the channel, it extracts the list, splits it, and then puts the categories
    one by one on the output channel.
  prefs: []
  type: TYPE_NORMAL
- en: These are enough samples to get started with Spring Integration testing. The
    best practices for TDD apply in the context of Spring Integration as well. In
    fact, apart from the fact that Spring Integration provides support classes for
    testing the components, there is nothing special about Spring Integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered how to test most widely used Spring Integration components. It's
    always good practice to test systems in *isolation*—so that integration time surprises
    are alleviated to the max. Let's finish our discussion on testing support and
    move on to the next chapter where we will discuss management and ways to scale
    up a Spring Integration application.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 9. Monitoring, Management, and Scaling Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we covered one of the most important aspects—testing.
    We will end our discussion on Spring Integration by covering the following topics
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have witnessed across the chapters, enterprise systems are disparate,
    disconnected, and prone to failure. One important aspect of enabling communication
    across them is the ability to monitor what went wrong, which of the components
    are overloaded, and what have been the vital stats of communication—this all will
    help in improving the reliability and efficiency of the systems. The Spring framework
    provides decent support for monitoring and management, let's discuss how it can
    be leveraged.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways of monitoring and managing operations; for example,
    the most common way is to use Java's JMX support, another option is to invoke
    commands remotely, or monitor and log events as they occur—let's cover the most
    commonly used method.
  prefs: []
  type: TYPE_NORMAL
- en: JMX support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JMX,** which is short for **Java Management Extensions**, does not need an
    introduction—it''s a standard way for remote monitoring of applications. Any application
    can provide implementation of MBeans and then they can be queried to get exposed
    management information. Spring Integration provides a standard component, which
    can be used to monitor channels, adapters, and other available components. Standard
    JMX can be extended to get more specific information.'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can use JMX support from Spring Integration, we need to add namespace
    declarations and maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NameSpace support**: This can be added using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Maven dependency**: This can be added using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Initializing the server**: Traditionally, in Java/Spring applications, we
    need to write code to start the platform MBean server, and export our MBeans,
    but Spring provides tags to achieve the same tasks. To create and start an MBean
    server, just use the following line of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For exporting the defined MBeans, the following line of code is sufficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Management annotations**: The Spring framework exposes some annotation, which
    can be used to mark components that will be managed or will help in management
    and monitoring. For example, `@ManagedResource` indicates a class participating
    in management and monitoring, while `@ManagedAttribute` and `@ManagedOperation`
    indicate a member level participation, respectively, for class attribute and operation.
    Enabling `<context:mbean-export/>` will scan and expose these beans and management
    nodes. Let''s write a sample MBean and export it, we will use this for our examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Due to the annotations used, this class will be exported as MBean. Additionally,
    this class implements `NotificationPublisherAware`, which can be used to send
    notifications. We will see its usage in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: '**JConsole**: To connect and monitor JMX beans, the easiest way is to use `Jconsole`.
    It comes bundled with JDK—look for it at `JDK_INSTALLATION_PATH/bin/Jconsole.exe`.
    By default, JConsole will select a random port, but to have explicit control over
    the ports of JMX, start the spring integration application with the following
    parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The notification listening channel adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the components used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int-jmx:notification-listening-channel-adapter`: This is the namespace support
    for the notification listening channel adapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channel`: This is the channel on which the received notification will be put
    as a message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object-name`: This is the name of the MBean, which publishes notifications
    for this adapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test this adapter, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the configuration context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Start `Jconsole` and connect to `FeedsExample`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Jconsole` will list the methods and attributes exposed by `TestMBean`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke add operation, which results in `Testbean` sending a notification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The payload will be put on the `listenForNotification` channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s write a small class that can trigger the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The class of the preceding code snippet is pretty simple; it loads the context,
    gets the reference of a channel, uses the Spring Integration support class `MessageBuilder`
    to build a payload, and then drops it on the channel. As soon as a message is
    put on to this channel, an event will be generated and sent across to subscribers.
    A wait has been introduced to allow some time for `Jconsole` to connect.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute polling channel adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name suggests, it polls for an attribute that is managed by MBean. The
    attribute name that needs to be polled and the object name of MBean that encapsulates
    the attribute are required. The following code is a quick sample configuration
    of the attribute polling channel adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding configuration polls the `ManagedData` attribute of `TestMbean`.
    If the attribute value changes, the changed value is put on the channel. We can
    have a simple service, given in the following line of code, activate it for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The tree polling channel adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The tree polling channel adapter queries the JMX tree itself and sends a payload,
    which is the graph of the MBean object. The graph can be further refined using
    a query—let''s write the following sample configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following code snippet to trigger the preceeding adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The operation invoking outbound gateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As usual, `Gateway` is used to make a response available for further processing—in
    this case, after invoking the operation, a response will be put back on `replychannel`
    for further processing, as done in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A simple service activator can be plugged in to validate the reslts returned
    by the gateway.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The MBean exporter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What about the standard spring integration components: `MessageChannels`, gateways,
    and others? Well, they can be exposed for monitoring with the following single
    line of configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly look at the elements used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default-domain`: This is optional and if left blank, `org.springframework.integration`
    will be used as the default domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server`: This is the reference of `mbeanServer` created using `<context:mbean-server/>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before closing the discussion on JMX, let''s look at a snapshot of JConsole.
    Here is the screenshot of the custom MBeans and listeners, which we have exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MBean exporter](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A screenshot showing all the components of Spring Integration, which we have
    defined in our application, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MBean exporter](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can observe two aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Integration package that lists all spring integration components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The feeds example that exposes user-defined MBeans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties and values of these adapters are pretty self-explanatory, I will
    leave it to you to explore these further.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking the message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is added, all the components through which this message passes (provided
    that the components have an `id` tag) have an audit message appended. Let''s take
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this code sample, we have declared `<int:message-history/>` at the start.
    Also, notice that the next two components `notifListener` and `publishListener`
    have an ID tag. With this configuration in place, a metadata will be added to
    the message the moment it passes through these components.
  prefs: []
  type: TYPE_NORMAL
- en: Wire tap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is extremely simple—it''s an interceptor that can be configured with any
    channel and it will "peek" into all messages going through the channel. This can
    be used for the purposes of debugging, logging critical information, and so on.
    Let''s add an interceptor to the channel that is listening for the monitoring
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After adding these configurations, all the messages passing through this channel
    will be logged.
  prefs: []
  type: TYPE_NORMAL
- en: Control bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have elements in spring integration that are being used for application
    level messaging. How about using the same system to trigger some action? The idea
    behind control bus is exactly the same—we can define the channel and then, based
    on the payload on that channel, it can invoke management operations. Let''s look
    at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A class to send a control message to this bus is given in the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With this, let's wrap up our discussion on management and monitoring. In the
    next section, we will pick one of the most important aspects of application design—scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scalability of a system is one of the most important non-functional requirements.
    As we know, there are basically two ways to scale a system: vertical scaling and
    horizontal scaling. **Vertical** **scaling** refers to adding more processing
    power to an existing system—if you are running out of memory, add memory; if CPU
    cycles are getting short, add some more cores and or make other changes. Not much
    of a challenge! On the other hand, **horizontal scaling** refers to adding more
    physical nodes, handling requests in a distributed way, adding redundancy at DB,
    and message broker components. Obviously, this needs a proper thought-through
    design. Let''s take a couple of ways that can be used to scale Spring applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Threading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common way to scale a system is to introduce parallel processing.
    However, before you learn how to do this, let''s be aware of the following pitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: It should be evaluated whether creating a thread will help
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads should be created as per machine capability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should consider latency across other endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads should be cleaned up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So let''s start with an example. We have discussed FTP, if thousands of files
    are available and we want to process them in parallel, how can this be achieved?
    We can use `TaskExecutors`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So what is going on in the preceding code? First, we define a task executor—nothing
    specific to spring integration. You can see that the `org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor`
    class from the Spring framework is used. Then, we attached this with the poller
    on the service activator. Now a pool of service will be created, which will process
    files on the input channel in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'As obvious as it can be, Spring Integration leverages Spring framework''s support
    for executors. The preceding code uses the bean directly, but Spring has provided
    namespace support as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The underlying abstraction is `org.springframework.core.task.TaskExecutor`.
    Whenever a task needs to be executed, it is submitted to the task executor; it
    is the task executor''s job to allocate and de-allocate threads for the task.
    Let''s take the case of the poller from the preceding example, if the elements
    on the pollable channel are stateless and can be processed concurrently, we can
    use an executor there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a task executor that maintains an underlying pool of threads, then
    we can specify the maximum threads to be maintained, keeping in view the physical
    resource limitation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Scaling the state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrency will work when there is no state; what about the use cases where
    we want to scale but at the same time managing the state is mandatory? For example,
    if the payload is too big, will we wait for all the payloads to be processed,
    holding the consumers downward? In [Chapter 7](part0061_split_000.html#page "Chapter 7. Integration
    with Spring Batch"), *Integration with Spring Batch*, we mentioned that it is
    possible to trigger the download and then wait for an event that the download
    has been completed; at that stage, the consumer will kick-in. Similarly, we have
    some approaches that we can leverage; in fact, we have already covered these in
    an earlier chapter so I will just touch upon leveraging persistent store for scaling
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Message store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name suggests, we can store the messages temporarily until some criteria
    is met. For example, if you remember, Aggregator is a spring integration component
    that correlates and temporarily stores the messages until the completion criteria
    is satisfied. A similar concept can be used for scaling where the task can be
    held aside and only processed when all other coordinating members are available.
    Let's take an example of feeds, some feeds may have pictures associated. The text
    part will be delivered immediately while the picture delivery may take a lot of
    time. We can configure aggregator so that it releases the messages when all of
    the parts have arrived. We already covered how to do this in [Chapter 5](part0044_split_000.html#page
    "Chapter 5. Message Flow"), *Message Flow*!
  prefs: []
  type: TYPE_NORMAL
- en: Claim check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept is very simple, instead of waiting for all the components to arrive,
    store the part at some known location and have a pointer to it. When the last
    chunk arrives, "claim" all other parts using the pointer. Obviously, this will
    apply where we can break the payloads in independent units and the system can
    be made aware of the final packet arrival. Once implemented, components down the
    processing chain will get the package only when all of their parts are available—they
    do not have to wait or be blocked for the duration of complete packet arrival.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we glanced through monitoring and management aspects of the
    spring integration framework such as how we can keep an eye on implicit and user-defined
    integration components, how we can send and receive an event and invoke an operation,
    and many other aspects. We also covered how threads can be used to scale the application
    and a couple of ways to scale the state. This brings us to the end of our theoretical
    journey. In the next chapter; we will write an end-to-end application and finish
    off our spring integration journey!
  prefs: []
  type: TYPE_NORMAL

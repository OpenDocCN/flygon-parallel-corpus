- en: Chapter 1. Demystifying Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 解密微服务
- en: Microservices are an architecture style and an approach for software development
    to satisfy modern business demands. Microservices are not invented; they are more
    of an evolution from the previous architecture styles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一种软件开发的架构风格和方法，以满足现代业务需求。微服务并非是创新，而是从以前的架构风格中演变而来。
- en: We will start the chapter by taking a closer look at the evolution of the microservices
    architecture from the traditional monolithic architectures. We will also examine
    the definition, concepts, and characteristics of microservices. Finally, we will
    analyze typical use cases of microservices and establish the similarities and
    relationships between microservices and other architecture approaches such as
    **Service Oriented Architecture** (**SOA**) and Twelve-Factor Apps. Twelve-Factor
    Apps defines a set of software engineering principles of developing applications
    targeting the cloud.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从更近距离地观察微服务架构从传统的大型架构演变而来。我们还将研究微服务的定义、概念和特点。最后，我们将分析微服务的典型用例，并建立微服务与其他架构方法（如面向服务的架构（SOA）和十二要素应用）之间的相似性和关系。十二要素应用定义了一套针对云平台开发应用程序的软件工程原则。
- en: 'In this chapter you, will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: The evolution of microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的演进
- en: The definition of the microservices architecture with examples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有示例的微服务架构的定义
- en: Concepts and characteristics of the microservices architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构的概念和特点
- en: Typical use cases of the microservices architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构的典型用例
- en: The relationship of microservices with SOA and Twelve-Factor Apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务与SOA和十二要素应用的关系
- en: The evolution of microservices
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的演进
- en: Microservices are one of the increasingly popular architecture patterns next
    to SOA, complemented by DevOps and cloud. The microservices evolution is greatly
    influenced by the disruptive digital innovation trends in modern business and
    the evolution of technologies in the last few years. We will examine these two
    factors in this section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是继SOA之后越来越受欢迎的架构模式之一，与DevOps和云相辅相成。微服务的演进受到了现代业务中颠覆性数字创新趋势和过去几年技术演进的极大影响。我们将在本节中研究这两个因素。
- en: Business demand as a catalyst for microservices evolution
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务需求作为微服务演进的催化剂
- en: In this era of digital transformation, enterprises increasingly adopt technologies
    as one of the key enablers for radically increasing their revenue and customer
    base. Enterprises primarily use social media, mobile, cloud, big data, and Internet
    of Things as vehicles to achieve the disruptive innovations. Using these technologies,
    enterprises find new ways to quickly penetrate the market, which severely pose
    challenges to the traditional IT delivery mechanisms.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数字转型的时代，企业越来越多地采用技术作为大幅增加其收入和客户群的关键推动力之一。企业主要利用社交媒体、移动、云、大数据和物联网作为实现颠覆性创新的工具。利用这些技术，企业找到了快速渗透市场的新途径，这严重挑战了传统的IT交付机制。
- en: The following graph shows the state of traditional development and microservices
    against the new enterprise challenges such as agility, speed of delivery, and
    scale.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了传统开发和微服务在面对敏捷性、交付速度和规模等新企业挑战方面的状态。
- en: '![Business demand as a catalyst for microservices evolution](img/B05447_01_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![业务需求作为微服务演进的催化剂](img/B05447_01_01.jpg)'
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Microservices promise more agility, speed of delivery, and scale compared to
    traditional monolithic applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务承诺比传统的大型应用程序更具敏捷性、交付速度和规模。
- en: Gone are the days when businesses invested in large application developments
    with the turnaround time of a few years. Enterprises are no longer interested
    in developing consolidated applications to manage their end-to-end business functions
    as they did a few years ago.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 过去企业投资于数年的大型应用程序开发的时代已经过去了。企业不再有兴趣开发整合的应用程序来管理他们的端到端业务功能，就像几年前那样。
- en: The following graph shows the state of traditional monolithic applications and
    microservices in comparison with the turnaround time and cost.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了传统的大型应用程序和微服务在周转时间和成本方面的比较。
- en: '![Business demand as a catalyst for microservices evolution](img/B05447_01_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![业务需求作为微服务演进的催化剂](img/B05447_01_02.jpg)'
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Microservices provide an approach for developing quick and agile applications,
    resulting in less overall cost.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务提供了一种开发快速敏捷应用程序的方法，从而降低总体成本。
- en: Today, for instance, airlines or financial institutions do not invest in rebuilding
    their core mainframe systems as another monolithic monster. Retailers and other
    industries do not rebuild heavyweight supply chain management applications, such
    as their traditional ERPs. Focus has shifted to building quick-win point solutions
    that cater to specific needs of the business in the most agile way possible.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如今，航空公司或金融机构不再投资于重建他们的核心大型主机系统，以避免另一个庞大的怪物。零售商和其他行业也不再重建重量级供应链管理应用程序，比如他们传统的ERP系统。焦点已转向构建满足业务特定需求的快速解决方案，以最敏捷的方式进行。
- en: Let's take an example of an online retailer running with a legacy monolithic
    application. If the retailer wants to innovate his/her sales by offering their
    products personalized to a customer based on the customer's past shopping, preferences,
    and so on and also wants to enlighten customers by offering products based on
    their propensity to buy them, they will quickly develop a personalization engine
    or offers based on their immediate needs and plug them into their legacy application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子，一个在线零售商正在使用传统的大型应用程序。如果零售商希望通过根据客户的过往购物、偏好等个性化客户的产品来创新销售，并且还希望根据客户购买倾向来为客户提供产品，他们将快速开发个性化引擎或根据客户的即时需求提供优惠，并将其插入他们的传统应用程序中。
- en: '![Business demand as a catalyst for microservices evolution](img/B05447_01_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![业务需求作为微服务演变的催化剂](img/B05447_01_03.jpg)'
- en: As shown in the preceding diagram, rather than investing in rebuilding the core
    legacy system, this will be either done by passing the responses through the new
    functions, as shown in the diagram marked **A**, or by modifying the core legacy
    system to call out these functions as part of the processing, as shown in the
    diagram marked **B**. These functions are typically written as microservices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图表所示，与其投资于重建核心遗留系统，这将通过将响应通过新功能传递来完成，如图中标有**A**的部分所示，或者通过修改核心遗留系统以调用这些功能作为处理的一部分，如图中标有**B**的部分所示。这些功能通常被编写为微服务。
- en: This approach gives organizations a plethora of opportunities to quickly try
    out new functions with lesser cost in an experimental mode. Businesses can later
    validate key performance indicators and alter or replace these implementations
    if required.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法为组织提供了大量的机会，以较低的成本在实验模式下快速尝试新功能。企业可以随后验证关键绩效指标，并根据需要修改或替换这些实现。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Modern architectures are expected to maximize the ability to replace their parts
    and minimize the cost of replacing their parts. The microservices approach is
    a means to achieving this.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现代架构期望最大化替换其部分并最小化替换其部分的成本。微服务方法是实现这一目标的手段。
- en: Technology as a catalyst for the microservices evolution
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术作为微服务演变的催化剂
- en: Emerging technologies have also made us rethink the way we build software systems.
    For example, a few decades back, we couldn't even imagine a distributed application
    without a two-phase commit. Later, NoSQL databases made us think differently.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 新兴技术也使我们重新思考构建软件系统的方式。例如，几十年前，我们甚至无法想象没有两阶段提交的分布式应用程序。后来，NoSQL数据库使我们有了不同的思考方式。
- en: Similarly, these kinds of paradigm shifts in technology have reshaped all the
    layers of the software architecture.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，技术上的这种范式转变已经重塑了软件架构的所有层面。
- en: The emergence of HTML 5 and CSS3 and the advancement of mobile applications
    repositioned user interfaces. Client-side JavaScript frameworks such as Angular,
    Ember, React, Backbone, and so on are immensely popular due to their client-side
    rendering and responsive designs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 5和CSS3的出现以及移动应用程序的进步重新定位了用户界面。诸如Angular、Ember、React、Backbone等客户端JavaScript框架因其客户端渲染和响应式设计而广受欢迎。
- en: With cloud adoptions steamed into the mainstream, **Platform as a Services**
    (**PaaS**) providers such as Pivotal CF, AWS, Salesforce.com, IBMs Bluemix, RedHat
    OpenShift, and so on made us rethink the way we build middleware components. The
    container revolution created by Docker radically influenced the infrastructure
    space. These days, an infrastructure is treated as a commodity service.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云采用成为主流，**平台即服务**（**PaaS**）提供商，如Pivotal CF、AWS、Salesforce.com、IBM的Bluemix、RedHat的OpenShift等，使我们重新思考构建中间件组件的方式。Docker带来的容器革命从根本上影响了基础设施领域。如今，基础设施被视为一种商品服务。
- en: The integration landscape has also changed with **Integration Platform as a
    Service** (**iPaaS**), which is emerging. Platforms such as Dell Boomi, Informatica,
    MuleSoft, and so on are examples of iPaaS. These tools helped organizations stretch
    integration boundaries beyond the traditional enterprise.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 集成景观也随着**集成平台即服务**（**iPaaS**）的出现而发生了变化。Dell Boomi、Informatica、MuleSoft等平台是iPaaS的例子。这些工具帮助组织将集成边界延伸到传统企业之外。
- en: 'NoSQLs have revolutionized the databases space. A few years ago, we had only
    a few popular databases, all based on relational data modeling principles. We
    have a long list of databases today: Hadoop, Cassandra, CouchDB, and Neo 4j to
    name a few. Each of these databases addresses certain specific architectural problems.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL已经彻底改变了数据库领域。几年前，我们只有几种流行的数据库，都基于关系数据建模原则。今天我们有了一个很长的数据库列表：Hadoop、Cassandra、CouchDB、Neo
    4j等等。每个数据库都解决了特定的架构问题。
- en: Imperative architecture evolution
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式架构演变
- en: Application architecture has always been evolving alongside demanding business
    requirements and the evolution of technologies. Architectures have gone through
    the evolution of age-old mainframe systems to fully abstract cloud services such
    as AWS Lambda.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 应用架构一直在与不断变化的业务需求和技术的发展一起不断演进。架构已经经历了古老的主机系统的演变，到完全抽象的云服务，比如AWS Lambda。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Using AWS Lambda, developers can now drop their "functions" into a fully managed
    compute service.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS Lambda，开发人员现在可以将他们的“功能”放入一个完全托管的计算服务中。
- en: 'Read more about Lambda at: [https://aws.amazon.com/documentation/lambda/](https://aws.amazon.com/documentation/lambda/)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://aws.amazon.com/documentation/lambda/](https://aws.amazon.com/documentation/lambda/)了解更多关于Lambda的信息。
- en: Different architecture approaches and styles such as mainframes, client server,
    N-tier, and service-oriented were popular at different timeframes. Irrespective
    of the choice of architecture styles, we always used to build one or the other
    forms of monolithic architectures. The microservices architecture evolved as a
    result of modern business demands such as agility and speed of delivery, emerging
    technologies, and learning from previous generations of architectures.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的架构方法和风格，如主机、客户端服务器、N层和面向服务的架构，在不同的时间段都很受欢迎。无论选择哪种架构风格，我们总是用来构建单片架构的一种或另一种形式。微服务架构的演变是现代业务需求（如敏捷性和交付速度）、新兴技术以及从以前一代架构中学到的结果。
- en: '![Imperative architecture evolution](img/B05447_01_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![命令式架构演变](img/B05447_01_04.jpg)'
- en: Microservices help us break the boundaries of monolithic applications and build
    a logically independent smaller system of systems, as shown in the preceding diagram.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务帮助我们打破了单片应用程序的边界，并构建了一个逻辑上独立的更小的系统，如前面的图表所示。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If we consider monolithic applications as a set of logical subsystems encompassed
    with a physical boundary, microservices are a set of independent subsystems with
    no enclosing physical boundary.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将单片应用程序视为一组逻辑子系统，包含有物理边界，那么微服务就是一组没有封闭物理边界的独立子系统。
- en: What are microservices?
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: Microservices are an architecture style used by many organizations today as
    a game changer to achieve a high degree of agility, speed of delivery, and scale.
    Microservices give us a way to develop more physically separated modular applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是许多组织今天使用的一种架构风格，作为实现高度敏捷性、交付速度和规模的游戏规则改变者。微服务为我们提供了一种开发更加物理分离的模块化应用程序的方式。
- en: Microservices are not invented. Many organizations such as Netflix, Amazon,
    and eBay successfully used the divide-and-conquer technique to functionally partition
    their monolithic applications into smaller atomic units, each performing a single
    function. These organizations solved a number of prevailing issues they were experiencing
    with their monolithic applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务并非创造出来的。许多组织，如Netflix、亚马逊和eBay，成功地使用分而治之的技术，将其单片应用程序功能性地分割成更小的原子单元，每个单元执行单一功能。这些组织解决了他们在单片应用程序中遇到的一些问题。
- en: Following the success of these organizations, many other organizations started
    adopting this as a common pattern to refactor their monolithic applications. Later,
    evangelists termed this pattern as the microservices architecture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些组织的成功之后，许多其他组织开始将这种模式作为重构其单片应用程序的常见模式。后来，倡导者将这种模式称为微服务架构。
- en: Microservices originated from the idea of hexagonal architecture coined by Alistair
    Cockburn. Hexagonal architecture is also known as the Ports and Adapters pattern.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务源自Alistair Cockburn提出的六边形架构的概念。六边形架构也被称为端口和适配器模式。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Read more about hexagonal architecture at [http://alistair.cockburn.us/Hexagonal+architecture](http://alistair.cockburn.us/Hexagonal+architecture).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://alistair.cockburn.us/Hexagonal+architecture](http://alistair.cockburn.us/Hexagonal+architecture)了解更多关于六边形架构。
- en: 'Microservices are an architectural style or an approach to building IT systems
    as a set of business capabilities that are autonomous, self-contained, and loosely
    coupled:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一种建立IT系统的架构风格或方法，作为一组自治、自包含和松耦合的业务能力：
- en: '![What are microservices?](img/B05447_01_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![什么是微服务？](img/B05447_01_05.jpg)'
- en: The preceding diagram depicts a traditional N-tier application architecture
    having a presentation layer, business layer, and database layer. The modules **A**,
    **B**, and **C** represent three different business capabilities. The layers in
    the diagram represent a separation of architecture concerns. Each layer holds
    all three business capabilities pertaining to this layer. The presentation layer
    has web components of all the three modules, the business layer has business components
    of all the three modules, and the database hosts tables of all the three modules.
    In most cases, layers are physically spreadable, whereas modules within a layer
    are hardwired.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表描述了传统的N层应用程序架构，包括表示层、业务层和数据库层。模块**A**、**B**和**C**代表三种不同的业务能力。图表中的层代表架构关注点的分离。每个层包含与该层相关的所有三种业务能力。表示层包含所有三个模块的Web组件，业务层包含所有三个模块的业务组件，数据库托管所有三个模块的表。在大多数情况下，层是可以物理分开的，而层内的模块是硬连接的。
- en: Let's now examine a microservices-based architecture.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看基于微服务的架构。
- en: '![What are microservices?](img/B05447_01_06.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![什么是微服务？](img/B05447_01_06.jpg)'
- en: As we can note in the preceding diagram, the boundaries are inversed in the
    microservices architecture. Each vertical slice represents a microservice. Each
    microservice has its own presentation layer, business layer, and database layer.
    Microservices are aligned towards business capabilities. By doing so, changes
    to one microservice do not impact others.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的图表所示，微服务架构中的边界是相反的。每个垂直切片代表一个微服务。每个微服务都有自己的表示层、业务层和数据库层。微服务是与业务能力对齐的。通过这样做，对一个微服务的更改不会影响其他微服务。
- en: There is no standard for communication or transport mechanisms for microservices.
    In general, microservices communicate with each other using widely adopted lightweight
    protocols, such as HTTP and REST, or messaging protocols, such as JMS or AMQP.
    In specific cases, one might choose more optimized communication protocols, such
    as Thrift, ZeroMQ, Protocol Buffers, or Avro.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的通信或传输机制没有标准。一般来说，微服务使用广泛采用的轻量级协议进行通信，如HTTP和REST，或者消息协议，如JMS或AMQP。在特定情况下，可以选择更优化的通信协议，如Thrift、ZeroMQ、Protocol
    Buffers或Avro。
- en: As microservices are more aligned to business capabilities and have independently
    manageable life cycles, they are the ideal choice for enterprises embarking on
    DevOps and cloud. DevOps and cloud are two facets of microservices.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务更加符合业务能力，并且具有独立可管理的生命周期，它们是企业在采用DevOps和云时的理想选择。DevOps和云是微服务的两个方面。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: DevOps is an IT realignment to narrow the gap between traditional IT development
    and operations for better efficiency.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps是一种IT重新调整，缩小传统IT开发和运营之间的差距，以提高效率。
- en: 'Read more about DevOps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于DevOps：
- en: '[http://dev2ops.org/2010/02/what-is-devops/](http://dev2ops.org/2010/02/what-is-devops/)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://dev2ops.org/2010/02/what-is-devops/](http://dev2ops.org/2010/02/what-is-devops/)'
- en: Microservices – the honeycomb analogy
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务-蜂窝类比
- en: The honeycomb is an ideal analogy for representing the evolutionary microservices
    architecture.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 蜂窝是一个理想的类比，用来代表演进的微服务架构。
- en: '![Microservices – the honeycomb analogy](img/B05447_01_07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![微服务-蜂窝类比](img/B05447_01_07.jpg)'
- en: In the real world, bees build a honeycomb by aligning hexagonal wax cells. They
    start small, using different materials to build the cells. Construction is based
    on what is available at the time of building. Repetitive cells form a pattern
    and result in a strong fabric structure. Each cell in the honeycomb is independent
    but also integrated with other cells. By adding new cells, the honeycomb grows
    organically to a big, solid structure. The content inside each cell is abstracted
    and not visible outside. Damage to one cell does not damage other cells, and bees
    can reconstruct these cells without impacting the overall honeycomb.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，蜜蜂通过排列六边形蜂窝来建造蜂巢。它们从小开始，使用不同的材料来建造蜂窝。建造是基于当时可用的材料。重复的蜂窝形成了一个模式，并形成了一个坚固的结构。蜂巢中的每个蜂房都是独立的，但也与其他蜂房集成在一起。通过添加新的蜂房，蜂巢有机地增长成一个大而坚固的结构。每个蜂房内部的内容是抽象的，对外不可见。一个蜂房的损坏不会影响其他蜂房，蜜蜂可以重建这些蜂房而不影响整个蜂巢。
- en: Principles of microservices
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的原则
- en: In this section, we will examine some of the principles of the microservices
    architecture. These principles are a "must have" when designing and developing
    microservices.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将研究微服务架构的一些原则。这些原则在设计和开发微服务时是“必须具备”的。
- en: Single responsibility per service
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个服务只有一个责任
- en: The single responsibility principle is one of the principles defined as part
    of the SOLID design pattern. It states that a unit should only have one responsibility.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 单一责任原则是SOLID设计模式的一部分所定义的原则之一。它指出一个单元应该只有一个责任。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Read more about the SOLID design pattern at:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多关于SOLID设计模式的信息：
- en: '[http://c2.com/cgi/wiki?PrinciplesOfObjectOrientedDesign](http://c2.com/cgi/wiki?PrinciplesOfObjectOrientedDesign)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://c2.com/cgi/wiki?PrinciplesOfObjectOrientedDesign](http://c2.com/cgi/wiki?PrinciplesOfObjectOrientedDesign)'
- en: This implies that a unit, either a class, a function, or a service, should have
    only one responsibility. At no point should two units share one responsibility
    or one unit have more than one responsibility. A unit with more than one responsibility
    indicates tight coupling.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一个单元，无论是类、函数还是服务，都应该只有一个责任。在任何时候，两个单元都不应该共享一个责任，或者一个单元有多个责任。一个具有多个责任的单元表示紧密耦合。
- en: '![Single responsibility per service](img/B05447_01_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![每个服务只有一个责任](img/B05447_01_08.jpg)'
- en: As shown in the preceding diagram, **Customer**, **Product**, and **Order**
    are different functions of an e-commerce application. Rather than building all
    of them into one application, it is better to have three different services, each
    responsible for exactly one business function, so that changes to one responsibility
    will not impair others. In the preceding scenario, **Customer**, **Product**,
    and **Order** will be treated as three independent microservices.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，**Customer**、**Product**和**Order**是电子商务应用程序的不同功能。与其将它们全部构建到一个应用程序中，最好是有三个不同的服务，每个负责一个业务功能，这样对一个责任的更改不会影响其他责任。在前述情景中，**Customer**、**Product**和**Order**将被视为三个独立的微服务。
- en: Microservices are autonomous
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务是自治的
- en: Microservices are self-contained, independently deployable, and autonomous services
    that take full responsibility of a business capability and its execution. They
    bundle all dependencies, including library dependencies, and execution environments
    such as web servers and containers or virtual machines that abstract physical
    resources.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是自包含的、独立部署的、自治的服务，完全负责业务能力及其执行。它们捆绑了所有依赖，包括库依赖，以及抽象物理资源的执行环境，如Web服务器、容器或虚拟机。
- en: One of the major differences between microservices and SOA is in their level
    of autonomy. While most SOA implementations provide service-level abstraction,
    microservices go further and abstract the realization and execution environment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和SOA之间的一个主要区别在于它们的自治级别。虽然大多数SOA实现提供服务级别的抽象，但微服务更进一步，抽象了实现和执行环境。
- en: In traditional application developments, we build a WAR or an EAR, then deploy
    it into a JEE application server, such as with JBoss, WebLogic, WebSphere, and
    so on. We may deploy multiple applications into the same JEE container. In the
    microservices approach, each microservice will be built as a fat Jar, embedding
    all dependencies and run as a standalone Java process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的应用程序开发中，我们构建一个WAR或EAR，然后将其部署到JEE应用服务器，如JBoss、WebLogic、WebSphere等。我们可能会将多个应用程序部署到同一个JEE容器中。在微服务方法中，每个微服务将被构建为一个fat
    Jar，嵌入所有依赖项，并作为一个独立的Java进程运行。
- en: '![Microservices are autonomous](img/B05447_01_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![微服务是自治的](img/B05447_01_09.jpg)'
- en: Microservices may also get their own containers for execution, as shown in the
    preceding diagram. Containers are portable, independently manageable, lightweight
    runtime environments. Container technologies, such as Docker, are an ideal choice
    for microservices deployment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务也可以获得自己的容器来执行，如前图所示。容器是可移植的、独立可管理的、轻量级的运行时环境。容器技术，如Docker，是微服务部署的理想选择。
- en: Characteristics of microservices
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的特点
- en: The microservices definition discussed earlier in this chapter is arbitrary.
    Evangelists and practitioners have strong but sometimes different opinions on
    microservices. There is no single, concrete, and universally accepted definition
    for microservices. However, all successful microservices implementations exhibit
    a number of common characteristics. Therefore, it is important to understand these
    characteristics rather than sticking to theoretical definitions. Some of the common
    characteristics are detailed in this section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面讨论的微服务定义是任意的。倡导者和实践者对微服务有着强烈但有时不同的看法。对于微服务并没有一个单一、具体和普遍接受的定义。然而，所有成功的微服务实现都表现出一些共同的特征。因此，重要的是要理解这些特征，而不是坚持理论上的定义。本节详细介绍了一些共同的特征。
- en: Services are first-class citizens
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务是一等公民
- en: In the microservices world, services are first-class citizens. Microservices
    expose service endpoints as APIs and abstract all their realization details. The
    internal implementation logic, architecture, and technologies (including programming
    language, database, quality of services mechanisms, and so on) are completely
    hidden behind the service API.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务世界中，服务是一等公民。微服务将服务端点公开为API，并抽象了所有实现细节。内部实现逻辑、架构和技术（包括编程语言、数据库、服务质量机制等）完全隐藏在服务API的后面。
- en: Moreover, in the microservices architecture, there is no more application development;
    instead, organizations focus on service development. In most enterprises, this
    requires a major cultural shift in the way that applications are built.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在微服务架构中，不再有应用程序开发；相反，组织专注于服务开发。在大多数企业中，这需要应用程序构建方式的重大文化转变。
- en: In a **Customer Profile** microservice, internals such as the data structure,
    technologies, business logic, and so on are hidden. They aren't exposed or visible
    to any external entities. Access is restricted through the service endpoints or
    APIs. For instance, Customer Profile microservices may expose **Register Customer**
    and **Get Customer** as two APIs for others to interact with.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在**客户资料**微服务中，诸如数据结构、技术、业务逻辑等的内部细节被隐藏起来。它们不会暴露或对任何外部实体可见。访问是通过服务端点或API进行限制的。例如，客户资料微服务可以公开**注册客户**和**获取客户**作为其他人与之交互的两个API。
- en: Characteristics of services in a microservice
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务中的服务特性
- en: As microservices are more or less like a flavor of SOA, many of the service
    characteristics defined in the SOA are applicable to microservices as well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务在某种程度上类似于SOA，因此在微服务中也适用于SOA中定义的许多服务特性。
- en: 'The following are some of the characteristics of services that are applicable
    to microservices as well:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些适用于微服务的服务特性：
- en: '**Service contract**: Similar to SOA, microservices are described through well-defined
    service contracts. In the microservices world, JSON and REST are universally accepted
    for service communication. In the case of JSON/REST, there are many techniques
    used to define service contracts. JSON Schema, WADL, Swagger, and RAML are a few
    examples.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务契约**：与SOA类似，微服务通过明确定义的服务契约进行描述。在微服务世界中，JSON和REST被普遍接受用于服务通信。在JSON/REST的情况下，有许多用于定义服务契约的技术。JSON
    Schema、WADL、Swagger和RAML是一些例子。'
- en: '**Loose coupling**: Microservices are independent and loosely coupled. In most
    cases, microservices accept an event as input and respond with another event.
    Messaging, HTTP, and REST are commonly used for interaction between microservices.
    Message-based endpoints provide higher levels of decoupling.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：微服务是独立的和松耦合的。在大多数情况下，微服务接受事件作为输入，并以另一个事件作为响应。消息传递、HTTP和REST通常用于微服务之间的交互。基于消息的端点提供更高级别的解耦。'
- en: '**Service abstraction**: In microservices, service abstraction is not just
    an abstraction of service realization, but it also provides a complete abstraction
    of all libraries and environment details, as discussed earlier.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务抽象**：在微服务中，服务抽象不仅是服务实现的抽象，还提供了所有库和环境细节的完全抽象，正如前面讨论的那样。'
- en: '**Service reuse**: Microservices are course-grained reusable business services.
    These are accessed by mobile devices and desktop channels, other microservices,
    or even other systems.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务重用**：微服务是粗粒度可重用的业务服务。这些服务可以被移动设备和桌面渠道、其他微服务，甚至其他系统访问。'
- en: '**Statelessness**: Well-designed microservices are stateless and share nothing
    with no shared state or conversational state maintained by the services. In case
    there is a requirement to maintain state, they are maintained in a database, perhaps
    in memory.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态性**：设计良好的微服务是无状态的，不共享任何共享状态或由服务维护的对话状态。如果需要维护状态，它们会在数据库中维护，可能是在内存中。'
- en: '**Services are discoverable**: Microservices are discoverable. In a typical
    microservices environment, microservices self-advertise their existence and make
    themselves available for discovery. When services die, they automatically take
    themselves out from the microservices ecosystem.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务可发现性**：微服务是可发现的。在典型的微服务环境中，微服务会自我宣传其存在，并使自己可供发现。当服务终止时，它们会自动从微服务生态系统中退出。'
- en: '**Service interoperability**: Services are interoperable as they use standard
    protocols and message exchange standards. Messaging, HTTP, and so on are used
    as transport mechanisms. REST/JSON is the most popular method for developing interoperable
    services in the microservices world. In cases where further optimization is required
    on communications, other protocols such as Protocol Buffers, Thrift, Avro, or
    Zero MQ could be used. However, the use of these protocols may limit the overall
    interoperability of the services.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务互操作性**：服务是可互操作的，因为它们使用标准协议和消息交换标准。消息传递、HTTP等被用作传输机制。在微服务世界中，REST/JSON是开发可互操作服务最流行的方法。在需要进一步优化通信的情况下，可以使用其他协议，如Protocol
    Buffers、Thrift、Avro或Zero MQ。然而，使用这些协议可能会限制服务的整体互操作性。'
- en: '**Service composeability**: Microservices are composeable. Service composeability
    is achieved either through service orchestration or service choreography.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务可组合性**：微服务是可组合的。服务可组合性是通过服务编排或服务编舞来实现的。'
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'More detail on SOA principles can be found at:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有关SOA原则的更多细节可以在以下找到：
- en: '[http://serviceorientation.com/serviceorientation/index](http://serviceorientation.com/serviceorientation/index)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://serviceorientation.com/serviceorientation/index](http://serviceorientation.com/serviceorientation/index)'
- en: Microservices are lightweight
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务是轻量级的
- en: Well-designed microservices are aligned to a single business capability, so
    they perform only one function. As a result, one of the common characteristics
    we see in most of the implementations are microservices with smaller footprints.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的微服务与单一业务能力对齐，因此它们只执行一个功能。因此，在大多数实现中，我们看到的共同特征是具有较小足迹的微服务。
- en: When selecting supporting technologies, such as web containers, we will have
    to ensure that they are also lightweight so that the overall footprint remains
    manageable. For example, Jetty or Tomcat are better choices as application containers
    for microservices compared to more complex traditional application servers such
    as WebLogic or WebSphere.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Container technologies such as Docker also help us keep the infrastructure footprint
    as minimal as possible compared to hypervisors such as VMWare or Hyper-V.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices are lightweight](img/B05447_01_10.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, microservices are typically deployed in Docker
    containers, which encapsulate the business logic and needed libraries. This help
    us quickly replicate the entire setup on a new machine or on a completely different
    hosting environment or even to move across different cloud providers. As there
    is no physical infrastructure dependency, containerized microservices are easily
    portable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Microservices with polyglot architecture
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As microservices are autonomous and abstract everything behind service APIs,
    it is possible to have different architectures for different microservices. A
    few common characteristics that we see in microservices implementations are:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Different services use different versions of the same technologies. One microservice
    may be written on Java 1.7, and another one could be on Java 1.8.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different languages are used to develop different microservices, such as one
    microservice is developed in Java and another one in Scala.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different architectures are used, such as one microservice using the Redis cache
    to serve data, while another microservice could use MySQL as a persistent data
    store.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Microservices with polyglot architecture](img/B05447_01_11.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, as **Hotel Search** is expected to have high transaction
    volumes with stringent performance requirements, it is implemented using Erlang.
    In order to support predictive searching, Elasticsearch is used as the data store.
    At the same time, **Hotel Booking** needs more ACID transactional characteristics.
    Therefore, it is implemented using MySQL and Java. The internal implementations
    are hidden behind service endpoints defined as REST/JSON over HTTP.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Automation in a microservices environment
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the microservices implementations are automated to a maximum from development
    to production.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: As microservices break monolithic applications into a number of smaller services,
    large enterprises may see a proliferation of microservices. A large number of
    microservices is hard to manage until and unless automation is in place. The smaller
    footprint of microservices also helps us automate the microservices development
    to the deployment life cycle. In general, microservices are automated end to end—for
    example, automated builds, automated testing, automated deployment, and elastic
    scaling.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Automation in a microservices environment](img/B05447_01_12.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'As indicated in the preceding diagram, automations are typically applied during
    the development, test, release, and deployment phases:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The development phase is automated using version control tools such as Git together
    with **Continuous Integration** (**CI**) tools such as Jenkins, Travis CI, and
    so on. This may also include code quality checks and automation of unit testing.
    Automation of a full build on every code check-in is also achievable with microservices.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The testing phase will be automated using testing tools such as Selenium, Cucumber,
    and other AB testing strategies. As microservices are aligned to business capabilities,
    the number of test cases to automate is fewer compared to monolithic applications,
    hence regression testing on every build also becomes possible.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure provisioning is done through container technologies such as Docker,
    together with release management tools such as Chef or Puppet, and configuration
    management tools such as Ansible. Automated deployments are handled using tools
    such as Spring Cloud, Kubernetes, Mesos, and Marathon.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施的配置是通过诸如Docker之类的容器技术进行的，再加上诸如Chef或Puppet之类的发布管理工具，以及诸如Ansible之类的配置管理工具。自动化部署使用诸如Spring
    Cloud、Kubernetes、Mesos和Marathon之类的工具进行处理。
- en: Microservices with a supporting ecosystem
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有支持生态系统的微服务
- en: Most of the large-scale microservices implementations have a supporting ecosystem
    in place. The ecosystem capabilities include DevOps processes, centralized log
    management, service registry, API gateways, extensive monitoring, service routing,
    and flow control mechanisms.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数大规模的微服务实现都有一个支持生态系统。生态系统的能力包括DevOps流程、集中式日志管理、服务注册表、API网关、广泛的监控、服务路由和流量控制机制。
- en: '![Microservices with a supporting ecosystem](img/B05447_01_13.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![具有支持生态系统的微服务](img/B05447_01_13.jpg)'
- en: Microservices work well when supporting capabilities are in place, as represented
    in the preceding diagram.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当前图表中所代表的支持能力齐备时，微服务运行良好。
- en: Microservices are distributed and dynamic
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务是分布式和动态的
- en: 'Successful microservices implementations encapsulate logic and data within
    the service. This results in two unconventional situations: distributed data and
    logic and decentralized governance.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的微服务实现将逻辑和数据封装在服务内部。这导致了两种非常规的情况：分布式数据和逻辑以及分散的治理。
- en: Compared to traditional applications, which consolidate all logic and data into
    one application boundary, microservices decentralize data and logic. Each service,
    aligned to a specific business capability, owns its data and logic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与将所有逻辑和数据整合到一个应用边界的传统应用程序相比，微服务将数据和逻辑分散化。每个服务都与特定的业务能力对齐，拥有自己的数据和逻辑。
- en: '![Microservices are distributed and dynamic](img/B05447_01_14.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![微服务是分布式和动态的](img/B05447_01_14.jpg)'
- en: The dotted line in the preceding diagram implies the logical monolithic application
    boundary. When we migrate this to microservices, each microservice **A**, **B**,
    and **C** creates its own physical boundaries.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图表中的虚线表示逻辑单片应用边界。当我们将其迁移到微服务时，每个微服务A、B和C都创建了自己的物理边界。
- en: Microservices don't typically use centralized governance mechanisms the way
    they are used in SOA. One of the common characteristics of microservices implementations
    is that they do not relay on heavyweight enterprise-level products, such as **Enterprise
    Service Bus** (**ESB**). Instead, the business logic and intelligence are embedded
    as a part of the services themselves.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常不使用像SOA中那样的集中式治理机制。微服务实现的一个共同特点是它们不依赖于重量级的企业级产品，如企业服务总线（ESB）。相反，业务逻辑和智能被嵌入到服务本身中。
- en: '![Microservices are distributed and dynamic](img/B05447_01_15.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![微服务是分布式和动态的](img/B05447_01_15.jpg)'
- en: A typical SOA implementation is shown in the preceding diagram. Shopping logic
    is fully implemented in ESB by orchestrating different services exposed by Customer,
    Order, and Product. In the microservices approach, on the other hand, Shopping
    itself will run as a separate microservice, which interacts with Customer, Product,
    and Order in a fairly decoupled way.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图表中显示了典型的SOA实现。购物逻辑完全在ESB中实现，通过编排由客户、订单和产品提供的不同服务。另一方面，在微服务方法中，购物本身将作为一个独立的微服务运行，以一种相当解耦的方式与客户、产品和订单进行交互。
- en: SOA implementations heavily relay on static registry and repository configurations
    to manage services and other artifacts. Microservices bring a more dynamic nature
    into this. Hence, a static governance approach is seen as an overhead in maintaining
    up-to-date information. This is why most of the microservices implementations
    use automated mechanisms to build registry information dynamically from the runtime
    topologies.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: SOA实现严重依赖于静态注册表和存储库配置来管理服务和其他工件。微服务为此带来了更加动态的特性。因此，静态治理方法被视为在维护最新信息方面的负担。这就是为什么大多数微服务实现使用自动化机制从运行时拓扑动态构建注册表信息。
- en: Antifragility, fail fast, and self-healing
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反脆弱性、快速失败和自愈
- en: Antifragility is a technique successfully experimented at Netflix. It is one
    of the most powerful approaches to building fail-safe systems in modern software
    development.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 反脆弱性是Netflix成功实验的一种技术。这是现代软件开发中构建故障安全系统的最强大方法之一。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The antifragility concept is introduced by Nassim Nicholas Taleb in his book
    *Antifragile: Things That Gain from Disorder*.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 反脆弱性概念是由纳西姆·尼古拉斯·塔勒布在他的书《反脆弱：从混乱中获益的事物》中引入的。
- en: In the antifragility practice, software systems are consistently challenged.
    Software systems evolve through these challenges and, over a period of time, get
    better and better at withstanding these challenges. Amazon's GameDay exercise
    and Netflix' Simian Army are good examples of such antifragility experiments.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在反脆弱性实践中，软件系统不断受到挑战。软件系统通过这些挑战不断发展，并在一段时间内变得越来越擅长应对这些挑战。亚马逊的GameDay练习和Netflix的Simian
    Army是这种反脆弱性实验的很好例子。
- en: Fail fast is another concept used to build fault-tolerant, resilient systems.
    This philosophy advocates systems that expect failures versus building systems
    that never fail. Importance should be given to how quickly the system can fail
    and if it fails, how quickly it can recover from this failure. With this approach,
    the focus is shifted from **Mean Time Between Failures** (**MTBF**) to **Mean
    Time To Recover** (**MTTR**). A key advantage of this approach is that if something
    goes wrong, it kills itself, and downstream functions aren't stressed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 快速失败是另一个用于构建容错、弹性系统的概念。这种理念主张期望系统出现故障，而不是构建永远不会出现故障的系统。重要的是系统能够多快地失败，以及如果失败了，它能够多快地从失败中恢复。采用这种方法，重点从“平均故障间隔时间”（MTBF）转移到“平均恢复时间”（MTTR）。这种方法的一个关键优势是，如果出现问题，系统会自行终止，并且下游功能不会受到压力。
- en: Self-healing is commonly used in microservices deployments, where the system
    automatically learns from failures and adjusts itself. These systems also prevent
    future failures.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 自愈在微服务部署中通常被使用，系统会自动从失败中学习并进行调整。这些系统还可以防止未来的失败。
- en: Microservices examples
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务示例
- en: There is no "one size fits all" approach when implementing microservices. In
    this section, different examples are analyzed to crystalize the microservices
    concept.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施微服务时，没有“一刀切”的方法。在本节中，将分析不同的示例来阐明微服务的概念。
- en: An example of a holiday portal
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假期门户网站示例
- en: In the first example, we will review a holiday portal, **Fly By Points**. Fly
    By Points collects points that are accumulated when a customer books a hotel,
    flight, or car through the online website. When the customer logs in to the Fly
    By Points website, he/she is able to see the points accumulated, personalized
    offers that can be availed of by redeeming the points, and upcoming trips if any.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们将回顾一个假期门户网站，**Fly By Points**。Fly By Points收集了当客户通过在线网站预订酒店、航班或汽车时积累的积分。当客户登录Fly
    By Points网站时，他/她可以看到积累的积分、通过兑换积分可以获得的个性化优惠以及即将到来的旅行（如果有的话）。
- en: '![An example of a holiday portal](img/B05447_01_16.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![假期门户网站示例](img/B05447_01_16.jpg)'
- en: Let's assume that the preceding page is the home page after login. There are
    two upcoming trips for **Jeo**, four personalized offers, and 21,123 loyalty points.
    When the user clicks on each of the boxes, the details are queried and displayed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前一页是登录后的主页。**Jeo**有两次即将到来的旅行，四个个性化的优惠和21,123积分。当用户点击每个框时，将查询并显示详细信息。
- en: 'The holiday portal has a Java Spring-based traditional monolithic application
    architecture, as shown in the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假期门户网站采用了基于Java Spring的传统单体应用架构，如下所示：
- en: '![An example of a holiday portal](img/B05447_01_17.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![假期门户网站示例](img/B05447_01_17.jpg)'
- en: As shown in the preceding diagram, the holiday portal's architecture is web-based
    and modular, with a clear separation between layers. Following the usual practice,
    the holiday portal is also deployed as a single WAR file on a web server such
    as Tomcat. Data is stored on an all-encompassing backing relational database.
    This is a good fit for the purpose architecture when the complexities are few.
    As the business grows, the user base expands, and the complexity also increases.
    This results in a proportional increase in transaction volumes. At this point,
    enterprises should look to rearchitecting the monolithic application to microservices
    for better speed of delivery, agility, and manageability.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，假期门户网站的架构是基于Web的模块化架构，各层之间有明确的分离。按照通常的做法，假期门户网站也部署为单个WAR文件，放在诸如Tomcat之类的Web服务器上。数据存储在一个全面的关系型数据库中。当业务增长、用户基数扩大并且复杂性增加时，交易量也会成比例增加。在这一点上，企业应该考虑将单体应用重新架构为微服务，以获得更快的交付速度、灵活性和可管理性。
- en: '![An example of a holiday portal](img/B05447_01_18.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![假期门户网站示例](img/B05447_01_18.jpg)'
- en: 'Examining the simple microservices version of this application, we can immediately
    note a few things in this architecture:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这个应用程序的简单微服务版本时，我们可以立即注意到架构中的一些事情：
- en: 'Each subsystem has now become an independent system by itself, a microservice.
    There are three microservices representing three business functions: **Trips**,
    **Offers**, and **Points**. Each one has its internal data store and middle layer.
    The internal structure of each service remains the same.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个子系统现在都成为了一个独立的系统，即一个微服务。有三个微服务代表三个业务功能：**Trips**、**Offers**和**Points**。每个微服务都有自己的内部数据存储和中间层。每个服务的内部结构保持不变。
- en: Each service encapsulates its own database as well as its own HTTP listener.
    As opposed to the previous model, there is no web server or WAR. Instead, each
    service has its own embedded HTTP listener, such as Jetty, Tomcat, and so on.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都封装了自己的数据库以及自己的HTTP监听器。与之前的模型相反，没有Web服务器或WAR。相反，每个服务都有自己的嵌入式HTTP监听器，如Jetty、Tomcat等。
- en: Each microservice exposes a REST service to manipulate the resources/entity
    that belong to this service.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务都会暴露一个REST服务来操作属于该服务的资源/实体。
- en: It is assumed that the presentation layer is developed using a client-side JavaScript
    MVC framework such as Angular JS. These client-side frameworks are capable of
    invoking REST calls directly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设呈现层是使用客户端JavaScript MVC框架（如Angular JS）开发的。这些客户端框架能够直接调用REST调用。
- en: When the web page is loaded, all the three boxes, Trips, Offers, and Points
    will be displayed with details such as points, the number of offers, and the number
    of trips. This will be done by each box independently making asynchronous calls
    to the respective backend microservices using REST. There is no dependency between
    the services at the service layer. When the user clicks on any of the boxes, the
    screen will be transitioned and will load the details of the item clicked on.
    This will be done by making another call to the respective microservice.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当网页加载时，三个框，Trips、Offers和Points将显示出来，包括积分、优惠数量和旅行次数等详细信息。每个框都会独立地通过REST对应的后端微服务进行异步调用。服务层之间没有依赖关系。当用户点击任何一个框时，屏幕将进行过渡并加载所点击项目的详细信息。这将通过对应微服务的另一个调用来完成。
- en: A microservice-based order management system
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于微服务的订单管理系统
- en: 'Let''s examine another microservices example: an online retail website. In
    this case, we will focus more on the backend services, such as the Order Service
    which processes the Order Event generated when a customer places an order through
    the website:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来看一个微服务示例：在线零售网站。在这种情况下，我们将更多地关注后端服务，比如处理订单事件的订单服务，当客户通过网站下订单时会生成订单事件：
- en: '![A microservice-based order management system](img/B05447_01_19.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![基于微服务的订单管理系统](img/B05447_01_19.jpg)'
- en: This microservices system is completely designed based on reactive programming
    practices.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微服务系统完全基于反应式编程实践设计。
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Read more on reactive programming at:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下网址阅读有关响应式编程的更多信息：
- en: '[http://www.reactivemanifesto.org](http://www.reactivemanifesto.org)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.reactivemanifesto.org](http://www.reactivemanifesto.org)'
- en: When an event is published, a number of microservices are ready to kick-start
    upon receiving the event. Each one of them is independent and does not rely on
    other microservices. The advantage of this model is that we can keep adding or
    replacing microservices to achieve specific needs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发布时，许多微服务准备好在接收事件时启动。它们每一个都是独立的，不依赖于其他微服务。这种模型的优势在于我们可以不断添加或替换微服务以满足特定需求。
- en: 'In the preceding diagram, there are eight microservices shown. The following
    activities take place upon the arrival of **Order Event**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，显示了八个微服务。在**订单事件**到达时，发生以下活动：
- en: Order Service kicks off when Order Event is received. Order Service creates
    an order and saves the details to its own database.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订单服务在接收到订单事件时启动。订单服务创建订单并将详细信息保存到自己的数据库中。
- en: If the order is successfully saved, Order Successful Event is created by Order
    Service and published.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果订单成功保存，订单服务将创建并发布订单成功事件。
- en: A series of actions take place when Order Successful Event arrives.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当订单成功事件到达时，一系列操作发生。
- en: Delivery Service accepts the event and places Delivery Record to deliver the
    order to the customer. This, in turn, generates Delivery Event and publishes the
    event.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交付服务接受事件并放置交付记录以将订单交付给客户。这反过来生成交付事件并发布事件。
- en: Trucking Service picks up Delivery Event and processes it. For instance, Trucking
    Service creates a trucking plan.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运输服务接收交付事件并处理。例如，运输服务创建运输计划。
- en: Customer Notification Service sends a notification to the customer informing
    the customer that an order is placed.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户通知服务向客户发送通知，通知客户订单已经下达。
- en: Inventory Cache Service updates the inventory cache with the available product
    count.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库存缓存服务使用可用产品数量更新库存缓存。
- en: Stock Reorder Service checks whether the stock limits are adequate and generates
    Replenish Event if required.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库存重新订购服务检查库存限制是否足够，并在需要时生成补货事件。
- en: Customer Points Service recalculates the customer's loyalty points based on
    this purchase.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户积分服务根据此购买重新计算客户的忠诚积分。
- en: '**Customer Account Service** updates the order history in the customer''s account.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户账户服务**更新客户账户中的订单历史记录。'
- en: In this approach, each service is responsible for only one function. Services
    accept and generate events. Each service is independent and is not aware of its
    neighborhood. Hence, the neighborhood can organically grow as mentioned in the
    honeycomb analogy. New services can be added as and when necessary. Adding a new
    service does not impact any of the existing services.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，每个服务只负责一个功能。服务接受并生成事件。每个服务都是独立的，不知道自己的邻居。因此，邻居可以像蜂窝类比中提到的那样有机地增长。新服务可以根据需要添加。添加新服务不会影响任何现有服务。
- en: An example of a travel agent portal
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旅行代理门户的示例
- en: This third example is a simple travel agent portal application. In this example,
    we will see both synchronous REST calls as well as asynchronous events.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这第三个示例是一个简单的旅行代理门户应用程序。在这个例子中，我们将看到同步的REST调用以及异步事件。
- en: In this case, the portal is just a container application with multiple menu
    items or links in the portal. When specific pages are requested—for example, when
    the menu or a link is clicked on—they will be loaded from the specific microservices.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，门户只是一个包含多个菜单项或链接的容器应用程序。当请求特定页面时，例如当单击菜单或链接时，它们将从特定的微服务加载。
- en: '![An example of a travel agent portal](img/B05447_01_20.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![旅行代理门户的示例](img/B05447_01_20.jpg)'
- en: 'When a customer requests a booking, the following events take place internally:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户请求预订时，内部发生以下事件：
- en: The travel agent opens the flight UI, searches for a flight, and identifies
    the right flight for the customer. Behind the scenes, the flight UI is loaded
    from the Flight microservice. The flight UI only interacts with its own backend
    APIs within the Flight microservice. In this case, it makes a REST call to the
    Flight microservice to load the flights to be displayed.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旅行代理打开航班UI，搜索航班，并为客户确定合适的航班。在幕后，航班UI是从航班微服务加载的。航班UI只与航班微服务内部的自己的后端API交互。在这种情况下，它通过REST调用航班微服务来加载要显示的航班。
- en: The travel agent then queries the customer details by accessing the customer
    UI. Similar to the flight UI, the customer UI is loaded from the Customer microservice.
    Actions in the customer UI will invoke REST calls on the Customer microservice.
    In this case, customer details are loaded by invoking appropriate APIs on the
    Customer microservice.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，旅行代理通过访问客户UI查询客户详细信息。与航班UI类似，客户UI是从客户微服务加载的。客户UI中的操作将在客户微服务上调用REST调用。在这种情况下，通过调用客户微服务上的适当API加载客户详细信息。
- en: Then, the travel agent checks the visa details for the customer's eligibility
    to travel to the selected country. This also follows the same pattern as mentioned
    in the previous two points.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，旅行代理检查客户的签证详细信息，以确定客户是否有资格前往所选国家。这也遵循前两点中提到的相同模式。
- en: Next, the travel agent makes a booking using the booking UI from the Booking
    microservice, which again follows the same pattern.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，旅行代理使用预订微服务的预订UI进行预订，这再次遵循相同的模式。
- en: The payment pages are loaded from the Payment microservice. In general, the
    payment service has additional constraints such as PCIDSS compliance (protecting
    and encrypting data in motion and data at rest). The advantage of the microservices
    approach is that none of the other microservices need to be considered under the
    purview of PCIDSS as opposed to the monolithic application, where the complete
    application comes under the governing rules of PCIDSS. Payment also follows the
    same pattern as described earlier.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支付页面是从支付微服务加载的。一般来说，支付服务有额外的约束条件，比如PCIDSS合规性（保护和加密数据在传输和静态数据）。微服务方法的优势在于，与单体应用相比，其他微服务不需要考虑PCIDSS的监管范围，而单体应用中整个应用都受PCIDSS规则的约束。支付也遵循前面描述的模式。
- en: Once the booking is submitted, the Booking microservice calls the flight service
    to validate and update the flight booking. This orchestration is defined as part
    of the Booking microservice. Intelligence to make a booking is also held within
    the Booking microservice. As part of the booking process, it also validates, retrieves,
    and updates the Customer microservice.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦预订提交，预订微服务调用航班服务来验证和更新航班预订。这种编排是作为预订微服务的一部分定义的。进行预订的智能也保存在预订微服务中。作为预订过程的一部分，它还验证、检索和更新客户微服务。
- en: Finally, the Booking microservice sends the Booking Event, which the Notification
    service picks up and sends a notification of to the customer.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，预订微服务发送预订事件，通知服务接收并向客户发送通知。
- en: The interesting factor here is that we can change the user interface, logic,
    and data of a microservice without impacting any other microservices.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的有趣因素是，我们可以在不影响其他微服务的情况下更改微服务的用户界面、逻辑和数据。
- en: This is a clean and neat approach. A number of portal applications can be built
    by composing different screens from different microservices, especially for different
    user communities. The overall behavior and navigation will be controlled by the
    portal application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种清晰而整洁的方法。可以通过组合不同微服务的不同屏幕来构建许多门户应用程序，特别是针对不同的用户群体。整体行为和导航将由门户应用程序控制。
- en: The approach has a number of challenges unless the pages are designed with this
    approach in mind. Note that the site layouts and static content will be loaded
    by the **Content Management System** (**CMS**) as layout templates. Alternately,
    this could be stored in a web server. The site layout may have fragments of UIs
    that will be loaded from the microservices at runtime.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除非页面是根据这种方法设计的，否则这种方法会面临许多挑战。请注意，网站布局和静态内容将由**内容管理系统**（**CMS**）作为布局模板加载。或者，这些内容可以存储在Web服务器上。网站布局可能包含从微服务在运行时加载的UI片段。
- en: Microservices benefits
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的好处
- en: Microservices offer a number of benefits over the traditional multitier, monolithic
    architectures. This section explains some key benefits of the microservices architecture
    approach.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务相对于传统的多层、单片架构有许多优势。本节解释了微服务架构方法的一些关键优势。
- en: Supports polyglot architecture
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持多语言架构
- en: With microservices, architects and developers can choose fit for purpose architectures
    and technologies for each microservice. This gives the flexibility to design better-fit
    solutions in a more cost-effective way.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有了微服务，架构师和开发人员可以为每个微服务选择合适的架构和技术。这样可以灵活地以更具成本效益的方式设计更合适的解决方案。
- en: As microservices are autonomous and independent, each service can run with its
    own architecture or technology or different versions of technologies.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务是自治和独立的，每个服务可以使用自己的架构或技术，或者不同版本的技术运行。
- en: The following shows a simple, practical example of a polyglot architecture with
    microservices.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单、实际的微服务多语言架构的示例。
- en: '![Supports polyglot architecture](img/B05447_01_21.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![支持多语言架构](img/B05447_01_21.jpg)'
- en: There is a requirement to audit all system transactions and record transaction
    details such as request and response data, the user who initiated the transaction,
    the service invoked, and so on.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个要求对所有系统交易进行审计，并记录诸如请求和响应数据、发起交易的用户、调用的服务等交易细节。
- en: As shown in the preceding diagram, while core services such as the Order and
    Products microservices use a relational data store, the Audit microservice persists
    data in Hadoop File System (HDFS). A relational data store is neither ideal nor
    cost effective in storing large data volumes such as in the case of audit data.
    In the monolithic approach, the application generally uses a shared, single database
    that stores Order, Products, and Audit data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，核心服务如订单和产品微服务使用关系型数据存储，而审计微服务将数据持久化在Hadoop文件系统（HDFS）中。在存储大数据量的情况下，关系型数据存储既不理想也不划算，比如审计数据。在单体架构中，应用通常使用一个共享的单一数据库来存储订单、产品和审计数据。
- en: In this example, the audit service is a technical microservice using a different
    architecture. Similarly, different functional services could also use different
    architectures.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，审计服务是一个使用不同架构的技术微服务。同样，不同的功能服务也可以使用不同的架构。
- en: In another example, there could be a Reservation microservice running on Java
    7, while a Search microservice could be running on Java 8\. Similarly, an Order
    microservice could be written on Erlang, whereas a Delivery microservice could
    be on the Go language. None of these are possible with a monolithic architecture.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个例子中，可能有一个运行在Java 7上的预订微服务，而搜索微服务可能在Java 8上运行。同样，订单微服务可以用Erlang编写，而交付微服务可以使用Go语言。这些在单体架构中都是不可能的。
- en: Enabling experimentation and innovation
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 促进实验和创新
- en: Modern enterprises are thriving towards quick wins. Microservices are one of
    the key enablers for enterprises to do disruptive innovation by offering the ability
    to experiment and fail fast.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现代企业正在追求快速成功。微服务是企业实施颠覆性创新的关键推动因素之一，因为它们提供了实验和快速失败的能力。
- en: As services are fairly simple and smaller in size, enterprises can afford to
    experiment new processes, algorithms, business logics, and so on. With large monolithic
    applications, experimentation was not easy; nor was it straightforward or cost
    effective. Businesses had to spend huge money to build or change an application
    to try out something new. With microservices, it is possible to write a small
    microservice to achieve the targeted functionality and plug it into the system
    in a reactive style. One can then experiment with the new function for a few months,
    and if the new microservice does not work as expected, we can change or replace
    it with another one. The cost of change will be considerably less compared to
    that of the monolithic approach.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务相当简单且规模较小，企业可以承担尝试新的流程、算法、业务逻辑等。对于大型单片应用程序，实验并不容易；也不直接或成本效益高。企业必须花费巨资来构建或更改应用程序以尝试新的东西。使用微服务，可以编写一个小型微服务来实现目标功能，并以一种反应式的方式将其插入系统中。然后可以对新功能进行几个月的实验，如果新的微服务不如预期那样工作，我们可以更改或替换为另一个。与单片方法相比，变更成本将大大降低。
- en: '![Enabling experimentation and innovation](img/B05447_01_22.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![启用实验和创新](img/B05447_01_22.jpg)'
- en: In another example of an airline booking website, the airline wants to show
    personalized hotel recommendations in their booking page. The recommendations
    must be displayed on the booking confirmation page.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个航空公司预订网站的示例中，航空公司希望在其预订页面上显示个性化的酒店推荐。这些推荐必须显示在预订确认页面上。
- en: As shown in the preceding diagram, it is convenient to write a microservice
    that can be plugged into the monolithic applications booking flow rather than
    incorporating this requirement in the monolithic application itself. The airline
    may choose to start with a simple recommendation service and keep replacing it
    with newer versions till it meets the required accuracy.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，编写一个可以插入单片应用程序预订流程的微服务比在单片应用程序本身中包含此要求更方便。航空公司可以选择从一个简单的推荐服务开始，并不断用更新的版本替换，直到满足所需的准确性。
- en: Elastically and selectively scalable
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性和可选择性可扩展
- en: As microservices are smaller units of work, they enable us to implement selective
    scalability.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务是较小的工作单元，它们使我们能够实现选择性的可伸缩性。
- en: Scalability requirements may be different for different functions in an application.
    A monolithic application, packaged as a single WAR or an EAR, can only be scaled
    as a whole. An I/O-intensive function when streamed with high velocity data could
    easily bring down the service levels of the entire application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 不同功能在应用程序中可能有不同的可伸缩性要求。作为单个WAR或EAR打包的单片应用程序只能作为一个整体进行扩展。当I/O密集型功能以高速数据流进行传输时，很容易降低整个应用程序的服务水平。
- en: In the case of microservices, each service could be independently scaled up
    or down. As scalability can be selectively applied at each service, the cost of
    scaling is comparatively less with the microservices approach.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务的情况下，每个服务都可以独立地进行横向或纵向扩展。由于可在每个服务上选择性地应用可伸缩性，因此与微服务方法相比，扩展的成本相对较低。
- en: 'In practice, there are many different ways available to scale an application
    and is largely subject to the architecture and behavior of the application. **Scale
    Cube** defines primarily three approaches to scaling an application:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，有许多不同的方法可用于扩展应用程序，这在很大程度上取决于应用程序的架构和行为。**Scale Cube**主要定义了扩展应用程序的三种方法：
- en: Scaling the *x* axis by horizontally cloning the application
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过水平克隆应用程序来扩展*x*轴
- en: Scaling the *y* axis by splitting different functionality
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过分割不同的功能来扩展*y*轴
- en: Scaling the *z* axis by partitioning or sharding the data
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过分区或分片数据来扩展*z*轴
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Read more about Scale Cube in the following site:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下网站了解有关Scale Cube的更多信息：
- en: '[http://theartofscalability.com/](http://theartofscalability.com/)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://theartofscalability.com/](http://theartofscalability.com/)'
- en: When *y* axis scaling is applied to monolithic applications, it breaks the monolithic
    to smaller units aligned with business functions. Many organizations successfully
    applied this technique to move away from monolithic applications. In principle,
    the resulting units of functions are in line with the microservices characteristics.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当将*y*轴扩展应用于单片应用程序时，它将单片应用程序分解为与业务功能对齐的较小单元。许多组织成功地应用了这种技术，摆脱了单片应用程序。原则上，功能的结果单元符合微服务的特征。
- en: For instance, in a typical airline website, statistics indicate that the ratio
    of flight searching to flight booking could be as high as 500:1\. This means one
    booking transaction for every 500 search transactions. In this scenario, the search
    needs 500 times more scalability than the booking function. This is an ideal use
    case for selective scaling.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在典型的航空公司网站上，统计数据表明，航班搜索与航班预订的比例可能高达500:1。这意味着每500次搜索交易就会有一次预订交易。在这种情况下，搜索需要比预订功能多500倍的可伸缩性。这是选择性扩展的理想用例。
- en: '![Elastically and selectively scalable](img/B05447_01_23.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![弹性和可选择性可扩展](img/B05447_01_23.jpg)'
- en: The solution is to treat search requests and booking requests differently. With
    a monolithic architecture, this is only possible with *z* scaling in the scale
    cube. However, this approach is expensive because in the *z* scale, the entire
    code base is replicated.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将搜索请求和预订请求区分对待。在单片架构中，这只有在规模立方体的*z*扩展中才可能。然而，这种方法很昂贵，因为在*z*规模中，整个代码库都会被复制。
- en: In the preceding diagram, Search and Booking are designed as different microservices
    so that Search can be scaled differently from Booking. In the diagram, Search
    has three instances, and Booking has two instances. Selective scalability is not
    limited to the number of instances, as shown in the diagram, but also in the way
    in which the microservices are architected. In the case of Search, an **in-memory
    data grid** (**IMDG**) such as Hazelcast can be used as the data store. This will
    further increase the performance and scalability of Search. When a new Search
    microservice instance is instantiated, an additional IMDG node is added to the
    IMDG cluster. Booking does not require the same level of scalability. In the case
    of Booking, both instances of the Booking microservice are connected to the same
    instance of the database.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Allowing substitution
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices are self-contained, independent deployment modules enabling the
    substitution of one microservice with another similar microservice.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Many large enterprises follow buy-versus-build policies to implement software
    systems. A common scenario is to build most of the functions in house and buy
    certain niche capabilities from specialists outside. This poses challenges in
    traditional monolithic applications as these application components are highly
    cohesive. Attempting to plug in third-party solutions to the monolithic applications
    results in complex integrations. With microservices, this is not an afterthought.
    Architecturally, a microservice can be easily replaced by another microservice
    developed either in-house or even extended by a microservice from a third party.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![Allowing substitution](img/B05447_01_24.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: A pricing engine in the airline business is complex. Fares for different routes
    are calculated using complex mathematical formulas known as the pricing logic.
    Airlines may choose to buy a pricing engine from the market instead of building
    the product in house. In the monolithic architecture, Pricing is a function of
    Fares and Booking. In most cases Pricing, Fares, and Booking are hardwired, making
    it almost impossible to detach.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: In a well-designed microservices system, Booking, Fares, and Pricing would be
    independent microservices. Replacing the Pricing microservice will have only a
    minimal impact on any other services as they are all loosely coupled and independent.
    Today, it could be a third-party service; tomorrow, it could be easily substituted
    by another third-party or home-grown service.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Enabling to build organic systems
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices help us build systems that are organic in nature. This is significantly
    important when migrating monolithic systems gradually to microservices.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Organic systems are systems that grow laterally over a period of time by adding
    more and more functions to it. In practice, an application grows unimaginably
    large in its lifespan, and in most cases, the manageability of the application
    reduces dramatically over this same period of time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are all about independently manageable services. This enable us
    to keep adding more and more services as the need arises with minimal impact on
    the existing services. Building such systems does not need huge capital investments.
    Hence, businesses can keep building as part of their operational expenditure.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: A loyalty system in an airline was built years ago, targeting individual passengers.
    Everything was fine until the airline started offering loyalty benefits to their
    corporate customers. Corporate customers are individuals grouped under corporations.
    As the current systems core data model is flat, targeting individuals, the corporate
    environment needs a fundamental change in the core data model, and hence huge
    reworking, to incorporate this requirement.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling to build organic systems](img/B05447_01_25.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, in a microservices-based architecture, customer
    information would be managed by the Customer microservice and loyalty by the Loyalty
    Points microservice.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在基于微服务的架构中，客户信息将由客户微服务管理，忠诚度将由忠诚度积分微服务管理。
- en: In this situation, it is easy to add a new Corporate Customer microservice to
    manage corporate customers. When a corporation is registered, individual members
    will be pushed to the Customer microservice to manage them as usual. The Corporate
    Customer microservice provides a corporate view by aggregating data from the Customer
    microservice. It will also provide services to support corporate-specific business
    rules. With this approach, adding new services will have only a minimal impact
    on the existing services.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，很容易添加一个新的企业客户微服务来管理企业客户。当一个公司注册时，个别成员将被推送到客户微服务中，以便像往常一样管理他们。企业客户微服务通过从客户微服务中聚合数据来提供企业视图。它还将提供支持企业特定业务规则的服务。采用这种方法，添加新服务对现有服务的影响将最小化。
- en: Helping reducing technology debt
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帮助减少技术债务
- en: As microservices are smaller in size and have minimal dependencies, they allow
    the migration of services that use end-of-life technologies with minimal cost.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务体积较小且依赖性较小，它们允许以最小成本迁移使用末期技术的服务。
- en: Technology changes are one of the barriers in software development. In many
    traditional monolithic applications, due to the fast changes in technologies,
    today's next-generation applications could easily become legacy even before their
    release to production. Architects and developers tend to add a lot of protection
    against technology changes by adding layers of abstractions. However, in reality,
    this approach does not solve the issue but, instead, results in over-engineered
    systems. As technology upgrades are often risky and expensive with no direct returns
    to business, the business may not be happy to invest in reducing the technology
    debt of the applications.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 技术变化是软件开发中的障碍之一。在许多传统的单片应用程序中，由于技术的快速变化，今天的下一代应用程序甚至在发布到生产之前就可能成为遗留系统。架构师和开发人员倾向于通过添加抽象层来保护技术变化。然而，实际上，这种方法并不能解决问题，反而导致了过度设计的系统。由于技术升级通常是风险和昂贵的，并且对业务没有直接回报，因此业务可能不愿意投资于减少应用程序的技术债务。
- en: With microservices, it is possible to change or upgrade technology for each
    service individually rather than upgrading an entire application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务，可以单独为每个服务更改或升级技术，而不是升级整个应用程序。
- en: Upgrading an application with, for instance, five million lines written on EJB
    1.1 and Hibernate to the Spring, JPA, and REST services is almost similar to rewriting
    the entire application. In the microservices world, this could be done incrementally.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将使用EJB 1.1和Hibernate编写的五百万行代码升级到Spring、JPA和REST服务几乎等同于重写整个应用程序。在微服务世界中，这可以逐步完成。
- en: '![Helping reducing technology debt](img/B05447_01_26.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![帮助减少技术债务](img/B05447_01_26.jpg)'
- en: As shown in the preceding diagram, while older versions of the services are
    running on old versions of technologies, new service developments can leverage
    the latest technologies. The cost of migrating microservices with end-of-life
    technologies is considerably less compared to enhancing monolithic applications.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，旧版本的服务在旧版本的技术上运行，而新服务开发可以利用最新的技术。与增强单片应用程序相比，使用末期技术迁移微服务的成本要低得多。
- en: Allowing the coexistence of different versions
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许不同版本的共存
- en: As microservices package the service runtime environment along with the service
    itself, this enables having multiple versions of the service to coexist in the
    same environment.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务将服务运行时环境与服务本身打包在一起，这使得同一环境中可以存在多个服务版本。
- en: There will be situations where we will have to run multiple versions of the
    same service at the same time. Zero downtime promote, where one has to gracefully
    switch over from one version to another, is one example of a such a scenario as
    there will be a time window where both services will have to be up and running
    simultaneously. With monolithic applications, this is a complex procedure because
    upgrading new services in one node of the cluster is cumbersome as, for instance,
    this could lead to class loading issues. A canary release, where a new version
    is only released to a few users to validate the new service, is another example
    where multiple versions of the services have to coexist.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将出现需要同时运行同一服务的多个版本的情况。零停机推广，其中必须从一个版本平稳地切换到另一个版本，就是这样一个情况的例子，因为会有一个时间窗口，两个服务必须同时运行。对于单片应用程序来说，这是一个复杂的过程，因为在集群的一个节点中升级新服务是很麻烦的，例如，这可能导致类加载问题。金丝雀发布，其中新版本只发布给少数用户以验证新服务，是另一个需要多个服务版本共存的例子。
- en: With microservices, both these scenarios are easily manageable. As each microservice
    uses independent environments, including service listeners such as Tomcat or Jetty
    embedded, multiple versions can be released and gracefully transitioned without
    many issues. When consumers look up services, they look for specific versions
    of services. For example, in a canary release, a new user interface is released
    to user A. When user A sends a request to the microservice, it looks up the canary
    release version, whereas all other users will continue to look up the last production
    version.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务，这两种情况都很容易管理。由于每个微服务都使用独立的环境，包括像Tomcat或Jetty嵌入式的服务监听器，因此可以发布多个版本并在没有太多问题的情况下进行平稳过渡。当消费者查找服务时，他们会寻找特定版本的服务。例如，在金丝雀发布中，新用户界面发布给用户A。当用户A发送请求到微服务时，它会查找金丝雀发布版本，而所有其他用户将继续查找上一个生产版本。
- en: Care needs to be taken at the database level to ensure the database design is
    always backward compatible to avoid breaking the changes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库层面需要注意确保数据库设计始终向后兼容，以避免破坏更改。
- en: '![Allowing the coexistence of different versions](img/B05447_01_27.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![允许不同版本共存](img/B05447_01_27.jpg)'
- en: As shown in the preceding diagram, version 1 and 2 of the **Customer** service
    can coexist as they are not interfering with each other, given their respective
    deployment environments. Routing rules can be set at the gateway to divert traffic
    to specific instances, as shown in the diagram. Alternatively, clients can request
    specific versions as part of the request itself. In the diagram, the gateway selects
    the version based on the region from which the request is originated.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，**客户**服务的版本1和2可以共存，因为它们不会相互干扰，考虑到它们各自的部署环境。路由规则可以在网关处设置，以将流量转发到特定实例，如图所示。或者，客户端可以在请求本身中请求特定版本。在图中，网关根据请求的来源地选择版本。
- en: Supporting the building of self-organizing systems
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持自组织系统的构建
- en: Microservices help us build self-organizing systems. A self-organizing system
    support will automate deployment, be resilient, and exhibit self-healing and self-learning
    capabilities.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务帮助我们构建自组织系统。自组织系统支持将自动化部署，具有弹性，并展现自愈和自学习能力。
- en: In a well-architected microservices system, a service is unaware of other services.
    It accepts a message from a selected queue and processes it. At the end of the
    process, it may send out another message, which triggers other services. This
    allows us to drop any service into the ecosystem without analyzing the impact
    on the overall system. Based on the input and output, the service will self-organize
    into the ecosystem. No additional code changes or service orchestration is required.
    There is no central brain to control and coordinate the processes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在良好架构的微服务系统中，服务不知道其他服务。它接受来自选定队列的消息并处理它。在处理结束时，它可能发送另一条消息，触发其他服务。这使我们可以将任何服务放入生态系统中，而无需分析对整个系统的影响。根据输入和输出，服务将自组织到生态系统中。不需要额外的代码更改或服务编排。没有中央大脑来控制和协调流程。
- en: 'Imagine an existing notification service that listens to an **INPUT** queue
    and sends notifications to an **SMTP** server, as shown in the following figure:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，现有的通知服务监听**INPUT**队列并将通知发送到**SMTP**服务器，如下图所示：
- en: '![Supporting the building of self-organizing systems](img/B05447_01_28.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: 支持自组织系统的构建
- en: Let's assume, later, a personalization engine, responsible for changing the
    language of the message to the customer's native language, needs to be introduced
    to personalize messages before sending them to the customer, the personalization
    engine is responsible for changing the language of the message to the customer's
    native language.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以后需要引入一个个性化引擎，负责将消息的语言更改为客户的母语，以在发送给客户之前个性化消息，个性化引擎负责将消息的语言更改为客户的母语。
- en: '![Supporting the building of self-organizing systems](img/B05447_01_29.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: 支持自组织系统的构建
- en: With microservices, a new personalization microservice will be created to do
    this job. The input queue will be configured as INPUT in an external configuration
    server, and the personalization service will pick up the messages from the INPUT
    queue (earlier, this was used by the notification service) and send the messages
    to the OUTPUT queue after completing process. The notification services input
    queue will then send to OUTPUT. From the very next moment onward, the system automatically
    adopts this new message flow.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务，将创建一个新的个性化微服务来执行此任务。输入队列将在外部配置服务器中配置为INPUT，并且个性化服务将从INPUT队列中获取消息（之前由通知服务使用），并在完成处理后将消息发送到OUTPUT队列。通知服务的输入队列将然后发送到OUTPUT。从下一刻起，系统将自动采用这种新的消息流。
- en: Supporting event-driven architecture
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持事件驱动架构
- en: Microservices enable us to develop transparent software systems. Traditional
    systems communicate with each other through native protocols and hence behave
    like a black box application. Business events and system events, unless published
    explicitly, are hard to understand and analyze. Modern applications require data
    for business analysis, to understand dynamic system behaviors, and analyze market
    trends, and they also need to respond to real-time events. Events are useful mechanisms
    for data extraction.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务使我们能够开发透明的软件系统。传统系统通过本机协议相互通信，因此表现为黑匣子应用程序。业务事件和系统事件，除非明确发布，否则很难理解和分析。现代应用程序需要数据进行业务分析，以了解动态系统行为，并分析市场趋势，它们还需要响应实时事件。事件是数据提取的有用机制。
- en: A well-architected microservice always works with events for both input and
    output. These events can be tapped by any service. Once extracted, events can
    be used for a variety of use cases.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 良好架构的微服务始终使用事件作为输入和输出。这些事件可以被任何服务利用。一旦提取，事件可以用于各种用例。
- en: For example, the business wants to see the velocity of orders categorized by
    product type in real time. In a monolithic system, we need to think about how
    to extract these events. This may impose changes in the system.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，业务希望实时查看按产品类型分类的订单速度。在单片系统中，我们需要考虑如何提取这些事件。这可能会对系统造成改变。
- en: '![Supporting event-driven architecture](img/B05447_01_30.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: 支持事件驱动架构
- en: In the microservices world, **Order Event** is already published whenever an
    order is created. This means that it is just a matter of adding a new service
    to subscribe to the same topic, extract the event, perform the requested aggregations,
    and push another event for the dashboard to consume.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务世界中，**订单事件**在订单创建时已经发布。这意味着只需要添加一个新的服务来订阅相同的主题，提取事件，执行请求的聚合，并推送另一个事件供仪表板消费。
- en: Enabling DevOps
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用DevOps
- en: Microservices are one of the key enablers of DevOps. DevOps is widely adopted
    as a practice in many enterprises, primarily to increase the speed of delivery
    and agility. A successful adoption of DevOps requires cultural changes, process
    changes, as well as architectural changes. DevOps advocates to have agile development,
    high-velocity release cycles, automatic testing, automatic infrastructure provisioning,
    and automated deployment.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是DevOps的关键推动因素之一。DevOps被广泛采用作为许多企业的实践，主要是为了提高交付速度和敏捷性。成功采用DevOps需要文化变革、流程变革以及架构变革。DevOps主张具有敏捷开发、高速发布周期、自动化测试、自动化基础设施配置和自动化部署。
- en: Automating all these processes is extremely hard to achieve with traditional
    monolithic applications. Microservices are not the ultimate answer, but microservices
    are at the center stage in many DevOps implementations. Many DevOps tools and
    techniques are also evolving around the use of microservices.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 用传统的单片应用程序自动化所有这些过程是非常难以实现的。微服务并不是终极答案，但在许多DevOps实施中，微服务处于中心舞台。许多DevOps工具和技术也围绕着微服务的使用而不断发展。
- en: Consider a monolithic application that takes hours to complete a full build
    and 20 to 30 minutes to start the application; one can see that this kind of application
    is not ideal for DevOps automation. It is hard to automate continuous integration
    on every commit. As large, monolithic applications are not automation friendly,
    continuous testing and deployments are also hard to achieve.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个需要数小时才能完成完整构建并且需要20到30分钟才能启动应用程序的单片应用程序；可以看出这种应用程序不太适合DevOps自动化。很难在每次提交时自动化持续集成。由于大型的单片应用程序不太适合自动化，连续测试和部署也很难实现。
- en: On the other hand, small footprint microservices are more automation-friendly
    and therefore can more easily support these requirements.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，小型微服务更易于自动化，并且因此更容易支持这些要求。
- en: Microservices also enable smaller, focused agile teams for development. Teams
    will be organized based on the boundaries of microservices.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务还可以为开发提供更小、更专注的敏捷团队。团队将根据微服务的边界进行组织。
- en: Relationship with other architecture styles
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他架构风格的关系
- en: Now that we have seen the characteristics and benefits of microservices, in
    this section, we will explore the relationship of microservices with other closely
    related architecture styles such as SOA and Twelve-Factor Apps.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了微服务的特点和好处，在本节中，我们将探讨微服务与其他密切相关的架构风格（如SOA和十二要素应用）的关系。
- en: Relations with SOA
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与SOA的关系
- en: SOA and microservices follow similar concepts. Earlier in this chapter, we discussed
    that microservices are evolved from SOA, and many service characteristics are
    common in both approaches.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: SOA和微服务遵循类似的概念。在本章的前面，我们讨论了微服务是从SOA发展而来的，并且许多服务特点在这两种方法中都是共通的。
- en: However, are they the same or are they different?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们是相同的还是不同的？
- en: As microservices are evolved from SOA, many characteristics of microservices
    are similar to SOA. Let's first examine the definition of SOA.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务是从SOA发展而来的，许多微服务的特点与SOA相似。让我们首先来看一下SOA的定义。
- en: 'The definition of SOA from *The Open Group* consortium is as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*The Open Group*联盟对SOA的定义如下：'
- en: '"Service-Oriented Architecture (SOA) is an architectural style that supports
    service orientation. Service orientation is a way of thinking in terms of services
    and service-based development and the outcomes of services.'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “面向服务的架构（SOA）是一种支持服务定位的架构风格。服务定位是一种以服务和基于服务的开发思维方式以及服务的结果。
- en: '>'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: 'A service:'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个服务：
- en: '>'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: Is a logical representation of a repeatable business activity that has a specified
    outcome (e.g., check customer credit, provide weather data, consolidate drilling
    reports)
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是一个可重复的业务活动的逻辑表示，具有指定的结果（例如，检查客户信用、提供天气数据、整合钻井报告）
- en: '>'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: It is self-contained.
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它是自包含的。
- en: '>'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: It may be composed of other services.
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它可能由其他服务组成。
- en: '>'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: It is a "black box" to consumers of the service."
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于服务的消费者来说，这是一个“黑匣子”。
- en: 'We observed similar aspects in microservices as well. So, in what way are microservices
    different? The answer is: it depends.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在微服务中观察到了类似的方面。那么，微服务有什么不同之处呢？答案是：这取决于情况。
- en: The answer to the previous question could be yes or no, depending upon the organization
    and its adoption of SOA. SOA is a broader term, and different organizations approached
    SOA differently to solve different organizational problems. The difference between
    microservices and SOA is in a way based on how an organization approaches SOA.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上一个问题的答案可能是肯定的，也可能是否定的，这取决于组织及其对SOA的采用。SOA是一个更广泛的术语，不同的组织以不同的方式来解决不同的组织问题。微服务和SOA之间的区别在于组织如何对待SOA。
- en: In order to get clarity, a few cases will be examined.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确，将研究一些案例。
- en: Service-oriented integration
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向服务的集成
- en: Service-oriented integration refers to a service-based integration approach
    used by many organizations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的集成是指许多组织使用的基于服务的集成方法。
- en: '![Service-oriented integration](img/B05447_01_31.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![面向服务的集成](img/B05447_01_31.jpg)'
- en: Many organizations would have used SOA primarily to solve their integration
    complexities, also known as integration spaghetti. Generally, this is termed as
    **Service-Oriented Integration** (**SOI**). In such cases, applications communicate
    with each other through a common integration layer using standard protocols and
    message formats such as SOAP/XML-based web services over HTTP or JMS. These types
    of organizations focus on **Enterprise Integration Patterns** (**EIP**) to model
    their integration requirements. This approach strongly relies on heavyweight ESB
    such as TIBCO Business Works, WebSphere ESB, Oracle ESB, and the likes. Most ESB
    vendors also packed a set of related products such as rules engines, business
    process management engines, and so on as an SOA suite. Such organizations' integrations
    are deeply rooted into their products. They either write heavy orchestration logic
    in the ESB layer or the business logic itself in the service bus. In both cases,
    all enterprise services are deployed and accessed via ESB. These services are
    managed through an enterprise governance model. For such organizations, microservices
    are altogether different from SOA.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Legacy modernization
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SOA is also used to build service layers on top of legacy applications.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![Legacy modernization](img/B05447_01_32.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: Another category of organizations would use SOA in transformation projects or
    legacy modernization projects. In such cases, the services are built and deployed
    in the ESB layer connecting to backend systems using ESB adapters. For these organizations,
    microservices are different from SOA.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented application
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some organizations adopt SOA at an application level.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![Service-oriented application](img/B05447_01_33.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: In this approach, lightweight integration frameworks, such as Apache Camel or
    Spring Integration, are embedded within applications to handle service-related
    cross-cutting capabilities such as protocol mediation, parallel execution, orchestration,
    and service integration. As some of the lightweight integration frameworks have
    native Java object support, such applications would even use native **Plain Old
    Java Objects** (**POJO**) services for integration and data exchange between services.
    As a result, all services have to be packaged as one monolithic web archive. Such
    organizations could see microservices as the next logical step of their SOA.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic migration using SOA
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Monolithic migration using SOA](img/B05447_01_34.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: The last possibility is transforming a monolithic application into smaller units
    after hitting the breaking point with the monolithic system. They would break
    the application into smaller, physically deployable subsystems, similar to the
    *y* axis scaling approach explained earlier, and deploy them as web archives on
    web servers or as JARs deployed on some home-grown containers. These subsystems
    as service would use web services or other lightweight protocols to exchange data
    between services. They would also use SOA and service design principles to achieve
    this. For such organizations, they may tend to think that microservices are the
    same old wine in a new bottle.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Relations with Twelve-Factor apps
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloud computing is one of the rapidly evolving technologies. Cloud computing
    promises many benefits, such as cost advantage, speed, agility, flexibility, and
    elasticity. There are many cloud providers offering different services. They lower
    the cost models to make it more attractive to the enterprises. Different cloud
    providers such as AWS, Microsoft, Rackspace, IBM, Google, and so on use different
    tools, technologies, and services. On the other hand, enterprises are aware of
    this evolving battlefield and, therefore, they are looking for options for de-risking
    from lockdown to a single vendor.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Many organizations do lift and shift their applications to the cloud. In such
    cases, the applications may not realize all the benefits promised by cloud platforms.
    Some applications need to undergo overhaul, whereas some may need minor tweaking
    before moving to cloud. This by and large depends upon how the application is
    architected and developed.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the application has its production database server URLs hardcoded
    as part of the applications WAR, it needs to be modified before moving the application
    to cloud. In the cloud, the infrastructure is transparent to the application,
    and especially, the physical IP addresses cannot be assumed.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: How do we ensure that an application, or even microservices, can run seamlessly
    across multiple cloud providers and take advantages of cloud services such as
    elasticity?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: It is important to follow certain principles while developing cloud native applications.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cloud native is a term used for developing applications that can work efficiently
    in a cloud environment, understanding and utilizing cloud behaviors such as elasticity,
    utilization based charging, fail aware, and so on.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Twelve-Factor App, forwarded by Heroku, is a methodology describing the characteristics
    expected from modern cloud-ready applications. Twelve-Factor App is equally applicable
    for microservices as well. Hence, it is important to understand Twelve-Factor
    App.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: A single code base
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code base principle advises that each application has a single code base.
    There can be multiple instances of deployment of the same code base, such as development,
    testing, and production. Code is typically managed in a source control system
    such as Git, Subversion, and so on.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![A single code base](img/B05447_01_35.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: Extending the same philosophy for microservices, each microservice should have
    its own code base, and this code base is not shared with any other microservice.
    It also means that one microservice has exactly one code base.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Bundling dependencies
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As per this principle, all applications should bundle their dependencies along
    with the application bundle. With build tools such as Maven and Gradle, we explicitly
    manage dependencies in a `pom.xml` or the `.gradle` file and link them using a
    central build artifact repository such as Nexus or Archiva. This ensures that
    the versions are managed correctly. The final executables will be packaged as
    a WAR file or an executable JAR file, embedding all the dependencies.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![Bundling dependencies](img/B05447_01_36.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: In the context of microservices, this is one of the fundamental principles to
    be followed. Each microservice should bundle all the required dependencies and
    execution libraries such as the HTTP listener and so on in the final executable
    bundle.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing configurations
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle advises the externalization of all configuration parameters from
    the code. An application's configuration parameters vary between environments,
    such as support to the e-mail IDs or URL of an external system, username, passwords,
    queue name, and so on. These will be different for development, testing, and production.
    All service configurations should be externalized.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![Externalizing configurations](img/B05447_01_37.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: The same principle is obvious for microservices as well. The microservices configuration
    parameters should be loaded from an external source. This will also help to automate
    the release and deployment process as the only difference between these environments
    is the configuration parameters.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Backing services are addressable
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All backing services should be accessible through an addressable URL. All services
    need to talk to some external resources during the life cycle of their execution.
    For example, they could be listening or sending messages to a messaging system,
    sending an e-mail, persisting data to database, and so on. All these services
    should be reachable through a URL without complex communication requirements.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![Backing services are addressable](img/B05447_01_38.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: In the microservices world, microservices either talk to a messaging system
    to send or receive messages, or they could accept or send messages to other service
    APIs. In a regular case, these are either HTTP endpoints using REST and JSON or
    TCP- or HTTP-based messaging endpoints.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Isolation between build, release, and run
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle advocates a strong isolation between the build, release, and
    run stages. The build stage refers to compiling and producing binaries by including
    all the assets required. The release stage refers to combining binaries with environment-specific
    configuration parameters. The run stage refers to running application on a specific
    execution environment. The pipeline is unidirectional, so it is not possible to
    propagate changes from the run stages back to the build stage. Essentially, it
    also means that it is not recommended to do specific builds for production; rather,
    it has to go through the pipeline.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![Isolation between build, release, and run](img/B05447_01_39.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: In microservices, the build will create executable JAR files, including the
    service runtime such as an HTTP listener. During the release phase, these executables
    will be combined with release configurations such as production URLs and so on
    and create a release version, most probably as a container similar to Docker.
    In the run stage, these containers will be deployed on production via a container
    scheduler.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Stateless, shared nothing processes
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle suggests that processes should be stateless and share nothing.
    If the application is stateless, then it is fault tolerant and can be scaled out
    easily.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: All microservices should be designed as stateless functions. If there is any
    requirement to store a state, it should be done with a backing database or in
    an in-memory cache.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Exposing services through port bindings
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Twelve-Factor application is expected to be self-contained. Traditionally,
    applications are deployed to a server: a web server or an application server such
    as Apache Tomcat or JBoss. A Twelve-Factor application does not rely on an external
    web server. HTTP listeners such as Tomcat or Jetty have to be embedded in the
    service itself.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Port binding is one of the fundamental requirements for microservices to be
    autonomous and self-contained. Microservices embed service listeners as a part
    of the service itself.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency to scale out
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle states that processes should be designed to scale out by replicating
    the processes. This is in addition to the use of threads within the process.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: In the microservices world, services are designed to scale out rather than scale
    up. The *x* axis scaling technique is primarily used for a scaling service by
    spinning up another identical service instance. The services can be elastically
    scaled or shrunk based on the traffic flow. Further to this, microservices may
    make use of parallel processing and concurrency frameworks to further speed up
    or scale up the transaction processing.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Disposability with minimal overhead
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle advocates building applications with minimal startup and shutdown
    times with graceful shutdown support. In an automated deployment environment,
    we should be able bring up or bring down instances as quick as possible. If the
    application's startup or shutdown takes considerable time, it will have an adverse
    effect on automation. The startup time is proportionally related to the size of
    the application. In a cloud environment targeting auto-scaling, we should be able
    to spin up new instance quickly. This is also applicable when promoting new versions
    of services.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: In the microservices context, in order to achieve full automation, it is extremely
    important to keep the size of the application as thin as possible, with minimal
    startup and shutdown time. Microservices also should consider a lazy loading of
    objects and data.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Development and production parity
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle states the importance of keeping development and production environments
    as identical as possible. For example, let's consider an application with multiple
    services or processes, such as a job scheduler service, cache services, and one
    or more application services. In a development environment, we tend to run all
    of them on a single machine, whereas in production, we will facilitate independent
    machines to run each of these processes. This is primarily to manage the cost
    of infrastructure. The downside is that if production fails, there is no identical
    environment to re-produce and fix the issues.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Not only is this principle valid for microservices, but it is also applicable
    to any application development.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing logs
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Twelve-Factor application never attempts to store or ship log files. In a
    cloud, it is better to avoid local I/Os. If the I/Os are not fast enough in a
    given infrastructure, it could create a bottleneck. The solution to this is to
    use a centralized logging framework. Splunk, Greylog, Logstash, Logplex, and Loggly
    are some examples of log shipping and analysis tools. The recommended approach
    is to ship logs to a central repository by tapping the logback appenders and write
    to one of the shippers' endpoints.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: In a microservices ecosystem, this is very important as we are breaking a system
    into a number of smaller services, which could result in decentralized logging.
    If they store logs in a local storage, it would be extremely difficult to correlate
    logs between services.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![Externalizing logs](img/B05447_01_40.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: In development, the microservice may direct the log stream to `stdout`, whereas
    in production, these streams will be captured by the log shippers and sent to
    a central log service for storage and analysis.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Package admin processes
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from application services, most applications provide admin tasks as well.
    This principle advises to use the same release bundle as well as an identical
    environment for both application services and admin tasks. Admin code should also
    be packaged along with the application code.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Not only is this principle valid for microservices, but also it is applicable
    to any application development.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Microservice use cases
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservice is not a silver bullet and will not solve all the architectural
    challenges of today's world. There is no hard-and-fast rule or rigid guideline
    on when to use microservices.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Microservices may not fit in each and every use case. The success of microservices
    largely depends on the selection of use cases. The first and the foremost activity
    is to do a litmus test of the use case against the microservices' benefits. The
    litmus test must cover all the microservices' benefits we discussed earlier in
    this chapter. For a given use case, if there are no quantifiable benefits or the
    cost outweighs the benefits, then the use case may not be the right choice for
    microservices.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss some commonly used scenarios that are suitable candidates for
    a microservices architecture:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Migrating a monolithic application due to improvements required in scalability,
    manageability, agility, or speed of delivery. Another similar scenario is rewriting
    an end-of-life heavily used legacy application. In both cases, microservices present
    an opportunity. Using a microservices architecture, it is possible to replatform
    a legacy application by slowly transforming functions to microservices. There
    are benefits in this approach. There is no humongous upfront investment required,
    no major disruption to business, and no severe business risks. As the service
    dependencies are known, the microservices dependencies can be well managed.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utility computing scenarios such as integrating an optimization service, forecasting
    service, price calculation service, prediction service, offer service, recommendation
    service, and so on are good candidates for microservices. These are independent
    stateless computing units that accept certain data, apply algorithms, and return
    the results. Independent technical services such as the communication service,
    the encryption service, authentication services, and so on are also good candidates
    for microservices.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如集成优化服务、预测服务、价格计算服务、预测服务、报价服务、推荐服务等的实用计算场景都是微服务的良好候选者。这些是独立的无状态计算单元，接受特定数据，应用算法，并返回结果。独立的技术服务，如通信服务、加密服务、认证服务等也是微服务的良好候选者。
- en: In many cases, we can build headless business applications or services that
    are autonomous in nature—for instance, the payment service, login service, flight
    search service, customer profile service, notification service, and so on. These
    are normally reused across multiple channels and, hence, are good candidates for
    building them as microservices.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可以构建无头业务应用程序或具有自主性质的服务，例如支付服务、登录服务、航班搜索服务、客户档案服务、通知服务等等。这些通常在多个渠道中被重复使用，因此很适合构建为微服务。
- en: There could be micro or macro applications that serve a single purpose and performing
    a single responsibility. A simple time tracking application is an example of this
    category. All it does is capture the time, duration, and task performed. Common-use
    enterprise applications are also candidates for microservices.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在微型或宏型应用程序，用于单一目的并执行单一职责。一个简单的时间跟踪应用程序就是这一类的例子。它所做的就是捕获时间、持续时间和执行的任务。常用的企业应用程序也是微服务的候选者。
- en: Backend services of a well-architected, responsive client-side MVC web application
    (the **Backend as a Service** (**BaaS**) scenario) load data on demand in response
    to the user navigation. In most of these scenarios, data could be coming from
    multiple logically different data sources as described in the *Fly By Points*
    example mentioned earlier.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好架构、响应式客户端 MVC web 应用程序的后端服务（**后端即服务**（**BaaS**）场景）根据用户导航需求加载数据。在大多数情况下，数据可能来自于多个逻辑上不同的数据源，就像之前提到的
    *飞越点* 示例一样。
- en: Highly agile applications, applications demanding speed of delivery or time
    to market, innovation pilots, applications selected for DevOps, applications of
    the System of Innovation type, and so on could also be considered as potential
    candidates for the microservices architecture.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度敏捷的应用程序、需要快速交付或上市时间、创新试点、选择进行 DevOps 的应用程序、创新型系统的应用程序等等也可以被视为微服务架构的潜在候选者。
- en: Applications that we could anticipate getting benefits from microservices such
    as polyglot requirements, applications that require **Command Query Responsibility
    segregations** (**CQRS**), and so on are also potential candidates of the microservices
    architecture.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以预期从微服务中获益的应用程序，例如多语言要求、需要 **命令查询职责分离**（**CQRS**）等等，也是微服务架构的潜在候选者。
- en: If the use case falls into any of these categories, it is a potential candidate
    for the microservices architecture.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用案例属于这些类别之一，它就是微服务架构的潜在候选者。
- en: 'There are few scenarios in which we should consider avoiding microservices:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，我们应该考虑避免使用微服务：
- en: If the organization's policies are forced to use centrally managed heavyweight
    components such as ESB to host a business logic or if the organization has any
    other policies that hinder the fundamental principles of microservices, then microservices
    are not the right solution unless the organizational process is relaxed.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果组织的政策被迫使用集中管理的重量级组件，例如 ESB 来托管业务逻辑，或者如果组织有任何其他阻碍微服务基本原则的政策，那么微服务就不是正确的解决方案，除非组织流程得到放松。
- en: If the organization's culture, processes, and so on are based on the traditional
    waterfall delivery model, lengthy release cycles, matrix teams, manual deployments
    and cumbersome release processes, no infrastructure provisioning, and so on, then
    microservices may not be the right fit. This is underpinned by Conway's Law. This
    states that there is a strong link between the organizational structure and software
    it creates.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果组织的文化、流程等等是基于传统的瀑布交付模型、漫长的发布周期、矩阵团队、手动部署和繁琐的发布流程、没有基础设施供应等等，那么微服务可能不适合。这是康威定律的基础。这一定律指出组织结构与其创建的软件之间存在着强烈的联系。
- en: Tip
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Read more about the Conway''s Law at:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读更多关于康威定律的信息：
- en: '[http://www.melconway.com/Home/Conways_Law.html](http://www.melconway.com/Home/Conways_Law.html)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.melconway.com/Home/Conways_Law.html](http://www.melconway.com/Home/Conways_Law.html)'
- en: Microservices early adopters
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务的早期采用者
- en: 'Many organizations have already successfully embarked on their journey to the
    microservices world. In this section, we will examine some of the frontrunners
    on the microservices space to analyze why they did what they did and how they
    did it. We will conduct some analysis at the end to draw some conclusions:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织已经成功地踏上了微服务世界的旅程。在本节中，我们将研究一些微服务领域的先驱者，分析他们为什么这样做以及他们是如何做到的。最后我们将进行一些分析以得出一些结论：
- en: '**Netflix** ([www.netflix.com](http://www.netflix.com)): Netflix, an international
    on-demand media streaming company, is a pioneer in the microservices space. Netflix
    transformed their large pool of developers developing traditional monolithic code
    to smaller development teams producing microservices. These microservices work
    together to stream digital media to millions of Netflix customers. At Netflix,
    engineers started with monolithic, went through the pain, and then broke the application
    into smaller units that are loosely coupled and aligned to the business capability.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uber** ([www.uber.com](http://www.uber.com)): Uber, an international transportation
    network company, began in 2008 with a monolithic architecture with a single code
    base. All services were embedded into the monolithic application. When Uber expanded
    their business from one city to multiple cities, the challenges started. Uber
    then moved to SOA-based architecture by breaking the system into smaller independent
    units. Each module was given to different teams and empowered them to choose their
    language, framework, and database. Uber has many microservices deployed in their
    ecosystem using RPC and REST.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Airbnb** ([www.airbnb.com](http://www.airbnb.com)): Airbnb, a world leader
    providing a trusted marketplace for accommodation, started with a monolithic application
    that performed all the required functions of the business. Airbnb faced scalability
    issues with increased traffic. A single code base became too complicated to manage,
    resulted in a poor separation of concerns, and ran into performance issues. Airbnb
    broke their monolithic application into smaller pieces with separate code bases
    running on separate machines with separate deployment cycles. Airbnb developed
    their own microservices or SOA ecosystem around these services.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orbitz** ([www.orbitz.com](http://www.orbitz.com)): Orbitz, an online travel
    portal, started with a monolithic architecture in the 2000s with a web layer,
    a business layer, and a database layer. As Orbitz expanded their business, they
    faced manageability and scalability issues with monolithic-tiered architecture.
    Orbitz then went through continuous architecture changes. Later, Orbitz broke
    down their monolithic to many smaller applications.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eBay** ([www.ebay.com](http://www.ebay.com)): eBay, one of the largest online
    retailers, started in the late 1990s with a monolithic Perl application and FreeBSD
    as the database. eBay went through scaling issues as the business grew. It was
    consistently investing in improving its architecture. In the mid 2000s, eBay moved
    to smaller decomposed systems based on Java and web services. They employed database
    partitions and functional segregation to meet the required scalability.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon** ([www.amazon.com](http://www.amazon.com)): Amazon, one of the largest
    online retailer websites, was run on a big monolithic application written on C++
    in 2001\. The well-architected monolithic application was based on a tiered architecture
    with many modular components. However, all these components were tightly coupled.
    As a result, Amazon was not able to speed up their development cycle by splitting
    teams into smaller groups. Amazon then separated out the code as independent functional
    services, wrapped with web services, and eventually advanced to microservices.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gilt** ([www.gilt.com](http://www.gilt.com)): Gilt, an online shopping website,
    began in 2007 with a tiered monolithic Rails application and a Postgres database
    at the back. Similarly to many other applications, as traffic volumes increased,
    the web application was not able to provide the required resiliency. Gilt went
    through an architecture overhaul by introducing Java and polyglot persistence.
    Later, Gilt moved to many smaller applications using the microservices concept.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Twitter** ([www.twitter.com](http://www.twitter.com)): Twitter, one of the
    largest social websites, began with a three-tiered monolithic rails application
    in the mid 2000s. Later, when Twitter experienced growth in its user base, they
    went through an architecture-refactoring cycle. With this refactoring, Twitter
    moved away from a typical web application to an API-based even driven core. Twitter
    uses Scala and Java to develop microservices with polyglot persistence.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nike** ([www.nike.com](http://www.nike.com)): Nike, the world leader in apparel
    and footwear, transformed their monolithic applications to microservices. Similarly
    to many other organizations, Nike too was run with age-old legacy applications
    that were hardly stable. In their journey, Nike moved to heavyweight commercial
    products with an objective to stabilize legacy applications but ended up in monolithic
    applications that were expensive to scale, had long release cycles, and needed
    too much manual work to deploy and manage applications. Later, Nike moved to a
    microservices-based architecture that brought down the development cycle considerably.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The common theme is monolithic migrations
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we analyze the preceding enterprises, there is one common theme. All these
    enterprises started with monolithic applications and transitioned to a microservices
    architecture by applying learning and pain points from their previous editions.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Even today, many start-ups begin with monolith as it is easy to start, conceptualize,
    and then slowly move to microservices when the demand arises. Monolithic to microservices
    migration scenarios have an added advantage: they have all the information upfront,
    readily available for refactoring.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Though, for all these enterprises, it is monolithic transformation, the catalysts
    were different for different organizations. Some of the common motivations are
    a lack of scalability, long development cycles, process automation, manageability,
    and changes in the business models.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: While monolithic migrations are no-brainers, there are opportunities to build
    microservices from the ground up. More than building ground-up systems, look for
    opportunities to build smaller services that are quick wins for business—for example,
    adding a trucking service to an airline's end-to-end cargo management system or
    adding a customer scoring service to a retailer's loyalty system. These could
    be implemented as independent microservices exchanging messages with their respective
    monolithic applications.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Another point is that many organizations use microservices only for their business-critical
    customer engagement applications, leaving the rest of the legacy monolithic applications
    to take their own trajectory.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Another important observation is that most of the organizations examined previously
    are at different levels of maturity in their microservices journey. When eBay
    transitioned from a monolithic application in the early 2000s, they functionally
    split the application into smaller, independent, and deployable units. These logically
    divided units are wrapped with web services. While single responsibility and autonomy
    are their underpinning principles, the architectures are limited to the technologies
    and tools available at that point in time. Organizations such as Netflix and Airbnb
    built capabilities of their own to solve the specific challenges they faced. To
    summarize, all of these are not truly microservices, but are small, business-aligned
    services following the same characteristics.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: There is no state called "definite or ultimate microservices". It is a journey
    and is evolving and maturing day by day. The mantra for architects and developers
    is the replaceability principle; build an architecture that maximizes the ability
    to replace its parts and minimizes the cost of replacing its parts. The bottom
    line is that enterprises shouldn't attempt to develop microservices by just following
    the hype.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the fundamentals of microservices with the
    help of a few examples.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: We explored the evolution of microservices from traditional monolithic applications.
    We examined some of the principles and the mind shift required for modern application
    architectures. We also took a look at the characteristics and benefits of microservices
    and use cases. In this chapter, we established the microservices' relationship
    with service-oriented architecture and Twelve-Factor Apps. Lastly, we analyzed
    examples of a few enterprises from different industries.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: We will develop a few sample microservices in the next chapter to bring more
    clarity to our learnings in this chapter.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 3. Applying Microservices Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。应用微服务概念
- en: Microservices are good, but can also be an evil if they are not properly conceived.
    Wrong microservice interpretations could lead to irrecoverable failures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是好的，但如果没有得到妥善构思，也可能是一种恶。错误的微服务解释可能导致无法挽回的失败。
- en: This chapter will examine the technical challenges around practical implementations
    of microservices. It will also provide guidelines around critical design decisions
    for successful microservices development. The solutions and patterns for a number
    of commonly raised concerns around microservices will also be examined. This chapter
    will also review the challenges in enterprise scale microservices development,
    and how to overcome those challenges. More importantly, a capability model for
    a microservices ecosystem will be established at the end.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨实际实施微服务的技术挑战。它还将提供成功微服务开发的关键设计决策指南。还将审查关于微服务的一些常见关注点的解决方案和模式。本章还将审查企业规模微服务开发中的挑战，以及如何克服这些挑战。更重要的是，将在最后建立一个微服务生态系统的能力模型。
- en: 'In this chapter you will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解以下内容：
- en: Trade-offs between different design choices and patterns to be considered when
    developing microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发微服务时需要考虑不同设计选择和模式之间的权衡
- en: Challenges and anti-patterns in developing enterprise grade microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发企业级微服务的挑战和反模式
- en: A capability model for a microservices ecosystem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务生态系统的能力模型
- en: Patterns and common design decisions
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和常见设计决策
- en: Microservices have gained enormous popularity in recent years. They have evolved
    as the preferred choice of architects, putting SOA into the backyards. While acknowledging
    the fact that microservices are a vehicle for developing scalable cloud native
    systems, successful microservices need to be carefully designed to avoid catastrophes.
    Microservices are not the one-size-fits-all, universal solution for all architecture
    problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，微服务已经获得了巨大的流行。它们已经成为架构师的首选，将SOA放在了后台。尽管承认微服务是开发可扩展的云原生系统的工具，但成功的微服务需要精心设计以避免灾难。微服务并非一刀切，也不是解决所有架构问题的通用解决方案。
- en: Generally speaking, microservices are a great choice for building a lightweight,
    modular, scalable, and distributed system of systems. Over-engineering, wrong
    use cases, and misinterpretations could easily turn the system into a disaster.
    While selecting the right use cases is paramount in developing a successful microservice,
    it is equally important to take the right design decisions by carrying out an
    appropriate trade-off analysis. A number of factors are to be considered when
    designing microservices, as detailed in the following sections.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，微服务是构建轻量级、模块化、可扩展和分布式系统的绝佳选择。过度设计、错误的用例和误解很容易将系统变成灾难。在选择正确的用例对于开发成功的微服务至关重要，同样重要的是通过进行适当的权衡分析做出正确的设计决策。在设计微服务时需要考虑许多因素，如下面的详细部分所述。
- en: Establishing appropriate microservice boundaries
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立适当的微服务边界
- en: One of the most common questions relating to microservices is regarding the
    size of the service. How big (mini-monolithic) or how small (nano service) can
    a microservice be, or is there anything like right-sized services? Does size really
    matter?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关于微服务最常见的问题之一是关于服务的大小。微服务可以有多大（迷你单片）或多小（纳米服务），或者是否有合适大小的服务？大小真的很重要吗？
- en: A quick answer could be "one REST endpoint per microservice", or "less than
    300 lines of code", or "a component that performs a single responsibility". But
    before we pick up any of these answers, there is lot more analysis to be done
    to understand the boundaries for our services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的答案可能是“每个微服务一个REST端点”，或者“少于300行代码”，或者“执行单一职责的组件”。但在我们选择这些答案之前，还有很多分析工作要做，以了解我们服务的边界。
- en: '**Domain-driven design** (**DDD**) defines the concept of a **bounded context**.
    A bounded context is a subdomain or a subsystem of a larger domain or system that
    is responsible for performing a particular function.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（**DDD**）定义了**有界上下文**的概念。有界上下文是一个较大的领域或系统的子域或子系统，负责执行特定的功能。'
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Read more about DDD at [http://domainlanguage.com/ddd/](http://domainlanguage.com/ddd/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://domainlanguage.com/ddd/](http://domainlanguage.com/ddd/)了解更多关于DDD的信息。
- en: 'The following diagram is an example of the domain model:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是领域模型的一个示例：
- en: '![Establishing appropriate microservice boundaries](img/B05447_03_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![建立适当的微服务边界](img/B05447_03_01.jpg)'
- en: In a finance back office, system invoices, accounting, billing, and the like
    represent different bounded contexts. These bounded contexts are strongly isolated
    domains that are closely aligned with business capabilities. In the financial
    domain, the invoices, accounting, and billing are different business capabilities
    often handled by different subunits under the finance department.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在金融后勤系统中，系统发票、会计、结算等代表不同的有界上下文。这些有界上下文是与业务能力密切相关的强烈隔离的领域。在金融领域，发票、会计和结算是不同的业务能力，通常由财务部门下的不同子单位处理。
- en: A bounded context is a good way to determine the boundaries of microservices.
    Each bounded context could be mapped to a single microservice. In the real world,
    communication between bounded contexts are typically less coupled, and often,
    disconnected.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有界上下文是确定微服务边界的好方法。每个有界上下文可以映射到一个单独的微服务。在现实世界中，有界上下文之间的通信通常耦合较少，而且经常是断开的。
- en: Even though real world organizational boundaries are the simplest mechanisms
    for establishing a bounded context, these may prove wrong in some cases due to
    inherent problems within the organization's structures. For example, a business
    capability may be delivered through different channels such as front offices,
    online, roaming agents, and so on. In many organizations, the business units may
    be organized based on delivery channels rather than the actual underlying business
    capabilities. In such cases, organization boundaries may not provide accurate
    service boundaries.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管真实世界的组织边界是建立有界上下文的最简单机制，但由于组织结构内在问题，这些边界在某些情况下可能会被证明是错误的。例如，业务能力可以通过不同的渠道进行交付，如前台办事处、在线、漫游代理等。在许多组织中，业务单位可能是根据交付渠道而不是实际的基础业务能力进行组织的。在这种情况下，组织边界可能无法提供准确的服务边界。
- en: A top-down domain decomposition could be another way to establish the right
    bounded contexts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自上而下的领域分解可能是建立正确有界上下文的另一种方式。
- en: There is no silver bullet to establish microservices boundaries, and often,
    this is quite challenging. Establishing boundaries is much easier in the scenario
    of monolithic application to microservices migration, as the service boundaries
    and dependencies are known from the existing system. On the other hand, in a green
    field microservices development, the dependencies are hard to establish upfront.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 建立微服务边界没有银弹，通常这是非常具有挑战性的。在将单块应用程序迁移到微服务的情况下，建立边界要容易得多，因为现有系统的服务边界和依赖关系是已知的。另一方面，在绿地微服务开发中，依赖关系很难事先建立。
- en: The most pragmatic way to design microservices boundaries is to run the scenario
    at hand through a number of possible options, just like a service litmus test.
    Keep in mind that there may be multiple conditions matching a given scenario that
    will lead to a trade-off analysis.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 设计微服务边界的最实用方法是将手头的情景运行通过多种可能的选项，就像服务试纸测试一样。请记住，可能有多个条件匹配给定情景，这将导致权衡分析。
- en: The following scenarios could help in defining the microservice boundaries.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下情景可能有助于定义微服务边界。
- en: Autonomous functions
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自主功能
- en: If the function under review is autonomous by nature, then it can be taken as
    a microservices boundary. Autonomous services typically would have fewer dependencies
    on external functions. They accept input, use its internal logic and data for
    computation, and return a result. All utility functions such as an encryption
    engine or a notification engine are straightforward candidates.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在审查的功能本质上是自主的，那么它可以被视为微服务边界。自主服务通常对外部功能的依赖较少。它们接受输入，使用内部逻辑和数据进行计算，并返回结果。所有实用功能，如加密引擎或通知引擎，都是直接的候选者。
- en: A delivery service that accepts an order, processes it, and then informs the
    trucking service is another example of an autonomous service. An online flight
    search based on cached seat availability information is yet another example of
    an autonomous function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接受订单、处理订单，然后通知卡车服务的交付服务是另一个自主服务的例子。基于缓存的座位可用性信息进行在线航班搜索是另一个自主功能的例子。
- en: Size of a deployable unit
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可部署单元的大小
- en: Most of the microservices ecosystems will take advantage of automation, such
    as automatic integration, delivery, deployment, and scaling. Microservices covering
    broader functions result in larger deployment units. Large deployment units pose
    challenges in automatic file copy, file download, deployment, and start up times.
    For instance, the size of a service increases with the density of the functions
    that it implements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数微服务生态系统将利用自动化，如自动集成、交付、部署和扩展。覆盖更广泛功能的微服务会导致更大的部署单元。大型部署单元在自动文件复制、文件下载、部署和启动时间方面存在挑战。例如，服务的大小随着它实现的功能密度的增加而增加。
- en: A good microservice ensures that the size of its deployable units remains manageable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的微服务确保其可部署单元的大小保持可管理。
- en: Most appropriate function or subdomain
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最合适的功能或子域
- en: It is important to analyze what would be the most useful component to detach
    from the monolithic application. This is particularly applicable when breaking
    monolithic applications into microservices. This could be based on parameters
    such as resource-intensiveness, cost of ownership, business benefits, or flexibility.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 分析从单块应用程序中分离出来的最有用的组件是非常重要的。这在将单块应用程序分解为微服务时特别适用。这可能基于资源密集性、所有权成本、业务利益或灵活性等参数。
- en: In a typical hotel booking system, approximately 50-60% of the requests are
    search-based. In this case, moving out the search function could immediately bring
    in flexibility, business benefits, cost reduction, resource free up, and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的酒店预订系统中，大约50-60%的请求是基于搜索的。在这种情况下，移出搜索功能可能会立即带来灵活性、业务利益、成本降低、资源释放等。
- en: Polyglot architecture
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多语言体系结构
- en: One of the key characteristics of microservices is its support for polyglot
    architecture. In order to meet different non-functional and functional requirements,
    components may require different treatments. It could be different architectures,
    different technologies, different deployment topologies, and so on. When components
    are identified, review them against the requirement for polyglot architectures.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的一个关键特征是支持多语言体系结构。为了满足不同的非功能性和功能性要求，组件可能需要不同的处理方式。这可能是不同的体系结构、不同的技术、不同的部署拓扑等。当组件被识别出来时，要根据多语言体系结构的要求对它们进行审查。
- en: In the hotel booking scenario mentioned earlier, a Booking microservice may
    need transactional integrity, whereas a Search microservice may not. In this case,
    the Booking microservice may use an ACID compliance database such as MySQL, whereas
    the Search microservice may use an eventual consistent database such as Cassandra.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面提到的酒店预订场景中，预订微服务可能需要事务完整性，而搜索微服务可能不需要。在这种情况下，预订微服务可能会使用ACID兼容的数据库，如MySQL，而搜索微服务可能会使用最终一致的数据库，如Cassandra。
- en: Selective scaling
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择性扩展
- en: Selective scaling is related to the previously discussed polyglot architecture.
    In this context, all functional modules may not require the same level of scalability.
    Sometimes, it may be appropriate to determine boundaries based on scalability
    requirements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 选择性扩展与先前讨论的多语言体系结构相关。在这种情况下，所有功能模块可能不需要相同级别的可扩展性。有时，根据可扩展性要求确定边界可能是合适的。
- en: For example, in the hotel booking scenario, the Search microservice has to scale
    considerably more than many of the other services such as the Booking microservice
    or the Notification microservice due to the higher velocity of search requests.
    In this case, a separate Search microservice could run on top of an Elasticsearch
    or an in-memory data grid for better response.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在酒店预订场景中，搜索微服务必须比许多其他服务（如预订微服务或通知微服务）扩展得多，因为搜索请求的速度更快。在这种情况下，一个独立的搜索微服务可以在Elasticsearch或内存数据网格上运行，以获得更好的响应。
- en: Small, agile teams
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小而敏捷的团队
- en: Microservices enable Agile development with small, focused teams developing
    different parts of the pie. There could be scenarios where parts of the systems
    are built by different organizations, or even across different geographies, or
    by teams with varying skill sets. This approach is a common practice, for example,
    in manufacturing industries.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务使得敏捷开发成为可能，小而专注的团队开发饼图的不同部分。可能存在不同组织或不同地理位置的团队，或者技能水平不同的团队构建系统的部分的情况。例如，在制造业中，这种方法是常见的做法。
- en: In the microservices world, each of these teams builds different microservices,
    and then assembles them together. Though this is not the desired way to break
    down the system, organizations may end up in such situations. Hence, this approach
    cannot be completely ruled out.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务的世界中，这些团队中的每一个都构建不同的微服务，然后将它们组合在一起。尽管这不是分解系统的理想方式，但组织可能最终会陷入这种情况。因此，这种方法不能完全被排除。
- en: In an online product search scenario, a service could provide personalized options
    based on what the customer is looking for. This may require complex machine learning
    algorithms, and hence need a specialist team. In this scenario, this function
    could be built as a microservice by a separate specialist team.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线产品搜索场景中，一个服务可以根据客户的需求提供个性化的选项。这可能需要复杂的机器学习算法，因此需要一个专业团队。在这种情况下，这个功能可以由一个独立的专业团队构建为一个微服务。
- en: Single responsibility
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单一责任
- en: In theory, the single responsibility principle could be applied at a method,
    at a class, or at a service. However, in the context of microservices, it does
    not necessarily map to a single service or endpoint.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，单一责任原则可以应用于方法、类或服务。然而，在微服务的背景下，并不一定对应于单个服务或端点。
- en: A more practical approach could be to translate single responsibility into single
    business capability or a single technical capability. As per the *single responsibility*
    principle, one responsibility cannot be shared by multiple microservices. Similarly,
    one microservice should not perform multiple responsibilities.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 更实际的方法可能是将单一责任转化为单一业务能力或单一技术能力。根据*单一责任*原则，一个责任不能被多个微服务共享。同样，一个微服务不应执行多个责任。
- en: There could, however, be special cases where a single business capability is
    divided across multiple services. One of such cases is managing the customer profile,
    where there could be situations where you may use two different microservices
    for managing reads and writes using a **Command Query Responsibility Segregation**
    (**CQRS**) approach to achieve some of the quality attributes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也可能存在特殊情况，其中单个业务能力分布在多个服务之间。其中一种情况是管理客户档案，可能会出现使用两个不同的微服务来管理读取和写入的情况，使用**命令查询责任分离**（**CQRS**）方法来实现一些质量属性。
- en: Replicability or changeability
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可复制性或可变性
- en: Innovation and speed are of the utmost importance in IT delivery. Microservices
    boundaries should be identified in such a way that each microservice is easily
    detachable from the overall system, with minimal cost of re-writing. If part of
    the system is just an experiment, it should ideally be isolated as a microservice.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创新和速度在IT交付中至关重要。微服务的边界应该被确定为每个微服务都可以轻松地从整个系统中分离出来，重新编写的成本最小。如果系统的一部分只是一个实验，最好将其作为一个微服务隔离起来。
- en: An organization may develop a recommendation engine or a customer ranking engine
    as an experiment. If the business value is not realized, then throw away that
    service, or replace it with another one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组织可能会开发一个推荐引擎或客户排名引擎作为一个实验。如果业务价值没有实现，那么就放弃该服务，或者用另一个替换它。
- en: Many organizations follow the startup model, where importance is given to meeting
    functions and quick delivery. These organizations may not worry too much about
    the architecture and technologies. Instead, the focus will be on what tools or
    technologies can deliver solutions faster. Organizations increasingly choose the
    approach of developing **Minimum Viable Products** (**MVPs**) by putting together
    a few services, and allowing the system to evolve. Microservices play a vital
    role in such cases where the system evolves, and services gradually get rewritten
    or replaced.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织遵循创业公司的模式，重视功能的实现和快速交付。这些组织可能不会过分担心架构和技术，而是关注哪些工具或技术可以更快地提供解决方案。组织越来越倾向于通过组合几个服务来开发**最小可行产品**（**MVPs**），并允许系统不断演进。在系统不断演进、服务逐渐重写或替换的情况下，微服务在这些情况下发挥着至关重要的作用。
- en: Coupling and cohesion
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 耦合和内聚
- en: Coupling and cohesion are two of the most important parameters for deciding
    service boundaries. Dependencies between microservices have to be evaluated carefully
    to avoid highly coupled interfaces. A functional decomposition, together with
    a modeled dependency tree, could help in establishing a microservices boundary.
    Avoiding too chatty services, too many synchronous request-response calls, and
    cyclic synchronous dependencies are three key points, as these could easily break
    the system. A successful equation is to keep high cohesion within a microservice,
    and loose coupling between microservices. In addition to this, ensure that transaction
    boundaries are not stretched across microservices. A first class microservice
    will react upon receiving an event as an input, execute a number of internal functions,
    and finally send out another event. As part of the compute function, it may read
    and write data to its own local store.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合和内聚是决定服务边界的两个最重要的参数。微服务之间的依赖关系必须经过仔细评估，以避免高度耦合的接口。功能分解，以及建模依赖树，可以帮助确定微服务的边界。避免过于啰嗦的服务、过多的同步请求-响应调用以及循环同步依赖是三个关键点，因为这些很容易破坏系统。一个成功的方程是在微服务内保持高内聚性，在微服务之间保持松耦合。除此之外，确保事务边界不要跨微服务。一流的微服务将在接收到事件作为输入时做出反应，执行一些内部功能，最终发送另一个事件。作为计算功能的一部分，它可能会读取和写入数据到自己的本地存储。
- en: Think microservice as a product
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将微服务视为产品
- en: DDD also recommends mapping a bounded context to a product. As per DDD, each
    bounded context is an ideal candidate for a product. Think about a microservice
    as a product by itself. When microservice boundaries are established, assess them
    from a product's point of view to see whether they really stack up as product.
    It is much easier for business users to think boundaries from a product point
    of view. A product boundary may have many parameters, such as a targeted community,
    flexibility in deployment, sell-ability, reusability, and so on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计还建议将一个有界上下文映射到一个产品。根据领域驱动设计，每个有界上下文都是一个理想的产品候选者。将微服务视为一个独立的产品。当微服务边界确定后，从产品的角度评估它们，看它们是否真的符合产品的标准。对于业务用户来说，从产品的角度思考边界会更容易。产品边界可能有许多参数，如针对的社区、部署灵活性、可销售性、可重用性等。
- en: Designing communication styles
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计通信风格
- en: Communication between microservices can be designed either in synchronous (request-response)
    or asynchronous (fire and forget) styles.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务之间的通信可以设计为同步（请求-响应）或异步（发送并忘记）风格。
- en: Synchronous style communication
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步风格通信
- en: 'The following diagram shows an example request/response style service:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了一个示例的请求/响应式服务：
- en: '![Synchronous style communication](img/B05447_03_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![同步风格通信](img/B05447_03_02.jpg)'
- en: In synchronous communication, there is no shared state or object. When a caller
    requests a service, it passes the required information and waits for a response.
    This approach has a number of advantages.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步通信中，没有共享状态或对象。当调用者请求服务时，它传递所需的信息并等待响应。这种方法有许多优点。
- en: An application is stateless, and from a high availability standpoint, many active
    instances can be up and running, accepting traffic. Since there are no other infrastructure
    dependencies such as a shared messaging server, there are management fewer overheads.
    In case of an error at any stage, the error will be propagated back to the caller
    immediately, leaving the system in a consistent state, without compromising data
    integrity.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是无状态的，从高可用性的角度来看，可以有许多活跃的实例运行，接受流量。由于没有其他基础设施依赖，如共享的消息服务器，管理开销更少。在任何阶段出现错误时，错误将立即传播回调用者，使系统保持一致状态，而不会损害数据完整性。
- en: The downside in a synchronous request-response communication is that the user
    or the caller has to wait until the requested process gets completed. As a result,
    the calling thread will wait for a response, and hence, this style could limit
    the scalability of the system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 同步请求-响应通信的缺点是用户或调用者必须等待请求的过程完成。因此，调用线程将等待响应，因此这种方式可能会限制系统的可扩展性。
- en: A synchronous style adds hard dependencies between microservices. If one service
    in the service chain fails, then the entire service chain will fail. In order
    for a service to succeed, all dependent services have to be up and running. Many
    of the failure scenarios have to be handled using timeouts and loops.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同步风格在微服务之间添加了硬依赖关系。如果服务链中的一个服务失败，整个服务链将失败。为了使服务成功，所有依赖的服务都必须正常运行。许多故障场景必须使用超时和循环来处理。
- en: Asynchronous style communication
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步风格通信
- en: 'The following diagram is a service designed to accept an asynchronous message
    as input, and send the response asynchronously for others to consume:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是一个设计用于接受异步消息作为输入，并异步发送响应供其他消费者使用的服务：
- en: '![Asynchronous style communication](img/B05447_03_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![异步风格通信](img/B05447_03_03.jpg)'
- en: The asynchronous style is based on reactive event loop semantics which decouple
    microservices. This approach provides higher levels of scalability, because services
    are independent, and can internally spawn threads to handle an increase in load.
    When overloaded, messages will be queued in a messaging server for later processing.
    That means that if there is a slowdown in one of the services, it will not impact
    the entire chain. This provides higher levels of decoupling between services,
    and therefore maintenance and testing will be simpler.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 异步风格基于反应式事件循环语义，解耦了微服务。这种方法提供了更高级别的可扩展性，因为服务是独立的，可以在内部生成线程来处理负载的增加。当负载过重时，消息将被排队在消息服务器中以供以后处理。这意味着如果其中一个服务减速，它不会影响整个链条。这提供了更高级别的服务之间的解耦，因此维护和测试将更简单。
- en: The downside is that it has a dependency to an external messaging server. It
    is complex to handle the fault tolerance of a messaging server. Messaging typically
    works with an active/passive semantics. Hence, handling continuous availability
    of messaging systems is harder to achieve. Since messaging typically uses persistence,
    a higher level of I/O handling and tuning is required.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是它对外部消息服务器有依赖性。处理消息服务器的容错性是复杂的。消息通常使用主/备份语义。因此，处理消息系统的持续可用性更难实现。由于消息通常使用持久性，需要更高级别的I/O处理和调优。
- en: How to decide which style to choose?
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何决定选择哪种风格？
- en: Both approaches have their own merits and constraints. It is not possible to
    develop a system with just one approach. A combination of both approaches is required
    based on the use cases. In principle, the asynchronous approach is great for building
    true, scalable microservice systems. However, attempting to model everything as
    asynchronous leads to complex system designs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有各自的优点和限制。无法只使用一种方法开发系统。根据用例需要，需要结合两种方法。原则上，异步方法非常适合构建真正可扩展的微服务系统。然而，试图将所有东西都建模为异步会导致复杂的系统设计。
- en: How does the following example look in the context where an end user clicks
    on a UI to get profile details?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端用户点击UI获取配置文件详细信息的情境中，以下示例是什么样子的？
- en: '![How to decide which style to choose?](img/B05447_03_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![如何决定选择哪种风格？](img/B05447_03_04.jpg)'
- en: This is perhaps a simple query to the backend system to get a result in a request-response
    model. This can also be modeled in an asynchronous style by pushing a message
    to an input queue, and waiting for a response in an output queue till a response
    is received for the given correlation ID. However, though we use asynchronous
    messaging, the user is still blocked for the entire duration of the query.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是向后端系统发出简单查询以在请求-响应模型中获取结果。这也可以通过将消息推送到输入队列，并在输出队列中等待响应，直到收到给定关联ID的响应来以异步风格建模。然而，尽管我们使用异步消息传递，用户仍然在整个查询的持续时间内被阻塞。
- en: 'Another use case is that of a user clicking on a UI to search hotels, which
    is depicted in the following diagram:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是用户点击UI搜索酒店，如下图所示：
- en: '![How to decide which style to choose?](img/B05447_03_05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![如何决定选择哪种风格？](img/B05447_03_05.jpg)'
- en: This is very similar to the previous scenario. However, in this case, we assume
    that this business function triggers a number of activities internally before
    returning the list of hotels back to the user. For example, when the system receives
    this request, it calculates the customer ranking, gets offers based on the destination,
    gets recommendations based on customer preferences, optimizes the prices based
    on customer values and revenue factors, and so on. In this case, we have an opportunity
    to do many of these activities in parallel so that we can aggregate all these
    results before presenting them to the customer. As shown in the preceding diagram,
    virtually any computational logic could be plugged in to the search pipeline listening
    to the **IN** queue.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这与先前的情景非常相似。然而，在这种情况下，我们假设这个业务功能在将酒店列表返回给用户之前会触发一系列内部活动。例如，当系统接收到这个请求时，它会计算客户排名，根据目的地获取优惠，根据客户偏好获取推荐，根据客户价值和收入因素优化价格等等。在这种情况下，我们有机会并行地执行许多这些活动，以便在向客户呈现结果之前汇总所有这些结果。如前图所示，几乎任何计算逻辑都可以插入到监听**IN**队列的搜索管道中。
- en: An effective approach in this case is to start with a synchronous request response,
    and refactor later to introduce an asynchronous style when there is value in doing
    that.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个有效的方法是从同步请求响应开始，以后根据需要引入异步风格。
- en: 'The following example shows a fully asynchronous style of service interactions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了完全异步风格的服务交互：
- en: '![How to decide which style to choose?](img/B05447_03_06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![如何决定选择哪种风格？](img/B05447_03_06.jpg)'
- en: The service is triggered when the user clicks on the booking function. It is
    again, by nature, a synchronous style communication. When booking is successful,
    it sends a message to the customer's e-mail address, sends a message to the hotel's
    booking system, updates the cached inventory, updates the loyalty points system,
    prepares an invoice, and perhaps more. Instead of pushing the user into a long
    wait state, a better approach is to break the service into pieces. Let the user
    wait till a booking record is created by the Booking Service. On successful completion,
    a booking event will be published, and return a confirmation message back to the
    user. Subsequently, all other activities will happen in parallel, asynchronously.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击预订功能时，服务被触发。同样，它是一种同步风格的通信。预订成功后，它会向客户的电子邮件地址发送消息，向酒店的预订系统发送消息，更新缓存库存，更新忠诚积分系统，准备发票，或许还有其他操作。与其让用户陷入长时间等待状态，更好的方法是将服务分解成片段。让用户等待，直到预订服务创建了一个预订记录。在成功完成后，将发布一个预订事件，并向用户返回确认消息。随后，所有其他活动将并行异步地发生。
- en: In all three examples, the user has to wait for a response. With the new web
    application frameworks, it is possible to send requests asynchronously, and define
    the callback method, or set an observer for getting a response. Therefore, the
    users won't be fully blocked from executing other activities.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个例子中，用户都需要等待响应。使用新的Web应用程序框架，可以异步发送请求，并定义回调方法，或设置观察者以获取响应。因此，用户不会完全被阻止执行其他活动。
- en: In general, an asynchronous style is always better in the microservices world,
    but identifying the right pattern should be purely based on merits. If there are
    no merits in modeling a transaction in an asynchronous style, then use the synchronous
    style till you find an appealing case. Use reactive programming frameworks to
    avoid complexity when modeling user-driven requests, modeled in an asynchronous
    style.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration of microservices
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Composability is one of the service design principles. This leads to confusion
    around who is responsible for the composing services. In the SOA world, ESBs are
    responsible for composing a set of finely-grained services. In some organizations,
    ESBs play the role of a proxy, and service providers themselves compose and expose
    coarse-grained services. In the SOA world, there are two approaches for handling
    such situations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The first approach is orchestration, which is depicted in the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Orchestration of microservices](img/B05447_03_07.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: In the orchestration approach, multiple services are stitched together to get
    a complete function. A central brain acts as the orchestrator. As shown in the
    diagram, the order service is a composite service that will orchestrate other
    services. There could be sequential as well as parallel branches from the master
    process. Each task will be fulfilled by an atomic task service, typically a web
    service. In the SOA world, ESBs play the role of orchestration. The orchestrated
    service will be exposed by ESBs as a composite service.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach is choreography, which is shown in the following diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Orchestration of microservices](img/B05447_03_08.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: In the choreography approach, there is no central brain. An event, a booking
    event in this case, is published by a producer, a number of consumers wait for
    the event, and independently apply different logics on the incoming event. Sometimes,
    events could even be nested where the consumers can send another event which will
    be consumed by another service. In the SOA world, the caller pushes a message
    to the ESB, and the downstream flow will be automatically determined by the consuming
    services.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are autonomous. This essentially means that in an ideal situation,
    all required components to complete their function should be within the service.
    This includes the database, orchestration of its internal services, intrinsic
    state management, and so on. The service endpoints provide coarse-grained APIs.
    This is perfectly fine as long as there are no external touch points required.
    But in reality, microservices may need to talk to other microservices to fulfil
    their function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, choreography is the preferred approach for connecting multiple
    microservices together. Following the autonomy principle, a component sitting
    outside a microservice and controlling the flow is not the desired option. If
    the use case can be modeled in choreographic style, that would be the best possible
    way to handle the situation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'But it may not be possible to model choreography in all cases. This is depicted
    in the following diagram:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Orchestration of microservices](img/B05447_03_09.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, Reservation and Customer are two microservices, with
    clearly segregated functional responsibilities. A case could arise when Reservation
    would want to get Customer preferences while creating a reservation. These are
    quite normal scenarios when developing complex systems.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Can we move Customer to Reservation so that Reservation will be complete by
    itself? If Customer and Reservation are identified as two microservices based
    on various factors, it may not be a good idea to move Customer to Reservation.
    In such a case, we will meet another monolithic application sooner or later.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we make the Reservation to Customer call asynchronous? This example is
    shown in the following diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Orchestration of microservices](img/B05447_03_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Customer preference is required for Reservation to progress, and hence, it may
    require a synchronous blocking call to Customer. Retrofitting this by modeling
    asynchronously does not really make sense.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 预订需要客户偏好才能进行，因此可能需要对客户进行同步阻塞调用。通过异步建模来进行适配实际上并没有意义。
- en: Can we take out just the orchestration bit, and create another composite microservice,
    which then composes Reservation and Customer?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否只取出编排部分，然后创建另一个复合微服务，然后将预订和客户组合起来？
- en: '![Orchestration of microservices](img/B05447_03_11.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![微服务的编排](img/B05447_03_11.jpg)'
- en: This is acceptable in the approach for composing multiple components within
    a microservice. But creating a composite microservice may not be a good idea.
    We will end up creating many microservices with no business alignment, which would
    not be autonomous, and could result in many fine-grained microservices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这在微服务内部组合多个组件的方法中是可以接受的。但创建一个复合微服务可能不是一个好主意。我们最终会创建许多与业务不对齐的微服务，这些微服务将不是自治的，并且可能会导致许多细粒度的微服务。
- en: Can we duplicate customer preference by keeping a slave copy of the preference
    data into Reservation?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否通过在预订中保留偏好数据的从属副本来复制客户偏好？
- en: '![Orchestration of microservices](img/B05447_03_12.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![微服务的编排](img/B05447_03_12.jpg)'
- en: Changes will be propagated whenever there is a change in the master. In this
    case, Reservation can use customer preference without fanning out a call. It is
    a valid thought, but we need to carefully analyze this. Today we replicate customer
    preference, but in another scenario, we may want to reach out to customer service
    to see whether the customer is black-listed from reserving. We have to be extremely
    careful in deciding what data to duplicate. This could add to the complexity.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 只要主服务器发生变化，变更就会传播。在这种情况下，预订可以使用客户偏好而无需进行调用。这是一个有效的想法，但我们需要仔细分析这一点。今天我们复制客户偏好，但在另一种情况下，我们可能希望联系客户服务，看看客户是否被列入了预订的黑名单。在决定复制哪些数据时，我们必须非常小心。这可能会增加复杂性。
- en: How many endpoints in a microservice?
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务中有多少个端点？
- en: 'In many situations, developers are confused with the number of endpoints per
    microservice. The question really is whether to limit each microservice with one
    endpoint or multiple endpoints:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，开发人员对每个微服务的端点数量感到困惑。问题实际上是是否限制每个微服务只有一个端点还是多个端点：
- en: '![How many endpoints in a microservice?](img/B05447_03_13.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![微服务中有多少个端点？](img/B05447_03_13.jpg)'
- en: 'The number of endpoints is not really a decision point. In some cases, there
    may be only one endpoint, whereas in some other cases, there could be more than
    one endpoint in a microservice. For instance, consider a sensor data service which
    collects sensor information, and has two logical endpoints: create and read. But
    in order to handle CQRS, we may create two separate physical microservices as
    shown in the case of **Booking** in the preceding diagram. Polyglot architecture
    could be another scenario where we may split endpoints into different microservices.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 端点的数量并不是一个决定性因素。在某些情况下，可能只有一个端点，而在其他一些情况下，一个微服务可能有多个端点。例如，考虑一个传感器数据服务，它收集传感器信息，并具有两个逻辑端点：创建和读取。但为了处理CQRS，我们可能会创建两个单独的物理微服务，就像前面图表中的**预订**一样。多语言架构可能是另一种情况，我们可能会将端点拆分成不同的微服务。
- en: Considering a notification engine, notifications will be send out in response
    to an event. The process of notification such as preparation of data, identification
    of a person, and delivery mechanisms, are different for different events. Moreover,
    we may want to scale each of these processes differently at different time windows.
    In such situations, we may decide to break each notification endpoint in to a
    separate microservice.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到通知引擎，通知将会在事件发生时发送出去。通知的过程，比如数据准备、人员识别和传递机制，对于不同的事件是不同的。此外，我们可能希望在不同的时间窗口内以不同的方式扩展这些过程。在这种情况下，我们可能决定将每个通知端点拆分成一个单独的微服务。
- en: In yet another example, a Loyalty Points microservice may have multiple services
    such as accrue, redeem, transfer, and balance. We may not want to treat each of
    these services differently. All of these services are connected and use the points
    table for data. If we go with one endpoint per service, we will end up in a situation
    where many fine-grained services access data from the same data store or replicated
    copies of the same data store.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个例子中，积分微服务可能有多个服务，比如积分、兑换、转移和余额。我们可能不希望对这些服务进行不同对待。所有这些服务都是相互连接的，并且使用积分表进行数据操作。如果我们为每个服务创建一个端点，我们最终会陷入这样一种情况：许多细粒度的服务从同一个数据存储或复制的相同数据存储中访问数据。
- en: In short, the number of endpoints is not a design decision. One microservice
    may host one or more endpoints. Designing appropriate bounded context for a microservice
    is more important.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，端点的数量不是一个设计决策。一个微服务可以承载一个或多个端点。为微服务设计适当的边界上下文更为重要。
- en: One microservice per VM or multiple?
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个虚拟机一个微服务，还是多个？
- en: One microservice could be deployed in multiple **Virtual Machines** (**VMs**)
    by replicating the deployment for scalability and availability. This is a no brainer.
    The question is whether multiple microservices could be deployed in one virtual
    machine? There are pros and cons for this approach. This question typically arises
    when the services are simple, and the traffic volume is less.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微服务可以通过复制部署来实现可扩展性和可用性，部署在多个**虚拟机**（**VMs**）中。这是一个不需要大脑的决定。问题是是否可以在一个虚拟机中部署多个微服务？这种方法有其利弊。这个问题通常在服务简单且流量较少时出现。
- en: Consider an example where we have a couple of microservices, and the overall
    transaction per minute is less than 10\. Also assume that the smallest possible
    VM size available is 2-core 8 GB RAM. A further assumption is that in such cases,
    a 2-core 8 GB VM can handle 10-15 transactions per minute without any performance
    concerns. If we use different VMs for each microservice, it may not be cost effective,
    and we will end up paying more for infrastructure and license, since many vendors
    charge based on the number of cores.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，我们有一对微服务，总交易量少于10笔每分钟。还假设可用的最小虚拟机大小是2核8GB内存。进一步假设在这种情况下，一个2核8GB的虚拟机可以处理10-15笔每分钟的交易而不会出现性能问题。如果我们为每个微服务使用不同的虚拟机，可能不是成本有效的，因为许多供应商根据核心数收费。
- en: 'The simplest way to approach this problem is to ask a few questions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法是提出几个问题：
- en: Does the VM have enough capacity to run both services under peak usage?
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机是否有足够的容量来在高峰使用时运行这两个服务？
- en: Do we want to treat these services differently to achieve SLAs (selective scaling)?
    For example, for scalability, if we have an all-in-one VM, we will have to replicate
    VMs which replicate all services.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否想要以不同的方式处理这些服务以实现SLA（选择性扩展）？例如，对于可伸缩性，如果我们有一个全包式虚拟机，我们将不得不复制复制所有服务的虚拟机。
- en: Are there any conflicting resource requirements? For example, different OS versions,
    JDK versions, and others.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否存在冲突的资源需求？例如，不同的操作系统版本，JDK版本等。
- en: If all your answers are *No*, then perhaps we can start with collocated deployment,
    until we encounter a scenario to change the deployment topology. However, we will
    have to ensure that these services are not sharing anything, and are running as
    independent OS processes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您所有的答案都是*否*，那么也许我们可以从共部署开始，直到遇到改变部署拓扑的情况。然而，我们必须确保这些服务不共享任何东西，并且作为独立的操作系统进程运行。
- en: Having said that, in an organization with matured virtualized infrastructure
    or cloud infrastructure, this may not be a huge concern. In such environments,
    the developers need not worry about where the services are running. Developers
    may not even think about capacity planning. Services will be deployed in a compute
    cloud. Based on the infrastructure availability, SLAs and the nature of the service,
    the infrastructure self-manages deployments. AWS Lambda is a good example of such
    a service.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在一个拥有成熟的虚拟化基础设施或云基础设施的组织中，这可能并不是一个巨大的问题。在这样的环境中，开发人员不需要担心服务运行的位置。开发人员甚至可能不考虑容量规划。服务将部署在计算云中。根据基础设施的可用性、SLA和服务的性质，基础设施自我管理部署。AWS
    Lambda就是这样一个服务的很好的例子。
- en: Rules engine – shared or embedded?
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规则引擎-共享还是嵌入？
- en: Rules are an essential part of any system. For example, an offer eligibility
    service may execute a number of rules before making a yes or no decision. Either
    we hand code rules, or we may use a rules engine. Many enterprises manage rules
    centrally in a rules repository as well as execute them centrally. These enterprise
    rule engines are primarily used for providing the business an opportunity to author
    and manage rules as well as reuse rules from the central repository. **Drools**
    is one of the popular open source rules engines. IBM, FICO, and Bosch are some
    of the pioneers in the commercial space. These rule engines improve productivity,
    enable reuse of rules, facts, vocabularies, and provide faster rule execution
    using the rete algorithm.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是任何系统的重要组成部分。例如，一个资格服务可能在做出是或否决定之前执行多个规则。我们要么手工编写规则，要么使用规则引擎。许多企业在规则存储库中集中管理规则，并在中央执行它们。这些企业规则引擎主要用于为业务提供编写和管理规则以及从中央存储库重用规则的机会。**Drools**是一种流行的开源规则引擎。IBM、FICO和Bosch是商业领域的一些先驱。这些规则引擎提高了生产率，实现了规则、事实、词汇的重用，并使用rete算法提供更快的规则执行。
- en: 'In the context of microservices, a central rules engine means fanning out calls
    from microservices to the central rules engine. This also means that the service
    logic is now in two places, some within the service, and some external to the
    service. Nevertheless, the objective in the context of microservices is to reduce
    external dependencies:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务的背景下，中央规则引擎意味着从微服务向中央规则引擎扩展调用。这也意味着服务逻辑现在在两个地方，一部分在服务内部，一部分在服务外部。然而，在微服务的背景下，目标是减少外部依赖：
- en: '![Rules engine – shared or embedded?](img/B05447_03_14.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![规则引擎-共享还是嵌入？](img/B05447_03_14.jpg)'
- en: 'If the rules are simple enough, few in numbers, only used within the boundaries
    of a service, and not exposed to business users for authoring, then it may be
    better to hand-code business rules than rely on an enterprise rule engine:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果规则足够简单，数量不多，仅在服务范围内使用，并且不向业务用户公开进行编写，那么手工编码业务规则可能比依赖企业规则引擎更好：
- en: '![Rules engine – shared or embedded?](img/B05447_03_15.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![规则引擎-共享还是嵌入？](img/B05447_03_15.jpg)'
- en: 'If the rules are complex, limited to a service context, and not given to business
    users, then it is better to use an embedded rules engine within the service:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果规则很复杂，限于服务上下文，并且不提供给业务用户，那么最好在服务内使用嵌入式规则引擎：
- en: '![Rules engine – shared or embedded?](img/B05447_03_16.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![规则引擎-共享还是嵌入？](img/B05447_03_16.jpg)'
- en: If the rules are managed and authored by business, or if the rules are complex,
    or if we are reusing rules from other service domains, then a central authoring
    repository with a locally embedded execution engine could be a better choice.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果规则由业务管理和编写，或者规则很复杂，或者我们正在从其他服务领域重用规则，那么具有本地嵌入执行引擎的中央编写存储库可能是更好的选择。
- en: Note that this has to be carefully evaluated since all vendors may not support
    the local rule execution approach, and there could be technology dependencies
    such as running rules only within a specific application server, and so on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这必须经过仔细评估，因为并非所有供应商都支持本地规则执行方法，可能存在技术依赖，比如只能在特定应用服务器内运行规则等。
- en: Role of BPM and workflows
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BPM和工作流的作用
- en: '**Business Process Management** (**BPM**) and **Intelligent Business Process
    Management** (**iBPM**) are tool suites for designing, executing, and monitoring
    business processes.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical use cases for BPM are:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Coordinating a long-running business process, where some processes are realized
    by existing assets, whereas some other areas may be niche, and there is no concrete
    implementation of the processes being in place. BPM allows composing both types,
    and provides an end-to-end automated process. This often involves systems and
    human interactions.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process-centric organizations, such as those that have implemented Six Sigma,
    want to monitor their processes for continuous improvement on efficiency.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process re-engineering with a top-down approach by redefining the business process
    of an organization.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There could be two scenarios where BPM fits in the microservices world:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![Role of BPM and workflows](img/B05447_03_17.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: The first scenario is business process re-engineering, or threading an end-to-end
    long running business process, as stated earlier. In this case, BPM operates at
    a higher level, where it may automate a cross-functional, long-running business
    process by stitching a number of coarse-grained microservices, existing legacy
    connectors, and human interactions. As shown in the preceding diagram, the loan
    approval BPM invokes microservices as well as legacy application services. It
    also integrates human tasks.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, microservices are headless services that implement a subprocess.
    From the microservices'' perspective, BPM is just another consumer. Care needs
    to be taken in this approach to avoid accepting a shared state from a BPM process
    as well as moving business logic to BPM:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Role of BPM and workflows](img/B05447_03_18.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: The second scenario is monitoring processes, and optimizing them for efficiency.
    This goes hand in hand with a completely automated, asynchronously choreographed
    microservices ecosystem. In this case, microservices and BPM work as independent
    ecosystems. Microservices send events at various timeframes such as the start
    of a process, state changes, end of a process, and so on. These events are used
    by the BPM engine to plot and monitor process states. We may not require a full-fledged
    BPM solution for this, as we are only mocking a business process to monitor its
    efficiency. In this case, the order delivery process is not a BPM implementation,
    but it is more of a monitoring dashboard that captures and displays the progress
    of the process.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, BPM could still be used at a higher level for composing multiple
    microservices in situations where end-to-end cross-functional business processes
    are modeled by automating systems and human interactions. A better and simpler
    approach is to have a business process dashboard to which microservices feed state
    change events as mentioned in the second scenario.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Can microservices share data stores?
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In principle, microservices should abstract presentation, business logic, and
    data stores. If the services are broken as per the guidelines, each microservice
    logically could use an independent database:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Can microservices share data stores?](img/B05447_03_19.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, both **Product** and **Order** microservices share
    one database and one data model. Shared data models, shared schema, and shared
    tables are recipes for disasters when developing microservices. This may be good
    at the beginning, but when developing complex microservices, we tend to add relationships
    between data models, add join queries, and so on. This can result in tightly coupled
    physical data models.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'If the services have only a few tables, it may not be worth investing a full
    instance of a database like an Oracle database instance. In such cases, a schema
    level segregation is good enough to start with:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Can microservices share data stores?](img/B05447_03_20.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: 'There could be scenarios where we tend to think of using a shared database
    for multiple services. Taking an example of a customer data repository or master
    data managed at the enterprise level, the customer registration and customer segmentation
    microservices logically share the same customer data repository:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一些情况，我们倾向于考虑为多个服务使用共享数据库。以企业级管理的客户数据存储库或主数据为例，客户注册和客户分割微服务在逻辑上共享相同的客户数据存储库。
- en: '![Can microservices share data stores?](img/B05447_03_21.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![微服务可以共享数据存储吗？](img/B05447_03_21.jpg)'
- en: As shown in the preceding diagram, an alternate approach in this scenario is
    to separate the transactional data store for microservices from the enterprise
    data repository by adding a local transactional data store for these services.
    This will help the services to have flexibility in remodeling the local data store
    optimized for its purpose. The enterprise customer repository sends change events
    when there is any change in the customer data repository. Similarly, if there
    is any change in any of the transactional data stores, the changes have to be
    sent to the central customer repository.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在这种情况下的另一种方法是通过为这些服务添加一个本地事务数据存储来将微服务的事务数据存储与企业数据存储库分开。这将帮助服务在重新设计本地数据存储以优化其用途时具有灵活性。企业客户存储库在客户数据存储库发生任何更改时发送更改事件。同样，如果事务数据存储中的任何更改，这些更改都必须发送到中央客户存储库。
- en: Setting up transaction boundaries
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置事务边界
- en: Transactions in operational systems are used to maintain the consistency of
    data stored in an RDBMS by grouping a number of operations together into one atomic
    block. They either commit or rollback the entire operation. Distributed systems
    follow the concept of distributed transactions with a two-phase commit. This is
    particularly required if heterogeneous components such as an RPC service, JMS,
    and so on participate in a transaction.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统中的事务用于通过将多个操作组合成一个原子块来维护存储在RDBMS中的数据的一致性。它们要么提交整个操作，要么回滚整个操作。分布式系统遵循分布式事务的概念，采用两阶段提交。如果异构组件（如RPC服务、JMS等）参与事务，则特别需要这一点。
- en: Is there a place for transactions in microservices? Transactions are not bad,
    but one should use transactions carefully, by analyzing what we are trying do.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中是否有事务的位置？事务并不是坏事，但应该谨慎使用，通过分析我们要做什么来使用事务。
- en: For a given microservice, an RDBMS like MySQL may be selected as a backing store
    to ensure 100% data integrity, for example, a stock or inventory management service
    where data integrity is key. It is appropriate to define transaction boundaries
    within the microsystem using local transactions. However, distributed global transactions
    should be avoided in the microservices context. Proper dependency analysis is
    required to ensure that transaction boundaries do not span across two different
    microservices as much as possible.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的微服务，可以选择像MySQL这样的RDBMS作为后备存储，以确保100%的数据完整性，例如库存或库存管理服务，其中数据完整性至关重要。在微系统中使用本地事务定义事务边界是合适的。然而，在微服务环境中应避免分布式全局事务。需要进行适当的依赖性分析，以尽可能确保事务边界不跨越两个不同的微服务。
- en: Altering use cases to simplify transactional requirements
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改用例以简化事务要求
- en: Eventual consistency is a better option than distributed transactions that span
    across multiple microservices. Eventual consistency reduces a lot of overheads,
    but application developers may need to re-think the way they write application
    code. This could include remodeling functions, sequencing operations to minimize
    failures, batching insert and modify operations, remodeling data structure, and
    finally, compensating operations that negate the effect.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最终一致性比跨多个微服务的分布式事务是更好的选择。最终一致性减少了很多开销，但应用程序开发人员可能需要重新思考他们编写应用程序代码的方式。这可能包括重新设计函数、对操作进行排序以最小化故障、批量插入和修改操作、重新设计数据结构，最后是抵消效果的补偿操作。
- en: A classical problem is that of the last room selling scenario in a hotel booking
    use case. What if there is only one room left, and there are multiple customers
    booking this singe available room? A business model change sometimes makes this
    scenario less impactful. We could set an "under booking profile", where the actual
    number of bookable rooms can go below the actual number of rooms (*bookable =
    available - 3*) in anticipation of some cancellations. Anything in this range
    will be accepted as "subject to confirmation", and customers will be charged only
    if payment is confirmed. Bookings will be confirmed in a set time window.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的问题是酒店预订用例中的最后一个房间售罄的情况。如果只剩下一个房间，有多个客户预订这个可用的房间怎么办？有时业务模型的变化会使这种情况影响较小。我们可以设置一个“预订不足”配置文件，其中可预订房间的实际数量可以低于实际房间数量（*可预订=可用-3*），以预期会有一些取消。在这个范围内的任何预订都将被接受为“待确认”，只有在确认付款后才会向客户收费。预订将在一定的时间窗口内得到确认。
- en: Now consider the scenario where we are creating customer profiles in a NoSQL
    database like CouchDB. In more traditional approaches with RDBMS, we insert a
    customer first, and then insert the customer's address, profile details, then
    preferences, all in one transaction. When using NoSQL, we may not do the same
    steps. Instead, we may prepare a JSON object with all the details, and insert
    this into CouchDB in one go. In this second case, no explicit transaction boundaries
    are required.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一种情况，我们正在在像CouchDB这样的NoSQL数据库中创建客户配置文件。在传统的RDBMS方法中，我们首先插入客户，然后一次性插入客户的地址、配置文件详细信息，然后是偏好。在使用NoSQL时，我们可能不会执行相同的步骤。相反，我们可能准备一个包含所有细节的JSON对象，并一次性将其插入CouchDB。在这种情况下，不需要显式的事务边界。
- en: Distributed transaction scenarios
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式事务场景
- en: 'The ideal scenario is to use local transactions within a microservice if required,
    and completely avoid distributed transactions. There could be scenarios where
    at the end of the execution of one service, we may want to send a message to another
    microservice. For example, say a tour reservation has a wheelchair request. Once
    the reservation is successful, we will have to send a message for the wheelchair
    booking to another microservice that handles ancillary bookings. The reservation
    request itself will run on a local transaction. If sending this message fails,
    we are still in the transaction boundary, and we can roll back the entire transaction.
    What if we create a reservation and send the message, but after sending the message,
    we encounter an error in the reservation, the reservation transaction fails, and
    subsequently, the reservation record is rolled back? Now we end up in a situation
    where we''ve unnecessarily created an orphan wheelchair booking:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中，如果需要，理想的情况是在微服务内使用本地事务，并完全避免分布式事务。可能存在这样的情况，即在执行一个服务结束时，我们可能希望向另一个微服务发送消息。例如，假设旅行预订有一个轮椅请求。一旦预订成功，我们将不得不向另一个处理辅助预订的微服务发送一个轮椅预订的消息。预订请求本身将在本地事务上运行。如果发送此消息失败，我们仍然处于事务边界内，可以回滚整个事务。如果我们创建了一个预订并发送了消息，但在发送消息后遇到了预订错误，预订事务失败，随后预订记录被回滚？现在我们陷入了一个不必要创建孤立轮椅预订的情况：
- en: '![Distributed transaction scenarios](img/B05447_03_22.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![分布式事务场景](img/B05447_03_22.jpg)'
- en: There are a couple of ways we can address this scenario. The first approach
    is to delay sending the message till the end. This ensures that there are less
    chances for any failure after sending the message. Still, if failure occurs after
    sending the message, then the exception handling routine is run, that is, we send
    a compensating message to reverse the wheelchair booking.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式来解决这种情况。第一种方法是延迟发送消息直到最后。这确保在发送消息后减少任何失败的机会。即使在发送消息后发生故障，也会运行异常处理例程，也就是我们发送一个补偿消息来撤销轮椅预订。
- en: Service endpoint design consideration
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务端点设计考虑
- en: 'One of the important aspects of microservices is service design. Service design
    has two key elements: contract design and protocol selection.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的一个重要方面是服务设计。服务设计有两个关键元素：合同设计和协议选择。
- en: Contract design
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合同设计
- en: The first and foremost principle of service design is simplicity. The services
    should be designed for consumers to consume. A complex service contract reduces
    the usability of the service. The **KISS** (**Keep It Simple Stupid**) principle
    helps us to build better quality services faster, and reduces the cost of maintenance
    and replacement. The **YAGNI** (**You Ain't Gonna Need It**) is another principle
    supporting this idea. Predicting future requirements and building systems are,
    in reality, not future-proofed. This results in large upfront investment as well
    as higher cost of maintenance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 服务设计的首要原则是简单。服务应该设计为消费者消费。复杂的服务合同会降低服务的可用性。**KISS**（**保持简单愚蠢**）原则帮助我们更快地构建更高质量的服务，并降低维护和更换的成本。**YAGNI**（**你不会需要它**）是支持这一想法的另一个原则。预测未来的需求并构建系统实际上并不能未雨绸缪。这导致了大量的前期投资以及更高的维护成本。
- en: Evolutionary design is a great concept. Do just enough design to satisfy today's
    wants, and keep changing and refactoring the design to accommodate new features
    as and when they are required. Having said that, this may not be simple unless
    there is a strong governance in place.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 进化式设计是一个很好的概念。只需进行足够的设计来满足当下的需求，并不断改变和重构设计以适应新功能的需求。话虽如此，除非有强有力的治理措施，否则这可能并不简单。
- en: '**Consumer Driven Contracts** (**CDC**) is a great idea that supports evolutionary
    design. In many cases, when the service contract gets changed, all consuming applications
    have to undergo testing. This makes change difficult. CDC helps in building confidence
    in consumer applications. CDC advocates each consumer to provide their expectation
    to the provider in the form of test cases so that the provider uses them as integration
    tests whenever the service contract is changed.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**消费者驱动的合同**（**CDC**）是支持进化式设计的一个很好的想法。在许多情况下，当服务合同发生变化时，所有消费应用都必须经过测试。这使得变更变得困难。CDC有助于建立对消费应用的信心。CDC倡导每个消费者以测试用例的形式向提供者提供他们的期望，以便提供者在服务合同发生变化时将它们用作集成测试。'
- en: Postel's law is also relevant in this scenario. Postel's law primarily addresses
    TCP communications; however, this is also equally applicable to service design.
    When it comes to service design, service providers should be as flexible as possible
    when accepting consumer requests, whereas service consumers should stick to the
    contract as agreed with the provider.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 波斯特尔定律在这种情况下也是相关的。波斯特尔定律主要涉及TCP通信；然而，这同样适用于服务设计。在服务设计方面，服务提供者在接受消费者请求时应尽可能灵活，而服务消费者应遵守与提供者达成的合同。
- en: Protocol selection
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议选择
- en: In the SOA world, HTTP/SOAP, and messaging were kinds of default service protocols
    for service interactions. Microservices follow the same design principles for
    service interaction. Loose coupling is one of the core principles in the microservices
    world too.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在SOA世界中，HTTP/SOAP和消息传递是服务交互的默认协议。微服务遵循相同的服务交互设计原则。松耦合也是微服务世界的核心原则之一。
- en: Microservices fragment applications into many physically independent deployable
    services. This not only increases the communication cost, it is also susceptible
    to network failures. This could also result in poor performance of services.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务将应用程序分解为许多物理独立的可部署服务。这不仅增加了通信成本，还容易受到网络故障的影响。这也可能导致服务性能不佳。
- en: Message-oriented services
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 面向消息的服务
- en: If we choose an asynchronous style of communication, the user is disconnected,
    and therefore, response times are not directly impacted. In such cases, we may
    use standard JMS or AMQP protocols for communication with JSON as payload. Messaging
    over HTTP is also popular, as it reduces complexity. Many new entrants in messaging
    services support HTTP-based communication. Asynchronous REST is also possible,
    and is handy when calling long-running services.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择异步通信方式，用户是断开连接的，因此响应时间不会直接受到影响。在这种情况下，我们可以使用标准的JMS或AMQP协议进行通信，JSON作为有效载荷。通过HTTP进行消息传递也很受欢迎，因为它减少了复杂性。许多新进入消息服务的公司支持基于HTTP的通信。异步REST也是可能的，在调用长时间运行的服务时非常方便。
- en: HTTP and REST endpoints
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HTTP和REST端点
- en: Communication over HTTP is always better for interoperability, protocol handling,
    traffic routing, load balancing, security systems, and the like. Since HTTP is
    stateless, it is more compatible for handling stateless services with no affinity.
    Most of the development frameworks, testing tools, runtime containers, security
    systems, and so on are friendlier towards HTTP.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于互操作性、协议处理、流量路由、负载平衡、安全系统等方面，通过HTTP进行通信总是更好的。由于HTTP是无状态的，它更适合处理无关联的无状态服务。大多数开发框架、测试工具、运行时容器、安全系统等都更友好地支持HTTP。
- en: With the popularity and acceptance of REST and JSON, it is the default choice
    for microservice developers. The HTTP/REST/JSON protocol stack makes building
    interoperable systems very easy and friendly. HATEOAS is one of the design patterns
    emerging for designing progressive rendering and self-service navigations. As
    discussed in the previous chapter, HATEOAS provides a mechanism to link resources
    together so that the consumer can navigate between resources. RFC 5988 – Web Linking
    is another upcoming standard.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 随着REST和JSON的流行和接受，它是微服务开发者的默认选择。HTTP/REST/JSON协议栈使构建互操作系统变得非常容易和友好。HATEOAS是一种新兴的设计模式，用于设计渐进式渲染和自助导航。正如前一章讨论的那样，HATEOAS提供了一种将资源链接在一起的机制，以便消费者可以在资源之间导航。RFC
    5988 - Web Linking是另一个即将推出的标准。
- en: Optimized communication protocols
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优化的通信协议
- en: If the service response times are stringent, then we need to pay special attention
    to the communication aspects. In such cases, we may choose alternate protocols
    such as Avro, Protocol Buffers, or Thrift for communicating between services.
    But this limits the interoperability of services. The trade-off is between performance
    and interoperability requirements. Custom binary protocols need careful evaluation
    as they bind native objects on both sides—consumer and producer. This could run
    into release management issues such as class version mismatch in Java-based RPC
    style communications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务的响应时间要求严格，那么我们需要特别关注通信方面。在这种情况下，我们可以选择替代协议，如Avro、Protocol Buffers或Thrift来进行服务之间的通信。但这限制了服务的互操作性。权衡是在通信开销与在多个服务中复制库之间。自定义二进制协议需要仔细评估，因为它们在消费者和生产者两端绑定了本地对象。这可能会导致类版本不匹配的问题，比如基于Java的RPC风格通信中的类版本不匹配问题。
- en: API documentations
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: API文档
- en: 'Last thing: a good API is not only simple, but should also have enough documentation
    for the consumers. There are many tools available today for documenting REST-based
    services like Swagger, RAML, and API Blueprint.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：一个好的API不仅要简单，还应该有足够的文档供消费者使用。今天有许多工具可用于记录REST-based服务，如Swagger、RAML和API
    Blueprint。
- en: Handling shared libraries
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理共享库
- en: The principle behind microservices is that they should be autonomous and self-contained.
    In order to adhere to this principle, there may be situations where we will have
    to duplicate code and libraries. These could be either technical libraries or
    functional components.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务背后的原则是它们应该是自治的和自包含的。为了遵循这个原则，可能会出现需要复制代码和库的情况。这些可以是技术库或功能组件。
- en: '![Handling shared libraries](img/B05447_03_23.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![处理共享库](img/B05447_03_23.jpg)'
- en: For example, the eligibility for a flight upgrade will be checked at the time
    of check-in as well as when boarding. If check-in and boarding are two different
    microservices, we may have to duplicate the eligibility rules in both the services.
    This was the trade-off between adding a dependency versus code duplication.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于航班升舱的资格将在办理登机手续时和登机时进行检查。如果办理登机手续和登机是两个不同的微服务，我们可能需要在两个服务中都复制资格规则。这是添加依赖与代码重复之间的权衡。
- en: It may be easy to embed code as compared to adding an additional dependency,
    as it enables better release management and performance. But this is against the
    DRY principle.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与添加额外的依赖相比，嵌入代码可能更容易，因为它能够更好地管理发布和提高性能。但这违反了DRY原则。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**DRY principle**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**DRY原则**'
- en: Every piece of knowledge must have a single, unambiguous, authoritative representation
    within a system.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的每一条知识都必须有一个单一、明确、权威的表示。
- en: 'The downside of this approach is that in case of a bug or an enhancement on
    the shared library, it has to be upgraded in more than one place. This may not
    be a severe setback as each service can contain a different version of the shared
    library:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，如果共享库出现错误或需要增强，就必须在多个地方进行升级。这可能不是一个严重的挫折，因为每个服务可以包含共享库的不同版本：
- en: '![Handling shared libraries](img/B05447_03_24.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![处理共享库](img/B05447_03_24.jpg)'
- en: An alternative option of developing the shared library as another microservice
    itself needs careful analysis. If it is not qualified as a microservice from the
    business capability point of view, then it may add more complexity than its usefulness.
    The trade-off analysis is between overheads in communication versus duplicating
    the libraries in multiple services.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将共享库开发为另一个微服务本身的替代选项需要仔细分析。如果从业务能力的角度来看它并不合格作为一个微服务，那么它可能会增加更多的复杂性而不是有用性。权衡分析在通信开销与在多个服务中复制库之间。
- en: User interfaces in microservices
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务中的用户界面
- en: 'The microservices principle advocates a microservice as a vertical slice from
    the database to presentation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务原则主张将微服务作为从数据库到表示的垂直切片：
- en: '![User interfaces in microservices](img/B05447_03_25.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: 'In reality, we get requirements to build quick UI and mobile applications mashing
    up the existing APIs. This is not uncommon in the modern scenario, where a business
    wants quick turnaround time from IT:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![User interfaces in microservices](img/B05447_03_26.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: Penetration of mobile applications is one of the causes of this approach. In
    many organizations, there will be mobile development teams sitting close to the
    business team, developing rapid mobile applications by combining and mashing up
    APIs from multiple sources, both internal and external. In such situations, we
    may just expose services, and leave it for the mobile teams to realize in the
    way the business wants. In this case, we will build headless microservices, and
    leave it to the mobile teams to build a presentation layer.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Another category of problem is that the business may want to build consolidated
    web applications targeted to communities:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![User interfaces in microservices](img/B05447_03_27.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: For example, the business may want to develop a departure control application
    targeting airport users. A departure control web application may have functions
    such as check-in, lounge management, boarding, and so on. These may be designed
    as independent microservices. But from the business standpoint, it all needs to
    be clubbed into a single web application. In such cases, we will have to build
    web applications by mashing up services from the backend.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: One approach is to build a container web application or a placeholder web application,
    which links to multiple microservices at the backend. In this case, we develop
    full stack microservices, but the screens coming out of this could be embedded
    in to another placeholder web application. One of the advantages of this approach
    is that you can have multiple placeholder web applications targeting different
    user communities, as shown in the preceding diagram. We may use an API gateway
    to avoid those crisscross connections. We will explore the API gateway in the
    next section.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Use of API gateways in microservices
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the advancement of client-side JavaScript frameworks like AngularJS, the
    server is expected to expose RESTful services. This could lead to two issues.
    The first issue is the mismatch in contract expectations. The second issue is
    multiple calls to the server to render a page.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the contract mismatch case. For example, `GetCustomer` may return
    a JSON with many fields:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding case, `Name`, `Address`, and `Contact` are nested JSON objects.
    But a mobile client may expect only basic information such as first name, and
    last name. In the SOA world, an ESB or a mobile middleware did this job of transformation
    of data for the client. The default approach in microservices is to get all the
    elements of `Customer`, and then the client takes up the responsibility to filter
    the elements. In this case, the overhead is on the network.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several approaches we can think about to solve this case:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first approach, minimal information is sent with links as explained in
    the section on HATEOAS. In the preceding case, for customer ID `1`, there are
    three links, which will help the client to access specific data elements. The
    example is a simple logical representation, not the actual JSON. The mobile client
    in this case will get basic customer information. The client further uses the
    links to get the additional required information.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The second approach is used when the client makes the REST call; it also sends
    the required fields as part of the query string. In this scenario, the client
    sends a request with `firstname` and `lastname` as the query string to indicate
    that the client only requires these two fields. The downside is that it ends up
    in complex server-side logic as it has to filter based on the fields. The server
    has to send different elements based on the incoming query.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The third approach is to introduce a level of indirection. In this, a gateway
    component sits between the client and the server, and transforms data as per the
    consumer''s specification. This is a better approach as we do not compromise on
    the backend service contract. This leads to what is called UI services. In many
    cases, the API gateway acts as a proxy to the backend, exposing a set of consumer-specific
    APIs:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是引入一定程度的间接性。在这种情况下，一个网关组件位于客户端和服务器之间，并根据消费者的规范转换数据。这是一个更好的方法，因为我们不会妥协后端服务契约。这导致了所谓的UI服务。在许多情况下，API网关充当后端的代理，公开一组特定于消费者的API：
- en: '![Use of API gateways in microservices](img/B05447_03_28.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: 微服务中使用API网关
- en: There are two ways we can deploy an API gateway. The first one is one API gateway
    per microservice as shown in diagram **A**. The second approach (diagram **B**)
    is to have a common API gateway for multiple services. The choice really depends
    on what we are looking for. If we are using an API gateway as a reverse proxy,
    then off-the-shelf gateways such as Apigee, Mashery, and the like could be used
    as a shared platform. If we need fine-grained control over traffic shaping and
    complex transformations, then per service custom API gateways may be more useful.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以两种方式部署API网关。第一种是每个微服务一个API网关，如图**A**所示。第二种方法（图**B**）是为多个服务使用一个通用API网关。选择取决于我们要寻找什么。如果我们将API网关用作反向代理，那么可以使用诸如Apigee、Mashery等现成的网关作为共享平台。如果我们需要对流量塑形和复杂转换进行精细控制，那么每个服务的自定义API网关可能更有用。
- en: A related problem is that we will have to make many calls from the client to
    the server. If we refer to our holiday example in [Chapter 1](ch01.html "Chapter 1. Demystifying
    Microservices"), *Demystifying Microservices*, you know that for rendering each
    widget, we had to make a call to the server. Though we transfer only data, it
    can still add a significant overhead on the network. This approach is not fully
    wrong, as in many cases, we use responsive design and progressive design. The
    data will be loaded on demand, based on user navigations. In order to do this,
    each widget in the client should make independent calls to the server in a lazy
    mode. If bandwidth is an issue, then an API gateway is the solution. An API gateway
    acts as a middleman to compose and transform APIs from multiple microservices.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 相关问题是，我们将不得不从客户端向服务器发出许多调用。如果我们参考[第1章](ch01.html "第1章。解密微服务")中的度假示例，*解密微服务*，您会知道为了呈现每个小部件，我们必须向服务器发出调用。尽管我们只传输数据，但仍可能对网络造成重大负担。这种方法并不完全错误，因为在许多情况下，我们使用响应式设计和渐进式设计。数据将根据用户导航按需加载。为了做到这一点，客户端中的每个小部件都应以懒惰模式独立地向服务器发出调用。如果带宽是一个问题，那么API网关就是解决方案。API网关充当中间人，从多个微服务中组合和转换API。
- en: Use of ESB and iPaaS with microservices
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在微服务中使用ESB和iPaaS
- en: Theoretically, SOA is not all about ESBs, but the reality is that ESBs have
    always been at the center of many SOA implementations. What would be the role
    of an ESB in the microservices world?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，SOA并不完全依赖于ESB，但现实情况是，ESB一直是许多SOA实施的核心。在微服务世界中，ESB的角色将是什么？
- en: In general, microservices are fully cloud native systems with smaller footprints.
    The lightweight characteristics of microservices enable automation of deployments,
    scaling, and so on. On the contrary, enterprise ESBs are heavyweight in nature,
    and most of the commercial ESBs are not cloud friendly. The key features of an
    ESB are protocol mediation, transformation, orchestration, and application adaptors.
    In a typical microservices ecosystem, we may not need any of these features.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，微服务是具有较小占地面积的完全云原生系统。微服务的轻量特性使得部署、扩展等自动化成为可能。相反，企业ESB具有沉重的特性，大多数商业ESB都不友好于云。ESB的关键特性是协议调解、转换、编排和应用适配器。在典型的微服务生态系统中，我们可能不需要这些功能。
- en: The limited ESB capabilities that are relevant for microservices are already
    available with more lightweight tools such as an API gateway. Orchestration is
    moved from the central bus to the microservices themselves. Therefore, there is
    no centralized orchestration capability expected in the case of microservices.
    Since the services are set up to accept more universal message exchange styles
    using REST/JSON calls, no protocol mediation is required. The last piece of capability
    that we get from ESBs are the adaptors to connect back to the legacy systems.
    In the case of microservices, the service itself provides a concrete implementation,
    and hence, there are no legacy connectors required. For these reasons, there is
    no natural space for ESBs in the microservices world.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务相关的有限ESB功能，已经可以使用更轻量级的工具，如API网关。编排从中央总线转移到了微服务本身。因此，在微服务的情况下，不需要集中的编排能力。由于服务设置为接受更通用的消息交换样式，使用REST/JSON调用，因此不需要协议调解。我们从ESB中获得的最后一部分功能是连接回传统系统的适配器。在微服务的情况下，服务本身提供了具体的实现，因此不需要传统的连接器。因此，ESB在微服务世界中没有自然的空间。
- en: Many organizations established ESBs as the backbone for their application integrations
    (EAI). Enterprise architecture policies in such organizations are built around
    ESBs. There could be a number of enterprise-level policies such as auditing, logging,
    security, validation, and so on that would have been in place when integrating
    using ESB. Microservices, however, advocate a more decentralized governance. ESBs
    will be an overkill if integrated with microservices.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织将ESB建立为其应用集成（EAI）的支柱。这些组织的企业架构政策是围绕ESB构建的。在使用ESB进行集成时，可能存在许多企业级政策，如审计、日志记录、安全性、验证等。然而，微服务倡导更加分散的治理。如果与微服务集成，ESB将是一种过度杀伤力。
- en: Not all services are microservices. Enterprises have legacy applications, vendor
    applications, and so on. Legacy services use ESBs to connect with microservices.
    ESBs still hold their place for legacy integration and vendor applications to
    integrate at the enterprise level.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有服务都是微服务。企业拥有遗留应用程序、供应商应用程序等。遗留服务使用ESB与微服务连接。ESB仍然在遗留集成和供应商应用程序集成中占据一席之地。
- en: With the advancement of clouds, the capabilities of ESBs are not sufficient
    to manage integration between clouds, cloud to on-premise, and so on. **Integration
    Platform as a Service** (**iPaaS**) is evolving as the next generation application
    integration platform, which further reduces the role of ESBs. In typical deployments,
    iPaaS invokes API gateways to access microservices.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云的发展，ESB的能力已不足以管理云之间、云与本地等之间的集成。**集成平台即服务**（**iPaaS**）正在成为下一代应用集成平台，进一步减少了ESB的作用。在典型部署中，iPaaS调用API网关来访问微服务。
- en: Service versioning considerations
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务版本考虑
- en: When we allow services to evolve, one of the important aspect to consider is
    service versioning. Service versioning should be considered upfront, and not as
    an afterthought. Versioning helps us to release new services without breaking
    the existing consumers. Both the old version and the new version will be deployed
    side by side.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们允许服务发展时，需要考虑的一个重要方面是服务版本控制。服务版本控制应该是提前考虑的，而不是事后的想法。版本控制帮助我们发布新服务而不会破坏现有的消费者。新旧版本将同时部署。
- en: 'Semantic versions are widely used for service versioning. A semantic version
    has three components: **major**, **minor**, and **patch**. Major is used when
    there is a breaking change, minor is used when there is a backward compatible
    change, and patch is used when there is a backward compatible bug fix.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本广泛用于服务版本控制。语义版本有三个组成部分：**主要**、**次要**和**补丁**。主要用于有破坏性变化时，次要用于向后兼容的变化，补丁用于向后兼容的错误修复。
- en: Versioning could get complicated when there is more than one service in a microservice.
    It is always simple to version services at the service level compared to the operations
    level. If there is a change in one of the operations, the service is upgraded
    and deployed to V2\. The version change is applicable to all operations in the
    service. This is the notion of immutable services.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当微服务中有多个服务时，版本控制可能会变得复杂。与操作级别相比，对服务级别进行版本控制总是更简单的。如果其中一个操作发生变化，服务将升级并部署到V2。版本变化适用于服务中的所有操作。这是不可变服务的概念。
- en: 'There are three different ways in which we can version REST services:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以三种不同的方式对REST服务进行版本控制：
- en: URI versioning
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI版本控制
- en: Media type versioning
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体类型版本控制
- en: Custom header
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义标头
- en: 'In URI versioning, the version number is included in the URL itself. In this
    case, we just need to be worried about the major versions only. Hence, if there
    is a minor version change or a patch, the consumers do not need to worry about
    the changes. It is a good practice to alias the latest version to a non-versioned
    URI, which is done as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在URI版本控制中，版本号包含在URL中。在这种情况下，我们只需要担心主要版本。因此，如果有次要版本变化或补丁，消费者不需要担心变化。将最新版本别名为非版本化的URI是一个好的做法，如下所示：
- en: '[PRE2]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A slightly different approach is to use the version number as part of the URL
    parameter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微不同的方法是将版本号作为URL参数的一部分：
- en: '[PRE3]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In case of media type versioning, the version is set by the client on the HTTP
    `Accept` header as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在媒体类型版本控制的情况下，版本由客户端在HTTP `Accept`标头中设置如下：
- en: '[PRE4]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A less effective approach for versioning is to set the version in the custom
    header:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制的一个不太有效的方法是在自定义标头中设置版本：
- en: '[PRE5]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the URI approach, it is simple for the clients to consume services. But this
    has some inherent issues such as the fact that versioning-nested URI resources
    could be complex. Indeed, migrating clients is slightly complex as compared to
    media type approaches, with caching issues for multiple versions of the services,
    and others. However, these issues are not significant enough for us to not go
    with a URI approach. Most of the big Internet players such as Google, Twitter,
    LinkedIn, and Salesforce are following the URI approach.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在URI方法中，客户端消费服务很简单。但这也存在一些固有问题，比如嵌套URI资源的版本控制可能会很复杂。事实上，与媒体类型方法相比，迁移客户端稍微复杂，服务的多个版本存在缓存问题等。然而，这些问题并不足以让我们不选择URI方法。大多数大型互联网公司，如谷歌、Twitter、LinkedIn和Salesforce都在采用URI方法。
- en: Design for cross origin
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计跨域
- en: With microservices, there is no guarantee that the services will run from the
    same host or same domain. Composite UI web applications may call multiple microservices
    for accomplishing a task, and these could come from different domains and hosts.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中，不能保证服务将从相同的主机或相同的域运行。复合UI Web应用程序可能调用多个微服务来完成任务，这些微服务可能来自不同的域和主机。
- en: CORS allows browser clients to send requests to services hosted on different
    domains. This is essential in a microservices-based architecture.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: CORS允许浏览器客户端向托管在不同域上的服务发送请求。这在基于微服务的架构中是必不可少的。
- en: One approach is to enable all microservices to allow cross origin requests from
    other trusted domains. The second approach is to use an API gateway as a single
    trusted domain for the clients.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是允许所有微服务允许来自其他受信任域的跨域请求。第二种方法是使用API网关作为客户端的单一受信任域。
- en: Handling shared reference data
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理共享参考数据
- en: When breaking large applications, one of the common issues which we see is the
    management of master data or reference data. Reference data is more like shared
    data required between different microservices. City master, country master, and
    so on will be used in many services such as flight schedules, reservations, and
    others.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在拆分大型应用程序时，我们经常看到的一个常见问题是主数据或参考数据的管理。参考数据更像是不同微服务之间需要共享的数据。城市主数据、国家主数据等将被用于许多服务，如航班时刻表、预订等。
- en: 'There are a few ways in which we can solve this. For instance, in the case
    of relatively static, never changing data, then every service can hardcode this
    data within all the microservices themselves:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling shared reference data](img/B05447_03_29.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: 'Another approach, as shown in the preceding diagram, is to build it as another
    microservice. This is good, clean, and neat, but the downside is that every service
    may need to call the master data multiple times. As shown in the diagram for the
    **Search** and **Booking** example, there are transactional microservices, which
    use the **Geography** microservice to access shared data:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling shared reference data](img/B05447_03_30.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: Another option is to replicate the data with every microservice. There is no
    single owner, but each service has its required master data. When there is an
    update, all the services are updated. This is extremely performance friendly,
    but one has to duplicate the code in all the services. It is also complex to keep
    data in sync across all microservices. This approach makes sense if the code base
    and data is simple or the data is more static.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling shared reference data](img/B05447_03_31.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: Yet another approach is similar to the first approach, but each service has
    a local near cache of the required data, which will be loaded incrementally. A
    local embedded cache such as Ehcache or data grids like Hazelcast or Infinispan
    could also be used based on the data volumes. This is the most preferred approach
    for a large number of microservices that have dependency on the master data.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Microservices and bulk operations
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have broken monolithic applications into smaller, focused services,
    it is no longer possible to use join queries across microservice data stores.
    This could lead to situations where one service may need many records from other
    services to perform its function.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices and bulk operations](img/B05447_03_32.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: 'For example, a monthly billing function needs the invoices of many customers
    to process the billing. To make it a bit more complicated, invoices may have many
    orders. When we break billing, invoices, and orders into three different microservices,
    the challenge that arises is that the **Billing** service has to query the **Invoices**
    service for each customer to get all the invoices, and then for each invoice,
    call the **Order** service for getting the orders. This is not a good solution,
    as the number of calls that goes to other microservices are high:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices and bulk operations](img/B05447_03_33.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: There are two ways we can think about for solving this. The first approach is
    to pre-aggregate data as and when it is created. When an order is created, an
    event is sent out. Upon receiving the event, the **Billing** microservice keeps
    aggregating data internally for monthly processing. In this case, there is no
    need for the **Billing** microservice to go out for processing. The downside of
    this approach is that there is duplication of data.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: A second approach, when pre-aggregation is not possible, is to use batch APIs.
    In such cases, we call `GetAllInvoices`, then we use multiple batches, and each
    batch further uses parallel threads to get orders. Spring Batch is useful in these
    situations.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Microservices challenges
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned about the right design decisions to be
    taken, and the trade-offs to be applied. In this section, we will review some
    of the challenges with microservices, and how to address them for a successful
    microservice development.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Data islands
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices abstract their own local transactional store, which is used for
    their own transactional purposes. The type of store and the data structure will
    be optimized for the services offered by the microservice.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to develop a customer relationship graph, we may use
    a graph database like Neo4j, OrientDB, and the like. A predictive text search
    to find out a customer based on any related information such as passport number,
    address, e-mail, phone, and so on could be best realized using an indexed search
    database like Elasticsearch or Solr.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'This will place us into a unique situation of fragmenting data into heterogeneous
    data islands. For example, Customer, Loyalty Points, Reservations, and others
    are different microservices, and hence, use different databases. What if we want
    to do a near real-time analysis of all high value customers by combining data
    from all three data stores? This was easy with a monolithic application, because
    all the data was present in a single database:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Data islands](img/B05447_03_34.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: In order to satisfy this requirement, a data warehouse or a data lake is required.
    Traditional data warehouses like Oracle, Teradata, and others are used primarily
    for batch reporting. But with NoSQL databases (like Hadoop) and microbatching
    techniques, near real-time analytics is possible with the concept of data lakes.
    Unlike the traditional warehouses that are purpose-built for batch reporting,
    data lakes store raw data without assuming how the data is going to be used. Now
    the question really is how to port the data from microservices into data lakes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Data porting from microservices to a data lake or a data warehouse can be done
    in many ways. Traditional ETL could be one of the options. Since we allow backdoor
    entry with ETL, and break the abstraction, this is not considered an effective
    way for data movement. A better approach is to send events from microservices
    as and when they occur, for example, customer registration, customer update events,
    and so on. Data ingestion tools consume these events, and propagate the state
    change to the data lake appropriately. The data ingestion tools are highly scalable
    platforms such as Spring Cloud Data Flow, Kafka, Flume, and so on.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Logging and monitoring
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Log files are a good piece of information for analysis and debugging. Since
    each microservice is deployed independently, they emit separate logs, maybe to
    a local disk. This results in fragmented logs. When we scale services across multiple
    machines, each service instance could produce separate log files. This makes it
    extremely difficult to debug and understand the behavior of the services through
    log mining.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Examining **Order**, **Delivery**, and **Notification** as three different
    microservices, we find no way to correlate a customer transaction that runs across
    all three of them:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging and monitoring](img/B05447_03_35.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: When implementing microservices, we need a capability to ship logs from each
    service to a centrally managed log repository. With this approach, services do
    not have to rely on the local disk or local I/Os. A second advantage is that the
    log files are centrally managed, and are available for all sorts of analysis such
    as historical, real time, and trending. By introducing a correlation ID, end-to-end
    transactions can be easily tracked.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: With a large number of microservices, and with multiple versions and service
    instances, it would be difficult to find out which service is running on which
    server, what's the health of these services, the service dependencies, and so
    on. This was much easier with monolithic applications that are tagged against
    a specific or a fixed set of servers.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Apart from understanding the deployment topology and health, it also poses a
    challenge in identifying service behaviors, debugging, and identifying hotspots.
    Strong monitoring capabilities are required to manage such an infrastructure.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the logging and monitoring aspects in [Chapter 7](ch07.html "Chapter 7. Logging
    and Monitoring Microservices"), *Logging and Monitoring Microservices*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dependency management is one of the key issues in large microservice deployments.
    How do we identify and reduce the impact of a change? How do we know whether all
    the dependent services are up and running? How will the service behave if one
    of the dependent services is not available?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Too many dependencies could raise challenges in microservices. Four important
    design aspects are stated as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Reducing dependencies by properly designing service boundaries.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing impacts by designing dependencies as loosely coupled as possible. Also,
    designing service interactions through asynchronous communication styles.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tackling dependency issues using patterns such as circuit breakers.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring dependencies using visual dependency graphs.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organization culture
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the biggest challenges in microservices implementation is the organization
    culture. To harness the speed of delivery of microservices, the organization should
    adopt Agile development processes, continuous integration, automated QA checks,
    automated delivery pipelines, automated deployments, and automatic infrastructure
    provisioning.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Organizations following a waterfall development or heavyweight release management
    processes with infrequent release cycles are a challenge for microservices development.
    Insufficient automation is also a challenge for microservices deployment.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: In short, Cloud and DevOps are supporting facets of microservice development.
    These are essential for successful microservices implementation.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Governance challenges
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices impose decentralized governance, and this is quite in contrast
    with the traditional SOA governance. Organizations may find it hard to come up
    with this change, and that could negatively impact the microservices development.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: There are number of challenges that comes with a decentralized governance model.
    How do we understand who is consuming a service? How do we ensure service reuse?
    How do we define which services are available in the organization? How do we ensure
    enforcement of enterprise polices?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The first thing is to have a set of standards, best practices, and guidelines
    on how to implement better services. These should be available to the organization
    in the form of standard libraries, tools, and techniques. This ensures that the
    services developed are top quality, and that they are developed in a consistent
    manner.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The second important consideration is to have a place where all stakeholders
    can not only see all the services, but also their documentations, contracts, and
    service-level agreements. Swagger and API Blueprint are commonly used for handling
    these requirements.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Operation overheads
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices deployment generally increases the number of deployable units
    and virtual machines (or containers). This adds significant management overheads
    and increases the cost of operations.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: With a single application, a dedicated number of containers or virtual machines
    in an on-premise data center may not make much sense unless the business benefit
    is very high. The cost generally goes down with economies of scale. A large number
    of microservices that are deployed in a shared infrastructure which is fully automated
    makes more sense, since these microservices are not tagged against any specific
    VMs or containers. Capabilities around infrastructure automation, provisioning,
    containerized deployment, and so on are essential for large scale microservices
    deployments. Without this automation, it would result in a significant operation
    overhead and increased cost.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: With many microservices, the number of **configurable items** (**CIs**) becomes
    too high, and the number of servers in which these CIs are deployed might also
    be unpredictable. This makes it extremely difficult to manage data in a traditional
    **Configuration Management Database** (**CMDB**). In many cases, it is more useful
    to dynamically discover the current running topology than a statically configured
    CMDB-style deployment topology.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Testing microservices
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices also pose a challenge for the testability of services. In order
    to achieve a full-service functionality, one service may rely on another service,
    and that, in turn, on another service—either synchronously or asynchronously.
    The issue is how do we test an end-to-end service to evaluate its behavior? The
    dependent services may or may not be available at the time of testing.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Service virtualization or service mocking is one of the techniques used for
    testing services without actual dependencies. In testing environments, when the
    services are not available, mock services can simulate the behavior of the actual
    service. The microservices ecosystem needs service virtualization capabilities.
    However, this may not give full confidence, as there may by many corner cases
    that mock services do not simulate, especially when there are deep dependencies.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Another approach, as discussed earlier, is to use a consumer driven contract.
    The translated integration test cases can cover more or less all corner cases
    of the service invocation.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Test automation, appropriate performance testing, and continuous delivery approaches
    such as A/B testing, future flags, canary testing, blue-green deployments, and
    red-black deployments, all reduce the risks of production releases.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure provisioning
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As briefly touched on under operation overheads, manual deployment could severely
    challenge the microservices rollouts. If a deployment has manual elements, the
    deployer or operational administrators should know the running topology, manually
    reroute traffic, and then deploy the application one by one till all services
    are upgraded. With many server instances running, this could lead to significant
    operational overheads. Moreover, the chances of errors are high in this manual
    approach.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Microservices require a supporting elastic cloud-like infrastructure which can
    automatically provision VMs or containers, automatically deploy applications,
    adjust traffic flows, replicate new version to all instances, and gracefully phase
    out older versions. The automation also takes care of scaling up elastically by
    adding containers or VMs on demand, and scaling down when the load falls below
    threshold.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: In a large deployment environment with many microservices, we may also need
    additional tools to manage VMs or containers that can further initiate or destroy
    services automatically.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The microservices capability model
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we conclude this chapter, we will review a capability model for microservices
    based on the design guidelines and common pattern and solutions described in this
    chapter.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the microservices capability model:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![The microservices capability model](img/B05447_03_36.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: 'The capability model is broadly classified in to four areas:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '**Core capabilities**: These are part of the microservices themselves'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supporting capabilities**: These are software solutions supporting core microservice
    implementations'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure capabilities**: These are infrastructure level expectations
    for a successful microservices implementation'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Governance capabilities**: These are more of process, people, and reference
    information'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core capabilities
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The core capabilities are explained as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '**Service listeners** (HTTP/messaging): If microservices are enabled for a
    HTTP-based service endpoint, then the HTTP listener is embedded within the microservices,
    thereby eliminating the need to have any external application server requirement.
    The HTTP listener is started at the time of the application startup. If the microservice
    is based on asynchronous communication, then instead of an HTTP listener, a message
    listener is started. Optionally, other protocols could also be considered. There
    may not be any listeners if the microservice is a scheduled service. Spring Boot
    and Spring Cloud Streams provide this capability.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage capability**: The microservices have some kind of storage mechanisms
    to store state or transactional data pertaining to the business capability. This
    is optional, depending on the capabilities that are implemented. The storage could
    be either a physical storage (RDBMS such as MySQL; NoSQL such as Hadoop, Cassandra,
    Neo 4J, Elasticsearch, and so on), or it could be an in-memory store (cache like
    Ehcache, data grids like Hazelcast, Infinispan, and so on)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business capability definition**: This is the core of microservices, where
    the business logic is implemented. This could be implemented in any applicable
    language such as Java, Scala, Conjure, Erlang, and so on. All required business
    logic to fulfill the function will be embedded within the microservices themselves.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event sourcing**: Microservices send out state changes to the external world
    without really worrying about the targeted consumers of these events. These events
    could be consumed by other microservices, audit services, replication services,
    or external applications, and the like. This allows other microservices and applications
    to respond to state changes.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service endpoints and communication protocols**: These define the APIs for
    external consumers to consume. These could be synchronous endpoints or asynchronous
    endpoints. Synchronous endpoints could be based on REST/JSON or any other protocols
    such as Avro, Thrift, Protocol Buffers, and so on. Asynchronous endpoints are
    through Spring Cloud Streams backed by RabbitMQ, other messaging servers, or other
    messaging style implementations such as ZeroMQ.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API gateway**: The API gateway provides a level of indirection by either
    proxying service endpoints or composing multiple service endpoints. The API gateway
    is also useful for policy enforcements. It may also provide real time load balancing
    capabilities. There are many API gateways available in the market. Spring Cloud
    Zuul, Mashery, Apigee, and 3scale are some examples of the API gateway providers.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User interfaces**: Generally, user interfaces are also part of microservices
    for users to interact with the business capabilities realized by the microservices.
    These could be implemented in any technology, and are channel- and device-agnostic.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure capabilities
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Certain infrastructure capabilities are required for a successful deployment,
    and managing large scale microservices. When deploying microservices at scale,
    not having proper infrastructure capabilities can be challenging, and can lead
    to failures:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud**: Microservices implementation is difficult in a traditional data
    center environment with long lead times to provision infrastructures. Even a large
    number of infrastructures dedicated per microservice may not be very cost effective.
    Managing them internally in a data center may increase the cost of ownership and
    cost of operations. A cloud-like infrastructure is better for microservices deployment.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers or virtual machines**: Managing large physical machines is not
    cost effective, and they are also hard to manage. With physical machines, it is
    also hard to handle automatic fault tolerance. Virtualization is adopted by many
    organizations because of its ability to provide optimal use of physical resources.
    It also provides resource isolation. It also reduces the overheads in managing
    large physical infrastructure components. Containers are the next generation of
    virtual machines. VMWare, Citrix, and so on provide virtual machine technologies.
    Docker, Drawbridge, Rocket, and LXD are some of the containerizer technologies.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster control and provisioning**: Once we have a large number of containers
    or virtual machines, it is hard to manage and maintain them automatically. Cluster
    control tools provide a uniform operating environment on top of the containers,
    and share the available capacity across multiple services. Apache Mesos and Kubernetes
    are examples of cluster control systems.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application lifecycle management**: Application lifecycle management tools
    help to invoke applications when a new container is launched, or kill the application
    when the container shuts down. Application life cycle management allows for script
    application deployments and releases. It automatically detects failure scenario,
    and responds to those failures thereby ensuring the availability of the application.
    This works in conjunction with the cluster control software. Marathon partially
    addresses this capability.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting capabilities
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Supporting capabilities are not directly linked to microservices, but they
    are essential for large scale microservices development:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '**Software defined load balancer**: The load balancer should be smart enough
    to understand the changes in the deployment topology, and respond accordingly.
    This moves away from the traditional approach of configuring static IP addresses,
    domain aliases, or cluster addresses in the load balancer. When new servers are
    added to the environment, it should automatically detect this, and include them
    in the logical cluster by avoiding any manual interactions. Similarly, if a service
    instance is unavailable, it should take it out from the load balancer. A combination
    of Ribbon, Eureka, and Zuul provide this capability in Spring Cloud Netflix.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Central log management**: As explored earlier in this chapter, a capability
    is required to centralize all logs emitted by service instances with the correlation
    IDs. This helps in debugging, identifying performance bottlenecks, and predictive
    analysis. The result of this is fed back into the life cycle manager to take corrective
    actions.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service registry**: A service registry provides a runtime environment for
    services to automatically publish their availability at runtime. A registry will
    be a good source of information to understand the services topology at any point.
    Eureka from Spring Cloud, Zookeeper, and Etcd are some of the service registry
    tools available.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security service**: A distributed microservices ecosystem requires a central
    server for managing service security. This includes service authentication and
    token services. OAuth2-based services are widely used for microservices security.
    Spring Security and Spring Security OAuth are good candidates for building this
    capability.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service configuration**: All service configurations should be externalized
    as discussed in the Twelve-Factor application principles. A central service for
    all configurations is a good choice. Spring Cloud Config server, and Archaius
    are out-of-the-box configuration servers.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing tools (anti-fragile, RUM, and so on)**: Netflix uses Simian Army
    for anti-fragile testing. Matured services need consistent challenges to see the
    reliability of the services, and how good fallback mechanisms are. Simian Army
    components create various error scenarios to explore the behavior of the system
    under failure scenarios.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and dashboards**: Microservices also require a strong monitoring
    mechanism. This is not just at the infrastructure-level monitoring but also at
    the service level. Spring Cloud Netflix Turbine, Hysterix Dashboard, and the like
    provide service level information. End-to-end monitoring tools like AppDynamic,
    New Relic, Dynatrace, and other tools like statd, Sensu, and Spigo could add value
    to microservices monitoring.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency and CI management**: We also need tools to discover runtime topologies,
    service dependencies, and to manage configurable items. A graph-based CMDB is
    the most obvious tool to manage these scenarios.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data lake**: As discussed earlier in this chapter, we need a mechanism to
    combine data stored in different microservices, and perform near real-time analytics.
    A data lake is a good choice for achieving this. Data ingestion tools like Spring
    Cloud Data Flow, Flume, and Kafka are used to consume data. HDFS, Cassandra, and
    the like are used for storing data.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliable messaging**: If the communication is asynchronous, we may need a
    reliable messaging infrastructure service such as RabbitMQ or any other reliable
    messaging service. Cloud messaging or messaging as a service is a popular choice
    in Internet scale message-based service endpoints.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process and governance capabilities
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last piece in the puzzle is the process and governance capabilities that
    are required for microservices:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '**DevOps**: The key to successful implementation of microservices is to adopt
    DevOps. DevOps compliment microservices development by supporting Agile development,
    high velocity delivery, automation, and better change management.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevOps tools**: DevOps tools for Agile development, continuous integration,
    continuous delivery, and continuous deployment are essential for successful delivery
    of microservices. A lot of emphasis is required on automated functioning, real
    user testing, synthetic testing, integration, release, and performance testing.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices repository**: A microservices repository is where the versioned
    binaries of microservices are placed. These could be a simple Nexus repository
    or a container repository such as a Docker registry.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice documentation**: It is important to have all microservices properly
    documented. Swagger or API Blueprint are helpful in achieving good microservices
    documentation.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference architecture and libraries**: The reference architecture provides
    a blueprint at the organization level to ensure that the services are developed
    according to certain standards and guidelines in a consistent manner. Many of
    these could then be translated to a number of reusable libraries that enforce
    service development philosophies.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about handling practical scenarios that will arise
    in microservices development.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: You learned various solution options and patterns that could be applied to solve
    common microservices problems. We reviewed a number of challenges when developing
    large scale microservices, and how to address those challenges effectively.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: We also built a capability reference model for a microservices-based ecosystem.
    The capability model helps in addressing gaps when building Internet scale microservices.
    The capability model learned in this chapter will be the backbone for this book.
    The remaining chapters will deep dive into the capability model.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a real-world problem and model it using the
    microservices architecture to see how to translate our learnings into practice.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 4. Microservices Evolution – A Case Study
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。微服务演进-案例研究
- en: Like SOA, a microservices architecture can be interpreted differently by different
    organizations, based on the problem in hand. Unless a sizable, real world problem
    is examined in detail, microservices concepts are hard to understand.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与SOA一样，微服务架构可以根据手头的问题在不同组织中有不同的解释。除非详细研究一个相当大的真实问题，否则微服务概念很难理解。
- en: This chapter will introduce BrownField Airline (BF), a fictitious budget airline,
    and their journey from a monolithic **Passenger Sales and Service** (**PSS**)
    application to a next generation microservices architecture. This chapter examines
    the PSS application in detail, and explains the challenges, approach, and transformation
    steps of a monolithic system to a microservices-based architecture, adhering to
    the principles and practices that were explained in the previous chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍BrownField航空公司（BF），一个虚构的廉价航空公司，以及他们从单体**乘客销售和服务**（**PSS**）应用到下一代微服务架构的过程。本章将详细研究PSS应用，并解释从单体系统到基于微服务的架构的挑战、方法和转型步骤，遵循前一章中解释的原则和实践。
- en: The intention of this case study is to get us as close as possible to a live
    scenario so that the architecture concepts can be set in stone.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例研究的目的是让我们尽可能接近实际情况，以便将架构概念确立下来。
- en: 'By the end of this chapter, you will have learned about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将学到以下内容：
- en: A real world case for migrating monolithic systems to microservices-based ones,
    with the BrownField Airline's PSS application as an example
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单体系统迁移到基于微服务的真实案例，以BrownField航空公司的PSS应用为例
- en: Various approaches and transition strategies for migrating a monolithic application
    to microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移单体应用程序到微服务的各种方法和过渡策略
- en: Designing a new futuristic microservices system to replace the PSS application
    using Spring Framework components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring框架组件设计一个新的未来主义微服务系统来替代PSS应用程序
- en: Reviewing the microservices capability model
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查微服务能力模型
- en: 'The examples in this chapter explore the following microservices capabilities
    from the microservices capability model discussed in [Chapter 3](ch03.html "Chapter 3. Applying
    Microservices Concepts"), *Applying Microservices Concepts*:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例探讨了[第3章](ch03.html "第3章。应用微服务概念")中讨论的微服务能力模型中的以下微服务能力：
- en: '**HTTP Listener**'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP监听器**'
- en: '**Message Listener**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息监听器**'
- en: '**Storage Capabilities (Physical/In-Memory)**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储能力（物理/内存）**'
- en: '**Business Capability Definitions**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务能力定义**'
- en: '**Service Endpoints & Communication Protocols**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务端点和通信协议**'
- en: '**User Interfaces**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面**'
- en: '**Security Service**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全服务**'
- en: '**Microservice Documentation**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务文档**'
- en: '![Reviewing the microservices capability model](img/B05447_04_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![审查微服务能力模型](img/B05447_04_01.jpg)'
- en: In [Chapter 2](ch02.html "Chapter 2. Building Microservices with Spring Boot"),
    *Building Microservices with Spring Boot*, we explored all these capabilities
    in isolation including how to secure Spring Boot microservices. This chapter will
    build a comprehensive microservices example based on a real world case study.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。使用Spring Boot构建微服务")中，*使用Spring Boot构建微服务*，我们独立探讨了所有这些能力，包括如何保护Spring
    Boot微服务。本章将基于一个真实案例构建一个全面的微服务示例。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The full source code of this chapter is available under the `Chapter 4` projects
    in the code files.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可在代码文件的`第4章`项目中找到。
- en: Understanding the PSS application
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解PSS应用
- en: BrownField Airline is one of the fastest growing low-cost, regional airlines,
    flying directly to more than 100 destinations from its hub. As a start-up airline,
    BrownField Airline started its operations with few destinations and few aircrafts.
    BrownField developed its home-grown PSS application to handle their passenger
    sales and services.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: BrownField航空公司是增长最快的低成本地区航空公司之一，从其枢纽直飞100多个目的地。作为一家初创航空公司，BrownField航空公司从少数目的地和少量飞机开始运营。BrownField开发了自己的PSS应用来处理他们的乘客销售和服务。
- en: Business process view
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务流程视图
- en: 'This use case is considerably simplified for discussion purposes. The process
    view in the following diagram shows BrownField Airline''s end-to-end passenger
    services operations covered by the current PSS solution:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用例为了讨论目的而大大简化了。以下图表中的流程视图显示了BrownField航空公司当前PSS解决方案涵盖的端到端乘客服务操作：
- en: '![Business process view](img/B05447_04_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![业务流程视图](img/B05447_04_02.jpg)'
- en: The current solution is automating certain customer-facing functions as well
    as certain internally facing functions. There are two internally facing functions,
    **Pre-flight** and **Post-flight**. **Pre-flight** functions include the planning
    phase, used for preparing flight schedules, plans, aircrafts, and so on. **Post-flight**
    functions are used by the back office for revenue management, accounting, and
    so on. The **Search** and **Reserve** functions are part of the online seat reservation
    process, and the **Check-in** function is the process of accepting passengers
    at the airport. The **Check-in** function is also accessible to the end users
    over the Internet for online check-in.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当前解决方案正在自动化某些面向客户的功能以及某些面向内部的功能。有两个面向内部的功能，**Pre-flight**和**Post-flight**。**Pre-flight**功能包括规划阶段，用于准备飞行计划、计划、飞机等。**Post-flight**功能由后勤部门用于收入管理、会计等。**搜索**和**预订**功能是在线座位预订流程的一部分，**办理登机手续**是在机场接受乘客的过程。**办理登机手续**也可以通过互联网向最终用户提供在线办理登机手续。
- en: The cross marks at the beginning of the arrows in the preceding diagram indicate
    that they are disconnected, and occur at different timelines. For example, passengers
    are allowed to book 360 days in advance, whereas the check-in generally happens
    24 hours before flight departure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，箭头开头的交叉标记表示它们是断开的，并且发生在不同的时间轴上。例如，乘客可以提前360天预订，而办理登机手续通常发生在飞机起飞前24小时。
- en: Functional view
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能视图
- en: 'The following diagram shows the functional building blocks of BrownField Airline''s
    PSS landscape. Each business process and its related subfunctions are represented
    in a row:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了BrownField航空公司PSS景观的功能构建块。每个业务流程及其相关的子功能都在一行中表示：
- en: '![Functional view](img/B05447_04_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![功能视图](img/B05447_04_03.jpg)'
- en: Each subfunction shown in the preceding diagram explains its role in the overall
    business process. Some subfunctions participate in more than one business process.
    For example, inventory is used in both search as well as in booking. To avoid
    any complication, this is not shown in the diagram. Data management and cross-cutting
    subfunctions are used across many business functions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图表中显示的每个子功能都解释了它在整个业务流程中的作用。一些子功能参与了多个业务流程。例如，库存在搜索和预订中都有使用。为了避免任何复杂情况，这在图表中没有显示。数据管理和交叉子功能在许多业务功能中使用。
- en: Architectural view
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构视图
- en: In order to effectively manage the end-to-end passenger operations, BrownField
    had developed an in-house PSS application, almost ten years back. This well-architected
    application was developed using Java and JEE technologies combined with the best-of-the-breed
    open source technologies available at the time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效管理端到端的乘客操作，BrownField在近十年前开发了一款内部PSS应用程序。这款良好架构的应用程序是使用Java和JEE技术结合当时最先进的开源技术开发的。
- en: 'The overall architecture and technologies are shown in the following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 整体架构和技术如下图所示：
- en: '![Architectural view](img/B05447_04_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![架构视图](img/B05447_04_04.jpg)'
- en: The architecture has well-defined boundaries. Also, different concerns are separated
    into different layers. The web application was developed as an *N*-tier, component-based
    modular system. The functions interact with each other through well-defined service
    contracts defined in the form of EJB endpoints.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 架构有明确定义的边界。此外，不同的关注点被分隔到不同的层中。Web应用程序被开发为*N*层、基于组件的模块化系统。功能通过以EJB端点形式定义的明确定义的服务契约相互交互。
- en: Design view
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计视图
- en: 'The application has many logical functional groupings or subsystems. Further,
    each subsystem has many components organized as depicted in the next diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有许多逻辑功能分组或子系统。此外，每个子系统都有许多组件，组织如下图所示：
- en: '![Design view](img/B05447_04_05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![设计视图](img/B05447_04_05.jpg)'
- en: Subsystems interact with each other through remote EJB calls using the IIOP
    protocol. The transactional boundaries span across subsystems. Components within
    the subsystems communicate with each other through local EJB component interfaces.
    In theory, since subsystems use remote EJB endpoints, they could run on different
    physically separated application servers. This was one of the design goals.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 子系统通过使用IIOP协议进行远程EJB调用相互交互。事务边界跨越子系统。子系统内的组件通过本地EJB组件接口相互通信。理论上，由于子系统使用远程EJB端点，它们可以在不同的物理分离的应用服务器上运行。这是设计目标之一。
- en: Implementation view
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施视图
- en: 'The implementation view in the following diagram showcases the internal organization
    of a subsystem and its components. The purpose of the diagram is also to show
    the different types of artifacts:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表中的实施视图展示了子系统及其组件的内部组织。图表的目的也是展示不同类型的构件：
- en: '![Implementation view](img/B05447_04_06.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![实施视图](img/B05447_04_06.jpg)'
- en: In the preceding diagram, the gray-shaded boxes are treated as different Maven
    projects, and translate into physical artifacts. Subsystems and components are
    designed adhering to the *program to an interface* principle. Interfaces are packaged
    as separate JAR files so that clients are abstracted from the implementations.
    The complexity of the business logic is buried in the domain model. Local EJBs
    are used as component interfaces. Finally, all subsystems are packaged into a
    single all-in-one EAR, and deployed in the application server.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，灰色阴影框被视为不同的Maven项目，并转化为物理构件。子系统和组件都遵循“按接口编程”的原则进行设计。接口被打包为单独的JAR文件，以便客户端与实现分离。业务逻辑的复杂性被隐藏在领域模型中。本地EJB被用作组件接口。最后，所有子系统被打包到一个单一的EAR中，并部署在应用服务器中。
- en: Deployment view
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署视图
- en: 'The application''s initial deployment was simple and straightforward as shown
    in the next diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的初始部署如下图所示，简单而直接：
- en: '![Deployment view](img/B05447_04_07.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![部署视图](img/B05447_04_07.jpg)'
- en: The web modules and business modules were deployed into separate application
    server clusters. The application was scaled horizontally by adding more and more
    application servers to the cluster.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Web模块和业务模块被部署到单独的应用服务器集群中。通过向集群添加更多应用服务器来实现水平扩展应用程序。
- en: Zero downtime deployments were handled by creating a standby cluster, and gracefully
    diverting the traffic to that cluster. The standby cluster is destroyed once the
    primary cluster is patched with the new version and brought back to service. Most
    of the database changes were designed for backward compatibility, but breaking
    changes were promoted with application outages.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 零停机部署通过创建一个备用集群，并优雅地将流量转移到该集群来处理。一旦主集群被打补丁升级到新版本并重新投入使用，备用集群就会被销毁。大多数数据库更改都设计为向后兼容，但破坏性更改会导致应用程序中断。
- en: Death of the monolith
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 巨石的消亡
- en: The PSS application was performing well, successfully supporting all business
    requirements as well as the expected service levels. The system had no issues
    in scaling with the organic growth of the business in the initial years.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: PSS应用程序表现良好，成功支持所有业务需求以及预期的服务水平。在最初的几年里，系统在业务的有机增长中没有任何问题。
- en: The business has seen tremendous growth over a period of time. The fleet size
    increased significantly, and new destinations got added to the network. As a result
    of this rapid growth, the number of bookings has gone up, resulting in a steep
    increase in transaction volumes, up to 200 - to 500 - fold of what was originally
    estimated.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 业务在一段时间内实现了巨大的增长。车队规模显著增加，新目的地被添加到网络中。由于这种快速增长，预订数量增加，导致交易量急剧增加，达到最初估计的200到500倍。
- en: Pain points
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 痛点
- en: The rapid growth of the business eventually put the application under pressure.
    Odd stability issues and performance issues surfaced. New application releases
    started breaking the working code. Moreover, the cost of change and the speed
    of delivery started impacting the business operations profoundly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 业务的快速增长最终使应用程序承受了压力。出现了奇怪的稳定性问题和性能问题。新的应用程序发布开始破坏工作代码。此外，变更的成本和交付速度开始深刻影响业务运营。
- en: 'An end-to-end architecture review was ordered, and it exposed the weaknesses
    of the system as well as the root causes of many failures, which were as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 进行了端到端架构审查，并暴露了系统的弱点以及许多故障的根本原因，如下所示：
- en: '**Stability**: The stability issues are primarily due to stuck threads, which
    limit the application server''s capability to accept more transactions. The stuck
    threads are mainly due to database table locks. Memory issues are another contributor
    to the stability issues. There were also issues in certain resource intensive
    operations that were impacting the whole application.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定性**：稳定性问题主要是由于线程阻塞，限制了应用服务器接受更多交易的能力。线程阻塞主要是由于数据库表锁。内存问题也是稳定性问题的另一个原因。还存在一些资源密集型操作的问题，这些问题影响了整个应用程序。'
- en: '**Outages**: The outage window increased largely because of the increase in
    server startup time. The root cause of this issue boiled down to the large size
    of the EAR. Message pile up during any outage windows causes heavy usage of the
    application immediately after an outage window. Since everything is packaged in
    a single EAR, any small application code change resulted in full redeployment.
    The complexity of the zero downtime deployment model described earlier, together
    with the server startup times increased both the number of outages and their duration.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障**：故障窗口的增加主要是由于服务器启动时间的增加。这个问题的根本原因归结为EAR的体积过大。在任何故障窗口期间，消息堆积导致故障窗口后立即对应用的大量使用。由于一切都打包在一个单独的EAR中，任何小的应用代码更改都会导致完全重新部署。之前描述的零停机部署模型的复杂性，以及服务器启动时间的增加，都增加了故障的数量和持续时间。'
- en: '**Agility**: The complexity of the code also increased considerably over time,
    partially due to the lack of discipline in implementing the changes. As a result,
    changes became harder to implement. Also, the impact analysis became too complex
    to perform. As a result, inaccurate impact analysis often led to fixes that broke
    the working code. The application build time went up severely, from a few minutes
    to hours, causing unacceptable drops in development productivity. The increase
    in build time also led to difficulty in build automation, and eventually stopped
    **continuous integration** (**CI**) and unit testing.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敏捷性**：随着时间的推移，代码的复杂性也大大增加，部分原因是在实施变更时缺乏纪律。因此，变更变得更难实施。此外，影响分析变得过于复杂。因此，不准确的影响分析经常导致修复破坏了工作代码。应用构建时间大大增加，从几分钟到几个小时，导致开发生产率不可接受的下降。构建时间的增加还导致构建自动化困难，并最终停止了**持续集成**（**CI**）和单元测试。'
- en: Stop gap fix
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时修复
- en: 'Performance issues were partially addressed by applying the Y-axis scale method
    in the scale cube, as described in [Chapter 1](ch01.html "Chapter 1. Demystifying
    Microservices"), *Demystifying Microservices*. The all-encompassing EAR is deployed
    into multiple disjoint clusters. A software proxy was installed to selectively
    route the traffic to designated clusters as shown in the following diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题部分通过在规模立方体中应用Y轴扩展方法来解决，如[第1章](ch01.html "第1章。解密微服务") *解密微服务*中所述。全面的EAR部署到多个不相交的集群中。安装了软件代理，以选择性地将流量路由到指定的集群，如下图所示：
- en: '![Stop gap fix](img/B05447_04_08.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![临时修复](img/B05447_04_08.jpg)'
- en: This helped BrownField's IT to scale the application servers. Therefore, the
    stability issues were controlled. However, this soon resulted in a bottleneck
    at the database level. Oracle's **Real Application Cluster** (**RAC**) was implemented
    as a solution to this problem at the database layer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于BrownField的IT扩展应用服务器。因此，稳定性问题得到了控制。然而，这很快在数据库层面导致了瓶颈。Oracle的**Real Application
    Cluster**（**RAC**）被实施为解决这个问题的解决方案。
- en: This new scaling model reduced the stability issues, but at a premium of increased
    complexity and cost of ownership. The technology debt also increased over a period
    of time, leading to a state where a complete rewrite was the only option for reducing
    this technology debt.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的扩展模型减少了稳定性问题，但以增加的复杂性和所有权成本为代价。技术债务也随着时间的推移而增加，导致了一种状态，即完全重写是减少这种技术债务的唯一选择。
- en: Retrospection
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾
- en: Although the application was well-architected, there was a clear segregation
    between the functional components. They were loosely coupled, programmed to interfaces,
    with access through standards-based interfaces, and had a rich domain model.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应用程序架构良好，但功能组件之间存在明显的分离。它们松散耦合，通过标准化接口编程，并且具有丰富的领域模型。
- en: The obvious question is, how come such a well-architected application failed
    to live up to the expectations? What else could the architects have done?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的问题是，为什么这样一个设计良好的应用程序未能达到预期？架构师还能做些什么？
- en: It is important to understand what went wrong over a period of time. In the
    context of this book, it is also important to understand how microservices can
    avoid the recurrence of these scenarios. We will examine some of these scenarios
    in the subsequent sections.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要了解随着时间的推移出现了什么问题。在本书的背景下，了解微服务如何避免这些情况再次发生也很重要。我们将在接下来的章节中研究其中一些情况。
- en: Shared data
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享数据
- en: Almost all functional modules require reference data such as the airline's details,
    airplane details, a list of airports and cities, countries, currencies, and so
    on. For example, fare is calculated based on the point of origin (city), a flight
    is between an origin and a destination (airports), check-in is at the origin airport
    (airport), and so on. In some functions, the reference data is a part of the information
    model, whereas in some other functions, it is used for validation purposes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有功能模块都需要参考数据，例如航空公司的详细信息，飞机的详细信息，机场和城市的列表，国家，货币等等。例如，票价是根据出发地（城市）计算的，航班是在出发地和目的地（机场）之间的，办理登机手续是在出发机场（机场）进行的，等等。在某些功能中，参考数据是信息模型的一部分，而在另一些功能中，它用于验证目的。
- en: Much of this reference data is neither fully static nor fully dynamic. Addition
    of a country, city, airport, or the like could happen when the airline introduces
    new routes. Aircraft reference data could change when the airline purchases a
    new aircraft, or changes an existing airplane's seat configuration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参考数据大部分既不是完全静态的，也不是完全动态的。当航空公司开通新航线时，可能会增加一个国家、城市、机场等。当航空公司购买新飞机或更改现有飞机的座位配置时，飞机参考数据可能会发生变化。
- en: 'One of the common usage scenarios of reference data is to filter the operational
    data based on certain reference data. For instance, say a user wishes to see all
    the flights to a country. In this case, the flow of events could be as follows:
    find all the cities in the selected country, then all airports in the cities,
    and then fire a request to get all the flights to the list of resulting airports
    identified in that country.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 参考数据的常见用法之一是根据某些参考数据过滤操作数据。例如，假设用户希望查看所有飞往某个国家的航班。在这种情况下，事件的流程可能如下：找到所选国家的所有城市，然后找到所有城市的机场，然后发送请求以获取所有飞往该国家中所识别的机场的航班列表。
- en: The architects considered multiple approaches when designing the system. Separating
    the reference data as an independent subsystem like other subsystems was one of
    the options considered, but this could lead to performance issues. The team took
    the decision to follow an exception approach for handling reference data as compared
    to other transactions. Considering the nature of the query patterns discussed
    earlier, the approach was to use the reference data as a shared library.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计系统时，架构师考虑了多种方法。将参考数据作为独立子系统分离是考虑的选项之一，但这可能会导致性能问题。团队决定采用异常处理的方法来处理参考数据，与其他事务相比。考虑到前面讨论的查询模式的性质，该方法是将参考数据用作共享库。
- en: 'In this case, the subsystems were allowed to access the reference data directly
    using pass-by-reference semantic data instead of going through the EJB interfaces.
    This also meant that irrespective of the subsystems, hibernate entities could
    use the reference data as a part of their entity relationships:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，允许子系统直接访问参考数据，而不是通过EJB接口。这也意味着无论子系统如何，Hibernate实体都可以将参考数据用作它们实体关系的一部分。
- en: '![Shared data](img/B05447_04_09.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![共享数据](img/B05447_04_09.jpg)'
- en: As depicted in the preceding diagram, the **Booking** entity in the reservation
    subsystem is allowed to use the reference data entities, in this case **Airport**,
    as part of their relationships.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，预订子系统中的**Booking**实体被允许使用参考数据实体，例如**Airport**，作为它们的关系的一部分。
- en: Single database
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单一数据库
- en: Though enough segregation was enforced at the middle tier, all functions pointed
    to a single database, even to the same database schema. The single schema approach
    opened a plethora of issues.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在中间层强制执行了足够的分离，但所有功能都指向单一数据库，甚至是相同的数据库架构。单一架构方法带来了一系列问题。
- en: Native queries
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 本地查询
- en: The Hibernate framework provides a good abstraction over the underlying databases.
    It generates efficient SQL statements, in most of the cases targeting the database
    using specific dialects. However, sometimes, writing native JDBC SQLs offers better
    performance and resource efficiency. In some cases, using native database functions
    gives an even better performance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate框架提供了对底层数据库的良好抽象。它生成高效的SQL语句，在大多数情况下使用特定的方言针对数据库。然而，有时编写本地JDBC SQL可以提供更好的性能和资源效率。在某些情况下，使用本地数据库函数可以获得更好的性能。
- en: The single database approach worked well at the beginning. But over a period
    of time, it opened up a loophole for the developers by connecting database tables
    owned by different subsystems. Native JDBC SQL was a good vehicle for doing this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 单一数据库方法在开始时效果很好。但随着时间的推移，它为开发人员打开了一个漏洞，通过连接不同子系统拥有的数据库表。本地JDBC SQL是执行这一操作的良好工具。
- en: 'The following diagram shows an example of connecting two tables owned by two
    subsystems using a native JDBC SQL:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了使用本地JDBC SQL连接两个子系统拥有的两个表的示例：
- en: '![Native queries](img/B05447_04_10.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![本地查询](img/B05447_04_10.jpg)'
- en: As shown in the preceding diagram, the Accounting component requires all booking
    records for a day, for a given city, from the Booking component to process the
    day-end billing. The subsystem-based design enforces Accounting to make a service
    call to Booking to get all booking records for a given city. Assume this results
    in *N* booking records. Now, for each booking record, Accounting has to execute
    a database call to find the applicable rules based on the fare code attached to
    each booking record. This could result in *N+1* JDBC calls, which is inefficient.
    Workarounds, such as batch queries or parallel and batch executions, are available,
    but this would lead to increased coding efforts and higher complexity. The developers
    tackled this issue with a native JDBC query as an easy-to-implement shortcut.
    Essentially, this approach could reduce the number of calls from *N+1* to a single
    database call, with minimal coding efforts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，会计组件需要从预订组件获取给定城市当天的所有预订记录，以便进行日终结算。基于子系统的设计要求会计组件向预订组件发起服务调用，以获取给定城市的所有预订记录。假设这会导致*N*条预订记录。现在，对于每条预订记录，会计组件必须执行数据库调用，以查找与每条预订记录附加的票价代码相关的适用规则。这可能导致*N+1*个JDBC调用，效率低下。虽然可以使用批量查询或并行和批量执行等解决方法，但这将导致增加编码工作量和增加复杂性。开发人员通过本地JDBC查询来解决这个问题，作为一种易于实现的快捷方式。基本上，这种方法可以将调用次数从*N+1*减少到单个数据库调用，编码工作量最小。
- en: This habit continued with many JDBC native queries connecting tables across
    multiple components and subsystems. This resulted not only in tightly coupled
    components, but also led to undocumented, hard-to-detect code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种习惯继续下去，许多JDBC本地查询连接跨多个组件和子系统的表。这不仅导致组件之间耦合度高，还导致代码难以发现和难以检测。
- en: Stored procedures
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存储过程
- en: Another issue that surfaced as a result of the use of a single database was
    the use of complex stored procedures. Some of the complex data-centric logic written
    at the middle layer was not performing well, causing slow response, memory issues,
    and thread-blocking issues.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用单个数据库而出现的另一个问题是复杂存储过程的使用。一些在中间层编写的复杂数据中心逻辑性能不佳，导致响应缓慢、内存问题和线程阻塞问题。
- en: In order to address this problem, the developers took the decision to move some
    of the complex business logic from the middle tier to the database tier by implementing
    the logic directly within the stored procedures. This decision resulted in better
    performance of some of the transactions, and removed some of the stability issues.
    More and more procedures were added over a period of time. However, this eventually
    broke the application's modularity.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，开发人员决定将一些复杂的业务逻辑从中间层移动到数据库层，通过在存储过程中直接实现逻辑。这个决定改善了一些交易的性能，并消除了一些稳定性问题。随着时间的推移，越来越多的存储过程被添加。然而，这最终破坏了应用程序的模块化。
- en: Domain boundaries
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 领域边界
- en: Though the domain boundaries were well established, all the components were
    packaged as a single EAR file. Since all the components were set to run on a single
    container, there was no stopping the developers referencing objects across these
    boundaries. Over a period of time, the project teams changed, delivery pressure
    increased, and the complexity grew tremendously. The developers started looking
    for quick solutions rather than the right ones. Slowly, but steadily, the modular
    nature of the application went away.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管领域边界已经建立，但所有组件都打包在一个单独的EAR文件中。由于所有组件都设置在单个容器上运行，开发人员可以自由引用这些边界之间的对象。随着时间的推移，项目团队发生了变化，交付压力增加，复杂性大大增加。开发人员开始寻找快速解决方案，而不是正确的解决方案。应用程序的模块化特性逐渐消失。
- en: 'As depicted in the following diagram, hibernate relationships were created
    across subsystem boundaries:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，跨子系统边界创建了Hibernate关系：
- en: '![Domain boundaries](img/B05447_04_11.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![领域边界](img/B05447_04_11.jpg)'
- en: Microservices to the rescue
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务解救
- en: There are not many improvement opportunities left to support the growing demand
    of BrownField Airline's business. BrownField Airline was looking to re-platform
    the system with an evolutionary approach rather than a revolutionary model.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: BrownField航空公司没有太多的改进机会来支持不断增长的业务需求。BrownField航空公司希望以渐进式方法而不是革命性模式重新平台化系统。
- en: 'Microservices is an ideal choice in these situations—for transforming a legacy
    monolithic application with minimal disruption to the business:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，微服务是一种理想选择，可以在最小干扰业务的情况下转换传统的单块应用：
- en: '![Microservices to the rescue](img/B05447_04_12.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![微服务解救](img/B05447_04_12.jpg)'
- en: As shown in the preceding diagram, the objective is to move to a microservices-based
    architecture aligned to the business capabilities. Each microservice will hold
    the data store, the business logic, and the presentation layer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，目标是转向基于微服务的架构，与业务能力对齐。每个微服务将包含数据存储、业务逻辑和表示层。
- en: The approach taken by BrownField Airline is to build a number of web portal
    applications targeting specific user communities such as customer facing, front
    office, and back office. The advantage of this approach lies in the flexibility
    for modeling, and also in the possibility to treat different communities differently.
    For example, the policies, architecture, and testing approaches for the Internet
    facing layer are different from the intranet-facing web application. Internet-facing
    applications may take advantage of **CDNs** (**Content Delivery Networks**) to
    move pages as close to the customer as possible, whereas intranet applications
    could serve pages directly from the data center.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: BrownField航空公司采取的方法是构建多个面向特定用户群体的Web门户应用程序，如面向客户、前台和后台。这种方法的优势在于对建模的灵活性，以及对不同社区进行不同对待的可能性。例如，面向互联网的层的政策、架构和测试方法与面向内部网的Web应用程序不同。面向互联网的应用程序可以利用CDN（内容传送网络）尽可能地将页面靠近客户端，而内部网应用程序可以直接从数据中心提供页面。
- en: The business case
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务案例
- en: When building business cases for migration, one of the commonly asked questions
    is "how does the microservices architecture avoid resurfacing of the same issues
    in another five years' time?"
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在为迁移建立业务案例时，一个常见的问题是“微服务架构如何避免在另外五年内重新出现相同的问题？”
- en: 'Microservices offers a full list of benefits, which you learned in [Chapter
    1](ch01.html "Chapter 1. Demystifying Microservices"), *Demystifying Microservices*,
    but it is important to list a few here that are critical in this situation:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务提供了一系列的好处，你在[第1章](ch01.html "第1章。解密微服务")中学到了，但在这种情况下，重要的是列出其中一些关键的好处：
- en: '**Service dependencies**: While migrating from monolithic applications to microservices,
    the dependencies are better known, and therefore the architects and developers
    are much better placed to avoid breaking dependencies and to future-proof dependency
    issues. Lessons from the monolithic application helps architects and developers
    to design a better system.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务依赖**：在从单片应用程序迁移到微服务时，依赖关系更为明确，因此架构师和开发人员更有能力避免破坏依赖关系，并未来保护依赖关系问题。来自单片应用程序的经验帮助架构师和开发人员设计一个更好的系统。'
- en: '**Physical boundaries**: Microservices enforce physical boundaries in all areas
    including the data store, the business logic, and the presentation layer. Access
    across subsystems or microservices are truly restricted due to their physical
    isolation. Beyond the physical boundaries, they could even run on different technologies.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理边界**：微服务在所有领域都强制实施物理边界，包括数据存储、业务逻辑和表示层。由于它们的物理隔离，跨子系统或微服务的访问是真正受限制的。除了物理边界，它们甚至可以在不同的技术上运行。'
- en: '**Selective scaling**: Selective scale out is possible in microservices architecture.
    This provides a much more cost-effective scaling mechanism compared to the Y-scale
    approach used in the monolithic scenario.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择性扩展**：在微服务架构中，可以进行选择性的扩展。与单片场景中使用的Y-比例方法相比，这提供了一种更具成本效益的扩展机制。'
- en: '**Technology obsolescence**: Technology migrations could be applied at a microservices
    level rather than at the overall application level. Therefore, it does not require
    a humongous investment.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术过时**：技术迁移可以应用于微服务级别，而不是整体应用级别。因此，它不需要巨额投资。'
- en: Plan the evolution
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划演变
- en: It is not simple to break an application that has millions of lines of code,
    especially if the code has complex dependencies. How do we break it? More importantly,
    where do we start, and how do we approach this problem?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要打破拥有数百万行代码的应用程序并不简单，特别是如果代码具有复杂的依赖关系。我们如何打破它？更重要的是，我们从哪里开始，以及如何解决这个问题？
- en: Evolutionary approach
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进化方法
- en: 'The best way to address this problem is to establish a transition plan, and
    gradually migrate the functions as microservices. At every step, a microservice
    will be created outside of the monolithic application, and traffic will be diverted
    to the new service as shown in the following diagram:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最佳方法是建立一个过渡计划，并逐渐将功能迁移到微服务。在每一步，都会在单片应用程序之外创建一个微服务，并将流量转移到新服务，如下图所示：
- en: '![Evolutionary approach](img/B05447_04_13.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![进化方法](img/B05447_04_13.jpg)'
- en: 'In order to run this migration successfully, a number of key questions need
    to be answered from the transition point of view:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功地运行这次迁移，需要从过渡的角度回答一些关键问题：
- en: Identification of microservices' boundaries
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别微服务的边界
- en: Prioritizing microservices for migration
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为迁移优先考虑微服务
- en: Handling data synchronization during the transition phase
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过渡阶段处理数据同步
- en: Handling user interface integration, working with old and new user interfaces
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户界面集成，与旧用户界面和新用户界面一起工作
- en: Handling of reference data in the new system
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新系统中处理参考数据
- en: Testing strategy to ensure the business capabilities are intact and correctly
    reproduced
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试策略以确保业务能力完整且正确重现
- en: Identification of any prerequisites for microservice development such as microservices
    capabilities, frameworks, processes, and so on
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务开发的任何先决条件的识别，如微服务能力、框架、流程等
- en: Identification of microservices boundaries
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别微服务边界
- en: The first and foremost activity is to identify the microservices' boundaries.
    This is the most interesting part of the problem, and the most difficult part
    as well. If identification of the boundaries is not done properly, the migration
    could lead to more complex manageability issues.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首要的活动是识别微服务的边界。这是问题中最有趣的部分，也是最困难的部分。如果边界的识别不正确，迁移可能会导致更复杂的可管理性问题。
- en: Like in SOA, a service decomposition is the best way to identify services. However,
    it is important to note that decomposition stops at a business capability or bounded
    context. In SOA, service decomposition goes further into an atomic, granular service
    level.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在SOA中一样，服务分解是识别服务的最佳方式。然而，需要注意的是，分解停止于业务能力或有界上下文。在SOA中，服务分解进一步到原子、细粒度的服务级别。
- en: A top-down approach is typically used for domain decomposition. The bottom-up
    approach is also useful in the case of breaking an existing system, as it can
    utilize a lot of practical knowledge, functions, and behaviors of the existing
    monolithic application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部向下的方法通常用于域分解。在打破现有系统的情况下，自下而上的方法也很有用，因为它可以利用现有单片应用程序的许多实际知识、功能和行为。
- en: The previous decomposition step will give a potential list of microservices.
    It is important to note that this isn't the final list of microservices, but it
    serves as a good starting point. We will run through a number of filtering mechanisms
    to get to a final list. The first cut of functional decomposition will, in this
    case, be similar to the diagram shown under the functional view introduced earlier
    in this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的分解步骤将给出潜在的微服务列表。重要的是要注意，这不是最终的微服务列表，但它作为一个很好的起点。我们将通过一些过滤机制来得到最终的列表。在这种情况下，功能分解的第一步将类似于本章前面介绍的功能视图下显示的图表。
- en: Analyze dependencies
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析依赖关系
- en: The next step is to analyze the dependencies between the initial set of candidate
    microservices that we created in the previous section. At the end of this activity,
    a dependency graph will be produced.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是分析我们在上一节中创建的候选微服务之间的依赖关系。在这项活动结束时，将生成一个依赖图。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A team of architects, business analysts, developers, release management and
    support staff is required for this exercise.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作需要一个由架构师、业务分析师、开发人员、发布管理和支持人员组成的团队。
- en: 'One way to produce a dependency graph is to list out all the components of
    the legacy system and overlay dependencies. This could be done by combining one
    or more of the approaches listed as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 生成依赖图的一种方法是列出遗留系统的所有组件并叠加依赖关系。这可以通过结合以下一种或多种方法来完成：
- en: Analyzing the manual code and regenerating dependencies.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析手动代码并重新生成依赖关系。
- en: Using the experience of the development team to regenerate dependencies.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用开发团队的经验重新生成依赖关系。
- en: Using a Maven dependency graph. There are a number of tools we could use to
    regenerate the dependency graph, such as PomExplorer, PomParser, and so on.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven依赖图。我们可以使用一些工具来重新生成依赖图，如PomExplorer、PomParser等。
- en: Using performance engineering tools such as AppDynamics to identify the call
    stack and roll up dependencies.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用性能工程工具，如AppDynamics来识别调用堆栈和依赖关系。
- en: 'Let us assume that we reproduce the functions and their dependencies as shown
    in the following diagram:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们按照以下图表中显示的函数及其依赖关系进行复制：
- en: '![Analyze dependencies](img/B05447_04_14.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![分析依赖关系](img/B05447_04_14.jpg)'
- en: There are many dependencies going back and forth between different modules.
    The bottom layer shows cross-cutting capabilities that are used across multiple
    modules. At this point, the modules are more like spaghetti than autonomous units.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不同模块之间存在许多来回的依赖关系。底层显示了跨模块使用的横切能力。在这一点上，模块更像是意大利面而不是自主单元。
- en: The next step is to analyze these dependencies, and come up with a better, simplified
    dependency map.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是分析这些依赖关系，并提出一个更好、更简化的依赖映射。
- en: Events as opposed to query
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事件与查询相对
- en: Dependencies could be query-based or event-based. Event-based is better for
    scalable systems. Sometimes, it is possible to convert query-based communications
    to event-based ones. In many cases, these dependencies exist because either the
    business organizations are managed like that, or by virtue of the way the old
    system handled the business scenario.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系可以是基于查询或基于事件的。基于事件的对可扩展系统更好。有时，可以将基于查询的通信转换为基于事件的通信。在许多情况下，这些依赖关系存在是因为业务组织是这样管理的，或者是由于旧系统处理业务情景的方式。
- en: 'From the previous diagram, we can extract the Revenue Management and the Fares
    services:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的图表中，我们可以提取出收入管理和票价服务：
- en: '![Events as opposed to query](img/B05447_04_15.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![事件与查询相对](img/B05447_04_15.jpg)'
- en: Revenue Management is a module used for calculating optimal fare values, based
    on the booking demand forecast. In case of a fare change between an origin and
    a destination, Update Fare on the Fare module is called by Revenue Management
    to update the respective fares in the Fare module.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 收入管理是一个用于根据预订需求预测计算最佳票价数值的模块。如果起始地和目的地之间的票价发生变化，收入管理将调用票价模块上的更新票价来更新票价模块中的相应票价。
- en: An alternate way of thinking is that the Fare module is subscribed to Revenue
    Management for any changes in fares, and Revenue Management publishes whenever
    there is a fare change. This reactive programming approach gives an added flexibility
    by which the Fares and the Revenue Management modules could stay independent,
    and connect them through a reliable messaging system. This same pattern could
    be applied in many other scenarios from Check-In to the Loyalty and Boarding modules.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考方式是，票价模块订阅了收入管理以获取票价变化，而收入管理在票价变化时发布。这种反应式编程方法通过这种方式给予了额外的灵活性，使得票价和收入管理模块可以保持独立，并通过可靠的消息传递系统进行连接。这种模式也可以应用于从办理登机到忠诚度和登机模块等许多其他情景。
- en: 'Next, examine the scenario of CRM and Booking:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检查CRM和Booking的情景：
- en: '![Events as opposed to query](img/B05447_04_16.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![事件与查询相对](img/B05447_04_16.jpg)'
- en: 'This scenario is slightly different from the previously explained scenario.
    The CRM module is used to manage passenger complaints. When CRM receives a complaint,
    it retrieves the corresponding passenger''s Booking data. In reality, the number
    of complaints are negligibly small when compared to the number of bookings. If
    we blindly apply the previous pattern where CRM subscribes to all bookings, we
    will find that it is not cost effective:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情景与先前解释的情景略有不同。CRM模块用于管理乘客投诉。当CRM收到投诉时，它会检索相应乘客的预订数据。实际上，投诉数量与预订数量相比可以忽略不计。如果我们盲目地应用先前的模式，即CRM订阅所有预订，我们会发现这是不划算的：
- en: '![Events as opposed to query](img/B05447_04_17.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![事件与查询相对](img/B05447_04_17.jpg)'
- en: Examine another scenario between the Check-in and Booking modules. Instead of
    Check-in calling the Get Bookings service on Booking, can Check-in listen to booking
    events? This is possible, but the challenge here is that a booking can happen
    360 days in advance, whereas Check-in generally starts only 24 hours before the
    fight departure. Duplicating all bookings and booking changes in the Check-in
    module 360 days in advance would not be a wise decision as Check-in does not require
    this data until 24 hours before the flight departure.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 检查预订和预订模块之间的另一个场景。办理登机是否可以监听预订事件，而不是调用预订模块上的获取预订服务？这是可能的，但这里的挑战是，预订可以提前360天发生，而办理登机通常只在飞行起飞前24小时开始。提前360天在办理登机模块中复制所有预订和预订更改将不是一个明智的决定，因为办理登机直到飞行起飞前24小时才需要这些数据。
- en: An alternate option is that when check-in opens for a flight (24 hours before
    departure), Check-in calls a service on the Booking module to get a snapshot of
    the bookings for a given flight. Once this is done, Check-in could subscribe for
    booking events specifically for that flight. In this case, a combination of query-based
    as well as event-based approaches is used. By doing so, we reduce the unnecessary
    events and storage apart from reducing the number of queries between these two
    services.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是，当航班开放办理登机手续时（起飞前24小时），办理登机会调用预订模块上的服务，以获取给定航班的预订快照。一旦完成，办理登机可以订阅该航班的预订事件。在这种情况下，使用了基于查询和基于事件的组合方法。通过这样做，除了减少这两个服务之间的查询次数外，还减少了不必要的事件和存储。
- en: In short, there is no single policy that rules all scenarios. Each scenario
    requires logical thinking, and then the most appropriate pattern is applied.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，并没有一种政策适用于所有情况。每种情况都需要逻辑思维，然后应用最合适的模式。
- en: Events as opposed to synchronous updates
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事件而不是同步更新
- en: 'Apart from the query model, a dependency could be an update transaction as
    well. Consider the scenario between Revenue Management and Booking:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查询模型，依赖关系也可以是更新事务。考虑收入管理和预订之间的情况：
- en: '![Events as opposed to synchronous updates](img/B05447_04_18.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![事件而不是同步更新](img/B05447_04_18.jpg)'
- en: In order to do a forecast and analysis of the current demand, Revenue Management
    requires all bookings across all flights. The current approach, as depicted in
    the dependency graph, is that Revenue Management has a schedule job that calls
    Get Booking on Booking to get all incremental bookings (new and changed) since
    the last synchronization.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对当前需求进行预测和分析，收入管理需要获取所有航班的所有预订。当前的方法如依赖图所示，收入管理有一个调用预订模块上的获取预订的定时作业，以获取自上次同步以来的所有增量预订（新预订和更改）。
- en: An alternative approach is to send new bookings and the changes in bookings
    as soon as they take place in the Booking module as an asynchronous push. The
    same pattern could be applied in many other scenarios such as from Booking to
    Accounting, from Flight to Inventory, and also from Flight to Booking. In this
    approach, the source service publishes all state-change events to a topic. All
    interested parties could subscribe to this event stream and store locally. This
    approach removes many hard wirings, and keeps the systems loosely coupled.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在预订模块中即时将新预订和预订更改作为异步推送发送。相同的模式可以应用于许多其他场景，例如从预订到会计，从航班到库存，以及从航班到预订。在这种方法中，源服务将所有状态更改事件发布到主题。所有感兴趣的方都可以订阅此事件流并在本地存储。这种方法消除了许多硬连接，并保持系统松散耦合。
- en: 'The dependency is depicted in the next diagram:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系在下一个图中描述：
- en: '![Events as opposed to synchronous updates](img/B05447_04_19.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![事件而不是同步更新](img/B05447_04_19.jpg)'
- en: In this case depicted in the preceding diagram, we changed both dependencies
    and converted them to asynchronous events.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中所示的情况下，我们改变了依赖关系，并将它们转换为异步事件。
- en: 'One last case to analyze is the Update Inventory call from the Booking module
    to the Inventory module:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要分析的情况是预订模块向库存模块的更新库存调用：
- en: '![Events as opposed to synchronous updates](img/B05447_04_20.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![事件而不是同步更新](img/B05447_04_20.jpg)'
- en: When a booking is completed, the inventory status is updated by depleting the
    inventory stored in the Inventory service. For example, when there are 10 economy
    class seats available, at the end of the booking, we have to reduce it to 9\.
    In the current system, booking and updating inventory are executed within the
    same transaction boundaries. This is to handle a scenario in which there is only
    one seat left, and multiple customers are trying to book. In the new design, if
    we apply the same event-driven pattern, sending the inventory update as an event
    to Inventory may leave the system in an inconsistent state. This needs further
    analysis, which we will address later in this chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当预订完成时，库存状态将通过减少存储在库存服务中的库存来更新。例如，当有10个经济舱座位可用时，在预订结束时，我们必须将其减少到9个。在当前系统中，预订和更新库存在同一事务边界内执行。这是为了处理只剩下一个座位的情况，而多个客户正在尝试预订。在新设计中，如果我们应用相同的事件驱动模式，将库存更新作为事件发送到库存可能会使系统处于不一致的状态。这需要进一步分析，我们将在本章后面解决这个问题。
- en: Challenge requirements
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战要求
- en: 'In many cases, the targeted state could be achieved by taking another look
    at the requirements:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，可以通过重新审视需求来实现目标状态：
- en: '![Challenge requirements](img/B05447_04_21.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![挑战要求](img/B05447_04_21.jpg)'
- en: 'There are two Validate Flight calls, one from Booking and another one from
    the Search module. The Validate Flight call is to validate the input flight data
    coming from different channels. The end objective is to avoid incorrect data stored
    or serviced. When a customer does a flight search, say "BF100", the system validates
    this flight to see the following things:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个验证航班的调用，一个来自预订，另一个来自搜索模块。验证航班的调用是为了验证来自不同渠道的输入航班数据。最终目标是避免存储或服务不正确的数据。当客户进行航班搜索时，比如说“BF100”，系统会验证这个航班以查看以下内容：
- en: Whether this is a valid flight?
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是否是一个有效的航班？
- en: Whether the flight exists on that particular date?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那天是否有这个特定日期的航班？
- en: Are there any booking restrictions set on this flight?
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这次航班有没有设置任何预订限制？
- en: An alternate way of solving this is to adjust the inventory of the flight based
    on these given conditions. For example, if there is a restriction on the flight,
    update the inventory as zero. In this case, the intelligence will remain with
    Flight, and it keeps updating the inventory. As far as Search and Booking are
    concerned, both just look up the inventory instead of validating flights for every
    request. This approach is more efficient as compared to the original approach.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方法是根据这些给定条件调整航班的库存。例如，如果航班有限制，更新库存为零。在这种情况下，智能将保留在航班中，并持续更新库存。就搜索和预订而言，两者只是查找库存，而不是为每个请求验证航班。与原始方法相比，这种方法更有效。
- en: Next we will review the Payment use case. Payment is typically a disconnected
    function due to the nature of security constraints such as PCIDSS-like standards.
    The most obvious way to capture a payment is to redirect a browser to a payment
    page hosted in the Payment service. Since card handling applications come under
    the purview of PCIDSS, it is wise to remove any direct dependencies from the Payment
    service. Therefore, we can remove the Booking-to-Payment direct dependency, and
    opt for a UI-level integration.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将审查支付用例。支付通常是一个独立的功能，因为安全约束的性质，如PCIDSS类似的标准。捕获支付的最明显方式是将浏览器重定向到支付服务中托管的支付页面。由于卡处理应用程序属于PCIDSS的范围，因此明智地删除支付服务的任何直接依赖关系。因此，我们可以删除预订到支付的直接依赖，并选择UI级别的集成。
- en: Challenge service boundaries
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战服务边界
- en: In this section, we will review some of the service boundaries based on the
    requirements and dependency graph, considering Check-in and its dependencies to
    Seating and Baggage.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将根据需求和依赖图，审查一些服务边界，考虑登记和其对座位和行李的依赖关系。
- en: The Seating function runs a few algorithms based on the current state of the
    seat allocation in the airplane, and finds out the best way to position the next
    passenger so that the weight and balance requirements can be met. This is based
    on a number of predefined business rules. However, other than Check-in, no other
    module is interested in the Seating function. From a business capability perspective,
    Seating is just a function of Check-in, not a business capability by itself. Therefore,
    it is better to embed this logic inside Check-in itself.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 座位功能基于飞机座位分配的当前状态运行一些算法，并找出最佳方式来安置下一个乘客，以满足重量和平衡要求。这是基于一些预定义的业务规则。然而，除了登记，没有其他模块对座位功能感兴趣。从业务能力的角度来看，座位只是登记的一个功能，而不是一个独立的业务能力。因此，最好将这个逻辑嵌入到登记本身。
- en: The same is applicable to Baggage as well. BrownField has a separate baggage
    handling system. The Baggage function in the PSS context is to print the baggage
    tag as well as store the baggage data against the Check-in records. There is no
    business capability associated with this particular functionality. Therefore,
    it is ideal to move this function to Check-in itself.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 行李也是一样的。BrownField有一个独立的行李处理系统。PSS上下文中的行李功能是打印行李标签以及将行李数据存储在登记记录中。这个特定功能没有与任何业务能力相关联。因此，最好将这个功能移动到登记本身。
- en: 'The Book, Search, and Inventory functions, after redesigning, are shown in
    the following diagram:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重新设计后，预订、搜索和库存功能如下图所示：
- en: '![Challenge service boundaries](img/B05447_04_22.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![挑战服务边界](img/B05447_04_22.jpg)'
- en: Similarly, Inventory and Search are more supporting functions of the Booking
    module. They are not aligned with any of the business capabilities as such. Similar
    to the previous judgement, it is ideal to move both the Search and Inventory functions
    to Booking. Assume, for the time being, that Search, Inventory, and Booking are
    moved to a single microservice named Reservation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，库存和搜索更多地是预订模块的支持功能。它们与任何业务能力都不对齐。与之前的判断类似，最好将搜索和库存功能移动到预订中。假设，暂时将搜索、库存和预订移动到一个名为预订的单一微服务中。
- en: As per the statistics of BrownField, search transactions are 10 times more frequent
    than the booking transactions. Moreover, search is not a revenue-generating transaction
    when compared to booking. Due to these reasons, we need different scalability
    models for search and booking. Booking should not get impacted if there is a sudden
    surge of transactions in search. From the business point of view, dropping a search
    transaction in favor of saving a valid booking transaction is more acceptable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 根据BrownField的统计数据，搜索交易的频率比预订交易高10倍。此外，与预订相比，搜索不是一项产生收入的交易。由于这些原因，我们需要为搜索和预订采用不同的可扩展性模型。如果搜索交易突然激增，预订不应受到影响。从业务角度来看，为了保存有效的预订交易，放弃搜索交易更为可接受。
- en: 'This is an example of a polyglot requirement, which overrules the business
    capability alignment. In this case, it makes more sense to have Search as a service
    separate from the Booking service. Let us assume that we remove Search. Only Inventory
    and Booking remain under Reservation. Now Search has to hit back to Reservation
    to perform inventory searches. This could impact the booking transactions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个多语种需求的例子，它推翻了业务能力的对齐。在这种情况下，将搜索作为一个独立的服务，与预订服务分开更有意义。假设我们移除搜索。现在只有库存和预订留在预订中。现在搜索必须返回到预订中执行库存搜索。这可能会影响预订交易：
- en: '![Challenge service boundaries](img/B05447_04_23.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![挑战服务边界](img/B05447_04_23.jpg)'
- en: A better approach is to keep Inventory along with the Booking module, and keep
    a read-only copy of the inventory under Search, while continuously synchronizing
    the inventory data over a reliable messaging system. Since both Inventory and
    Booking are collocated, this will also solve the need to have two-phase commits.
    Since both of them are local, they could work well with local transactions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是将库存与预订模块一起，并在搜索下保留库存的只读副本，同时通过可靠的消息系统持续同步库存数据。由于库存和预订都是同地的，这也解决了需要进行两阶段提交的需求。由于它们都是本地的，它们可以很好地与本地事务一起工作。
- en: Let us now challenge the Fare module design. When a customer searches for a
    flight between A and B for a given date, we would like to show the flights and
    fares together. That means that our read-only copy of inventory can also combine
    both fares as well as inventory. Search will then subscribe to Fare for any fare
    change events. The intelligence still stays with the Fare service, but it keeps
    sending fare updates to the cached fare data under Search.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们挑战票价模块的设计。当客户在给定日期搜索A和B之间的航班时，我们希望同时显示航班和票价。这意味着我们的只读库存副本也可以同时组合票价和库存。搜索将订阅票价以获取任何票价变更事件。智能仍然留在票价服务中，但它不断将票价更新发送到搜索下的缓存票价数据。
- en: Final dependency graph
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最终依赖图
- en: There are still a few synchronized calls, which, for the time being, we will
    keep as they are.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一些同步调用，暂时我们将保持它们不变。
- en: 'By applying all these changes, the final dependency diagram will look like
    the following one:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用所有这些变化，最终的依赖图将如下所示：
- en: '![Final dependency graph](img/B05447_04_24.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![最终依赖图](img/B05447_04_24.jpg)'
- en: Now we can safely consider each box in the preceding diagram as a microservice.
    We have nailed down many dependencies, and modeled many of them as asynchronous
    as well. The overall system is more or less designed in the reactive style. There
    are still some synchronized calls shown in the diagram with bold lines, such as
    Get Bulk from Check-In, Get Booking from CRM, and Get Fare from Booking. These
    synchronous calls are essentially required as per the trade-off analysis.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以安全地将前图中的每个方框视为一个微服务。我们已经确定了许多依赖关系，并且将其中许多建模为异步的。整个系统基本上是以反应式风格设计的。在图中仍然显示了一些同步调用，如从办理登机手续获取批量、从CRM获取预订和从预订获取票价等，这些同步调用根据权衡分析实际上是必需的。
- en: Prioritizing microservices for migration
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为迁移微服务设置优先级
- en: 'We have identified a first-cut version of our microservices-based architecture.
    As the next step, we will analyze the priorities, and identify the order of migration.
    This could be done by considering multiple factors explained as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了基于微服务的架构的第一次版本。下一步，我们将分析优先级，并确定迁移顺序。这可以通过考虑以下多个因素来完成：
- en: '**Dependency**: One of the parameters for deciding the priority is the dependency
    graph. From the service dependency graph, services with less dependency or no
    dependency at all are easy to migrate, whereas complex dependencies are way harder.
    Services with complex dependencies will also need dependent modules to be migrated
    along with them.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖性**：决定优先级的参数之一是依赖图。从服务依赖图中，具有较少依赖或根本没有依赖的服务易于迁移，而复杂的依赖关系则更难。具有复杂依赖关系的服务还需要将依赖模块与其一起迁移。'
- en: Accounting, Loyalty, CRM, and Boarding have less dependencies as compared to
    Booking and Check-in. Modules with high dependencies will also have higher risks
    in their migration.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 会计、忠诚度、CRM和登机手续与预订和办理登机手续相比具有较少的依赖关系。具有高依赖性的模块在迁移时也会有更高的风险。
- en: '**Transaction volume**: Another parameter that can be applied is analyzing
    the transaction volumes. Migrating services with the highest transaction volumes
    will relieve the load on the existing system. This will have more value from an
    IT support and maintenance perspective. However, the downside of this approach
    is the higher risk factor.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交易量**：另一个可以应用的参数是分析交易量。迁移具有最高交易量的服务将减轻现有系统的负担。从IT支持和维护的角度来看，这将具有更多的价值。然而，这种方法的缺点是风险因素更高。'
- en: As stated earlier, Search requests are ten times higher in volume as compared
    to Booking requests. Requests for Check-in are the third-highest in volume transaction
    after Search and Booking.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，搜索请求的数量是预订请求的十倍。在搜索和预订之后，办理登机手续的请求是交易量第三高的。
- en: '**Resource utilization**: Resource utilization is measured based on the current
    utilizations such as CPU, memory, connection pools, thread pools, and so on. Migrating
    resource intensive services out of the legacy system provides relief to other
    services. This helps the remaining modules to function better.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源利用率**：资源利用率是基于当前利用率来衡量的，例如CPU、内存、连接池、线程池等。将资源密集型服务从传统系统中迁移出去可以为其他服务提供帮助。这有助于其余模块的更好运行。'
- en: Flight, Revenue Management, and Accounting are resource-intensive services,
    as they involve data-intensive transactions such as forecasting, billing, flight
    schedule changes, and so on.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 航班、收入管理和会计是资源密集型服务，因为它们涉及数据密集型交易，如预测、计费、航班时间表更改等。
- en: '**Complexity**: Complexity is perhaps measured in terms of the business logic
    associated with a service such as function points, lines of code, number of tables,
    number of services, and others. Less complex modules are easy to migrate as compared
    to the more complex ones.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：复杂性可能是根据与服务相关的业务逻辑来衡量的，例如功能点、代码行数、表数、服务数等。与更复杂的模块相比，较不复杂的模块易于迁移。'
- en: Booking is extremely complex as compared to the Boarding, Search, and Check-in
    services.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与登机、搜索和办理登机手续服务相比，预订服务非常复杂。
- en: '**Business criticality**: The business criticality could be either based on
    revenue or customer experience. Highly critical modules deliver higher business
    value.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务重要性**：业务重要性可以基于收入或客户体验。高度关键的模块提供更高的业务价值。'
- en: Booking is the most revenue-generating service from the business stand point,
    whereas Check-in is business critical as it could lead to flight departure delays,
    which could lead to revenue loss as well as customer dissatisfaction.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**Velocity of changes**: Velocity of change indicates the number of change
    requests targeting a function in a short time frame. This translates to speed
    and agility of delivery. Services with high velocity of change requests are better
    candidates for migration as compared to stable modules.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistics show that Search, Booking, and Fares go through frequent changes,
    whereas Check-in is the most stable function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Innovation**: Services that are part of a disruptive innovative process need
    to get priority over back office functions that are based on more established
    business processes. Innovations in legacy systems are harder to achieve as compared
    to applying innovations in the microservices world.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the innovations are around Search, Booking, Fares, Revenue Management,
    and Check-in as compared to back office Accounting.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Based on BrownField's analysis, Search has the highest priority, as it requires
    innovation, has high velocity of changes, is less business critical, and gives
    better relief for both business and IT. The Search service has minimal dependency
    with no requirements to synchronize data back to the legacy system.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Data synchronization during migration
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the transition phase, the legacy system and the new microservices will
    run in parallel. Therefore, it is important to keep the data synchronized between
    the two systems.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The simplest option is to synchronize the data between the two systems at the
    database level by using any data synchronization tool. This approach works well
    when both the old and the new systems are built on the same data store technologies.
    The complexity will be higher if the data store technologies are different. The
    second problem with this approach is that we allow a backdoor entry, hence exposing
    the microservices' internal data store outside. This is against the principle
    of microservices.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take this on a case-by-case basis before we can conclude with a generic
    solution. The following diagram shows the data migration and synchronization aspect
    once Search is taken out:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Data synchronization during migration](img/B05447_04_25.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Let us assume that we use a NoSQL database for keeping inventory and fares under
    the Search service. In this particular case, all we need is the legacy system
    to supply data to the new service using asynchronous events. We will have to make
    some changes in the existing system to send the fare changes or any inventory
    changes as events. The Search service then accepts these events, and stores them
    locally into the local NoSQL store.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: This is a bit more tedious in the case of the complex Booking service.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the new Booking microservice sends the inventory change events
    to the Search service. In addition to this, the legacy application also has to
    send the fare change events to Search. Booking will then store the new Booking
    service in its My SQL data store.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![Data synchronization during migration](img/B05447_04_26.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: The most complex piece, the Booking service, has to send the booking events
    and the inventory events back to the legacy system. This is to ensure that the
    functions in the legacy system continue to work as before. The simplest approach
    is to write an update component which accepts the events and updates the old booking
    records table so that there are no changes required in the other legacy modules.
    We will continue this until none of the legacy components are referring the booking
    and inventory data. This will help us minimize changes in the legacy system, and
    therefore, reduce the risk of failures.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: In short, a single approach may not be sufficient. A multi-pronged approach
    based on different patterns is required.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Managing reference data
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the biggest challenges in migrating monolithic applications to microservices
    is managing reference data. A simple approach is to build the reference data as
    another microservice itself as shown in the following diagram:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将单体应用程序迁移到微服务的最大挑战之一是管理参考数据。一个简单的方法是将参考数据构建为另一个微服务，如下图所示：
- en: '![Managing reference data](img/B05447_04_27.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![管理参考数据](img/B05447_04_27.jpg)'
- en: In this case, whoever needs reference data should access it through the microservice
    endpoints. This is a well-structured approach, but could lead to performance issues
    as encountered in the original legacy system.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，需要参考数据的人员应该通过微服务端点访问它。这是一个结构良好的方法，但可能会导致性能问题，就像在原始的旧系统中遇到的问题一样。
- en: An alternate approach is to have reference data as a microservice service for
    all the admin and CRUD functions. A near cache will then be created under each
    service to incrementally cache data from the master services. A thin reference
    data access proxy library will be embedded in each of these services. The reference
    data access proxy abstracts whether the data is coming from cache or from a remote
    service.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将参考数据作为所有管理和CRUD功能的微服务。然后在每个服务下创建一个近缓存，从主服务中逐步缓存数据。一个薄的参考数据访问代理库将被嵌入到这些服务中。参考数据访问代理抽象了数据是来自缓存还是远程服务的细节。
- en: 'This is depicted in the next diagram. The master node in the given diagram
    is the actual reference data microservice:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下一个图中有所描述。给定图中的主节点是实际的参考数据微服务：
- en: '![Managing reference data](img/B05447_04_28.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![管理参考数据](img/B05447_04_28.jpg)'
- en: The challenge is to synchronize the data between the master and the slave. A
    subscription mechanism is required for those data caches that change frequently.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于在主节点和从节点之间同步数据。对于那些频繁更改的数据缓存，需要订阅机制。
- en: 'A better approach is to replace the local cache with an in-memory data grid,
    as shown in the following diagram:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是用内存数据网格替换本地缓存，如下图所示：
- en: '![Managing reference data](img/B05447_04_29.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![管理参考数据](img/B05447_04_29.jpg)'
- en: The reference data microservice will write to the data grid, whereas the proxy
    libraries embedded in other services will have read-only APIs. This eliminates
    the requirement to have subscription of data, and is much more efficient and consistent.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 参考数据微服务将写入数据网格，而嵌入在其他服务中的代理库将具有只读API。这消除了对数据订阅的要求，更加高效和一致。
- en: User interfaces and web applications
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面和Web应用程序
- en: During the transition phase, we have to keep both the old and new user interfaces
    together. There are three general approaches usually taken in this scenario.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在过渡阶段，我们必须同时保留旧的和新的用户界面。通常有三种一般性方法用于处理这种情况。
- en: 'The first approach is to have the old and new user interfaces as separate user
    applications with no link between them, as depicted in the following diagram:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是将旧的和新的用户界面作为独立的用户应用程序，彼此之间没有链接，如下图所示：
- en: '![User interfaces and web applications](img/B05447_04_30.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面和Web应用程序](img/B05447_04_30.jpg)'
- en: A user signs in to the new application as well as into the old application,
    much like two different applications, with no **single sign-on** (**SSO**) between
    them. This approach is simple, and there is no overhead. In most of the cases,
    this may not be acceptable to the business unless it is targeted at two different
    user communities.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登录到新应用程序以及旧应用程序，就像两个不同的应用程序，它们之间没有单点登录（SSO）。这种方法简单，没有额外开销。在大多数情况下，除非针对两个不同的用户群体，否则业务可能不会接受这种方法。
- en: 'The second approach is to use the legacy user interface as the primary application,
    and then transfer page controls to the new user interfaces when the user requests
    pages of the new application:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是将旧用户界面作为主要应用程序，然后在用户请求新应用程序的页面时将页面控件转移到新用户界面：
- en: '![User interfaces and web applications](img/B05447_04_31.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面和Web应用程序](img/B05447_04_31.jpg)'
- en: In this case, since the old and the new applications are web-based applications
    running in a web browser window, users will get a seamless experience. SSO has
    to be implemented between the old and the new user interfaces.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于旧应用程序和新应用程序都是在Web浏览器窗口中运行的Web应用程序，用户将获得无缝的体验。必须在旧和新用户界面之间实现SSO。
- en: 'The third approach is to integrate the existing legacy user interface directly
    to the new microservices backend, as shown in the next diagram:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是直接将现有的旧用户界面集成到新的微服务后端，如下图所示：
- en: '![User interfaces and web applications](img/B05447_04_32.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面和Web应用程序](img/B05447_04_32.jpg)'
- en: In this case, the new microservices are built as headless applications with
    no presentation layer. This could be challenging, as it may require many changes
    in the old user interface such as introducing service calls, data model conversions,
    and so on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，新的微服务被构建为无展示层的无头应用程序。这可能是具有挑战性的，因为它可能需要对旧的用户界面进行许多更改，比如引入服务调用、数据模型转换等。
- en: Another issue in the last two cases is how to handle the authentication of resources
    and services.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两种情况中的另一个问题是如何处理资源和服务的认证。
- en: Session handling and security
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会话处理和安全性
- en: Assume that the new services are written based on Spring Security with a token-based
    authorization strategy, whereas the old application uses a custom-built authentication
    with its local identity store.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 假设新服务是基于Spring Security编写的，采用基于令牌的授权策略，而旧应用程序使用自定义构建的身份存储进行身份验证。
- en: 'The following diagram shows how to integrate between the old and the new services:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了如何在旧服务和新服务之间进行集成：
- en: '![Session handling and security](img/B05447_04_33.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![会话处理和安全性](img/B05447_04_33.jpg)'
- en: The simplest approach, as shown in the preceding diagram, is to build a new
    identity store with an authentication service as a new microservice using Spring
    Security. This will be used for all our future resource and service protections,
    for all microservices.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，最简单的方法是使用Spring Security构建一个新的身份存储和认证服务作为一个新的微服务。这将用于我们所有未来的资源和服务保护，对于所有微服务。
- en: The existing user interface application authenticates itself against the new
    authentication service, and secures a token. This token will be passed to the
    new user interface or new microservice. In both cases, the user interface or microservice
    will make a call to the authentication service to validate the given token. If
    the token is valid, then the UI or microservice accepts the call.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的用户界面应用程序对新的身份验证服务进行身份验证，并获得一个令牌。这个令牌将被传递给新的用户界面或新的微服务。在这两种情况下，用户界面或微服务将调用身份验证服务来验证给定的令牌。如果令牌有效，那么用户界面或微服务接受调用。
- en: The catch here is that the legacy identity store has to be synchronized with
    the new one.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，遗留身份存储必须与新的身份存储同步。
- en: Test strategy
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试策略
- en: One important question to answer from a testing point of view is how can we
    ensure that all functions work in the same way as before the migration?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试的角度来看，一个重要的问题是如何确保所有功能在迁移之前和之后都能正常工作？
- en: Integration test cases should be written for the services that are getting migrated
    before the migration or refactoring. This ensures that once migrated, we get the
    same expected result, and the behavior of the system remains the same. An automated
    regression test pack has to be in place, and has to be executed every time we
    make a change in the new or old system.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移或重构之前，应编写针对正在迁移的服务的集成测试用例。这可以确保一旦迁移完成，我们能够得到相同的预期结果，并且系统的行为保持不变。必须建立一个自动化的回归测试包，并且每次在新旧系统中进行更改时都必须执行。
- en: 'In the following diagram, for each service we need one test against the EJB
    endpoint, and another one against the microservices endpoint:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个服务，我们需要一个针对EJB端点的测试，另一个针对微服务端点的测试：
- en: '![Test strategy](img/B05447_04_34.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![测试策略](img/B05447_04_34.jpg)'
- en: Building ecosystem capabilities
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建生态系统能力
- en: Before we embark on actual migration, we have to build all of the microservice's
    capabilities mentioned under the capability model, as documented in [Chapter 3](ch03.html
    "Chapter 3. Applying Microservices Concepts"), *Applying Microservices Concepts*.
    These are the prerequisites for developing microservices-based systems.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们着手实际迁移之前，我们必须构建所有在能力模型下提到的微服务的能力，如[第3章](ch03.html "第3章。应用微服务概念")*应用微服务概念*中所记录的。这些是开发基于微服务的系统的先决条件。
- en: In addition to these capabilities, certain application functions are also required
    to be built upfront such as reference data, security and SSO, and Customer and
    Notification. A data warehouse or a data lake is also required as a prerequisite.
    An effective approach is to build these capabilities in an incremental fashion,
    delaying development until it is really required.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些能力，还需要预先构建某些应用功能，如参考数据、安全和SSO，以及客户和通知。数据仓库或数据湖也是必需的先决条件。一个有效的方法是以增量方式构建这些能力，直到真正需要为止。
- en: Migrate modules only if required
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只有在必要的情况下才迁移模块。
- en: In the previous chapters, we have examined approaches and steps for transforming
    from a monolithic application to microservices. It is important to understand
    that it is not necessary to migrate all modules to the new microservices architecture,
    unless it is really required. A major reason is that these migrations incur cost.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经研究了从单片应用转变为微服务的方法和步骤。重要的是要理解，除非真的需要，否则没有必要将所有模块迁移到新的微服务架构中。一个主要原因是这些迁移会产生成本。
- en: We will review a few such scenarios here. BrownField has already taken a decision
    to use an external revenue management system in place of the PSS revenue management
    function. BrownField is also in the process of centralizing their accounting functions,
    and therefore, need not migrate the accounting function from the legacy system.
    Migration of CRM does not add much value at this point to the business. Therefore,
    it is decided to keep the CRM in the legacy system itself. The business has plans
    to move to a SaaS-based CRM solution as part of their cloud strategy. Also note
    that stalling the migration halfway through could seriously impact the complexity
    of the system.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里审查一些这样的情景。BrownField已经决定使用外部收入管理系统来取代PSS收入管理功能。BrownField也正在将他们的会计功能集中化，因此，不需要迁移遗留系统的会计功能。在这一点上，迁移CRM并不会给业务增加太多价值。因此，决定将CRM保留在遗留系统中。业务计划作为他们的云策略的一部分转移到基于SaaS的CRM解决方案。还要注意，中途停止迁移可能会严重影响系统的复杂性。
- en: Target architecture
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标架构
- en: 'The architecture blueprint shown in the following diagram consolidates earlier
    discussions into an architectural view. Each block in the diagram represents a
    microservice. The shaded boxes are core microservices, and the others are supporting
    microservices. The diagram also shows the internal capabilities of each microservice.
    User management is moved under security in the target architecture:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表中的架构蓝图将之前的讨论整合成了一个架构视图。图表中的每个块代表一个微服务。阴影框是核心微服务，其他的是支持微服务。图表还显示了每个微服务的内部能力。用户管理已移至目标架构中的安全性下：
- en: '![Target architecture](img/B05447_04_35.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![目标架构](img/B05447_04_35.jpg)'
- en: Each service has its own architecture, typically consisting of a presentation
    layer, one or more service endpoints, business logic, business rules, and database.
    As we can see, we use different selections of databases that are more suitable
    for each microservice. Each one is autonomous with minimal orchestration between
    the services. Most of the services interact with each other using the service
    endpoints.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都有自己的架构，通常包括表示层、一个或多个服务端点、业务逻辑、业务规则和数据库。正如我们所看到的，我们使用不同的数据库选择，这些数据库更适合每个微服务。每个微服务都是自治的，服务之间的编排很少。大多数服务使用服务端点相互交互。
- en: Internal layering of microservices
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务的内部分层
- en: In this section, we will further explore the internal structure of microservices.
    There is no standard to be followed for the internal architecture of a microservice.
    The rule of thumb is to abstract realizations behind simple service endpoints.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进一步探讨微服务的内部结构。没有标准可供遵循微服务的内部架构。经验法则是在简单的服务端点背后抽象实现。
- en: 'A typical structure would look like the one shown in the following diagram:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的结构看起来像下图所示：
- en: '![Internal layering of microservices](img/B05447_04_36.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![微服务的内部分层](img/B05447_04_36.jpg)'
- en: The UI accesses REST services through a service gateway. The API gateway may
    be one per microservice or one for many microservices—it depends on what we want
    to do with the API gateway. There could be one or more rest endpoints exposed
    by microservices. These endpoints, in turn, connect to one of the business components
    within the service. Business components then execute all the business functions
    with the help of domain entities. A repository component is used for interacting
    with the backend data store.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: UI通过服务网关访问REST服务。API网关可以是每个微服务一个，也可以是多个微服务一个，这取决于我们想要用API网关做什么。微服务可以暴露一个或多个rest端点。这些端点反过来连接到服务内的一个业务组件。业务组件然后借助领域实体执行所有业务功能。存储库组件用于与后端数据存储交互。
- en: Orchestrating microservices
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编排微服务
- en: 'The logic of the booking orchestration and the execution of rules sits within
    the Booking service. The brain is still inside the Booking service in the form
    of one or more booking business components. Internally, business components orchestrate
    private APIs exposed by other business components or even external services:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 预订编排的逻辑和规则执行位于预订服务内。大脑仍然在预订服务内，以一个或多个预订业务组件的形式。在内部，业务组件编排其他业务组件或甚至外部服务暴露的私有API：
- en: '![Orchestrating microservices](img/B05447_04_37.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![编排微服务](img/B05447_04_37.jpg)'
- en: As shown in the preceding diagram, the booking service internally calls to update
    the inventory of its own component other than calling the Fare service.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，预订服务内部调用更新其自己组件的库存，而不是调用票价服务。
- en: Is there any orchestration engine required for this activity? It depends on
    the requirements. In complex scenarios, we may have to do a number of things in
    parallel. For example, creating a booking internally applies a number of booking
    rules, it validates the fare, and it validates the inventory before creating a
    booking. We may want to execute them in parallel. In such cases, we may use Java
    concurrency APIs or reactive Java libraries.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这项活动是否需要编排引擎？这取决于需求。在复杂的情况下，我们可能需要同时做很多事情。例如，内部创建预订应用了许多预订规则，它验证票价，验证库存，然后才创建预订。我们可能希望并行执行它们。在这种情况下，我们可以使用Java并发API或反应式Java库。
- en: In extremely complex situations, we may opt for an integration framework such
    as Spring Integration or Apache Camel in embedded mode.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在极其复杂的情况下，我们可以选择集成框架，如Spring Integration或Apache Camel的嵌入模式。
- en: Integration with other systems
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他系统集成
- en: In the microservices world, we use an API gateway or a reliable message bus
    for integrating with other non-microservices.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务世界中，我们使用API网关或可靠的消息总线来与其他非微服务集成。
- en: Let us assume that there is another system in BrownField that needs booking
    data. Unfortunately, the system is not capable of subscribing to the booking events
    that the Booking microservice publishes. In such cases, an **Enterprise Application
    integration** (**EAI**) solution could be employed, which listens to our booking
    events, and then uses a native adaptor to update the database.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 假设BrownField中有另一个系统需要预订数据。不幸的是，该系统无法订阅预订微服务发布的预订事件。在这种情况下，可以使用**企业应用集成**（**EAI**）解决方案，它监听我们的预订事件，然后使用本地适配器更新数据库。
- en: Managing shared libraries
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理共享库
- en: Certain business logic is used in more than one microservice. Search and Reservation,
    in this case, use inventory rules. In such cases, these shared libraries will
    be duplicated in both the microservices.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 某些业务逻辑在多个微服务中使用。在这种情况下，这些共享库将在两个微服务中复制。
- en: Handling exceptions
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'Examine the booking scenario to understand the different exception handling
    approaches. In the following service sequence diagram, there are three lines marked
    with a cross mark. These are the potential areas where exceptions could occur:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 检查预订场景以了解不同的异常处理方法。在下面的服务序列图中，有三条用叉号标记的线。这些是异常可能发生的潜在区域：
- en: '![Handling exceptions](img/B05447_04_38.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![处理异常](img/B05447_04_38.jpg)'
- en: There is a synchronous communication between Booking and Fare. What if the Fare
    service is not available? If the Fare service is not available, throwing an error
    back to the user may cause revenue loss. An alternate thought is to trust the
    fare which comes as part of the incoming request. When we serve search, the search
    results will have the fare as well. When the user selects a flight and submits,
    the request will have the selected fare. In case the Fare service is not available,
    we trust the incoming request, and accept the Booking. We will use a circuit breaker
    and a fallback service which simply creates the booking with a special status,
    and queues the booking for manual action or a system retry.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 预订和票价之间存在同步通信。如果票价服务不可用怎么办？如果票价服务不可用，将错误返回给用户可能会导致收入损失。另一种想法是信任作为传入请求的一部分的票价。当我们提供搜索时，搜索结果也将包含票价。当用户选择航班并提交时，请求将包含所选的票价。如果票价服务不可用，我们信任传入的请求，并接受预订。我们将使用断路器和一个备用服务，该服务仅以特殊状态创建预订，并将预订排队等待手动操作或系统重试。
- en: What if creating the booking fails? If creating a booking fails unexpectedly,
    a better option is to throw a message back to the user. We could try alternative
    options, but that could increase the overall complexity of the system. The same
    is applicable for inventory updates.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建预订失败怎么办？如果创建预订意外失败，更好的选择是将消息返回给用户。我们可以尝试替代选项，但这可能会增加系统的整体复杂性。对于库存更新也是如此。
- en: In the case of creating a booking and updating the inventory, we avoid a situation
    where a booking is created, and an inventory update somehow fails. As the inventory
    is critical, it is better to have both, create booking and update inventory, to
    be in a local transaction. This is possible as both components are under the same
    subsystem.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建预订和更新库存的情况下，我们避免了创建预订后库存更新出现意外失败的情况。由于库存很关键，最好将创建预订和更新库存都放在本地事务中。这是可能的，因为这两个组件都在同一子系统下。
- en: 'If we consider the Check-in scenario, Check-in sends an event to Boarding and
    Booking as shown in the next diagram:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑登记场景，登记向登机和预订发送事件，如下图所示：
- en: '![Handling exceptions](img/B05447_04_39.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![处理异常](img/B05447_04_39.jpg)'
- en: Consider a scenario where the Check-in services fail immediately after the Check-in
    Complete event is sent out. The other consumers processed this event, but the
    actual check-in is rolled back. This is because we are not using a two-phase commit.
    In this case, we need a mechanism for reverting that event. This could be done
    by catching the exception, and sending another Check-in Cancelled event.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一种情况，即在完成登记后立即发生登记服务失败。其他消费者处理了此事件，但实际的登记被回滚了。这是因为我们没有使用两阶段提交。在这种情况下，我们需要一种回滚该事件的机制。这可以通过捕获异常并发送另一个“取消登记”事件来实现。
- en: In this case, note that to minimize the use of compensating transactions, sending
    the Check-in event is moved towards the end of the Check-in transaction. This
    reduces the chance of failure after sending out the event.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，需要注意的是为了最小化补偿事务的使用，发送登记事件被移至登记事务的末尾。这减少了发送事件后失败的机会。
- en: On the other hand, what if the check-in is successful, but sending the event
    failed? We could think of two approaches. The first approach would be to invoke
    a fallback service to store it locally, and then use another sweep-and-scan program
    to send the event at a later time. It could even retry multiple times. This could
    add more complexity and may not be efficient in all cases. An alternate approach
    is to throw the exception back to the user so that the user can retry. However,
    this might not always be good from a customer engagement standpoint. On the other
    hand, the earlier option is better for the system's health. A trade-off analysis
    is required to find out the best solution for the given situation.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果登记成功，但发送事件失败怎么办？我们可以考虑两种方法。第一种方法是调用备用服务将其存储在本地，然后使用另一个扫描程序在以后的某个时间发送事件。甚至可以多次重试。这可能会增加更多的复杂性，并且在所有情况下可能不高效。另一种方法是将异常返回给用户，以便用户可以重试。然而，从客户参与的角度来看，这可能并不总是好的。另一方面，前一种选项对于系统的健康状况更好。需要进行权衡分析，以找出给定情况的最佳解决方案。
- en: Target implementation view
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标实现视图
- en: 'The next diagram represents the implementation view of the BrownField PSS microservices
    system:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 下图表示了BrownField PSS微服务系统的实现视图：
- en: '![Target implementation view](img/B05447_04_40.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![目标实现视图](img/B05447_04_40.jpg)'
- en: 'As shown in the preceding diagram, we are implementing four microservices as
    an example: Search, Fare, Booking, and Check-in. In order to test the application,
    there is a website application developed using Spring MVC with Thymeleaf templates.
    The asynchronous messaging is implemented with the help of RabbitMQ. In this sample
    implementation, the default H2 database is used as the in-memory store for demonstration
    purposes.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们正在实施四个微服务作为示例：搜索、票价、预订和登记。为了测试应用程序，使用了Spring MVC和Thymeleaf模板开发了一个网站应用程序。异步消息传递是通过RabbitMQ实现的。在此示例实现中，使用默认的H2数据库作为内存存储以进行演示。
- en: The code in this section demonstrates all the capabilities highlighted in the
    *Reviewing the microservices capability model* section of this chapter.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码演示了本章*审查微服务能力模型*部分中强调的所有功能。
- en: Implementation projects
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现项目
- en: 'The basic implementation of the BrownField Airline''s PSS microservices system
    has five core projects as summarized in the following table. The table also shows
    the port range used for these projects to ensure consistency throughout the book:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: BrownField航空公司的PSS微服务系统的基本实现有五个核心项目，如下表所总结。该表还显示了这些项目使用的端口范围，以确保整本书的一致性：
- en: '| Microservice | Projects | Port Range |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 微服务 | 项目 | 端口范围 |'
- en: '| --- | --- | --- |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Book microservice | `chapter4.book` | `8060`-`8069` |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 预订微服务 | `chapter4.book` | `8060`-`8069` |'
- en: '| Check-in microservice | `chapter4.checkin` | `8070`-`8079` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 办理登机手续微服务 | `chapter4.checkin` | `8070`-`8079` |'
- en: '| Fare microservice | `chapter4.fares` | `8080`-`8089` |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 航班微服务 | `chapter4.fares` | `8080`-`8089` |'
- en: '| Search microservice | `chapter4.search` | `8090`-`8099` |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 搜索微服务 | `chapter4.search` | `8090`-`8099` |'
- en: '| Website | `chapter4.website` | `8001` |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 网站 | `chapter4.website` | `8001` |'
- en: The website is the UI application for testing the PSS microservices.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站是用于测试PSS微服务的UI应用程序。
- en: 'All microservice projects in this example follow the same pattern for package
    structure as shown in the following screenshot:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，所有微服务项目都遵循与下图中所示的包结构相同的模式：
- en: '![Implementation projects](img/B05447_04_41.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![实施项目](img/B05447_04_41.jpg)'
- en: 'The different packages and their purposes are explained as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不同包及其用途的解释：
- en: The root folder (`com.brownfield.pss.book`) contains the default Spring Boot
    application.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件夹（`com.brownfield.pss.book`）包含默认的Spring Boot应用程序。
- en: The `component` package hosts all the service components where the business
    logic is implemented.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`包承载所有服务组件，业务逻辑在其中实现。'
- en: The `controller` package hosts the REST endpoints and the messaging endpoints.
    Controller classes internally utilize the component classes for execution.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器包承载着REST端点和消息端点。控制器类在内部利用组件类进行执行。
- en: The `entity` package contains the JPA entity classes for mapping to the database
    tables.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity`包含用于映射到数据库表的JPA实体类。'
- en: Repository classes are packaged inside the `repository` package, and are based
    on Spring Data JPA.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库类被打包在`repository`包中，并且基于Spring Data JPA。
- en: Running and testing the project
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和测试项目
- en: 'Follow the steps listed next to build and test the microservices developed
    in this chapter:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '按照下面列出的步骤构建和测试本章开发的微服务： '
- en: 'Build each of the projects using Maven. Ensure that the `test` flag is switched
    off. The test programs assume other dependent services are up and running. It
    fails if the dependent services are not available. In our example, Booking and
    Fare have direct dependencies. We will learn how to circumvent this dependency
    in [Chapter 7](ch07.html "Chapter 7. Logging and Monitoring Microservices"), *Logging
    and Monitoring Microservices*:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Maven构建每个项目。确保`test`标志关闭。测试程序假定其他依赖服务正在运行。如果依赖服务不可用，则测试将失败。在我们的示例中，预订和票价有直接依赖关系。我们将学习如何在[第7章](ch07.html
    "第7章。记录和监控微服务"), *记录和监控微服务*中避免这种依赖关系：
- en: '[PRE0]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the RabbitMQ server:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行RabbitMQ服务器：
- en: '[PRE1]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the following commands in separate terminal windows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单独的终端窗口中运行以下命令：
- en: '[PRE2]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The website project has a `CommandLineRunner`, which executes all the test cases
    at startup. Once all the services are successfully started, open `http://localhost:8001`
    in a browser.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网站项目有一个`CommandLineRunner`，它在启动时执行所有测试用例。一旦所有服务成功启动，就在浏览器中打开`http://localhost:8001`。
- en: The browser asks for basic security credentials. Use `guest` or `guest123` as
    the credentials. This example only shows the website security with a basic authentication
    mechanism. As explained in [Chapter 2](ch02.html "Chapter 2. Building Microservices
    with Spring Boot"), *Building Microservices with Spring Boot*, service-level security
    can be achieved using OAuth2.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器要求输入基本安全凭据。使用`guest`或`guest123`作为凭据。本示例仅显示了具有基本身份验证机制的网站安全性。如[第2章](ch02.html
    "第2章。使用Spring Boot构建微服务"), *使用Spring Boot构建微服务*中所述，可以使用OAuth2实现服务级安全性。
- en: Entering the correct security credentials displays the following screen. This
    is the home screen of our BrownField PSS application:![Running and testing the
    project](img/B05447_04_42.jpg)
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入正确的安全凭据会显示以下屏幕。这是我们BrownField PSS应用程序的主屏幕：![运行和测试项目](img/B05447_04_42.jpg)
- en: The **SUBMIT** button invokes the Search microservice to fetch the available
    flights that meet the conditions mentioned on the screen. A few flights are pre-populated
    at the startup of the Search microservice. Edit the Search microservice code to
    feed in additional flights, if required.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提交**按钮调用搜索微服务以获取满足屏幕上条件的可用航班。在搜索微服务启动时预先填充了一些航班。如有需要，编辑搜索微服务代码以输入额外的航班。'
- en: The output screen with a list of flights is shown in the next screenshot. The
    **Book** link will take us to the booking screen for the selected flight:![Running
    and testing the project](img/B05447_04_43.jpg)
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个截图显示了带有航班列表的输出屏幕。**预订**链接将带我们到所选航班的预订屏幕：![运行和测试项目](img/B05447_04_43.jpg)
- en: The following screenshot shows the booking screen. The user can enter the passenger
    details, and create a booking by clicking on the **CONFIRM** button. This invokes
    the Booking microservice, and internally, the Fare service as well. It also sends
    a message back to the Search microservice:![Running and testing the project](img/B05447_04_44.jpg)
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个截图显示了预订屏幕。用户可以输入乘客信息，并通过点击**确认**按钮来创建预订。这会调用预订微服务，以及内部的票价服务。它还会向搜索微服务发送一条消息：![运行和测试项目](img/B05447_04_44.jpg)
- en: If booking is successful, the next confirmation screen is displayed with a booking
    reference number:![Running and testing the project](img/B05447_04_45.jpg)
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果预订成功，下一个确认屏幕将显示预订参考号码：![运行和测试项目](img/B05447_04_45.jpg)
- en: Let us test the Check-in microservice. This can be done by clicking on **CheckIn**
    in the menu at the top of the screen. Use the booking reference number obtained
    in the previous step to test Check-in. This is shown in the following screenshot:![Running
    and testing the project](img/B05447_04_46.jpg)
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试办理登机手续微服务。可以通过点击屏幕顶部的**办理登机手续**菜单来完成。使用前一步获得的预订参考号码来测试办理登机手续。如下图所示：![运行和测试项目](img/B05447_04_46.jpg)
- en: Clicking on the **SEARCH** button in the previous screen invokes the Booking
    microservice, and retrieves the booking information. Click on the **CheckIn**
    link to perform the check-in. This invokes the Check-in microservice:![Running
    and testing the project](img/B05447_04_47.jpg)
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个屏幕上点击**搜索**按钮会调用Booking微服务，并检索预订信息。点击**办理登机手续**链接进行办理登机手续。这会调用办理登机微服务：![运行和测试项目](img/B05447_04_47.jpg)
- en: If check-in is successful, it displays the confirmation message, as shown in
    the next screenshot, with a confirmation number. This is done by calling the Check-in
    service internally. The Check-in service sends a message to Booking to update
    the check-in status:![Running and testing the project](img/B05447_04_48.jpg)
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果办理登机成功，它会显示确认消息，如下一张截图所示，并附有确认号。这是通过内部调用办理登机服务来完成的。办理登机服务向Booking发送消息以更新登机状态：![运行和测试项目](img/B05447_04_48.jpg)
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented and tested the BrownField PSS microservice with
    basic Spring Boot capabilities. We learned how to approach a real use case with
    a microservices architecture.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用基本的Spring Boot功能实现并测试了BrownField PSS微服务。我们学习了如何使用微服务架构处理真实用例。
- en: We examined the various stages of a real-world evolution towards microservices
    from a monolithic application. We also evaluated the pros and cons of multiple
    approaches, and the obstacles encountered when migrating a monolithic application.
    Finally, we explained the end-to-end microservices design for the use case that
    we examined. Design and implementation of a fully-fledged microservice implementation
    was also validated.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们审查了从单体应用程序向微服务的真实世界演变的各个阶段。我们还评估了多种方法的利弊，以及迁移单体应用程序时遇到的障碍。最后，我们解释了我们审查的用例的端到端微服务设计。还验证了一个完整的微服务实现的设计和实施。
- en: In the next chapter, we will see how the Spring Cloud project helps us to transform
    the developed BrownField PSS microservices to an Internet-scale deployment.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到Spring Cloud项目如何帮助我们将开发的BrownField PSS微服务转换为互联网规模的部署。

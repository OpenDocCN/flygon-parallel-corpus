- en: Chapter 3. Building Queries with Spring Data JPA
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用Spring Data JPA构建查询
- en: 'We have learned how we can configure Spring Data JPA and implemented a simple
    CRUD application. Now it is time that we learn some skills that will help us to
    implement real-life applications. In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何配置Spring Data JPA并实现了一个简单的CRUD应用程序。现在是时候学习一些技能，这些技能将帮助我们实现真实的应用程序。在本章中，我们将涵盖：
- en: How we can use query methods for creating queries
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用查询方法创建查询
- en: How we can create dynamic queries by using the JPA Criteria API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用JPA Criteria API创建动态查询
- en: How we can use Querydsl for creating dynamic queries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用Querydsl创建动态查询
- en: How we can sort and paginate query results
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何对查询结果进行排序和分页
- en: 'In the course of this chapter, we will extend our contact manager application
    by adding a search function to it. The requirements of the search function are
    as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过向联系人管理应用程序添加搜索功能来扩展它。搜索功能的要求如下：
- en: The search function must return all contacts whose first name or last name start
    with the given search term
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索功能必须返回所有名字或姓氏以给定搜索词开头的联系人
- en: The search must be case insensitive
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索必须不区分大小写
- en: The search results must be sorted in ascending order by using the last name
    and first name
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索结果必须按姓氏和名字按升序排序
- en: The search function must be able to paginate search results
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索功能必须能够对搜索结果进行分页
- en: We will also learn to sort and paginate the contact list shown on the home page
    of our application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习如何对应用程序主页上显示的联系人列表进行排序和分页。
- en: Building queries
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建查询
- en: 'There are three options we can use to build queries with Spring Data JPA: query
    methods, JPA Criteria API, and Querydsl. During this section, we will learn how
    to use them and start the implementation of our search function. We will also
    take a look at the pros and cons of each option and receive concrete recommendations
    concerning the selection of the correct query creation technique.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Spring Data JPA构建查询的三种选项：查询方法，JPA Criteria API和Querydsl。在本节中，我们将学习如何使用它们并开始实现我们的搜索功能。我们还将看一下每个选项的优缺点，并得到关于选择正确的查询创建技术的具体建议。
- en: 'Before we can move forward, we have to add a `search()` method, which is used
    as a starting point of our search function, to the `ContactService` interface.
    The signature of the `search()` method looks like the following code snippet:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们必须向`ContactService`接口添加一个`search()`方法，该方法用作我们搜索功能的起点。`search()`方法的签名如下代码片段所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Query methods
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询方法
- en: 'The simplest way to create queries with Spring Data JPA is to use query methods.
    **Query methods** are methods that are declared in the repository interface. There
    are three techniques we can use to create query methods:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Data JPA创建查询的最简单方法是使用查询方法。**查询方法**是在存储库接口中声明的方法。我们可以使用三种技术来创建查询方法：
- en: '**Query generation from method name**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从方法名称生成查询**'
- en: '**Named Queries**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名查询**'
- en: The `@Query` annotation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Query`注解'
- en: Query generation from method name
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从方法名称生成查询
- en: 'Query generation from method name is a query generation strategy where the
    executed query is parsed from the name of a query method. The naming convention,
    which is used to create the names of query methods, has three important components:
    **method prefixes**, **property expressions**, and **keywords**. Next we will
    learn the basic usage of these components and implement our search function. We
    will also take a look at the pros and cons of this approach.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从方法名称生成查询是一种查询生成策略，其中执行的查询是从查询方法的名称中解析出来的。用于创建查询方法名称的命名约定有三个重要组件：**方法前缀**，**属性表达式**和**关键字**。接下来，我们将学习这些组件的基本用法并实现我们的搜索功能。我们还将看一下这种方法的优缺点。
- en: Method prefixes
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法前缀
- en: The name of each method must start with a special prefix. This ensures that
    the method is identified as a query method. The supported prefixes are `findBy`
    , `find`, `readBy` , `read` , `getBy` , and `get` . All prefixes are synonyms
    and they have no effect on the parsed query.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法的名称必须以特殊前缀开头。这确保该方法被识别为查询方法。支持的前缀是`findBy`，`find`，`readBy`，`read`，`getBy`和`get`。所有前缀都是同义词，对解析的查询没有影响。
- en: Property expressions
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性表达式
- en: 'Property expressions are used to refer either to a direct property or to a
    nested property of a managed entity. We will use the `Contact` entity to demonstrate
    the usage of property expressions in the following table:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 属性表达式用于引用托管实体的直接属性或嵌套属性。我们将使用`Contact`实体来演示以下表中属性表达式的用法：
- en: '| Property expression | Referred property |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 属性表达式 | 引用的属性 |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LastName` | The `lastName` property of the `Contact` class. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `LastName` | `Contact`类的`lastName`属性。 |'
- en: '| `AddressStreetAddress` | The `streetAddress` property of the `Address` class.
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `AddressStreetAddress` | `Address`类的`streetAddress`属性。 |'
- en: 'Let''s find out how the property resolution algorithm works by using the `AddressStreetAddress`
    property expression as an example. This algorithm has three phases:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`AddressStreetAddress`属性表达式来了解属性解析算法是如何工作的。该算法有三个阶段：
- en: At first it will check if the entity class has a property with the name matching
    the property expression when the first letter of the property expression is transformed
    to lowercase. If a match is found, that property is used. If a property named
    `addressStreetAddress` is not found from the `Contact` class the algorithm moves
    to the next phase.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它将检查实体类是否具有与属性表达式匹配的名称的属性，当属性表达式的第一个字母转换为小写时。如果找到匹配项，则使用该属性。如果在`Contact`类中找不到名为`addressStreetAddress`的属性，则算法将移至下一个阶段。
- en: 'The property expression is split at camel case parts starting from right to
    left to a head and a tail. After this is done, the algorithm tries to find a matching
    property from the entity. If a match it found, the algorithm tries to find the
    referred property by following the parts of the property expression from head
    to tail. In this phase, our property expression is split into two parts: `AddressStreet`
    and `Address`. Since the `Contact` entity does not have a matching property, the
    algorithm continues to the third phase.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The split point is moved to the left and the algorithm tries to find a matching
    property from the entity. The property expression is split into two parts: `Address`
    and `StreetAddress`. A matching property `address` is found from the `Contact`
    class. Also, since the `Address` class has a property named `streetAddress`, a
    match is found.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `Contact` class would have a property called `addressStreetAddress`,
    the property selection algorithm would select it instead of the `streetAddress`
    property of the `Address` class. We can solve this problem by using the underscore
    character in the property expression to manually specify traversal points. In
    this case, we should use a property expression `Address_StreetAddress`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Keywords
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Keywords are used to specify constraints against the values of properties referred
    by property expressions. There are two rules that are used to combine property
    expressions together with keywords:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: We can create a **constraint** by adding a keyword after a property expression
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can combine constraints by adding either the **And** or **Or** keyword between
    them
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reference manual of Spring Data JPA ([http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/](http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/))
    describes how property expressions and keywords can be used for creating query
    methods:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyword | Sample | JPQL Snippet |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| `And` | `findByLastNameAndFirstName` | `where x.lastname = ?1 and x.firstname
    = ?2` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| `Or` | `findByLastNameOrFirstName` | `where x.lastname = ?1 or x.firstname
    = ?2` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| `Between` | `findByStartDateBetween` | `where x.startDate between 1? and
    ?2` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| `LessThan` | `findByAgeLessThan` | `where x.age < ?1` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| `GreaterThan` | `findByAgeGreaterThan` | `where x.age > ?1` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| `After` | `findByStartDateAfter` | `where x.startDate > ?1` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| `Before` | `findByStartDateBefore` | `where x.startDate < ?1` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| `IsNull` | `findByAgeIsNull` | `where x.age is null` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| `IsNotNull`, `NotNull` | `findByAge`(`Is`)`NotNull` | `where x.age is not
    null` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| `Like` | `findByFirstNameLike` | `where x.firstname like ?1` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| `NotLike` | `findByFirstNameNotLike` | `where x.firstname not like ?1` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| `StartingWith` | `findByFirstNameStartingWith` | `where x.firstname like
    ?1` (parameter bound with appended `%`) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| `EndingWith` | `findByFirstNameEndingWith` | `where x.firstname like ?1`
    (parameter bound with prepended `%`) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| `Containing` | `findByFirstNameContaining` | `where x.firstname like ?1`
    (parameter bound wrapped in `%`) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| `OrderBy` | `findByAgeOrderByLastNameDesc` | `where x.age = ?1 order by x.lastname
    desc` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| `Not` | `findByLastNameNot` | `where x.lastname <> ?1` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| `In` | `findByAgeIn` (Collection<Age> ages) | `where x.age in ?1` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| `NotIn` | `findByAgeNotIn` (Collection<Age> ages) | `where x.age not in ?1`
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| `True` | `findByActiveTrue` | `where x.active = true` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| `False` | `findByActiveFalse` | `where x.active = false` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: Implementing the search function
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is time to use the skills we have learned and add the search function to
    our contact manager application. We can implement the search function by following
    these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: We add a query method to the `ContactRepository` interface by following the
    described naming convention.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement a service method that uses the query method.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we have to create the query method. The signature of our query method
    is given as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Second, we have to add the `search()` method to the `RepositoryContactService`
    class. This method simply delegates the method call to the repository and gives
    the used search term as a parameter. The source code of the implemented method
    is given as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们必须将`search()`方法添加到`RepositoryContactService`类中。这个方法简单地将方法调用委托给存储库，并将使用的搜索词作为参数。实现方法的源代码如下：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pros and cons
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: 'We have now learned how we can create queries by using the query generation
    from the method name strategy. The pros and cons of this strategy are described
    in the following table:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何使用方法名称策略生成查询。这种策略的优缺点在下表中描述：
- en: '| Pros | Cons |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: It is a fast way to create simple queries
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是创建简单查询的快速方法
- en: It provides a consistent naming strategy for method names
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为方法名称提供了一致的命名策略
- en: '|'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The features of the method name parser decide what kind of queries we can create
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称解析器的特性决定了我们可以创建什么样的查询
- en: The method names of complicated query methods are long and ugly
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂查询方法的方法名称又长又难看
- en: Queries are verified at runtime
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询在运行时进行验证
- en: No support for dynamic queries
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持动态查询
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: One good example about the limitations of the method name parser is the lack
    of the `Lower` keyword. This means that we cannot implement a case insensitive
    search by using this strategy. Next we will learn alternative strategies for creating
    queries that do not suffer from this restriction.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称解析器的限制的一个很好的例子是缺少`Lower`关键字。这意味着我们无法通过使用这种策略来实现不区分大小写的搜索。接下来我们将学习创建不受此限制的查询的替代策略。
- en: Named queries
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名查询
- en: 'A second way to create query methods with Spring Data JPA is to use named queries.
    If we want to create a query method with a named query, we have to:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Data JPA创建查询方法的第二种方法是使用命名查询。如果我们想要使用命名查询创建查询方法，我们必须：
- en: Create a named query.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个命名查询。
- en: Create a query method that executes the named query.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建执行命名查询的查询方法。
- en: Create a service method that uses the created query method.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用创建的查询方法的服务方法。
- en: These steps are described with more details in following section. We will also
    discuss the pros and cons of named queries.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在下一节中有更详细的描述。我们还将讨论命名查询的优缺点。
- en: Creating a named query
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建命名查询
- en: Spring Data JPA supports named queries that are created by using either JPQL
    or SQL. The selection of the used query language determines how the created named
    query is declared.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA支持使用JPQL或SQL创建的命名查询。所使用的查询语言的选择决定了创建的命名查询是如何声明的。
- en: 'We can create a JPA named query by following these steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤创建一个JPA命名查询：
- en: We add the `@NamedQueries` annotation to an entity class. This annotation takes
    an array of `@NamedQuery` annotations as its value, and it must be used if we
    specify more than one named query
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`@NamedQueries`注解添加到实体类中。这个注解以`@NamedQuery`注解的数组作为其值，并且如果我们指定了多个命名查询，必须使用它
- en: 'We use the `@NamedQuery` annotation for creating the named query. This annotation
    has two properties that are relevant to us: the `name` property stores the name
    of the named query, and the `query` property contains the executed JPQL query.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`@NamedQuery`注解来创建命名查询。这个注解有两个对我们有关系的属性：`name`属性存储了命名查询的名称，`query`属性包含了执行的JPQL查询。
- en: 'The declaration of our named query, which uses JPQL, is given as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的使用JPQL的命名查询的声明如下：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can also use XML for declaring named queries. In this case, we must use the
    `named-query` element and declare the query in an entity mapping XML file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用XML声明命名查询。在这种情况下，我们必须使用`named-query`元素，并在实体映射XML文件中声明查询。
- en: 'We can create a named native query by following these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤创建一个命名的本地查询：
- en: We add the `@NamedNativeQueries` annotation to an entity class. This annotation
    accepts an array of `@NamedNativeQuery` annotations as its value, and it must
    be used if we specify more than one native named query.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`@NamedNativeQueries`注解添加到实体类中。这个注解接受`@NamedNativeQuery`注解的数组作为其值，并且如果我们指定了多个本地命名查询，必须使用它。
- en: We create the native named query by using the `@NamedNativeQuery` annotation.
    The name of the created native named query is stored in the `name` property. The
    value of the `query` property is the executed SQL query. The `resultClass` property
    contains an entity class that is returned by the query.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使用`@NamedNativeQuery`注解来创建本地命名查询。创建的本地命名查询的名称存储在`name`属性中。`query`属性的值是执行的SQL查询。`resultClass`属性包含了查询返回的实体类。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the named native query does not return an entity or a list of entities, we
    can map the query result to a correct return type by using the `@SqlResultSetM`
    `apping` annotation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命名本地查询不返回实体或实体列表，我们可以使用`@SqlResultSetMapping`注解将查询结果映射到正确的返回类型。
- en: 'The declaration of our named native query looks like the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的命名本地查询的声明如下代码片段：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can also use XML for creating named native queries. In this case, we must
    use the `named-native-query` element and declare the SQL query in an entity mapping
    XML file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用XML创建命名本地查询。在这种情况下，我们必须使用`named-native-query`元素，并在实体映射XML文件中声明SQL查询。
- en: Creating the query method
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建查询方法
- en: 'Our next step is to add the query method to the contact repository. We will
    have to:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是将查询方法添加到联系人存储库中。我们将不得不：
- en: Determine the correct name for the query method. Spring Data JPA resolves method
    names back to named queries by pretending the simple name of the managed entity
    and a dot to the method name. The name of our named query is `Contact.findContacts`.
    Thus, we have to add a method called `findContacts` to the `ContactRepository`
    interface.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定查询方法的正确名称。Spring Data JPA通过假装托管实体的简单名称和方法名称之间的点来将方法名称解析回命名查询。我们的命名查询的名称是`Contact.findContacts`。因此，我们必须在`ContactRepository`接口中添加一个名为`findContacts`的方法。
- en: Use the `@Param` annotation to identify the method parameter as a value of the
    named parameter that is used in our queries.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@Param`注解将方法参数标识为我们查询中使用的命名参数的值。
- en: 'The signature of the added query method is given as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的查询方法的签名如下所示：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating the service method
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建服务方法
- en: 'Next we have to add the `search()` method to the `RepositoryContactService`
    class. Our implementation consists of the following steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须将`search()`方法添加到`RepositoryContactService`类中。我们的实现包括以下步骤：
- en: We build the used like pattern.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建使用的like模式。
- en: We fetch the search results by calling the created query method.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用创建的查询方法来获取搜索结果。
- en: 'The source code of the `search()` method is given as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`search()`方法的源代码如下：'
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Pros and cons
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优缺点
- en: 'We are now capable of creating query methods by using named queries. The pros
    and cons of this approach are described in the following table:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用命名查询来创建查询方法。这种方法的优缺点在下表中描述：
- en: '| Pros | Cons |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Supports both JPQL and SQL
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持JPQL和SQL
- en: Makes it easier to migrate existing applications using named queries to Spring
    Data JPA
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使得迁移现有应用程序使用命名查询到Spring Data JPA更容易
- en: The return type of native queries is not restricted to entities or to the list
    of entities
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地查询的返回类型不限于实体或实体列表
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Query validation is done at runtime
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询验证在运行时完成
- en: No support for dynamic queries
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持动态查询
- en: The query logic litters the code of our entity classes
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询逻辑使我们的实体类的代码混乱
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '@Query annotation'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Query注解'
- en: 'The `@Query` annotation is used to specify the query that is executed when
    a query method is called. We can implement both JPQL and SQL queries with the
    `@Query` annotation by:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Query`注解用于指定调用查询方法时执行的查询。我们可以使用`@Query`注解来实现JPQL和SQL查询：'
- en: Adding a new method of a repository and annotating it with the `@Query` annotation.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向存储库添加一个新的方法，并用`@Query`注解进行注释。
- en: Creating the service method, which uses the query method.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建使用查询方法的服务方法。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the method name of the method annotated with the `@Query` annotation conflicts
    with the name of a named query, the annotated query will be executed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`@Query`注解的方法名称与命名查询的名称冲突，则将执行注解的查询。
- en: Next we will get concrete instructions that will guide us through the described
    steps and find out the pros and cons of this technique.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将得到具体的指导说明，以指导我们完成所描述的步骤，并了解这种技术的优缺点。
- en: Creating the query method
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建查询方法
- en: First we must add the query method to the `ContactRepository` class. As we already
    know, we can create the actual query by using either JPQL or SQL. The selection
    of the used query language has some effects on the creation of the query methods.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们必须将查询方法添加到`ContactRepository`类中。正如我们已经知道的，我们可以使用JPQL或SQL来创建实际的查询。使用的查询语言对查询方法的创建有一些影响。
- en: 'We can create a query method that uses JPQL by:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式创建使用JPQL的查询方法：
- en: Adding a new method to the `ContactRepository` interface.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`ContactRepository`接口添加一个新的方法。
- en: Using the `@Param` annotation to identify the parameter of the method as the
    value of the named parameter.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@Param`注解将方法的参数标识为命名参数的值。
- en: Annotating the method with the `@Query` annotation and setting the executed
    JPQL query as its value.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`@Query`注解注释方法，并将执行的JPQL查询设置为其值。
- en: 'The declaration of our query method, which fulfills the requirements of the
    search function, is given as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的查询方法的声明，满足搜索功能的要求，如下所示：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to create a query method that uses SQL, we have to:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个使用SQL的查询方法，我们必须：
- en: Add a new method to the `ContactRepository` interface.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`ContactRepository`接口添加一个新的方法。
- en: Identify the method parameter as a value of the named parameter used in the
    SQL query by using the `@Param` annotation.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@Param`注解将方法参数标识为SQL查询中使用的命名参数的值。
- en: Annotate the created method with the `@Query` annotation and set the SQL query
    as its value. Set the value of the `nativeQuery` property to true.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`@Query`注解注释创建的方法，并将SQL查询设置为其值。将`nativeQuery`属性的值设置为true。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A native query created with the `@Query` annotation can return only entities
    or list of entities. If we need a different return type, we must use a named query
    and map the query result by using the `@SqlResultSetMapping` annotation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Query`注解创建的本地查询只能返回实体或实体列表。如果我们需要不同的返回类型，必须使用命名查询，并使用`@SqlResultSetMapping`注解映射查询结果。
- en: 'The declaration of our query method, which implements the requirements of the
    search function, looks like the following code snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 实现满足搜索功能要求的查询方法的声明如下代码片段所示：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Spring Data JPA does not provide dynamic sorting or pagination support for native
    queries created with `@Query` annotation because there is no reliable way to manipulate
    SQL queries.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA不支持使用`@Query`注解创建的本地查询的动态排序或分页支持，因为没有可靠的方法来操作SQL查询。
- en: Creating the service method
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建服务方法
- en: 'Our next step is to add an implementation of the `search()` method to the `RepositoryContactService`
    class. We can do this by:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是向`RepositoryContactService`类添加`search()`方法的实现。我们可以通过以下方式实现：
- en: Getting the used like pattern.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取使用的like模式。
- en: Fetching the search results by calling the created query method.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用创建的查询方法来获取搜索结果。
- en: 'The source code of the implemented `search()` method is given as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '实现的`search()`方法的源代码如下： '
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Pros and cons
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优缺点
- en: 'We have now learned how we can use the `@Query` annotation for creating query
    methods. This approach naturally has both pros and cons that are described in
    the following table:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何使用`@Query`注解来创建查询方法。这种方法自然地具有优缺点，如下表所述：
- en: '| Pros | Cons |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Supports both JPQL and SQL
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持JPQL和SQL
- en: No naming convention for method names
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称没有命名约定
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Native queries can return only entities or a list of entities
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地查询只能返回实体或实体列表
- en: No support for dynamic queries
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持动态查询
- en: Query validation is done at runtime
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询验证在运行时完成
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: JPA Criteria API
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JPA Criteria API
- en: 'The JPA Criteria API provides us with a way to create dynamic and type-safe
    queries in an object-oriented manner. We can create **criteria queries** by following
    these steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: JPA Criteria API为我们提供了以面向对象的方式创建动态和类型安全查询的方法。我们可以通过以下步骤创建**条件查询**：
- en: We add JPA Criteria API support to a repository.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向存储库添加JPA Criteria API支持。
- en: We create the executed criteria query.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了执行的条件查询。
- en: We create a service method that executes the created query.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个执行创建的查询的服务方法。
- en: These steps, and the pros and cons of using the JPA criteria API, are described
    in the following section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤以及使用JPA Criteria API的优缺点将在以下部分中描述。
- en: Adding the JPA Criteria API support to a repository
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将JPA Criteria API支持添加到存储库
- en: 'We can add JPA Criteria API support to a repository by extending the `JpaSpecificationExecutor<T>`
    interface. When we extend this interface, we must give the type of the managed
    entity as a type parameter. The source code of the `ContactRepository` interface
    is given as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过扩展`JpaSpecificationExecutor<T>`接口向存储库添加JPA Criteria API支持。当我们扩展这个接口时，我们必须将受管实体的类型作为类型参数给出。`ContactRepository`接口的源代码如下所示：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Extending the `JpaSpecificationExecutor<T>` interface gives us access to the
    following methods that can be used to execute criteria queries:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`JpaSpecificationExecutor<T>`接口使我们可以访问以下方法，这些方法可用于执行条件查询：
- en: '| Method | Description |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `long count(Specification<Contact> s)` | Returns the number of entities matching
    with the given search criteria. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: 返回与给定搜索条件匹配的实体数量。
- en: '| `List<Contact> findAll(Specification<Contact> s)` | Returns all entities
    matching with the given search criteria. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `List<Contact> findAll(Specification<Contact> s)` | 返回与给定搜索条件匹配的所有实体。 |'
- en: '| `Contact findOne(Specification<Contact> s)` | Returns a single contact matching
    with the given search criteria. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: 返回与给定搜索条件匹配的单个联系人。
- en: Creating the criteria query
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建条件查询
- en: As we have learned, Spring Data JPA uses the `Specification<T>` interface for
    specifying the criteria query. This interface declares the `Predicate toPredicate(Root<T>
    root, CriteriaQuery<?> query, CriteriaBuilder cb)` method that we can use to create
    the executed criteria query.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，Spring Data JPA使用`Specification<T>`接口来指定条件查询。这个接口声明了`Predicate toPredicate(Root<T>
    root, CriteriaQuery<?> query, CriteriaBuilder cb)`方法，我们可以使用它来创建执行的条件查询。
- en: 'In order to create criteria queries for the `Contact` entity, we have to:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为`Contact`实体创建条件查询，我们必须：
- en: Create a static metamodel class for the `Contact` entity.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Contact`实体创建一个静态元模型类。
- en: Create a way to build `Specification<Contact>` objects.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建构建`Specification<Contact>`对象的方法。
- en: Creating a static metamodel class
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建静态元模型类
- en: 'Static metamodel classes provide static access to the metadata that describes
    the attributes of entities, and they are used to create type-safe queries with
    JPA Criteria API. Static metamodel classes are typically generated automatically
    but in here we will create one manually for the sake of an example. We can create
    a static metamodel class by following these rules:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 静态元模型类提供对描述实体属性的元数据的静态访问，并用于使用JPA Criteria API创建类型安全查询。静态元模型类通常是自动生成的，但在这里，我们将为了示例而手动创建一个。我们可以通过遵循以下规则创建一个静态元模型类：
- en: A static metamodel class should be placed in the same package than the corresponding
    entity
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态元模型类应放置在与相应实体相同的包中
- en: The name of a static metamodel class is created by appending an underscore character
    to the simple name of the corresponding entity
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态元模型类的名称是通过在相应实体的简单名称后附加下划线字符来创建的
- en: 'Since we are using only the `firstName` and `lastName` properties of the `Contact`
    entity when building our criteria query, we can ignore the other attributes. The
    source code of the `Contact_` class looks like the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在构建条件查询时只使用`Contact`实体的`firstName`和`lastName`属性，我们可以忽略其他属性。`Contact_`类的源代码如下所示：
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating specifications
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建规范
- en: 'We can create specifications in a clean manner by creating a specification
    builder class and use static method to build the actual specifications. The logic
    used to build the needed like pattern is also moved to this class. Our implementation
    of the specification builder class is explained in the following steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个规范构建器类并使用静态方法来构建实际的规范，以清晰的方式创建规范。用于构建所需like模式的逻辑也移动到了这个类中。我们规范构建器类的实现在以下步骤中解释：
- en: We create a `getLikePattern()` method that is used to create the like pattern
    from the search term.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`getLikePattern()`方法，用于从搜索词创建like模式。
- en: We create a static `firstOrLastNameStartsWith()` method that returns a new `Specification<Contact>`
    object.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个静态的`firstOrLastNameStartsWith()`方法，返回一个新的`Specification<Contact>`对象。
- en: We build the criteria query in the `toPredicate()` method of the `Specification<Contact>`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`Specification<Contact>`的`toPredicate()`方法中构建条件查询。
- en: 'The source code of our specification builder class is given as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的规范构建器类的源代码如下所示：
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating the service method
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建服务方法
- en: 'Our implementation of the `search()` method of the `RepositoryContactService`
    class contains the following two steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`RepositoryContactService`类的`search()`方法的实现包含以下两个步骤：
- en: We obtain the `Specification<Contact>` object by using our specification builder.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使用我们的规范构建器获得`Specification<Contact>`对象。
- en: We get the search results by calling the `findAll()` method of the repository
    and passing the `Specification<Contact>` object as a parameter.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过调用存储库的`findAll()`方法并将`Specification<Contact>`对象作为参数传递来获取搜索结果。
- en: 'The source code of our implementation is given as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现的源代码如下所示：
- en: '[PRE13]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Pros and cons
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优缺点
- en: 'We have now learned how we can implement dynamic queries by using the JPA Criteria
    API. Before we can use these skills in real-world applications, we should be aware
    of the pros and cons of this approach. These are described in the following table:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何使用JPA Criteria API实现动态查询。在我们可以在实际应用程序中使用这些技能之前，我们应该了解这种方法的优缺点。这些在下表中描述：
- en: '| Pros | Cons |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Supports dynamic queries
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持动态查询
- en: Syntax verification is done during compilation
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法验证在编译期间完成
- en: Makes it easier to migrate applications using the JPA Criteria API to Spring
    Data JPA
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使得迁移使用JPA Criteria API的应用程序到Spring Data JPA更容易
- en: '|'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Complex queries are hard to implement and understand
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂查询难以实现和理解
- en: '|'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Querydsl
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Querydsl
- en: '**Querydsl** is a framework that enables the construction of type-safe dynamic
    queries through an API that resembles SQL (to learn more on Querydsl, visit [http://www.querydsl.com/](http://www.querydsl.com/)).
    If we want to create queries by using Querydsl, we have to:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**Querydsl**是一个框架，通过类似SQL的API实现类型安全的动态查询的构建（要了解更多关于Querydsl的信息，请访问[http://www.querydsl.com/](http://www.querydsl.com/)）。如果我们想使用Querydsl创建查询，我们必须：'
- en: Configure Querydsl Maven Integration.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Querydsl Maven集成。
- en: Generate Querydsl query type.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成Querydsl查询类型。
- en: Add Querydsl support to a repository.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向存储库添加Querydsl支持。
- en: Create the executed query.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建执行的查询。
- en: Execute the created query.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行创建的查询。
- en: We will explain these steps in more detail in the following section and we will
    also take a look of the pros and cons of Querydsl.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更详细地解释这些步骤，并且我们还将看一下Querydsl的优缺点。
- en: Configuring Querydsl-Maven integration
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Querydsl-Maven集成
- en: 'The configuration of the Querydsl-Maven integration consist of two steps:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Querydsl-Maven集成的配置包括两个步骤：
- en: We configure the needed dependencies.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们配置所需的依赖项。
- en: We configure the APT Maven plugin that is used for code generation.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们配置用于代码生成的APT Maven插件。
- en: Configuring Querydsl Maven dependencies
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置Querydsl Maven依赖项
- en: 'Because we are using Querydsl with JPA, we have to declare the following dependencies
    in the `pom.xml` file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在使用Querydsl与JPA，所以必须在`pom.xml`文件中声明以下依赖项：
- en: Querydsl core that provides the core functions of Querydsl
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供Querydsl核心，提供Querydsl的核心功能
- en: Querydsl APT, which provides support for APT based code generation
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Querydsl APT，提供基于APT的代码生成支持
- en: Querydsl JPA, that adds support for JPA annotations
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Querydsl JPA，为JPA注解添加支持
- en: 'We are using the Querydsl version 2.8.0\. Thus, we have to add the following
    dependency declarations to the dependencies section of the `pom.xml` file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Querydsl版本2.8.0。因此，我们必须将以下依赖声明添加到`pom.xml`文件的依赖项部分：
- en: '[PRE14]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Configuring the code generation Maven plugin
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置代码生成Maven插件
- en: 'Our next step is to configure the Maven plugin of the Annotation Processing
    Tool of Java 6, which is used to generate the Querydsl query types. We can configure
    this plugin by:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是配置Java 6的注解处理工具的Maven插件，用于生成Querydsl查询类型。我们可以通过以下方式配置此插件：
- en: Configuring the plugin to execute its `process` goal in Maven's `generate-sources`
    lifecycle phase.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置插件以在Maven的`generate-sources`生命周期阶段执行其`process`目标。
- en: Specifying the target directory in which the query types are generated.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定生成查询类型的目标目录。
- en: Configuring the code generator to look for JPA annotations from entity classes.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置代码生成器以查找实体类的JPA注解。
- en: 'The configuration of the Maven APT plugin is given as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Maven APT插件的配置如下：
- en: '[PRE15]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Generating Querydsl query types
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成Querydsl查询类型
- en: If our configuration is working properly, Querydsl query types should be generated
    automatically when we build our project with Maven.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的配置正常工作，使用Maven构建项目时，Querydsl查询类型应该会自动生成。
- en: Note
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Maven APT plugin has a known issue that prevents its usage directly from
    Eclipse. Eclipse users must create the Querydsl query types manually by running
    the command `mvn generate-sources` at command prompt.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Maven APT插件存在一个已知问题，阻止直接从Eclipse使用它。Eclipse用户必须通过在命令提示符下运行命令`mvn generate-sources`来手动创建Querydsl查询类型。
- en: 'The query types are found from the `target/generated-sources` directory. The
    following rules will apply for the generated query types:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 查询类型可以从`target/generated-sources`目录中找到。生成的查询类型将适用以下规则：
- en: Each query type is generated in the same package as the corresponding entity.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个查询类型都生成在与相应实体相同的包中。
- en: The name of a query type class is built by appending the simple name of the
    entity class to a letter "`Q`". For example, since the name of our entity class
    is `Contac`t, the name of the corresponding Querydsl query type is `QContact`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询类型类的名称是通过将实体类的简单名称附加到字母"`Q`"来构建的。例如，由于我们的实体类的名称是`Contact`，相应的Querydsl查询类型的名称是`QContact`。
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before we can use the query types in our code, we must add the `target/generated-sources`
    directory as a source directory of our project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中使用查询类型之前，我们必须将`target/generated-sources`目录添加为项目的源目录。
- en: Adding Querydsl support to a repository
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向存储库添加Querydsl支持
- en: 'We can add Querydsl support to a repository by extending the `QueryDslPredicateExecutor<T>`
    interface. When we extend this interface we must give the type of the managed
    entity as a type parameter. The source code of the `ContactRepository` interface
    is given as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过扩展`QueryDslPredicateExecutor<T>`接口来向存储库添加Querydsl支持。当我们扩展此接口时，必须将托管实体的类型作为类型参数给出。`ContactRepository`接口的源代码如下：
- en: '[PRE16]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After we have extended the `QueryDslPredicateExecutor<T>` interface, we have
    access to the following methods:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们扩展了`QueryDslPredicateExecutor<T>`接口之后，我们可以访问以下方法：
- en: '| Method | Description |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `long count(Predicate p)` | Returns the number of entities matching with
    the given search criteria. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `long count(Predicate p)` | 返回与给定搜索条件匹配的实体数量。 |'
- en: '| `Iterable<Contact> findAll(Predicate p)` | Returns all entities matching
    with the given search criteria. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `Iterable<Contact> findAll(Predicate p)` | 返回与给定搜索条件匹配的所有实体。 |'
- en: '| `Contact findOne(Predicate p)` | Returns a single entity matching with the
    given search criteria. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `Contact findOne(Predicate p)` | 返回与给定搜索条件匹配的单个实体。 |'
- en: Creating the executed query
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建执行的查询
- en: 'Each query must implement the `Predicate` interface that is provided by Querydsl.
    Luckily, we don''t have to implement this interface manually. Instead, we can
    use the query types for creating the actual query objects. A clean way to do this
    is to create a special predicate builder class and use a static method for creating
    the actual predicates. Let''s call this class `ContactPredicates`. Our implementation
    of the static method that creates predicates fulfilling the requirements of the
    search function is explained as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 每个查询必须实现Querydsl提供的`Predicate`接口。幸运的是，我们不必手动实现这个接口。相反，我们可以使用查询类型来创建实际的查询对象。一个清晰的方法是创建一个特殊的predicate构建器类，并使用静态方法来创建实际的predicates。让我们称这个类为`ContactPredicates`。我们实现了创建满足搜索功能要求的predicates的静态方法，如下所述：
- en: We implement a static `firstOrLastNameStartsWith()` method that returns an implementation
    of the `Predicate` interface.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个静态的`firstOrLastNameStartsWith()`方法，返回`Predicate`接口的实现。
- en: We get a reference to the `QContact` query type.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获得了`QContact`查询类型的引用。
- en: We build our query by using the `QContact` query type.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`QContact`查询类型构建我们的查询。
- en: 'The source code of our predicate builder class is given as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的predicate构建器类的源代码如下：
- en: '[PRE17]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Executing the created query
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行创建的查询
- en: 'We have implemented the `search()` method of the `RepositoryContactService`
    class by:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下方式实现了`RepositoryContactService`类的`search()`方法：
- en: Getting the used predicate by calling the static `firstOrLastNAmeStartsWith()`
    method of the `ContactPredicates` class.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`ContactPredicates`类的静态`firstOrLastNAmeStartsWith()`方法获取使用的predicate。
- en: Getting results by calling our repository method and passing the predicate as
    a parameter.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用我们的存储库方法并将predicate作为参数传递来获取结果。
- en: Using the `CollectionUtils` class found from the `Commons Collections` library
    to add every contact to the returned list.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Commons Collections`库中的`CollectionUtils`类将每个联系人添加到返回的列表中。
- en: 'The source code of our implementation is given as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现源代码如下：
- en: '[PRE18]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Pros and cons
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: 'We are now capable of creating queries by using Spring Data JPA and Querydsl.
    The pros and cons of Querydsl are described in the following table:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够使用Spring Data JPA和Querydsl创建查询。Querydsl的优缺点如下表所述：
- en: '| Pros | Cons |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Supports dynamic queries
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持动态查询
- en: Clean and understandable API
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰易懂的API
- en: Syntax verification is done during compilation
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法验证在编译期间完成
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Requires code generation
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要代码生成
- en: Eclipse integration is not working properly
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse集成工作不正常
- en: '|'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: What technique should we use?
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们应该使用哪种技术？
- en: 'In the course of this section, we have been discussing different ways to create
    queries with Spring Data JPA. We are also aware of the pros and cons of each described
    technique. This information is refined to concrete guidelines that are given in
    the following list:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经讨论了使用Spring Data JPA创建查询的不同方法。我们也意识到了每种描述的技术的优缺点。这些信息被细化为以下列表中给出的具体指南：
- en: We should use query methods for creating static queries.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该使用查询方法创建静态查询。
- en: We can use the query generation from method name strategy if the created query
    is simple and the method name parser supports the required keywords. Otherwise,
    we should use the `@Query` annotation because of its flexibility and because it
    does not force us to use long and ugly method names.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果创建的查询简单且方法名解析器支持所需的关键字，我们可以使用方法名策略生成查询。否则，我们应该使用`@Query`注解，因为它灵活，并且不强制我们使用冗长且丑陋的方法名。
- en: Named queries are useful if we cannot create our query method by using the query
    generation from the method strategy or the `@Query` annotation. This approach
    can also be useful if we are migrating an existing application to Spring Data
    JPA. However, we should use them sparingly when we are creating new applications
    because they tend to litter our entities with query logic.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们无法使用方法策略生成查询或`@Query`注解创建查询方法，命名查询是有用的。这种方法也可以在将现有应用程序迁移到Spring Data JPA时使用。然而，当我们创建新应用程序时，应该谨慎使用它们，因为它们倾向于在我们的实体中添加查询逻辑。
- en: Native queries are useful if we cannot create the query by using the other described
    techniques or if we need to tune up the performance of an individual query. However,
    we must understand that using native queries creates a dependency between our
    application and the used database schema. Also, if we use provider specific SQL
    extensions, our application is tied to the used database provider.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们无法使用其他描述的技术创建查询，或者需要调整单个查询的性能，原生查询是有用的。然而，我们必须理解使用原生查询会在我们的应用程序和使用的数据库模式之间创建依赖关系。此外，如果我们使用特定于提供程序的SQL扩展，我们的应用程序将与使用的数据库提供程序绑定。
- en: We should use the JPA Criteria API for creating dynamic queries if we are migrating
    an existing application that uses criteria queries to Spring Data JPA. The JPA
    Criteria API is also a valid option if we cannot live with the problems of the
    Querydsl-Eclipse integration.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们正在将使用criteria查询的现有应用程序迁移到Spring Data JPA，应该使用JPA Criteria API来创建动态查询。如果我们无法忍受Querydsl-Eclipse集成的问题，JPA
    Criteria API也是一个有效的选择。
- en: Querydsl is a great choice for creating dynamic queries. It provides a clean
    and readable API, which is a huge benefit over the JPA Criteria API. Querydsl
    should be our first choice for creating dynamic queries from a scratch. The clumsy
    Eclipse integration is naturally a downside for Eclipse users.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Querydsl是创建动态查询的绝佳选择。它提供了一个清晰易懂的API，这是JPA Criteria API的巨大优势。Querydsl应该是我们从头开始创建动态查询的首选。笨拙的Eclipse集成自然是Eclipse用户的缺点。
- en: Sorting query results
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序查询结果
- en: In the course of this section, we will learn different techniques that can be
    used to sort query results with Spring Data JPA. We will also learn the guidelines
    that we can use to select a proper sorting method for each situation.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课程中，我们将学习使用Spring Data JPA对查询结果进行排序的不同技术。我们还将学习可以用于为每种情况选择适当排序方法的准则。
- en: Sorting with method name
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法名进行排序
- en: 'If we are building our queries by using the query generation from the method
    name strategy, we can sort query results by the following steps:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用从方法名生成查询的策略构建查询，我们可以按照以下步骤对查询结果进行排序：
- en: Creating a query method
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建查询方法
- en: Modifying an existing service method to use the new query method.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改现有的服务方法以使用新的查询方法。
- en: Creating the query method
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建查询方法
- en: 'When we are building our queries by using the query generation from the method
    name strategy, we can use the `OrderBy` keyword to sort the query results when
    we:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用从方法名生成查询的策略构建查询时，我们可以使用`OrderBy`关键字来对查询结果进行排序，当我们：
- en: Append the `OrderBy` keyword to the method name.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`OrderBy`关键字附加到方法名。
- en: Append the property expression that corresponds to the property of the entity,
    which is used to sort the query results, to the method name.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将与实体属性对应的属性表达式附加到方法名，用于对查询结果进行排序。
- en: Append a keyword describing the sorting order to the method name. If the query
    results are sorted in ascending order, the keyword `Asc` should be used. `Desc`
    keyword is used when the query results are sorted in descending order.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将描述排序顺序的关键字附加到方法名。如果查询结果按升序排序，则应使用关键字`Asc`。当查询结果按降序排序时，使用`Desc`关键字。
- en: Repeat step 2 and step 3 if more than one property is used to sort the query
    results.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用多个属性对查询结果进行排序，则重复步骤2和步骤3。
- en: 'We can fulfill the new requirement of the search function by appending the
    string `OrderByLastNameAscFirstNameAsc` to the name of our query method. The signature
    of our query method is given as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在查询方法的名称后附加字符串`OrderByLastNameAscFirstNameAsc`来满足搜索功能的新要求。查询方法的签名如下：
- en: '[PRE19]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Modifying the service method
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改服务方法
- en: 'We have to modify the `search()` method of the `RepositoryContactService` class
    to delegate the method call forward to the new query method. The source code of
    this method is given as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须修改`RepositoryContactService`类的`search()`方法，以将方法调用委托给新的查询方法。该方法的源代码如下：
- en: '[PRE20]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Sorting with query strings
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用查询字符串进行排序
- en: In some cases, we have to add the sorting logic to the actual query string.
    If we are using named queries or native queries with the `@Query` annotation,
    we must provide the sorting logic in the actual query. It is also possible to
    add sorting logic to the actual query when we are using `@Query` annotation with
    JPQL queries.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们必须将排序逻辑添加到实际的查询字符串中。如果我们使用带有`@Query`注解的命名查询或本地查询，我们必须在实际查询中提供排序逻辑。当我们使用带有JPQL查询的`@Query`注解时，也可以将排序逻辑添加到实际查询中。
- en: JPQL queries
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JPQL查询
- en: 'When we want to sort the query results of a JPQL query, we must use the `ORDER
    BY` keyword of JPQL. The JPQL query that fulfills the new requirement of the search
    function is given as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想对JPQL查询的查询结果进行排序时，必须使用JPQL的`ORDER BY`关键字。满足搜索功能的JPQL查询如下所示：
- en: '[PRE21]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: SQL queries
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL查询
- en: 'When we want to sort the query results of native SQL queries, we must use the
    `ORDER BY` keyword of SQL. The SQL query fulfilling the new requirement of the
    search function is given as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想对本地SQL查询的查询结果进行排序时，必须使用SQL的`ORDER BY`关键字。满足搜索功能的SQL查询如下所示：
- en: '[PRE22]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sorting with the Sort class
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sort类进行排序
- en: 'If we are using the methods of the `JpaRepository<T,ID>` interface, query methods,
    or the JPA Criteria API, we can use the `Sort` class for sorting query results.
    If we decide to use this approach, we have to:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`JpaRepository<T,ID>`接口的方法、查询方法或JPA Criteria API，我们可以使用`Sort`类对查询结果进行排序。如果我们决定使用这种方法，我们必须：
- en: Create an instance of the `Sort` class.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Sort`类的实例。
- en: Pass the created instance as a parameter to the used repository method.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建的实例作为参数传递给所使用的存储库方法。
- en: Note
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We cannot use the `Sort` class to sort the query results of named queries or
    native queries declared with `@Query` annotation.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用`Sort`类对带有`@Query`注解声明的命名查询或本地查询的查询结果进行排序。
- en: 'Since all the techniques that are described later need to get an instance of
    the `Sort` class, we will have to add a way to create these objects to the `RepositoryContactService`
    class. We will do this by creating a private `sortByLastNameAndFirstNameAsc()`
    method. The source code of this method is given as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 由于后面描述的所有技术都需要获得`Sort`类的实例，我们将不得不为`RepositoryContactService`类添加一种创建这些对象的方法。我们将通过创建一个私有的`sortByLastNameAndFirstNameAsc()`方法来实现这一点。该方法的源代码如下：
- en: '[PRE23]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: JpaRepository
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JpaRepository
- en: We used the `findAll()` method of the `JpaRepository<T,ID>` interface to get
    a list of all the entities stored to the database. However, when we extended the
    `JpaRepository<T,ID>` interface, we also got access to the `List<Contact> findAll(Sort
    sort`) method which we can use to sort a list of entities that are stored to a
    database.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`JpaRepository<T,ID>`接口的`findAll()`方法来获取存储在数据库中的所有实体的列表。然而，当我们扩展了`JpaRepository<T,ID>`接口时，我们还可以访问`List<Contact>
    findAll(Sort sort)`方法，我们可以使用它来对存储在数据库中的实体列表进行排序。
- en: 'As an example, we are going to sort the list of all the entities in ascending
    order by using last name and first name. We can do this by:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，我们将按照姓氏和名字的字母顺序对所有实体的列表进行排序。我们可以通过以下方式实现：
- en: Getting a new `Sort` object.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个新的`Sort`对象。
- en: Getting the sorted list of entities by calling the `findAll()` method of our
    repository and passing the created `Sort` object as a parameter.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用我们的存储库的`findAll()`方法并将创建的`Sort`对象作为参数传递来获取排序后的实体列表。
- en: 'The source code of the `findAll()` method of the `RepositoryContactService`
    is given as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepositoryContactService`的`findAll()`方法的源代码如下：'
- en: '[PRE24]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Query generation from the method name
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从方法名生成查询
- en: 'We can also use this approach for sorting the query results of queries that
    are created by using the query generation from the method name strategy. If we
    want to use this technique, we have to modify the signature of our query method
    to take a `Sort` object as a parameter. The signature of our query method, which
    implements the new sorting requirement of the search function, is given as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our next step is to change the implementation of the `search()` method of the
    `RepositoryContactService` class. The new implementation is explained in the following
    steps:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: We get a reference to a `Sort` object.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call our new repository method and provide the needed parameters.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our implementation is given as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '@Query annotation'
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We don''t have to add the sorting logic to the actual query if we are using
    the `@Query` annotation for building queries with JPQL. We can also modify the
    signature of our query method to take a `Sort` object as a parameter. The declaration
    of our query method is given as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next step is to modify the `search()` method to the `RepositoryContactService`
    class. Our implementation of this method is described as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: We create the used like pattern.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get a reference to a `Sort` object.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call our repository method and provide the needed parameters.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `search()` method looks like the following code:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: JPA Criteria API
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to create queries by using JPA Criteria API, we had to modify the `ContactRepository`
    interface to extend the `JpaSpecificationExecutor<T>` interface. This gives us
    access to the `List<Contact> findAll(Specification spec, Sort sort)` method that
    returns a sorted list of entities matching the given search conditions.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation of the `search()` method of the `RepositoryContactService`
    class is described as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: We get the used search criteria by using our specification builder class.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the used `Sort` object.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will call the `findAll()` method of the `ContactRepository` and provide the
    necessary parameters.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our `search()` method is given as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sorting with Querydsl
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extending the `QuerydslPredicateExecutor<T>` interface in our contact repository
    gave us access to the `Iterable<Contact> findAll(Predicate predicate, OrderSpecifier<?>...
    orders)` method that returns a sorted list of all entities that match with the
    given search criteria.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create a service method that creates an array of `OrderSpecifier`
    objects. The source code of the `sortByLastNameAndFirstNameAsc()` method is given
    as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our next step is to modify the implementation of the `search()` method of the
    `RepositoryContactService` class to fulfill the given requirements. Our implementation
    of the `search()` method is described as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: We get the used search criteria.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the used `OrderSpecifier` array by calling the `sortByLastNameAndFirstNameAsc()`
    method that we created earlier.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the `findAll()` method of the `ContactRepository` and provide the needed
    parameters.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `CollectionUtils` class found from the `Commons Collections` library
    to add all contacts to the returned list.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `search()` method is given as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What technique should we use?
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best approach is to keep the query generation and sorting logic in the
    same place, if possible. In this way, we can check the implementation of our query
    by looking at one place, and one place only. This general guideline can be refined
    to the following concrete instructions:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: If we are using the query generation from the method name, we should use this
    approach for sorting the query results. If the method name becomes too long or
    ugly, we can always use the `Sort` class for sorting our query results but this
    should not be our first choice. Instead, we should consider building our query
    by using the `@Query` annotation.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are using JPQL or SQL, we should add the sorting logic in our query string.
    This way we can check our query logic and sorting logic from the same place.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are using named queries or native queries with the `@Query` annotation,
    we must add the sorting logic into our query string.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we are building our queries by using the JPA Criteria API, we must use
    the `Sort` class because that is only the method provided by the `JpaSpecificationExecutor<T>`
    interface.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we are using Querydsl for building our queries, we must use the `OrderSpecifier`
    class to sort our query results because that is required by the `QueryDslPredicateExecutor<T>`
    interface.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paginating query results
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Paginating query results is a very common requirement for practically every
    application that presents some kind of data. The key component of the pagination
    support of Spring Data JPA is the `Pageable` interface that declares the following
    methods:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
- en: '| `int getPageNumber()` | Returns the number of the requested page. The page
    numbers are zero indexed. Thus, the number of the first page is zero. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
- en: '| `int getPageSize()` | Returns the number of elements shown on a single page.
    The page size must always be larger than zero. |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
- en: '| `int getOffset()` | Returns the selected offset according to the given page
    number and page size. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
- en: '| `Sort getSort()` | Returns the sorting parameters used to sort the query
    results. |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
- en: 'We can use this interface to paginate the query results with Spring Data JPA
    by:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new `PageRequest` object. We can use the `PageRequest` class because
    it implements the `Pageable` interface.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Passing the created object to a repository method as a parameter.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we are using query methods for creating our queries, we have got two options
    for the return type of the query method:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: If we need to access the metadata of the requested page, we can make our query
    method return `Page<T>` where `T` is the type of the managed entity.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are interested in only getting the contacts of the requested page, we
    should make our query method return `List<T>`, where `T` is the type of the managed
    entity.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to add pagination to our contact manager application, we have to make
    changes to the service layer of our application and implement the pagination.
    Both of these tasks are described in more detail in the following subsections.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Changing the service layer
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the Spring Data JPA repositories are just interfaces, we have to create
    the `PageRequest` objects on the service layer. This means that we have to figure
    out a way to pass the pagination parameters to the service layer and use these
    parameters to create the `PageRequest` object. We can achieve this goal by following
    these steps:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: We create a class that stores the pagination parameters and the search term.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We change the method signatures of the service interface.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement a way to create `PageRequest` objects.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a class for pagination parameters
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we have to create a class that is used to store both the pagination parameters
    and the used search term. Spring Data provides a custom argument resolver called
    `PageableArgumentResolver` that will automatically build the `PageRequest` object
    by parsing the request parameters. More information about this approach is available
    at [http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/#web-pagination](http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/#web-pagination).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not use this approach since we don''t want to introduce a dependency
    between our web layer and Spring Data. Instead we will use a simple DTO that has
    only a few fields, and getters and setters. The source code of the `SearchDTO`
    is given as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Changing the service interface
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to change the `ContactService` interface of our example application
    in order to provide pagination support for both the contact list and the search
    result list. The required changes are mentioned as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: We have to replace the `findAll()` method with `findAllForPage()` method that
    takes the page number and the page size as a parameter
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to modify the signature of the `search()` method to take `SearchDTO`
    as a parameter
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The signatures of changed methods are given as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating PageRequest objects
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can move forward to the actual implementations we have to add a new
    method to the `RepositoryContactService` class. This method is used to create
    `PageRequest` objects that are passed as a parameter to our repository. The implementation
    of the `buildPageSpecification()` method is explained as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: We use the `sortByLastNameAndFirstNameAsc()` method to get a reference to the
    used `Sort` object.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the page number, page size, and the Sort object to create a new `PageRequest`
    object.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the relevant methods is given as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Implementing pagination
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to paginate the results of our queries, we have to pass the created
    `PageRequest` object to a correct repository method. This method depends on the
    approach, which we are using to build our queries. Each of these approaches is
    described in this subsection.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: JpaRepository
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because the `ContactRepository` extends the `JpaRepository<T,ID>` interface,
    we got access to the `Page<Contact> findAll(Pageable page)` method that we can
    use to paginate the list of all entities. The implementation of the `findAllForPage()`
    method of the `RepositoryContactService` class is described as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: We get the used `PageRequest` object.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get a reference to `Page<Contact>` by calling the repository method and passing
    the `PageRequest` object as parameter.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return a list of contacts.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our `findAllForPage()` method is given as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Query generation from the method name
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we are building our queries by using the query generation from the method
    name strategy, we can paginate query results by:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Adding pagination support to the query method.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling the query method from a service method.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding pagination support to the query method
  id: totrans-438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Adding pagination support to our query method is rather simple. All we have
    to do is make the following changes to the signature of the query method:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Pageable` interface as a parameter of the query method.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine the return type of the query method.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we are not interested in the page metadata, the signature of our query
    method is given as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Modifying the service class
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The modifications needed by the `search()` method of the `RepositoryContactService`
    are rather simple. We get a reference to a `PageRequest` object and pass it as
    a parameter to our query method. The source code of the modified method is given
    as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Named queries
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to paginate the query results of named queries, we have to:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Add pagination support to the query method.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the query method from a service method.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding pagination support to the query method
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can add pagination support to a query method that is backed up by a named
    query by adding the `Pageable` interface as a parameter of the query method. At
    this point we do not need the page metadata for anything. Thus, the signature
    of our query method is given as follows:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Modifying the service class
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our implementation of the `search()` method of the `RepositoryContactService`
    class is explained as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: We get the used like pattern.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the required `PageRequest` object.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the list of contacts by calling the modified query method.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our modified `search()` method is given as follows:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '@Query annotation'
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can paginate the query results of JPQL queries built with the `@Query` annotation
    by:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Adding the pagination support to a query method.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling the query method from a service method.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding pagination support to a query method
  id: totrans-465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can add pagination support to a query method that is annotated with the
    `@Query` annotation by making the following changes to its signature:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: We add the `Pageable` interface as a parameter of the method.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We determine the return type of the method.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point we are not interested in the metadata of the returned page. Thus,
    the declaration of the query method is given as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Modifying the service method
  id: totrans-471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The implementation of the `search()` method of the `RepositoryContactService`
    class is described as follows:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: We get the used like pattern.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get a reference to the used `PageRequest` object.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the list of contacts by calling the query method and passing the like
    pattern and the created `PageRequest` object as a parameter.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `search()` method is given as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: JPA Criteria API
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to build queries with the JPA Criteria API, the `ContactRepository`
    interface must extend the `JpaSpecificationExecutor<T>` interface. This gives
    us access to the `Page<Contact> findAll(Specification spec, Pageable page)` method
    that can be used to paginate the query results of criteria queries. The only thing
    that is left for us to do is to modify the `search()` method of the `RepositoryContactService`
    class. Our implementation is explained as follows:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: We get the used specification.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the used `PageRequest` object.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the `Page` implementation by calling the repository method and passing
    the specification and the `PageRequest` object as a parameter.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return the requested list of contacts by calling the `getContent()` method
    of the `Page` class.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our search method is given as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Querydsl
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the `ContactRepository` interface extends the `QueryDslPredicateExecutor<T>`
    interface, we got access to the `Page<Contact> findAll(Predicate predicate, Pageable
    page)` method that we can use to paginate query results. In order to add pagination
    support to our search function, we have to make some changes to the existing `search()`
    method of the `RepositoryContactService` class. The new implementation of this
    method is described in the following steps:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: We get a reference to the used `Predicate`.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the used `PageRequest` object.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get a `Page` reference by calling the repository method and passing the `Predicate`
    and `PageRequest` object as parameters.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return the requested contacts.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our new `search()` method looks like the following code:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Summary
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have learned that:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: We can use query generation from method name, named queries, or the `@Query`
    annotation for the purpose of creating query methods with Spring Data JPA
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create dynamic queries by using either JPA Criteria API or Querydsl
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are three different methods we can use to sort query results
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are paginating the query results of a query method, the return type of
    the method can be either `List` or `Page`
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each query creation method has its strengths and weaknesses that we must consider
    when we are selecting the correct solution for the current problem
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes we need to add custom functions to our repositories. This issue is
    addressed in the next chapter.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL

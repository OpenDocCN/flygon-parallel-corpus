- en: 10\. Foundational Calculus with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn to calculate the derivatives of functions at
    a given value of x. You'll also learn to calculate the integrals of functions
    between given values and use derivation to solve optimization problems, such as
    maximizing profit or minimizing cost. By the end of this chapter, you will be
    able to use calculus to solve a range of mathematical problems.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calculus has been called the science of change, since its tools were developed
    to deal with constantly changing values such as the position and velocity of planets
    and projectiles. Previously, there was no way to express this kind of change in
    a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first important topic in calculus is the **derivative**. This is the rate
    of change of a function at a given point. Straight lines follow a simple pattern
    known as the slope. This is the change in the *y* value (the *rise*) over a given
    range of *x* values (the *run*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Slope of a line'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.1: Slope of a line'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 10.1*, the *y* value in the line increases by 2 units for every 1-unit
    increase in the *x* value, so we divide 2 by 1 to get a slope of 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the slope of a curve isn''t constant over the whole curve like it
    is in a line. So, as you can see in *Figure 10.2*, the rate of change of this
    function at point **A** is different from the rate of change at point **B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Finding the slope of a curve'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.2: Finding the slope of a curve'
  prefs: []
  type: TYPE_NORMAL
- en: However, if we zoom in closely enough on point **A**, we see the curve is pretty
    closely approximated by a straight line.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: Zooming in on the curve'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.3: Zooming in on the curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how derivatives work: we make the change in *x*, the *run*, small enough
    that the slope over that small part of the curve will closely approximate the
    rate of change of the curve at that point. Let''s see what it looks like in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Derivative Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For all the fear whipped up about derivatives in calculus courses, the function
    for calculating a derivative numerically is surprisingly easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Jupyter notebook, we''ll define a function, *f(x)*, to be the parabola
    *y = x*2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write a function to calculate the derivative at any point *(x, f(x))*
    using the classic formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: Formula for calculating derivatives'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.4: Formula for calculating derivatives'
  prefs: []
  type: TYPE_NORMAL
- en: 'The numerator is the *rise* and the denominator is the *run*. *Δ x* means the
    *change in x*, and we''re going to make that a really small decimal by dividing
    1 by a million:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The triple-quotes ( `"""` ) shown in the code snippet below are used to denote
    the start and end points of a multi-line code comment. Comments are added into
    code to help explain specific bits of logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can calculate the derivative of the function at any *x* value and we''ll
    get a very accurate approximation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These values are only a little off from their actual values (-5.999999 instead
    of -6). We can round up the printout to the nearest tenth and we''ll see the values
    more clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve calculated the derivative of the function *y = x*2 at a number of points
    and we can see the pattern: the derivative is always twice the *x* value. This
    is the slope of the line that approximates the curve at that point. The awesome
    power of this method will become clear in this exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.01: Finding the Derivatives of Other Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use our derivative function to calculate the derivative of any function
    we can express. There''s no need to go through tedious algebraic manipulations
    when we can simply use the *tiny run* method of calculating the slope. Here, our
    function will find the derivative of some complicated-looking functions. We reused
    *f*, but you can call other functions as well. In this exercise, you will find
    the derivatives of each function at the given *x* values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Function definitions at given x values'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.5: Function definitions at given x values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need to import the square root function from the `math` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the preceding functions in the equations, translated into Python code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the derivative function if you haven''t already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then print out the derivatives by calling each function and the desired *x*
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ve just learned a very important skill: finding the derivative of a function
    (any function) at a specific *x* value. This is the reason calculus students do
    lots of hard algebra: to get the derivative as a function, and then they can plug
    in an *x* value. However, with Python, we just directly calculated the numerical
    derivative of a function without doing any algebra.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2AnlJOC](https://packt.live/2AnlJOC).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3gi4I7S](https://packt.live/3gi4I7S).
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Equation of the Tangent Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common question in calculus is to find the equation of the line tangent to
    the curve at a given point. Remember our points **A** and **B**? The tangent lines
    are the lines that closely approximate the curve at those points, as you can see
    in *Figure 10.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Two tangent lines to a curve'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.6: Two tangent lines to a curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the information in *Figure 10.6*. The equation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: Equation of f(x)'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.7: Equation of f(x)'
  prefs: []
  type: TYPE_NORMAL
- en: The *x* value at point **A** in *Figure 10.6* is -0.48 and the *x* value at
    **B** is 0.67\. The great thing about using Python to do this is it won't matter
    if the given values are whole numbers, negatives, or decimals, the computer will
    easily process the number-crunching.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the equation of a line, all we need is a slope and a point. If you
    remember your algebra, you can use this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: Equation of a line'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.8: Equation of a line'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re given the function and the point (*x*0*, y*0), so from that, we can
    find the slope *m* from the derivative of the function at the given *x* value.
    The equation of the tangent line will be in the form *y = mx + b*, and the only
    thing we don''t know is *b*, the *y* intercept of the line. But if we rearrange
    the preceding equation, we can see it on the right side of the equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: Equation of line at the point'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.9: Equation of line at the point'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to find the slope *m* using the derivative function we already have,
    then plug it into *y*0 *- m x*0. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define our `f(x)` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll write a function to return the *y* intercept of a line given the
    slope and a point. Call it `point_slope`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll write a function that takes the function `f` and an `x` value
    and finds the derivative of `f` at `x`, puts that into the `point_slope` function,
    and prints out the equation of the line in *y = mx + b* form. Call it `tangent_line`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We find the slope of the tangent line by taking the derivative of `f` at `x`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we use the `point_slope` function to find the *y* intercept:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to get the equations of the lines tangent to `f` at *x = -0.48* and *x
    = 0.67*, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned how to find out the equations of tangent lines at
    specific values of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Integrals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One major topic of calculus is differential calculus, which means taking derivatives,
    as we've been doing so far in this chapter. The other major topic is integral
    calculus, which involves adding up areas or volumes using many small *slices*.
  prefs: []
  type: TYPE_NORMAL
- en: When calculating integrals by hand, we're taught to reverse the algebra we would
    do to find a derivative. But that algebra gets messy and, in some cases, impossible.
    The *hard* version we learned in school was Riemann sums, which required us to
    cut the area under a curve into rectangular *slices* and add them up to get the
    area. But you could never work with more than 10 slices in a realistic amount
    of time, certainly not on a test.
  prefs: []
  type: TYPE_NORMAL
- en: However, using Python, we can work with as many slices as we want, and it saves
    us the drudgery of jumping through a lot of hoops to get an algebraic equation.
    The point of finding the algebraic equation is to obtain accurate number values,
    and if using a program will get us the most accurate numbers, then we should definitely
    take that route.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.10* shows a function and the area under it. Most commonly the area
    is bounded by the function itself, a lower *x* value **a**, an upper *x* value
    **b**, and the *x* axis.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: The area S under a curve defined by the function f(x) from
    a to b'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.10: The area S under a curve defined by the function f(x) from a
    to b'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''re going to do is to slice the area **S** into rectangles of equal
    width, and since we know the height (*f(x)*), it''ll be easy to add them all up
    using Python. *Figure 10.11* shows what the situation looks like for *f(x) = x*2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: The area S sliced into 10 rectangles of equal width'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.11: The area S sliced into 10 rectangles of equal width'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define the function and choose the number of rectangles (so that
    the value of both will be easy to change). In this instance, we will use 20 rectangles,
    which will give us a higher degree of accuracy than the 10 rectangles shown in
    *Figure 10.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define our integral function. First, divide the range `(b – a)` into
    equal widths by dividing by `num`, the number of rectangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll loop over the range, adding the area of the rectangles as we go.
    We do this with a one-line list comprehension. For every `n`, we multiply the
    base of the rectangle (`width`) by the height (*f(x)*) to get the area of each
    rectangle. Finally, we return the sum of all the areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the function call looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows how, with more rectangles, we get closer and closer to the
    actual value of the area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems to be growing slowly. What if we jump ahead to 100 rectangles? That
    would create the situation shown in *Figure 10.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12: Smaller rectangles making a better approximation of the area'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.12: Smaller rectangles making a better approximation of the area'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we change the `print` statement to give us the area of the 100
    rectangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'How about 1,000 rectangles, an integral that would be extremely difficult and
    time-consuming to calculate by hand? Using Python, we''ll just change `100` to
    `1000` and get a much more accurate approximation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And summing up 100,000 rectangles gets us 0.3333283333\. It seems like it's
    getting close to 0.333, or 1/3\. But adding more zeroes doesn't cost us anything,
    so feel free to increase the number of rectangles as much as required to get a
    more accurate result.
  prefs: []
  type: TYPE_NORMAL
- en: Using Trapezoids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can get better approximations sooner using trapezoids rather than rectangles.
    That way, we won''t miss as much area, as you can see in *Figure 10.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13: Using trapezoids for better approximations to the curve'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.13: Using trapezoids for better approximations to the curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the formula for the trapezoidal rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14: Formula for area of trapezoids'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.14: Formula for area of trapezoids'
  prefs: []
  type: TYPE_NORMAL
- en: The heights of the segments at the endpoints *x = a* and *x = b* are counted
    once, while all the other heights are counted twice. That's because there are
    two *heights* in the formula for the area of a trapezoid. Can you guess how to
    adapt your integral function to be trapezoidal?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll run the `trap_integral` function using `5` trapezoids:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So, by using only 5 trapezoids, we have reduced the error to 3%. (Remember,
    we know the true value of the area for this function is 0.333...) Using 10 trapezoids,
    we get 0.335, which has an error of 0.6%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.02: Finding the Area Under a Curve'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll find the area under the following functions in the
    given intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15: Formula for intervals'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.15: Formula for intervals'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to find the area. Having written the `trap_integral`
    function to use trapezoids to approximate the area under a curve, it''s easy:
    just define the function (you may have to import a `trig` function and `pi`) and
    declare the endpoints. Have it use 100 trapezoids, because that''ll be very accurate
    and quickl:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `math` functions you''ll need and define `f`, `g`, and `h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then call the `trap_integral` function on each function between the specified
    *x* values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By now, you can probably see the power in this numerical method. If you can
    express a function in Python, you can get a very accurate approximation of its
    integral using the function for adding up all the rectangles under the curve,
    or even more accurately, the function for adding up all the trapezoids under the
    curve.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3dTUVTG](https://packt.live/3dTUVTG).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2Zsfxxi](https://packt.live/2Zsfxxi).
  prefs: []
  type: TYPE_NORMAL
- en: Using Integrals to Solve Applied Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a curve is rotated about the *x* or *y* axis or a line parallel to one of
    the axes, to form a 3D object, we can calculate the volume of this solid by using
    the tools of integration. For example, let''s say the parabola *y = x*2 is rotated
    around its axis of symmetry to form a paraboloid, as in *Figure 10.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16: A parabola rotated about the z axis'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.16: A parabola rotated about the z axis'
  prefs: []
  type: TYPE_NORMAL
- en: We can find the volume by adding up all the *slices* of the paraboloid as you
    go up the solid. Just as before, when we were using rectangles in two dimensions,
    now we're using cylinders in three dimensions. In *Figure 10.16*, the slices are
    going up the figure and not to the right, so we can flip it in our heads and redefine
    the curve *y = x*2 as *y = sqrt(x)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the radius of each cylinder is the *y* value, and let''s say we''re going
    from *x = 0* to *x = 1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17: Flipping the paraboloid on its side'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.17: Flipping the paraboloid on its side'
  prefs: []
  type: TYPE_NORMAL
- en: The endpoints are still *0* and *1*, but the radius of the curve is the *y*
    value, which is *sqrt(x)*. So the volume of each circular slice is the volume
    of a cylinder (*pi * radius*2 ** height*), in this case *pi * r*2 ** thickness*,
    or *pi * sqrt(x)*2 ** width*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import `sqrt` and `pi` from the `math` module and define `f(x)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll define a function that will take the function of the paraboloid
    and the beginning and ending values of `x`. It starts off by defining the running
    volume and the number of slices we''re going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we calculate the thickness of the slices by dividing the range of *x*
    values by the number of slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we calculate the volume of each cylindrical slice, which is *pi * r*2 **
    width*. We add that to the running volume, and when the loop is done we return
    the final volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add up all the volumes between `0` and `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This value is an approximation of the volume of the bounded paraboloid. Again,
    the more slices we split the function up into, the more accurate the approximation
    to the real volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.03: Finding the Volume of a Solid of Revolution'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s another solid-of-revolution problem: find the volume of the solid formed
    when the following functions are rotated around the *x* axis on the given intervals.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, the green curve is *f(x) = 4 – 4x*2 and the red curve
    is *g(x) = 1-x*2. Find the volume of the solid formed when the area between the
    functions is rotated about the *x* axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18: A two-dimensional look at the two functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.18: A two-dimensional look at the two functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting shape of the solid would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19: The resulting shape is like a ring'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.19: The resulting shape is like a ring'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is like a problem of finding the area of a ring, as shown in the preceding
    figure. The formula is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.20: Formula for area of a ring'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.20: Formula for area of a ring'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to find the volume of the solid using Python, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `f` and `g` as usual, and a third function (`h`) to be the difference
    of the squares of `f` and `g`, from the ring area formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the volume of the solid will be the sum of a given number (`num`) of cylinders
    made between the functions. We do the same thing as in our integration function.
    The radius of the cylinder is the same as the height of our rectangle when we
    were integrating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The volume of a cylinder is *pi*r*2**h*, and we''ll add that to the running
    total volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s where we call `vol_solid` on the `h` function for *x* between `-1`
    and `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Hence, the volume of the resulting solid is 50.3 cubic units. So, we have used
    our function to find the volumes of solids, and we have adapted it to find the
    volume of the solid between two curves.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2NR9Svg](https://packt.live/2NR9Svg).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3eWJaxs](https://packt.live/3eWJaxs).
  prefs: []
  type: TYPE_NORMAL
- en: Using Derivatives to Solve Optimization Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In many applied problems, we''re looking for an optimal point, where the error
    is lowest, for example, or the profit is highest. The traditional way is to model
    the situation using a function, find the derivative of the function, and solve
    for the input that makes the derivative zero. This is because the derivative is
    zero at local minima and maxima, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.21: A cubic function and the points we want to find'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.21: A cubic function and the points we want to find'
  prefs: []
  type: TYPE_NORMAL
- en: The function we're given in the figure is *f(x) = x*3 *- 2.8x*2 *+ 1.2x + 0.85*.
    We're interested in finding the local maximum, point **A**, and the local minimum,
    point **B**. We would have to differentiate the function and solve the resulting
    equation by hand. But using a computer, we can simply start at a value of *x*
    on the left of the grid and take small steps, checking *f(x)* until we get a change
    in direction. To do that, we can use our derivative function to check when the
    derivative changes sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define `f(x)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll define a function called `find_max_mins` to start at a minimum
    *x* value and take tiny steps, checking if the derivative equals zero or if it
    changes sign, from positive to negative or vice versa. The most mathematical way
    to do that is to check whether the previous derivative times the new one is negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call the function so it''ll print out all the values at which the
    derivative changes sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: These are the local maximum and local minimum of `f` in *Figure 10.21*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.04: Find the Quickest Route'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use this procedure of finding maxima and minima to find the minimum
    value of a complicated function. In traditional calculus classes, students have
    to take the derivative algebraically, set it to zero, and then solve the resulting
    equation. We can model the situation in Python and use our derivative and the
    `find_max_min` functions to easily find the minimum value. Here''s the situation:
    a lighthouse is located 6 kilometers offshore, and a cabin on the straight shoreline
    is 9 kilometers from the point on the shore nearest the lighthouse. If you row
    at a rate of 3 km/hr and walk at a rate of 5 km/hr, where should you land your
    boat in order to get from the lighthouse to the cabin as quickly as possible?'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22: Distance of the lighthouse from the cabin'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.22: Distance of the lighthouse from the cabin'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re aiming to minimize the time it takes to make this trip, so let''s make
    a formula for time. Remember, time is distance divided by rate:![Figure 10.23:
    Formula for calculating time'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_10_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.23: Formula for calculating time'
  prefs: []
  type: TYPE_NORMAL
- en: 'And there''s the function we need to minimize. The optimal *x* is going to
    be between 0 and 9 kilometers, so we''ll set those as our start and end values
    when we call our `find_max_mins` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s very close to 4.5 kilometers along the beach. This is a very useful
    calculation: we found the shortest distance between two points when other constraints
    have been put in place.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/31DwYxu](https://packt.live/31DwYxu).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/38wNRM5](https://packt.live/38wNRM5).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.05: The Box Problem'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s a classic problem given to all calculus students in which a manufacturer
    has a rectangular piece of material that they want to make into a box by cutting
    identical squares out of the corners, like in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.24: Cutting squares out of the corners of a rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.24: Cutting squares out of the corners of a rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the piece of material is 10 inches by 12 inches. Here''s the
    problem: find the size of the square to cut out in order to maximize the volume
    of the resulting box:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for the volume of the box will be length multiplied by width multiplied
    by height. In terms of *x*, the length of the square cut from the corners, the
    length of the box is *12 – 2x*, since two corners are cut out of the 12-inch sides.
    Similarly, the width of the box will be *10 – 2x*. The height, once the "flaps"
    are bent upwards, will be *x*. So, the volume is:![Figure 10.25: Formula to calculate
    the volume'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_10_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.25: Formula to calculate the volume'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you define this function in Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, you know how to put this into your `find_max_mins` function. We only
    want to plug in values between 0 and 5 because more than 5 inches would mean we''d
    be left with no side (the width is 10 inches):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The maximum volume is achieved by cutting squares with side length 1.81 inches.
    Here''s a plot of the volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.26: Plot of maximum value achieved'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.26: Plot of maximum value achieved'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the maximum volume is achieved when a square of 1.81 inches
    is cut from each side, since this is where the maximum point of the plot lies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3gc11AC](https://packt.live/3gc11AC).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2NNSNmb](https://packt.live/2NNSNmb).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.06: The Optimal Can'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A cylindrical can hold 355 cm3 of soda. What dimensions (radius and height)
    will minimize the cost of metal to construct the can? You can neglect the top
    of the can:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The surface area of a cylinder is the area of the bottom (a circle, so πr2)
    plus the area of its side, which is a rectangle of base *2πr* and a height of
    *h*. The volume of a cylinder is πr2h, so we put it all together:![Figure 10.27:
    Formula to calculate the volume of a cylinder'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_10_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.27: Formula to calculate the volume of a cylinder'
  prefs: []
  type: TYPE_NORMAL
- en: 'The volume is already set to 355\. From there, we can get an expression for
    *h* in terms of *r* and we''ll have the surface area all in terms of one variable:![Figure
    10.28: Substituting the values in the formula'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_10_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.28: Substituting the values in the formula'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s express it in Python and put it in our `find_max_mins` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the code, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'So the solution is for the radius to be around 4.8 cm and the height to be
    355/(π(4.8)2) = 4.9 cm. That means the can is about twice as wide as it is tall.
    Here''s a plot of the `surf_area` function for cans between 2 and 6 cm. You can
    see the point that minimizes the material, between 4.5 and 5 cm. We calculated
    it to be exactly 4.9 cm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.29: Finding the minimum material needed to make a can'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.29: Finding the minimum material needed to make a can'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2Zu2bAK](https://packt.live/2Zu2bAK).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/38lUNeE](https://packt.live/38lUNeE).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.07: Calculating the Distance between Two Moving Ships'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At noon, ship A is 20 km north of ship B. If ship A sails south at 6 km/hr
    and ship B sails east at 8 km/hr, find the time at which the distance between
    the two ships is smallest. The following figure shows the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.30: Ships A and B moving south and east'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.30: Ships A and B moving south and east'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to find the time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The distance is velocity multiplied by time, so the distance between the two
    ships can be modeled by this equation:![Figure 10.31: Formula for calculating
    distance'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_10_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.31: Formula for calculating distance'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s express that using Python and put it into our `find_max_mins` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We assume the time will be between `0` and `4` hours:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The time is therefore 1.2 hours, illustrated by the minimum point on the following
    plot. Two tenths of an hour is 12 minutes, meaning the ships will be closest at
    1:12 pm. Here''s a plot of the distance versus time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.32: Plot of distance versus time'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.32: Plot of distance versus time'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/38k2kuF](https://packt.live/38k2kuF).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/31FK3GG](https://packt.live/31FK3GG).
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10.01: Maximum Circle-to-Cone Volume'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a classic optimization problem, which results in some extremely complicated
    equations to differentiate and solve if you''re doing it by hand. However, doing
    it with the help of Python will make the calculus part much easier. You start
    with a circle and cut out a sector of θ degrees. Then you attach points **A**
    and **B** in the following figure to make a cone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.33: Circle to cone volume'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.33: Circle to cone volume'
  prefs: []
  type: TYPE_NORMAL
- en: The problem, like in the box problem, is to find the angle to cut out which
    maximizes the volume of the cone. It will require you to visualize cutting out
    the angle, attach the points to make a cone, and calculate the volume of the resulting
    cone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steps for completion:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the arc length of `AB`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find *h*, the height of the resulting cone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find *r*, the radius of the base of the cone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find an expression for the volume of the cone as a function of theta (*θ*),
    the angle cut out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 694.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tools of calculus allowed mathematicians and scientists to deal with constantly
    changing values, and those tools changed the way science is done. All of a sudden,
    we could use infinitely small steps to approximate the slope of a curve at a point,
    or infinitely small rectangles to approximate the area under a curve. These tools
    were developed hundreds of years before our modern world of computers and free
    programming software, but there's no reason to limit ourselves to the tools available
    to Newton, Leibniz, and the Bernoullis.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned to take derivatives of functions by simply dividing
    the *rise* of the function from one point to another by the infinitesimal *run*
    between those points. We simply told Python to divide 1 by a million to give us
    that small number. Without a computer, plugging those decimals into a function
    would be a daunting task, but Python plugs a decimal into a function as easily
    as a whole number.
  prefs: []
  type: TYPE_NORMAL
- en: We used the derivative idea to find the highest or lowest output of a function,
    where the derivative equals zero. This enabled us to find the optimal value of
    a function that would yield the shortest distance, or the greatest volume, for
    example.
  prefs: []
  type: TYPE_NORMAL
- en: The second most important topic in calculus is integration, and that allowed
    us to build up a complicated area or volume slice by slice using rectangles, trapezoids,
    or cylinders. Using Python, we could easily combine hundreds or thousands of slices
    to accurately approximate an area or volume.
  prefs: []
  type: TYPE_NORMAL
- en: We've only scratched the surface of the power that calculus and Python give
    us to work with changing values, infinitely small values, and infinitely large
    ones, too.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll expand on these basic tools to find the lengths of
    curves, the areas of surfaces, and, most usefully for machine learning, the minimum
    point on a surface.
  prefs: []
  type: TYPE_NORMAL
- en: WFT54
  prefs: []
  type: TYPE_NORMAL
- en: GLS48
  prefs: []
  type: TYPE_NORMAL

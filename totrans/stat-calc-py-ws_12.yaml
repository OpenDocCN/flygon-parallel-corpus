- en: 12\. Intermediate Calculus with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to solve problems when given equations
    dealing with the change in a variable. In this chapter, you'll use numerical methods
    to model populations and temperatures and use differential equations to calculate
    their past values or predict their future values. You'll learn how to use binary
    search to *guess and check* your way to a very accurate solution when you know
    it's in a specific range of numbers. You'll also model situations where objects
    move and solve for their future positions when given differential equations for
    their velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Math students often complain that there's no real-world application for the
    kinds of problems arising in algebra and geometry, such as factoring polynomials
    or bisecting angles, but the same can't be said for differential equations. Using
    the tools, you'll learn about in this chapter, you will be able to model and solve
    real-life problems in physics, electronics, and engineering with differential
    equations. Python is the perfect tool for mathematicians and scientists who want
    to be able to crunch numbers and solve problems but don't want to have to get
    another degree in computer science to do so. Python is one of the most popular
    programming languages due to its ease of use and lack of unnecessary abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: By the 1600s, mathematicians had modeled the motion of falling objects with
    mathematical equations and had set their sights on the planets in outer space.
    Newton modeled their motion and the equations he came up with referred not only
    to unknown numbers but also the changes in those numbers. For example, his equations
    didn't only contain an unknown angle, but the change in that angle (its angular
    velocity) and even the change in the change in the angle (its acceleration)! There
    were no tools for solving those equations, so he had to invent the tools himself.
    These tools became known as calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Differential Equations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solving an equation in a math class usually involves an unknown number, *x*.
    The equation hides the value but gives you hints as to how to find the value,
    such as ![1](image/B15968_12_InlineEquation1.png). But to solve a differential
    equation, you''re only given information regarding the derivative of a function,
    and you''re expected to find the function. It could be something as simple as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Finding a function with derivative 2'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: Finding a function with derivative 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means *find a function whose derivative is 2.* This can also be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Alternative way to represent derivative of the function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.2: Alternative way to represent derivative of the function'
  prefs: []
  type: TYPE_NORMAL
- en: By simple integration, we can find functions that work in this equation because
    we know the function *y = 2x* has a derivative of 2\. In fact, many related functions,
    such as *y = 2x + 1*, *y = 2x + 2*, *y = 2x + 3*, and so on, all have a derivative
    of 2\. So, we write a general form, that is, *y = 2x + C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things get more complicated when we don''t have much to go on, like in this
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Derivative of a function whose value is the function itself'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.3: Derivative of a function whose value is the function itself'
  prefs: []
  type: TYPE_NORMAL
- en: This is asking for a function whose derivative is the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how differential equations are used, let's start with simple functions,
    and ones involving things in the real world, such as money.
  prefs: []
  type: TYPE_NORMAL
- en: Interest Calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a crucial tool in the study of differential equations that originated
    in the study of interest calculations in the middle ages. Let's take a look at
    the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.01: Calculating Interest'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A savings account pays 2% annual interest. If $3,500 is invested, how much money
    is in the account after 5 years?
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for simple interest is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Formula for simple interest'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.4: Formula for simple interest'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, *I* is the interest, *P* is the principal or the original amount invested,
    *r* is the rate of interest or growth, and *t* is the time the amount has been
    invested for. By this formula, the interest earned on the amount is *I = (3500)(0.02)(5)
    = $350*. Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good opportunity to start a program that will take in an initial
    amount, interest rate, and time and output the interest earned using the preceding
    formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the docstring of the `amount` function, it will take a starting
    amount and a rate of growth and return the amount of the investment after the
    given number of years. Let''s see the interest earned in 1-5 years:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But this isn''t really how interest works. A few times every year, we calculate
    the interest earned for that fraction of the year, add it to the principal, and
    the new principal is higher. The next interest calculation is on the higher number,
    hence the name *compound interest*. The formula for the amount after *t* years,
    given *n* compounding per year, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5: Formula to calculate the amount after t years'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.5: Formula to calculate the amount after t years'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our `amount` function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we added the interest earned in the fraction of the year
    given by the number of compounding. If we only compound the interest once a year,
    it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, at the end of 5 years, we've earned $364, not just $350\. Compounding more
    often, even with the same interest rate, makes the amount grow more quickly. If
    we changed the compounding to 12 per year (compounding monthly), we'd end up with
    $3,867 after 5 years, a little more than compounding annually.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3dUWz7C.](https://packt.live/3dUWz7C
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3iqUKCO.](https://packt.live/3iqUKCO
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.02: Calculating Compound Interest – Part 1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '$2,000 is invested in a savings account that earns 5.5% annual interest, compounded
    monthly. How long will it take for the amount to grow to $8,000? Follow these
    steps to work this out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll print out the first 5 years of the investment using our `amount` function
    from the previous exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After 5 years, the amount is only $2,631\. To get to $8,000, we''ll have to
    go to 20 or 30 years:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Sometime between 25 and 30 years, we'll get to $8,000\. The way to get more
    exact is to guess smarter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cut the range in half and guess higher or lower based on what we get
    out. For example, the average of 25 and 30 years is 27.5, so we enter the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, we'd reach $9,000 in 27.5 years. The time to get to $8,000 must be less
    than that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll calculate the average of 25 and 27.5 and plug that in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a program to keep doing this until we find our answer. This is
    called a **binary search**. Let''s create a `bin_search` function that will take
    the name of the function we''re using, the lower and upper bounds of the range
    we''re searching over, and the target output—in this case, 8,000—as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the critical line. It plugs the average into the function, using all
    the other required parameters, and assigns the output to the `guess` variable.
    We''ll check whether that variable is equal to our target or whether we have to
    guess higher or lower:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll plug the lower and higher ends of our range into our function, as well
    as our target number, to get our approximation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks like we''ll get to $8,000 in **25 years and 4 months**. Let''s check
    that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Sure enough, the balance after that compounding is just over $8,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the binary search again, but for now, let's use our code to find a
    rather important mathematical constant that comes up often in differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3iq95PV.](https://packt.live/3iq95PV
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2BpdbHI.](https://packt.live/2BpdbHI
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.03: Calculating Compound Interest – Part 2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How much would you make if you invested $1 at 100% interest for 1 year, compounded
    continuously?
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the more frequently you compound the interest, the higher the
    final amount will be. How much do you think it will be? $1.50? $2? The principal,
    rate, and time are all 1, but what is the `comps` variable? Follow these steps
    to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To approximate compounding continuously, we''ll compound the interest every
    second (*365*24*60*60* times per year):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is around $2.72\. That number, 2.71828…, is the number *e*, which is the
    base of natural logarithms. It''s very useful for modeling populations in the
    natural world since animals, plants, and microorganisms don''t wait until the
    end of the month to reproduce—they do so continuously. So, when interest is compounded
    continuously or when a population is growing naturally, we''ll use this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: Formula to calculate compound interest'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.6: Formula to calculate compound interest'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a function to do this quickly. First, we''ll need to import *e*
    from the `math` module for our continuous compounding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `pert` function that will plug in the initial amount or population,
    the growth rate, and the time, and return the final amount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We will return to this function throughout this chapter. For now, let's answer
    some more investment questions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2D2Q1r0.](https://packt.live/2D2Q1r0
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/31G5pDQ.](https://packt.live/31G5pDQ
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.04: Calculating Compound Interest – Part 3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A person borrows $5,000 at 18% annual interest compounded monthly. How much
    will the person owe after 1 year? Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can just put it into our function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For comparison, let's see what would happen if the interest was compounded continuously.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use our `pert` function to input `P = 5000`, `r = 0.18`, and `t = 1`
    as values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting amount is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/31ES5Qi.](https://packt.live/31ES5Qi
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3f5j0s4.](https://packt.live/3f5j0s4
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.05: Becoming a Millionaire'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How long would it take to become a millionaire if you invested $1,000 at 8%
    annual interest compounded daily? What if the initial amount is $10,000? Follow
    these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define the `bin_search` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take some wild guesses and see what we would get if the $1,000 were
    invested for these numbers of years:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After 50 years, you still would only have $54,000, not a million. But after
    100 years, you''d have almost 3 million:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The answer must be somewhere between 50 and 100\. Looks like a job for our
    binary search:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that after 86.36 years, we''ll have 1 million dollars. If the initial
    investment is $10,000, then update the `guess` variable in the `bin_search` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we''ll print out the output we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we reach 1 million dollars in somewhere between 50 and 60 years. Let''s
    change `1000` to `10000` in our binary search function and check it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Just over 57.57 years to reach a million dollars.
  prefs: []
  type: TYPE_NORMAL
- en: So, we've started off learning about differential equations by studying compound
    interest. An initial amount of money had a rate of interest applied to it at intervals
    of a year, a month, or a day.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/31ycoPg.](https://packt.live/31ycoPg
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2NMT9sX.](https://packt.live/2NMT9sX
    )
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll extend the same reasoning to amounts of people, animals, bacteria,
    and heat, which change constantly, or *continuously*.
  prefs: []
  type: TYPE_NORMAL
- en: Population Growth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Differential equations are useful for finding a formula for the population
    of people, animals, and bacteria at a certain time; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: Differential equation to calculate population at time t'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.7: Differential equation to calculate population at time t'
  prefs: []
  type: TYPE_NORMAL
- en: 'This differential equation means the rate of change of *y* is proportional
    to *y*, or the population grows proportional to its amount. This is the definition
    of population growth rate: a fraction or percentage of the population. The solution
    is similar to our interest problems involving continuous compounding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: Differential equation to calculate the rate of change'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.8: Differential equation to calculate the rate of change'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.06: Calculating the Population Growth Rate – Part 1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the 1980s, the annual population growth rate in Kenya was 4%. At that rate,
    how long would it take for the population to double? Follow these steps to complete
    this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter what the starting population, we''re looking for *t*, which makes
    the factor *e*rt equal to 2\. We can use our `pert` function and our binomial
    search function, with a little tweaking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re looking for the time, *t*, that will, with a growth rate of 4%, turn
    our initial population of 1 into 2\. We estimate it will be somewhere between
    1 and 100 years:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check that with algebra. We take the log of both sides of the equation
    and solve *t*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9: Equation to solve for time (t)'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.9: Equation to solve for time (t)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that in just over 17 years, the population of Kenya will have doubled.
    We can check this with our `amount` function. In 1989, the population of Kenya
    was 21,000,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Yes, using a million compoundings a year, the population grows to almost 42
    million in 17.3 years.
  prefs: []
  type: TYPE_NORMAL
- en: In response to this, the Kenyan government made a big push to promote *family
    planning*. Did it work?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2BxsfCT.](https://packt.live/2BxsfCT
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2Zuoy9c.](https://packt.live/2Zuoy9c
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.07: Calculating the Population Growth Rate – Part 2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2010, the population of Kenya was 42.0 million. In 2019, it was 52.5 million.
    What is the population growth rate per year for that range?
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we can use our binary search function to return a growth factor,
    *r*, given the initial population (in millions), the time, *t*, and the target
    population (in millions) after 9 years.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `bin_search` function, change the time to `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll find the annual growth rate for those 9 years. We know it''s between
    0 and 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The value that is printed is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The family planning program must have worked! Kenya reduced its population growth
    rate to 2.5%.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3eWKzDW.](https://packt.live/3eWKzDW
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/31EKPUq.](https://packt.live/31EKPUq
    )
  prefs: []
  type: TYPE_NORMAL
- en: Half-Life of Radioactive Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much like population problems, half-life problems concern a population, but
    one of atoms of radioactive materials where half the atoms change over time into
    atoms of a different substance. For example, Carbon-14 decays into Nitrogen-14,
    and it takes about 5,730 years for half the carbon to decay. This makes *radiocarbon
    dating* a crucial tool in everything from archaeology to detecting forged artworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.08: Measuring Radioactive Decay'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Radium-226 has a half-life of 1,600 years. How much of the radium in a given
    sample will disappear in 800 years?
  prefs: []
  type: TYPE_NORMAL
- en: 'The differential equation meaning "*the rate of decay of a substance is proportional
    to the amount of the substance*" is expressed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10: Differential equation for calculating rate of decay of a substance'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.10: Differential equation for calculating rate of decay of a substance'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is similar to that for our population problems, except that the
    decay factor is negative, since the amount decreases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11: Calculating rate of change with negative decay factor'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.11: Calculating rate of change with negative decay factor'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means the final amount is equal to the initial amount of time, *e*, to
    the product of a decay factor, *r*, and time, *t*. We can use our binary search
    function as if this were a population problem. We''re looking for the growth rate,
    *r*, that cuts our population in half in 1,600 years. Follow these steps to complete
    this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change *t* in the `guess =` line in the `bin_search` function to `1600`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, search for the growth factor, which we figure is going to be between
    -2 and 0\. Our target amount is ½ of the starting amount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the decay factor, *r*, for Radium-226\. All we have to do to find out
    the percentage of the sample left after 800 years is plug that into our `pert`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: So, around 71% of the sample remains after 800 years.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YSzQ84.](https://packt.live/2YSzQ84
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2ByUwJj.](https://packt.live/2ByUwJj
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.09: Measuring the Age of a Historical Artifact'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A sample of cloth is radiocarbon-tested for age. This means the scientists measure
    how much Carbon-14 (half-life 5,730 years) has decayed into a more stable isotope.
    They find the amount of Carbon-14 remaining is 10 times that of Carbon-13\. How
    old is the cloth?
  prefs: []
  type: TYPE_NORMAL
- en: 'If Carbon-14 takes 5,730 years for half its amount to decay, we need to find
    the rate, *r*, for our Pert formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12: The Pert formula'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.12: The Pert formula'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use our binary search function to solve *r*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the line that''s changed. We put a beginning amount of `1` into the
    `pert` function, *r* will be `avg`, and `5730` will be the target time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '*r = -0.000120968*, so our Pert formula becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13: Substituting the new value of r in the Pert formula'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.13: Substituting the new value of r in the Pert formula'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means *x* grams of Carbon-14 decayed, and 10x grams, 10 times as much,
    remains. So, the decayed amount is 1/11th or 0.091 of the whole sample. The ending
    amount is 1 – 0.091\. That makes our Pert equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14: Pert equation with ending amount'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.14: Pert equation with ending amount'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only unknown in our equation is *t*, so we''re changing our `bin_search`
    function to guess and check strategically for the correct *t*. Go back to your
    `bin_search` function; the beginning should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the line we''re changing. We''re plugging in 1 for the original amount,
    the long decimal is our *r*, and the average of our time range is used for the
    time. The target is 0.091 of the sample, and this will keep guessing and averaging
    until it returns the exact number of years to get to the target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it''s a decreasing function, if the guess is less than the target, we''ll
    have overshot it and the `upper` number will be replaced by the average:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we changed the `if guess < target:` line. We''re looking for the number
    of years it''ll take the amount to decay from 1 to 0.91 at the given rate. We
    suspect it''s somewhere between 1 and 100,000 years. The second `print` line is
    just a check that our `pert` function confirms that after 5,730 years, the amount
    left is exactly half the original amount. Here''s the output when we run our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: According to our calculations, the cloth is around **780 years** old.
  prefs: []
  type: TYPE_NORMAL
- en: So, we originally wrote this code to measure the amount of money left in an
    investment that grew at a given rate for a certain time. In this section, we applied
    this to the amount of radioactive material left in an object after decaying at
    a known rate for an unknown amount of time. This is how scientists calculate the
    age of archaeological artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3eOJJJv.](https://packt.live/3eOJJJv
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/38mESgn.](https://packt.live/38mESgn
    )
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll use the same idea but apply it to the change in the temperature
    of objects such as a cup of coffee or a human body.
  prefs: []
  type: TYPE_NORMAL
- en: Newton's Law of Cooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Did you ever wonder how the **Crime Scene Investigator** (**CSI**) with the
    latex gloves on police shows can tell the time of death of the victim? Isaac Newton
    is credited with figuring out that the cooling of substances follows a differential
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15: Differential equation for rate of change of temperature'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.15: Differential equation for rate of change of temperature'
  prefs: []
  type: TYPE_NORMAL
- en: 'See how this differential equation is slightly different than the ones we''ve
    seen before? Instead of the rate of change of the temperature of the substance
    being proportional to the temperature of the substance, this says *"the rate of
    change of the temperature of a substance is proportional to the difference between
    the temperature of the substance and the temperature of the environment."* So,
    if a cup of hot coffee is left in a hot room, its temperature is going to change
    less quickly than if it''s left in a very cold room. Similarly, we know the starting
    temperature of the body of the victim on the police show: 98.6° F.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.10: Calculating the Time of Death'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An investigator arrives at the scene of the crime and measures the temperature
    of the environment and the body. If the environment is 65° and the body is 80°,
    the investigator notes the time and waits an hour. The difference between the
    temperatures of the body and the environment is 15\. An hour later, the environment
    is still 65° and the body has further cooled to 75°. The difference in temperatures
    is now 10°. When did the victim die?
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information, she can set up the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.16: Equation for calculating the time of death'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.16: Equation for calculating the time of death'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use our binary search to find out what the decay rate for the temperature
    is. We''ll need to import `e` and make sure we have our `pert` and `average` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of our `bin_search` function is the same as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the important change: our original amount (the temperature difference)
    is 15 degrees, and we want to know *r*, the rate of change in our Pert formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the rate of decay for this situation, so we know the beginning difference
    between the temperature of the body and the environment (98.6 – 65), as well as
    the final difference (10) and the rate of decay. Here''s a graph of the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17: A graph of the cooling body'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.17: A graph of the cooling body'
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to know is the number of hours it took for that difference to decay
    to 10\. Our equation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18: Number of hours taken for the difference to decay to 10'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.18: Number of hours taken for the difference to decay to 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'We change our binary search function to get the time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: But if the time is too low, the difference will be too high. The easiest way
    to get around this is to make the higher *t* the *lower* part of the function
    call and the lower *t* the *upper* end of the range to search.
  prefs: []
  type: TYPE_NORMAL
- en: 'The investigator figures the time has to be between 0 and 5 hours:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Almost exactly 3 hours. That looks close to the time when the *y*-value of the
    curve in the preceding graph is 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check that in our `pert` function. Start at a difference of 33.6 degrees
    with *r = -0.4055* and *t = 3.0*. Hopefully, we end up with 10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: So, now, when the star detective arrives on the scene at 2:30 a.m., the investigator
    can say, "The time of death was around 11:30 pm."
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/38jN68K.](https://packt.live/38jN68K
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3gefegi.](https://packt.live/3gefegi
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.11: Calculating the Rate of Change in Temperature'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A cup of coffee at a perfect temperature of 175° F is left in a 72° room. We
    wait 15 minutes and measure the temperature of the coffee to find it has changed
    to 140°. At this rate, what will its temperature be 1 hour from the start? Follow
    these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference starts at 103° (175-72). In 0.25 hours, it''s changed to 68°
    (140-72). Now, we can set up an equation:![Figure 12.19: Equation for calculating
    difference in the coffee''s temperature'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_12_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.19: Equation for calculating difference in the coffee''s temperature'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change our binary search function to reflect this situation. Change
    the `guess=` line in the `bin_search` function to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it to find what *r* between -2 and 0 will give us a difference of 68°:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s fast! Put that into our Pert formula with *P = 103* and *t=1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: That's the difference in 1 hour. If the room is 72°, that means the coffee will
    be *72 + 19.5 = 91.5°*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3gl5p0i.](https://packt.live/3gl5p0i
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YTdCmw.](https://packt.live/2YTdCmw
    )
  prefs: []
  type: TYPE_NORMAL
- en: Mixture Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In algebra, there are word problems where you have to figure out how much material
    you have to add to a mixture to get a certain concentration or amount. In calculus,
    naturally, the problem has to be harder: for example, the mixture is changing;
    material is going into the mixture, and material is going out. You have to find
    out how much mixture or how much of the solvent is present after a specific amount
    of time. Let''s look at the following exercise to better understand this concept.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.12: Solving Mixture Problems – Part 1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tank contains 82 gallons of brine in which 18 pounds of salt is dissolved.
    Brine containing 3 pounds of dissolved salt per gallon flows into the tank at
    the rate of 5 gallons per minute. The mixture, which is kept uniform by stirring,
    flows out of the tank at a rate of 2 gallons per minute. How much salt is in the
    tank at the end of 39 minutes?
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, this kind of problem leads to some complicated differential
    equations, and only after pages of algebra do you get an equation (usually involving
    *e* to some power) into which you can plug the time and get your final amount.
    However, using programming, we can simply start with our given starting solution
    and add and subtract whatever material the problem calls for. It''s a matter of
    keeping track of solution and solute. Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a function to find the salt content after `t` minutes, given
    our initial conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, every minute, 5 more gallons of brine is being added, containing 15 pounds
    (5 gallons at 3 pounds of salt *per gallon*) of salt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, 2 gallons of the brine flows out every minute, but how much salt is in
    it? That requires us to find the concentration of each gallon of brine:![Figure
    12.20: Formula to calculate the concentration of each gallon of brine'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_12_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.20: Formula to calculate the concentration of each gallon of brine'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be easily converted into code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the salt leaving the tank every minute will be the number of gallons of
    solution flowing out, times the concentration of salt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'After the loop finishes, we can print out the final amounts of brine and the
    salt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To solve our problem, we simply run our `salt_content` function with *t=39*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: That means we end up with 469 pounds of salt after 39 minutes. That number is
    very close to the analytical solution, but it's not exact. What could we do to
    get more accurate results? Remember, the idea behind *e*, the base of natural
    logarithms, is that it simulates constant change in a value, and we're only calculating
    our changes in our solution once every minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce a variable, `frac`, that will let us calculate our changes
    in fractions of a minute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `frac=0.001` value in the parameters means we''ll calculate the changes
    a thousand times per minute. That means we''ll multiply the times we loop by 1,000,
    or 1/`frac`, and we''ll multiply the change in our amounts by `frac`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The output changes to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 470.7 pounds of salt is even closer to the analytical solution, and using smaller
    fractions of a minute doesn't change the output much.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2BlX2Tn.](https://packt.live/2BlX2Tn
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3dSrEcm.](https://packt.live/3dSrEcm
    )
  prefs: []
  type: TYPE_NORMAL
- en: Let's use this function on other problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.13: Solving Mixture Problems – Part 2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A tank contains a solution of 10,000 L of brine with a concentration of 1 kg
    of salt per 100 L. Brine with 2 kg of salt per 100 L flows into the tank at a
    rate of 20 L per second. The (uniform) mixture leaves at a rate of 10 L per second.
    Find out how much salt is in the tank in 5 minutes. Follow these steps to complete
    this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we need to do a little arithmetic to find out our initial amount of salt,
    but 1 kg of salt per 100 L is 100 kg of salt in 10,000 L, and it''s 0.4 kg of
    salt in 20 L, which is flowing into the tank. Here''s our new function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s call the `salt_content` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The output when we call the function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: (Remember, our numbers are all in seconds, and we want 5 minutes, hence the
    `5*60` parameter.)
  prefs: []
  type: TYPE_NORMAL
- en: The output tells us there's 183 kg of salt in the solution in 5 minutes. This
    is very close to the analytical solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simplify our task by changing the hardcoded numbers to variables, so
    when we have a problem with a different initial amount of brine, for example,
    we can just enter a different number into the function call. We''ll need variables
    for the initial amount of brine (or any solution), the initial amount of solute
    (so far, we''ve been using salt), the velocity of brine in, the velocity of salt
    in, and the velocity of brine out. Here''s how to change the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to solve the last problem, our function call would have more arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the output should be the same as in *step 1*. Let's apply this
    to more problems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3gkTWOd.](https://packt.live/3gkTWOd
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3eSWF17.](https://packt.live/3eSWF17
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.14: Solving Mixture Problems – Part 3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A vat contains 100 L of a sugar-water mixture with 900 g of sugar. A sugar-water
    mixture containing 5 g of sugar per L enters the vat at a rate of 2 L per minute.
    Another mixture containing 10 g of sugar per L flows into the vat at a rate of
    1 L per minute. The vat is kept mixed, and the resulting mixture is drained from
    the vat at 3 L per minute. Find the amount of sugar in the vat in 1 hour. Follow
    these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only trick here is that the total solution entering is 3 L per minute,
    and the total solute entering is 20 g per minute. Here''s the function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The amount of solute is 705 g.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YRWNIl.](https://packt.live/2YRWNIl
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YRWKfD.](https://packt.live/2YRWKfD
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.15: Solving Mixture Problems – Part 4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we added pure water? Would that make it harder or easier? Let's try
    this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'A tank contains 1,200 L of a brine mixture of water and 18 g of salt. Fresh
    water enters the tank at a rate of 15 L per minute and the tank is mixed to remain
    uniform. A pipe drains the mixture at a rate of 10 L per minute. How much salt
    is in the tank after 15 minutes? Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use our `salt_content` function, but the `salt in` variable will be
    set to `0`. This makes the following function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the salt content after 15 minutes is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The salt content has decreased from 18 g to 15.9 g.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2ZsLTIs.](https://packt.live/2ZsLTIs
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2AnLrT8.](https://packt.live/2AnLrT8
    )
  prefs: []
  type: TYPE_NORMAL
- en: So, we've seen several topics from differential equations that normally require
    a lot of algebraic manipulation to find an equation for the situation so that
    (presumably) we can plug in a variable and get the temperature, position, or amount
    we're looking for. Modeling using Python and running simulations as we have has
    saved us a lot of algebra and still got us very accurate answers.
  prefs: []
  type: TYPE_NORMAL
- en: Euler's Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In undergraduate math classes, you''re taught all these algebraic methods for
    taking derivatives and integrals and solving differential equations. We didn''t
    mention Laplace transforms, which are even more complicated ways of solving differential
    equations algebraically. Now, for the dirty secret about differential equations
    they don''t tell you in school, unless you major in engineering: most differential
    equations you come across in real life have *no analytical solution*.'
  prefs: []
  type: TYPE_NORMAL
- en: The good news is there have been numerical methods for avoiding messy algebra
    for hundreds of years, and with the invention of computers, these methods have
    become standard. Even when there is an analytical solution, numerical methods
    can be almost as accurate for practical purposes as the analytical method and
    take a fraction of the time to get a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of Euler''s method is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Start at the known point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the derivative at this point using the differential equation. This
    is the direction the curve is taking at this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move a tiny step in the direction you calculated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat until you get to the end of the desired range.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exercise 12.16: Solving Differential Equations with Euler''s Method'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''re given the differential equation ![2](image/B15968_12_InlineEquation4.png).
    You want to know the output of the function *y = f(x)* at a specific value of
    *x*. You''re given one point on the graph: *f(0) = 1*. This means, *"the derivative
    of this function at every point is the y-value of the function at that point."*
    Remember, the derivative is the slope or the direction that point on the graph
    is heading. Euler''s method is to start at the initial value, in this case, at
    (0,1), and calculate the direction to the next point using the differential equation.
    The **Differential Equations** (**DE**) states the slope is the *y*-value, so
    we take a small step in the positive *x*-direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.21: Taking a small step (hopefully) in the right direction'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.21: Taking a small step (hopefully) in the right direction'
  prefs: []
  type: TYPE_NORMAL
- en: 'The derivative is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.22: Derivative of the function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.22: Derivative of the function'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, *ΔY* becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.23: Formula to calculate ΔY'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.23: Formula to calculate ΔY'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s the product of the derivative and the stepsize. To find the next *y*-value,
    we add *ΔY* to the previous *y*-value. At the new point, we repeat this process:
    calculate the slope of the function at this point, multiply by the stepsize, and
    add that to the present *y*-value. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a Python function to do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we know the initial `x` and `y`. We want to know `y` when `x=2`; the stepsize
    can be ½:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We no longer need the `print` statement inside the `euler` function, so comment
    it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line is the result of calculating the slope, which is simply the
    *y*-value, 1, multiplying that by the stepsize, ½, and moving up that distance.
    If the derivative had been negative, we''d have moved down. On the second line,
    we multiplied the *y*-value, 1.5, by the stepsize, 0.5, and got 0.75\. We moved
    up from 0.75 to 2.25 and so on. Taking small steps in the x-direction until we
    got to our target x-value, 2, we ended up at a *y*-value of 5.0625\. We no longer
    need to print out each step, but let''s cut the stepsize in half 10 times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the smaller the stepsize, the closer we seem to be getting to 7.37\. Here''s
    a graph of the paths of the approximations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.24: Better approximations with a smaller stepsize'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.24: Better approximations with a smaller stepsize'
  prefs: []
  type: TYPE_NORMAL
- en: The fourth curve (the curve to the right) is the path of our approximations
    with stepsize 1\. The third graph has stepsize ½, the second curve ¼, and the
    first curve 1/8\. We choose the ![a](image/B15968_12_InlineEquation2.png) differential
    equation because we know the algebraic solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'When *x* is 2, *e*2 *= 7.389*. Adding the actual curve of *y=e*x (the first
    curve on the left), we can see that the smaller the stepsize, the closer the approximations
    get to the actual curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.25: The actual curve added to the left side of the first curve'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.25: The actual curve added to the left side of the first curve'
  prefs: []
  type: TYPE_NORMAL
- en: But the last approximation, with stepsize 0.001953125, took 1,024 steps between
    0 and 2\. It's easy to see why Euler's method wasn't preferred to algebraic methods
    before the invention of the computer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2VEQiaa.](https://packt.live/2VEQiaa
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2ByZvtv.](https://packt.live/2ByZvtv
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.17: Using Euler''s Method to Evaluate a Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use Euler''s method and stepsize 0.001 on the **initial value problem** (**IVP**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.26: Euler''s method on initial VP'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.26: Euler''s method on initial VP'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, *y(0) = 1* in order to calculate the approximate solution *y(x)* for
    when *x = 0.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `euler` function, enter the differential equation in the `slope=` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the proper parameters in the function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This means that by taking tiny steps from our known point (0,1) going in the
    direction specified by the differential equation, we were able to predict that
    1.49 is the approximate *y*-value corresponding to the x-value 0.3.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3inHj6S.](https://packt.live/3inHj6S
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2VFLEbF.](https://packt.live/2VFLEbF
    )
  prefs: []
  type: TYPE_NORMAL
- en: Runge-Kutta Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Euler's method is based only on the derivative at each point, it has the
    problem of always overshooting or undershooting the true curve. Not surprisingly,
    in the centuries since Euler's method was invented, improvements have been made
    to offset its drawbacks. One such improvement is the **Runge-Kutta** (**RK**)
    method, which averages together four approximations, one of which is Euler's method,
    using the beginning of the interval, another using the end of the interval, and
    two other approximations using the midpoint of the interval. When averaged together,
    the approximations at the midpoint are given a higher weight.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the equations when the DE is given, *f(x,y)*, the starting *x* and
    *y*, *x*0 and *y*0, and the step size, *h*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.27: Equations when f(x,y) is given'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.27: Equations when f(x,y) is given'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next *y*, we average together the four preceding approximations, with
    double the weight on *k*2 and *k*3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.28: Formula for averaging the 4 preceding approximations'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.28: Formula for averaging the 4 preceding approximations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, of course, *x* is incremented by *h*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.29: Incrementing x by h'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.29: Incrementing x by h'
  prefs: []
  type: TYPE_NORMAL
- en: This is a lot to code, but its power is impressive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.18: Implementing the Runge-Kutta Method'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the Runge-Kutta method and stepsize 0.2 on the IVP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.30: Runge Kutta method with stepsize 0.2'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.30: Runge Kutta method with stepsize 0.2'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the differential equation. Let''s call it `deriv(x,y)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll define the Runge-Kutta method, calling it `rk4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'When we start at *y(0) = 0* and we want *y(1)* using a stepsize of 0.2, here''s
    what we call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Our progress is printed out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The same problem using the same stepsize, but using Euler''s method, is less
    accurate. In the `euler` function, change the `slope=` line to match the new differential
    equation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we print out the solution using Euler''s method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn''t very close to the Runge-Kutta solution. However, the Runge-Kutta
    improvement may have been more useful before computers, because we can simply
    decrease the step size in Euler''s method and get a much better approximation.
    This is the same output for Euler''s method with a stepsize of 0.001:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This has been a brief look at the *numerical methods* used to solve equations,
    not by doing algebra but by feeding the starting point into a computer program
    and taking small steps in the direction indicated by the differential equations.
    This is an enormous field of calculus, especially now that free software and programming
    languages, coupled with fast computer processors, make easy work of previously
    laborious calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3eWxF95.](https://packt.live/3eWxF95
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3dUlkkg.](https://packt.live/3dUlkkg
    )
  prefs: []
  type: TYPE_NORMAL
- en: Pursuit Curves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A big topic in calculus is the pursuit curve, which is the path traced by an
    agent pursuing a moving target. Since the pursuer moves directly toward its target,
    and then the target moves, this situation leads to all kinds of differential equations.
    The algebra can get very ugly, and that's why calculus professors love the topic.
    However, as we know, differential equations are usually about finding a general
    algebraic solution, that is, a function, not a number. In theory, we then plug
    values into the function to find the location of a particle or the temperature
    of a room at a specific time. Using Python, we skip the algebraic step by modeling
    the situation and finding a numerical solution. What we lose in generality, we
    gain in ease of computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.19: Finding Where the Predator Catches the Prey'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A rabbit starts at (0,0) and runs in the positive *y*-direction at 1 unit per
    second. A fox starts at (20,0) and pursues the rabbit, running 1.5 times as fast
    as the rabbit. At what *y*-value does the fox catch the rabbit?
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need some functions from the `math` module to measure distance
    and angles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll write a function to measure the distance between the predator''s position
    and the prey''s position using the Pythagorean Theorem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The key is that the change in *y* over the change in *x* between the locations
    of the prey and the predator represents the tangent of the angle we want. We know
    their locations, so we use the inverse tangent function, called `atan2`, to calculate
    the angle so that the predator points directly at the prey. All we really want
    is to know how much to change the predator''s *x*- and *y*-coordinates for them
    to move 1 unit toward the prey. To turn the predator toward the prey, we need
    to find the angle between the two points, as shown in the following diagram:![Figure
    12.31: The angle between predator and prey'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_12_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.31: The angle between predator and prey'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we know the change, we can multiply the vector by whatever velocity we
    want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: We calculate the change in `x` and `y`, calculate the angle using the `arctangent`
    function, and then we use cosine and sine to find the corresponding changes in
    the predator's *x*- and *y*-coordinates so that it walks one unit toward the prey.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the chase can begin. We start the predator and prey at their stated locations.
    Then, we start a loop where we move the prey one unit (or an increment of that
    for more accuracy):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we run the chase and print out the *y*-value where the predator catches
    the prey:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This is extremely close to the theoretical value of 24.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3f6x44Z.](https://packt.live/3f6x44Z
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2NO1A7v.](https://packt.live/2NO1A7v
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.20: Using Turtles to Visualize Pursuit Curves'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll visualize the path of the predator and prey, which
    is called the *pursuit curve*. There''s a built-in module in Python, based on
    the virtual turtles of the Logo programming language, that makes it easy to create
    virtual agents that can walk around the screen according to the code we write.
    Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the functions from the `turtle` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'We set up the size of the screen according to the desired lower-left point,
    which we''ll make (-30, -30), and the upper-right point, which we''ll make (40,40):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting up the predator and prey means creating a `Turtle` object and setting
    its color, position, and speed. The turtle leaves paths when it walks, so we tell
    it `penup` to keep it from drawing until it gets to its starting location. Then,
    we tell it `pendown` so that it will start drawing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'We set up the prey by making the turtle green and giving it the shape of a
    turtle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pursue` function should look familiar, but it has built-in functions to
    calculate the distance and even for pointing at another turtle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll execute the `pursue` function and then once it prints the output, we''ll
    tell it the program is done so that the graphics window doesn''t freeze:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this, you can watch the chase. Here''s what the final output should
    look like:![Figure 12.32: The path of the predator is a logarithmic curve'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_12_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.32: The path of the predator is a logarithmic curve'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extension**: Change the prey''s path into a circle. After the line to make
    the prey move forward, add this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make the prey turn left a fraction of a degree every step. But if
    the turn is the same every time, it''ll eventually make a circle. The resulting
    path looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.33: The pursuit curve when the prey is fleeing in a circular path'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.33: The pursuit curve when the prey is fleeing in a circular path'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3dWHDG6.](https://packt.live/3dWHDG6
    )
  prefs: []
  type: TYPE_NORMAL
- en: This section does not currently have an online interactive example and will
    need to be run locally.
  prefs: []
  type: TYPE_NORMAL
- en: Position, Velocity, and Acceleration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Differential equations are often used to study the paths of projectiles, and
    this can be said to be the origin of calculus. Newton invented the tools of calculus
    to solve the differential equations that resulted from his study of the movements
    of the planets and showed that falling objects on Earth are subject to the same
    laws of physics as orbiting planets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.21: Calculating the Height of a Projectile above the Ground'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A ball is thrown upward with an initial velocity of 29 m/s. How long before
    it hits the ground? Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In algebra class, we''re led to calculate the height of a projectile using
    an equation:![Figure 12.34: Formula to calculate the height of a projectile'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_12_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.34: Formula to calculate the height of a projectile'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *h*0 is the initial height, *v*0 is the initial upward velocity, *t* is
    the number of seconds elapsed, and *g* is the acceleration due to gravity, around
    32 feet or 9.8 meters per second. But projectiles don't calculate their position
    using equations; they simply travel in the direction their derivative indicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s model that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: So, for the first second, the ball will be thrown up at 29 meters per second
    but will be slowed down by gravity 9.8 meters per second, meaning after a second,
    it's only going *29 – 9.8 = 19.2* meters per second. So, after a second, the ball
    should be 19.2 meters up in the air. We repeat that every second until its height
    is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the `height` function should look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The velocity and height are assigned their starting values, *v*0 and *h*0,
    and then the velocity is updated by *g* and the acceleration (due to gravity),
    and then the height, *h*, is updated by the velocity. We repeat our calculation
    every second and check to see when the ball''s height returns to zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like the ball hits the ground somewhere between 4 and 5 seconds. But
    when we put *t = 5* into the preceding formula, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.35: Substituting the values in the formula for calculating the
    height of a projectile'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.35: Substituting the values in the formula for calculating the height
    of a projectile'
  prefs: []
  type: TYPE_NORMAL
- en: 'After 5 seconds, the ball should still be 22.5 meters in the air. What''s wrong
    with our code? As you should know by now, the ball doesn''t only change its velocity
    once every second. Its velocity is changing constantly. Just like compound interest,
    we need to calculate the new velocity many times a second. That''s easy for Python.
    We''ll just introduce an `inc` variable for the increment in time. Remember that
    this increases the number of times we loop through the calculations, so the `for
    i in range` line changes too. Then, *g* and *v* are multiplied by the increment.
    We''ll recalculate every half a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this using the same code to execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The ball is in the air for longer, and at 5 seconds, it''s 10.3 meters in the
    air. If we make the increment very small, it should get much closer to 22.5 meters
    at 5 seconds. Change `inc` to 0.001, run it again, and you''ll get this output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'To answer the question of when the ball hits the ground, we''ll have to do
    a binary search between 5 and 6 seconds. As in previous searches, we use our `bin_search`
    function and change the `guess =` line to reflect the number we''re *guessing*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'All we had to change was the `guess =` line with the parameters of the `height`
    function. The last parameter, *t*, is what we''re searching for, so that''s what
    we''re averaging. The binary search function will plug in values between 5 and
    6 and return the value of *t* that returns 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we solve the quadratic equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*29t – 4.9t*2 *= 0*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For *t*, we get *t = 0* and *5.9184*. Of course, the height of the ball was
    0 before we threw it, and the second value is very close to what we got. Here''s
    what the graph of the function looks like. Neglecting air resistance, the graph
    of the particle''s height over time follows a parabolic path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.36: The path of a projectile without air resistance'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.36: The path of a projectile without air resistance'
  prefs: []
  type: TYPE_NORMAL
- en: This was a test of our code because we had a nice formula to check our output.
    Now, we will move on to harder calculus problems involving velocity and acceleration
    where there isn't a formula to help us check the answers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2VEAkN4.](https://packt.live/2VEAkN4
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2Bzpz7Z.](https://packt.live/2Bzpz7Z
    )
  prefs: []
  type: TYPE_NORMAL
- en: An Example of Calculating the Height of a Projectile with Air Resistance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Math students are forced to study particles traveling in perfect parabolic
    paths from algebra through calculus. Unfortunately, that''s not how real particles
    travel. In real life, objects travel through some medium such as air or water
    and are slowed down depending on the density of the medium, their cross-sectional
    area, and other factors. This makes for a complicated equation for the force that''s
    applied to a projectile. In the simplest of terms, *the force on a projectile
    is the acceleration due to gravity and deceleration proportional to the square
    of its velocity*. The equation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*F = mg - kv*2'
  prefs: []
  type: TYPE_NORMAL
- en: With air resistance, we'll need to know the mass, *m*, of the projectile. The
    acceleration due to gravity, *g*, is 9.8 m/s2. The *k* variable is a combination
    of at least three different factors, but the value *k = 0.27* yields realistic
    results for this situation.
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous exercise, we calculate the acceleration and use it to update
    the velocity. Then, we update the position of the projectile according to the
    velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The force on the projectile is made up of two parts: the usual acceleration
    due to gravity and a drag component. Let''s write a Python function to calculate
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Many times, our values are multiplied by `inc`, the increment variable, so that
    we can take smaller steps to get better approximations, as we did before. The
    `gravity` and `drag` variables are taken directly from the force equation. Notice
    that if the velocity is greater than 0, the projectile is traveling upward, so
    the downward force is the sum of the gravity and drag forces. Otherwise, the projectile
    is traveling downward, so the force of gravity is still downward but the drag
    is slowing it down, so we use the difference of the gravity and the drag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll adapt our `height` function from the previous exercise to calculate
    the time it takes for the height to equal 0 and add in a call to our `force` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s the `v -=` line that''s doing the heavy lifting in this function. The
    velocity will be acted on by the downward force. When we run this using *k = 0*,
    we should get the same time and ending velocity as in the previous problem, with
    no air resistance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Yes; in the previous exercise, the projectile took 5.9 seconds to reach the
    ground. When there's no air resistance and the ending height is the same as the
    initial height, the ending velocity will be the same as the initial velocity,
    only in the opposite direction, so –29 m/s.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's put in our more realistic value for *k*, `0.27`, and see how long
    it takes the particle to reach the ground and how fast it will be going. What
    do you predict?
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `v -=` line in the `height` function to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The output when you run the program will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the projectile went up and back down in only 2.2 seconds, and the final
    velocity was –5.9 m/s. If we juxtapose the graphs of the heights of the projectiles
    with and without air resistance, we certainly get a lot less height with air resistance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.37: The height of a projectile, with air resistance (the inner
    curve)'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.37: The height of a projectile, with air resistance (the inner curve)'
  prefs: []
  type: TYPE_NORMAL
- en: That sure is a lot of resistance. Play around with different values for *k*,
    the constant of drag, to get different ending times and ending velocities. This
    leads us to a very interesting idea in math and science, known as **terminal velocity**,
    when the downward and upward forces on a projectile equal out and it no longer
    accelerates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.22: Calculating the Terminal Velocity'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your projectile started at an initial height of 3,000 meters and jumped out
    of a plane (downward velocity of 0), what velocity would it reach? Would it simply
    continue accelerating until the projectile hits the ground?
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the mass to 80 kg, an average weight for a human, and *k* to `0.27`.
    Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have your `force` function from the previous example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change your `height` function so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the important line where we tell the `force` function the mass, the
    value of *k*, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'We go through 500 loops but only print out the velocity every 50th loop. Let''s
    run it with this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output we receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'The velocity starts at 0 and gets more and more negative until it stops decreasing.
    It evens out around 54 m/s (negative because it''s downward), which is around
    120 miles per hour, the terminal velocity for a human body in free fall. Here''s
    a graph of the velocity over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.38: The velocity of a body in free fall with air resistance'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.38: The velocity of a body in free fall with air resistance'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2NNmWBM.](https://packt.live/2NNmWBM
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2BUuXCp.](https://packt.live/2BUuXCp
    )
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's complete an activity to test what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12.01: Finding the Velocity and Location of a Particle'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The velocity vector of a particle moving in the *x-y* plane has the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.39: Differential equation for the velocity vector of a particle'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_12_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.39: Differential equation for the velocity vector of a particle'
  prefs: []
  type: TYPE_NORMAL
- en: Find all the times (and coordinates) at which the line tangent to the curve
    is horizontal, and then find the speed of the particle at *t = 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Write functions for *dx/dt* and *dy/dt*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through the output to find where the derivative is 0 by finding the values
    where the derivative goes from positive to negative or vice versa. Then, use binary
    search to find more accurate approximations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `position` function and take incremental steps of time using loops,
    changing the position of the particle according to the derivatives (the *change
    in position*) given previously. The function should stop at the desired elapsed
    time and print out the *x-y* coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug the times you found in *step 2* into the `position` function to find the
    *x-y* coordinates of the particle when the derivative is 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're asked for the speed of the particle at time *t = 1*. Find the vertical
    and horizontal components of the particle's velocity using the differential equations
    you're given, and also find the hypotenuse of the right triangle created with
    those components acting as the legs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 702.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calculus is a very powerful set of tools for modeling real situations, from
    the transfer of heat to the motion of planets. It has enabled us to calculate
    the rate of change of a function in an instant and the area under complicated
    curves (tasks that seemed impossible using only the tools of algebra and geometry).
    In this chapter, we've been able to deal with the rate of change of a value (the
    derivative) as a value in itself, and we've calculated some very accurate results
    using Python loops and functions. Modeling situations that lead to differential
    equations, such as the paths of projectiles, was what drove the development of
    the first electronic computers.
  prefs: []
  type: TYPE_NORMAL
- en: Math classes may still emphasize algebraic solutions to equations, even differential
    equations, but as we've seen in this chapter, using a computer is a straightforward
    way to model a real-life situation such as a predator pursuing its prey. We changed
    variables such as the amount of money in an investment, the amount of salt in
    a mixture, and the direction a predator was facing thousands of times, recalculating
    amounts and distances every step, and got very accurate results. Python was the
    perfect tool to set some starting conditions and let the program run until a projectile
    hit the ground or reached a terminal velocity. Python also helped us avoid laborious
    algebraic manipulations and let us *brute force* an answer by creating a simple
    model of a falling object or a predator pursuing its prey. This was *simple* because
    we didn't have to repeat the calculations thousands of times—the computer did.
    Plus, these numerical methods are already used on differential equations that
    have no simple algebraic solution, and they even work on those equations that
    do. Hopefully, this chapter has proven the power of using a computer to model
    and analyze complicated real-world situations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you've learned how to build on Python's loops, variables, conditionals,
    functions, and lists to solve complicated problems in statistics, probability,
    and calculus. You've also learned how to time the execution of your code and plot
    your output. You've used Python's state-of-the-art numerical package, `numpy`,
    to speed up calculations and manipulate arrays for a host of applications. You've
    also seen Python programming being applied to every math topic under the sun,
    and now you'll be able to apply it to any real-life situations you encounter in
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: JMK95
  prefs: []
  type: TYPE_NORMAL
- en: GEA39
  prefs: []
  type: TYPE_NORMAL

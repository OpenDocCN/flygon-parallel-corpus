- en: 7\. Kubernetes Serverless with Kubeless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Kubernetes cluster with Minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the Kubeless framework on Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create, update, call, and delete Kubeless functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List, describe, debug, and monitor Kubeless functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create HTTP and PubSub triggers for Kubeless functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will first learn about the Kubeless architecture. Then,
    we'll create our first Kubeless function, deploy it, and invoke it. You'll also
    learn how to debug a Kubeless function in the case of a failure.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Kubeless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Kubeless** is an open source and Kubernetes-native serverless framework that
    runs on top of Kubernetes. This allows software developers to deploy code into
    a Kubernetes cluster without worrying about the underlying infrastructure. **Kubeless**
    is a project by Bitnami, who is a provider of packaged applications for any platform.
    Bitnami provides software installers for over 130 applications, which allow you
    to quickly and efficiently deploy these software applications to any platform.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubeless** functions support multiple programming languages, including Python,
    PHP, Ruby, Node.js, Golang, Java, .NET, Ballerina, and custom runtimes. These
    functions can be invoked with HTTP(S) calls as well as event triggers with Kafka
    or NATS messaging systems. Kubeless also supports Kinesis triggers to associate
    functions with the AWS Kinesis service, which is a managed data-streaming service
    by AWS. Kubeless functions can even be invoked at specified intervals using scheduled
    triggers.'
  prefs: []
  type: TYPE_NORMAL
- en: Kubeless comes with its own Command-Line Interface (CLI) named `kubeless`, which
    is similar to the **kubectl** CLI offered by Kubernetes. We can create, deploy,
    list, and delete Kubeless functions using this `kubeless` CLI. Kubeless also has
    a graphical user interface, which makes the management of the functions much easier.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create our first serverless function on Kubernetes
    using Kubeless. Then, we will invoke this function with multiple mechanisms including
    HTTP, and PubSub triggers. Once we are familiar with the basics of Kubeless, we
    will create a more advanced function that can post messages to Slack.
  prefs: []
  type: TYPE_NORMAL
- en: Kubeless Architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Kubeless framework is an extension of the Kubernetes framework, leveraging
    native Kubernetes concepts such as **Custom Resource Definitions** (**CRDs**)
    and custom controllers. Since Kubeless is built on top of Kubernetes, it can take
    advantage of all the great features available in Kubernetes, such as self-healing,
    autoscaling, load balancing, and service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Custom resources are extensions of the Kubernetes API. You can find more about
    Kubernetes' custom resources in the official Kubernetes documentation at [https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the Kubernetes architecture in order to understand the
    core concepts behind it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Kubeless architecture diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: Kubeless architecture diagram'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The preceding diagram is similar to the standard Kubernetes architecture with
    Kubernetes masters and nodes. There can be one or more Kubernetes masters that
    are responsible for overall decision-making in the cluster. Kubernetes nodes are
    used to host the Kubernetes pods. These pods contain the functions written by
    the software developers. The source code of the functions will be injected into
    the pods by the controller using **ConfigMaps**.
  prefs: []
  type: TYPE_NORMAL
- en: These pods will be managed by the **Kubeless controller**. During the Kubeless
    framework installation process, it will launch an in-cluster controller that will
    continuously watch for function resources. When a function is being deployed,
    this controller will create relevant services, deployments, and pods with the
    provided runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kubeless framework has three core concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtimes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions represent the code blocks executed by the Kubeless framework. During
    the installation, a CRD named `functions.kubeless.io` will be created to represent
    the Kubeless functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Triggers represent the invocation mechanism of the function. A Kubeless function
    will be invoked whenever it receives a trigger. A single trigger can be associated
    with one or many functions. Functions deployed on Kubeless can be triggered using
    five possible mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP trigger: This executes through HTTP(S)-based invocations such as HTTP
    GET or POST requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CronJob trigger: This executes through a predefined schedule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kafka trigger: This executes when a message gets published to the Kafka topics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NATS trigger: This executes when a message gets published to the NATS topics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kinesis trigger: This executes when records get published to AWS Kinesis data
    streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtimes represent different programming languages that can be used to write
    and execute Kubeless functions. A single programming language will be further
    divided into multiple runtimes based on the version. As an example, Python 2.7,
    Python 3.4, Python 3.6, and Python 3.7 are the runtimes supporting the Python
    programming language. Kubeless supports runtimes in both the stable and incubator
    stage. A runtime is considered stable once it meets certain technical requirements
    specified by Kubeless. Incubator runtimes are considered to be in the development
    stage. Once the specified technical requirements are fulfilled, runtime maintainers
    can create a "pull" request in the Kubeless GitHub repository to move the runtime
    from the incubator stage to the stable stage. At the time of writing this book,
    Ballerina, .NET, Golang, Java, Node.js, PHP, and Python runtimes are available
    in the stable stage and JVM and Vertx runtimes are available in the incubator
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following document defines the technical requirements for a stable runtime:
    [https://github.com/kubeless/runtimes/blob/master/DEVELOPER_GUIDE.md#runtime-image-requirements](https://github.com/kubeless/runtimes/blob/master/DEVELOPER_GUIDE.md#runtime-image-requirements).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes Cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to have a working Kubernetes cluster in order to install the Kubeless
    framework. You can create your own Kubernetes cluster using tools such as Minikube,
    Kubeadm, and Kops. You can also create a Kubernetes cluster using the managed
    Kubernetes cluster services provided by public cloud providers such as **Google
    Kubernetes Engine** (**GKE**), Microsoft's **Azure Kubernetes Service** (**AKS**),
    and **Amazon Elastic Kubernetes Service** (**Amazon EKS**). In the following sections,
    we will create our own Kubernetes cluster using **Minikube**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes Cluster with Minikube
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we are going to create our Kubernetes cluster with Minikube. Minikube
    is a tool that will install and run Kubernetes locally on your PC. This will create
    a single-node Kubernetes cluster inside a **Virtual Machine** (**VM**). Minikube
    is used by the software developers who want to try Kubernetes locally, but it
    is not recommended for running production-grade Kubernetes clusters. We will begin
    creating our Kubernetes cluster by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install VirtualBox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since Minikube is running as a VM, we need to install a hypervisor to support
    the VMs. We will be installing Oracle VirtualBox, which is a free virtualization
    software developed by Oracle Corporation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'VirtualBox can be installed on Ubuntu 18.04 with the APT package manager by
    executing the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sudo apt install virtualbox -y`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the `virtualbox` command to start **Oracle VM VirtualBox Manager**,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.2: Oracle VM VirtualBox Manager'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.2: Oracle VM VirtualBox Manager'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Install `minikube`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we are going to install `Minikube` version 1.2.0, which is the latest
    version available at the time of writing this book. First, download the `minikube`
    binaries to your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Downloading the Minikube binaries'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3: Downloading the Minikube binaries'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, add execution permission to the `minikube` binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Adding execution permissions to Minikube binaries'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: Adding execution permissions to Minikube binaries'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, move the Minikube binary to the `/usr/local/bin/` path location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Moving the Minikube binaries to the path'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: Moving the Minikube binaries to the path'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Verify the installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Verifying the Minikube version'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6: Verifying the Minikube version'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Start the Minikube cluster with the `minikube start` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a VM for Minikube in VirtualBox, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Starting Minikube'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.7: Starting Minikube'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, in the **VirtualBox Manager** window, you can see a VM named `minikube`
    in the running state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: Oracle VirtualBox with the Minikube VM'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.8: Oracle VirtualBox with the Minikube VM'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Install `kubectl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we are going to install `kubectl` version 1.15.0, which is the latest
    version available at the time of writing this book. First, download the `kubectl`
    binaries to your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: Downloading the kubectl binaries'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.9: Downloading the kubectl binaries'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, add execution permissions to the Minikube binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10: Adding execution permissions to the kubectl binaries'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.10: Adding execution permissions to the kubectl binaries'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, move the Minikube binary to the `/usr/local/bin/` path location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 7.11: Moving the kubectl binaries to the path'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.11: Moving the kubectl binaries to the path'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Verify the installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be shown on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12: Verifying the kubectl version'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.12: Verifying the kubectl version'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Verify that the `kubectl` CLI is correctly pointed to the Minikube cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13: Verifying that kubectl is pointed to the Minikube cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.13: Verifying that kubectl is pointed to the Minikube cluster'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Installing Kubeless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the Minikube Kubernetes environment is ready, we can install Kubeless
    on top of the Kubernetes cluster. Installing Kubeless consists of installing three
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: The Kubeless framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubeless CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubeless UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubeless framework will install all the extensions on top of Kubernetes
    to support Kubeless features. This includes CRDs, custom controllers, and deployments.
    The Kubeless CLI is used to interact with the Kubeless framework for tasks such
    as deploying functions, invoking functions, and creating triggers. The Kubeless
    UI is a GUI for the Kubeless framework, which will help you to view, edit, and
    run functions.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Kubeless Framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to install Kubeless version 1.0.3, which is the latest available
    release at the time of writing this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create the `kubeless` namespace using `kubectl create namespace`.
    This is the default namespace used by Kubeless to store all its objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14: Creating the kubeless namespace'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.14: Creating the kubeless namespace'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the next step, we will install the Kubeless framework. We will be using
    one of the YAML manifests provided by Kubeless to install the framework. There
    are multiple `yaml` files provided by Kubeless and we have to choose the correct
    `yaml` file based on the Kubernetes environment (for example, `rbac`, `non-rbac`,
    or `openshift`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The screen will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15: Installing the Kubeless framework'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.15: Installing the Kubeless framework'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The preceding step will create multiple Kubernetes objects in the `kubeless`
    namespace. This will create a function object as a **Custom Resource Definition**
    and Kubeless controller as a deployment. You can verify that these objects are
    up and running by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16: Verifying the Kubeless installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.16: Verifying the Kubeless installation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, we have completed the installation of the Kubeless framework successfully.
    In the next section, we will install the Kubeless CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Kubeless CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Kubeless CLI** is the command-line interface for running commands against
    the Kubeless framework. `kubeless function` is the most common one because it
    allows you to perform tasks such as deploying, calling, updating, or deleting
    a function. Additionally, you can list and describe the functions. Checking the
    logs or metrics is also supported through the `kubeless function` command. You
    can also manage Kubeless triggers, topics, and autoscaling from the Kubeless CLI.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have successfully installed the Kubeless framework, the next step is
    to install the Kubeless CLI. We are going to use Kubeless CLI version 1.0.3, which
    is the same version as the Kubeless framework we installed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to download the Kubeless CLI zip file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17: Downloading the Kubeless binaries'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.17: Downloading the Kubeless binaries'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we will extract the zip file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand this better, refer to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18: Extracting the Kubeless binaries'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.18: Extracting the Kubeless binaries'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, move the Kubeless executable to the `/usr/local/bin/` path location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is what you''ll see on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19: Moving the Kubeless binaries to the path'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.19: Moving the Kubeless binaries to the path'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, we have successfully installed the Kubeless CLI. We can verify this by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20: Verifying the Kubeless version'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.20: Verifying the Kubeless version'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Kubeless UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Kubeless UI** is the GUI for Kubeless. It allows you to create, edit,
    delete, and execute Kubeless functions with an easy-to-use UI. Execute the following
    command to install the Kubeless UI in the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21: Installing the Kubeless UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.21: Installing the Kubeless UI'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once the installation is successful, execute the following command to open
    the Kubeless UI in a browser window. You can reload the browser window if the
    Kubeless UI doesn''t show up, since creating the service can take a few minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22: The Kubeless GUI'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.22: The Kubeless GUI'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We've just completed the installation of the Kubeless UI, which can be used
    to create, edit, delete, and execute Kubeless functions that are similar to the
    Kubeless CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Kubeless Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once Kubeless is successfully installed, you can now forget about the underlying
    infrastructure, including VMs and containers, and focus only on your function
    logic. Kubeless functions are code snippets written in one of the supported languages.
    As we discussed previously, Kubeless supports multiple programming languages and
    versions. You can execute the `kubeless get-server-config` command to get a list
    of language runtimes supported by your Kubeless version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23: Kubeless server configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.23: Kubeless server configuration'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the following sections, we are going to create, deploy, list, invoke, update,
    and delete a Kubeless function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubeless Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every Kubeless function, regardless of the language runtime, has the same format.
    It receives two arguments as input and returns a string or object as the response.
    The first argument of the function is an event, which includes all the information
    about the event source such as the event ID, event time, and event type. The `data`
    field inside the `event` object contains the body of the function request. The
    second argument of the function is named `context`, which contains general information
    about the function, such as its name, timeout, runtime, and memory limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample Python function that returns the text `Welcome to
    Kubeless World` as the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can save the file as `hello.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Kubeless Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the function is ready, you can deploy it to the Kubeless framework. You
    can use the `kubeless function deploy` command to register the function with the
    Kubeless framework. In order to deploy a function, you need to provide few pieces
    of information, including the function name, the runtime of the function, the
    file that contains the function source code, and the method name to be executed
    when the function is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24: Deploying a Kubeless function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.24: Deploying a Kubeless function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s break this command up into a few pieces in order to understand what
    each part of the command does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeless function deploy hello`: This tells Kubeless to register a new function
    named `hello`. We can use this name to invoke this function later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--runtime python3.7`: This tells Kubeless to use the Python 3.7 runtime to
    run this function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--from-file hello.py`: This tells Kubeless to use the code available in the
    `hello.py` file to create the `hello` function. If you are not in the current
    file path when executing the command, you need to specify the full file path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--handler hello.main`: This specifies the name of the code file and the method
    to execute when this function is invoked. This should be in the format of `<file-name>.<function-name>`.
    In our case, the filename is `hello` and the function name inside the file is
    `main`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the other options that are available when deploying a function
    by executing the `kubeless function deploy --help` command.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the Kubeless Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you deploy the function, you can verify that the function is deployed
    successfully by listing the functions with the `kubeless function list` command.
    You should see the details of all the registered functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot reflects the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25: Listing the Kubeless functions with the Kubeless CLI'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.25: Listing the Kubeless functions with the Kubeless CLI'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The same can be achieved using the `kubeless function ls` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to obtain more detailed information about a specific function,
    you can use the `kubeless function describe` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26: Describing a Kubeless function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.26: Describing a Kubeless function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Since a Kubeless function is created as a Kubernetes object (that is, a custom
    resource), you can also use the Kubectl CLI to get the information about the available
    functions. The following is the output from the `kubectl get functions` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27: Listing the Kubeless functions with the kubectl CLI'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.27: Listing the Kubeless functions with the kubectl CLI'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Invoking the Kubeless Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it''s time to invoke our `hello` function. You can use the `kubeless function
    call` method to invoke the Kubeless function. The `hello` function will return
    the text `Welcome to Kubeless World` as the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28: Invoking a Kubeless function with the kubeless CLI'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.28: Invoking a Kubeless function with the kubeless CLI'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Congratulations! You have successfully executed your first Kubeless function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also invoke Kubeless functions with the Kubeless UI. Once you open
    the Kubeless UI, you can see the list of functions available on the left-hand
    side. You can click on the `hello` function to open it. Then, click on the **Run**
    function button to execute the function. You can see the expected response of
    **Welcome to Kubeless World** underneath the **Response** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29: Invoking a Kubeless function with the Kubeless UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.29: Invoking a Kubeless function with the Kubeless UI'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Kubeless functions can also be updated or deleted using the Kubeless UI.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Kubeless Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After successfully invoking our `hello` function, we are now going to update
    it to say *hello* to anyone. You can update the `hello.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then execute the `kubeless function update` command to update the `hello`
    function that we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30: Updating a Kubeless function with the Kubeless CLI'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.30: Updating a Kubeless function with the Kubeless CLI'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now you have to pass the required data when invoking the `hello` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31: Invoking updated Kubeless functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.31: Invoking updated Kubeless functions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should be able to see `Hello Kubeless World!` as the output of the preceding
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the Kubeless Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to delete the function, you can execute the `kubeless function
    delete` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.32: Deleting the kubeless function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.32: Deleting the kubeless function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once the function is deleted, try listing the function again. It should throw
    an error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We would see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.33: Verifying the deletion of the kubeless function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.33: Verifying the deletion of the kubeless function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The preceding `kubeless function delete` command will delete not only the `kubeless`
    function, but, while creating the Kubeless function, the framework creates Kubernetes
    objects such as pods and deployment. Those objects will also be deleted when we
    delete the kubeless function. You can verify this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the result as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.34: Verifying the deletion'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.34: Verifying the deletion'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now we have learned how to create, deploy, list, invoke, update, and delete
    Kubeless functions. Let's move on to an exercise about creating your first Kubeless
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 21: Creating Your First Kubeless Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will create, deploy, invoke, and later delete a Kubeless
    function. Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson07/Exercise21](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson07/Exercise21).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file with a sample `hello` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.35: Creating the my-function.py file'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.35: Creating the my-function.py file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create the `lesson-7` namespace and deploy the `my-function.py` file created
    previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.36: Deploying my-function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.36: Deploying my-function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Verify whether `my-function` has been deployed correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output rendered is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.37: Verifying my-function has successfully deployed'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.37: Verifying my-function has successfully deployed'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Invoke `my-function` with the `kubeless` CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.38: Invoking my-function with the Kubeless CLI'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.38: Invoking my-function with the Kubeless CLI'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Delete `my-function` and the `lesson-7` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.39: Deleting my-function with the Kubeless CLI'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.39: Deleting my-function with the Kubeless CLI'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, first, we created a simple Python function, which returned
    the `Welcome to Serverless Architectures with Kubernetes` string as the output
    and deployed it to Kubeless. Then, we listed the function to make sure it was
    created successfully. Then, we invoked the `my-function` and successfully returned
    the expected response of `Welcome to Serverless Architectures with Kubernetes`.
    Finally, we did the cleanup by deleting the function.
  prefs: []
  type: TYPE_NORMAL
- en: Kubeless HTTP Triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, we discussed how to invoke Kubeless functions using
    the Kubeless CLI. In this section, we are going to demonstrate how to expose these
    functions to everyone by creating HTTP triggers.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP triggers are used to execute a Kubeless function through HTTP(S)-based
    invocations such as HTTP `GET` or `POST` requests. When a function is deployed,
    Kubeless will create a Kubernetes service associated with the function with the
    `ClusterIP` as the service type; however, these services are not publicly accessible.
    In order to make the function publicly available, we need to create a Kubeless
    HTTP trigger. This will expose the Kubeless functions to everyone by using Kubernetes
    ingress rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run the HTTP trigger, your Kubernetes cluster must have a running
    ingress controller. Once the ingress controller is running in the Kubernetes cluster,
    you can use the `kubeless trigger http create` command to create an HTTP trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`--function-name flag` is used to specify the name of the function that will
    be associated with the HTTP trigger.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is a number of ingress controller add-ons available for Kubernetes, including
    NGINX, Kong, Traefik, F5, Contour, and more. You can find them at [https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 22: Creating an HTTP Trigger for a Kubeless Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will first enable the ingress plugin for Minikube. Then,
    we will create a function to be executed with HTTP triggers. Finally, we will
    create an HTTP trigger and invoke this function with the HTTP trigger.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson07/Exercise22](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson07/Exercise22).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to enable the `ingress` add-on in our Minikube cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.40: Enabling the Minikube add-on'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.40: Enabling the Minikube add-on'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After a couple of minutes, you should be able to see that the `nginx-ingress-controller`
    container has been created in the `kube-system` namespace, which is the namespace
    for the object created by the Kubernetes system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.41: Listing the nginx-ingress-controller pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.41: Listing the nginx-ingress-controller pod'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once the `nginx-ingress-controller` container is in a running state, we will
    create the function to be executed with the HTTP trigger. Create a Python file
    named `greetings.py` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `lesson-7` namespace and deploy the `greetings.py` created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.42: Executing the function with an HTTP trigger'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.42: Executing the function with an HTTP trigger'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Invoke the function and verify that the function is providing the expected
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once invoked, the screen will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.43: Output for function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.43: Output for function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now we can create the `http` trigger for the `hello` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.44: Creating the HTTP trigger'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_44.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.44: Creating the HTTP trigger'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'List the `http` triggers; you should be able to see the `http` trigger for
    the `hello` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The list will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.45: Listing the HTTP triggers'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_45.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.45: Listing the HTTP triggers'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This will create an `ingress` object in the Kubernetes layer. We can list the
    `ingress` objects with the `kubectl` CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.46: Listing ingress objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.46: Listing ingress objects'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can see the hostname with the `.nip.io` domain, which we can use to access
    the `greetings` function over HTTP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this case, the hostname is `greetings.192.168.99.100.nip.io`. Once you open
    this hostname in a web browser, you should be able to see the greeting message
    in the browser window (note that your output may be different depending on your
    local time):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.47: Invoking the function with the HTTP GET request'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_47.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.47: Invoking the function with the HTTP GET request'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Kubeless PubSub Triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubeless functions can be invoked by sending input messages to `topics` in messaging
    systems. This method is known as a PubSub mechanism. Currently, Kubeless supports
    two messaging systems, namely, Kafka and NATS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create PubSub triggers in Kubeless, we need to have a running Kafka
    cluster or NATS cluster. Once the Kafka or NATS cluster is ready, we can use `kubeless
    trigger kafka create` to create a Kafka trigger or `kubeless trigger nats create`
    to create a NATS trigger and associate our PubSub function with the new trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss what each piece of the command does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeless trigger <trigger-type> create <trigger-name>`: This tells Kubeless
    to create a PubSub trigger with the provided name and trigger type. Valid trigger
    types are **kafka** and **nats**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--function-selector <label-query>`: This tells us which function should be
    associated with this trigger. Kubernetes labels are used to define this relationship
    (for example, `--function-selector key1=value1,key2=value2`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--trigger-topic <topic-name>`: The Kafka broker will listen to this topic
    and the function will be triggered when a message is published to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The topic is where messages from the producers get published. The Kubeless CLI
    allows us to create topics using the `kubeless topic` command. This allows us
    to create, delete, list topics, and publish messages to topics easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 23: Creating a PubSub Trigger for a Kubeless Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will first create a Kafka and Zookeeper cluster within
    our Minikube environment. Once the Kafka and Zookeeper clusters are ready, we
    will create a function to be executed with PubSub triggers. Next, we will create
    the PubSub topic. Publishing messages to the created topic will execute the Kubeless
    function. Perform the following steps to complete the exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s invoke a Kubeless function with the **PubSub** mechanism using Kafka:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to deploy **Kafka** and **Zookeeper** to our Kubernetes
    cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.48: Installing Kafka and Zookeeper'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_48.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.48: Installing Kafka and Zookeeper'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Verify that two `statefulset` named `kafka` and `zoo` are running in the `kubeless`
    namespace for Kafka and Zookeeper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.49: Verifying the Kafka and Zookeeper installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_49.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.49: Verifying the Kafka and Zookeeper installation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once our Kafka and Zookeeper deployment is ready, we can create and deploy
    the function to be triggered by `PubSub` triggers. Create a file named `pubsub.py`
    and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s deploy our function now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The deployment will yield the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.50: Deploying the pubsub function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_50.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.50: Deploying the pubsub function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once the function is deployed, we can verify the function is successful by
    listing the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The listed function will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.51: Verifying the pubsub function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_51.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.51: Verifying the pubsub function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, let''s create the `kafka` trigger with the `kubeless trigger kafka create`
    command and associate our `pubsub` function with the new trigger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.52: Creating the kafka trigger for the pubsub function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_52.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.52: Creating the kafka trigger for the pubsub function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now we need a Kubeless topic to publish the messages. Let''s create a topic
    with the `kubeless topic create` command. We need to make sure that the topic
    name is similar to the one we provided as the `--trigger-topic` while creating
    the `kafka` trigger in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay. Now it''s time to test our `pubsub` function by publishing events to
    `pubsub-topic`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the `logs` function to verify whether the `pubsub` function is successfully
    invoked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the published message in the `output` logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand this better, check out the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.53: Logs of the pubsub function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_53.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.53: Logs of the pubsub function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Monitoring a Kubeless Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we have successfully deployed our Kubeless function, we then need to monitor
    our function. This can be achieved with the `kubeless function top` command. This
    command will provide us with the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NAME`: The name of the Kubeless function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NAMESPACE`: The namespace of the function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`METHOD`: The HTTP method type (for example, GET/POST) when invoking the function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TOTAL_CALLS`: The total number of invocations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TOTAL_FAILURES`: The number of function failures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TOTAL_DURATION_SECONDS`: The total number of seconds this function has executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AVG_DURATION_SECONDS`: The average number of seconds this function has executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MESSAGE`: Any other messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the `kubeless function top` output for the `hello` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.54: Viewing the metrics for the hello function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_54.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.54: Viewing the metrics for the hello function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that we've monitored the function, it's time to move toward debugging it.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a Kubeless Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Kubeless function can fail at different stages of the function life cycle
    (for example, from deployment time to function execution time) due to a number
    of reasons. In this section, we are going to debug a function to identify the
    cause of failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to demonstrate multiple error scenarios, first, we are going to create
    a sample function with the following code block in the `debug.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**Error Scenario 01**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to deploy this function using the `kubeless function deploy`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This will result in `Invalid runtime error` and Kubeless will display the supported
    runtimes. Upon further inspection, we can see that there is a typo in the `--runtime`
    parameter of the `kubeless function deploy` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting output would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.55: Deploying the debug function  error'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_55.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.55: Deploying the debug function  error'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s correct this typo and rerun the `kubeless function deploy` command with
    the `python3.7` runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the function will be successfully deployed into the Kubeless environment.
    It should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.56: Deploying the debug function  successful'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_56.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.56: Deploying the debug function  successful'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Error Scenario 02**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check the status of the function using the `kubeless function ls`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand this better, refer to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.57: Listing the debug function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_57.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.57: Listing the debug function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can see that the status is `0/1 NOT READY`. Now, let''s check the status
    of the debug pod using the `kubectl get pods` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, refer to the following screenshot for the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.58: Listing the debug function pods'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_58.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.58: Listing the debug function pods'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, debug `pod` is in `CrashLoopBackOff` status. This error commonly occurs
    due to either a syntax error in the function or the dependencies that we specify.
  prefs: []
  type: TYPE_NORMAL
- en: On closer inspection, we could identify that a colon (`:`) to mark the end of
    the function header is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's correct this and update our function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `debug.py` file and add a colon at the end of the function header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now execute the `kubeless function update` command to update the function
    with the new code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.59: Updating the debug function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_59.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.59: Updating the debug function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When you execute the `kubeless function ls` debug again, you should be able
    to see that the function is now ready with the `1/1 READY` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.60: Listing the debug function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_60.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.60: Listing the debug function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Error Scenario 03**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an example error scenario with our `hello` function. For this,
    you can call the `hello` function by replacing the key name of the `data` section
    with `username`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how it looks on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.61: Invoking the debug function  error'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_61.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.61: Invoking the debug function  error'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In order to find the possible cause for this failure, we need to check the
    function logs. You can execute the `kubeless function logs` command to view the
    logs of the `hello` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.62: Checking the debug function logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_62.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.62: Checking the debug function logs'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The first few lines of the output show lines similar to the following code
    block, which are internal health checks. As per the logs, we can see that all
    the calls to the `/healthz` endpoint have been successful with the `200` HTTP
    success response code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can see a stack trace of the error messages, as follows, with the
    possible cause being the `KeyError: ''name''` error. The function was expecting
    a `''name''` key, which was not found during the function execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line of the error message indicates that HTTP error `500` was returned
    for the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`HTTP 500` is the error code returned by the HTTP protocol, which indicates
    an **Internal Server Error**. This means that the server was unable to fulfill
    the request due to unexpected conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from `kubeless function logs`, you can also use the `kubectl logs` command,
    which will return a similar output. You need to pass the `-l` parameter, which
    indicates a label, in order to only get the logs for a specific function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.63: Checking the debug function logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_63.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.63: Checking the debug function logs'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Use the `kubectl get functions --show-labels` command to see the labels associated
    with the Kubeless functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will yield the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.64: Listing the function labels'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_64.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.64: Listing the function labels'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s correct our mistake and pass the correct argument to the `debug` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our function has run successfully and has generated `Hello Kubeless` as
    its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.65: Invoking the debug function  successful'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_65.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.65: Invoking the debug function  successful'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Serverless Plugin for Kubeless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Serverless Framework is a general framework for deploying serverless applications
    across different serverless providers. The serverless plugin for Kubeless supports
    deploying Kubeless functions. Apart from the plugin for Kubeless, the Serverless
    Framework supports serverless applications such as AWS Lambda, Azure Functions,
    Google Cloud Functions, Apache OpenWhisk, and Kubeless.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will install the serverless framework and create a Kubeless
    function using the CLI provided by the serverless framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start installing the serverless framework, we need to have Node.js
    version 6.5.0 or later installed as a prerequisite. So, first, let''s install
    Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.66: Node.js version 6.5.0 installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_66.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.66: Node.js version 6.5.0 installation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once installed, verify the Node.js version by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.67: Node.js version verification'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_67.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.67: Node.js version verification'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once the Node.js installation is successful, we will then install the Serverless
    Framework by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will verify the serverless version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.68: Serverless version verification'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_68.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.68: Serverless version verification'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have successfully completed the installation of the Serverless Framework.
    We can now start creating functions with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `serverless create` command to create a basic service from a
    template. Let''s create a project named `my-kubeless-project`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break the command into pieces in order to understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--template kubeless-python`: Currently, two templates are available for the
    Kubeless framework. `kubeless-python` creates a Python function and `kubeless-nodejs`
    creates a Node.js function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--path my-kubeless-project`: This defines that this function should be created
    under the `my-kubeless-project` directory. Take a look at the output to understand
    it better:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.69: Creation of my-kubeless-project'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_69.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.69: Creation of my-kubeless-project'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This command will create a directory named `my-kubeless-project` and several
    files within this directory. First, let''s move to the `my-kubeless-project` directory
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The following files are in the `my-kubeless-project` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: handler.py
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: serverless.yml
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: package.json
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `handler.py` file contains a sample Python function, as follows. This is
    a simple function that returns a JSON object and the status code of 200:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'It also creates a `serverless.yml` file, which tells the serverless framework
    to execute the `hello` function inside the `handler.py` file. In the `provider`
    section, it is mentioned that this is a Kubeless function with a `python2.7` runtime.
    In the `plugins` section, it defines the custom plugins required, such as the
    `serverless-kubeless` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `package.json` file contains the `npm` packaging information,
    such as `dependencies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: You can update these files as required to match your business requirements.
    We are not going to change these files in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to execute the `npm install` command, which installs all
    `npm` dependencies, such as the `kubeless-serverless` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.70: Installing the npm dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_70.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.70: Installing the npm dependencies'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once the dependencies are ready, let''s deploy the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploying the service provides us with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.71: Deploying the service'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_71.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.71: Deploying the service'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, we can deploy the function using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.72: Deploying the function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_72.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.72: Deploying the function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When the function is successfully deployed, we can invoke the function with
    the `serverless invoke` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking the function renders the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.73: Invoking the function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_73.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.73: Invoking the function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can also use the `kubeless function call` command to invoke this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing this will provide the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.74: Using the kubeless function call to invoke the function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_74.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.74: Using the kubeless function call to invoke the function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once you are done with the function, use `serverless remove` to delete the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.75: Deleting the function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_75.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.75: Deleting the function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Execute the `serverless logs -f hello` command if you encounter any errors while
    invoking the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7: Publishing Messages to Slack with Kubeless'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine that you need a Slackbot to post messages to your Slack channel. This
    Slackbot should be able to post messages to a specific Slack channel using the
    incoming webhook integration method. This bot will print a success message if
    posting the message to Slack was successful; otherwise, it will print an error
    message if there were any errors while sending the message to Slack. In this activity,
    we will be creating a Kubeless function that can post messages to a specific Slack
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a prerequisite to this activity, we need to have a Slack workspace with
    incoming webhook integration. Execute the following steps to create a Slack workspace
    and integrate the incoming webhook:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution-Slack Setup**'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Slack workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit [https://slack.com/create](https://slack.com/create) to create a workspace.
    Enter your email address and then click on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should receive a six-digit confirmation code to the email that you entered
    on the previous page. Enter the received code on the workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add suitable names for our workspace and Slack channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be asked to fill in email IDs for others who are collaborating on the
    same project. You can either skip this section or fill in the details and then
    continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that your Slack channel is ready, click on `See Your Channel in Slack`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once clicked, we should see our channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we are going to add the `Incoming Webhook` app to our Slack. From the left
    menu, select `Add apps` under the `Apps` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Incoming Webhooks` in the search field and then click on `Install` for
    `Incoming Webhook` app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `Add Configuration`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `Add Incoming WebHooks Integration`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the webhook URL. We will need this when we are writing the Kubeless function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The detailed steps on creating a Slack workspace with incoming webhook integration,
    along with the corresponding screenshots, are available on page 422.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to start the activity. Execute the following steps to complete
    this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Activity Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function in any language (supported by Kubeless) that can post messages
    to Slack. In this activity, we will write a Python function that performs the
    following steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `requests` library as a dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a `POST` request to the incoming webhook (created in step 2) with an input
    message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the response of the post request,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the function to the Kubeless framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to your Slack workspace and verify that the message was successfully posted
    to the Slack channel. The final output should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.76: Verifying whether the message was successfully posted'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_07_76.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.76: Verifying whether the message was successfully posted'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to the activity can be found on page 422.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned how to deploy a single-node Kubernetes cluster with
    Minikube. Then, we installed the Kubeless framework, Kubeless CLI, and Kubeless
    UI on top of our Minikube cluster. Once the Kubernetes cluster and Kubeless framework
    were ready, we created our first Kubeless function with Python and deployed it
    to Kubeless. Then, we discussed multiple ways of invoking Kubeless functions,
    namely with the Kubeless CLI, the Kubeless UI, HTTP triggers, scheduled triggers,
    and PubSub triggers. Next, we discussed how to debug common error scenarios that
    we encounter while deploying Kubeless functions. Then, we discussed how we can
    use the serverless framework to deploy a Kubeless function. Finally, in the activity,
    we learned how we can use a Kubeless function to send messages to a Slack channel.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we shall introduce OpenWhisk, and cover OpenWhisk actions
    and triggers.
  prefs: []
  type: TYPE_NORMAL

- en: Architectural Styles
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces the different architectural approaches or styles. Each
    section will discuss a different approach to designing software with its pros
    and cons, as well as describe when and how to apply it to reap its benefits. We'll
    begin this chapter by comparing stateful and stateless architectures. Next, we'll
    go from monolith systems, through various types of service-oriented designs, all
    the way to microservices. Then, we'll start to look at architectural styles from
    different angles by describing event-based systems, layered systems, and finally,
    modular designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have completed this chapter, you''ll be familiar with the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Deciding between stateful and stateless approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding monoliths—why they should be avoided, and recognizing exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding services and microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring event-based architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding layered architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning module-based architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to know what a software service is and be able to read code in
    C++11.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code from this chapter can be found at the following GitHub page: [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter02](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Deciding between stateful and stateless approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stateful and stateless are two opposite ways to write software, each with their
    own pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, stateful software's behavior depends on its internal state.
    Let's take a web service, for instance. If it remembers its state, the consumer
    of the service can send less data in each request, because the service remembers
    the context of those requests. However, saving on the request size and bandwidth
    has a hidden cost on the web service's side. If the user sends many requests at
    the same time, the service now has to synchronize its work. As multiple requests
    could change the state, at the same time, not having synchronization could lead
    to data races.
  prefs: []
  type: TYPE_NORMAL
- en: If the service was stateless, however, then each request coming to it would
    need to contain all the data needed to process it successfully. This means that
    the requests would get bigger and use up more bandwidth, but on the other hand,
    it would allow for better performance and scaling of the service. If you're familiar
    with functional programming, you would probably find stateless services intuitive.
    Processing each request can be understood as a call to a pure function. In fact,
    many of the advantages that stateless programming provides stem from its functional
    programming roots. Mutable state is the enemy of concurrent code. Functional programming
    relies on immutable values, even if this means making copies instead of modifying
    existing objects. Thanks to this, each thread can work independently and no data
    races are possible.
  prefs: []
  type: TYPE_NORMAL
- en: Since there are no race conditions, no locks are required as well, which can
    be an enormous boost in terms of performance. No locks also mean that you will
    no longer need to deal with deadlocks. Having pure functions means that your code
    will be easier to debug, too, since you don't have any side effects. Not having
    side effects, in turn, is also helpful for compilers, as optimizing code without
    side effects is a much easier task and can be performed more aggressively. Yet
    another benefit of writing code in a functional manner is that the sources you
    write tend to be more terse and expressive, especially when compared to code that
    heavily depends on the **Gang of Four** (**GoF**) design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't necessarily mean that if bandwidth is not an issue, you should
    always go with stateless. Those decisions can be made on many levels, from single
    classes or functions to whole applications.
  prefs: []
  type: TYPE_NORMAL
- en: Take classes, for example. If you're modeling, say, a `Consultant`, it makes
    sense that the class would contain fields such as the consultant's name, contact
    data, hourly rate, current and past projects, and whatnot. It is natural for it
    to be stateful. Now, imagine that you need to calculate the pay they receive for
    their work. Should you create a `PaymentCalculator` class? Should you add a member
    or a free function to calculate this? If you go with the class approach, should
    you pass a `Consultant` as a constructor parameter or a method argument? Should
    the class have properties such as allowances?
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a member function to calculate the pay would break the **Single Responsibility
    Principle** (**SRP)**, as now the class would then have two responsibilities:
    calculating the pay and storing the consultant''s data (state). This means introducing
    a free function or a separate class for this purpose should be preferred to having
    such hybrid classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Should there be a state in such a class in the first place? Let's discuss the
    different approaches to our `PaymentCalculator` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach would be to expose the properties required for calculation purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This approach has two cons. The first is that it's not thread-safe; a single
    instance of such a `PaymentCalculator` class cannot be used in multiple threads
    without locks. The second is that once our calculations become more complicated,
    the class will probably start duplicating more fields from our `Consultant` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To eliminate the duplication, we could rework our class to store a `Consultant`
    instance like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that since we cannot rebind references easily, we're using a helper class
    from the **Guideline Support Library** (**GSL**) to store a rebindable pointer
    in a wrapper that automatically ensures we're not storing a null value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach still has the disadvantage of not being thread-safe. Can we do
    any better? It turns out that we can make the class thread-safe by making it stateless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If there is no state to manage, it doesn't really matter if you decide to create
    free functions (perhaps in a distinct namespace) or group them as static functions
    of a class, as we did in the preceding snippet. In terms of classes, it's useful
    to distinguish between value (entity) types and operation types, as mixing them
    can lead to SRP violations.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless and stateful services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same principles that we discussed for classes can be mapped to higher-level
    concepts, for instance, microservices.
  prefs: []
  type: TYPE_NORMAL
- en: What does a stateful service look like? Let's take FTP as an example. If it's
    not anonymous, it requires the user to pass a username and password to create
    a session. The server stores this data to identify the user as still connected,
    so it's constantly storing state. Each time the user changes the working directory,
    the state gets updated. Each change done by the user is reflected as a change
    of state, even when they disconnect. Having a stateful service means that depending
    on the state, you can be returned different results for two identically looking
    `GET` requests. If the server loses the state, your requests can even stop processing
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful services can also have issues with incomplete sessions or unfinished
    transactions and added complexity. How long should you keep the sessions open?
    How can you verify whether the client has crashed or disconnected? When should
    we roll back any changes made? While you can come up with answers to those questions,
    it's usually easier to rely on the consumers of your service communicating with
    it in a dynamic, "intelligent" way. Since they'll be maintaining some kind of
    state on their own, having a service that also maintains the state is not only
    unnecessary but often wasteful.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless services, as the REST ones described later in the book, take the opposite
    approach. Each request must contain all the data required in order for it to be
    successfully processed, so two identical idempotent requests (such as `GET`) will
    cause identical replies. This is assuming the data stored on the server doesn't
    change, but data is not necessarily the same thing as state. All that matters
    is that each request is self-contained.
  prefs: []
  type: TYPE_NORMAL
- en: Statelessness is fundamental in modern internet services. The HTTP protocol
    is stateless, while many service APIs, for example, Twitter's, are stateless as
    well. REST, which Twitter's API relies on, is designed to be functionally stateless.
    The whole concept behind this acronym, **Representational State Transfer** (**REST**),
    carries the notion that all the state required for processing the request must
    be transferred within it. If this is not the case, you can't say you have a RESTful
    service. There are, however, some exceptions to the rule, driven by practical
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: If you're building an online store, you probably want to store information pertaining
    to your customers, such as their order history and shipping addresses. The client
    on the customer's side probably stores an authentication cookie, while the server
    will probably store some user data in a database. The cookie replaces our need
    for managing a session, as it'd be done in a stateful service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping sessions on the server side is a bad approach for services for several
    reasons: they add a lot of complexity that could be avoided, they make bugs harder
    to replicate, and most importantly, they don''t scale. If you''d want to distribute
    the load to another server, chances are you''d have trouble replicating the sessions
    with the load and synchronizing them between servers. All session information
    should be kept on the client''s side.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that if you wish to have a stateful architecture, you need to have
    a good reason to. Take the FTP protocol, for instance. It has to replicate the
    changes both on the client side and server side. The user only authenticates to
    a single, specific server, in order to perform single-stated data transfers. Compare
    this with services such as Dropbox, where the data is often shared between users
    and the file access is abstracted away through an API, to see why a stateless
    model would suit this case better.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding monoliths—why they should be avoided, and recognizing exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest architectural style in which you can develop your application is
    a monolithic one. This is why many projects are started using this style. A monolithic
    application is just one big block, meaning that functionally distinguishable parts
    of the application, such as dealing with I/O, data processing, and the user interface,
    are all interwoven instead of being in separate architectural components. Another
    notable example of this architectural style is the Linux kernel. Note that the
    kernel being monolithic does not stop it from being modular.
  prefs: []
  type: TYPE_NORMAL
- en: It can be easier to deploy such a monolithic application than a multi-component
    one as there is simply one thing that needs to be deployed. It can also be easier
    to test, as end-to-end testing just requires that you launch a single component.
    Integration is easier too since, as well as scaling your solution, you can just
    add more instances behind a load balancer. With all those advantages, why would
    anyone dread this architectural style? It turns out that despite those advantages,
    there are also many drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: The scalability offered sounds nice in theory, but what if your application
    has modules with different resource requirements? How about needing to scale just
    one module from your application? The lack of modularity, an inherent property
    of monolithic systems, is the source of many flaws associated with this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: What's more, the longer you develop a monolithic application, the more problems
    you'll have in maintaining it. It's a challenge to keep the internals of such
    an application loosely coupled, as it's so easy to just add yet another dependency
    between its modules. As such an application grows, it becomes harder and harder
    to understand it, so the development process will most probably slow down over
    time because of the added complexity. It can also be hard to maintain **Design-Driven
    Development**'s (**DDD**) bounded contexts when developing monoliths.
  prefs: []
  type: TYPE_NORMAL
- en: Having one big application has drawbacks regarding the deployment and execution
    sides as well. It will take a lot longer to start such an application than it
    would take to start more, smaller services. And regardless of what you change
    in the application, you might not like that it forces you to redeploy the whole
    application at once. Now, imagine that one of your developers introduces a resource
    leak in the application. If the leaky code is executed over and over, it will
    not only bring down its single aspect of the app's functionality, it can also
    bring down the rest of the application as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you're a fan of using bleeding-edge technologies in your project, a monolithic
    style doesn't bring any great news either. Since you now need to migrate your
    whole application at once, it's harder to update any libraries or frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding explanation suggests that a monolithic architecture is only good
    for simple and small applications. There is, however, one more situation where
    it could actually be a good idea to use it. If you care about performance, having
    a monolith can sometimes help you to squeeze more from your app in terms of latency
    or throughput when compared to microservices. Inter-process communication will
    always incur some overhead, which monolithic applications don't need to pay. If
    you're interested in measurements, see the paper listed in the *Further reading*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding services and microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because of the drawbacks of monolithic architectures, other approaches have
    emerged. A common idea is to split your solution into multiple services that communicate
    with each other. You can then split the development between different teams, each
    taking care of a separate service. The boundaries of each team's work are clear,
    unlike in the monolithic architecture style.
  prefs: []
  type: TYPE_NORMAL
- en: A **service-oriented architecture**, or **SOA** for short, means that the business
    functions are modularized and presented as separate services for the consumer
    applications to use. Each service should have a self-describing interface and
    hide any implementation details, such as the internal architecture, technologies,
    or the programming language used. This allows for multiple teams to develop the
    services however they like, meaning that under the hood, each can use what suits
    their needs best. If you have two teams of developers, one proficient in C# and
    one in C++, they can develop two services that can easily communicate with one
    another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advocates of SOA came up with a manifesto prioritizing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Business value over technical strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategic goals over project-specific benefits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intrinsic interoperability over custom integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared services over purpose-specific implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility over optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolutionary refinement over pursuit of initial perfection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even though this manifesto doesn''t bind you to a specific tech stack, or implementation,
    or type of services, the two most common types of services are SOAP and REST.
    Aside from those, recently, there''s a third one that has been growing in popularity:
    gRPC-based. You can find out more about these in the chapters on services-oriented
    architecture and microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, microservices is a software development pattern where
    an application is split as a collection of loosely-coupled services that communicate
    using lightweight protocols. The microservices pattern is similar to the UNIX
    philosophy stating that a program should only have one purpose. According to UNIX
    philosophy, advanced problems are solved by composing such programs into UNIX
    pipelines. Similarly, microservice-based systems are composed of many microservices
    and supporting services.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with an overview of the pros and cons of this architectural style.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and disadvantages of microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The small size of services in a microservice architecture means that they're
    faster to develop, deploy, and understand. As the services are built independently
    of each other, the time necessary to compile their new versions can be drastically
    reduced. Thanks to this, it is easier to employ rapid prototyping and development
    when dealing with this architectural style. This, in turn, makes it possible to
    reduce the lead-time, meaning that business requirements can be introduced and
    evaluated much quicker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other benefits of a microservice-based approach include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Modularity, which is inherent to this architectural style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better testability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility when replacing system parts (such as single services, databases,
    message brokers, or cloud providers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Integration with legacy systems: it is not necessary to migrate an entire application,
    just the parts that require current development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enabling distributed development: independent development teams can work on
    multiple microservices in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scalability: a microservice may be scaled independently of the others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, here are some disadvantages of microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: They require a mature DevOps approach and reliance on CI/CD automation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are harder to debug, and require better monitoring and distributed tracing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional overhead (in terms of auxiliary services) may outweigh the benefits
    for smaller applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now discuss what are the characteristics of services written in this architectural
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the microservice style is fairly recent, there is no single definition
    for microservices. According to Martin Fowler, there are several essential characteristics
    of microservices, which we will describe next:'
  prefs: []
  type: TYPE_NORMAL
- en: Each service should be an independently replaceable and upgradeable component.
    This is connected to easier deployment and loose coupling between the services,
    as opposed to components being libraries in a monolithic application. In the latter
    case, when you replace one library, you often have to redeploy the whole application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each service should be developed by a cross-functional team, focused on a specific
    business capability. Ever heard of Conway's law?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*"Any organization that designs a system (defined broadly) will produce a design
    whose structure is a copy of the organization''s communication structure."**–
    Melvyn Conway, 1967*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have cross-functional teams, you end up with software silos. The
    lack of communication that comes with them will make you constantly jump through
    hurdles to successfully deliver.
  prefs: []
  type: TYPE_NORMAL
- en: Each service should be a product, which is owned by the development team throughout
    its lifetime. This stays in contrast to the project mentality, where you develop
    software and just pass it on for someone to maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services should have smart endpoints and use dump pipes, not the other way around.
    This stands in contrast to traditional services, which often rely on the logic
    of an **Enterprise Service Bus** (**ESB**), which often manages the routing of
    messages and transforms them according to business rules. In microservices, you
    achieve cohesiveness by storing the logic in the service and avoid coupling with
    messaging components. Using "dumb" message queues, such as ZeroMQ, can help with
    this goal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services should be governed in a decentralized way. Monoliths are usually written
    using one specific technology stack. When they're being split into microservices,
    each one can choose whatever suits its own specific needs best. Governing and
    assuring that each microservice runs 24/7 is done by a team responsible for this
    specific service instead of a central department. Companies such as Amazon, Netflix,
    and Facebook follow this approach and observe that making developers responsible
    for the flawless execution of their services in production helps to ensure high
    quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services should manage their data in a decentralized way. Instead of having
    one database for all of them, each microservice can choose a database that best
    matches its needs. Having decentralized data can lead to some challenges with
    handling updates, but allows for better scaling. This is why microservices often
    coordinate in a transaction-free manner and offer eventual consistency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The infrastructure used by services should be managed automatically. To deal
    with dozens of microservices in an efficient manner, you need to have Continuous
    Integration and Continuous Delivery in place, as otherwise, deploying your services
    will be hell. Automated runs of all your tests will save you lots of time and
    trouble. Implementing Continuous Deployment on top of that will shorten the feedback
    loop and allow your customers to use your new features faster, too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices should be prepared for the failure of other services that they
    depend on. In a distributed deployment environment with so many moving parts,
    it's normal for some of them to break from time to time. Your services should
    be able to handle such failures gracefully. Patterns such as Circuit Breaker or
    Bulkhead (described later in the book) can help to achieve this. To make your
    architecture resilient, it's also critical to be able to bring failing services
    back up efficiently or even to know ahead of time that they're going to crash.
    Real-time monitoring of latency, throughput, and resource usage is essential for
    this. Get to know Netflix's Simian Army toolkit as it's invaluable for creating
    a resilient architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectures based on microservices should be ready to constantly evolve. You
    should design microservices and the cooperation between them in a manner that
    allows for easy replacement of a single microservice, or sometimes even groups
    of them. It's tricky to design the services properly, especially since some of
    the complexity that was once in the code of one bigger module can now be present
    as complex communication schemes between services, where it's harder to manage
    – so-called Spaghetti Integration. This means the experience and skill set of
    the architect plays a more important role than with traditional services or a
    monolithic approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On top of that, here are some other characteristics shared by many (but not
    all) microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: Using separate processes that communicate over network protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using technology-agnostic protocols (such as HTTP and JSON)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping services small and with a low runtime overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, you should have a good understanding of what the characteristics of microservice-based
    systems are, so let's see how this approach compares with other architectural
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices and other architectural styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microservices may be used as an architectural pattern on their own. However,
    they are often combined with other architectural choices, such as cloud-native
    computing, serverless applications, and mostly with lightweight application containers.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented architectures bring loose coupling and high cohesion. Microservices
    can do it too, when applied correctly. However, it can be somewhat challenging
    because it requires good intuition to partition the system into the usually vast
    amount of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: There are more similarities between microservices and their bigger cousins as
    they, too, can have SOAP-, REST-, or gRPC-based messaging and use technologies
    such as message queues for being event-driven. They also have well-known patterns
    to help with achieving the required quality attributes, such as fault tolerance
    (for example, through the isolation of faulty components), but in order to have
    an efficient architecture, you must decide on your approach to elements such as
    API gateways, service registries, load balancing, fault tolerance, monitoring,
    configuration management, and, of course, the technology stack to use.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microservices scale differently to monolithic applications. In monoliths, the
    entire functionality is handled by a single process. Scaling the application means
    replicating this process across different machines. Such scaling doesn't take
    into account which of the functionalities are heavily used and which do not require
    additional resources.
  prefs: []
  type: TYPE_NORMAL
- en: With microservices, each functional element is handled as a separate service,
    which means a separate process. In order to scale a microservices-based application,
    only the parts that require more resources can be replicated to different machines.
    Such an approach makes it easier to better use the available resources.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most companies have some kind of existing monolithic code that they don't want
    to immediately rewrite using microservices, but still want to transition to this
    kind of architecture. In such cases, it's possible to adapt microservices incrementally,
    by adding more and more services that interact with the monolith. You can create
    new functionalities as microservices or just cut out some parts of the monolith
    and create microservices out of them.
  prefs: []
  type: TYPE_NORMAL
- en: More details regarding microservices, including how to build your own from scratch,
    are available in [Chapter 13](ccc9ef2c-747a-4b56-9009-21382c7838d5.xhtml), *Designing
    Microservices*.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring event-based architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event-based systems are those whose architecture revolves around processing
    events. There are components that generate events, the channels through which
    the events propagate, and the listeners who react to them, potentially triggering
    new events too. It's a style that promotes asynchrony and loose coupling, which
    makes it a good way to increase performance and scalability, as well as an easy
    solution to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: With those advantages, there are also some challenges to solve. One of them
    is the complexity to create a system of this type. All the queues must be made
    fault-tolerant so that no events are lost in the middle of being processed. Processing
    transactions in a distributed way is also a challenge on its own. Using the Correlation
    ID pattern to track events between processes, along with monitoring techniques,
    can save you hours of debugging and scratching your head.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of event-based systems include stream processors and data integrations,
    as well as systems aiming for low latency or high scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now discuss common topologies used in such systems.
  prefs: []
  type: TYPE_NORMAL
- en: Common event-based topologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two main topologies of event-driven architectures are broker-based and mediator-based.
    Those topologies differ in how the events flow through the system.
  prefs: []
  type: TYPE_NORMAL
- en: The mediator topology is best used when processing an event that requires multiple
    tasks or steps that can be performed independently. All events produced initially
    land in the mediator's event queue. The mediator knows what needs to be done in
    order to handle the event, but instead of performing the logic itself, dispatches
    the event to appropriate event processors through each processor's event channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this reminds you of how business processes flow, then you''ve got good intuition.
    You can implement this topology in **Business Process Management** (**BPM**) or
    **Business Process Execution Language** (**BPEL**). However, you can also implement
    it using technologies such as Apache Camel, Mule ESB, and others:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50e74bcc-6cd2-4a56-b3ab-d0913cd785d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The mediator topology
  prefs: []
  type: TYPE_NORMAL
- en: 'A broker, on the other hand, is a lightweight component that contains all the
    queues and doesn''t orchestrate the processing of an event. It can require that
    the recipients subscribe to specific kinds of events and then simply forwards
    all the ones that are interesting for them. Many message queues rely on brokers,
    for example, ZeroMQ, which is written in C++ and aims for zero waste and low latency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ccd1a75-053f-4283-8776-6b8d9d759295.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The broker topology
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the two common topologies used in event-based systems, let's
    learn about a powerful architectural pattern using events at its core.
  prefs: []
  type: TYPE_NORMAL
- en: Event sourcing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can think of events as notifications that contain additional data for the
    notified services to process. There is, however, another way to think of them:
    a change of state. Think how easy it would be to debug issues with your application
    logic if you''d be able to know the state in which it was when the bug occurred
    and what change was requested of it. That''s one benefit of event sourcing. In
    essence, it captures all the changes that happen to the system by simply recording
    all the events in the sequence they happened.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you''ll find that the service no longer needs to persist its state in
    a database, as storing the events somewhere else in the system is enough. Even
    if it does, it can be done asynchronously. Another benefit that you derive from
    event sourcing is a complete audit log for free:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86b71086-b197-4f3a-8d89-33613cb3b087.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Event sourcing architecture. Providing a unified view of the application
    state can allow for consuming it and creating periodic snapshots for faster recovery
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the reduced need for data synchronization, event-sourced systems often
    offer low latency, which makes them a good fit for trading systems and activity
    trackers, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now learn about another popular architectural style.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding layered architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your architecture starts to look like spaghetti or you just want to prevent
    it, having your components structured in layers may help. Remember Model-View-Controller?
    Or maybe similar patterns, such as Model-View-ViewModel or Entity-Control-Boundary?
    Those are all typical examples of a layered architecture (also called N-tier architecture
    if the layers are physically separated from each other). You can structure code
    in layers, you can create layers of microservices, or apply this pattern to other
    areas where you think it could bring its benefits. Layering provides abstraction
    and the separation of concerns, and this is the main reason why it's being introduced.
    However, it can also help reduce complexity, while improving modularity, reusability,
    and maintainability of your solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'A real-world example would be in self-driving cars, where layers can be used
    to hierarchically make decisions: the lowest layer would handle the car''s sensors,
    then another layer would deal with single features consuming the sensor data,
    and on top of that one, there could be another one to ensure that all the features
    result in safe behavior. When sensors are replaced in another model of the car,
    only the lowest layer will need to be replaced.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A layered architecture is often pretty easy to implement since most developers
    already know the notion of layers – they simply need to develop several layers
    and stack them as in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b4d8943-f07f-46d2-b950-2885cbcd3668.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – An example of a 3-tiered architecture using a textual interface
    in the presentation layer
  prefs: []
  type: TYPE_NORMAL
- en: The challenge with creating an efficient layered architecture lays in specifying
    stable, well-defined interfaces between the layers. Often, you can have several
    layers on top of one. For instance, if you have a layer for domain logic, it can
    be a base for a presentation layer and a layer for providing APIs to other services.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't mean that layering is always a good thing. With microservices,
    there are two main scenarios where layering emerges. The first is when you want
    to separate one group of services from another. For instance, you could have a
    fast-changing layer to engage with your business partners, with content that changes
    frequently, and another business capabilities-oriented layer. The latter is not
    being changed at such a fast pace and is using stable technologies. Separating
    those two makes sense. There's also a notion that less stable components should
    rely on more stable components, so it's easy to see that you could have two layers
    here with the customer-facing one depending on the business capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The other scenario is when layers are created to reflect the communication structure
    of the organization (hello again, Conway's law). This will probably reduce communication
    between the teams, which can result in a decrease in innovation as now the teams
    won't know the internals or ideas of each other that well.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now discuss another example of a layered architecture often used with
    microservices—Backends for Frontends.
  prefs: []
  type: TYPE_NORMAL
- en: Backends for Frontends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's not uncommon to see many frontends that rely on the same backend. Let's
    say you have a mobile application and a web application, both using the same backend.
    It may be a good design choice at first. However, once the requirements and usage
    scenarios of those two applications diverge, your backend will require more and
    more changes, serving just one of the frontends. This can lead to the backend
    having to support competing requirements, like two separate ways to update the
    data store or different scenarios for providing data. Simultaneously, the frontends
    start to require more bandwidth to communicate with the backend properly, which
    also leads to more battery usage in mobile apps. At this point, you should consider
    introducing a separate backend for each frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, you can think of a user-facing application as being a single entity
    having two layers: the frontend and the backend. The backend can depend on another
    layer, consisting of downstream services. Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c197d4bb-ac3f-46e2-afea-c68ec914cf38.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – The Backends for Frontends pattern
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of using **Backends for Frontends** (**BFFs**) is that some code
    must be duplicated. As long as this speeds up development and is not a burden
    in the long term, it's OK. But it also means that you should be on the watch for
    possibilities to aggregate duplicated logic in a downstream service. Sometimes,
    introducing a service just to aggregate similar calls can help solve duplication
    issues. Often, if you have many frontends, some can still share a backend and
    not cause it to have competing requirements. If you're creating mobile applications
    for iOS and Android, for instance, you could think of reusing the same backend
    for those, and having separate ones for web and/or desktop applications.
  prefs: []
  type: TYPE_NORMAL
- en: Learning module-based architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, by modules, we mean software components that can be loaded
    and unloaded in runtime. For C++20's modules, refer to [Chapter 5](315eea2a-c029-4bc3-a159-4f897d393639.xhtml),
    *Leveraging C++ Language Features.*
  prefs: []
  type: TYPE_NORMAL
- en: If you've ever needed to run a component with as little downtime as possible,
    but for any reason couldn't apply the usual fault-tolerance patterns, such as
    redundant copies of your service, making this component module-based can come
    to save your day. Or you may just be attracted by a vision of a modular system
    with versioning of all the modules, with an easy lookup of all the available services,
    along with the decoupling, testability, and enhancing teamwork that module-based
    systems can cause. All of this is why **Open Service Gateway Initiative** (**OSGi**)
    modules were created for Java and got ported to C++ in more than a few frameworks.
    Examples of architectures using modules include IDEs such as Eclipse, **Software
    Defined Networking** (**SDN**) projects such as OpenDaylight, or home automation
    software such as OpenHAB.
  prefs: []
  type: TYPE_NORMAL
- en: OSGi also allows for automatic dependency management between modules, controlling
    their initialization and unloading, as well as controlling their discovery. Since
    it's service-oriented, you can think of using OSGi services as something akin
    to having tiny (micro?) services in one "container". This is why one of the C++
    implementations is named C++ Micro Services. To see them in action, refer to their
    *Getting Started* guide from the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting concept adopted by the C++ Micro Services framework is a new
    way to deal with singletons. The `GetInstance()` static function will, instead
    of just passing a static instance object, return a service reference obtained
    from the bundled context. So effectively, singleton objects will get replaced
    by services that you can configure. It can also save you from the static deinitialization
    fiasco, where multiple singletons that depend on each other have to unload in
    a specific order.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've discussed the various architectural styles that you can
    encounter in the wild and apply to your software. We've discussed monolithic architecture,
    went through service-oriented architecture, moved onto microservices, and discussed
    the various ways in which they can provide external interfaces and interact with
    each other. You learned how to write RESTful services and how to create a resilient
    and easy-to-maintain microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve also shown how to create simple clients to consume equally simple services.
    Later on, we discussed various other approaches to architecture: an event-driven
    one, a runtime module-based one, and showed where layering can be spotted and
    why. You now know how to implement event sourcing and recognize when to use BFFs.
    Moreover, you now know how architecture styles can help you achieve several quality
    attributes and what challenges this can bring.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to know which of those attributes are
    important in a given system.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. What are the traits of a RESTful service?
  prefs: []
  type: TYPE_NORMAL
- en: 2\. What toolkit can you use to aid you in creating a resilient distributed
    architecture?
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Should you use centralized storage for your microservices? Why/why not?
  prefs: []
  type: TYPE_NORMAL
- en: 4\. When should you write a stateful service instead of a stateless one?
  prefs: []
  type: TYPE_NORMAL
- en: 5\. How does a broker differ from a mediator?
  prefs: []
  type: TYPE_NORMAL
- en: 6\. What is the difference between an N-tier and an N-layer architecture?
  prefs: []
  type: TYPE_NORMAL
- en: 7\. How should you approach replacing a monolith with a microservice-based architecture?
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flygare, R., and Holmqvist, A. (2017). *Performance characteristics between
    monolithic and microservice-based systems (Dissertation*). Retrieved from [http://urn.kb.se/resolve?urn=urn:nbn:se:bth-14888](http://urn.kb.se/resolve?urn=urn:nbn:se:bth-14888)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engelen, Robert. (2008). *A framework for service-oriented computing with C
    and C++ web service components*. ACM Trans. Internet Techn. 8\. 10.1145/1361186.1361188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fowler, Martin. *Microservices – A definition of this new architectural term*.
    Retrieved from [https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa](https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started – C++ Micro Services documentation*. Retrieved from [http://docs.cppmicroservices.org/en/stable/doc/src/getting_started.html](http://docs.cppmicroservices.org/en/stable/doc/src/getting_started.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

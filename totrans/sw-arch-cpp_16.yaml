- en: Service-Oriented Architecture
  prefs: []
  type: TYPE_NORMAL
- en: A very common architecture for distributed systems is **Service-Oriented Architecture**
    (**SOA**). It's not a new invention, as this architectural style is almost as
    old as computer networking. There are many aspects of SOA ranging from an **Enterprise
    Service Bus** (**ESB**) to cloud-native microservices.
  prefs: []
  type: TYPE_NORMAL
- en: If your applications include web, mobile, or **Internet-of-Things** (**IoT**)
    interfaces, this chapter will help you understand how they can be built with a
    focus on modularity and maintainability. As most of the current systems work in
    a client-server (or other network topology) manner, learning about SOA principles
    will help you design and improve such systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SOA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopting messaging principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging managed services and cloud providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the examples presented in this chapter do not require any specific software.
    For an AWS API example, you will need the **AWS SDK for C++**, which can be found
    at [https://aws.amazon.com/sdk-for-cpp/](https://aws.amazon.com/sdk-for-cpp/).
  prefs: []
  type: TYPE_NORMAL
- en: The code present in the chapter has been placed on GitHub at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter12](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Service-Oriented Arcitecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service-Oriented Architecture is an example of a software design that features
    loosely coupled components that provide services to each other. The components
    use a shared communication protocol, usually over a network. In this design, services
    mean units of functionality that can be accessed outside of the originating component.
    An example of a component could be a mapping service that provides a map of the
    area in response to geographical coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the definition, a service has four properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a representation of business activity with a defined outcome.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is self-contained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is opaque to its users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may be composed of other services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Service-Oriented Architecture does not regulate how to approach the service
    orientation. It's a term that may be applied to many different implementations.
    There are discussions on whether some approaches actually should be considered
    to be Service-Oriented Architecture. We don't want to take part in these discussions,
    only to highlight some of the approaches that often are mentioned as SOA approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Let's compare some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise Service Bus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ESB is often the first association when someone says Service-Oriented Architecture.
    It's one of the oldest approaches to implementing SOA.
  prefs: []
  type: TYPE_NORMAL
- en: ESB draws an analogy from computer hardware architecture. Hardware architecture
    uses computer buses such as PCI to achieve modularity. This way, third-party providers
    are able to implement modules (such as graphic cards, sound cards, or I/O interfaces)
    independently of the motherboard manufacturer as long as everyone is adhering
    to the standards required by the bus.
  prefs: []
  type: TYPE_NORMAL
- en: Much like the PCI, the ESB architecture aims to build a standard, general-purpose
    way to allow for the interaction of loosely coupled services. Such services are
    expected to be developed and deployed independently. It should also be possible
    to combine heterogeneous services.
  prefs: []
  type: TYPE_NORMAL
- en: As with SOA itself, ESB is not defined by any global standard. To implement
    ESB, it is necessary to establish an additional component in the system. This
    component is the bus itself. The communication over ESB is event-driven and often
    achieved with the means of message-oriented middleware and message queues, which
    we'll discuss in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Enterprise Service Bus component serves the following roles:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the deployment and versioning of services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining service redundancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing messages between services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring and controlling the message exchange
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving contention between the components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing common services, such as event handling, encryption, or message queuing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcing Quality of Service (**QOS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are both proprietary commercial products as well as open source ones
    that implement the Enterprise Service Bus functionality. Some of the most popular
    open source products are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Apache Camel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache ServiceMix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Synapse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JBoss ESB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenESB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat Fuse (based on Apache Camel)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most popular commercial products are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: IBM Integration Bus (replacing IBM WebSphere ESB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Azure Service Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft BizTalk Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle Enterprise Service Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SAP Process Integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As with all the patterns and products that we present in this book, you will
    have to consider the strengths and weaknesses before deciding to go with a particular
    architecture. Some of the benefits of introducing Enterprise Service Bus are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Better scalability of services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed workload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can focus on configuration rather than implementing custom integration in services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An easier way to design loosely coupled services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services are replaceable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in redundancy capability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages, on the other hand, mostly revolve around the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A single point of failure – the ESB component's failure means the outage of
    an entire system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration is more complex, which impacts maintenance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message queuing, message translation, and other services provided by ESB may
    reduce performance or even become a bottleneck.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Web services are another popular implementation of Service-Oriented Architecture.
    By their definition, web services are services offered by one machine to another
    machine (or operator) where communication occurs over World Wide Web protocols.
    Even though W3C, the governing body concerning the World Wide Web, allows the
    use of other protocols such as FTP or SMTP, web services typically use HTTP as
    transport.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to implement web services using proprietary solutions,
    most implementations are based on open protocols and standards. Although many
    of the approaches are often referred to as web services, they are fundamentally
    different from each other. Later in the chapter, we will describe the various
    approaches in detail. For now, let's focus on their common features.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and disadvantages of web services
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The benefits of web services are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using popular web standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lot of tooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given next are the disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: A lot of overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some implementations are too complex (for example, SOAP/WSDL/UDDI specifications).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messaging and streaming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've mentioned message queues and message brokers already when covering the
    Enterprise Service Bus architecture. Other than as part of an ESB implementation,
    messaging systems may also be standalone architectural elements.
  prefs: []
  type: TYPE_NORMAL
- en: Message queues
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Message queues are components used for **Inter-Process Communication** (**IPC**).
    As the name suggests, they use the queue data structure to pass messages between
    different processes. Usually, message queues are a part of **Message-Oriented
    Middleware** (**MOM**) designs.
  prefs: []
  type: TYPE_NORMAL
- en: On the lowest level, message queues are available in UNIX specifications, both
    in System V and in POSIX. While they are interesting when implementing IPC on
    a single machine, we would like to focus on message queues that are suitable for
    distributed computing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are currently three standards used in open source software that are related
    to message queuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Message Queuing Protocol** (**AMQP**), a binary protocol operating
    on the application layer of the 7-Layer OSI model. Popular implementations include
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apache Qpid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache ActiveMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Event Hubs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Service Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streaming Text Oriented Messaging Protocol** (**STOMP**), a text-based protocol
    similar to HTTP (uses verbs such as `CONNECT`, `SEND`, `SUBSCRIBE`). Popular implementations
    include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apache ActiveMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: syslog-ng
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MQTT**, a lightweight protocol aimed at embedded devices. Popular implementations
    include home automation solutions such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OpenHAB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adafruit IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IoT Guru
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node-RED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home Assistant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pimatic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure IoT Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message brokers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Message brokers deal with the translation, validation, and routing of messages
    in a messaging system. Like message queues, they are parts of MOM.
  prefs: []
  type: TYPE_NORMAL
- en: Using message brokers, you can minimize the application's awareness regarding
    other parts of the system. This leads to designing loosely coupled systems, as
    message brokers take all the burden related to common operations on messages.
    It is known as a **Publish-Subscribe** (**PubSub**) design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Brokers typically manage message queues for receivers but are also able to
    perform additional functions, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Translating messages from one representation to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the message sender, receiver, or contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing messages to one or more destinations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregating, decomposing, and recomposing messages in transit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving data from external services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmenting and enriching messages through interaction with external services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling and responding to errors and other events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing different routing patterns, such as PubSub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popular implementations of message brokers are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Apache ActiveMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Kafka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Qpid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse Mosquitto MQTT Broker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NATS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS ActiveMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Kinesis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Service Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud computing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cloud computing is a broad term with a lot of different meanings. Initially,
    the term **cloud** referred to a layer of abstraction that the architecture shouldn't
    be too worried about. This could, for example, mean servers and network infrastructure
    managed by a dedicated operations team. Later, service providers started applying
    the term cloud computing to their own products that abstracted the underlying
    infrastructure with all its complexities. Instead of having to configure each
    piece of infrastructure individually, it was possible to use a simple **Application
    Programming Interface** (**API**) to set up all the necessary resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, cloud computing has grown to include many novel approaches to application
    architecture. It may consist of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Managed services, such as databases, cache layers, and message queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalable workload orchestration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container deployment and orchestration platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless computing platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important thing to remember when considering cloud adoption is that
    hosting your application in the cloud requires an architecture designed specifically
    for the cloud. Most often, it also means architecture designed specifically for
    the given cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: This means choosing a cloud provider is not just a decision about whether one
    choice is better than another at a given moment in time. It means that the future
    cost of switching a provider may be too big to warrant the move. Migration between
    providers requires architectural changes and for a working application, they may
    outweigh the savings expected from the migration.
  prefs: []
  type: TYPE_NORMAL
- en: There is also another consequence of cloud architecture design. For legacy applications,
    it means that in order to take advantage of the cloud benefits, the applications
    would first have to be rearchitected and rewritten. Migration to the cloud is
    not just a matter of copying binary and configuration files from on-premises hosting
    to virtual machines managed by a cloud provider. Such an approach would only mean
    a waste of money as cloud computing is only cost-effective if your applications
    are scalable and cloud-aware.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud computing doesn't necessarily mean using external services and leasing
    machines from third-party providers. There are also solutions such as OpenStack
    that run on-premises, which allow you to leverage the benefits of cloud computing
    using the servers you already own.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover managed services later in this chapter. Containers, cloud-native
    design, and serverless architecture will have their own dedicated chapters later
    in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is some debate regarding whether microservices are a part of SOA or not.
    Most of the time, the term SOA is pretty much equivalent to the ESB design. Microservices
    are in many respects the opposite of ESB. This leads to opinions that microservices
    are a distinct pattern from SOA, being the next step in the evolution of software
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We believe that they are, in fact, a modern approach to SOA that aims to eliminate
    some of the problems featured in ESB. After all, microservices fit within the
    definition of Service-Oriented Architecture very well.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are the subject of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Service-Oriented Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Splitting the system's functionality over multiple services has several benefits.
    First of all, each service can be maintained and deployed separately. This helps
    the team focus on a given task, without the need to understand every possible
    interaction within the system. It also enables agile development as tests only
    have to cover a particular service, not the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: The second benefit is that the modularity of the services helps create a distributed
    system. With a network (usually based on the Internet Protocol) as a means of
    communication, services can be split between different machines to provide scalability,
    redundancy, and better resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing new features and maintaining the existing software is a difficult
    task when there are many producers and many consumers for each service. This is
    why SOA encourages the use of documented and versioned APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to make it easier for both service producers and consumers to interact
    is by using established protocols that describe how to pass data and metadata
    between different services. These protocols may include SOAP, REST, or gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: The use of APIs and standard protocols makes it easy to create new services
    that provide added value over the existing ones. Considering we have a service,
    A, that returns our geographical location and another service, B, that provides
    the current temperature for a given location, we can invoke A and use its response
    in a request to B. This way, we get the current temperature for the current location
    without implementing the entire logic on our own.
  prefs: []
  type: TYPE_NORMAL
- en: All of the complexity and implementation details of both services are unknown
    to us and we treat them as **black boxes**. The maintainers of both services may
    also introduce new functionality and release new versions of the services without
    the need to inform us about it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and experimenting with Service-Oriented Architecture is also easier
    than with monolithic applications. A small change in a single place doesn't require
    the recompilation of an entire code base. It is often possible to invoke services
    in an ad hoc manner using client tools.
  prefs: []
  type: TYPE_NORMAL
- en: Let's return to our example with the weather and geographical location service.
    If both services are exposing a REST API, we are able to build a prototype using
    nothing more than a cURL client to send appropriate requests manually. When we
    confirm that the response is satisfactory, we may then start writing code that
    will automate the entire operation and possibly expose the results as another
    service.
  prefs: []
  type: TYPE_NORMAL
- en: To get the benefits of SOA, we need to remember that all of the services have
    to be loosely coupled. If services depend on each other's implementation, it means
    they are no longer loosely coupled and are tightly coupled instead. Ideally, any
    given service should be replaceable by a different analogous service without impacting
    the operation of the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: In our weather and location example, this means that reimplementing a location
    service in a different language (say, switching from Go to C++) should not affect
    the downstream consumers of that service as long as they use the established API.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to still introduce breaking changes in the API by releasing a
    new API version. A client connecting to version 1.0 would observe the legacy behavior
    while clients connecting to 2.0 would benefit from bugfixes, better performance,
    and other improvements that come at the cost of compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: For services relying on HTTP, API versioning usually occurs at the URI level.
    So a version 1.0, 1.1, or 1.2 API can be accessed when calling [https://service.local/v1/customer](https://service.local/v1/customer)
    while the version 2.0 API resides at [https://service.local/v2/customer](https://service.local/v2/customer).
    An API gateway, HTTP proxy, or a load balancer is then able to route the requests
    to appropriate services.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges with SOA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introducing an abstraction layer always comes at a cost. The same rule applies
    to Service-Oriented Architecture. It's easy to see the abstraction costs when
    looking at Enterprise Service Bus, web services, or message queues and brokers.
    What may be less obvious is that microservices also come at a cost. Their cost
    is related to the **Remote Procedure Call** (**RPC**) frameworks they use and
    the resource consumption related to service redundancy and duplication of their
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Another target of criticism related to SOA is the lack of uniform testing frameworks.
    Individual teams that develop the services of an application may use tooling unknown
    to other teams. Other issues related to testing are that the heterogeneous nature
    and interchangeability of components mean there is a huge set of combinations
    to test. Some combinations may introduce edge cases that are not typically observed.
  prefs: []
  type: TYPE_NORMAL
- en: As the knowledge about particular services is mostly concentrated in a single
    team, it is much harder to understand how an entire application works.
  prefs: []
  type: TYPE_NORMAL
- en: When the SOA platform is developed during the lifetime of an application, it
    may introduce the need for all the services to update their version to target
    the recent platform development. This means that instead of introducing new features,
    developers would be focused on making sure their application functions correctly
    after the changes to the platform. In an extreme case, maintenance costs may rise
    drastically for those services that don't see new releases and are constantly
    patched to adhere to platform requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Service-Oriented Architecture follows Conway's law, described in [Chapter 2](6fbde08c-f8a2-475d-9984-2a9882a761b4.xhtml),
    *Architectural Styles*.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting messaging principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've mentioned previously in this chapter, messaging has many different
    use cases, ranging from IoT and sensor networks to microservices-based distributed
    applications running in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of messaging is that it is a neutral way to connect services
    implemented using different technologies. When developing an SOA, each service
    is typically developed and maintained by a dedicated team. Teams may choose the
    tools they feel comfortable with. This applies to programming languages, third-party
    libraries, and build systems.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining a uniform set of tools may be counter-productive as different services
    may have different needs. For example, a kiosk application may require a **Graphical
    User Interface** (**GUI**) library such as Qt. A hardware controller that is a
    part of the same application will have other requirements, possibly linking to
    the hardware manufacturer's third-party components. These dependencies may then
    impose some restrictions that cannot be satisfied for both components simultaneously
    (for example, a GUI application may require a recent compiler, while the hardware
    counterpart may be pinned to an older one). Using messaging systems to decouple
    these components lets them have separate life cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some use cases for messaging systems include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Financial operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fleet monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logistics capturing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data order fulfillment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task queuing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following sections focus on the messaging systems designed for low overhead
    and message systems with brokers used for distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Low-overhead messaging systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Low-overhead messaging systems are typically used in environments that either
    require a small footprint or low latency. These are usually sensor networks, embedded
    solutions, and IoT devices. They are less common in cloud-based and distributed
    services, but it's still possible to use them in such solutions.
  prefs: []
  type: TYPE_NORMAL
- en: MQTT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**MQTT** stands for **Message Queuing Telemetry Transport**. It is an open
    standard both under OASIS and ISO. MQTT uses the PubSub model usually over TCP/IP,
    but it can also work with other transport protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, MQTT's design goals are a low-code footprint and the possibility
    of running in low-bandwidth locations. There is a separate specification called
    **MQTT-SN**, which stands for **MQTT for Sensor Networks**. It focuses on battery-powered
    embedded devices without the TCP/IP stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'MQTT uses a message broker that receives all the messages from the client and
    routes those messages to their destinations. QoS is provided on three levels:'
  prefs: []
  type: TYPE_NORMAL
- en: At most once delivery (no guarantee)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least once delivery (acknowledged delivery)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exactly once delivery (assured delivery)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be no surprise that MQTT is especially popular with various IoT applications.
    It's supported by OpenHAB, Node-RED, Pimatic, Microsoft Azure IoT Hub, and Amazon
    IoT. It's also popular with instant messaging, being used in ejabberd and Facebook
    Messanger. Other use cases include carsharing platforms, logistics, and transportation.
  prefs: []
  type: TYPE_NORMAL
- en: The two most popular C++ libraries supporting this standard are Eclipse Paho
    and mqtt_cpp based on C++14 and Boost.Asio. For Qt applications, there's also
    qmqtt.
  prefs: []
  type: TYPE_NORMAL
- en: ZeroMQ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ZeroMQ is a brokerless messaging queue. It supports common messaging patterns,
    such as PubSub, client/server, and several others. It is independent of a particular
    transport and may be used with TCP, WebSockets, or IPC.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea, contained in the name, is that ZeroMQ requires zero brokers and
    zero administration. It is also advocated as providing zero latency, which means
    no latency is added coming from the presence of a broker.
  prefs: []
  type: TYPE_NORMAL
- en: The low-level library is written in C, and it has implementations for various
    popular programming languages, including C++. The most popular implementation
    for C++ is cppzmq, which is a header-only library targeting C++11.
  prefs: []
  type: TYPE_NORMAL
- en: Brokered messaging systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two most popular messaging systems that don't focus on low overhead are
    AMQP-based RabbitMQ and Apache Kafka. Both are mature solutions that are extremely
    popular in a lot of different designs. Many articles focus on superiority in a
    particular area of either RabbitMQ or Apache Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: This is a slightly incorrect point of view as both messaging systems are based
    on different paradigms. Apache Kafka focuses on streaming vast amounts of data
    and storing the stream in persistent memory to allow future replay. RabbitMQ,
    on the other hand, is often used as a message broker between different microservices
    or a task queue to handle background jobs. For this reason, routing in RabbitMQ
    is much more advanced than the one present in Apache Kafka. Kafka's primary use
    cases are data analysis and real-time processing.
  prefs: []
  type: TYPE_NORMAL
- en: While RabbitMQ uses the AMQP protocol (and supports other protocols as well,
    such as MQTT and STOMP), Kafka uses its own protocol based on TCP/IP. This means
    that RabbitMQ is interoperable with other existing solutions based on these supported
    protocols. If you write an application that uses AMQP to interact with RabbitMQ,
    it should be possible to migrate it later to use Apache Qpid, Apache ActiveMQ,
    or managed solutions from AWS or Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: The scaling concerns could also drive the choice of one message broker over
    another. The architecture of Apache Kafka allows for easy horizontal scaling,
    which means adding more machines to the existing pool of workers. RabbitMQ, on
    the other hand, was designed with vertical scaling in mind, which means adding
    more resources to the existing machine, rather than adding more machines of similar
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Using web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier in the chapter, the common characteristic of web services
    is that they are based on standard web technologies. Most of the time, this will
    mean the **Hypertext Transfer Protocol** (**HTTP**) and this is the technology
    we will focus on. Although it is possible to implement web services based on different
    protocols, such services are extremely rare and therefore out of our scope.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for debugging web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the major benefits of using HTTP as transport is the wide availability
    of tools. For the most part, testing and debugging a web service may be performed
    using nothing more than a web browser. Apart from that, there are a lot of additional
    programs that may be helpful in automation. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The standard Unix file downloader `wget`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modern HTTP client `curl`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popular open source libraries such as libcurl, curlpp, C++ REST SDK, cpr (C++
    HTTP requests library), and NFHTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing frameworks such as Selenium or Robot Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser extensions such as Boomerang
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standalone solutions such as Postman and Postwoman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dedicated testing software including SoapUI and Katalon Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP-based web services work by returning an HTTP response to an HTTP request
    that uses appropriate HTTP verbs (such as GET, POST, and PUT). The semantics of
    how the request and the response should look and what data they should convey
    differs from implementation to implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most implementations fall into one of two categories: XML-based web services
    and JSON-based web services. JSON-based web services are currently displacing
    XML-based ones, but it is still common to find services that use XML formats.'
  prefs: []
  type: TYPE_NORMAL
- en: For dealing with data encoded with either JSON or XML, additional tools such
    as xmllint, xmlstarlet, jq, and libxml2 may be required.
  prefs: []
  type: TYPE_NORMAL
- en: XML-based web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first web services that gained traction were primarily based on XML. **XML**
    or **eXtensible Markup Language** was at the time the interchange format of choice
    in distributed computing and in the web environment. There were several different
    approaches to designing services with an XML payload.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible that you may want to interact with existing XML-based web services
    that are developed either internally within your organization or externally. However,
    we advise you to implement new web services using more lightweight methods, such
    as JSON-based web services, RESTful web services, or gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: XML-RPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the first standards that emerged was called XML-RPC. The idea behind
    the project was to provide an RPC technology that would compete with the then
    prevalent **Common Object Model** (**COM**), and CORBA. The aim was to use HTTP
    as a transport protocol and make the format human-readable and human-writable
    as well as parsable to machines. To achieve that, XML was chosen as the data encoding
    format.
  prefs: []
  type: TYPE_NORMAL
- en: When using XML-RPC, the client that wants to perform a remote procedure call
    sends an HTTP request to the server. The request may have multiple parameters.
    The server answers with a single response. The XML-RPC protocol defines several
    data types for parameters and results.
  prefs: []
  type: TYPE_NORMAL
- en: Although SOAP features similar data types, it uses XML schema definitions, which
    make the messages much less readable than the ones in XML-RPC.
  prefs: []
  type: TYPE_NORMAL
- en: Relationship to SOAP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since XML-RPC is no longer actively maintained, there aren't any modern C++
    implementations for the standard. If you want to interact with XML-RPC web services
    from modern code, the best way may be to use the gSOAP toolkit that supports XML-RPC
    and other XML web service standards.
  prefs: []
  type: TYPE_NORMAL
- en: The main criticism of XML-RPC was that it didn't give much value over sending
    plain XML requests and responses while making the messages significantly larger.
  prefs: []
  type: TYPE_NORMAL
- en: As the standard evolved, it became SOAP. As SOAP it formed the basis for the
    W3C web services stack of protocols.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The original abbreviation of **SOAP** stood for **Simple Object Access Protocol**.
    The abbreviation was dropped in version 1.2 of the standard. It's an evolution
    of the XML-RPC standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'SOAP consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The SOAP envelope**, defining the message''s structure and processing rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The SOAP header** rules defining application-specific data types (optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The SOAP body**, which carries remote procedure calls and responses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example SOAP message using HTTP as transport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The example uses standard HTTP headers and the POST method to call a remote
    procedure. One header that is unique to SOAP is the `SOAPAction`. It points to
    a URI identifying the intent of the action. It is up to the clients to decide
    how to interpret this URI.
  prefs: []
  type: TYPE_NORMAL
- en: '`soap:Header` is optional so we leave it empty. Together with `soap:Body`,
    it is contained within `soap:Envelope`. The main procedure call takes place within
    `soap:Body`. We introduce our own XML namespace that is specific to the Dominican
    Fair application. The namespace points to the root of our domain. The procedure
    we call is `FindMerchants` and we provide three arguments: latitude, longtitude,
    and distance.'
  prefs: []
  type: TYPE_NORMAL
- en: As SOAP was designed to be extensible, transport-neutral, and independent of
    the programming model, it also led to the creation of other accompanying standards.
    This means it is usually necessary to learn all the related standards and protocols
    before using SOAP.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a problem if your application makes extensive use of XML and your
    development team is familiar with all the terms and specifications. However, if
    all you want is to expose an API for a third party, a much easier approach would
    be to build a REST API as it is much easier to learn for both producers and consumers.
  prefs: []
  type: TYPE_NORMAL
- en: WSDL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Web Services Description Language** (**WSDL**) provides a machine-readable
    description of how services can be called and how messages should be formed. Like
    the other W3C web services standards, it is encoded in XML.'
  prefs: []
  type: TYPE_NORMAL
- en: It is often used with SOAP to define interfaces that the web service offers
    and how they may be used.
  prefs: []
  type: TYPE_NORMAL
- en: Once you define your API in WSDL, you may (and should!) use automated tooling
    to help you create code out of it. For C++, one framework with such tools is gSOAP.
    It comes with a tool named `wsdl2h`, which will generate a header file out of
    the definition. You can then use another tool, `soapcpp2`, to generate bindings
    from the interface definition to your implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, due to the verbosity of the messages, the size and bandwidth
    requirements for SOAP services are generally huge. If this is not an issue, then
    SOAP can have its uses. It allows for both synchronous and asynchronous calls,
    as well as stateful and stateless operations. If you require rigid, formal means
    of communication, SOAP can provide them. Just make sure to use version 1.2 of
    the protocol due to the many improvements it introduces. One of them is the enhanced
    security of the services. Another is the improved definition of services themselves,
    which aids interoperability, or the ability to formally define the means of transportation
    (allowing for the usage of message queues), to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: UDDI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next step after documenting the web service interfaces is service discovery,
    which allows applications to find and connect to the services implemented by other
    parties.
  prefs: []
  type: TYPE_NORMAL
- en: '**Universal Description, Discovery, and Integration** (**UDDI**) is a registry
    for WSDL files that may be searched manually or automatically. As with the other
    technologies discussed in this section, UDDI uses an XML format.'
  prefs: []
  type: TYPE_NORMAL
- en: UDDI registry may be queried with SOAP messages for automated service discovery.
    Even though UDDI provided the logical extensions of WSDL, its adoption in the
    open was disappointing. It is still possible to find UDDI systems used internally
    by companies.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP libraries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Two of the most popular libraries for SOAP are **Apache Axis** and **gSOAP**.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Axis is suitable for implementing both SOAP (including WSDL) and REST
    web services. It's worth noting that the library hasn't seen a new release for
    over a decade.
  prefs: []
  type: TYPE_NORMAL
- en: gSOAP is a toolkit that allows for creating and interacting with XML-based web
    services with a focus on SOAP. It handles data binding, SOAP and WSDL support,
    JSON and RSS parsing, UDDI APIs, and several other related web services standards.
    Although it doesn't use modern C++ features, it is still actively maintained.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-based web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JSON** stands for **JavaScript Object Notation**. Contrary to what the name
    suggests, it is not limited to JavaScript. It is language-independent. Parsers
    and serializers for JSON exist in most programming languages. JSON is much more
    compact than XML.'
  prefs: []
  type: TYPE_NORMAL
- en: Its syntax is derived from JavaScript as it was based on a JavaScript subset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supported data types for JSON are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number: The exact format may vary between implementations; defaults to the
    double-precision floating-point in JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String: Unicode-encoded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boolean: Using `true` and `false` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Array: May be empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Object: A map with key-value pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`: Representing an empty value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Packer` configuration presented in [Chapter 9](dba66494-c6a0-40f7-a6e8-c9612e996daf.xhtml),
    *Continuous Integration/Continuous Deployment,* is an example of a JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: One of the standards using JSON as a format is the JSON-RPC protocol.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-RPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSON-RPC is a JSON-encoded remote procedure call protocol similar to XML-RPC
    and SOAP. Unlike its XML predecessor, it requires little overhead. It is also
    very simple while maintaining the human-readability of XML-RPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how our previous example expressed in a SOAP call will look with JSON-RPC
    2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This JSON document still requires proper HTTP headers, but even with the headers,
    it is still considerably smaller than the XML counterpart. The only metadata present
    is the file with the JSON-RPC version and the request ID. The `method` and `params`
    fields are pretty much self-explanatory. The same can't always be said about SOAP.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the protocol is lightweight, easy to implement, and easy to use,
    it hasn't seen widespread adoption when compared to both SOAP and REST web services.
    It was released much later than SOAP and around the same time that REST services
    started to get popular. While REST quickly rose to success (possibly due to its
    flexibility), JSON-RPC failed to get similar traction.
  prefs: []
  type: TYPE_NORMAL
- en: Two useful implementations for C++ are libjson-rpc-cpp and json-rpc-cxx. json-rpc-cxx
    is a modern reimplementation of the previous library.
  prefs: []
  type: TYPE_NORMAL
- en: REpresentational State Transfer (REST)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative approach to web services is **REpresentional State Transfer (REST).**
    Services that conform to this architectural style are often called RESTful services.
    The main difference between REST and SOAP or JSON-RPC is that REST is based almost
    entirely on HTTP and URI semantics.
  prefs: []
  type: TYPE_NORMAL
- en: 'REST is an architectural style defining a set of constraints when implementing
    web services. Services that conform to this style are called RESTful. These constraints
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Must use a client-server model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statelessness (neither the client nor the server needs to store the state related
    to their communication).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cacheability (responses should be defined as cacheable or non-cacheable to benefit
    from standard web caching to improve scalability and performance).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layered system (proxies and load balancers should by no means affect the communication
    between the client and server).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'REST uses HTTP as the transport protocol with URIs representing resources and
    HTTP verbs that manipulate the resources or invoke operations. There is no standard
    regarding how each HTTP method should behave, but the semantics most often agreed
    on are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: POST – Create a new resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GET – Retrieve an existing resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PATCH – Update an existing resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DELETE – Delete an existing resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PUT – Replace an existing resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to reliance on web standards, RESTful web services can reuse existing components
    such as proxies, load balancers, and the cache. Thanks to the low overhead, such
    services are also very performant and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Description languages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like with XML-based web services, RESTful services can be described in
    both a machine and human-readable way. There are a few competing standards available,
    with OpenAPI being the most popular.
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OpenAPI is a specification overseen by the OpenAPI Initiative, part of the Linux
    Foundation. It used to be known as the Swagger Specification as it used to be
    a part of the Swagger framework.
  prefs: []
  type: TYPE_NORMAL
- en: The specification is language agnostic. It uses JSON or YAML input to generate
    documentation of methods, parameters, and models. This way, using OpenAPI helps
    to keep the documentation and source code up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a good selection of tools compatible with OpenAPI, such as code generators,
    editors, user interfaces, and mock servers. The OpenAPI generator can generate
    code for C++ using either cpp-restsdk or Qt 5 for client implementation. It can
    also generate server code using Pistache, Restbed, or Qt 5 QHTTPEngine. There''s
    also a convenient OpenAPI editor available online: [https://editor.swagger.io/](https://editor.swagger.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An API documented with OpenAPI would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first two fields (`openapi` and `info`) are metadata describing the document.
    The `paths` field contains all of the possible paths that correspond to the resources
    and methods of the REST interface. In the preceding example, we are only documenting
    a single path (`/item`) and a single method (`GET`). This method takes `itemId`
    as a required parameter. We provide a single possible response code, which is
    `200`. A 200 response contains a body that is a JSON document itself. The value
    associated with the `example` key is the example payload of a successful response.
  prefs: []
  type: TYPE_NORMAL
- en: RAML
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A competing specification, **RAML**, stands for **RESTful API Modeling Language**.
    It uses YAML for description and enables discovery, code reuse, and pattern-sharing.
  prefs: []
  type: TYPE_NORMAL
- en: The rationale behind establishing RAML was that while OpenAPI is a great tool
    to document existing APIs, it was not, at the time, the best way to design new
    APIs. Currently, the specification is being considered to become a part of the
    OpenAPI Initiative.
  prefs: []
  type: TYPE_NORMAL
- en: A RAML document may be converted to OpenAPI to make use of the available tooling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of an API documented with RAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example describes the same interface documented previously with OpenAPI.
    When serialized in YAML, both OpenAPI 3.0 and RAML 2.0 look very similar. The
    main difference is that OpenAPI 3.0 requires the use of JSON schema for documenting
    structures. With RAML 2.0, you can reuse the existing **XML Schema Definition**
    (**XSD**), which makes it easier to migrate from XML-based web services or to
    include external resources.
  prefs: []
  type: TYPE_NORMAL
- en: API Blueprint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: API Blueprint presents a different approach to the preceding two specifications.
    Instead of relying on either JSON or YAML, it uses Markdown to document data structures
    and endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Its approach is similar to the test-driven development methodology, as it encourages
    designing contracts before implementing features. This way, it is easier to test
    whether the implementation actually fulfills the contract.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with RAML, it is possible to convert the API Blueprint specification
    to OpenAPI as well as the other way round. There is also a command-line interface
    and a C++ library for parsing API Blueprints, called Drafter, which you can use
    in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a simple API documented with API Blueprint looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding, we see that a `GET` method directed at the `/item` endpoint
    should result in a response code of `200`. Below that is the JSON message that
    corresponds to the one our service will typically return.
  prefs: []
  type: TYPE_NORMAL
- en: API Blueprint allows for more natural documentation. The main disadvantage is
    that it is the least popular of the formats described so far. This means both
    the documentation and tooling are nowhere near the quality of OpenAPI.
  prefs: []
  type: TYPE_NORMAL
- en: RSDL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Similar to WSDL, **RSDL** (or **RESTful Service Description Language**), is
    an XML description for web services. It is language-independent and designed to
    be both human- and machine-readable.
  prefs: []
  type: TYPE_NORMAL
- en: It's much less popular than the previously presented alternatives. It is also
    much harder to read, especially compared to API Blueprint or RAML.
  prefs: []
  type: TYPE_NORMAL
- en: Hypermedia as the Engine of Application State
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although providing a binary interface such as a *gRPC-based* one can give you
    great performance, in many cases, you'll still want to have the simplicity of
    a RESTful interface. **Hypermedia as the Engine of Application State** (**HATEOAS**)
    can be a useful principle to implement if you want an intuitive REST-based API.
  prefs: []
  type: TYPE_NORMAL
- en: Just as you would open a web page and navigate based on the hypermedia shown,
    you can write your services with HATEOAS to achieve the same thing. This promotes
    the decoupling of server and client code and allows a client to quickly know what
    requests are valid to send, which is often not the case with binary APIs. The
    discovery is dynamic and based on the hypermedia provided.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a typical RESTful service, when executing an operation, you get
    JSON with data such as an object's state. With HATEOAS, aside from that, you would
    get a list of links (URLs) showing you the valid operations you can run on said
    object. The links (hypermedia) are the engine of the application. In other words,
    the available actions are determined by the state of the resources. While the
    term hypermedia may sound strange in this context, it basically means linking
    to the resources, including text, images, and video.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have a REST method allowing us to add an item by using the
    PUT method, we could add a return parameter that links to the resource created
    that way. If we use JSON for serialization, this could take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There is no universally accepted method of serializing HATEOAS hypermedia. On
    the one hand, it makes it easier to implement regardless of the server implementation.
    On the other hand, the client needs to know how to parse the response to find
    the relevant traversal data.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of HATEOAS is that it makes it possible to implement the
    API changes on the server side without necessarily breaking the client code. When
    one of the endpoints gets renamed, the new endpoint is referenced in subsequent
    responses, so the client is informed where to direct further requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same mechanism may provide features such as paging or make it easy to discover
    methods available for a given object. Getting back to our item example, here''s
    a possible response we could receive after making a `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we got links to two methods responsible for modifying the stock. If the
    stock is no longer available, our response will look like this (note that one
    of the methods is no longer advertised):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: One of the significant problems related to HATEOAS is that the two design principles
    seem to be at odds with each other. Adding traversable hypermedia would be much
    easier to consume if it were always presented in the same format. The freedom
    of expression here makes it harder to write clients unaware of the server's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Not all RESTful APIs can benefit from introducing this principle – by introducing
    HATEOAS you commit to writing clients in a specific manner so that they're able
    to benefit from this API style.
  prefs: []
  type: TYPE_NORMAL
- en: REST in C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft's C++ REST SDK is currently one of the best ways to implement RESTful
    APIs in C++ applications. Also known as cpp-restsdk, it is the library that we're
    using in this book to illustrate various examples.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A recent alternative to REST web services is GraphQL. The **QL** in the name
    stands for **Query Language**. Rather than relying on the server to serialize
    and present the necessary data, in GraphQL clients query and manipulate the data
    directly. Apart from the reversal of responsibility, GraphQL also features mechanisms
    that make it easier to work with data. Typing, static validation, introspection,
    and schemas are all parts of the specification.
  prefs: []
  type: TYPE_NORMAL
- en: There are server implementations of GraphQL available for a lot of languages
    including C++. One of the popular implementations is cppgraphqlgen from Microsoft.
    There are also many tools that help with development and debugging. What's interesting
    is that you can use GraphQL to query the database directly thanks to products
    such as Hasura or PostGraphile, which add the GraphQL API on top of a Postgres
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging managed services and cloud providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service-Oriented Architecture may be extended to the current cloud computing
    trend. While Enterprise Service Bus features services usually developed in-house,
    with cloud computing it is possible to use the services provided by one or more
    cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: While designing an application architecture for cloud computing, you should
    always consider the managed services offered by the provider before implementing
    any alternatives. For example, before you decide that you want to host your own
    PostgreSQL database with selected plugins, make sure you understand the trade-offs
    and costs when compared to a managed database hosting offered by your provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current cloud landscape provides a lot of services designed to handle popular
    use cases such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document (NoSQL) databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-memory cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container orchestration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computer vision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Natural language processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text-to-speech and speech-to-text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring, logging, and tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content delivery networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task management and scheduling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key and secret management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the huge choice of available third-party services, it is clear how cloud
    computing fits within Service-Oriented Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud computing as an extension of SOA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cloud computing is an extension of virtual machine hosting. What differentiates
    cloud computing providers from traditional VPS providers is two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud computing is available via an API, which makes it a service in itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides virtual machine instances, cloud computing offers additional services
    such as storage, managed databases, programmable networking, and many others.
    All of them are also available via an API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several ways you can use the cloud provider's API to feature in your
    application, which we will now present.
  prefs: []
  type: TYPE_NORMAL
- en: Using API calls directly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your cloud provider offers an API accessible in your language of choice,
    you can interact with the cloud resources directly from your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: you have an application that allows users to upload their own pictures.
    This application uses the Cloud API to create a storage bucket for each newly
    registered user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a C++ function that creates an AWS S3 bucket named
    after the username provided in the parameter. This bucket is configured to reside
    in a given region. If the operation fails, we want to get the error message and
    log it using `spdlog`.
  prefs: []
  type: TYPE_NORMAL
- en: Using API calls through a CLI tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some operations don''t have to be performed during the runtime of your application.
    They are typically run during the deployment and therefore may be automated in
    shell scripts, for example. One such use case is invoking a CLI tool to create
    a new VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We use the gcloud CLI tool from Google Cloud Platform to create a network called
    `database` that will be used to handle traffic from the private instances to the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party tools that interact with the Cloud API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at an example of running HashiCorp Packer to build a virtual machine
    instance image that is preconfigured with your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we provide the required credentials and region and employ
    a builder to prepare an instance from the Ubuntu image for us. The instance we
    are interested in needs to have 512 MB RAM. Then, we provide the instance first
    by sending a `.deb` package to it, and then by executing a shell command to install
    this package.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the cloud API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accessing cloud computing resources via an API is one of the most important
    features that distinguish it from traditional hosting. Using an API means you
    are able to create and delete instances at will without the intervention of an
    operator. This way, it becomes very easy to implement features such as load-based
    autoscaling, advanced deployments (Canary releases or Blue-Green), and automated
    development and testing environments for an application.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud providers usually expose their APIs as RESTful services. On top of that,
    they often also provide client libraries for several programming languages. While
    all of the three most popular providers support C++ as a client library, the support
    from smaller vendors may vary.
  prefs: []
  type: TYPE_NORMAL
- en: If you're thinking about deploying your C++ application to the cloud and plan
    on using the Cloud API, make sure your provider has released a C++ **Software
    Development Kit** (**SDK**). It is still possible to use the Cloud API without
    an official SDK, for example, using the CPP REST SDK library, but keep in mind
    this would require a lot more work to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the **Cloud SDK**, you will also need access control. Typically,
    there are two ways your application can be authenticated to use the Cloud API:'
  prefs: []
  type: TYPE_NORMAL
- en: '**By providing an API token**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API token should be secret and never stored as part of the version control
    system or inside a compiled binary. To prevent theft, it should also be encrypted
    at rest.
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways to pass the API token securely to the application is by means
    of a security framework such as HashiCorp Vault. It is programmable secret storage
    with built-in lease time management and key rotation.
  prefs: []
  type: TYPE_NORMAL
- en: '**By being hosted on an instance with appropriate access rights**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many cloud providers allow giving access rights to particular virtual machine
    instances. This way, an application hosted on such an instance doesn't have to
    authenticate using a separate token. Access control is then based on the instance
    the cloud API request originates from.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is easier to implement since it doesn't have to factor in the
    need for secret management. The downside is that when the instance becomes compromised,
    the access rights will be available to all of the applications running there,
    not just the application you've deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Using the cloud CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Cloud CLI is typically used by human operators to interact with the Cloud
    API. Alternatively, it may be used for scripting or using the Cloud API with languages
    that are officially unsupported.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following Bourne Shell script creates a resource group in
    the Microsoft Azure cloud and then creates a virtual machine belonging to that
    resource group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When looking for documentation on how to manage cloud resources, you will encounter
    a lot of examples using the Cloud CLI. Even if you wouldn't normally use the CLI,
    instead preferring a solution such as Terraform, having the Cloud CLI at hand
    may help you with debugging infrastructure problems.
  prefs: []
  type: TYPE_NORMAL
- en: Using tools that interact with the Cloud API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have already learned about the dangers of vendor lock-in when using products
    from cloud providers. Typically, each cloud provider will offer a different API
    and a different CLI to all the others. There are cases where smaller providers
    offer abstraction layers that allow accessing their products via an API similar
    to that of the well-known providers. This approach aims to help with migrating
    the application from one platform to another.
  prefs: []
  type: TYPE_NORMAL
- en: Such instances are rare, though, and in general, tools used to interact with
    services from one provider are incompatible with those from another provider.
    This is a problem not only when you consider migration from one platform to the
    next. It may also be problematic if you want to host your application on a variety
    of providers.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, there's a new set of tools, collectively known as **Infrastructure
    as Code** (**IaC**) tools, that offer an abstraction layer on top of different
    providers. These tools are not necessarily limited to cloud providers either.
    They're usually general-purpose and help to automate many different layers of
    your application's architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](https://cdp.packtpub.com/hands_on_software_architecture_with_c__/wp-admin/post.php?post=33&action=edit),
    *Continuous Integration and Continuous Deployment*, we briefly covered some of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New tools allow architects and developers to abstract the infrastructure even
    more and build, first and foremost, with the cloud in mind. Popular solutions
    such as Kubernetes and OpenShift are driving this trend, but the landscape consists
    of a lot of smaller players as well. The last chapter of this book is dedicated
    to cloud-native design and describes this modern approach to building applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about different approaches to implementing
    Service-Oriented Architecture. Since a service may interact with its environment
    in different ways, there are many architectural patterns to choose from. We've
    learned about the benefits and disadvantages of the most popular ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have focused on the architectural and implementational aspects of some of
    the widely popular approaches: message queues, web services including REST, and
    using managed services and cloud platforms. Other approaches that we will dig
    even deeper into will be presented in the standalone chapters, such as microservices
    and containers.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look into microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the properties of a service in Service-Oriented Architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some benefits of web services?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When are microservices not a good choice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the use cases of message queues?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the benefits of choosing JSON over XML?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does REST build on web standards?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do cloud platforms differ from traditional hosting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*SOA Made Simple*: [https://www.packtpub.com/product/soa-made-simple/9781849684163](https://www.packtpub.com/product/soa-made-simple/9781849684163)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SOA Cookbook*: [https://www.packtpub.com/product/soa-cookbook/9781847195487](https://www.packtpub.com/product/soa-cookbook/9781847195487)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

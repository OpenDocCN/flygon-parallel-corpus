- en: Appendix A
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for coming this far on this journey through software architecture.
    Our goal in writing this book was to help you make informed decisions regarding
    the design of your applications and systems. By now, you should feel confident
    when deciding whether to choose IaaS, PaaS, SaaS, or FaaS.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of things we haven't even touched on in this book as they were
    extensive and out of the scope of the book. Either we had too little experience
    with the given topic, or we thought that it was too niche. There are also areas
    that we felt were very important, but we couldn't find the right place for them
    in the chapters. You'll find them in this appendix.
  prefs: []
  type: TYPE_NORMAL
- en: Designing data storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now discuss the storage for your application. First let's decide whether
    you should go with SQL, NoSQL, or something else.
  prefs: []
  type: TYPE_NORMAL
- en: A good rule of thumb is to decide on the technology according to the size of
    your database. For small databases, say, those whose size will never grow into
    the terabyte area, going with SQL is a valid approach. If you have a very small
    database or want to create an in-memory cache, you can try SQLite. If you plan
    to go into single terabytes, again guaranteeing that the size will never get bigger
    than that, your best bet would be to go with NoSQL. It's possible in some cases
    to still stick to SQL databases, but it gets expensive quickly because of the
    costs of hardware, as you'll need a beast of a server for your master node. Even
    if it's not an issue, you should measure whether the performance is enough for
    your needs and be prepared for long maintenance windows. In some cases, it may
    also suit you to just run a cluster of SQL machines using technologies such as
    Citus, which is, in essence, a sharded PostgreSQL. However, usually, it's just
    cheaper and simpler to go with NoSQL in such cases. If the size of your database
    exceeds 10 TBs or you need to ingest data in real time, consider using a data
    warehouse instead of NoSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Which NoSQL technology should I use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The answer to this question depends on several factors. A few are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to store time series (save increments at small, regular intervals),
    then the best option would be to use InfluxDB or VictoriaMetrics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need something similar to SQL but could live without joins, or in other
    words, if you plan to store your data in columns, you can try out Apache Cassandra,
    AWS DynamoDB, or Google's BigTable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If that's not the case, then you should think about whether your data is a document
    without a schema, such as JSON or some kind of application logs. If that's the
    case, you could go with Elasticsearch, which is great for such flexible data and
    provides a RESTful API. You could also try out MongoDB, which stores its data
    in **Binary JSON** (**BSON**) format and allows MapReduce.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OK, but what if you don't want to store documents? Then you could opt for object
    storage, especially if your data is large. Usually, going with a cloud provider
    is OK in this case, which means that using Amazon's S3 or Google's Cloud Storage
    or Microsoft's Blob storage should help your case. If you want to go with something
    local, you could use OpenStack's Swift or deploy Ceph.
  prefs: []
  type: TYPE_NORMAL
- en: If file storage is also not what you're looking for, then perhaps your case
    is just about simple key-value data. Using such storage has its benefits as it's
    fast. This is why many distributed caches are built using it. Notable technologies
    include Riak, Redis, and Memcached (this last one is not suitable for persisting
    data).
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the previously mentioned options, you could consider using a tree-based
    database such as BerkeleyDB. Those databases are basically specialized key-value
    storage with path-like access. If trees are too restricting for your case, you
    might be interested in graph-oriented databases such as Neo4j or OrientDB.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While related to cloud-native design, serverless architecture is a popular topic
    on its own. It gained a lot of popularity since the introduction of FaaS or CaaS
    products, such as AWS Lambda, AWS Fargate, Google Cloud Run, and Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless is mostly an evolution of PaaS products such as Heroku. It abstracts
    the underlying infrastructure so that developers can focus on the application
    and not on infrastructural choices.
  prefs: []
  type: TYPE_NORMAL
- en: An additional benefit of serverless over older PaaS solutions is that you don't
    have to pay for what you don't use. Rather than paying for a given service level,
    you typically pay for the actual execution time of the deployed workload with
    serverless. If you only want to run a given piece of code once a day, you don't
    need to pay a monthly fee for an underlying server.
  prefs: []
  type: TYPE_NORMAL
- en: While we didn't get into too much detail about serverless, it is rarely used
    with C++. When it comes to FaaS, only AWS Lambda currently supports C++ as a possible
    language. Since containers are language-agnostic, you can use C++ applications
    and functions with CaaS products such as AWS Fargate, Azure Container Instances,
    or Google Cloud Run.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless functions may still be relevant to you if you want to run non-C++
    auxiliary code used along with your C++ application. Maintenance tasks and scheduled
    jobs are an excellent fit for serverless and they usually don't require the performance
    or efficiency of C++ binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Communication and culture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this book is software architecture. Why would we want to mention
    communication and culture in a book around software, then? If you think about
    it, all software is written *by* people *for* people. The human aspect is prevalent
    and yet we often fail to admit it.
  prefs: []
  type: TYPE_NORMAL
- en: As an architect, your role won't be to figure out the best approach to solving
    a given problem. You'll also have to communicate your proposed solution to your
    team members. Often, the choices you make will result from previous conversations.
  prefs: []
  type: TYPE_NORMAL
- en: These are the reasons communication and team culture also play a role in software
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In one of the early chapters, we've mentioned Conway's Law. This law states
    that the architecture of the software system reflects the organization that's
    working on it. This means that building great products requires building great
    teams and understanding psychology.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to be a great architect, learning people skills may be as important
    as learning technical ones.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've used the term DevOps (and DevSecOps) several times within this book. This
    topic deserves some additional space, in our opinion. DevOps is an approach to
    building software products that breaks with traditional silo-based development.
  prefs: []
  type: TYPE_NORMAL
- en: In the waterfall model, teams operated on single aspects of work independently
    of each other. The development team would write code, QA would test and validate
    the code, and security and compliance would come after that. Eventually, the operations
    team would take care of maintenance. The teams rarely communicated, and even then,
    it was usually a very formal process.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge about particular fields of expertise was only available to the teams
    responsible for a given piece of the workflow. Developers knew very little about
    QA and next to nothing about operations. While this setup was very convenient,
    the modern landscape requires more agility than the waterfall model can provide.
  prefs: []
  type: TYPE_NORMAL
- en: That's why a new model of working was proposed, one that encourages more collaboration,
    better communication, and lots of knowledge sharing between different stakeholders
    of a software product. While DevOps refers to bringing together developers and
    operations, what it means is bringing everyone closer.
  prefs: []
  type: TYPE_NORMAL
- en: Developers start working with QA and security even before they write the first
    lines of code. Operation engineers are more familiar with the code base. Businesses
    can easily track the progress of a given ticket and, in some cases, can even do
    a deployment preview in a self-service manner.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps has become synonymous with using particular tools such as Terraform or
    Kubernetes. But DevOps is by no means the same as using any specific tools. Your
    organization can follow the DevOps principles without using Terraform or Kubernetes,
    and it can use Terraform and Kubernetes while not practicing DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the principles of DevOps is that it encourages improved information
    flow among the product''s stakeholders. With that, it''s possible to fulfill another
    principle: reduce wasteful activities that don''t bring value to the end product.'
  prefs: []
  type: TYPE_NORMAL
- en: When you're building modern systems, it is worth doing so using modern methodology.
    Migrating an existing organization to DevOps may require a massive mindset shift,
    so it is not always possible. It's worth pursuing when starting a greenfield project
    that you have control over.
  prefs: []
  type: TYPE_NORMAL

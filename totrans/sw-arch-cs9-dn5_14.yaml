- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Service-Oriented Architectures with .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **Service-Oriented Architecture** (**SOA**) refers to a modular architecture
    where interaction between system components is achieved through communication.
    SOA allows applications from different organizations to exchange data and transactions
    automatically and allows organizations to offer services on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, as we discussed in the *Microservices and the evolution of the concept
    of modules* section of *Chapter 5*, *Applying a Microservice Architecture to Your
    Enterprise Application*, communication-based interaction solves binary compatibility
    and version mismatch problems that inevitably appear in complex systems made up
    of modules that share the same address space. Moreover, with SOA, you do not need
    to deploy different copies of the same component in the various systems/subsystems
    that use it – each component only needs to be deployed in just one place. This
    can be a single server, a cluster located in a single data center, or a geographically
    distributed cluster. Here, each version of your component is deployed just once,
    and the server/cluster logic automatically creates all the necessary replicas,
    thus simplifying the overall **Continuous Integration / Continuous Delivery**
    (**CI/CD**) cycle.
  prefs: []
  type: TYPE_NORMAL
- en: If a newer version conforms to the communication interface that is declared
    to the clients, no incompatibilities can occur. On the other hand, with DLLs/packages,
    when the same interface is maintained, incompatibilities may arise because of
    possible version mismatches in terms of the dependencies of other DLLs/packages
    that the library module might have in common with its clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Organizing clusters/networks of cooperating services was discussed in *Chapter
    5*, *Applying a Microservice Architecture to Your Enterprise Application*. In
    this chapter, we will mainly focus on the communication interface offered by each
    service. More specifically, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principles of the SOA approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOAP and REST web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does .NET 5 deal with SOA?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case – exposing WWTravelClub packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to publicly expose data from the WWTravelClub
    book use case through an ASP.NET Core service.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the Visual Studio 2019 free Community edition or better
    with all the database tools installed.
  prefs: []
  type: TYPE_NORMAL
- en: All the concepts in this chapter will be clarified with practical examples based
    on this book's WWTravelClub book use case. You will find the code for this chapter
    at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principles of the SOA approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like classes in an object-oriented architecture, services are implementations
    of interfaces that, in turn, come from a system's functional specifications. Therefore,
    the first step in a *service* design is the definition of its *abstract interface*.
    During this stage, you define all the service operations as interface methods
    that operate on the types of your favorite language (C#, Java, C++, JavaScript,
    and so on) and decide which operations to implement with synchronous communication
    and which ones to implement with asynchronous communication.
  prefs: []
  type: TYPE_NORMAL
- en: The interfaces that are defined in this initial stage will not necessarily be
    used in the actual service implementation and are just useful design tools. Once
    we have decided on the architecture of the services, these interfaces are usually
    redefined so that we can adapt them to the peculiarity of the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that SOA messages must keep the same kind of semantics
    as method calls/answers; that is, the reaction to a message must not depend on
    any previously received messages. Here, the messages must be independent of each
    other, and the service *must not remember* any previously received messages. This
    is what we call stateless development.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if the purpose of messages is to create a new database entry,
    this semantic must not change with the context of other messages, and the way
    the database entry is created must depend on the content of the current message
    and not on other previously received messages. Consequently, a client cannot create
    sessions and cannot log in to a service, perform some operations, and then log
    out. An authentication token must be repeated in each message.
  prefs: []
  type: TYPE_NORMAL
- en: The reasons for this constraint are modularity, testability, and maintainability.
    In fact, a session-based service would be very hard to test and modify due to
    the interactions that are *hidden* in the session data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have decided on the interface that is going to be implemented by a
    service, you must decide which communication stack/SOA architecture to adopt.
    The communication stack must be part of some official or *de facto* standard to
    ensure the interoperability of the service. Interoperability is the main constraint
    prescribed by SOA: services must offer a communication interface that does not
    depend on the specific communication library used, on the implementation language,
    or on the deployment platform.'
  prefs: []
  type: TYPE_NORMAL
- en: Considering you have decided on the communication stack/architecture, you need
    to adapt your previous interfaces to the peculiarities of the architecture (see
    the *REST web services* subsection of this chapter for more details). Then, you
    must translate these interfaces into the chosen communication language. This means
    that you must map all the programming language types into types that are available
    in the chosen communication language.
  prefs: []
  type: TYPE_NORMAL
- en: The actual translation of data is usually performed automatically by the SOA
    libraries that are used by your development environment. However, some configuration
    might be needed, and, in any case, we must be aware of how our programming language
    types are transformed before each communication. For instance, some numeric types
    might be transformed into types with less precision or with different ranges of
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The interoperability constraint can be interpreted in a lighter form in the
    case of microservices that are not accessible outside of their clusters, since
    they need to communicate with other microservices that belong to the same cluster.
    In this case, this means that the communication stack might be platform-specific
    so that it can increase performance, but it must be standard to avoid compatibility
    problems with other microservices that might be added to the cluster as the application
    evolves.
  prefs: []
  type: TYPE_NORMAL
- en: We have spoken of the *communication stack* and not of the *communication protocol*
    because SOA communication standards usually define the format of the message's
    content and provide different possibilities for the specific protocol that is
    used to embed those messages. For instance, the SOAP protocol just defines an
    XML-based format for the various kinds of messages, but SOAP messages can be conveyed
    by various protocols. Usually, the most common protocol that is used for SOAP
    is HTTP, but you may decide to jump to the HTTP level and send SOAP messages directly
    over TCP/IP for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The choice of communication stack you should adopt depends on several factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compatibility constraints**: If your service must be publicly available on
    the internet to business clients, then you must conform to the most common choices,
    which means using either SOAP over HTTP or JSON REST services. The most common
    choices are different if your clients are not business clients but **Internet
    of Things** (**IoT**) clients. Also, within IoT, the protocols that are used in
    different application areas can be different. For instance, marine vehicle status
    data is not typically exchanged with *Signal K*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development/deployment platform**: Not all communication stacks are available
    on all development frameworks and on all deployment platforms, but luckily, all
    the most common communication stacks that are used in public business services,
    such as SOAP and JSON-based REST communication, are available on all the main
    development/deployment platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: If your system is not exposed to the outside world and is
    a private part of your microservice cluster, performance considerations have a
    higher priority. In this scenario, gRPC, which we will discuss soon in this chapter,
    can be mentioned as a good option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability of tools and knowledge in your team**: Having knowledge and
    knowing about the availability of tools in your team/organization has an important
    weight when it comes to choosing between acceptable communication stacks. However,
    this kind of constraint always has less priority than compatibility constraints
    since it makes no sense to conceive a system that is easy to implement for your
    team but that almost nobody can use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility versus available features**: Some communication solutions, while
    less complete, offer a higher degree of flexibility, while other solutions, while
    being more complete, offer less flexibility. The need for flexibility started
    a movement from SOAP-based services to the more flexible REST services in the
    last few years. This point will be discussed in more detail when we describe SOAP
    and REST services in the remainder of this section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service description**: When services must be exposed on the internet, client
    applications need a publicly available description of the service specifications
    to design their communication clients. Some communication stacks include languages
    and conventions to describe service specifications. Formal service specifications
    that are exposed this way can be processed so that they automatically create communication
    clients. SOAP goes further and allows service discoverability by means of a public
    XML-based directory containing information about the tasks each web service can
    carry out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have chosen the communication stack you wish to use, you must use
    the tools that are available in your development environment to implement the
    service in a way that conforms to the chosen communication stack. Sometimes, communication
    stack compliance is automatically ensured by the development tools, but sometimes,
    it may require some development effort. For instance, in the .NET world, the compliance
    of SOAP services is automatically ensured by development tools if you use WCF,
    while the compliance of REST services falls under the developer''s responsibility.
    Some of the fundamental features of SOA solutions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Allows the client to authenticate to access service operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Handles the client''s permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: This is how communication is kept safe, that is, how to prevent
    unauthorized systems from reading and/or modifying the content of the communication.
    Typically, encryption prevents both unauthorized modifications and reading, while
    electronic signature algorithms prevent just modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exceptions**: Returns exceptions to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message reliability**: Ensures that messages reliably reach their destination
    in case of possible infrastructure faults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Though sometimes desirable, the following features are not always necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed transactions**: The capability to handle distributed transactions,
    thus undoing all the changes you have made whenever the distributed transactions
    fail or are aborted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support for the Publisher/Subscriber pattern**: If and how events and notifications
    are supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Addressing**: If and how references to other services and or service/methods
    are supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing**: If and how messages can be routed through a network of services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remainder of this section is dedicated to describing SOAP and REST services
    since they are the *de facto* standard for business services that are exposed
    outside of their clusters/servers. For performance reasons, microservices use
    other protocols, discussed in *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*; *Chapter 6*, *Azure Service Fabric*; and *Chapter
    7*, *Azure Kubernetes Service*. For inter-cluster communication, **Advanced Message
    Queuing Protocol** (**AMQP**) is used, and links are given in the *Further reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Simple Object Access Protocol** (**SOAP**) allows both one-way messages
    and answer/response messages. Communication can be both synchronous and asynchronous,
    but, if the underlying protocol is synchronous, such as in the case of HTTP, the
    sender receives an acknowledgment saying that the message was received (but not
    necessarily processed). When asynchronous communication is used, the sender must
    listen for incoming communications. Often, asynchronous communication is implemented
    with the Publisher/Subscriber pattern that we described in *Chapter 11*, *Design
    Patterns and .NET 5 Implementation*.
  prefs: []
  type: TYPE_NORMAL
- en: Messages are represented as XML documents called **envelopes**. Each envelope
    contains a `header`, a `body`, and a `fault` element. The `body` is where the
    actual content of the message is placed. The `fault` element contains possible
    errors, so it is the way exceptions are exchanged when communication occurs. Finally,
    the `header` contains any auxiliary information that enriches the protocol but
    does not contain domain data. For example, the `header` may contain an authentication
    token, and/or a signature if the message is signed.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying protocol that is used to send the XML envelopes is usually HTTP,
    but the SOAP specification allows any protocol, so we can use TCP/IP or SMTP directly.
    As a matter of fact, the more diffused underlying protocol is HTTP, so, if you
    do not have a good reason to choose another protocol, you should use HTTP in order
    to maximize the interoperability of the service.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP specifications contain the basics of message exchange, while other auxiliary
    features are described in separate specification documents called `WS- *` and
    are usually handled by adding extra information in the SOAP header. `WS-*` specifications
    handle all the fundamental and desirable features of SOA we listed previously.
    For instance, `WS-Security` takes care of security, including authentication,
    authorization, and encryption/signatures; `WS-Eventing` and `WS-Notification`
    are two alternative ways of implementing the Publisher/Subscriber pattern; `WS-ReliableMessaging`
    is concerned with the reliable delivery of messages in case of possible faults;
    and `WS-Transaction` is concerned with distributed transactions.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `WS-*` specifications are in no way exhaustive but are the more
    relevant and supported features. In fact, actual implementations in various environments
    (such as Java and .NET) furnish the more relevant `WS-*` services, but no implementation
    supports all the `WS-*` specifications.
  prefs: []
  type: TYPE_NORMAL
- en: All the XML documents/document parts involved in the SOAP protocol are formally
    defined in XSD documents, which are special XML documents whose content provides
    a description of XML structures. Also, all your custom data structures (classes
    and interfaces in an object-oriented language) must be translated into XSD if they
    are going to be part of a SOAP envelope.
  prefs: []
  type: TYPE_NORMAL
- en: Each XSD specification has an associated `namespace` that identifies the specification
    and a physical location where it can be found. Both the namespace and the physical
    location are URIs. The location URI does not need to be publicly accessible if
    the web service is accessible just from within an intranet.
  prefs: []
  type: TYPE_NORMAL
- en: The whole definition of a service is an XSD specification that may contain references
    to other namespaces, that is, to other XSD documents. Simply put, all the messages
    of a SOAP communication must be defined in an XSD specification. Then, a server
    and a client can communicate if they refer to the same XSD specifications. This
    means, for instance, that you need to create a new XSD specification each time
    you add another field to a message. After that, you need to update all the XSD
    files that reference the old message definition to the new message definition
    by creating a new version of them. In turn, these modifications require the creation
    of other versions for other XSD files, and so on. Therefore, simple modifications
    that maintain compatibility with the previous behavior (clients could simply ignore
    the field that was added) may cause an exponential chain of version changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the last few years, the difficulty in handling modifications, along with
    the complexity of handling the configuration of all the `WS-*` specifications
    and performance problems, caused a gradual move toward the simpler REST services
    that we will describe in the upcoming sections. This move started with services
    that were called from JavaScript due to the difficulty of implementing complete
    SOAP clients that were able to run efficiently in a web browser. Moreover, the
    complex SOAP machinery was oversized for the simple needs of the typical clients
    running in a browser and may have caused a complete waste of development time.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, services aimed at non-JavaScript clients started a massive
    move toward REST services, and nowadays the preferred choice is REST services,
    with SOAP being used either for compatibility with legacy systems or when features
    that are not supported by REST services are needed. A typical application area
    that continues to prefer the SOAP system is that of payment/banking systems because
    these systems need the transactional support that is offered by the `WS-Transaction`
    SOAP specification. There is no equivalent in the REST services world.
  prefs: []
  type: TYPE_NORMAL
- en: REST web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST services were initially conceived to avoid the complex machinery of SOAP
    in simple cases such as calls to a service from the JavaScript code of a web page.
    Then, they gradually became the preferred choice for complex systems. REST services
    use HTTP to exchange data in JSON or, less commonly, in XML format. Simply put,
    they replace the SOAP body with the HTTP body, the SOAP header with the HTTP header,
    and the HTTP response code replaces the fault element and furnishes further auxiliary
    information on the operation that was performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reason for the success of REST services is that HTTP already offers
    most of the SOAP features natively, which means we can avoid building a SOAP level
    on top of HTTP. Moreover, the whole HTTP machinery is simpler than SOAP: simpler
    to program, simpler to configure, and simpler to implement efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, REST services impose fewer constraints on the clients. Type compatibility
    between servers and clients conforms to the more flexible JavaScript type compatibility
    model because JSON is a subset of JavaScript. Moreover, when XML is used in place
    of JSON, it maintains the same JavaScript type compatibility rules. No XML namespaces
    need to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: When using JSON and XML, if the server adds some more fields to the response
    while keeping the same semantic of all the other fields compatible with the previous
    client, they can simply ignore the new fields. Accordingly, changes that are made
    to a REST service definition only need to be propagated to previous clients in
    case of breaking changes that cause actual incompatible behavior in the server.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it is likely that changes will be self-limited and won't result in
    an exponential chain of changes because type compatibility does not require the
    reference to a specific type to be defined in a unique shared place and simply
    requires that the shape of types is compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Service type compatibility rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s clarify the REST service type compatibility rules with an example. Imagine
    that several services use a `Person` object that contains `Name`, `Surname`, and
    `Address` string fields. This object is served by **S1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Type compatibility is ensured if the service and client refer to different
    copies of the preceding definition. It is also acceptable for the client to use
    a definition with fewer fields, since it can simply ignore all the other fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can only use a definition with fewer fields within your "own" code. Attempting
    to send information back to the server without the expected fields may cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine the scenario where you have an **S2** service that takes `Person`
    objects from **S1** and adds them to the responses it returns on some of its methods.
    Suppose the **S1** service that handles the `Person` object replaces the `Address`
    string with a complex object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After the breaking change, the **S2** service will have to adapt its communication
    client that calls the **S1** service to the new format. Then, it can convert the
    new `Person` format into the older one before using `Person` objects in its responses.
    This way, the **S2** service avoids propagating the breaking change of **S1**.
  prefs: []
  type: TYPE_NORMAL
- en: In general, basing type compatibility on the object shape (tree of nested properties),
    instead of a reference to the same formal type definition, increases flexibility
    and modifiability. The price we pay for this increased flexibility is that type
    compatibility cannot be computed automatically by comparing the formal definition
    of server and client interfaces. In fact, in absence of a univocal specification,
    each time a new version of the service is released, the developer must verify
    that the semantics of all the fields that the client and server have in common
    remain unchanged from the previous version.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea behind REST services is to give up the severity checks and complex
    protocols for greater flexibility and simplicity, while SOAP does exactly the
    opposite.
  prefs: []
  type: TYPE_NORMAL
- en: Rest and native HTTP features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The REST services manifesto states that REST uses native HTTP features to implement
    all the required service features. So, for instance, authentication will be performed
    directly with the HTTP `Authorization` field, encryption will be achieved with
    HTTPS, exceptions will be handled with an HTTP error status code, and routing
    and reliable messaging will be handled by the machinery the HTTP protocol relies
    on. Addressing is achieved by using URLs to refer to services, their methods,
    and other resources.
  prefs: []
  type: TYPE_NORMAL
- en: There is no native support for asynchronous communication since HTTP is a synchronous
    protocol. There is also no native support for the Publisher/Subscriber pattern,
    but two services can interact with the Publisher/Subscriber pattern by each exposing
    an endpoint to the other. More specifically, the first service exposes a subscription
    endpoint, while the second one exposes an endpoint where it receives its notifications,
    which are authorized through a common secret that is exchanged during the subscription.
    This pattern is quite common. GitHub also allows us to send our REST services
    to repository events.
  prefs: []
  type: TYPE_NORMAL
- en: REST services offer no easy options when it comes to implementing distributed
    transactions, which is why payment/banking systems still prefer SOAP. Luckily,
    most application areas do not need the strong form of consistency that is ensured
    by distributed transactions. For them, lighter forms of consistency, such as *eventual
    consistency*, are enough and are preferred for performance reasons. Please refer
    to *Chapter 9*, *How to Choose Your Data Storage in the Cloud*, for a discussion
    on the various types of consistencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The REST manifesto not only prescribes the usage of the predefined solutions
    that are already available in HTTP but also the usage of a web-like semantic.
    More specifically, all the service operations must be conceived as CRUD operations
    on resources that are identified by URLs (the same resource may be identified
    by several URLs). In fact, REST is the acronym for **Representational State Transfer**,
    meaning that each URL is the representation of some sort of object. Each kind
    of service request needs to adopt the appropriate HTTP verb, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` (Read operation): The URL represents the resource that is returned by
    the read operation. Thus, `GET` operations mimic pointer dereferencing. In the
    case of a successful operation, a 200 (OK) status code is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` (Creation operation): The JSON/XML object that is contained in the request
    body is added as a new resource to the object represented by the operation URL.
    If the new resource is successfully created immediately, a 201 (created) status
    code is returned, along with a response object that depends on the operation and
    the indicative about where the created resource can be retrieved from. The response
    object should contain the most specific URL that identifies the created resource.
    If creation is deferred to a later time, a 202 (accepted) status code is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` (Edit operation): The JSON/XML object contained in the request body replaces
    the object referenced by the request URL. In the case of successful operation,
    a 200 (OK) status code is returned. This operation is idempotent, meaning that
    repeating the same request twice causes the same modification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: The JSON/XML object contained in the request body contains instructions
    on how to modify the object referenced by the request URL. This operation is not
    idempotent since the modification may be an increment of a numeric field. In the
    case of successful operation, a 200 (OK) status code is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: The resource referenced by the request URL is removed. In the case
    of successful operation, a 200 (OK) status code is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the resource has been moved from the request URL to another URL, a redirect
    code is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '`301` (moved permanently), plus the new URL where we can find the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`307` (moved temporarily), plus the new URL where we can find the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the operation fails, a status code that depends on the kind of failure is
    returned. Some examples of failures codes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`400` (bad request): The request that was sent to the server is ill-formed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404` (not found): When the request URL does not refer to any known object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`405` (method not allowed): When the request verb is not supported by the resource
    referenced by the URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`401` (unauthorized): The operation requires authentication, but the client
    has not furnished any valid authorization header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`403` (forbidden): The client is correctly authenticated but has no right to
    perform the operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list of status codes is not exhaustive. References to an exhaustive
    list will be provided in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: It is fundamental to point out that `POST`/`PUT`/`PATCH`/`DELETE` operations
    may have – and usually have – side effects on other resources. Otherwise, it would
    be impossible to code operations that act simultaneously on several resources.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the HTTP verb must conform with the operation that is performed
    on the resource and referenced by the request URL, but the operation might affect
    other resources. The same operation might be performed with a different HTTP verb
    on one of the other involved resources. It is the developer's responsibility to
    choose which way to perform the same operation to implement it in the service
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the side effects of HTTP verbs, REST services can encode all these
    operations as CRUD operations on resources represented by URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Often, moving an existing service to REST requires us to split the various inputs
    between the request URL and the request body. More specifically, we extract the
    input fields that univocally define one of the objects involved in the method's
    execution and use them to create a URL that univocally identifies that object.
    Then, we decide on which HTTP verb to use based on the operation that is performed
    on the selected object. Finally, we place the remainder of the input in the request
    body.
  prefs: []
  type: TYPE_NORMAL
- en: If our services were designed with an object-oriented architecture focused on
    the business domain objects (such as DDD, as described in *Chapter 12*, *Understanding
    the Different Domains in Software Solutions*), the REST translation of all the
    service methods should be quite immediate, since services should already be organized
    around domain resources. Otherwise, moving to REST might require some service
    interface redefinitions.
  prefs: []
  type: TYPE_NORMAL
- en: The adoption of full REST semantics has the advantage that services can be extended
    with or without small modifications being made to the preexisting operation definitions.
    In fact, extensions should mainly manifest as additional properties of some objects
    and as additional resource URLs with some associated operations. Therefore, preexisting
    clients can simply ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: Example of methods in the REST language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s learn how methods can be expressed in the REST language with a
    simple example of an intra-bank money transfer. A bank account can be represented
    by a URL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A transfer might be represented as a `PATCH` request whose body contains an
    object with properties representing the amount of money, time of transfer, description,
    and the account receiving the money.
  prefs: []
  type: TYPE_NORMAL
- en: The operation modifies the account mentioned in the URL, but also the receiving
    account as a *side effect*. If the account doesn't have enough money, a `403`
    (Forbidden) status code is returned, along with an object with all the error details
    (an error description, the available funds, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since all the bank operations are recorded in the account statement,
    the creation and addition of a new transfer object for a *bank account operations*
    collection associated with the bank account is a better way to represent the transfer.
    In this case, the URL might be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the HTTP verb is `POST` since we are creating a new object. The body content
    is the same and a `422` status code is returned if there is a lack of funds.
  prefs: []
  type: TYPE_NORMAL
- en: Both representations of the transfer cause the same changes in the database.
    Moreover, once the inputs are extracted from the different URLs and from the possibly
    different request bodies, the subsequent processing is the same. In both cases,
    we have the same inputs and the same processing – it is just the exterior appearance
    of the two requests that is different.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the introduction of the virtual *operations* collection allows us
    to extend the service with several more *operations* collection-specific methods.
    It is worth pointing out that the *operations* collection does not need to be
    connected with a database table or with any physical object: it lives in the world
    of URLs and creates a convenient way for us to model the transfer.'
  prefs: []
  type: TYPE_NORMAL
- en: The increased usage of REST services leads to a description of REST service
    interfaces to be created, like the ones developed for SOAP. This standard is called **OpenAPI**.
    We will talk about this in the following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenAPI standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenAPI is a standard that is used for describing the REST API. It is currently
    version 3\. The whole service is described by a JSON endpoint, that is, an endpoint
    that describes the service with a JSON object. This JSON object has a general
    section that applies to the whole service and contains the general features of
    the service, such as its version and description, as well as shared definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Then, each service endpoint has a specific section that describes the endpoint
    URL or URL format (in case some inputs are included in the URL), all its inputs,
    all the possible output types and status codes, and all the authorization protocols.
    Each endpoint-specific section can reference the definitions contained in the
    general section.
  prefs: []
  type: TYPE_NORMAL
- en: A description of the OpenAPI syntax is out of the scope of this book, but references
    are provided in the *Further reading* section. Various development frameworks
    automatically generate OpenAPI documentation by processing the REST API code and
    further information is provided by the developer, so your team does not need to
    have in-depth knowledge of OpenAPI syntax. An example of it is the `Swashbuckle.AspNetCore`
    NuGet package that we will present in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The *How does .NET 5 deal with SOA?* section explains how we can automatically
    generate OpenAPI documentation in ASP.NET Core REST API projects, while the use
    case at the end of this chapter provides a practical example of its usage.
  prefs: []
  type: TYPE_NORMAL
- en: We will end this subsection by talking about how to handle authentication and
    authorization in REST services.
  prefs: []
  type: TYPE_NORMAL
- en: REST service authorization and authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since REST services are sessionless, when authentication is required, the client
    must send an authentication token in every single request. That token is usually
    placed in the HTTP authorization header, but this depends on the type of authentication
    protocol you are using. The simplest way to authenticate is through the explicit
    transmission of a shared secret. This can be done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The shared secret is called an API key. Since, at the time of writing, there
    is no standard on how to send it, API keys can also be sent in other headers,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that API key-based authentication needs HTTPS to stop
    shared secrets from being stolen. API keys are very simple to use, but they do
    not convey information about user authorizations, so they can be adopted when
    the operations allowed by the client are quite standard and there are no complex
    authorization patterns. Moreover, when exchanged in requests, API keys are susceptible
    to being attacked on the server or client side. A common pattern to mitigate this
    is to create a "service account" user and restrict their authorizations to just
    those needed and use the API keys from that specific account when interacting
    with the API.
  prefs: []
  type: TYPE_NORMAL
- en: Safer techniques use shared secrets that are valid for a long period of time,
    just by the user logging in. Then, the login returns a short-life token that is
    used as a shared secret in all the subsequent requests. When the short-life secret
    is going to expire, it can be renewed with a call to a renew endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The whole logic is completely decoupled from the short-life token-based authorization
    logic. The login is usually based on login endpoints that receive long-term credentials
    and return short-life tokens. Login credentials are either usual username-password
    pairs that are passed as input to the login method or other kinds of authorization
    tokens that are converted into short-life tokens that are served by the login
    endpoint. Login can also be achieved with various authentication protocols based
    on X.509 certificates.
  prefs: []
  type: TYPE_NORMAL
- en: The most widespread short-life token type is the so-called bearer token. Each
    bearer token encodes information about how long it lasts and a list of assertions,
    called claims, that can be used for authorization purposes. Bearer tokens are
    returned by either login operations or renewal operations. Their characteristic
    feature is that they are not tied to the client that receives them or to any other
    specific client.
  prefs: []
  type: TYPE_NORMAL
- en: No matter how a client gets a bearer token, this is all a client needs to be
    granted all the rights implied by its claims. It is enough to transfer a bearer
    token to another client to empower that client with all the rights implied by
    all the bearer token claims, since no proof of identity is required by bearer
    token-based authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, once a client gets a bearer token, it can delegate some operations
    to third parties by transferring its bearer token to them. Typically, when a bearer
    token must be used for delegation, during the login phase, the client specifies
    the claims to include to restrict what operations can be authorized by the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to API key authentication, bearer token-based authentication is disciplined
    by standards. They must use the following `Authorization` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Bearer tokens can be implemented in several ways. REST services typically use
    JWT tokens that are strung with a Base64URL encoding of JSON objects. More specifically,
    JWT creation starts with a JSON header, as well as a JSON payload. The JSON header
    specifies the kind of token and how it is signed, while the payload consists of
    a JSON object that contains all the claims as property/value pairs. The following
    is an example header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the header and payload are Base64URL-encoded and the corresponding string
    is concatenated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding string is then signed with the algorithm specified in the header,
    which, in our example, is RSA +SHA256, and the signature string is concatenated
    with the original string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the final bearer token string. A symmetric signature can
    be used instead of RSA, but, in this case, both the JWT issuer and all the services
    using it for authorization must share a common secret, while, with RSA, the private
    key of the JWT issuer does not need to be shared with anyone, since the signature
    can be verified with just the issuer public key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some payload properties are standard, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iss`: Issuer of the JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aud`: The audience, that is, the services and/or operations that can use the
    token for authorization. If a service does not see its identifier within this
    list, it should reject the token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub`: A string that identifies the *principal* (that is, the user) to which
    the JWT was issued.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iat`, `exp`, and `nbf`: These are for the time the JWT was issued, its expiration
    time, and, if set, the time after which the token is valid, respectively. All
    the times are expressed as seconds from midnight UTC on January 1, 1970\. Here,
    all the days are considered as having exactly 86,400 seconds in them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other claims may be defined as public if we represent them with a unique URI;
    otherwise, they are considered private to the issuer and to the services known
    to the issuer.
  prefs: []
  type: TYPE_NORMAL
- en: How does .NET 5 deal with SOA?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WCF technology has not been ported to .NET 5 and there are no plans to perform
    a complete port of it. Instead, Microsoft is investing in gRPC, Google's open
    source technology. Besides, .NET 5 has excellent support for REST services through
    ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reasons behind the decision to abandon WCF in .NET 5 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As we have already discussed, SOAP technology has been overtaken by REST technology
    in most application areas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WCF technology is strictly tied to Windows, so it would be very expensive to
    reimplement all its features from scratch in .NET 5\. Since support for full .NET
    will continue, users that need WCF can still rely on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general strategy, with .NET 5, Microsoft prefers investing in open source
    technologies that can be shared with other competitors. That is why, instead of
    investing in WCF, Microsoft provided a gRPC implementation starting from .NET
    Core 3.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next subsections will cover the support provided inside Visual Studio for
    each technology we have mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP client support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In WCF, service specifications are defined through .NET interfaces and the actual
    service code is supplied in classes that implement those interfaces. Endpoints,
    underlying protocols (HTTP and TCP/IP), and any other features are defined in
    a configuration file. In turn, the configuration file can be edited with an easy
    to use configuration tool. Therefore, the developer is responsible for providing
    just the service behavior as a standard .NET class and for configuring all the
    service features in a declarative way. This way, the service configuration is
    completely decoupled from the actual service behavior and each service can be
    reconfigured so that it can be adapted to a different environment without the
    need to modify its code.
  prefs: []
  type: TYPE_NORMAL
- en: While .NET 5 does not support SOAP technology, it does support SOAP clients.
    More specifically, it is quite easy to create a SOAP service proxy for an existing
    SOAP service in Visual Studio (please refer to *Chapter 11*, *Design Patterns
    and .NET 5 Implementation*, for a discussion of what a proxy is and of the proxy
    pattern).
  prefs: []
  type: TYPE_NORMAL
- en: In the case of services, a proxy is a class that implements the service interface
    and whose methods perform their jobs by calling the analogous methods of the remote
    service.
  prefs: []
  type: TYPE_NORMAL
- en: To create a service proxy, right-click **Dependencies** in your project in **Solution
    Explorer**, and then select **Add connected service**. Then, in the form that
    appears, select **Microsoft WCF Service Reference Provider**. There, you can specify
    the URL of the service (where the WSDL service description is contained), the
    namespace where you wish to add the proxy class, and much more. At the end of
    the wizard, Visual Studio automatically adds all the necessary NuGet packages
    and scaffolds the proxy class. This is enough to create an instance of this class
    and to call its methods so that we can interact with the remote SOAP service.
  prefs: []
  type: TYPE_NORMAL
- en: There are also third parties, such as NuGet packages that provide limited support
    for SOAP services, but at the moment, they aren't very useful, since such limited
    support does not include features that aren't available in REST services.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio 2019 supports the gRPC project template, which scaffolds both
    a gRPC server and a gRPC client. gRPC implements a remote procedure call pattern
    that offers both synchronous and asynchronous calls, reducing the traffic of messages
    between client and server.
  prefs: []
  type: TYPE_NORMAL
- en: Although at the time of writing this book, gRPC is not available for IIS and
    App Service in Azure, there are great initiatives related to it. One of them is
    gRPC-Web ([https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/)).
  prefs: []
  type: TYPE_NORMAL
- en: It is configured in a way that is similar to WCF and to .NET remoting, as we
    described at the end of *Chapter 6*, *Azure Service Fabric*. That is, services
    are defined through interfaces and their code is provided in classes that implement
    those interfaces, while clients interact with those services through proxies that
    implement the same service interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC is a good option for internal communications within a microservices cluster,
    especially if the cluster is not fully based on Service Fabric technology and
    cannot rely on .NET remoting. Since there are gRPC libraries for all the main
    languages and development frameworks, it can be used in Kubernetes-based clusters,
    as well as in Service Fabric clusters that host Docker images that have been implemented
    in other frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC is more efficient than the REST services protocol due to its more compact
    representation of data and it being easier to use, since everything to do with
    the protocol is taken care of by the development framework. However, at the time
    of writing, none of its features rely on well-established standards, so it cannot
    be used for publicly exposed endpoints – it can only be used for intra-cluster
    communication. For this reason, we will not describe gRPC in detail, but the *Further
    reading* section of this chapter contains references to both gRPC in general and
    to its .NET Core implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Using gRPC is super easy since Visual Studio's gRPC project template scaffolds
    everything so that the gRPC service and its clients are working. The developer
    just needs to define the application-specific C# service interface and a class
    that implements it.
  prefs: []
  type: TYPE_NORMAL
- en: You can check details about this implementation at [https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-5.0](https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-5.0).
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the section is dedicated to .NET Core support for REST services
    from both the server and client side.
  prefs: []
  type: TYPE_NORMAL
- en: A short introduction to ASP.NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core applications are .NET Core applications based on the *Host* concept
    we described in the *Using generic hosts* subsection of *Chapter 5*, *Applying
    a Microservice Architecture to Your Enterprise Application*. The `program.cs`
    file of each ASP.NET application creates a Host, builds it, and runs it with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`CreateDefaultBuilder` sets up a standard Host, while `ConfigureWebHostDefaults`
    configures it so that it can handle an HTTP pipeline. More specifically, it sets
    the `ContentRootPath` property of the `IWebHostEnvironment` interface for the
    current directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, it loads the configuration information from `appsettings.json` and `appsettings.[EnvironmentName].json`.
    Once loaded, the configuration information contained in the JSON object properties
    can be mapped to .NET object properties with the ASP.NET Core options framework.
    More specifically, `appsettings.json` and `appsettings.[EnvironmentName].json`
    are merged and the file's environment-specific information overrides the corresponding
    `appsettings.json` settings.
  prefs: []
  type: TYPE_NORMAL
- en: '`EnvironmentName` is taken from the `ASPNETCORE_ENVIRONMENT` environment variable.
    In turn, it is defined in the `Properties\launchSettings.json` file when the application
    runs in Visual Studio, over **Solution Explorer**. In this file, you can define
    several environments that can be selected with the dropdown next to Visual Studio''s
    run button **IIS Express**. By default, the **IIS Express** setting sets `ASPNETCORE_ENVIRONMENT`
    to `Development`. The following is a typical `launchSettings.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The value to use for `ASPNETCORE_ENVIRONMENT` when the application is published
    can be added to the published XML file after it has been created by Visual Studio.
    This value is `<EnvironmentName>Staging</EnvironmentName>`. It can also be specified
    in your Visual Studio ASP.NET Core project file (`.csproj`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Later, the application configures Host logging so that it can write to the console
    and debug output. This setting can be changed with further configuration. Then,
    it sets up/connects a web server to the ASP.NET Core pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application runs in Linux, the ASP.NET Core pipeline connects to the
    .NET Core Kestrel web server. Since Kestrel is a minimal web server, you are responsible
    for reverse proxying requests to it from a complete web server, such as Apache
    or NGINX, that adds features that Kestrel does not have. When the application
    runs in Windows, by default, `ConfigureWebHostDefaults` connects the ASP.NET Core
    pipeline directly to **Internet Information Services** (**IIS**). However, you
    can also use Kestrel in Windows and you can reverse proxy IIS requests to Kestrel
    by changing the `AspNetCoreHostingModel` setting of your Visual Studio project
    file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`UseStartup<Startup>()` lets Host services (see the *Using generic hosts* subsection
    in *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise Application*)
    and the definition of the ASP.NET Core pipeline be taken from the methods of the
    project''s `Startup.cs` class. More specifically, services are defined in its
    `ConfigureServices(IServiceCollection services)` method, while the ASP.NET Core
    pipeline is defined in the `Configure` method. The following code shows the standard
    `Configure` method scaffolded with an API REST project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Each middleware in the pipeline is defined by an `app.Use<something>` method,
    which often accepts some options. Each of them processes the requests and then
    either forwards the modified request to the next one in the pipeline or returns
    an HTTP response. When an HTTP response is returned, it is processed by all the
    previous ones in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Modules are inserted in the pipeline in the order they are defined by the `app.Use<something>`
    method calls. The preceding code adds an error page if `ASPNETCORE_ENVIRONMENT`
    is `Development`; otherwise, `UseHsts` negotiates a security protocol with the
    client. Finally, `UseEndpoints` adds the MVC controllers that create the actual
    HTTP response. A complete description of the ASP.NET Core pipeline will be given
    in the *Understanding the presentation layers of web applications* section of
    *Chapter 15*, *Presenting ASP.NET Core MVC*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will explain how the MVC framework lets you implement
    REST services.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing REST services with ASP.NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Today, we can guarantee that the use of MVC and a Web API is consolidated. In the
    MVC framework, HTTP requests are processed by classes called controllers. Each
    request is mapped to the call of a controller public method. The selected controller
    and controller methods depend on the shape of the request path, and they are defined
    by routing rules, that, for the REST API, are usually provided through attributes
    associated with both the `Controller` class and its methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`Controller` methods that process HTTP requests are called action methods.
    When the controller and action methods are selected, the MVC framework creates
    a controller instance to serve the request. All the parameters of the controller
    constructors are resolved with dependency injection with types defined in the
    `ConfigureServices` method of the `Startup.cs` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the *Using generic hosts* subsection of *Chapter 5*, *Applying
    a Microservice Architecture to Your Enterprise Application*, for a description
    of how to use dependency injection with .NET Core Hosts, and to the *Dependency
    Injection pattern* subsection of *Chapter 11*, *Design Patterns and .NET 5 Implementation*,
    for a general discussion of dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a typical REST API controller and its controller method definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `[ApiController]` attribute declares that the controller is a REST API controller.
    `[Route("api/[controller]")]` declares that the controller must be selected on
    paths that start with `api/<controller name>`. The controller name is the name
    of the controller class without the `Controller` postfix. Thus, in this case,
    we have `api/values`.
  prefs: []
  type: TYPE_NORMAL
- en: '`[HttpGet("{id}")]` declares that the method must be invoked on GET requests
    of the `api/values/<id>` type, where `id` must be a number that''s passed as an
    argument to the method invocation. This can be done with `Get(int id)`. There
    is also an `Http<verb>` attribute for each HTTP verb: `HttpPost` and `HttpPatch`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We may also have another method defined like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This method is invoked on `GET` requests of the `api/values` type, that is,
    on `GET` requests without `id` after the controller name.
  prefs: []
  type: TYPE_NORMAL
- en: Several action methods can have the same name, but only one should be compatible
    with each request path; otherwise, an exception is thrown. In other words, routing
    rules and `Http<verb>` attributes must univocally define which controller and
    which of its action methods to select for each request.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, parameters are passed to the action methods of API controllers
    according to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple types (`integers`, `floats`, and `DateTimes`) are taken from the request
    path if routing rules specify them as parameters, as in the case of the previous
    example's `[HttpGet("{id}")]` attribute. If they are not found in the routing
    rules, the MVC framework looks for query string parameters with the same name.
    Thus, for instance, if we replace `[HttpGet("{id}")]` with `[HttpGet]`, the MVC
    framework will look for something like `api/values?id=<an integer>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex types are extracted from the request body by formatters. The right formatter
    is chosen according to the value of the request's `Content-Type` header. If no
    `Content-Type` header is specified, the JSON formatter is taken. The JSON formatter
    tries to parse the request body as a JSON object and then tries to transform this
    JSON object into an instance of the .NET Core complex type. If either the JSON
    extraction or the subsequent conversion fails, an exception is thrown. By default,
    just the JSON input formatter is supported, but you can also add an XML formatter
    that can be used when `Content-Type` specifies XML content. It is enough to add
    the `Microsoft.AspNetCore.Mvc.Formatters.Xml` NuGet package and replace `services.AddControllers()`
    with `services.AddControllers().AddXmlSerializerFormatters()` in the `ConfigureServices`
    method of `Startup.cs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can customize the source that is used to fill an action method parameter
    by prefixing the parameter with an adequate attribute. The following code shows
    some examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The return type of an `Action` method must be an `IActionResult` interface
    or a type that implements that interface. In turn, `IActionResult` has just the
    following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This method is called by the MVC framework at the right time to create the actual
    response and response headers. The `ActionContext` object, when passed to the
    method, contains the whole context of the HTTP request, which includes a request
    object with all the necessary information about the original HTTP requests (headers,
    body, and cookies), as well as a response object that collects all the pieces
    of the response that is being built.
  prefs: []
  type: TYPE_NORMAL
- en: You do not have to create an implementation of `IActionResult` manually, since
    `ControllerBase` already has methods to create `IActionResult` implementations
    so that all the necessary HTTP responses are generated. Some of these methods
    are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`OK`: This returns a 200 status code, as well as an optional result object.
    It is used either as `return OK()` or as `return OK(myResult)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BadRequest`: This returns a 400 status code, as well as an optional response
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Created(string uri, object o)`: This returns a 201 status code, as well as
    a result object and the URI of the created resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Accepted`: This returns a 202 status result, as well as an optional result
    object and resource URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unauthorized`: This returns a 401 status result, as well as an optional result
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Forbid`: This returns a 403 status result, as well as an optional list of
    failed permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StatusCode(int statusCode, object o = null)`: This returns a custom status
    code, as well as an optional result object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An action method can return a result object directly with `return myObject`.
    This is equivalent to returning `OK(myObject)`.
  prefs: []
  type: TYPE_NORMAL
- en: When all the result paths return a result object of the same type, say, `MyType`,
    the action method can be declared as returning `ActionResult<MyType>`. You may
    also return responses like `NotFound`, but for sure you will get a better type
    check with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: By default, result objects are serialized in JSON in the response body. However,
    if an XML formatter has been added to the MVC framework processing pipeline, as shown
    previously, the way the result is serialized depends on the `Accept` header of
    the HTTP request. More specifically, if the client explicitly requires XML format
    with the `Accept` header, the object will be serialized in XML; otherwise, it
    will be serialized in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex objects that are passed as input to action methods can be validated
    with validation attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the controller has been decorated with the `[ApiController]` attribute and
    if validation fails, the MVC framework automatically creates a `BadRequest` response
    containing a dictionary with all the validation errors detected, without executing
    the action method. Therefore, you do not need to add further code to handle validation
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Action methods can also be declared as async methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Practical examples of controllers/action methods will be shown in the *Use case*
    section of this chapter. In the next subsection, we will explain how to handle
    authorization and authentication with JWT tokens.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core service authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using a JWT token, authorizations are based on the claims contained in
    the JWT token. All the token claims in any action method can be accessed through
    the `User.Claims` controller property. Since `User.Claims` is an `IEnumerable<Claim>`,
    it can be processed with `LINQ` to verify complex conditions on claims. If authorization
    is based on *role* claims, you can simply use the `User.IsInRole` function, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, permissions are not usually checked from within action methods and
    are automatically checked by the MVC framework, according to authorization attributes
    that decorate either the whole controller or a single action method. If an action
    method or the whole controller is decorated with `[Authorize]`, then access to
    the action method is possible only if the request has a valid authentication token,
    which means we don''t have to perform a check on the token claims. It is also
    possible to check whether the token contains a set of roles using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'More complex conditions on claims require that authorization policies be defined
    in the `ConfigureServices` method of `Startup.cs`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After that, you can decorate the action methods or controllers with `[Authorize(Policy
    = "Father")]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using JWT-based authorization, you must configure it in `Startup.cs`.
    First, you must add the middleware that processes authentication tokens in the
    ASP.NET Core processing pipeline defined in the `Configure` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you must configure the authentication services in the `ConfigureServices`
    section. Here, you define the authentication options that will be injected through
    dependency injection into the authentication middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code provides a name to the authentication scheme, that is, a
    default name. Then, it specifies JWT authentication options. Usually, we require
    that the authentication middleware verifies that the JWT token is not expired
    (`ValidateLifetime = true`), that it has the right issuer and audience (see the
    *REST services authorization and authentication* section of this chapter), and
    that its signature is valid.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example uses a symmetric signing key generated from a string.
    This means that the same key is used to sign and to verify the signature. This
    is an acceptable choice if JWT tokens are created by the same website that uses
    them, but it is not an acceptable choice if there is a unique JWT issuer that
    controls access to several Web API sites.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we should use an asymmetric key (typically, an `RsaSecurityKey`), so JWT
    verification requires just the knowledge of the public key associated with the
    actual private signing key. Identity Server 4 can be used to quickly create a
    website that works as an authentication server. It emits a JWT token with the
    usual username/password credentials or converts other authentication tokens. If
    you use an authentication server such as Identity Server 4, you do not need to
    specify the `IssuerSigningKey` option, since the authorization middleware is able
    to retrieve the required public key from the authorization server automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is enough to provide the authentication server URL, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if you decide to emit JWT in your Web API''s site, you can
    define a `Login` action method that accepts an object with a username and password,
    and that, while relying on database information, builds the JWT token with code
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, `JwtSecurityTokenHandler().WriteToken(token)` generates the actual token
    string from the token properties contained in the `JwtSecurityToken` instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will learn how to empower our Web API with an OpenAPI
    documentation point so that proxy classes for communicating with our services
    can be generated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core support for OpenAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the information that is needed to fill in an OpenAPI JSON document can
    be extracted from Web API controllers through reflection, that is, input types
    and sources (path, request body, and header) and endpoint paths (these can be
    extracted from routing rules). Returned output types and status codes, in general,
    cannot be easily computed since they can be generated dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the MVC framework provides the `ProducesResponseType` attribute
    so that we can declare a possible return type – a status code pair. It is enough
    to decorate each action method with as many `ProducesResponseType` attributes
    as there are possible types, that is, possible status code pairs, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If no object is returned along a path, we can just declare the status code,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can also specify just the status code when all the paths return the same
    type and when that type is specified in the action method return type as `ActionResult<CommonReturnType>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the action methods have been documented, to generate any actual documentation
    for the JSON endpoints, we must install the `Swashbuckle.AspNetCore` NuGet package
    and place some code in the `Startup.cs` file. More specifically, we must add some
    middleware in the `Configure` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must add some configuration options in the `ConfigureServices` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first argument of the `SwaggerDoc` method is the documentation endpoint
    name. By default, the documentation endpoint is accessible through the `<webroot>//swagger/<endpoint
    name>/swagger.json` path, but this can be changed in several ways. The rest of
    the information contained in the `Info` class is self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: We can add several `SwaggerDoc` calls to define several documentation endpoints.
    However, by default, all the documentation endpoints will contain the same documentation,
    which includes a description of all the REST services included in the project.
    This default can be changed by calling the `c.DocInclusionPredicate(Func<string,
    ApiDescription> predicate)` method from within `services.AddSwaggerGen(c => {...})`.
  prefs: []
  type: TYPE_NORMAL
- en: '`DocInclusionPredicate` must be passed a function that receives a JSON document
    name and an action method description and must return `true` if the documentation
    of the action must be included in that JSON document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare that your REST APIs need a JWT token, you must add the following
    code within `services.AddSwaggerGen(c => {...})`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can enrich the JSON documentation endpoint with information that has been
    extracted from triple-slash comments, which are usually added to generate automatic
    code documentation. The following code shows some examples of this. The following
    snippet shows how we can add a method description and parameter information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet shows how we can add an example of usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet shows how we can add parameter descriptions and return
    type descriptions for each HTTP status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable extraction from triple-slash comments, we must enable code documentation
    creation by adding the following code in our project file (`.csproj`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must enable code documentation processing from within `services.AddSwaggerGen(c
    => {...})` by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our documentation endpoints are ready, we can add some more middleware
    that is contained in the same `Swashbuckle.AspNetCore` NuGet package to generate
    a friendly user interface that we can test our REST API on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you have several documentation endpoints, you need to add a `SwaggerEndpoint`
    call for each of them. We will use this interface to test the REST API defined
    in this chapter's use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a working JSON documentation endpoint, you can automatically
    generate the C# or TypeScript code of a proxy class with one of the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The NSwagStudio Windows program, which is available at [https://github.com/RicoSuter/NSwag/wiki/NSwagStudio](https://github.com/RicoSuter/NSwag/wiki/NSwagStudio).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `NSwag.CodeGeneration.CSharp` or `NSwag.CodeGeneration.TypeScript` NuGet
    packages if you want to customize code generation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `NSwag.MSBuild` NuGet package if you want to tie code generation to Visual
    Studio build operations. The documentation for this can be found at [https://github.com/RicoSuter/NSwag/wiki/MSBuild](https://github.com/RicoSuter/NSwag/wiki/MSBuild).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next subsection, you will learn how to invoke a REST API from another
    REST API or from a .NET Core client.
  prefs: []
  type: TYPE_NORMAL
- en: .Net Core HTTP clients
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `HttpClient` class in the `System.Net.Http` namespace is a .NET standard
    2.0 built-in HTTP client class. While it could be used directly whenever we need
    to interact with a REST service, there are some problems in creating and releasing
    `HttpClient` instances repeatedly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Their creation is expensive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an `HttpClient` is released, for instance, in a `using` statement, the
    underlying connection is not closed immediately but at the first garbage collection
    session, which is a repeated creation. Release operations quickly exhaust the
    maximum number of connections the operating system can handle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, either a single `HttpClient` instance is reused, such as a singleton,
    or `HttpClient` instances are somehow pooled. Starting from the 2.1 version of
    .NET Core, the `HttpClientFactory` class was introduced to pool HTTP clients.
    More specifically, whenever a new `HttpClient` instance is required for an `HttpClientFactory`
    object, a new `HttpClient` is created. However, the underlying `HttpClientMessageHandler`
    instances, which are expensive to create, are pooled until their maximum lifetime
    expires.
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClientMessageHandler` instances must have a finite duration since they
    cache DNS resolution information that may change over time. The default lifetime
    of `HttpClientMessageHandler` is 2 minutes, but it can be redefined by the developer.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `HttpClientFactory` allows us to automatically pipeline all the HTTP operations
    with other operations. For instance, we can add a Polly retry strategy to handle
    all the failures of all our HTTP operations automatically. For an introduction
    to Polly, please refer to the *Resilient task execution* subsection of *Chapter
    5*, *Applying a Microservice Architecture to Your Enterprise Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to exploit the advantages offered by the `HttpClientFactory`
    class is to add the `Microsoft.Extensions.Http` NuGet package and then to follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a proxy class, say, `MyProxy`, to interact with the desired REST service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let `MyProxy` accept an `HttpClient` instance in its constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `HttpClient` that was injected into the constructor to implement all
    the necessary operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare your proxy in the services configuration method of your Host which,
    in the case of an ASP.NET Core application, is the `ConfigureServices` method
    of the `Startup.cs` class, while, in the case of a client application, this is
    the `ConfigureServices` method of the `HostBuilder` instance. In the simplest
    case, the declaration is something similar to `services.AddHttpClient<MyProxy>()`.
    This will automatically add `MyProxy` to the services that are available for dependency
    injection, so you can easily inject it, for instance, in your controller's constructors.
    Moreover, each time an instance of `MyProxy` is created, an `HttpClient` is returned
    by an `HttpClientFactory` and is automatically injected into its constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the constructors of the classes that need to interact with a REST service,
    we may also need an interface instead of a specific proxy implementation with
    a declaration of the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A Polly resilient strategy (see the *Resilient task execution* subsection of
    *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise Application*)
    can be applied to all the HTTP calls issued by our proxy class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can preconfigure some of the properties of all the `HttpClient`
    instances that are passed to our proxy, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This way, each client that is passed to the proxy is preconfigured so that they
    require a JSON response and must work with a specific service. Once the base address
    has been defined, each HTTP request needs to specify the relative path of the
    service method to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to perform a `POST` to a service. This requires
    an extra package, `System.Net.Http.Json`. Here, we are stating that the `HttpClient`
    that was injected into the proxy constructor has been stored in the `webClient`
    private field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use Polly, you do not need to intercept and handle communication errors
    since this job is performed by Polly. First, you need to verify the status code
    to decide what to do next. Then, you can parse the JSON string contained in the
    response body to get a .NET instance of a type that, in general, depends on the
    status code. The code to perform the parsing is based on the `System.Text.Json`
    NuGet package''s `JsonSerializer` class and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Performing a GET request is similar but, instead of calling `PostAsJsonAsync`,
    you need to call `GetAsync`, as shown here. The use of other HTTP verbs is completely
    analogous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you can check in this topic, accessing HTTP APIs is quite simple and requires
    the implementation of some .NET 5 libraries. Since the beginning of .NET Core,
    Microsoft has been working a lot on the improvement of the performance and the
    simplicity of this part of the framework. It is up to you to keep in touch with
    the documentation and facilities they keep implementing.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – exposing WWTravelClub packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement an ASP.NET REST service that lists all the
    packages that are available for a given vacation's start and end dates. For didactic
    purposes, we will not structure the application according to the best practices
    described in *Chapter 12*, *Understanding the Different Domains in Software Solutions*;
    instead, we will simply generate the results with a LINQ query that will be directly
    placed in the controller action method. A well-structured ASP.NET Core application
    will be presented in *Chapter 15*, *Presenting ASP.NET Core MVC*, which is dedicated
    to the MVC framework.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make a copy of the `WWTravelClubDB` solution folder and rename the new
    folder `WWTravelClubREST`. The WWTravelClubDB project was built step by step in
    the various sections of *Chapter 8*, *Interacting with Data in C# – Entity Framework
    Core*. Let's open the new solution and add a new ASP.NET Core API project to it
    named `WWTravelClubREST` (the same name as the new solution folder). For simplicity,
    select no authentication. Right-click on the newly created project and select
    **Set as StartUp project** to make it the default project that is launched when
    the solution is run.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to add a reference to the WWTravelClubDB project.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core projects store configuration constants in the `appsettings.json`
    file. Let''s open this file and add the database connection string for the database
    we created in the WWTravelClubDB project to it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must add the WWTravelClubDB entity framework database context to the
    `ConfigureServices` method in `Startup.cs`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The option object settings that are passed to `AddDbContext` specify the usage
    of SQL server with a connection string that is extracted from the `ConnectionStrings`
    section of the `appsettings.json` configuration file with the `Configuration.GetConnectionString("DefaultConnection")`
    method. The `b =>b.MigrationsAssembly("WWTravelClubDB")` lambda function declares
    the name of the assembly that contains the database migrations (see *Chapter 8*,
    *Interacting with Data in C# – Entity Framework Core*) which, in our case, is
    the DLL that was generated by the WWTravelClubDB project. For the preceding code
    to compile, you should add `Microsoft.EntityFrameworkCore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to enrich our REST service with OpenAPI documentation, let''s
    add a reference to the `Swashbuckle.AspNetCore` NuGet package. Now, we can add
    the following very basic configuration to the `ConfigureServices` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can add the middleware for the OpenAPI endpoint and for adding a user
    interface for our API documentation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to encode our service. Let''s delete `ValuesController`,
    which is automatically scaffolded by Visual Studio. Then, right-click on the `Controller`
    folder and select **Add** | **Controller**. Now, choose an empty API controller
    called `PackagesController`. First, let''s modify the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Route` attribute declares that the basic path for our service will be
    `api/packages`. The unique action method that we implement is `GetPackagesByDate`,
    which is invoked on `HttpGet` requests on paths of the `bydate/{start}/{stop}`
    type, where `start` and `stop` are the `DateTime` parameters that are passed as
    input to `GetPackagesByDate`. The `ProduceResponseType` attributes declare the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: When a request is successful, a 200 code is returned, and the body contains
    an `IEnumerable` of the `PackagesListDTO` (which we will soon define) type containing
    the required package information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the request is ill-formed, a 400 code is returned. We don't specify the type
    returned since bad requests are automatically handled by the MVC framework through
    the `ApiController` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of unexpected errors, a 500 code is returned with an empty body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s define the `PackagesListDTO` class in a new `DTOs` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add the following `using` clauses to our controller code so
    that we can easily refer to our DTO and to Entity Framework LINQ methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to fill the body of the `GetPackagesByDate` method with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The LINQ query is similar to the one contained in the `WWTravelClubDBTest` project
    we tested in *Chapter 8*, *Interacting with Data in C# – Entity Framework Core*.
    Once the result has been computed, it is returned with an `OK` call. The method's
    code handles internal server errors by catching exceptions and returning a 500
    status code since bad requests are automatically handled before the `Controller`
    method is called by the `ApiController` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the solution. When the browser opens, it is unable to receive any
    result from our ASP.NET Core website. Let''s modify the browser URL so that it
    is `https://localhost:<previous port>/swagger`. The user interface of the OpenAPI
    documentation will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Swagger output'
  prefs: []
  type: TYPE_NORMAL
- en: '`PackagesListDTO` is the model we defined to list the packages, while `ProblemDetails`
    is the model that is used to report errors in the event of bad requests. By clicking
    the **GET** button, we can get more details about our `GET` method and we can
    also test it, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_14_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: GET method details'
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention when it comes to inserting dates that are covered by packages
    in the database; otherwise, an empty list will be returned. The ones shown in
    the preceding screenshot should work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dates must be entered in a correct JSON format; otherwise, a 400 Bad Request
    error is returned, like the one shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you insert the correct input parameters, the Swagger UI returns the packages
    that satisfy the query in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: That is all! You have implemented your first API with OpenAPI documentation!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced SOA, its design principles, and its constraints.
    Among them, it is worth remembering interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we focused on well-established standards for business applications that
    achieve the interoperability that is needed for publicly exposed services. Therefore,
    SOAP and REST services were discussed in detail, along with the transition from
    SOAP services to REST services, which has taken place in most application areas
    in the last few years. Then, REST service principles, authentication/authorization,
    and its documentation were described in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at the tools that are available in .NET 5 that we can use
    to implement and interact with services. We looked at a variety of frameworks
    for intra-cluster communication, such as .NET remoting and gRPC, and tools for
    SOAP and REST-based public services.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we mainly focused on REST services. Their ASP.NET Core implementations
    were described in detail, along with the techniques we can use to authenticate/authorize
    them and their documentation. We also focused on how to implement efficient .NET
    Core proxies so that we can interact with REST services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use .NET 5 while building an application
    on ASP .NET Core MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can services use cookie-based sessions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it good practice to implement a service with a custom communication protocol?
    Why or why not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a `POST` request to a REST service cause a deletion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many dot-separated parts are contained in a JWT bearer token?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, where are the complex type parameters of a REST service's action
    methods taken from?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is a controller declared as a REST service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main documentation attributes of ASP.NET Core services?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are ASP.NET Core REST service routing rules declared?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should a proxy be declared so that we can take advantage of .NET Core's
    `HttpClientFactory` class features?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter mainly focused on the more commonly used REST service. If you
    are interested in SOAP services, a good place to start is the Wikipedia page regarding
    SOAP specifications: [https://en.wikipedia.org/wiki/List_of_web_service_specifications](https://en.wikipedia.org/wiki/List_of_web_service_specifications).
    On the other hand, if you are interested in the Microsoft .NET WCF technology
    for implementing SOAP services, you can refer to WCF''s official documentation
    here: [https://docs.microsoft.com/en-us/dotnet/framework/wcf/](https://docs.microsoft.com/en-us/dotnet/framework/wcf/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter mentioned the AMQP protocol as an option for intra-cluster communication
    without describing it. Detailed information on this protocol is available on AMQP''s
    official site: [https://www.amqp.org/](https://www.amqp.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'More information on gRPC is available on Google gRPC''s official site: [https://grpc.io/](https://grpc.io/).
    More information on the Visual Studio gRPC project template can be found here:
    [https://docs.microsoft.com/en-US/aspnet/core/grpc/](https://docs.microsoft.com/en-US/aspnet/core/grpc/).
    You may also want to check out gRPC-Web at [https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'More details on ASP.NET Core services are available in the official documentation:
    [https://docs.microsoft.com/en-US/aspnet/core/web-api/](https://docs.microsoft.com/en-US/aspnet/core/web-api/).
    More information on .NET Core''s HTTP client is available here: [https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests](https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests).'
  prefs: []
  type: TYPE_NORMAL
- en: 'More information on JWT token authentication is available here: [https://jwt.io/](https://jwt.io/).
    If you would like to generate JWT tokens with Identity Server 4, you may refer
    to its official documentation page: [http://docs.identityserver.io/en/latest/](http://docs.identityserver.io/en/latest/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'More information on OpenAPI is available at [https://swagger.io/docs/specification/about/](https://swagger.io/docs/specification/about/),
    while more information on Swashbuckle can be found on its GitHub repository page:
    [https://github.com/domaindrivendev/Swashbuckle](https://github.com/domaindrivendev/Swashbuckle).'
  prefs: []
  type: TYPE_NORMAL

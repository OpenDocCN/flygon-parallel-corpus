- en: DevOps and Release Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps和发布管理
- en: DevOps is an important technique that helps teams to prevent their work from
    becoming isolated. It also helps remove boring processes and unnecessary bureaucracy
    throughout the whole software development cycle. This technique is used throughout
    the whole software development process, from writing code to deploying applications
    to production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps是一种重要的技术，可以帮助团队防止他们的工作变得孤立。它还有助于消除整个软件开发周期中的乏味流程和不必要的官僚主义。这种技术在整个软件开发过程中使用，从编写代码到将应用程序部署到生产环境。
- en: 'This chapter will demonstrate how to achieve these goals by embracing automation
    in order to reduce the number of manual tasks and deploy applications using automated
    pipelines in charge of validating written code, provisioning infrastructure, and
    deploying the required artifacts into a production environment. In this chapter,
    we will review the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将演示如何通过采用自动化来实现这些目标，以减少手动任务的数量，并使用自动化管道部署应用程序，负责验证编写的代码，提供基础设施，并将所需的构件部署到生产环境。在本章中，我们将审查以下主题：
- en: Silos
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 孤立
- en: DevOps culture motivations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps文化动机
- en: DevOps adoption
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps采用
- en: Embracing automation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用自动化
- en: Infrastructure as code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: Applying DevOps practices using Spring Framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Framework应用DevOps实践
- en: Release management pipelines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布管理管道
- en: Continuous delivery
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续交付
- en: Silos
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 孤立
- en: Some years ago, the software industry used the waterfall model to manage the
    **systems development lifecycle** (**SDLC**). The waterfall model includes many
    phases, such as gathering requirements, designing a solution, writing the code,
    verifying that the code meets the user requirements, and finally, delivering the
    product. In order to work on each of these phases, different teams and roles were
    created, including analysts, developers, software architects, QA teams, operations
    people, project managers, and so on. Each one of these roles were responsible
    for producing output and delivering it to the next team.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，软件行业使用瀑布模型来管理系统开发生命周期（SDLC）。瀑布模型包括许多阶段，如收集需求、设计解决方案、编写代码、验证代码是否符合用户需求，最后交付产品。为了在每个阶段工作，创建了不同的团队和角色，包括分析师、开发人员、软件架构师、QA团队、运维人员、项目经理等。每个角色都负责产出并将其交付给下一个团队。
- en: 'The steps needed to create a software system using the waterfall model are
    as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用瀑布模型创建软件系统所需的步骤如下：
- en: Analysts gather the software requirements
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析师收集软件需求
- en: Software architects review the requirements carefully and expand the documents
    with information about the tools and technologies that will be used, modules that
    have to be written to create the system, diagrams showing how the components are
    going to be connected in order to work as a whole, and so on
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件架构师仔细审查需求，并扩展文档，提供有关将使用的工具和技术、必须编写的模块以创建系统、显示组件如何连接以作为整体运行的图表等信息
- en: Developers follow the directions issued by the architects and code the application
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员按照架构师发布的指令编写应用程序
- en: QAs have to validate if the created software works as expected
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: QAs必须验证创建的软件是否按预期工作
- en: The operations team deploys the software
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运维团队部署软件
- en: As you might notice from these steps, at each stage, a different team is producing
    a well-defined output that is delivered to the next team creating a chain. This
    process perfectly describes how teams work using a silo mentality.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些步骤中可以看出，在每个阶段，不同的团队正在产出明确定义的产出，并将其交付给下一个团队，形成一个链条。这个过程完美地描述了团队使用孤立心态的工作方式。
- en: This software production process seems good at first glance. However, this approach
    has several disadvantages. Firstly, it is impossible to produce perfect output
    in each phase, and incomplete artifacts are often produced. As a result, teams
    and departments that are concentrated on their own processes begin to pay less
    attention to what everyone else in the organization does. If a member of a team
    feels less responsible for the problems that occur within another team, a wall
    of conflict arises in this area because each team works separately with several
    barriers between them, causing issues such as communication breakdowns, thereby
    disrupting the free and fluent flow of information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个软件生产过程乍一看似乎不错。然而，这种方法有几个缺点。首先，在每个阶段都不可能产生完美的产出，通常会产生不完整的构件。因此，专注于自己流程的团队和部门开始对组织中其他人的工作付出较少关注。如果团队的成员对其他团队内发生的问题感到责任较小，那么在这个领域就会出现冲突的墙壁，因为每个团队都独立工作，彼此之间有几道障碍，导致沟通中断，从而破坏信息的自由流动。
- en: How to break silos
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何打破孤立
- en: In the previous section, we looked at how teams are organized to produce output.
    It's pretty self-evident that each team member by and large has the same skills
    as their fellow team members. As a consequence, it's impossible to ask a team
    of analysts to write code for a certain functionality or provision the infrastructure
    to deploy the application into production.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到团队如何组织以产生产出。很明显，每个团队成员基本上具有与其他团队成员相同的技能。因此，要求分析团队编写某个功能的代码或提供基础设施将应用程序部署到生产环境是不可能的。
- en: The first step to breaking silos is creating multidisciplinary teams. This means
    that a team should have members with different skills that will help the team
    approach different problems and needs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 打破孤立的第一步是创建多学科团队。这意味着团队应该有不同技能的成员，这些技能将帮助团队解决不同的问题和需求。
- en: Ideally, each team member should have all the necessary skills to approach any
    kind of need. However, this goal is almost impossible to achieve.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，每个团队成员都应具备处理任何需求的必要技能。然而，这个目标几乎是不可能实现的。
- en: Once you have a multidisciplinary team, you can easily end up having people
    working using a silo style within the same team. In order to solve this problem,
    you need to define a plan to make each member incorporate more skills as part
    of their portfolio. For example, you can make a developer work with a QA expert
    using the pair programming technique. In this way, the developer will learn how
    the QA expert thinks, and the QA will acquire development skills.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个跨学科团队，你很容易会发现在同一个团队中有人以信息孤岛的方式工作。为了解决这个问题，你需要制定一个计划，让每个成员都能够将更多的技能纳入他们的技能组合中。例如，你可以让开发人员与QA专家一起使用配对编程技术。这样，开发人员将学习QA专家的思维方式，而QA将获得开发技能。
- en: Multidisciplinary teams create an environment of collaboration across all stages
    of the SDLC.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 跨学科团队在整个软件开发生命周期的各个阶段创建了协作的环境。
- en: DevOps culture
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps文化
- en: 'There a lot of definitions for DevOps. We are going to use the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DevOps有很多定义。我们将使用以下定义：
- en: '"DevOps is a culture that encourages operation and development teams to work
    together without taking away from the specific skills and responsibilities that
    each team has."'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “DevOps是一种鼓励运营和开发团队共同合作的文化，而不会削弱每个团队具有的特定技能和责任。”
- en: This means that the software development team takes the responsibility and ownership
    of the code they produce. DevOps changes the way that people are organized and
    the processes they follow across the SDLC.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着软件开发团队要对他们所产生的代码负责和拥有权。DevOps改变了人们在软件开发生命周期中的组织方式和他们遵循的流程。
- en: 'This culture removes silos because it requires all roles to become involved
    in the SDLC and to work together, as shown in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种文化消除了信息孤岛，因为它要求所有角色都参与到软件开发生命周期中，并共同合作，如下图所示：
- en: '![](img/b318270d-09d7-4d05-a27b-9ed23091466c.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b318270d-09d7-4d05-a27b-9ed23091466c.png)'
- en: Breaking the silos in an organization
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打破组织中的信息孤岛
- en: Motivations
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动机
- en: To understand the motivation for adopting DevOps, let's look at a common real-life
    scenario that is often encountered in companies and organizations that develop
    software.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解采用DevOps的动机，让我们看一个在开发软件的公司和组织中经常遇到的常见现实场景。
- en: 'Suppose we are working at a company that hasn''t yet adopted DevOps or practices
    for **continuous integration** (**CI**) and **continuous deployment** (**CD**) in
    the software development process. Let''s imagine that this company has the following
    teams that are responsible for releasing a feature or a new piece of software:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在一家尚未采用DevOps或**持续集成**（**CI**）和**持续部署**（**CD**）实践的公司工作。让我们想象一下，这家公司有以下团队负责发布一个功能或新软件：
- en: '**Development team:** This team writes and commits code to a source version
    control system using branches that represent new features or bug fixes'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发团队：**该团队使用代表新功能或错误修复的分支将代码编写并提交到源代码版本控制系统中。'
- en: '**Operations team:** This team installs the artifacts in the different environments—for
    example, through testing and production'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运维团队：**该团队在不同的环境中安装构件，例如通过测试和生产。'
- en: '**QA team:** This team validates that the produced artifact works as expected
    from an end-user and technical perspective, and it approves or rejects the produced
    code'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QA团队：**该团队验证所产生的构件从最终用户和技术角度是否按预期工作，并批准或拒绝所产生的代码。'
- en: 'This process is repeated each time that features and bug fixes are released
    by developers. When first going through this common process, we realize that there
    are several problems, including the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每当开发人员发布功能和错误修复时，都会重复这个常见的流程。在首次经历这个常见流程时，我们意识到存在一些问题，包括以下问题：
- en: '**Different environments:** The environment in which the code is developed
    often has a different environment and configuration to the staging and production
    environments.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同的环境：**代码开发的环境通常与暂存和生产环境具有不同的环境和配置。'
- en: '**Communication:** Forming a multidisciplinary team based on DevOps practices
    is going to help us break silos in organizations. Otherwise, lack of communication
    between teams is solved via meetings, conference calls, and/or emails.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沟通：**基于DevOps实践形成跨学科团队将帮助我们打破组织中的信息孤岛。否则，团队之间缺乏沟通是通过会议、电话会议和/或电子邮件解决的。'
- en: '**Different behavior:** The number of bugs produced in a production environment
    varies in comparison to those produced in a development environment. There are
    also cases where bugs can''t be reproduced at all.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同的行为：**在生产环境中产生的错误数量与在开发环境中产生的错误数量不同。也有一些情况下错误根本无法重现。'
- en: 'As we can see, there are several problems that we need to solve here. Let''s
    look at how to approach each one of the aforementioned problems:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这里有几个问题需要解决。让我们看看如何解决上述每一个问题：
- en: '**Different environments**: With infrastructure-as-code practices, we can create
    files that are going to enable each environment to work with immutable servers,
    which is a concept that we are going to look at in a future section about infrastructure
    as code.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同的环境：**通过基础设施即代码实践，我们可以创建文件，使每个环境都能够使用不可变服务器，这是我们将在关于基础设施即代码的未来部分中讨论的概念。'
- en: '**Communication**: Forming a multidisciplinary team based on DevOps practices
    is going to help us to break up silos in the organization in question.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沟通：**基于DevOps实践形成跨学科团队将帮助我们打破组织中的信息孤岛。'
- en: '**Different behavior**: Using an infrastructure as code approach, we will be
    able to create immutable servers, guaranteeing the same behavior in different
    environments (such as development, test, and production).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同的行为：**使用基础设施即代码方法，我们将能够创建不可变服务器，保证不同环境（如开发、测试和生产）中的相同行为。'
- en: '**Time to market**: Applying **continuous delivery** (**CD**), allows us to
    deploy new features to production as quickly as possible.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上市时间：**应用**持续交付**（**CD**）使我们能够尽快将新功能部署到生产环境。'
- en: Most of these are common problems in real-life scenarios, which is why several
    organizations are adopting DevOps. This starts by breaking the silos, which has
    several advantages to development teams. For example, it allows them to deploy
    as soon as possible with fewer errors. It also allows them to react quickly to
    change, making the process more productive. As a result of this, I encourage your
    organization to break silos and become agile in order to produce higher quality
    applications fast.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: DevOps adoption
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The adoption of DevOps suits organizations' need to release applications faster,
    minimizing the bugs and risks associated with delivering software to production.
    As part of this process, we need to increase the number of automated processes
    for testing an application, and it's highly recommended that we remove manual
    processes to avoid human interaction, which can lead us to create errors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of such processes that could be automated are the environment configuration
    and deployment processes. Let''s look at the improvements to the SDLC:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a4f4bff-9659-4f32-9ef2-29dda3582059.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Waterfall method versus agile method and DevOps
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: However, there are several problems that we must handle in order to deliver
    software faster. First of all, we need to embrace a culture of automation. A culture
    of automation forces us to use many tools that we are going to introduce in the
    next section, and we need to understand that DevOps has become an essential part
    of our process because of the rise of microservices with more complex and distributed
    systems. However, don't forget that the *main goal of DevOps is collaboration,
    not just automation*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Embracing automation
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Embracing automation is one of the key factors in the adoption of DevOps. There
    are several tools that will help us with this process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to find tools that help us to automate the process in all stages throughout
    the SDLC. These phases are shown in the following diagram:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fe552c5-3b23-44a3-a440-01ddb919becd.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Pipeline in the organization
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Within an organization, a pipeline is designed to keep the software delivery
    process simple. The first step is to identify the different stages, as we did
    in the preceding diagram, and then we should choose the right tools that will
    allow us to automate each stage. Let''s review the stages and tools/software associated
    with each stage:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Code (Git, SVN, and so on).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build (Maven, Gradle, npm, and so on).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test automation. This could also include integration testing (JUnit, Postman,
    Newman, JFrog, Selenium, Cucumber, Gherkin, and so on).
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment (Ansible, Vagrant, Docker, Chef, Puppet, and so on).
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring (we are going to talk in depth about monitoring in [Chapter 12](f58465fa-861d-4800-a2a3-fe19c06e8789.xhtml),
    *Monitoring*).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration and continuous deployment (Jenkins, Hudson, and so on).
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code analysis (Sonatype, Jacoco, PMD, FindBugs, and so on).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we learned in [Chapter 10](8762b4ca-6a2e-4b00-acf3-3f8f5e2f00b9.xhtml), *Containerizing
    Your Applications*, we know how to provide environments based on containers, and
    we need to understand that the examples that we created can also be applied to
    the concept of infrastructure as code, which we are going to look at in the next
    section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure as code
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infrastructure as code refers to the process of creating files along with environment
    definitions and procedures that are going to be used to provision an environment.
    The DevOps concept started to use these scripts or files in a repository together
    with the code so that we can determine what code is going to be deployed in which
    environment. Using these practices, we can be sure that all servers and environments
    are consistent.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: A typical organization or team will deploy their application in more than one
    environment, mainly for testing purposes. When we have environments for development,
    staging, and production, the biggest problem developers face is that each environment
    is different and requires different properties.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的组织或团队将在多个环境中部署他们的应用程序，主要用于测试目的。当我们有开发、暂存和生产环境时，开发人员面临的最大问题是每个环境都不同，需要不同的属性。
- en: 'These properties may include the following configurations, among others:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性可能包括以下配置，以及其他配置：
- en: Server names
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器名称
- en: IP addresses and port numbers
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP地址和端口号
- en: Server queue connection
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器队列连接
- en: Database connection
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接
- en: Credentials
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凭据
- en: The modern era of software development suddenly brought us testability, repeatability,
    and transparency in building infrastructures. One of the key goals nowadays is
    to recreate or build complete software environments with nothing other than physical
    server resources within an on-premise or cloud environment.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发的现代时代突然给我们带来了在构建基础设施时的可测试性、可重复性和透明度。如今的一个关键目标是在本地或云环境中仅使用物理服务器资源重新创建或构建完整的软件环境。
- en: As a consequence of this, we should be able to create database instances, populate
    them with initial data from scripts or backup files, and rebuild our source code
    to create artifacts that can be deployed whenever we want.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其结果，我们应该能够创建数据库实例，用脚本或备份文件中的初始数据填充它们，并重新构建我们的源代码以创建可以随时部署的构件。
- en: 'There are many tools that we can use to apply the concept of infrastructure
    as code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以用来应用基础设施即代码的概念：
- en: For configuration synchronization, we can use Chef, Puppet, or Ansible
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于配置同步，我们可以使用Chef、Puppet或Ansible
- en: For containerized servers, we can use Docker to deploy new application versions
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于容器化服务器，我们可以使用Docker部署新的应用程序版本
- en: 'Some of the key benefits that we are going to embrace are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要拥抱的一些关键好处如下：
- en: '*Immutable servers*, which apply changes by rebuilding servers in our infrastructure
    instead of modifying the existing servers'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可变服务器*，通过在基础设施中重建服务器来应用更改，而不是修改现有服务器'
- en: '*The testing of *changes to the infrastructure, which involves reproducing
    the environment with files that we can test in different stages of our application
    and infrastructure'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对基础设施进行更改的测试*，这涉及使用文件在我们应用程序和基础设施的不同阶段进行测试来复制环境'
- en: 'The following diagram shows the main idea behind these two key benefits to
    recreate environments at each stage:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了重新创建每个阶段环境的这两个关键好处的主要思想：
- en: '![](img/75d805ec-7501-480a-bf5f-5f623c339570.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75d805ec-7501-480a-bf5f-5f623c339570.png)'
- en: Immutable infrastructure
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变基础设施
- en: 'An automated process to provision servers gives, us the following benefits:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化的服务器配置过程给我们带来以下好处：
- en: It is possible to recreate any environment or server automatically
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以自动重新创建任何环境或服务器
- en: Configuration files can store credentials or custom configurations that can
    be different for each environment
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件可以存储凭据或自定义配置，每个环境可能不同
- en: The environment will always be the same at different stages
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同阶段环境将始终相同
- en: In the following section, we are going to create some examples of infrastructure
    as code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将创建一些基础设施即代码的示例。
- en: Spring application and DevOps practices
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring应用程序和DevOps实践
- en: Spring provides out-of-the-box features aligned to DevOps principles. Let's
    look at some of these.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了与DevOps原则一致的开箱即用功能。让我们看看其中一些。
- en: First of all, we are going to create a new Spring Boot application using the
    Spring Initializr available at [https://start.spring.io](https://start.spring.io/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用[https://start.spring.io](https://start.spring.io/)上提供的Spring Initializr创建一个新的Spring
    Boot应用程序。
- en: Supporting different environments
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持不同环境
- en: A common scenario in the delivery of an application is that we code the application
    on a development environment (almost always our own computer) and then the application
    is deployed in different test and production environments. Spring configuration
    files allow us to use different configurations on each environment. We can use
    a local configuration file as part of an application and then later, we can override
    those configuration values using environment variables. This is commonly needed
    because we use different credentials and configurations for each environment of
    our deployment configuration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在交付应用程序的常见场景是我们在开发环境（几乎总是我们自己的计算机）上编写应用程序，然后将应用程序部署在不同的测试和生产环境中。Spring配置文件允许我们在每个环境中使用不同的配置。我们可以使用本地配置文件作为应用程序的一部分，然后稍后，我们可以使用环境变量覆盖这些配置值。这通常是因为我们在部署配置的每个环境中使用不同的凭据和配置。
- en: 'Before creating different Spring configuration files for each of the different
    environments that we need to deploy our application on, we are going to add an
    `index.html` static page behind the `/main/resources/static` folder with the following
    label:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们需要部署应用程序的每个不同环境创建不同的Spring配置文件之前，我们将在`/main/resources/static`文件夹后面添加一个`index.html`静态页面，标签如下：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For the next steps, we are going to show some features that Spring offers in
    favor of DevOps. We are also going to complete an exercise in which we provide
    Docker containers with layers that will be configured to support different environments,
    such as development, testing, and production environments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将展示Spring在DevOps方面提供的一些功能。我们还将完成一个练习，为Docker容器提供将配置为支持不同环境（如开发、测试和生产环境）的层。
- en: 'First, we are going to create a different profile for our application. For
    example, we can create different configuration files for development, testing,
    and production, using three files named `application-dev.properties`, `application-test.properties` and `application-production.properties` in
    the `/infra-as-code/src/main/resources` folder:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为我们的应用程序创建一个不同的配置文件。例如，我们可以使用三个文件分别命名为`application-dev.properties`、`application-test.properties`和`application-production.properties`在`/infra-as-code/src/main/resources`文件夹中创建不同的配置文件，用于开发、测试和生产：
- en: '![](img/2a1858d4-9302-4b3c-a3bc-f8cd6bc3782e.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a1858d4-9302-4b3c-a3bc-f8cd6bc3782e.png)'
- en: 'In order to see how Spring Profiles work, we are going to change the port that
    our application is using. The property that is used to configure the port is `server.port`.
    Let''s change this value for each one of the different files we have, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解Spring配置文件的工作原理，我们将更改应用程序正在使用的端口。用于配置端口的属性是`server.port`。让我们按照以下方式更改我们拥有的每个不同文件的值：
- en: '`application-dev.properties`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`application-dev.properties`：'
- en: '[PRE1]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`application-test.properties`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`application-test.properties`：'
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`application-production.properties`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`application-production.properties`：'
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Selecting profiles
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择配置文件
- en: 'Before running an application supporting different profiles, you will need
    to select the desired profile to use the configuration needed. A profile can be
    selected using the `spring.profiles.active` flag using the JVM parameter, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行支持不同配置文件的应用程序之前，您需要选择要使用的配置文件。可以使用JVM参数`spring.profiles.active`标志来选择配置文件，如下所示：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, you can check the application in the browser using the port associated
    with the profile provided. Valid values for the `spring.profiles.active` flag
    are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用与提供的配置文件相关联的端口在浏览器中检查应用程序。`spring.profiles.active`标志的有效值如下：
- en: '`dev`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`'
- en: '`production`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`production`'
- en: '`test`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`'
- en: If you don't provide any value for the flag, then the configurations from `application.properties`
    will be used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有为该标志提供任何值，则将使用`application.properties`中的配置。
- en: This is a simple example of exploring profiles in Spring. Remember that with
    profiles, we can also configure datasources, queues, beans, and anything you need.
    You can always override any of the provided configuration variables using environment
    variables.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个探索Spring中配置文件的简单示例。请记住，使用配置文件，我们还可以配置数据源、队列、bean以及您需要的任何内容。您始终可以使用环境变量覆盖任何提供的配置变量。
- en: Additionally, as we saw in [Chapter 10](8762b4ca-6a2e-4b00-acf3-3f8f5e2f00b9.xhtml),
    *Containerizing Your Applications*, we are able to dockerize a Spring Boot application,
    and with this knowledge, we can learn about immutable servers and how to test
    infrastructure changes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们在[第10章](8762b4ca-6a2e-4b00-acf3-3f8f5e2f00b9.xhtml)中看到的，*容器化您的应用程序*，我们可以将Spring
    Boot应用程序docker化，并借此了解不可变服务器以及如何测试基础架构更改。
- en: 'In this section, we are going to learn a similar way to recreate the infrastructure
    using Vagrant ([https://www.vagrantup.com/](https://www.vagrantup.com/)) version
    1.7.0 or later. This may require virtualization software (for example, VirtualBox:
    [https://www.virtualbox.org/](https://www.virtualbox.org/)).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习使用Vagrant ([https://www.vagrantup.com/](https://www.vagrantup.com/))版本1.7.0或更高版本重新创建基础架构的类似方法。这可能需要虚拟化软件（例如VirtualBox：[https://www.virtualbox.org/](https://www.virtualbox.org/)）。
- en: Another tool that can perform the same task is Ansible ([http://ansible.com/](http://ansible.com/)),
    which is not covered in this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以执行相同任务的工具是Ansible ([http://ansible.com/](http://ansible.com/))，本章不涉及该工具。
- en: Vagrant
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vagrant
- en: Vagrant is a tool that is designed to recreate virtual environments that are
    primarily intended for development. The functionality is based on VirtualBox,
    and it can use provisioning tools such as Chef, Salt, or Puppet.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant是一个旨在重新创建虚拟环境的工具，主要用于开发。其功能基于VirtualBox，并且可以使用诸如Chef、Salt或Puppet之类的配置工具。
- en: It also makes it possible to work with different providers, such as Amazon EC2,
    DigitalOcean, VMware, and others.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以与不同的提供者一起使用，例如Amazon EC2、DigitalOcean、VMware等。
- en: Vagrant uses a configuration file named `Vagrantfile`, which contains all the
    configurations needed to provision the desired environment. Once the aforementioned
    configuration file is created, the `vagrant up` command is used to install and
    configure the environment using the provided instructions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant使用一个名为`Vagrantfile`的配置文件，其中包含所有需要配置所需环境的配置。一旦创建了上述配置文件，就可以使用`vagrant
    up`命令使用提供的指令安装和配置环境。
- en: Vagrant has to be installed on the machine before we continue. To do this, follow
    the tool's documentation available at [https://www.vagrantup.com/intro/getting-started/install.html](https://www.vagrantup.com/intro/getting-started/install.html).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant必须在继续之前安装在机器上。要做到这一点，请按照工具的文档中提供的步骤进行操作[https://www.vagrantup.com/intro/getting-started/install.html](https://www.vagrantup.com/intro/getting-started/install.html)。
- en: Working with Vagrant
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vagrant工作
- en: 'Now, we are going to create a `Vagrantfile` configuration file in the root
    of our application to create a simple environment. We will provide a Linux distribution
    environment, which will be Ubuntu. The content of the `Vagrantfile` is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在应用程序的根目录中创建一个`Vagrantfile`配置文件来创建一个简单的环境。我们将提供一个Linux发行版环境，即Ubuntu。`Vagrantfile`的内容如下：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Pay attention to line 6 of `Vagrantfile`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`Vagrantfile`的第6行：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are creating our Linux environment from an already built VM box from `hashicorp/precise32`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从已构建的VM box `hashicorp/precise32` 创建我们的Linux环境。
- en: 'Before continuing with the provision of the environment using Vagrant, we are
    going to create an `ssh` file that will install JDK 8 for us. At the root of the
    project, create an `entrypoint.sh` file with the following content:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续使用Vagrant提供环境之前，我们将创建一个`ssh`文件，该文件将为我们安装JDK 8。在项目的根目录下，创建一个名为`entrypoint.sh`的文件，内容如下：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, to create the box and provision the VM, we are going to run the following
    on the Console:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了创建虚拟机并提供VM，我们将在控制台上运行以下命令：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On the first attempt, it will take some minutes to download the box and provision
    the server. Between these processes, you will be asked which network interface
    you will use to provision your server with the question *Which interface should
    the network bridge to?*. You can then choose what is more convenient for your
    machine.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次尝试时，下载盒子和配置服务器将需要一些时间。在这些过程之间，您将被问及要使用哪个网络接口来配置您的服务器，问题是*网络桥接到哪个接口？*。然后您可以选择对您的机器更方便的选项。
- en: 'At the end of the whole output of our execution, we will see our Spring application
    running on the provisioned server, as shown in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的执行的整个输出结束时，我们将在配置的服务器上看到我们的Spring应用程序正在运行，如下图所示：
- en: '![](img/d8364ec2-ae89-485e-84c2-8cbb275367e1.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8364ec2-ae89-485e-84c2-8cbb275367e1.png)'
- en: 'Now we can check our application is running on port `8090` (`http://localhost:8090/`)
    in the browser. You can check the Java process running inside Vagrant by accessing
    `ssh` with the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在浏览器中检查我们的应用是否在端口`8090`（`http://localhost:8090/`）上运行。您可以通过以下命令访问`ssh`来检查Vagrant中运行的Java进程：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will open an `ssh` session on our provision server, allowing us to see
    the process already created in the console:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的配置服务器上打开一个`ssh`会话，让我们可以在控制台中看到已经创建的进程：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the result will be our running Java process, as shown in the
    following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的输出将是我们正在运行的Java进程，如下图所示：
- en: '![](img/1622befd-b408-4574-bc6f-0e3a0b47e948.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1622befd-b408-4574-bc6f-0e3a0b47e948.png)'
- en: 'To stop the VM, we can use the `vagrant halt` command in the console:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止虚拟机，可以在控制台中使用`vagrant halt`命令：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To destroy the created VM you can enter the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要销毁创建的虚拟机，可以输入以下内容：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We just learned to express our infrastructure as code using Vagrant. We can
    create an environment or server needed for the different stages using different
    tools; we can review this in the previous chapter. In the next section, we are
    going to create an example of the process of release management.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚学会使用Vagrant将基础设施表示为代码。我们可以使用不同的工具为不同阶段创建所需的环境或服务器；我们可以在上一章中回顾这一点。在下一节中，我们将创建发布管理过程的示例。
- en: Release management
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布管理
- en: To bring your code to production, the process must be planned out.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的代码带到生产环境，必须计划好这个过程。
- en: This process of planning is called **release management**. Throughout this process,
    we need to take care of the integrity and consistency of the existing services,
    guaranteeing the operation of our systems.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规划过程称为**发布管理**。在整个过程中，我们需要关注现有服务的完整性和一致性，确保我们系统的运行。
- en: 'To understand the steps involved in the release management process, we are
    going to look at the following concepts:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解发布管理过程中涉及的步骤，我们将看一下以下概念：
- en: pipelines
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流水线
- en: Continuous integration
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Continuous delivery and continuous deployment
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续交付和持续部署
- en: pipelines
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流水线
- en: 'A pipeline is a sequence of steps that we must go through to accomplish a goal.
    We looked at this concept in [Chapter 7](c5c3f9e5-157a-4f24-bebf-fb42488ee995.xhtml), *Pipe-and-Filter
    Architectures*. The same concept in this context is used to execute a sequence
    of steps in our release management process. A pipeline will assist us during the software delivery
    process in different environments. We are going to create a simple pipeline that
    consists of five stages:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线是我们必须经历的一系列步骤来实现目标。我们在[第7章](c5c3f9e5-157a-4f24-bebf-fb42488ee995.xhtml)中看过这个概念，*管道和过滤器架构*。在这个上下文中，相同的概念用于执行我们发布管理过程中的一系列步骤。流水线将在不同环境中协助我们进行软件交付过程。我们将创建一个由五个阶段组成的简单流水线：
- en: Automatically building our projects
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动构建我们的项目
- en: Running tests (such as unit and integration)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试（如单元测试和集成测试）
- en: Deploying to staging
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到暂存环境
- en: Running an acceptance test
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行验收测试
- en: Deploying to production (this includes deploying our application in a cloud
    or on-premise server)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到生产环境（包括在云端或本地服务器上部署我们的应用程序）
- en: 'The following diagram shows how the pipeline will look:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了流水线的外观：
- en: '![](img/cd11eede-1f3b-41a6-8d9b-cd6c0aa27780.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd11eede-1f3b-41a6-8d9b-cd6c0aa27780.png)'
- en: Pipeline CI/CD
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD流水线
- en: Each stage could have one or more tasks or jobs, such as creating a database
    schema, provisioning a box with Vagrant, cloning a Docker container, and so on.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段可能有一个或多个任务或作业，例如创建数据库模式，使用Vagrant为盒子进行配置，克隆Docker容器等。
- en: 'The previous diagram is divided into two parts:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表分为两部分：
- en: Continuous integration
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Continuous deployment
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署
- en: In the next few sections, we are going to briefly look at these two concepts.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将简要介绍这两个概念。
- en: Continuous integration
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: Continuous integration (CI) refers to the practice in which developers merge
    their produced code into the main branch as often as possible. The merged code
    should work without bugs and it should also provide value for the business.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成（CI）是指开发人员尽可能经常将他们生成的代码合并到主分支中的做法。合并的代码应该没有错误，并且还应该为业务提供价值。
- en: Using CI, we can automatically validate the committed code by running a set
    of automated tests. When we are using this practice, we are working on a CI codebase,
    avoiding the problems that arose in the past when scheduling a specific date and
    time to release a build.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CI，我们可以通过运行一组自动化测试来自动验证提交的代码。当我们使用这种做法时，我们正在处理一个CI代码库，避免了过去在安排特定日期和时间发布构建时出现的问题。
- en: With the CI approach, the most important goal is to automate the test to guarantee
    that the application is not broken any time the new commits are pushed into the
    main source code branch.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 采用CI方法，最重要的目标是自动化测试，以确保每次将新提交推送到主源代码分支时应用程序都不会出现故障。
- en: Continuous delivery and continuous deployment
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付和持续部署
- en: CD is a process based on CI. As part of the CD process, we need other steps
    that are required to deploy the application to a production environment including
    tasks such as configuring and provisioning servers (infrastructure as code), acceptance
    testing, and preparing the build for a production environment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: CD是基于CI的一个过程。作为CD过程的一部分，我们需要其他步骤，这些步骤是将应用程序部署到生产环境所需的，包括配置和提供服务器（基础设施即代码）、验收测试以及为生产环境准备构建。
- en: A continuous deployment process differs from a continuous delivery process when
    deploying in a production environment without *human* intervention.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中进行部署时，持续部署过程与持续交付过程不同，不需要*人类*干预。
- en: We are now going to create an example based on our simple pipeline. To focus
    on the processes of CI and CD, we are going to use the project that we created
    in the last chapter's *Docker Compose* section that showed you how to containerize
    your application. This project includes a complete environment that is ready to
    use, and which already includes an automated test.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个基于我们简单流水线的示例。为了专注于CI和CD的流程，我们将使用上一章节的*Docker Compose*部分中创建的项目，该部分向您展示了如何将应用程序容器化。该项目包括一个完整的环境，已经准备好使用，并且已经包含了自动化测试。
- en: Automating pipelines
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化流水线
- en: 'As previously explained, we are going to need several tools to automate our
    pipeline for our example. For this, we are going to use the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将需要几个工具来自动化我们示例的流水线。为此，我们将使用以下工具：
- en: 'A GitHub repository for our code: We can push our code to a repository and
    create a merge that automatically launches the build and test'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码的GitHub存储库：我们可以将我们的代码推送到存储库并创建一个自动启动构建和测试的合并
- en: Gradle or Maven to build our project
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gradle或Maven构建我们的项目
- en: Junit, Postman, and Newman to test the automation
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Junit、Postman和Newman进行自动化测试
- en: Docker to deploy into containersJenkins to act as our automation server for
    CI and CD
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker部署到容器中的Jenkins作为我们的CI和CD的自动化服务器
- en: First, we are going to push our code to a repository. To do this, we are going
    to use GitHub. Create an account if you haven't already.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将把我们的代码推送到存储库。为此，我们将使用GitHub。如果还没有，请创建一个帐户。
- en: 'Open a terminal and go to the root folder of our application. For our convenience,
    we are going to push the repository from our machine, so we are going to initialize
    our project as a repository. In the command line, execute the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并转到我们应用程序的根文件夹。为了方便起见，我们将从我们的机器上推送存储库，因此我们将初始化我们的项目作为存储库。在命令行中执行以下操作：
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of the command will look as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出将如下所示：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we are going to add all our files to a new local repository, as shown
    in the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将把所有文件添加到一个新的本地存储库中，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we are going to commit our code locally, as shown in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在本地提交我们的代码，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of our local commit will print the following initial lines:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本地提交的输出将打印以下初始行：
- en: '[PRE17]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To push our code, we then need to create a repository in our GitHub account.
    We can create a new repository by going to the Repositories section, clicking
    on the green Create Repository button, and filling in the name and description of
    the repository, as shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要推送我们的代码，我们需要在GitHub帐户中创建一个存储库。我们可以通过转到存储库部分，点击绿色的创建存储库按钮，并填写存储库的名称和描述来创建一个新的存储库，如下面的屏幕截图所示：
- en: '![](img/26f922b3-48dd-446f-b3b3-94c9c9c828fd.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26f922b3-48dd-446f-b3b3-94c9c9c828fd.png)'
- en: Creating a GitHub repository
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个GitHub存储库
- en: 'We now have the URL of our repository—for example, `https://github.com/$YOUR_GITHUB_USER/bank-app`. The
    result of the repository that we created will look like the following screenshot:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们存储库的URL，例如`https://github.com/$YOUR_GITHUB_USER/bank-app`。我们创建的存储库的结果将如下屏幕截图所示：
- en: '![](img/b3ab7ef0-b637-4810-9d47-122653be156d.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3ab7ef0-b637-4810-9d47-122653be156d.png)'
- en: GitHub repository
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库
- en: 'As per the instructions given in GitHub, we now need to push our code to the
    repository using the command line:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 根据GitHub给出的说明，我们现在需要使用命令行将我们的代码推送到存储库：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we will push our changes from the local repository to our GitHub repository,
    as shown in the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从本地存储库推送我们的更改到我们的GitHub存储库，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now we can review our code on our GitHub account repository and, as recommended,
    add a `README` file to explain the purpose of the application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的GitHub帐户存储库上查看我们的代码，并根据建议添加一个`README`文件来解释应用程序的目的。
- en: In the next section, we are going to look at the concept of a CI server before
    continuing with our exercise.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将在继续练习之前先看一下CI服务器的概念。
- en: Jenkins
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins
- en: 'Jenkins is a continuous integration server that is in charge of automating
    our pipeline. Before integrating with our Git repository to build our application
    automatically, let''s review the key concepts behind the CI server:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是一个负责自动化我们流水线的持续集成服务器。在与我们的Git存储库集成以自动构建我们的应用程序之前，让我们先回顾一下CI服务器背后的关键概念：
- en: '**Pipeline**: A pipeline consist of a set of sequential steps that will occur
    in the order in which they are arranged. The pipeline is also where we can parallelize
    tasks.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流水线**: 流水线由一系列按顺序发生的步骤组成。流水线也是我们可以并行执行任务的地方。'
- en: '**Job**: This is a small unit of work, such as *run test* or *pull our code*.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业**: 这是一个小的工作单元，例如*运行测试*或*拉取我们的代码*。'
- en: '**Queue**: This represents all queuing jobs that the CI server will run when
    there is the capacity to do so.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列**: 这代表了CI服务器在有能力运行时将运行的所有排队作业。'
- en: '**Plugin**: These are the features that we can add to our CI server. For example,
    we can use one plugin to connect to our Git repository.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件**: 这些是我们可以添加到我们的CI服务器的功能。例如，我们可以使用一个插件连接到我们的Git存储库。'
- en: '**Master/slave**: The master is the host that can delegate work to a slave
    client machine to scale our CI.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主/从**: 主机可以将工作委派给从机器来扩展我们的CI。'
- en: Jenkins has different methods of distribution. We can see more details about
    this project at [https://jenkins.io/download/](https://jenkins.io/download/).
    For our example, we are going to use a Docker image that is ready to use.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins有不同的分发方法。我们可以在[https://jenkins.io/download/](https://jenkins.io/download/)上查看更多关于这个项目的细节。在我们的示例中，我们将使用一个准备好的Docker镜像。
- en: 'As we already have Docker installed, we can pull the Jenkins image in the command
    line by running the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经安装了Docker，我们可以通过运行以下命令在命令行中拉取Jenkins镜像：
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can see our image by running the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过运行以下命令来查看我们的镜像：
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we are going to run our Jenkins master from our container by running the
    following in the command line:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过在命令行中运行以下命令来从容器中运行我们的Jenkins主服务器：
- en: '[PRE22]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Pay attention to the output of the console with the generated administrator
    password, as shown in the following screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意控制台输出的生成的管理员密码，如下截图所示：
- en: '![](img/5bc7e400-605d-4b1f-b498-ac8854682b17.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bc7e400-605d-4b1f-b498-ac8854682b17.png)'
- en: Generating the Jenkins password
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 生成Jenkins密码
- en: We can now see our Jenkins server is running using `http://localhost:8080/`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到我们的Jenkins服务器正在使用`http://localhost:8080/`运行。
- en: 'The first step is to paste the administrator password that we have just seen
    on the console, as shown in the following screenshot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是粘贴我们刚在控制台上看到的管理员密码，如下截图所示：
- en: '![](img/c0dec531-f445-4ed3-bd75-ab2a4db0e90a.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0dec531-f445-4ed3-bd75-ab2a4db0e90a.png)'
- en: Unlocking Jenkins
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁Jenkins
- en: We are now going to install the suggested plugins, which is going to take a
    while. Then we will continue the process by creating an admin user and URL.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将安装建议的插件，这将需要一些时间。然后我们将继续创建一个管理员用户和URL的过程。
- en: 'We are going to enable build triggering, so we are going to configure our Jenkins
    instance for receiving push notifications from GitHub. To do this, go through
    the following steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启用构建触发，因此我们将配置我们的Jenkins实例以接收来自GitHub的推送通知。为此，请按照以下步骤进行：
- en: Go to the Jenkins home page (`http://localhost:8080`) and then click on the
    **New item** icon in the left menu.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Jenkins主页（`http://localhost:8080`），然后点击左侧菜单中的**New item**图标。
- en: 'Enter the name of the project and select Freestyle project. After doing this,
    click on the OK button, as shown in the following screenshot:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目名称并选择自由风格项目。完成后，点击“OK”按钮，如下截图所示：
- en: '![](img/6e7d5c71-1915-4f60-80cd-a6b7fc4b9a15.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e7d5c71-1915-4f60-80cd-a6b7fc4b9a15.png)'
- en: 'Jenkins will show a page where the job steps should be configured. First, enter
    a description for the project and GitHub URL repository created as shown in the
    following screenshot:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins将显示一个页面，应该在该页面上配置作业步骤。首先，输入项目的描述和GitHub URL存储库，如下截图所示：
- en: '![](img/e925304f-0205-4859-b0a5-4255442a3256.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e925304f-0205-4859-b0a5-4255442a3256.png)'
- en: '4. Enter the credentials of your user account for GitHub, as is shown in the
    following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 输入您的GitHub用户帐户的凭据，如下截图所示：
- en: '![](img/d984098f-7203-45ca-8097-944a3e164645.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d984098f-7203-45ca-8097-944a3e164645.png)'
- en: '5\. Finally, at the end of the page select Gradle as the build tool for the
    project:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 最后，在页面底部选择Gradle作为项目的构建工具：
- en: '![](img/71fd61b3-d798-47d6-9762-730393860b23.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71fd61b3-d798-47d6-9762-730393860b23.png)'
- en: The job created can be configured to be triggered every time we commit code
    to GitHub. The job will download the code, run tests, and generate the deployable
    artifact (JAR file) using Gradle. You can add additional steps in this job to build,
    tag, and push Docker images in Docker Hub and later deploy it automatically on
    an on-premise or cloud-based server.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的作业可以配置为在每次向GitHub提交代码时触发。该作业将下载代码，运行测试，并使用Gradle生成可部署的工件（JAR文件）。您可以在此作业中添加额外的步骤来在Docker
    Hub中构建、标记和推送Docker镜像，然后自动部署到本地或基于云的服务器。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have familiarized ourselves with the meaning of a DevOps
    culture and how it affects the processes of an organization. We also looked at
    how to automate the instrumentation process of servers, using techniques such
    as infrastructure as code to embrace automation. Furthermore, we learned how to
    build pipelines that are capable of getting the latest implemented features from
    a repository, validating the code, running tests on different levels, and bringing
    the application to production. In the next chapter, we will look at the concerns
    surrounding the monitoring of applications, looking at why it is so important
    to care for them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们熟悉了DevOps文化的含义以及它如何影响组织的流程。我们还学习了如何自动化服务器的仪器化过程，使用基础设施即代码等技术来实现自动化。此外，我们学习了如何构建能够从存储库获取最新实施功能、验证代码、在不同层面运行测试并将应用程序推向生产的流水线。在下一章中，我们将探讨围绕应用程序监控的关注点，看看为什么关心它们如此重要。

- en: Putting It All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"If you always do what you always did, then you will always get what you always
    got."'
  prefs: []
  type: TYPE_NORMAL
- en: – Albert Einstein
  prefs: []
  type: TYPE_NORMAL
- en: We have gone through a lot of theory followed by even more practice. The entire
    journey was like a speeding train and we have hardly had an opportunity to repeat
    what we learned. There was no time for rest.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that the time for the reflection is now. We'll summarize everything
    we learned and go through TDD best practices. Some of those have already been
    mentioned, while others will be new.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: TDD in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common conventions and good practices, such as in naming tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Red-Green-Refactor** is the pillar of TDD that wraps it into a short and
    repeatable cycle. By short, we mean very short. The time dedicated to each phase
    is often counted in minutes, if not seconds. Write a test, see it fail, write
    just enough implementation code to make the last test pass, run all tests, and
    pass into the green phase. Once the minimum code is written so that we have safety
    in the form of passing tests, it is time to refactor the code until it is as good
    as we''re hoping it to be. While in this phase, tests should always pass. Neither
    new functionalities nor new tests can be introduced while refactoring is in progress.
    Doing all this in such a short period of time is often scary, or might sound impossible.
    We hope that, through the exercises we did together, your skills have improved,
    as well as your confidence and speed.'
  prefs: []
  type: TYPE_NORMAL
- en: While there is the word **test** in **TDD**, it is not the main benefit nor
    objective. TDD is, first and foremost, a concept of a better way to design our
    code. On top of that, we end up with tests that should be used to continuously
    check that the application continues working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of speed was mentioned often previously. While part of this is
    accomplished by us being ever more proficient in TDD, another contributor is **test
    doubles** (mocking, stubbing, spying, and so on). With these, we can remove the
    need for external dependencies such as databases, file systems, third-party services,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What are the other benefits of TDD? Documentation is one of them. Since code
    itself is the only accurate and always up-to-date representation of the applications
    we're working on, specifications written using TDD (being code as well) is the
    first place we should turn to when we need to better understand what a piece of
    code does.
  prefs: []
  type: TYPE_NORMAL
- en: How about design? You noticed how TDD produces code that is designed better.
    Rather than defining design in advance, with TDD it tends to emerge as we progress
    from one specification to another. At the same time, code that is easy to test
    is well-designed code. Tests force us to apply some coding best practices.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that TDD does not need to be practiced only on small units (methods).
    It can also be used at a much higher-level, where the focus is on a feature or
    a behavior that can span multiple methods, classes, or even applications and systems.
    One of the forms of TDD practiced at such a high-level is **behavior-driven development**
    (**BDD**). Unlike TDD, which is based on the unit tests that are done by developers
    for developers, BDD can be used by almost everyone in your organization. Since
    it tackles behaviors and it's written in natural (ubiquitous) language, testers,
    managers, business representatives, and others can participate in its creation
    and use it as a reference later on.
  prefs: []
  type: TYPE_NORMAL
- en: We defined legacy code as code without tests. We faced some of the challenges
    legacy code puts in front of us and learned some of the techniques that can be
    used to make it testable.
  prefs: []
  type: TYPE_NORMAL
- en: With all this in mind, let's go through TDD best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coding best practices are a set of informal rules that the software development
    community has developed over time, which can help to improve the quality of software.
    While each application needs a level of creativity and originality (after all,
    we're trying to build something new or better), coding practices help us avoid
    some of the problems others faced before us. If you're just starting with TDD,
    it is a good idea to apply some (if not all) of the best practices generated by
    others.
  prefs: []
  type: TYPE_NORMAL
- en: 'For easier classification of TDD best practices, we divided them into four
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you'll see, not all of them are exclusive to TDD. Since a big part of TDD
    consists of writing tests, many of the best practices presented in the following
    sections apply to testing in general, while others are related to general coding
    best practices. No matter the origin, all of them are useful when practicing TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Take the advice with a certain dose of skepticism. Being a great programmer
    is not only about knowing how to code, but also about being able to decide which
    practice, framework, or style best suits the project and the team. Being agile
    is not about following someone else's rules, but about knowing how to adapt to
    circumstances and choose the best tools and practices that suit the team and the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Naming conventions help to organize tests better, so that it is easier for developers
    to find what they're looking for. Another benefit is that many tools expect that
    those conventions are followed. There are many naming conventions in use, and
    those presented here are just a drop in the ocean. The logic is that any naming
    convention is better than none. Most important is that everyone on the team knows
    what conventions are being used and are comfortable with them. Choosing more popular
    conventions has the advantage that newcomers to the team can get up to speed fast,
    since they can leverage existing knowledge to find their way around.
  prefs: []
  type: TYPE_NORMAL
- en: Separate the implementation from the test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: It avoids accidentally packaging tests together with production binaries;
    many build tools expect tests to be in a certain source directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Common practice is to have at least two source directories. Implementation code
    should be located in `src/main/java` and test code in `src/test/java`. In bigger
    projects, the number of source directories can increase, but the separation between
    implementation and tests should remain as is.
  prefs: []
  type: TYPE_NORMAL
- en: Build tools such as Gradle and Maven expect source directory separation as well
    as naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the `build.gradle` files that we used throughout
    this book did not explicitly specify what to test, nor what classes to use to
    create a `.jar` file. Gradle assumes that tests are in `src/test/java` and that
    the implementation code that should be packaged into a JAR file is in `src/main/java`.
  prefs: []
  type: TYPE_NORMAL
- en: Place test classes in the same package as implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: Knowing that tests are in the same package as the code helps you
    to find code faster.'
  prefs: []
  type: TYPE_NORMAL
- en: As stated in the previous practice, even though packages are the same, classes
    are in separate source directories.
  prefs: []
  type: TYPE_NORMAL
- en: All exercises throughout this book followed this convention.
  prefs: []
  type: TYPE_NORMAL
- en: Name test classes in a similar fashion to the classes they test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: Knowing that tests have a similar name to the classes they are testing
    helps you find the classes faster.'
  prefs: []
  type: TYPE_NORMAL
- en: One commonly used practice is to name tests the same as the implementation classes,
    with the suffix `Test`. If, for example, the implementation class is `TickTackToe`,
    the test class should be `TickTackToeTest`.
  prefs: []
  type: TYPE_NORMAL
- en: However, in all cases, with the exception of those we used throughout the refactoring
    exercises, we prefer the suffix `Spec`. It helps to make a clear distinction that
    test methods are primarily created as a way to specify what will be developed.
    Testing is a great sub-product of those specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Use descriptive names for test methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: It helps in understanding the objective of tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Using method names that describe tests is beneficial when trying to figure out
    why some tests failed or when the coverage should be increased with more tests.
    It should be clear what conditions are set before the test, what actions are performed,
    and what the expected outcome is.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different ways to name test methods, and our preferred method
    is to name them using the `Given`/`When`/`Then` syntax used in the BDD scenarios.
    `Given` describes (pre)conditions, `When` describes actions, and `Then` describes
    the expected outcome. If a test does not have preconditions (usually set using
    `@Before` and `@BeforeClass` annotations), `Given` can be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at one of the specifications we created for our Tic-Tac-Toe
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Just by reading the name of the method, we can understand what it is about.
    When we play and the whole horizontal or vertical and diagonal line is populated,
    then we have a winner.
  prefs: []
  type: TYPE_NORMAL
- en: Do not rely only on comments to provide information about the test objective.
    Comments do not appear when tests are executed from your favorite IDE, nor do
    they appear in reports generated by CI or build tools.
  prefs: []
  type: TYPE_NORMAL
- en: Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD processes are the core set of practices. Successful implementation of TDD
    depends on practices described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Write a test before writing the implementation code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: It ensures that testable code is written; it ensures that every line
    of code gets tests written for it.'
  prefs: []
  type: TYPE_NORMAL
- en: By writing or modifying the test first, the developer is focused on requirements
    before starting to work on the implementation code. This is the main difference
    compared to writing tests after the implementation is done. The additional benefit
    is that with the tests written first, we are avoiding the danger that the tests
    work as **quality checking** (**QC**) instead of **quality assurance** (**QA**).
    We're trying to ensure that quality is built in, as opposed to checking later
    whether we met quality objectives.
  prefs: []
  type: TYPE_NORMAL
- en: Only write new code when the test is failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: It confirms that the test does not work without the implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: If tests are passing without the need to write or modify the implementation
    code, then either the functionality is already implemented or the test is defective.
    If new functionality is indeed missing, then the test always passes and is therefore
    useless. Tests should fail for the expected reason. Even though there are no guarantees
    that the test is verifying the right thing, with fail first and for the expected
    reason, confidence that verification is correct should be high.
  prefs: []
  type: TYPE_NORMAL
- en: Rerun all tests every time the implementation code changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: It ensures that there are no unexpected side effects caused by code
    changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time any part of the implementation code changes, all tests should be
    run. Ideally, tests are fast to execute and can be run by the developer locally.
    Once code is submitted to version control, all tests should be run again to ensure
    that there was no problem due to code merges. This is especially important when
    more than one developer is working on the code. **Continuous integration** (**CI**)
    tools should be used to pull the code from the repository, compile it, and run
    tests, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins ([https://jenkins.io/](https://jenkins.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hudson ([http://hudson-ci.org/](http://hudson-ci.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Travis ([https://travis-ci.org/](https://travis-ci.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bamboo ([https://www.atlassian.com/software/bamboo](https://www.atlassian.com/software/bamboo))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All tests should pass before a new test is written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: The focus is maintained on a small unit of work; implementation code
    is (almost) always in working condition.'
  prefs: []
  type: TYPE_NORMAL
- en: It is sometimes tempting to write multiple tests before the actual implementation.
    In other cases, developers ignore problems detected by existing tests and move
    towards new features. This should be avoided whenever possible. In most cases,
    breaking this rule will only introduce technical debt that will need to be paid
    with interest. One of the goals of TDD is that the implementation code is (almost)
    always working as expected. Some projects, due to pressures to reach the delivery
    date or maintain the budget, break this rule and dedicate time to new features,
    leaving the task of fixing the code associated with failed tests for later. These
    projects usually end up postponing the inevitable.
  prefs: []
  type: TYPE_NORMAL
- en: Refactor only after all tests are passing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: This type of refactoring is safe.'
  prefs: []
  type: TYPE_NORMAL
- en: If all implementation code that can be affected has tests and they are all passing,
    it is relatively safe to refactor. In most cases, there is no need for new tests.
    Small modifications to existing tests should be enough. The expected outcome of
    refactoring is to have all tests passing both before and after the code is modified.
  prefs: []
  type: TYPE_NORMAL
- en: Development practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practices listed in this section are focused on the best way to write tests.
    Write the simplest code to pass the test as it ensures cleaner and clearer design
    and avoids unnecessary features.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that the simpler the implementation, the better and easier it is
    to maintain the product. The idea adheres to the **keep it simple**, **stupid**
    (**KISS**) principle. This states that most systems work best if they are kept
    simple rather than made complex; therefore, simplicity should be a key goal in
    design, and unnecessary complexity should be avoided. Write assertions first,
    act later as it clarifies the purpose of the requirements and tests early.
  prefs: []
  type: TYPE_NORMAL
- en: Once the assertion is written, the purpose of the test is clear and the developer
    can concentrate on the code that will accomplish that assertion and, later on,
    on the actual implementation. Minimize assertions in each test as it avoids assertion
    roulette; it allows the execution of more asserts.
  prefs: []
  type: TYPE_NORMAL
- en: If multiple assertions are used within one test method, it might be hard to
    tell which of them caused a test failure. This is especially common when tests
    are executed as part of the CI process. If the problem cannot be reproduced on
    a developer's machine (as may be the case if the problem is caused by environmental
    issues), fixing the problem may be difficult and time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: When one assert fails, execution of that test method stops. If there are other
    asserts in that method, they will not be run and information that can be used
    in debugging is lost.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, having multiple asserts creates confusion about the objective
    of the test.
  prefs: []
  type: TYPE_NORMAL
- en: This practice does not mean that there should always be only one `assert` per
    test method. If there are other asserts that test the same logical condition or
    unit of functionality, they can be used within the same method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code contains two specifications that clearly define what the
    objective of the tests is. By reading the method names and looking at the `assert`,
    there should be clarity on what is being tested. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This specification has more than one `assert`, but they are testing the same
    logical unit of functionality. The first `assert` is confirming that the exception
    exists, and the second that its message is correct. When multiple asserts are
    used in one test method, they should all contain messages that explain the failure.
    This way, debugging the failed `assert` is easier. In the case of one `assert`
    per test method, messages are welcome but not necessary, since it should be clear
    from the method name what the objective of the test is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This test has many asserts. It is unclear what the functionality is, and if
    one of them fails, it is not known whether the rest would work or not. It might
    be hard to understand the failure when this test is executed through some CI tools.
  prefs: []
  type: TYPE_NORMAL
- en: Do not introduce dependencies between tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: The tests work in any order independently, whether all or only a
    subset is run.'
  prefs: []
  type: TYPE_NORMAL
- en: Each test should be independent of the others. Developers should be able to
    execute any individual test, a set of tests, or all of them. Often, due to the
    test runner's design, there is no guarantee that tests will be executed in any
    particular order. If there are dependencies between tests, they might easily be
    broken with the introduction of new ones.
  prefs: []
  type: TYPE_NORMAL
- en: Tests should run fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: These tests are used often.'
  prefs: []
  type: TYPE_NORMAL
- en: If it takes a lot of time to run tests, developers will stop using them or run
    only a small subset related to the changes they are making. The benefit of fast
    tests, besides fostering their usage, is quick feedback. The sooner the problem
    is detected, the easier it is to fix it. Knowledge about the code that produced
    the problem is still fresh. If the developer already started working on the next
    feature while waiting for the completion of the execution of the tests, they might
    decide to postpone fixing the problem until that new feature is developed. On
    the other hand, if they drops their current work to fix the bug, time is lost
    in context switching.
  prefs: []
  type: TYPE_NORMAL
- en: Tests should be so quick that developers can run all of them after each change
    without getting bored or frustrated.
  prefs: []
  type: TYPE_NORMAL
- en: Use test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: This reduces code dependency and test execution will be faster.'
  prefs: []
  type: TYPE_NORMAL
- en: Mocks are prerequisites for the fast execution of tests and the ability to concentrate
    on a single unit of functionality. By mocking dependencies external to the method
    that is being tested, the developer is able to focus on the task at hand without
    spending time in setting them up. In the case of bigger teams, those dependencies
    might not even be developed. Also, the execution of tests without mocks tends
    to be slow. Good candidates for mocks are databases, other products, services,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Use setup and teardown methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: This allows setup and teardown code to be executed before and after
    the class or each method.'
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, some code needs to be executed before the test class or before
    each method in a class. For this purpose, JUnit has `@BeforeClass` and `@Before`
    annotations that should be used as the setup phase. `@BeforeClass` executes the
    associated method before the class is loaded (before the first test method is
    run).
  prefs: []
  type: TYPE_NORMAL
- en: '`@Before` executes the associated method before each test is run. Both should
    be used when there are certain preconditions required by tests. The most common
    example is setting up test data in the (hopefully in-memory) database.'
  prefs: []
  type: TYPE_NORMAL
- en: At the opposite end are `@After` and `@AfterClass` annotations, which should
    be used as the teardown phase. Their main purpose is to destroy data or a state
    created during the setup phase or by the tests themselves. As stated in one of
    the previous practices, each test should be independent from the others. Moreover,
    no test should be affected by the others. The teardown phase helps to maintain
    the system as if no test was previously executed.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use base classes in tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: It provides test clarity.'
  prefs: []
  type: TYPE_NORMAL
- en: Developers often approach test code in the same way as implementation. One of
    the common mistakes is to create base classes that are extended by tests. This
    practice avoids code duplication at the expense of test clarity. When possible,
    base classes used for testing should be avoided or limited. Having to navigate
    from the test class to its parent, to the parent of the parent, and so on in order
    to understand the logic behind tests often introduces unnecessary confusion. Clarity
    in tests should be more important than avoiding code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD, coding, and testing in general, are heavily dependent on other tools and
    processes. Some of the most important ones are as follows. Each of them is too
    big a topic to be explored in this book, so they will be described only briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage and CI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: It gives assurance that everything is tested.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code coverage practices and tools are very valuable in determining that all
    code, branches, and complexity is tested. Some of these tools are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: JaCoCo ([http://www.eclemma.org/jacoco/](http://www.eclemma.org/jacoco/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clover ([https://www.atlassian.com/software/clover](https://www.atlassian.com/software/clover))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cobertura ([http://cobertura.github.io/cobertura/](http://cobertura.github.io/cobertura/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CI tools are a must for all except the most trivial projects. Some of the most
    used tools are:'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins ([https://jenkins.io/](https://jenkins.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hudson ([http://hudson-ci.org/](http://hudson-ci.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Travis ([https://travis-ci.org/](https://travis-ci.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bamboo ([https://www.atlassian.com/software/bamboo](https://www.atlassian.com/software/bamboo)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use TDD together with BDD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: Both developer unit tests and functional customer facing tests are
    covered.'
  prefs: []
  type: TYPE_NORMAL
- en: While TDD with unit tests is a great practice, in many cases it does not provide
    all the testing that projects need. TDD is fast to develop, helps the design process,
    and gives confidence through fast feedback. On the other hand, BDD is more suitable
    for integration and functional testing, provides a better process for requirement
    gathering through narratives, and is a better way of communicating with clients
    through scenarios. Both should be used, and together they provide a full process
    that involves all stakeholders and team members. TDD (based on unit tests) and
    BDD should be driving the development process. Our recommendation is to use TDD
    for high code coverage and fast feedback, and BDD as automated acceptance tests.
    While TDD is mostly oriented towards white-box, BDD often aims at black-box testing.
    Both TDD and BDD are trying to focus on QA instead of QC.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first went through a brief overview of TDD. We learned about
    the four best practices that can help to improve the quality of software.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to the final chapter, we will be introduced to the concepts of CI and
    continuous delivery, and the importance of TDD all through the pipeline process
    will be highlighted with an example.
  prefs: []
  type: TYPE_NORMAL

- en: Component Composition with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The components you write with TypeScript are at their best when kept short
    and simple. However, a short and simple component will hardly make a full-blown
    app. How do you compose components performing specific tasks and combine them
    to make a usable application? This is what this chapter is all about. We will
    discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Component hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between components at different levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also see some hands-on examples on how components are composed and how
    these composed components communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Component composability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composability is the most outstanding feature and the selling point of components.
    As a matter of fact, this is what makes components what they are. Not just on
    the web but whenever an entity is referred to as a component, then it has a tendency
    to be composed with other components.
  prefs: []
  type: TYPE_NORMAL
- en: While some components can function on their own, most depend implicitly or explicitly on
    other stand-alone components to achieve a given task. TypeScript and templates
    greatly simplify composition in Angular, enabling it to put the pieces of our
    app together in a seamless and an easy-to-maintain way.
  prefs: []
  type: TYPE_NORMAL
- en: Composition happens hierarchically; hence, most component relationships are
    either parent-to-child or child-to-parent. It is also important to keep in mind
    that if such a parent-child relationship exists, then some components might be
    siblings to others, depending on the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A composed component has a parental relationship with another component, either
    as the parent or as a child. There is a tendency for a nested chain; hence, nothing
    stops a child component from having a grandparent or a parent component from having
    a grandchild component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/453d62b1-475d-435f-8b61-67100bb55440.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the entry `App` component has two child components: `CommentList` and
    `CommentForm`. `CommentList` also has a child, `CommentItem`. It''s okay to say
    that `CommentItem` is the grandchild of `App`. It''s also okay to say that `CommentList`
    and `CommentForm` are siblings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The thick arrows show how the data flows from the parent components down to
    the child components, while the dotted arrows show how the data is pushed as events
    from the child components to the parent components. This illustration of data
    flowing down and moving up leads us to our next topic for discussion: component
    communication.'
  prefs: []
  type: TYPE_NORMAL
- en: Component communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on the diagram that we saw previously, let's see some examples in action.
    The recommended place to start is the data flow from parent to child.
  prefs: []
  type: TYPE_NORMAL
- en: Parent-child flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jump right in and create a new Angular project using the Angular CLI. With
    that done, update `AppComponent` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The key difference is that I have added an array of comments. These comments
    are what we intend to pass down to the child component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `CommentListComponent` using the Angular CLI generate command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The created component is meant to receive a list of comments from the parent
    component, `AppComponent`. When it receives this component, it can iterate over
    them and print them on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Input` TypeScript decorator is used to specify that a class property will
    be set by a parent component. Hence, we do not need to set any values on `CommentListComponent.comments`,
    but we need to wait until a value is passed down to it via `AppComponent`. Remember
    `AppComponent.comments` exists as well, so we can use property binding to pass
    `AppComponent.comments` to`CommentListComponent.comments`in `app.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `comments` array is the value passed to the `[comments]` attribute. This
    attribute is what we created and decorated in the `CommentListComponent` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have an array of comments on the parent component (`AppComponent`);
    you have passed this component down to the child component (`CommentListComponent`)
    via property binding, and you''re receiving the list of comments using the `Input`
    decorator. The next thing you need to do is display the received comments on `comment-list.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `*ngFor` directive is used to iterate over the comments, get each comment,
    and display a comment on our view.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ba7abb11-cdac-4852-a474-b5a22ea57684.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can go a level deeper to create a comment item component, which just takes
    a single comment and displays it. Create another component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a decorated comment property, which will receive the comment item from
    the comment list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Send the comment down via the `comment list` parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `comment` template variable doesn't have to exist on the component class.
    It's procured from the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can simply render the comment item on the `comment-item.component.html`
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding another child illustrates nesting. `App | comment list | comment item`
    is the flow. `App` is the parent of `comment list` and the grandparent of `comment
    item`. `comment list` is the parent of `comment item`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head to the browser and see that, while nothing actually changes, our code
    is structured better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/52f7ff63-9805-4065-93e8-79ad575cba53.png)'
  prefs: []
  type: TYPE_IMG
- en: Intercepting property changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you may want to do some tweaking on the data flowing into a child
    component from the parent component. You can use getters and setters to intercept
    the data and manipulate it before setting it on the view. Let''s see that in play
    by capitalizing the author names before they are set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The decorator is no longer set on the value property but on the setter property.
    This property receives the comment from the comment list—the parent component.
    It then overrides the author property with an uppercase version of the author's
    name. The getter just returns the comment, so you can access it from the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how it looks in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fb9adce2-7254-4c30-9bbe-d16ff3140fa3.png)'
  prefs: []
  type: TYPE_IMG
- en: Child–parent flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this flow, rather than passing data down, the data needs to flow up the chain.
    Most of the time, the data flows up based on the events triggered on the child
    by the user and we try to notify the parent about that event. Hence, Angular allows
    you to listen to the child events on the parent component and to act on the events.
    These events can be characterized with the data as the payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by registering a double-click event on each comment item via the
    comment list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to add the `showComment` handler on the component class to handle
    this event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The handler uses `onShowComment`, which is decorated as an output property with
    the `Output` decorator to emit an event of the`EventEmitter`type. This emitted
    event is what the parent component will need to listen to. Note how the comment
    is passed to the `emit` method; this shows how we can pass data from the child
    to the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we listen to the parent component (`App`) for this event to occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that the event binding annotation, `()`, is used for events, in this case,
    `onShowComment`. The binding refers to `EventEmitter`, while its value refers
    to the handler method that is yet to be created. The handler method is called,
    and we pass the value data from the child component as `$event`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The method just alerts the comment as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/536c136e-4205-42ba-88e1-03897066c949.png)'
  prefs: []
  type: TYPE_IMG
- en: Accessing properties and methods of a child via a parent component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other than data flowing in and the event pushed up, there are other strategies
    for communication. We can access child members from the parent component using
    template variables. Let''s create a counter component to serve as our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add a counter variable and initialize it to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Also, there are two methods to just increment or decrement the counter. Note
    that nothing calls these methods; there are no buttons with an event attached
    to increment or decrement. What we want to do is access these methods from the
    parent component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, add the component to the template with a template variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`#counter` is a variable that is accessible from anywhere in the template.
    Hence, you can use it as an object to access the methods and properties of the
    counter component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows a button counter with buttons that we can click to increment or
    decrement the counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d175e8fa-a9ae-4ae4-840e-66b381d81a10.png)'
  prefs: []
  type: TYPE_IMG
- en: Accessing child members with ViewChild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the template variables don''t feel natural, you can achieve the same behavior
    using `ViewChild`. This allows you to access the child as a variable on the class
    and not on the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We import the counter component and register it as a child of this component
    using `ViewChild`. We then create a `counterComponent` variable of the`CounterComponent`type.
    We can then use this variable in our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you can start using components as building blocks by writing small, maintainable
    components and making them interact with each other using composition. In this
    chapter, you learned what hierarchical inheritance means in component architectures, how
    data flows up and down hierarchical trees, and how components interact with each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore a more centric interaction strategy using
    services. This will help us create logic that components will share, hence keeping
    our codebase very DRY (Don't Reapeat Yourself).
  prefs: []
  type: TYPE_NORMAL

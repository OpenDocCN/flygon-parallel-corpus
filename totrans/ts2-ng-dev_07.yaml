- en: Separating Concerns with Typed Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter builds on the previous chapter, with more techniques showing how
    communication occurs within your application''s building blocks. You will learn
    the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Services and Dependency Injection (DI) concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component communication with services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data logic with services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand services better, you need to understand at least the basic concepts
    of Dependency Injection.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Angular in TypeScript demands that your building blocks (components,
    directives, services, and so on) are written in classes. They are just building
    blocks, which means that they need to be intertwined with each other before they
    can become functional, thus making a full-blown application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This intertwining process can be pretty daunting. For this reason, let''s understand
    the problem first. Take the following TypeScript class, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the `Person` and `Skill` classes is as simple as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sample is very functional and valid code until you starting having
    more developer types that need to be created using this class. There is no way
    to actually create another type of developer because all the implementation details
    are tied to a class; hence, the process isn't flexible. We need to make the class
    a lot more generic before it can be used to create more types of developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try improving the `Developer` class, so it receives all the values needed
    to create a class from the constructor rather than setting it in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So much improvement in so few lines! We are now using the constructor to make
    the code a lot more flexible. With this update, you can use the `Developer` class
    to create as many types of developer as you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this solution seems like it will save the day, there is still a tight
    coupling issue going on in the system. What happens when the constructors in the `Person` and `Skill` classes
    change? The implication is that you will have to come back and update the call
    to this constructor in the `Developer` class. Here is an example of such a change
    in `Skill`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We added another field to the `yearsOfExperience` class, which is of the number
    type and represents how long a developer has been practicing a claimed skill.
    For this to actually work in `Developer`, we have to update the `Developer` class
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Updating this class every time a dependency changes is what we''re are striving
    to avoid. A common practice is to elevate the constructors of the dependencies
    to the constructor of the class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This way, the `Developer` is less aware of the implementation details of `Skill`
    and `Person`. Therefore, if they change internally, `Developer` won't care; it
    just stays as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, TypeScript provides a productivity shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This shorthand will implicitly declare the properties and assign them as dependencies
    via the constructor as well.
  prefs: []
  type: TYPE_NORMAL
- en: That's not all; elevating these dependencies introduces another challenge. How
    do we manage all the dependencies in our application without losing track of where
    things are meant to be? This is where Dependency Injection comes in. It's not
    an Angular thing, but a popular pattern implemented in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start seeing DI in action right in an Angular app.
  prefs: []
  type: TYPE_NORMAL
- en: Data in components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To better understand the importance of services and DI, let''s create a simple
    app with a component that shows a list of user comments. Once you have an app
    created, you can run the following command to generate the required component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the component''s code with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The component has a `comments` array, which is populated with hardcoded data
    once the component is initialized via the `ngOnInit` lifecycle. Now we need to
    iterate over the list of arrays and print on the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to include the component in your entry (app) component for it to show
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Your app should look like the following (remember to include Bootstrap as seen
    in [Chapter 2](1388eb32-f9cf-4efd-86fe-dc3f201ed039.xhtml), *Getting Started with
    TypeScript*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d857dd7f-3771-4c0f-b578-17ce88a96779.png)'
  prefs: []
  type: TYPE_IMG
- en: This example works, but the devil lies in the detail. When another component
    needs a list of comments or a portion of the list, we end up recreating the comments.
    This is the problem with having data in components.
  prefs: []
  type: TYPE_NORMAL
- en: Data class services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the sake of reusability and maintainability, we need to abstract the logic
    concerns out of the component and let the component just serve as a presentation
    layer. This is one of those use cases where TypeScript services in Angular come
    into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'You first need to create a service with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates your service class, `./src/app/comment.service.ts`, with a scaffold
    content. Update the content with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The class now does whatever our component was supposed to do with the data,
    and the data is fetched using the `getComments` method, which simply returns an
    array of comments. The `CommentService`class is also decorated; this is not required
    unless the class has dependencies to be resolved. Nonetheless, good practice demands
    that we always decorate with `Injectable` to know that a class is meant to be
    a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back with our list component, we just import the class, resolve the dependency
    from the constructor to create an instance of the service class, and then populate
    the property with the `getComments` return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s attempt to run the app with these current changes in our browser and
    see whether things still work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e3c6caa-3823-455d-9791-2546bf4e64f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Hell, no! It just blew up. What could have gone wrong? The error message reads
    No provider for CommentService!
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that, when we scaffold components with the `ng` CLI command, the CLI
    not only creates a component but also adds it to our declaration array in the
    decorator of `ngModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Modules need to know which components and services belong to them as members.
    This is why the component is added automatically for you. This is not the same
    for services because the CLI doesn''t automatically update the module (it warns
    you during the scaffold) when you create service classes via the CLI tool. We
    need to add the service manually via the `providers` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the app once more to see how our service now powers the app with no
    more errors in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b6d2e1c8-27d6-4690-ad1e-ba2f1c79e877.png)'
  prefs: []
  type: TYPE_IMG
- en: If there is a need to manipulate the data, it must be done in the service and
    not in the component. Assuming you want to delete a comment by double-clicking
    on each item in the list, it's fine to receive the event with the component but
    the actual deletion should be handled by the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding an event listener to the list items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `dblclick`event is triggered by double-clicking the items. When this happens,
    we call the `removeComment` method while passing the comment we want to remove
    from the item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what `removeComment` looks like in the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it doesn''t do anything more than calling a method on our service,
    which is also called `removeComment`. This is the method that has the actual responsibility
    of removing items from the array of comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Component interaction with services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very handy use case for services. In [chapter 6](70f76e99-3d5b-43d6-90ad-5ea049aa622c.xhtml), *Component
    Composition with* TypeScript, we discussed how components interact with each other
    and showed different ways of doing it. One of those ways was left out--using a
    service as an event hub/communication platform for different components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume again that, when an item in the list is clicked, we use a sibling
    component to the comment list component to show a detailed view of the selected
    comment. First, we need to create this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can update the `app.component.html` file to show the added component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to define what our component does, because it''s empty right now.
    But before that, let''s update the comment service to also serve as a hub between
    the list component and the sibling detail component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The service now uses an Rx subject to create a stream and a listener, which
    the selected comment is pushed through and fetched from. The `commentSelectedSource`object
    is responsible for adding a comment to the stream when the comment is clicked.
    The `commetSelected$` object is an observable that we can subscribe to and act
    on when this comment is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, head right back to your component and add a click event to select the
    comment item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The click event triggers a `showComment` method on the component, which, in
    turn, calls `showComment` on the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We still have to update the comment detail component, so it subscribes to the
    observable we created in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `ngOnInit`lifecycle hook, we are able to create a subscription to
    the observable once the component is ready. There is a comment property that will
    be bound to the view, and this property is updated via the subscription every
    time a comment item is clicked. Here is the template for the component showing
    the selected comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can start the app again and try selecting a comment. You should see the
    following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/48b9955d-ace1-4e62-9f8a-3a88ab63ddef.png)'
  prefs: []
  type: TYPE_IMG
- en: Services as utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from managing state and component interaction, services are also known
    for handling utility operations. Let''s say that we want to start collecting new
    comments in our comment app. We don''t know much about forms yet, so we can use
    the browser''s prompt. We expect the user to pass both the username and the content
    via the same textbox in the prompt, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we need a utility method to extract these bits from the textbox
    into a comment object with the author and content properties. Let''s start with
    collecting the information from the comment list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `showPrompt()` method is used to collect the user input, and the input
    is passed to the`parseComment` method on the service. This method is an example
    of a utility method, and we will implement it soon. We will also implement the
    `addComment` method, which is called with the parsed comment to update the list
    of comments. Next, add a button to the view with a click event listener that triggers
    `showPrompt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add these two methods to the comment service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `parseComment` method takes a string, splits the string, and gets the author
    and content of the comment. Then, it returns the comment. The addComment method
    takes a comment and adds it to the list of existing comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can start adding new comments, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/31cc7b09-e373-4aa9-9fa7-f4ef30bd706d.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter exposed a lot of interesting concepts in data abstraction, while
    utilizing the power of dependency injection. You learned how components interact
    with each other using a service as a hub, how data and logic are abstracted from
    a component to services, and how reusable utility code is handled in a service
    to keep your application clean. In the next chapter, you'll learn a practical
    approach to forms in Angular and DOM events.
  prefs: []
  type: TYPE_NORMAL

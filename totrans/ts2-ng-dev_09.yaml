- en: Writing Modules, Directives, and Pipes with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modularity is essential for building large software systems, and Angular projects
    are not an exception to this. When our app starts growing, managing its different
    members in one entry module starts becoming really difficult and confusing. It
    becomes more challenging when you have a lot of services, directives, and pipes.
    Speaking of directives and pipes, we will take some time to discuss their use
    cases and examples in this chapter, while taking a journey in managing our application
    better with modules.
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DOM manipulation is not always best handled in components. Components should
    be as lean as possible; this way, things are kept simple and your code can easily
    be moved around and reused. So, where should we handle DOM manipulation then?
    The answer is directives. Just like you should take data manipulation tasks to
    services, best practices suggest you take heavy DOM manipulations to directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of directives in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, components! Components are qualified directives. They are directives with
    a direct access to the template being manipulated. We have already seen components
    enough in this book; let's focus on the attribute and structural directives.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This category of directives is known for adding behavioral features to the DOM
    but not removing or adding any DOM content. Things such as changing appearance,
    showing or hiding elements, manipulating elements' attributes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand attribute directives, let's build some UI directives that
    are applied to component templates. These directives will change the behavior
    of the DOM when they are applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directive in a fresh project with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create an empty directive in the app folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Directive` decorator is first imported from the`@angular/core` module.
    The decorator is used on any class that is expected to act as a directive. Just
    like decorators on components, the directive decorator takes an object with a
    selector property. When this selector is applied to the DOM, the behavior of the
    directive is exhibited.
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior we are trying to achieve in this example entails styling a completely
    unstyled button with just a single attribute. Let''s assume that we have the following
    button in our app component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a simple boring button on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4c27b9ac-8bbe-47d1-8d4c-fc4668eefec0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To use the attribute directive we just created, add it as a *value-less* attribute
    to the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, find a way to access the button element from the `directive` class. We
    need this access to be able to apply styles to the button, right from the class.
    Thanks to the `ElementRef` class, which, when injected to the directive via the
    constructor, gives us access to the native element, which is where the button
    element can be accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is injected and resolved into the `el` property. We can access the button
    element from the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nativeElement` property gives you access to the element that the attribute
    directive was applied to. You can then treat the value like a DOM API, which is
    why we can access the `style`and `backgroundColor` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7cd2e5f0-0729-4fff-968a-b6968f9e5506.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that the pink background was applied effectively. Let''s make the
    button more interesting with more styles, right from the directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of setting the values using several dots, we just use the `Object.assign`
    method to reduce the amount of code we have to write. Now, we have a prettier
    button in the browser, completely styled with a directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fef31767-c6f0-4eb3-ae1b-ab8a2f6942bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling events in directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Directives are so flexible that they allow you to apply different states, based
    on events triggered by the user. For instance, we can add a hover behavior to
    the button where a different color (say black) is applied to the button when the
    mouse cursor moves over the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We introduced a few members to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: We import `HostListener`, a decorator that extends a method in the class. It
    turns the method into an event listener attached to the native element. The decorator
    takes an argument of the event type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define two methods on `onMouseEnter` and `onMouseLeave`and then decorate
    the methods with `HostListener`. These methods change the background colors of
    the button when a hover occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what the behavior looks like when we hover the mouse over the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8495e131-6c3b-4e47-8bf6-619d6415048c.png)'
  prefs: []
  type: TYPE_IMG
- en: Dynamic attribute directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we, the authors of this directive, are the final consumers? What if
    another developer is reusing the directive as an API? How do we make it flexible
    enough with dynamic values? When you ask yourself these questions while writing
    directives, then it's time to make it dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this while, we have been using the directive without any value. We can
    actually use attribute values to receive inputs into the directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We added a new attribute, `bgColor`, which is not a directive but an input
    property. The property is used to send dynamic values to the directive, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the changes we introduced:'
  prefs: []
  type: TYPE_NORMAL
- en: Two `Input` decorated properties--`bgColor` and `bgHoverColor`--are introduced
    to serve as the flow of dynamic values from the template to the directive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The setup of this directive is moved from the constructor to the `ngOnInit`
    method. This is because the input decorator is set by Angular's change detection,
    which doesn't happen in a constructor, thereby making `bgColor` and `bgHoverColor`
    undefined when we try to access them from the constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When setting up the styles, rather than hardcoding the value of `backgroundColor`,
    we use the value received via `bgColor`. We also have a fallback value just in
    case the developer forgets to include the attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same thing happens to the mouse-enter and mouse-leave events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, the button visuals are affected by dynamic values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/95a00373-e877-40f1-8669-cb1b1bd41e35.png)'
  prefs: []
  type: TYPE_IMG
- en: Structural directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural directives have a lot in common with attribute directives, in terms
    of how they are created, but they are very different in how they are expected
    to behave. A structural directive, unlike an attribute directive, is expected
    to create or remove a DOM element. This is different from using a CSS display
    property to show or hide an element. In this case, the element is still in the
    DOM tree but is not visible to the end user when hidden.
  prefs: []
  type: TYPE_NORMAL
- en: A good example is `*ngIf`. When an element is removed from the DOM using an
    `*ngIf` structural directive, the directive both disappears from the screen and
    gets deleted from the DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: Why the difference?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way you control the visibility of DOM elements could have a great impact
    on the performance of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Take for instance, you have an accordion that is expected to be clicked by the
    user to show more information. The user might decide to hide the accordion's content
    after viewing the content and, at a later time, come back to reopen it for references.
    It starts becoming obvious that the accordion's content has the tendency of being
    displayed and hidden at any time.
  prefs: []
  type: TYPE_NORMAL
- en: When this is the case, it is best that we use an attribute directive that doesn't
    hide/remove the accordion content but rather just hides it. This makes it really
    fast to show and hide again when needed. Using a structural directive such as `*ngIf`
    keeps creating and destroying a part of the DOM tree, which can be very expensive
    if the DOM content being controlled is huge.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when you have some content you're sure the user will view
    only once or a maximum of two times, it is better to make use of a structural
    directive such as `*ngIf`. This way, your DOM is not littered with lots of unused
    HTML contents.
  prefs: []
  type: TYPE_NORMAL
- en: The deal with asterisks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The asterisks that precede all the structural directives are very important.
    The `*ngIf` and `*ngFor`directives refuse to work when you remove the asterisks
    from them, implying that the asterisks are required. The question, therefore,
    is this: why do the asterisks have to be there?'
  prefs: []
  type: TYPE_NORMAL
- en: 'They are syntactic sugar in Angular, meaning that they don''t have to be written
    this way. This is how they actually look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This template attribute is, in turn, translated into the following by Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'See how `ngIf` has now become a normal Angular property but is injected into
    a template. When the value is `false`, the template is removed (not hidden) from
    the DOM tree. Writing such directives this way is just a lot of code to write,
    so Angular added the syntactic sugar to simplify how we write the `ngIf` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating structural directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen how to use structural directives from our previous examples.
    How do we create them? We create them in the same way we created the attribute
    directive, by running the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Yes, we are naming the directive `when`. This directive does exactly what `*ngIf` does,
    so, hopefully, it will help you better understand the internals of the directive
    you've already used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the directive with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We introduced a few members you're not familiar with yet. `TemplateRef` is a
    reference to the `ng-template` template that we saw earlier, in which the DOM
    content we are controlling is contained. `ViewContainerRef` is a reference to
    the view itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `appWhen` directive in the view, it''s expected to take a condition
    such as`ngIf`. To receive such a condition, we need to create a decorated `Input` setter
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The setter method in the directive checks whether the value resolves to `true`and
    then displays the content and creates the view if it's yet to be created. The
    reverse becomes the case when the value resolves to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test the directive by clicking the button we were to toiling within the
    attribute directives section. When the button is clicked, it toggles a property
    to `true` or `false`. This property is bound to the value of the directive we
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the app component class with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `updateToggle`method is bound to the button in order to flip the value
    of `toggle` when clicked by the user. Here is what the app component HTML looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you click the button, it shows or hides the text by adding or removing
    it from the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3ba02da5-84b0-4609-ac7e-631d82b634c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another interesting template feature that we have not discussed yet are pipes.
    Pipes allow you to format the template content in-place, right in the template.
    Instead of formatting content in the component, you could just write a pipe to
    do so for you right in the template. Here is a perfect example for a pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the `| percent` after a decimal figure changes the value to a percentage
    representation, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ccef630-dbac-4d8d-982b-1a1e67e5ad0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is another example with one of the case pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `uppercase` pipe transforms a text string to uppercase. Here is the output
    of the preceding code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1655112a-fdf8-404c-9a96-d6063cffaf9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some pipes take arguments, which help fine-tune the behavior of the pipe when
    applied to some content. An example of such pipes is the currency pipe, which
    takes an argument to define which currency a content will be formatted with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows a nicely formatted value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/41576b5a-4a7a-48cc-92e8-ef5f2995ebb4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The pipe takes two arguments separated by a colon (`:`). The first argument
    is the currency that we set to Euro. The second argument is a Boolean value that
    indicates the kind of currency symbol shown. Because the value is `true`, the
    Euro symbol is shown. Here is the output when the value is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/10f6ee42-d0fd-4ed7-a6cd-2d9f1dd96ae2.png)'
  prefs: []
  type: TYPE_IMG
- en: Instead of using the symbol, it just precedes the value with the currency code
    (EUR).
  prefs: []
  type: TYPE_NORMAL
- en: Creating pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen what we can use pipes for and where we can use them. The next
    thing we need to understand is how to create our own custom pipes using TypeScript
    classes. First, run the following command to generate an empty pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update the generated class file with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This example takes a string and returns the reversed version of the string.
    The `ReversePipe` class implements a `PipeTransform` interface, which defines
    a `transform` method that must be created with a certain signature, as seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: The class is decorated with a `Pipe` decorator, which takes a config object
    as an argument. The object must define a `name` property, which serves as the
    identifier for the pipe when applied to a template. In our case, the name of the
    pipe is `reverse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now apply your custom pipe to the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When you view the example, the text is reversed, so it now starts with p and
    ends with w:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/70355d3c-9e20-42dd-815a-7797aafa89d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Passing arguments to pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to create pipes, but we also have it at the back of our minds that
    pipes take arguments. How do we add these arguments to our custom pipes?
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated pipe could already be giving you hints from the previous example
    because of the optional `args` parameter passed to the transform method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that we want to define whether the reverse of the string is applied
    letter-to-letter or word-to-word, the best way to give the pipe user this control
    is through arguments. Here is an updated example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When the argument supplied is `true`, we reverse the string by words, not letters.
    This is done by splitting the string in places where there are white spaces, not
    empty strings. When it's `false`, we split at empty strings, which reverses the
    string based on letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the pipe while passing it an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the resulting output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bab69d1f-d381-4538-827e-1b9d38be6c4d.png)'
  prefs: []
  type: TYPE_IMG
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We mentioned modules at the beginning of this article and how they help us
    organize our project. With that in mind, take a look at this app module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a module from the directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you paid so much attention to details, you may have noticed that we never
    added `UiButtonDirective` or `WhenDirective` in the directive. Neither did we
    add `ReversePipe` in the pipe example. These additions are automated for all the
    members when your run the `generate` command, except for services.
  prefs: []
  type: TYPE_NORMAL
- en: For all the members you create, that is, components, directives, pipes, and
    services, you need to include them where they belong in a module.
  prefs: []
  type: TYPE_NORMAL
- en: A module (usually referred to as `NgModule`) is a class that is decorated with
    the `NgModule` decorator. This decorator takes a config object that tells Angular
    about the members created in the app and where they belong to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the different properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`declarations`: Components, directives, and pipes must be defined in the `declarations`
    array for them to be exposed to the app. Failure to do so will log errors to your
    console, telling you that the omitted member is not recognized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imports`: The app module is not the only module that exists. You can have
    smaller and simpler modules that group related task members together. In this
    case, you still need to import the smaller modules to the app module. The `imports`
    array is where you do that. These smaller modules are usually referred to as feature
    modules. A feature module can also be imported to another feature module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`providers`: If you have services that abstract specific tasks and need to
    be injected via dependency injection into the app, you need to specify such services
    in the `providers` array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bootstrap`: The `bootstrap` array is only declared in the entry module, which
    is usually the app module. This array defines which component should be launched
    first or which component serves as the entry point of your app. The value is always
    `AppComponent` because that is the entry point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot of concepts, ranging from directives and pipes to modules.
    You learned the different types of directives (attribute and structural) and how
    to create each of them. We also discussed how arguments are passed to pipes while
    creating them. In the next chapter, we will talk about routing in Angular applications
    and how TypeScript plays a significant role.
  prefs: []
  type: TYPE_NORMAL

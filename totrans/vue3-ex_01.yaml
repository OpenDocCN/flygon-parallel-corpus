- en: '*Chapter 1*: Creating Your First Application in Vue 3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Vue 3** is the latest version of the popular Vue.js framework. It is focused
    on improving developer experience and speed. It is a component-based framework
    that lets us create modular, testable apps with ease. It includes concepts that
    are common to other frameworks such as props, transitions, event handling, templates,
    directives, data binding, and more. The main goal of this chapter is to get you
    started with developing your first Vue app. This chapter is focused on how to
    create components.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to use Vue 3 to create simple apps from
    scratch. We will start by building the most basic apps and then move on to building
    more complex solutions in the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major topics we will cover are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Vue as a framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Vue project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vue 3 core features – components and built-in directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with Vue.js Devtools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter is located at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter01](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Vue as a framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the introduction, there are concepts in Vue that are available
    from other frameworks. Directives manipulate the **Document Object Model** (**DOM**)
    just like in Angular.js and Angular. Templates render data like we do with Angular.
    It also has its own special syntax for data binding and adding directives.
  prefs: []
  type: TYPE_NORMAL
- en: Angular and React both have props that pass data between components. We can
    also loop through array and object entries to display items from lists. Also,
    like Angular, we can add plugins to a Vue project to extend its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts that are exclusive to Vue.js include computed properties, which are
    component properties that are derived from other properties. Also, Vue components
    have watchers that let us watch for reactive data changes. Reactive data is data
    that is watched by Vue.js and actions are done automatically when reactive data
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: As reactive data changes, other parts of a component and other components that
    reference those values are all updated automatically. This is the magic of Vue.
    It is one of the reasons that we can do so much with so little code. It takes
    care of the task of watching for data changes for us, so that we don't have to
    do that.
  prefs: []
  type: TYPE_NORMAL
- en: Another unique feature of Vue 3 is that we can add the framework and its libraries
    with script tags. This means that if we have a legacy frontend, we can still use
    Vue 3 and its libraries to enhance legacy frontends. Also, we don't need to add
    build tools to build our app. This is a great feature that isn't available with
    most other popular frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: There's also the popular Vue Router library for routing, and the Vuex library
    for state management. They have all been updated to be compatible with Vue 3,
    so we can use them safely. This way, we don't have to worry about which router
    and state management library to use as we do with other frameworks such as React.
    Angular comes with its own routes, but no standard state management library has
    been designated.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Vue project with the Vue CLI and script tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to create Vue projects or to add script tags to our
    existing frontends. For prototyping or learning purposes, we can add the latest
    version of Vue 3 by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will always include the latest version of Vue in our app. If we use it
    in production, we should include the version number to avoid unexpected changes
    from newer versions breaking our app. The version number can replace the `next`
    word if we want to specify the version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also install Vue by installing it as a package. To do that, we can run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will install the latest version of Vue in our JavaScript project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we created a Vue project from scratch with an older version of the Vue CLI,
    then we can use the CLI to generate all the files and install all the packages
    for us. This is the easiest way to get started with a Vue project. With Vue 3,
    we should use Vue CLI v4.5 by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also install the Vue palate by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to upgrade our Vue project to Vue 3, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The Vite build tool will let us create a Vue 3 project from scratch. It lets
    us serve our project much faster than with the Vue CLI because it can work with
    modules natively. We can set up a Vue project from scratch by running these commands
    with NPM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With Yarn, we must run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In either case, we replace `<project-name>` with the project name of our choice.
  prefs: []
  type: TYPE_NORMAL
- en: There are various builds of Vue that we can use. One set are CDN versions, which
    don't come with bundlers. We can recognize them by the `vue(.runtime).global(.prod).js`
    pattern in the filename. These can be included directly with script tags.
  prefs: []
  type: TYPE_NORMAL
- en: We use them with templates that are directly added to the HTML. The `vue.global.js`
    file is the full build and includes both the compiler and the runtime, so it can
    compile templates on the fly from HTML. The `vue.runtime.global.js` file only
    contains the runtime and requires the template to be precompiled during a build
    step.
  prefs: []
  type: TYPE_NORMAL
- en: The development and production branches are hardcoded, and we can tell them
    apart by checking if the file ends with `.prod.js`. These files are production
    ready as they're minified. These aren't **Universal Module Definition** (**UMD**)
    builds. They contain IIFEs that are meant to be used with regular script tags.
  prefs: []
  type: TYPE_NORMAL
- en: If we use a bundler such as Webpack, Rollup, or Parcel, then we can use the
    `vue(.runtime).esm-bundler.js` file. The development and production branches are
    determined by the `process.env.NODE_ENV` property. It also has the full version,
    which compiles the template on the fly at runtime and a runtime version.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be going through the basic features of Vue with the
    script tag version of Vue. In the subsequent chapters, we'll move on to using
    the Vue CLI to create our Vue 3 projects. This way, we can focus on exploring
    the basic features of Vue 3, which will be handy when we move on to creating more
    complex projects. Let's begin by creating a Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your Vue instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have set up our Vue project, we can look at the Vue instance more
    closely. All Vue 3 apps have a Vue instance. The Vue instance serves as the entry
    point of the app. This means this is what is loaded first. It is the root component
    of the app, and it has a template and a component option object to control how
    the template is rendered in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our first Vue 3 app, we must add the following code to the `index.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In our first Vue 3 app, we started by adding the `script` tag to add the Vue
    framework script. It's not final yet, so we added the next version of the Vue
    script.
  prefs: []
  type: TYPE_NORMAL
- en: In the body, we have a `div` with the ID app, which we use to hold the template.
    The only content that is inside the template will be compiled by the template
    compiler that comes with Vue 3\. Below that, we have a `script` tag to create
    our app. It provides the `Counter` object, which contains the properties we can
    use to create our app.
  prefs: []
  type: TYPE_NORMAL
- en: Vue components come as objects that will be used by Vue to create any necessary
    components. The `data` property is a special property that returns the initial
    values of our states. The states are automatically reactive. The `count` state
    is a reactive state that we can update. It is the same one that's in the template.
    Anything in the curly braces must be some expression that contains reactive properties
    or other JavaScript expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add reactive states between the curly braces, then they will be updated.
    Since the `count` reactive property is initialized to `0`, the `count` property
    is also `0` in the template. The `Counter` object is passed into the `Vue.createApp`
    method to compile the template and connect the reactive properties, to render
    the expression inside the curly braces as the final result. So, we should see
    `count: 0` in our rendered output.'
  prefs: []
  type: TYPE_NORMAL
- en: The `mount()` method accepts a CSS selector string as its argument. The selector
    is the template to render the app in. Whatever is inside it will be considered
    Vue expressions, and they will be rendered accordingly. Expressions in curly braces
    will be rendered and attributes will be interpreted by Vue as props or directives,
    depending on how they are written.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the core features of Vue.js 3.
  prefs: []
  type: TYPE_NORMAL
- en: Vue 3 core features – components and built-in directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created a basic Vue app with a Vue instance, we can look more
    closely at how to make it do more. Vue 3 is a component-based framework. Therefore,
    components are the core building blocks that are used to build full production
    - quality Vue 3 apps. Components are parts that can be combined to form a full
    app and are reusable. Vue 3 components have several parts, which include the template,
    the component option object, and the styles. The styles are the CSS styles that
    we apply to the rendered elements. The template is what is rendered on the browser's
    screen. It contains HTML code combined with JavaScript expressions to form the
    content that's rendered in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Templates get their data from the corresponding component option object. Also,
    the component templates can have directives that control how content is rendered
    and how to bind data from the template to a reactive property.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a basic Vue app with a Vue instance. Now, we must find a way to organize
    our app in a manageable way. Vue 3 is a component-based frontend framework. This
    means that apps created with Vue 3 are created by composing multiple components
    into one. This way, we can keep each part of our app small, and this helps with
    making testing easy, as well as easy to debug. This is something that is important
    as we are creating a non-trivial app that provides functionality for users.
  prefs: []
  type: TYPE_NORMAL
- en: In Vue 3, a component is a Vue instance with some predefined options. To use
    components in another component, we must register them. To create a Vue component,
    we can call the `app.component()` method. The first argument is the component,
    called `string`, while the second argument is an object that contains the component
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'A minimal component should at least contain the template property that was
    added to the object. This way, it will display something in our component to make
    it useful. We will start by creating a component for displaying todo items. To
    display our todo item, we can create a `todo-item` component. Also, a component
    most likely needs to accept props to display data from its parent component. A
    **prop** is a special attribute that lets a Vue component pass some data to a
    child component. A child component has the `props` property to define what kind
    of value it will accept. To do this, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We called the `app.component()` method to create the `todo-item` component.
    It contains the `props` property with an array of prop names to accept the `todo`
    prop. The way we defined the prop means that we can accept any value as the value
    of the `todo` prop. We can also specify them with a value type, set whether it
    is required or not, or provide a default value for it. The `template` property
    lets us render it when we want to. We just set it to a string, and it will render
    the items like any other template.
  prefs: []
  type: TYPE_NORMAL
- en: The `li` element is rendered in the template. The curly braces work the same
    way as any other template. It is used to interpolate the value. To access the
    prop's value, we just access it as a property of this in the component or just
    with the prop name itself in the template.
  prefs: []
  type: TYPE_NORMAL
- en: To pass the `todo` prop from the root Vue instance to the `todo-item` component,
    we prefix the prop name with a colon to indicate that it is a prop. The colon
    is short for `v-bind`. The `v-bind` directive is a built-in Vue directive that
    lets us pass data to a child component as a prop. If we have a prop name that
    is in camel case, then it will be mapped to a kebab-case name in the HTML to keep
    it valid. This is because valid attributes should have kebab-case names. The template
    compiler that comes with Vue 3 will do the mapping automatically. So, we just
    have to follow the conventions and then we can pass our props correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are using the `v-for` directive, we should add the key prop so that Vue
    3 can keep track of the items properly. With the `v-for` directive, we can loop
    through an array or object and display the entries from them. The value should
    be a unique ID so that Vue can render the items properly, even if we swap the
    positions of the items and add or delete items and perform other actions in a
    list. To do this, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Each `id` property value is unique for Vue's list tracking to work.
  prefs: []
  type: TYPE_NORMAL
- en: Vue components look like custom elements in the web component's specification,
    but Vue components are not custom elements. They can't be used interchangeably.
    It is just a way to use a familiar syntax for creating components, and this is
    standard. There are some features in Vue components that are not available in
    custom elements. There is no cross-component data flow, custom event communication,
    and build tool integration with custom components. However, all these features
    are available in Vue components. We will cover these features of Vue components
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Component life cycle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each Vue 3 component has its own life cycle, and each life cycle stage has its
    own method. If the given stage of the life cycle is reached and if the method
    is defined in the component, the method will be run.
  prefs: []
  type: TYPE_NORMAL
- en: Right after the app is mounted with `app.mount(),` the events and life cycle
    are initialized. The first method that will be run when the component is being
    loaded is the `beforeCreate()` method. Then, the components are initialized with
    the reactive properties. Then, the `created()` method is run. Since the reactive
    properties are initialized at this stage, we can access the reactive properties
    in this method and the methods that are loaded after this one.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the component's template or render functions are run to render the items.
    Once the content is loaded, `beforeMount` is run. Once `beforeMount` is run, the
    app will be mounted into the element that we specified with the selector we passed
    into the `app.mount()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Once the app is mounted into the element, the mounted hook is run. Now, when
    any reactive property changes, the `beforeUpdate` hook is run. Then, the virtual
    DOM is rerendered, and the latest items are rendered from the latest values of
    the reactive properties. It is a good place to run any initialization code for
    outside libraries. Once that is done, the `updated` hook is run.
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeDestroy` is run right before the component is unmounted. It is a good
    place to run any cleanup code before destroying the component. The `destroyed`
    hook is run when the component is destroyed. The reactive properties won''t be
    available here.'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reactive properties are properties of the component option object that let us
    synchronize what is displayed in the template, and they change according to the
    operations we do with them. Any changes that are applied to reactive properties
    are propagated throughout the app wherever they are referenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we added the `count` reactive property to our app.
    To update it, we just have to update the reactive property''s value itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the `@click="count++"` expression, which listens for clicks of
    the button, and we increase the count by `1` when we click the increment button.
    The latest value will be reflected everywhere since it is a reactive property.
    Vue can pick up the changes for reactive properties automatically. `@click` is
    shorthand for `v-on:click`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can rewrite the expression as a method. To do that, we can write the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To reference the `count` reactive property in the Vue instance object, we must
    reference it as a property of this. So, `this.count` in the Vue instance object
    is the same as `count` in the template. The `this` keyword refers to the component
    instance. We should remember this so that we don't run into problems later.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we add the method's properties to the component object. This is a special
    property that is used to hold methods in our code that we can reference in other
    parts of the Vue instance or in our template. Like with reactive properties, methods
    are referenced as properties of this in the Vue instance object, and we omit this
    in the template.
  prefs: []
  type: TYPE_NORMAL
- en: So, when we click the button, we run the increment method in the `methods` property.
    When we click the button, the count value will increase by `1`, and we should
    see that displayed in our browser's output.
  prefs: []
  type: TYPE_NORMAL
- en: Handling user input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most apps require users to input something to forms. We can do this easily with
    Vue 3 with the `v-model` directive. It synchronizes the inputted value with the
    reactive properties that we have defined in our Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, we just add the `v-model` attribute to the input box. To do that,
    we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the `message` reactive property, which has been initialized to
    the `hello world.` string. We can use the same value in the template by setting
    that as the value of the `v-model` directive. It will do the synchronization between
    the inputted value and the `message` reactive property so that whatever we type
    in will be propagated to the rest of the Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the `hello world.` string is both shown in the input box and the
    paragraph element. And when we enter something into the input box, it will also
    be shown in the paragraph element. It will update the value of the `message` reactive
    property. This is one great feature that comes with Vue 3 that we will use in
    many places.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals and loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another very useful feature of Vue 3 is that we can conditionally render content
    in the template. To do this, we can use the `v-if` directive, which lets us show
    something conditionally. The `v-if` directive puts the element in the DOM only
    if the condition we assign to it is true. The `v-show` directive shows and hides
    the element it is bound to with CSS, and the element is always in the DOM. If
    the value for it is true, then we will see it shown in the template. Otherwise,
    we don't see the item displayed.
  prefs: []
  type: TYPE_NORMAL
- en: It works by conditionally attaching the item to the DOM. The elements and components
    that are inside the element or component that has the `v-if` directive are only
    appended to the DOM when the `v-if` value is true. Otherwise, they won't be attached
    to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s say we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `''hello world''` will be shown since `show` is `true`. If we have the
    following code, we won''t see anything displayed since the span isn''t attached
    to the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To render an array of items in our template and the final output, we can use
    the `v-for` directive. We place a value that is a special JavaScript expression
    that lets us loop through the array. We can use the `v-for` directive by writing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have the `v-for` directive with our `li` element. `'todo in todos'` loops
    through the `todo` array and renders the item in-between the tags. The `todo`
    variable is the individual *todos* entry that is being iterated. We access the
    description property so that we can show the value of the description in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have done that, we will see a numbered list with the `todo` text listed.
  prefs: []
  type: TYPE_NORMAL
- en: Template syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already used templates extensively. We mainly use interpolation to display
    data and some directives to render data. Also, we can use the `@` or `v-on` directive
    to listen to events that are emitted, such as clicks and input value changes.
  prefs: []
  type: TYPE_NORMAL
- en: There is other useful syntax that we can use to create templates with. One of
    them is displaying raw HTML with our interpolated expressions. By default, Vue
    3 escapes all HTML entities so that they will be displayed as-is. The `v-html`
    directive lets us display HTML code as real HTML rather than as plain text.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set the `rawHtml` reactive property as the value of `v-html`, so that
    we can see the `b` tag being rendered as bold text instead of the characters in
    raw form being rendered.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript expressions and templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can put any JavaScript expressions in-between the curly braces. It can only
    be a single expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following pieces of code show what''s valid in-between the
    curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, we can't put any JavaScript statements in-between the curly braces.
    For example, we can't write `{{ var foo = 1 }}` or `{{ if (yes) { return message
    } }}`.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Computed properties** are special reactive properties that are derived from
    other reactive properties. Computed properties are added to the computed property''s
    objects as functions. They always return something that is derived from other
    reactive properties. Therefore, they must be synchronous functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a computed property, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created the `reversedMessage` computed property, which is the reverse
    of the `message` reactive property. We return the message with the order of the
    characters reversed. Whenever the `message` reactive property is updated, the
    `reversedMessage()` method will be run again and return the newest value. Therefore,
    we can see both `'hello world'` and `'dlrow olleh'` in the same template. The
    return values of these computed properties must have other reactive properties
    in them so that they will be updated when other reactive properties update.
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components may not have enough to do what we want. The main thing that is missing
    is the ability to manipulate the DOM and synchronize input data with reactive
    properties. Directives are special attributes that start with the `v-` prefix.
    They expect single JavaScript expressions as values. We have already seen some
    built-in directives such as `v-if`, `v-for`, `v-bind`, and `v-on` being used for
    various purposes. Directives can take arguments in addition to values.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can write `<a v-on:click="doSomething"> ... </a>` to listen
    to the click event on the anchor element. The `v-on` part is the directive's name.
    The part between the colon and the equal sign is the argument for the directive,
    so `click` is the directive's argument. `doSomething` is the value of the directive.
    It is the name of the method we want to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Directive arguments can be dynamic. To add dynamic arguments, we can put them
    between square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`attributeName` is the reactive property that we want to use to set the value
    of the argument. It should be a string. We can also do the same thing with the
    `v-on` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We listen to the event with the given `eventName`. `eventName` should also be
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: Directive modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Directives can take modifiers that let us change the behavior of a directive.
    Modifiers are special postfixes that are denoted by a dot. They can be chained
    to provide more changes. They indicate that a directive should be bound in some
    special way. For instance, if we need to listen to the `submit` event, we can
    add the `prevent` modifier to make it call `event.preventDefault()`, which will
    prevent the default submission behavior. We can do that by writing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look at how to debug Vue 3 projects easily with the Vue.js Devtools
    browser extension.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with Vue.js Devtools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, there is no easy way to debug our app. All we can do is add `console.log`
    statements to our code to look at the values. With Vue.js Devtools, we can have
    more visibility in our app. Vue.js Devtools is a Chrome or Firefox extension that
    we can use to debug our Vue.js applications. It can be used on projects that are
    created with Vite or created from scratch by including the `script` tag for Vue
    3\. We can install the extension by searching for the Vue.js Devtools extension
    in the respective browser's app store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important:'
  prefs: []
  type: TYPE_NORMAL
- en: The URL to install the Chrome version of Vue.js Devtools is at [https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd).
  prefs: []
  type: TYPE_NORMAL
- en: The Firefox version of the add-on is at [https://addons.mozilla.org/en-CA/firefox/addon/vue-js-devtools/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search](https://addons.mozilla.org/en-CA/firefox/addon/vue-js-devtools/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve installed it, we should see the Vue tab in the browser''s development
    console. With it, we can inspect the reactive properties that are loaded by Vue.
    If our component has a `name` property, then it will be displayed in the component
    tree of the application. For example, let''s say we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, since we have the `name` property of the `foo` component set to `'foo'`,
    we will see that listed in the component tree. Also, the `foo` component has the
    `message` reactive property, so we will also see the `message` property displayed
    with its value. Above the component tree, there is a search box that lets us find
    the reactive property with the given name. We can also search for components with
    the **Find components**`…` input box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows us the values of Reactive properties in our
    Vue 3 app, within the Vue Devtools extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Inspecting reactive properties with Vue Devtools'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_1.1_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – Inspecting reactive properties with Vue Devtools
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also the **Timeline** menu item, which we can use to inspect the events
    that are emitted. For example, let''s say we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When we click on the **Increment** button, we will see the mouse events logged
    in the **Timelines** section. The time the event is triggered will also be logged.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Global Settings** section, we can see the **Normalize Component Names**
    setting, which lets us change how the component names are displayed. We can display
    the original name in Pascal case or Kebab case. The **Theme** option lets us change
    the theme color of the Vue tab.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that Vue 3 is a component-based framework, and we
    looked at the different parts of the component. One important part we covered
    was reactive properties. They are properties of the component that we can change
    to update all the parts of the app that reference the reactive property. These
    properties can be watched manually, and any value changes are also picked up automatically
    by Vue 3 so that any parts of the app that reference the reactive property are
    updated automatically. Components are composed in a way that they can be reused
    whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to understand the role of a template in every component. Templates
    are also a part of every component. They must all render something onto the screen.
    Templates can have HTML elements, other components, and directives that modify
    how the elements and components in the template are rendered. Templates can have
    JavaScript expressions in them so that we can do things such as react to events.
    Then, we looked at the importance of computed properties in a component. Computed
    properties are special reactive properties that depend on other reactive properties.
    They are functions that are synchronous and return a value based on combining
    other reactive properties.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point that we looked at is the `v-model` directive, which
    is built into Vue 3\. Vue 3 provides the `v-model` directive so that we can bind
    reactive properties to form control values. Directives are special Vue code that
    let us change how DOM elements are rendered. Vue 3 provides many built-in directives
    to do things such as render elements from an array, bind form control values to
    reactive properties, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we looked at how to use Vue.js Devtools to make debugging
    easier. It is a browser extension available for Chromium browsers and Firefox
    that lets us watch the reactive property values of components and see what components
    are rendered. It will also log any events that are triggered by the elements in
    a component.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to build a simple GitHub app that makes
    HTTP requests.
  prefs: []
  type: TYPE_NORMAL

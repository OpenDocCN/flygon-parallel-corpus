- en: Authentication and Session Management Flaws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main purpose of web applications is to allow users to access and process
    information that is stored in a remote place. Sometimes this information is public,
    while at other times it may be user-specific or even confidential. Such applications
    require the users to prove their identity before being allowed access to such
    information. This identity verification process is called **authentication**,
    and it requires the user to provide a proof of identity that may be one or more
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Something the user *knows*: Such as a username and secret password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Something the user *has*: Like a smart card or a special code sent to the user''s
    phone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Something the user *is*: Voice, facial, fingerprint, or any other biometric
    mechanism'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first alternative is the most common in web applications. There are some
    cases, such as banking or internal corporate applications, which may use one or
    more of the remaining methods.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is a stateless and connectionless protocol. This means that every request
    that a client sends to the server is treated by the server as unrelated to any
    previous or future requests sent by that or any other client. Thus, after a user
    logs in to a web application, the next request will be treated by the server as
    if it was the first one. Hence, the client would need to send their credentials
    on every request. This adds unnecessary exposure for that sensitive information
    and needless effort to the communications.
  prefs: []
  type: TYPE_NORMAL
- en: A number of techniques have been developed to allow web applications to track
    the activities of users and maintain the state of the application according to
    the changes they make to their own environment, and to separate them from the
    ones of other users without asking them to log in for every action they take.
    This is called **session management**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will review how authentication and session management are
    usually performed in modern web applications, and you will learn how to identify
    and exploit some of the most common security flaws in such mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication schemes in web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting into the specific penetration testing concepts, let's review
    how authentication is done in modern web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Platform authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using **platform authentication**, users send their credentials in every
    request's header, using the `Authorization` variable. Even when they have to submit
    their credentials only once, the browser or the system stores them and uses them
    when required.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different types of platform authentication. The most common
    ones are discussed in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Basic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this type of platform authentication, the username and password are sent
    attached to the `Authorization` header and encoded using base64\. This means that
    anybody who sees the request's header is able to decode the credentials to cleartext,
    as base64 encoding is not a cryptographic format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshots show how login information is sent in base64 and
    how it can be decoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can use Burp Suite''s Decoder to convert from base64 to ASCII text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Digest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Digest authentication** is significantly more secure than basic authentication.
    When a client wants to access a protected resource, the server sends a random
    string, called a **nonce**, as a challenge. The client then uses this nonce together
    with the username and password to calculate an MD5 hash and sends it back to the
    server for verification.'
  prefs: []
  type: TYPE_NORMAL
- en: NTLM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**NTLM** is a variant of digest authentication, where Windows credentials and
    an NTLM hashing algorithm are used to transform the challenge of an application''s
    username and password. This scheme requires multiple request-response exchanges,
    and the server and any intervening proxies must support persistent connections.'
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This authentication scheme makes use of the **Kerberos** protocol to authenticate
    to a server. As with NTLM, it doesn''t ask for a username and password, but it
    uses Windows credentials to log in. This protocol uses an **Authentication Server**
    (**AS**) apart from the web server, and it involves a series of negotiation steps
    in order to authenticate. These steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends the username (ID) to the AS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The AS looks for the ID in the database and uses the hashed password to encrypt
    a session key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The AS sends the encrypted session key and a ticket (TGT) containing the user
    ID, session key, session expiration, and other data, encrypted with the server's
    secret key to the client. If the password is incorrect, the client will be unable
    to decrypt its session key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client decrypts the session key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the client wants to access a protected resource on the web server, it will
    need to send the TGT and resource ID in one message and client ID and timestamp
    encrypted with the session key in another message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the server is able to decrypt the received information, it responds with
    a client-to-server ticket, encrypted using AS's secret key and a client/server
    session key, further encrypted using the client's session key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this information from the AS, the client can now request the resource from
    the web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following diagram, you can see the process graphically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: HTTP Negotiate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Also called *Windows Authentication*, the **HTTP Negotiate** scheme uses Windows
    credentials and selects between Kerberos and NTLM authentication, depending on
    whether Kerberos is available or not.
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks of platform authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the Kerberos and NTLM schemes are considered secure, and even digest
    or basic authentication can be used over TLS with a low risk of a malicious actor
    intercepting the communication and stealing the credentials, platform authentication
    still has some inherent disadvantages in terms of security. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Credentials are sent more often, hence their exposure and the risk of being
    captured in a **Man-in-the-Middle** (**MITM**) attack are higher, especially for
    the basic, digest, and NTLM schemes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform authentication does not have the log out or session expiration options.
    As **Single Sign On** (**SSO**) is in place when using Windows Authentication,
    the session starts as soon as the user opens the application's main page without
    asking for username and password, and it gets renewed automatically if it expires.
    An attacker who gains access to the user's machine or Windows account will gain
    instant access to the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform authentication is not suitable for public applications, as they require
    a higher technological and administrative effort to set up and manage than the
    most popular form-based authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the kind of authentication with which we are more familiar: an HTML
    form that contains username and password fields and a submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This authentication may vary from case to case, as its implementation is completely
    application dependent. Nevertheless, the most common approach follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The user fills in the authentication form and clicks on the Submit button. The
    client (web browser) then sends the request containing username and password to
    the server in cleartext, unless the client-side encryption is done by the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server receives the information and checks for the existence of the user
    in its database and compares the stored and submitted passwords (or password hashes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user exists and the password is correct, the server responds with an
    affirmative message that may include a redirection to the user's home page and
    a session identifier (usually as a cookie) so that the user doesn't need to send
    their credentials again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client receives the response, stores the session identifier, and redirects
    to the home page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is by far the most interesting authentication method from a penetration
    testing perspective, as there is no standard way to do it (even when there are
    best practices), and it is usually a source for a good number of vulnerabilities
    and security risks due to improper implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Two-factor Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated before, to prove your identity to an application, you must provide
    something you know, something you have, or something you are. Each of these identifiers
    are called a **factor**. **Multi-factor Authentication** (**MFA**) comes from
    the need to provide an extra layer of security to certain applications and prevent
    unauthorized access in case, for example, a password is guessed or stolen by an
    attacker.
  prefs: []
  type: TYPE_NORMAL
- en: '**Two-factor** **Authentication** (**2FA**) in most web applications means
    that the user must provide the username and password (first factor) and a special
    code or **One-Time Password** (**OTP**), which is temporary and randomly generated
    by a device that the user has or is sent to them through SMS or email by the server.
    The user then submits the OTP back to the application. More sophisticated applications
    may implement the use of a smartcard or some form of biometrics, such as a fingerprint,
    in addition to the password. As this requires the user to have extra hardware
    or a specialized device, these types of applications are much less common.'
  prefs: []
  type: TYPE_NORMAL
- en: Most banking applications implement a form of MFA, and recently, public email
    services and social media have started to promote and enforce the use of 2FA among
    their users.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OAuth** is an open standard for access delegation. When Facebook or Google
    users allow third-party applications to access their accounts, they don''t share
    their credentials with such applications. Instead, service providers (Google,
    Twitter, or Facebook) share a special access token that allows such applications
    to retrieve specific information about the user''s account or access certain functionality
    according to the permission given by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: Session management mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Session management** involves the creation or definition of session identifiers
    on login, the setting of inactivity timeouts, session expiration, and session
    invalidation on logout; also, it may extend to authorization checks depending
    on the user''s privileges, as the session ID must be linked to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: Sessions based on platform authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When platform authentication is used, the most common approach used is to work
    with the header that is already included, containing the credentials, or challenge
    the response as the identifier for a user's session, and to manage session expiration
    and logout through the application's logic; although, as stated previously, it's
    common to find that there is no session timeout, expiration, or logout when platform
    authentication is in place.
  prefs: []
  type: TYPE_NORMAL
- en: If Kerberos is used, the tokens emitted by the AS already include session information
    and are used to managing such session.
  prefs: []
  type: TYPE_NORMAL
- en: Session identifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Session identifiers are more common in form authentication, but they may also
    be present when we use platform authentication. A **session identifier**, or a **session
    ID**, is a unique number or value assigned to every user every time they initiate
    a session within an application. This value must be different from the user's
    ID and password. It must be different every time a user logs in, and it must be
    sent with every request to the server so that it can distinguish between requests
    from different sessions/users.
  prefs: []
  type: TYPE_NORMAL
- en: The most common way to send session IDs between a client and server is through
    cookies. Once the server receives a set of valid usernames and passwords, it associates
    that login information with a session ID and responds to the client, sending such
    IDs as the value of a cookie.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshots, you will see some examples of server responses
    that include session cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, a PHP application sets a session cookie called `PHPSESSID`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, a Java application sets a session cookie called `JSESSIONID`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, an ASP.NET application sets a session cookie called
    `ASP.NET_SessionId`.
  prefs: []
  type: TYPE_NORMAL
- en: Common authentication flaws in web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have spent some time discussing how different authentication mechanisms work
    in web applications. In this section, you will learn how to identify and exploit
    some of the most common security failures in them.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of authentication or incorrect authorization verification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you saw how to use DIRB and other tools to find directories
    and files that may not be referenced by any page on the web server or that may
    contain privileged functionality, such as `/admin` and `/user/profile`. If you
    are able to browse directly to those directories and use the functionality within
    them without having to authenticate, or if being authenticated as a standard user,
    you can browse to the application's administrative area or modify other user's
    profiles just by browsing to them, then that application has a major security
    issue with regard to its authentication and/or authorization mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Username enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In black box and gray box penetration testing scenarios, discovering a list
    of valid users for an application may be one of the first steps, especially if
    such an application is not commercial so that you can look for default users online.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enumerating users in web applications is done by analyzing the responses when
    usernames are submitted in places such as login, registration, and password recovery
    pages. Some common error messages follow, which you can find when submitting forms
    to such pages that tell you that you can enumerate users:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"User foo: invalid password"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"invalid user ID"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"account disabled"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"this user is not active"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"invalid user"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's review a very simple example on how to discover valid usernames from a
    web application that gives excessive information when an incorrect username is
    provided. Use OWASP WebGoat from the **Broken Web Applications** (**BWA**) virtual
    machine with IP address, `10.7.7.5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First run Burp Suite and configure your browser to use it as proxy (in Firefox,
    navigate to Preferences | Advanced | Network | Connection | Settings):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, log in to WebGoat using the `webgoat` default user with the `webgoat` password and
    go to Authentication Flaws | Forgot Password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a password recovery form that requires a username to continue the recovery
    process. You can input a nonexistent username, such as `nonexistentuser`, and
    submit it to see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The username is not valid, and you will not be able to proceed with password
    recovery. You can assume that when the user is valid, you will have a different
    response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s use Burp Suite''s Intruder to try to find a valid name. First, you
    look for the request in Burp Proxy''s history and send it to Intruder (press *Ctrl*
    + *I* or right-click and select Send to Intruder):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, change to the Intruder tab, then to the number of your request, and last
    to Positions. You can see that all client modifiable parameters are selected by
    default. Click on Clear to unselect them, and then select only the username value
    and click on Add:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Intruder automates the sending of multiple requests to the server, replacing
    the selected values with user-provided inputs, and it records all responses so
    that you can analyze them. Now add a list of usernames to try, instead of the
    one already submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Burp Intruder has four different attack types that describe how the inputs
    will be filled with the payloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sniper**: This uses a single payload set, and selects each input position,
    one at a time, for every value within this payload set. The number of requests
    will be the length of the payload set multiplied by the number of input positions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Battering ram**: This uses a single payload set, and selects all input positions
    simultaneously for every value within this payload set. The number of requests
    will be the length of the payload set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pitchfork**: This uses multiple input positions, and it requires a payload
    set for each position. It submits one value for each payload set in its corresponding
    input at a time. The number of requests made will be the length of the shortest
    payload set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster bomb**: When using multiple inputs, all of the elements in the payload
    set 1 will be paired with all of the elements of the payload set 2 and so on until
    the payload set *n*. The number of requests made in the attack is determined by
    multiplying all payload sets'' sizes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, change to the Payloads tab inside Intruder. Leave Payload set unchanged,
    and click on Load... in the Payload Options [Simple List] section; this is designed
    to load a file containing the names that you want to try. Luckily, Kali Linux
    includes an extensive collection of dictionaries and wordlists in the `/usr/share/wordlists`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you will use `/usr/share/wordlists/metasploit/http_default_users.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that you have the request with the input positions defined and the payload
    list ready, click on Start Attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the results, all of the names tried had an identical response;
    that is, all but one. You'll notice that `admin` had a response with a different
    length, and if you go through the response's body, you will see that it is asking
    the password recovery question. So, `admin` is a valid username.
  prefs: []
  type: TYPE_NORMAL
- en: Username enumeration can be done every time that an application shows different
    responses for valid and invalid usernames. Also, some applications include a validation
    when registering a new user, so that the name is not duplicated. If this validation
    is done before the form is submitted, there is a web service preforming such validations
    and you can use it for enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering passwords by brute force and dictionary attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have identified valid users in the application, the natural next step
    is to attempt to find the passwords for these users. There are plenty of methods
    to obtain valid passwords from users, from mimicking the original site in a different
    server and using social engineering to trick users into submitting their information,
    to taking advantage of insecure password recovery mechanisms, to guessing the
    password, if it is a common one.
  prefs: []
  type: TYPE_NORMAL
- en: '**Brute force** is a method that attempts all possible character combinations
    to discover a valid password. This can work well when the application allows passwords
    of one to three or even four characters. If such passwords are allowed, chances
    are that at least one user is using them.'
  prefs: []
  type: TYPE_NORMAL
- en: For longer passwords, a brute force attack is completely impractical, as you
    would need to send millions (or billions) of requests to the application before
    you discover one valid password. Adding to this, the time required to perform
    such an attack is much longer (extremely longer) than the standard one or two
    weeks scheduled for penetration testing. For this situation, we rely on the predictability
    of the human element—even when, for practical purposes, possible combinations
    of eight or more character passwords are almost infinite, we humans tend to use
    only a small subset of those combinations as passwords and the most common ones
    are very common.
  prefs: []
  type: TYPE_NORMAL
- en: To take advantage of this fact, there are dictionaries that contain common or
    default passwords, or the ones known to be leaked in previous attacks on popular
    sites. Using these dictionaries, you can reduce the number of attempts that you
    need to make for discovering a valid password and increasing the chances of finding
    it as a word in the dictionary, which has already been used by a number of people
    as a password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since 2012, SplashData has released a list of the most used passwords in the
    world, according to an analysis made on collections of hacked and leaked passwords.
    The 2017 and 2016 results can be checked at [https://www.teamsid.com/worst-passwords-2017-full-list/](https://www.teamsid.com/worst-passwords-2017-full-list/)
    and [https://www.teamsid.com/worst-passwords-2016/](https://www.teamsid.com/worst-passwords-2016/).
    Another list that gets published on a yearly basis is the one from the Keeper
    password manager: [https://blog.keepersecurity.com/2017/01/13/most-common-passwords-of-2016-research-study/](https://blog.keepersecurity.com/2017/01/13/most-common-passwords-of-2016-research-study/).'
  prefs: []
  type: TYPE_NORMAL
- en: Attacking basic authentication with THC Hydra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**THC Hydra** is a long-time favorite online password cracking tool among hackers
    and penetration testers.'
  prefs: []
  type: TYPE_NORMAL
- en: Online cracking means that login attempts to the service are actually made.
    This may generate a lot of traffic and raise alerts on the server when security
    and monitoring tools are in place. For this reason, you should be especially careful
    when attempting an online brute force or dictionary attack over an application
    or server, and tune the parameters so that you have the best possible speed without
    overwhelming the server, raising alerts, or locking out user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: A good approach for conducting online attacks when there is monitoring in place
    or an account lockout after a certain number of failed attempts is to start with
    three or four passwords per user, or an amount less than the lockout threshold.
    Take the most obvious or common passwords (for example, `password`, `admin`, or
    `12345678`), and if no results are obtained, go back to the reconnaissance stage
    to get a better set of passwords and try again after several minutes or a couple
    of hours.
  prefs: []
  type: TYPE_NORMAL
- en: THC Hydra has the ability to connect to a wide range of services, such as FTP,
    SSH, Telnet, and RDP. We will use it to do a dictionary attack on an HTTP server
    that uses basic authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to know the URL that actually processes the login credentials.
    Pop up your *Kali machine*, open Burp Suite, and configure the browser to use
    it as a proxy. You will use the vulnerable virtual machine and the WebGoat application.
    When you try to access WebGoat, you get a dialog asking for login information.
    If you submit any random name and password, you get the same dialog again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Even when an attempt wasn''t successful, the request is already registered
    in Burp. Next, look for one that has the `Authorization: Basic` header in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you know that the URL processing the login is `http://10.7.7.5/WebGoat/attack`.
    This is enough information to run Hydra, but first you need to have a list of
    possible usernames and another one for passwords. In a real-world scenario, possible
    usernames and passwords will depend on the organization, the application, and
    the knowledge you have about its users. For this test, you can use the following
    list of probable users for an application called WebGoat, and designate it to
    be a target of security testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As for passwords, you can try some of the most common ones and add variations
    of the application''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the usernames'' list as `users.txt` and the passwords'' list as `passwords.txt`.
    First, run `hydra` without any parameters to look at the help and execution information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that it requires the `-L` option to add a user list file, `-P`
    to add a password list file, and the protocol, server, port, and optional information
    in this form: `protocol://server:port/optional`. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You'll find that the combination of the `webgoat` user and the `webgoat` password is
    accepted by the server.
  prefs: []
  type: TYPE_NORMAL
- en: A useful option when using Hydra is `-e` with the `n`, `s`, or `r` modifiers that
    can process login inputs, sending an empty password (`n`), username as password
    (`s`), reverse the username and use it as password (`r`), and `-u`, which loops
    users first. This means that it tries all users with a single password and then
    moves on to the next password. This may prevent you from being locked out by some
    defensive mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking form-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because there is no standard implementation, and web applications are much
    more flexible in terms of validation and attack prevention, login forms pose some
    special challenges when it comes to brute forcing them:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no standard name, position, or format in the username and password
    parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no standard negative or positive response to a login attempt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client-side and server-side validations may prevent certain types of attacks
    or repeated submission of requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication may be done in more than one step; that is, asking the username
    in one page and the password in the next page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately for penetration testers, most applications use the basic pattern
    of HTML form, sent through a `POST` request including the username and password
    as parameters and getting a redirect to the user's home page on successful login,
    and an error or redirection to the login page if failed. You will now examine
    two methods used to execute a dictionary attack on this kind of form. The same
    principle applies to almost all form-based authentication, with some modifications
    on how the responses are interpreted and the required parameters for submission.
  prefs: []
  type: TYPE_NORMAL
- en: Using Burp Suite Intruder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in a basic authentication attack, you first need to identify the request
    that performs the actual authentication and its parameters in order to attack
    the correct ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, on the left-hand side, you''ll see OWASP Bricks
    in the authentication form (in the Vulnerable Virtual system main menu, go to
    Bricks | Login pages | Login #3), and on the right-hand side, you can see the
    request via the `POST` method. You''ll observe that the `username` and `passwd`
    parameters are sent in the body, while there is no `Authorization` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To do a dictionary attack on this login page, you first need to analyze the
    response to identify what distinguishes a failed login from a successful one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the screenshot, you may observe that a failed response contains the `"Wrong
    user name or password."` text. For sure, this won't be in a successful login.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, send the request to Intruder, and select the `username` and `passwd`
    parameters as inputs. Then, select Cluster bomb as the attack type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, go to the Payloads tab, select the payload set `1`, and load the file
    containing the usernames that we used before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For payload set `2`, we will also use the passwords file used in the previous
    exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in this screenshot, `60` requests are made to the server, as
    you have 6 usernames and 10 possible passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can launch your attack at this point, then analyze the responses, and learn
    whether some login combination was successful. However, Burp Intruder has some
    features that can make your life easier, not only with simple examples like this,
    but when attacking complex real-world applications. Go to the Options tab and
    then to Grep - Match to make Intruder look for some specific text in the responses,
    so that you can easily identify the one that is successful. Click on the Flag
    result items with responses matching these expressions box, clear the current
    list, and enter the following in the Enter a new item box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Press *Enter* or click on Add. Intruder will mark all responses that contain
    this message; thus the ones that are not marked may represent a successful login.
    If you knew the correct login message, you look for that message and directly
    identify a correct set of credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Start the attack, and wait for the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It looks like you have found at least one valid username and its password.
  prefs: []
  type: TYPE_NORMAL
- en: Using THC Hydra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Among the many protocols that Hydra supports, there are `http-get-form`, `http-post-form`,
    `https-get-form`, and `https-post-form`, which are the HTTP and HTTPS login forms
    sent by the `GET` and `POST` method respectively. Using the same information from
    the previous exercise, you can run a dictionary attack with Hydra using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may notice that the syntax in this case is slightly different than your
    previous use of Hydra. Let''s check it out together:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you have the `hydra` command and the target host (`hydra 10.7.7.5`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then the protocol or service that you want to test (`http-form-post`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next comes the protocol-specific parameters in quotes (`""`) and separated
    with colons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: URL (`/owaspbricks/login-3/index.php`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The body of the request, indicated by `^USER^`, where Hydra should put the usernames
    and `^PASS^` for the place where the passwords should go
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The failed login message (`Wrong user name or password.`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Last comes the username and password lists indicated by `-L` and `-P`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The password reset functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common weak spot in web applications is the implementation of the password
    recovery and reset functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Since applications need to be user friendly, and some users forget their passwords,
    applications need to incorporate a way to allow these users to reset or recover
    their passwords. Coming up with a secure solution for this problem is not an easy
    task, and many developers may leave some weak link that a penetration tester or
    attacker can exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Recovery instead of reset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When facing the question of what to do when a user forgets their password,
    you can choose between two main options:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow them to recover the old password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow them to reset it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The fact that an application allows a user to recover their old password presumes
    some security flaws in the application''s design:'
  prefs: []
  type: TYPE_NORMAL
- en: Passwords are stored in a recoverable manner in the database instead of using
    a one-way hashing algorithm, which is the best practice for storing passwords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the server-side code, a customer service agent or the system administrator
    can recover the password. An attacker may also be able to do this through social
    engineering or technical exploitation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The password is put at risk when communicated back to the user, either by email,
    telephone, or by being displayed on a web page. There are many ways in which an
    intermediary or a bystander can capture such information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common password reset flaws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common method that applications employ to allow users to recover or reset
    their passwords is to ask one or more questions, where only the legitimate user
    should know the answer. This includes place of birth, first school, name of first
    pet, and mother's maiden name. The problems begin when the questions asked by
    the application are not that secret to a prospective attacker, and this problem
    increases if the user is a high-profile person, such as a celebrity or politician,
    when so many details of their lives are publicly available.
  prefs: []
  type: TYPE_NORMAL
- en: A second layer of protection is in not giving direct access to the password
    reset functionality, but sending an email or SMS with a password reset link. If
    this email or phone number is requested while trying to reset the password, chances
    are that you can spoof this information, replace the user's number by yours, and
    get any user's password reset.
  prefs: []
  type: TYPE_NORMAL
- en: If the email or phone number are correctly verified, and it's not possible to
    spoof them, there is still the chance that the reset link is not correctly implemented.
    Sometimes these links include a parameter indicating the ID, such as the number
    or name of the user whose password is going to be reset. In this case, all that
    you need to do is to generate a link using a user that you control and change
    that parameter to one of the user whose password you want to reset.
  prefs: []
  type: TYPE_NORMAL
- en: Another possible fail is that such a reset link is not invalidated after the
    first, legitimate use. In this case, if an attacker gains access to such a link,
    by any means, they can access it again and reset the user's password.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerabilities in 2FA implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common form of MFA in web applications is the use of a randomly generated
    number (four to eight digits) used as OTP that the user gets from a special device,
    a mobile app (such as Google Authenticator, Authy, 1Password, or LastPass Authenticator),
    or through an SMS or email sent by the server on request.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can detect and take advantage of some implementation flaws in this process
    during a penetration test when the following conditions exist:'
  prefs: []
  type: TYPE_NORMAL
- en: OTP numbers are not completely random and can be predicted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OTPs are not linked to the user to whom they are assigned. This means that you
    can generate an OTP for one user and use it with another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same password or token can be used multiple times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no limit for OTP submission attempts. This opens up the possibility
    of brute force attacks, which are more likely to be successful as OTPs are normally
    short strings of numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User information is not validated when sending the OTP by email or SMS, allowing
    an attacker to spoof the email address or phone number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expiration time of the OTP is too long for the purposes of the application.
    This expands the time window for an attacker to get a valid, unused token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Newly generated OTPs don't invalidate previous ones, so for example, if a user
    requests a token or password multiple times for the same operation because the
    network failed on the first attempt(s), an attacker may use the earlier attempt
    to replicate the operation or perform another one that accepts the same token,
    even after the legitimate operation was already executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliance on the device from where the application is accessed. Nowadays, people
    have banking applications, personal email, social networks, work email, and many
    other applications on their phones. Thus, you should think twice about using email,
    SMS, or mobile apps as a second factor of authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting and exploiting improper session management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated previously, session management allows the application to track user
    activity and validate authorization conditions without requiring the user to submit
    their credentials every time a request is made. This means that if session management
    is not properly done, a user may be able to access other users' information or
    execute actions beyond their privilege level, or an external attacker may gain
    access to a users' information and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Using Burp Sequencer to evaluate the quality of session IDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Burp Sequencer** is a statistical analysis tool that lets you collect a large
    amount of values, such as session IDs, and perform calculations on them to evaluate
    if they are being randomly generated, or maybe just obfuscated or encoded. This
    is useful when dealing with complex session cookies, as it gives you an idea of
    how the cookies are being generated and if there is some way of attacking or predicting
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Burp Sequencer, you first need to find the response that sets the session
    cookie. It''s usually the response to a successful login with a `Set-Cookie` header.
    In the following screenshot, you can see the response that sets a session cookie
    (`WEAKID`) for the WebGoat''s session hijacking exercise (go to WebGoat | Session
    Management Flaws | Hijack a Session):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At first sight, the value of the response may seem unique and difficult enough
    to guess. The first part looks like an ID, and the second part appears to be a
    timestamp, maybe the expiration time in nanoseconds. It should be very difficult
    to guess at which precise nanosecond a session is ending, right? Well, as you'll
    see, it's not the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find that response in the Burp Proxy''s history, and right-click on it. You''ll
    then see the Send to Sequencer option. Once in Sequencer, you need to choose which
    part of the response it is focused on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You have the option to analyze a cookie, a form field, or a custom portion
    of the response. In this case, select the `WEAKID` cookie and click on Start live
    capture. It will start making requests to the server to capture as many different
    cookie values as possible. When finished, click on Analyze now to execute the
    analysis. In the result, Sequencer will indicate if the analyzed value is random
    enough and a good choice as a session ID. As you can see, `WEAKID` is weak and
    easily predictable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Entropy** is a measure of the level of randomness in a piece of information.
    The result shows that `WEAKID` has zero randomness, which means that it''s totally
    predictable and not a good option as a session ID. Sequencer also provides more
    detailed information about the distribution and significance of each byte and
    bit in the strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you''ll see the character analysis chart. You
    can see that the characters in positions `3`, `4`, `15`, `16`, and `18` change
    much more than the characters in positions 0 or 5 to 13, which don''t seem to
    change at all. Also, characters 0 to 4 suggest a counter or an increasing number,
    as the last character changes more than the previous one, and that character more
    than the one previous to it, and so on. We will verify this in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Predicting session IDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have identified a session ID that seems to be predictable. Now let''s try
    to find a valid session. To do this, you''ll take the same request that receives
    the cookie and send it to Intruder. In this case, you just want to repeat the
    same request several times. However, Intruder needs to have insertion points for
    it to run, so add a header (`Test: 1`) to the request and set the insertion position
    in its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will send `101` requests in this test, so set the payload to be of the Numbers type,
    with a sequential increase from 0 to 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now go to the Options tab, and in the Grep-Extract section, add one item. Be
    sure that the Update config based on selection below checkbox is checked, and
    select only the cookie''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on OK and then on Start attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can see the `WEAKID` value in the Intruder''s result table, and you
    can verify that the first part of the cookie''s value is a sequential number and
    the second part is also always increasing. This depends on the time that the request
    was received by the server. If you look at the following screenshot, you can see
    that there are some gaps in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first half of a currently active session is `18299`. We know that because
    the server didn''t give us that value, and we know that it is increasing with
    each request. We also know that the second part is a timestamp and that it also
    depends on the time the session cookie was assigned. Thus, the second part of
    the value we seek must be in between the two values that we already know: `1509154565768`
    and `1509154566190`. As the difference between those two numbers is small (422),
    we can easily use Intruder to brute force the value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take the same original request and send it once again to Intruder. This
    time, add a cookie to it. After the value of `JSESSIONID`, add the following (remember
    to adjust the values to your results):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the last four characters, and add a position marker there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the Payloads tab, the attack will try the numbers from 5768 to 6190:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Last, add an expression to match so that you will clearly know when you have
    a successful result. At this point, you only know the message that an unauthenticated
    user should have. You would assume that an authenticated one (with a valid session
    cookie) won''t be requested to sign in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Start the attack, and wait until Intruder finds something:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You now have a valid session ID. To use it, all that you need to do is to replace
    the value of your session cookie with the one that you just found and visit the
    page to hijack someone else's session. I'll leave this for you to test.
  prefs: []
  type: TYPE_NORMAL
- en: Session Fixation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the user-provided information is used to generate the session ID,
    or worse, the user-provided information *becomes* the session ID. When this happens,
    an attacker can force a user to use a predefined identifier and then monitor the
    application for when this user starts a session. This is called **Session Fixation**.
  prefs: []
  type: TYPE_NORMAL
- en: WebGoat has a somewhat simplistic, yet very illustrative demonstration of this
    vulnerability (go to WebGoat | Session Management Flaws | Session Fixation). We
    will use it to illustrate how this attack can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step sets you up as the attacker. You need to craft an email to include
    a session ID (`SID`) value in the link that you are sending to the victim, so
    add that parameter with any value, for example, `&SID=123`, to the link to Goat
    Hills Financial:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An attacker has discovered that the Goat Hills Financial site uses a GET parameter
    to define session identifiers and is sending a phishing email to a client of that
    institution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this step of the exercise, you act as the victim, receiving the email from
    the attacker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As the email seems legitimate because it comes from `admin@webgoatfinancial.com`,
    you click on the link, which sends you to the login page and you log in accordingly.
    Now there is a valid session that uses the parameter that the attacker sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next stage requires the attacker to log in to the same site as the victim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You intercept the request with Burp Proxy and edit it to include the `SID`
    parameter the victim has used to log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You have now gained access to the victim''s profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two major flaws in how session IDs are managed in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, session IDs are generated by means of the user-provided information,
    which makes it easier for an attacker to identify valid values and relate them
    to existing users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, the identifier doesn't change once an authenticated session is started
    (for example, after the victim logs in) and here is the origin of the term, Session
    Fixation, as the attacker is able to preset the value that the session ID will
    have for the victim, making it possible to use that same value to hijack the victim's
    authenticated session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing authentication and session attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication in web applications is a difficult problem to solve, and no universal
    solution has been found to date. Because of this, preventing vulnerabilities in
    this area of applications is to a great extent case specific, and developers need
    to find a balance between usability and security according to the particular use
    cases and user profiles with which they are dealing.
  prefs: []
  type: TYPE_NORMAL
- en: We can say this even about session management, as current methods still represent
    workarounds of the deficiencies of the HTTP protocol. Probably with the advent
    of HTML5 and WebSockets or similar technologies, you will have some better alternatives
    to work with in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, it is possible to define some generic guidelines for both authentication
    and session management, which would help developers raise the security bar to
    attackers, and we can use these as a reference when looking for defects and making
    recommendations to clients.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of authentication guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Usernames or user identifiers must be unique for each user and be case insensitive
    (`user` is the same as `User`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enforce a strong password policy that prevents the use of the following as
    passwords:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Username as password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short (that is, less than eight characters) passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single case passwords, that is, all lowercase or all uppercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single character set, such as all numbers, all letters, and no use of special
    characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number sequences (123456, 9876543210)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Celebrities, TV shows, movies, or fictional characters (Superman, Batman, Star
    Wars)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords in public dictionaries, such as the top-25 most common passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use secure protocols, such as TLS, to submit login information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not disclose information about the existence or validity of a username in
    error messages or response codes (for example, do not respond with a 404 code
    when a user is not found).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To prevent brute-force attacks, implement a temporary lockout after a certain
    number of failed attempts: five is a well-balanced number, so that a user who
    fails to log in five consecutive times is locked out for a certain amount of time,
    say twenty or thirty minutes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the password reset feature is implemented, ask for the username or email
    and the security question, if available. Then, send a one-time reset link to the
    user's registered email or to their mobile phone through SMS. This link must be
    disabled after the user resets their password or after a certain amount of time,
    perhaps a couple of hours, if that doesn't happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When implementing MFA, favor the use of third-party and widely tested frameworks,
    such as Google Authenticator or Authy, if using mobile applications or RSA, or
    Gemalto devices, if a physical token or smartcard is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid implementing custom or home-made cryptography and random generation modules,
    and favor standard algorithms from well-known libraries and frameworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask for re-authentication on sensitive tasks, such as privilege changes on users,
    sensitive data deletion, or modification of global configuration changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OWASP has a quick guide on best practices for implementing authentication on
    web applications at [https://www.owasp.org/index.php/Authentication_Cheat_Sheet](https://www.owasp.org/index.php/Authentication_Cheat_Sheet).
  prefs: []
  type: TYPE_NORMAL
- en: Session management guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of session management guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: No matter the authentication mechanism used, always implement session management
    and validate the session on every page and/or request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use long, random, and unique session identifiers. Favor the mechanisms already
    implemented in major web development languages such as ASP.NET, PHP, and J2EE.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate new session IDs for users on log in and log out. Permanently invalidate
    the used ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalidate sessions and log users out after a reasonable time of inactivity—15
    to 20 minutes. Provide a good balance between security and usability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always give a user the explicit option to log out; that is, having a log out
    button/option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using session cookies, make sure that all security flags are set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Secure` attribute is used to prevent the use of the session cookie over
    non-encrypted communication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HttpOnly` attribute is used to prevent access to the cookie value through
    scripting languages. This reduces the impact in **Cross-Site Scripting** (**XSS**)
    attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use nonpersistent session cookies, without the `Expires` or `Max-Age` attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict the `Path` attribute to the server's root (`/`) or the specific directory
    where the application is hosted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SameSite` attribute is currently only supported by Chrome and Opera web
    browsers. This provides extra protection against information leakage and **Cross-Site
    Request Forgery** (**CSRF**), by preventing the cookie from being sent to the
    server by external sites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Link the session ID with the user's role and privileges, and use it to verify
    authorization on every request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More in-depth advice about this topic can be found in the *Session Management
    Cheat Sheet* of OWASP at [https://www.owasp.org/index.php/Session_Management_Cheat_Sheet](https://www.owasp.org/index.php/Session_Management_Cheat_Sheet).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed different ways in which web applications perform
    user authentication to restrict access to privileged resources or sensitive information
    and looked at how the session is maintained, given that HTTP doesn't have a built-in
    session management functionality. The most common approaches for doing this in
    today's web applications are form-based authentication and session IDs sent in
    cookies.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined the most common security failure points in authentication and
    session management, how attackers can exploit them using built-in browser tools,
    or through other tools included in Kali Linux, such as Burp Suite, OWASP ZAP,
    and THC Hydra.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we discussed some best practices that may prevent or mitigate
    authentication and session management flaws by requiring authentication for all
    privileged components of the application using complex, random session IDs and
    enforcing a strong password policy. These are some of the most important preventative
    and mitigation techniques for such flaws.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will cover the most common kinds of injection vulnerabilities,
    how to detect and exploit them in a penetration test and also the measures required
    to take in order to fix the applications and prevent attacks through these techniques
    from being successful.
  prefs: []
  type: TYPE_NORMAL

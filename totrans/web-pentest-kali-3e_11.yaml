- en: Using Automated Scanners on Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have learned about finding and exploiting vulnerabilities in web
    applications, mostly by manually testing one parameter or one request at a time.
    Although this is the best way to discover security flaws, especially flaws related
    to the flow of information within the application or those within the business
    logic and authorization controls, sometimes in professional penetration testing
    there are projects that due to time, scope, or volume cannot be fully addressed
    through manual testing, and which require the use of automated tools that help
    accelerate the process of finding vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the aspects that you need to consider when
    using automated vulnerability scanners on web applications. You will also get
    to know about the scanners and fuzzers included in Kali Linux and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations before using an automated scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Web application vulnerability scanners** operate a little differently than
    other types of scanners, such as OpenVAS or Nessus. The latter typically connects
    to a port on a host, obtain the type and version of the service running on such
    ports, and then check this information against their vulnerability database. On
    the contrary, a web application scanner identifies input parameters within the
    application''s pages and submits a multitude of requests probing different payloads
    on each parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: As a result of operating in this manner, an automated scan will almost certainly
    record information in the database, generate activity logs, alter existing information,
    and if the application has delete or restore functionality, it may even erase
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key considerations a penetration tester must take into
    account before including a web vulnerability scanner as a means for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the scope and project documentation to make sure that the use of automated
    tools is allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform the testing in an environment set up especially for that purpose (QA,
    development, or testing). Use the production environment only under an explicit
    request by the client and let them know that there is an inherent risk of damaging
    the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the tool's plugins and modules so that the results are up to date with
    the latest vulnerability disclosures and techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the scanning tool parameters and scope before launching the scan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the tools to the maximum level of logging. Logs will prove to be very
    useful in case of any incident as well as for verifying the findings and reporting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not leave the scanner unattended. You don't need to be staring at the progress
    bar, but you should constantly be checking how the scanner is doing and the status
    of the server being tested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not rely on a single tool—sometimes different tools will obtain different
    results for the same kind of test. When one misses some vulnerabilities, another
    may find it but miss something else. Thus, if you are using automated scanners
    in the scope of testing, use more than one and also consider the use of commercial
    products such as Burp Suite Professional or Acunetix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web application vulnerability scanners in Kali Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kali Linux includes multiple tools for automated vulnerability scanning of web
    applications. We have examined some of these already, particularly the ones focused
    on specific vulnerabilities such as sqlmap for SQL injection or XSSer for Cross-Site
    Scripting (XSS).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will cover the basic usage of some of the more general web vulnerability
    scanners listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Nikto
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skipfish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wapiti
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OWASP-ZAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nikto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A long-time classic, **Nikto** is perhaps the most widely used and well-known
    web vulnerability scanner in the world. Even though its scanning operation is
    not very deep and its findings are somewhat generic (they are, by and large, related
    to outdated software versions, the use of vulnerable components, or misconfigurations
    detected by analyzing the response headers), Nikto is still a very useful tool
    because of its extensive set of tests and due to its low likelihood of breaking
    things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nikto is a command-line tool. In the following screenshot, `nikto` is used
    with the parameters `-h` for the host or URL that we want to scan and `-o` to
    specify the output file. The extension of the file determines the format of the
    report. Other common formats are `.csv` (for comma separated file) and `.txt`
    (for text files):'
  prefs: []
  type: TYPE_NORMAL
- en: For more details and other options to use with `nikto`, run it with the `-H`
    option, for full help.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00275.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s see what the report from the previous scan looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00276.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Based on these two screenshots, you can see that Nikto identified the server
    version and some issues in the response header. In particular, an IP address disclosed
    the lack of some protection headers, such as `X-Frame-Options` and `X-XSS-Protection`,
    and that the session cookie does not include the `HttpOnly` flag. This means that
    it can be retrieved through script code.
  prefs: []
  type: TYPE_NORMAL
- en: Skipfish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Skipfish** is a very fast scanner that can help identify vulnerabilities
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML/XPath injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directory traversal and file inclusions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directory listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'According to its Google *Code* page ([http://code.google.com/p/skipfish/](http://code.google.com/p/skipfish/)):'
  prefs: []
  type: TYPE_NORMAL
- en: Skipfish is an active web application security reconnaissance tool. It prepares
    an interactive site map for the targeted site by carrying out a recursive crawl
    and dictionary-based probes. The resulting map is then annotated with the output
    from a number of active (but hopefully non-disruptive) security checks. The final
    report generated by the tool is meant to serve as a foundation for professional
    web application security assessments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of Skipfish is very straightforward. You just need to provide the URL
    to be scanned as a parameter. Optionally, you can add the output file and fine-tune
    the scan. To run Skipfish over the WackoPicko application in the test VM and generate
    an HTML report, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `-o` option indicates the directory where the report is to be stored. The
    `-I` option tells Skipfish only to scan URLs that include the string `WackoPicko`,
    excluding the rest of the applications in the VM. The last parameter is the URL
    where you want the scanning to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the command is launched, an information screen appears. You can press
    any key or wait for 60 seconds for the scan to start. Once the scan starts, the
    following status screen is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00277.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the scan finishes, a summary screen like the following is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00278.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, once the scan completes, the report will be ready in the specified folder.
    The following screenshot shows what a Skipfish report looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00279.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The report shows the vulnerabilities identified by Skipfish in the order of
    higher risk (red dots) to lower risk (orange dots). For example, Skipfish identified
    an SQL injection vulnerability in the login page, Query injection vector, rated
    as high risk by the scanner. It also identified a directory traversal or file
    inclusion and a possible XSS vulnerability rated as medium, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Wapiti
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Wapiti** is an actively-maintained, command-line tool based web vulnerability
    scanner. Wapiti version 3.0 was released in January 2018 ([http://wapiti.sourceforge.net/](http://wapiti.sourceforge.net/));
    however, Kali Linux still includes the previous version (2.3.0). According to
    the Wapiti website, this tool includes modules to detect the following vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: File disclosure (Local and remote include/require, `fopen`, `readfile`...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database Injection (PHP/JSP/ASP SQL injections and XPath injections)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XSS (Cross-Site Scripting) injection (reflected and permanent)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command Execution detection (`eval()`, `system()`, `passtru()`...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRLF Injection (HTTP Response Splitting, session fixation...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XXE (XML External Entity) injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of known potentially dangerous files (thanks to the Nikto database)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weak `.htaccess` configurations that can be bypassed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presence of backup files providing sensitive information (source code disclosure)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shellshock (aka Bash bug)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start Wapiti, you need to issue the `launch` command in the command line,
    followed by the URL to be scanned and the options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, Wapiti is run over the HTTPS site for BodgeIt
    on the vulnerable VM, generating the report in the `wapiti_output` directory (the `-o`
    option). You can skip the SSL certificate verification, as the test VM has a self-signed
    certificate. Wapiti would stop without scanning, so use `--verify-ssl 0` to bypass
    such a verification. You should not send more than 50 variants of the same request
    (the `-n` option). This is done to prevent loops. Finally, `2> null` is used to
    prevent the standard error output to overpopulate the screen, as multiple requests
    with non-expected values will be made by the scanner and Wapiti can be very verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then see the following output on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00280.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The scan will take some time. When it finishes, open the `index.html` file
    in the specified directory to see the results. The following is an example of
    how Wapiti reports vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00281.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Wapiti's report is very detailed, and it includes a description of each finding,
    the request used to trigger the potential vulnerability, proposed solutions, and
    references to get more information about these. In the preceding screenshot, you
    can see that it found XSS in BodgeIt's search page.
  prefs: []
  type: TYPE_NORMAL
- en: OWASP-ZAP scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among OWASP-ZAP's many features, there is an active vulnerability scanner. In
    this case, *active* means that the scanner actively sends crafted requests to
    the server, as opposed to a passive scanner, which only analyzes the requests
    and responses sent by the web server through the proxy while normally browsing
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the scanner, you need to right-click on the site or directory to be
    scanned and select Attack | Active Scan...:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00282.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The active scanner doesn't do any crawling or spidering on the selected target.
    Thus, it is advisable that you manually browse through the target site while having
    the proxy set up, or run the spider prior to scanning a directory or host.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Active Scan dialog box, you can select the target, whether you want
    the scan to be recursive, and if you enable the advanced options, you can choose
    the scanning policy, attack vectors, target technologies, and other options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00283.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click on Start Scan, the Active Scan tab will gain focus and the scanning
    progress and requests log will appear within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00284.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The scan results will be logged in the Alerts tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00285.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, using Report in the main menu, you can export the results to a number
    of formats such as HTML, XML, Markdown, or JSON. The following screenshot shows
    what an HTML report looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00286.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: OWASP-ZAP also sorts its scan results by risk level, and it includes a detailed
    description of the issues found, payloads used, recommendations for solutions,
    and references.
  prefs: []
  type: TYPE_NORMAL
- en: Burp Suite, in its professional version, also has an active scanner that gives
    very accurate results with a low rate of false positives.
  prefs: []
  type: TYPE_NORMAL
- en: Content Management Systems scanners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Content Management Systems** (**CMSs**), such as WordPress, Joomla, or Drupal
    are frameworks used to create websites with little or no programming required.
    They incorporate third-party plugins to ease tasks such as login and session management,
    searches, and even include full shopping cart modules.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, CMSs are vulnerable, not only within their own code, but also in
    the plugins they include. The latter are not subject to consistent quality controls,
    and they are generally made by independent programmers in their spare time, releasing
    updates and patches according to their own schedule.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we will now cover some of the most popular vulnerability scanners for
    CMSs.
  prefs: []
  type: TYPE_NORMAL
- en: WPScan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**WPScan**, as its name suggests, is a vulnerability scanner focused on the
    WordPress CMS. It will identify the version numbers of WordPress and those of
    the installed plugins and then match them against a database of known vulnerabilities
    in order to identify possible security risks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the basic use of WPScan, just adding the target
    URL as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00287.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On first run, you may be required to update the database using the `--update`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: JoomScan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JoomScan** is the vulnerability scanner for the Joomla sites included in
    Kali Linux. To use it, you only need to add the `-u` option followed by the site''s
    URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'JoomScan first tries to fingerprint the server by detecting the Joomla version
    and plugin, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00288.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, JoomScan will show the vulnerabilities related to the detected
    configuration or installed plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00289.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: CMSmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CMSmap** is not included in Kali Linux, but it can be easily installed from
    its Git repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'CMSmap scans for vulnerabilities in WordPress, Joomla, or Drupal sites. It
    has the ability to autodetect the CMS used by the site. It is a command-line tool,
    and you need to use the `-t` option to specify the target site. CMSmap displays
    the vulnerabilities it finds preceded by an indicator of the severity rating that
    it determines: `[I]` for informational, `[L]` for low, `[M]` for medium, and `[H]`
    for high, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00290.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `--noedb` option used in the screenshot prevents WordPress from looking
    for exploits for the identified vulnerabilities in the Exploit Database ([https://www.exploit-db.com/](https://www.exploit-db.com/)),
    as our Kali Linux VM is not connected to the internet. Trying to connect to an
    external server would result in errors and delays in obtaining the results.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fuzzing** is a testing mechanism that sends specially-crafted (or random,
    depending on the type of fuzzing) data to a software implementation through its
    regular inputs. The implementation may be a web application, thick client, or
    a process running on a server. It is a black-box testing technique that injects
    data in an automated fashion. Though fuzzing is mostly used for security testing,
    it can also be used for functional testing.'
  prefs: []
  type: TYPE_NORMAL
- en: One may think from the preceding definition that fuzzing is the same as any
    vulnerability scanning. And yes, fuzzing is part of the vulnerability scanning
    process that can also involve the fingerprinting and crawling of the web application
    and the analysis of the responses in order to determine if a vulnerability is
    present.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to take the fuzzing part out of the scanning process and
    execute it alone, so that it's on us and not the scanner to determine the test
    inputs and analyze the test results. This way, we can obtain a finer control on
    what test values in which parameters are sent to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Using the OWASP-ZAP fuzzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **OWASP-ZAP fuzzer** can be run from the site map, the proxy''s history,
    or the request panel by right-clicking on the request that you want to fuzz and
    selecting Attack | Fuzz..., as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00291.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After doing that, the fuzzing dialog appears where you can select the insert
    points; that is, the part of the request where you want to try different values
    in order to analyze server''s responses. In the following example, we are selecting
    the `q` parameter''s value in BodgeIt''s search from the OWASP BWA vulnerable
    virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00292.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that two lists of payloads have already been added. To do that, select
    the text that you want to fuzz, the value of `q` in this case, and click on Add...
    on the right-hand side (in the Fuzz Locations tab) for the Payloads dialog to
    appear. Then click on Add... in that dialog box. You'll take the first payload
    list from the file `/usr/share/wfuzz/wordlist/injections/SQL.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file contains fuzzing strings that will help identify SQL injection vulnerabilities.
    Select File in the payload type, click on Select..., and browse to the file to
    load it, as shown in the following screenshot. Then click on Add to add that list
    to the fuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00293.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, use the second payload to test for XSS. This time you will use File Fuzzers
    as the type. This is a collection of fuzzing strings that OWASP-ZAP includes out
    of the box. From these fuzzers, select some XSS lists from JbroFuzz | XSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00294.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Other options for fuzzing strings that can be used in OWASP-ZAP are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Empty/Null**: This option submits the original value (no change)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numberzz**: This option generates a sequence of numbers, allowing you to
    define the start value, end value, and increment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regex**: This option generates a defined number of strings that match the
    given regular expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Script**: This option lets you to use a script (loaded from Tools | Options...
    | Scripts) to generate the payloads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strings**: This option shows a simple list of strings, manually provided'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once all of the insertion points and their corresponding fuzzing inputs have
    been selected, you can launch the fuzzer by clicking on Start Fuzzer. The Fuzzer
    tab will then show up in the bottom panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next screenshot, you can see the fuzzing results. The State column shows
    a preliminary diagnosis made by the tool indicating how likely it is that such
    requests will lead to an exploitable vulnerability. Notice the word Reflected
    in the example. This means that the string sent by the fuzzer has been returned
    by the server as part of the response. We know that this is a string indicator
    of XSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00295.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To explore further the possibility of finding an exploitable vulnerability from
    the results shown in the Fuzzer tab, you can select any request and its header
    and body. The corresponding response will be shown in the associated sections
    in the central panel. The response will show the *suspicious* string highlighted.
    This way, you can tell at first glance if a vulnerability is present, and if that
    particular test case is worth digging into a little more. If that's the case,
    you can right-click on the request and select Open/Resend with Request Editor
    to launch the Request Editor and manipulate and resend the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option for further investigating a request that you think might lead
    to an exploitation is to replay the request in a browser so that you can see how
    it behaves and how the server responds. To do this, right-click on the request,
    select Open URL In Browser, and then select your preferred browser. This will
    open the browser and make it submit the selected request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00296.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Burp Intruder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have already used Intruder for various tasks in previous chapters, and you
    are aware of its power and flexibility. Now we will use it to fuzz the BodgeIt
    login page looking for SQL injection vulnerabilities. The first thing that you
    need to do is to send a valid login request from the proxy history to Intruder.
    This is accomplished by right-clicking on the request and selecting Send to Intruder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once in Intruder, you will clear all of the insertion points and add one in
    the username value, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00297.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to set the payloads. To do this, go to the Payloads tab, click
    on Load... to load a file, and go to `/usr/share/wfuzz/wordlist/injections/SQL.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00298.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, to make it easier to identify interesting requests, you will add some
    matching rules so that you can tell from the attack dialog when a request is causing
    errors or contains interesting words. Add the following terms to the Grep - Match
    section in Options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`error`: Adding this will be useful when you want to know when an input triggers
    errors, as basic SQL injections display error messages when altering the syntax
    of a query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQL`: In case the error message doesn''t contain the word `error`, you want
    to know when an input triggers a response that contains the word `SQL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`table`: Add when you expect to read an SQL detailed error message that contains
    table names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`select`: Add this in case there is an SQL sentence disclosed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding list of terms is in no way an optimum list for response matching.
    It is provided simply for demonstration purposes. In a real-life scenario, one
    would manually analyze the actual responses given by the application first and
    then choose the terms that match that context and the vulnerabilities being sought.
    The following screenshot shows what the example match list would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00299.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once all attack parameters have been configured, you are ready to start the
    attack. It doesn't take much time for `error` to start getting matches. You can
    see that `table` is matched by every response, so it was not a good choice. `SQL`
    and `select` get no matches, at least in the first responses. If you select one
    of the responses that have `error` checked, you will see that there is a message
    System error. at the top of the page, which seems to be triggered when the payload
    contains a single quote.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be an indicator of SQL injection, and it may worth digging into a
    little more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00300.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see how this request would behave if executed from a browser in every request
    or response in any Burp Suite component, you can right-click and select Request
    in browser. You get to choose if you want the original session (send the request''s
    session cookies) or current session (the session cookies the browser has at the
    moment):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00301.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you send a request from Burp Suite to the browser, you get a URL starting
    with `http://burp/repeat/` that you need to copy and paste into the browser that
    you want to replay the request on. Burp Suite doesn''t launch the browser like
    ZAP does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows how the request in the example appears in the
    browser. It definitely looks like the System error. message should not be there,
    and you should look deeper into that request and manually try variants in order
    to gain SQL injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Post-scanning actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sadly, it is more common than it should be that companies that offer penetration
    testing services end up doing only a vulnerability scan and customizing and adapting
    their reports without a manual testing phase, and without validating that the
    alleged vulnerabilities found by the scanner are actual vulnerabilities. Not only
    does this fail to provide any value to the customers, who by themselves could
    download a vulnerability scanner and run it against their applications, but it
    also damages the perception that companies have about security services and security
    companies, making it harder for those who provide quality services to position
    those services in the marketplace at competitive prices.
  prefs: []
  type: TYPE_NORMAL
- en: After a scanner generates the scanning report, you cannot just take that report
    and say that you found *X* and *Y* vulnerabilities. As scanners always produce
    false positives (that is, report vulnerabilities that don't exist) and false negatives
    (such as vulnerabilities missed by the scanner), it is mandatory that you also
    conduct a manual test so that you can find and report vulnerabilities that were
    not covered by automated tools, such as authorization issues or business logic
    bypasses or abuses among others, so that you can verify that all findings reported
    by the scanner are actual vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the use of automated vulnerability scanners in
    web application penetration testing, the risks posed by the use of automated tools
    when testing production environments, and considerations that needed to be taken
    into account before using them.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we moved on to the use of some of the scanners included in Kali Linux,
    such as Nikto, Skipfish, Wapiti, and OWASP-ZAP. We also talked about specialized
    scanners for Content Management Systems such as WordPress, Joomla, and Drupal.
    We addressed the topic of fuzzing as a separate technique from scanning. We used
    the OWASP-ZAP fuzzer and Burp Intruder to test multiple inputs over a single input.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed some of the tasks necessary to be done after automated
    scanning or fuzzing is complete. You need to validate the scanner's results in
    order to eliminate all false positives, and you need to test the application manually,
    as there are vulnerabilities that an automated scanner will not be able to find.
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, we come to the end of the book. Penetration testing is a
    field of eternal students. Penetration testers need to keep up with the pace of
    technology, and though methodologies change, you shouldn't forget the old ways,
    as it is not unusual for today's organizations to have applications that use obsolete
    frameworks while cohabiting with top-notch technology.
  prefs: []
  type: TYPE_NORMAL
- en: This book provides a general overview of web penetration testing, its methodology,
    and techniques to help you identify, exploit, and remediate some of the most common
    vulnerabilities found in web applications. You will need to continue your journey
    by learning more from different sources, researching, practicing, and then practicing
    some more. Also, learning about other fields such as development, networking,
    and operating systems is advantageous, as it allows you to put the application
    in context with its environment and better assess the risks it genuinely poses.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the valuable applications mentioned in this book and other similar
    ones that are available, public bug bounty programs, such as HackerOne ([https://www.hackerone.com/](https://www.hackerone.com/))
    and BugCrowd ([https://www.bugcrowd.com/](https://www.bugcrowd.com/)), are an
    excellent way for the inexperienced tester to gain experience by testing real
    applications with the authorization of the owner and with the opportunity of getting
    paid for finding vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you, dear reader, have found this book interesting and useful for
    your purposes, whether it is to learn about web application security in order
    to improve your development process, to pursue a career on penetration testing
    or as a seasoned penetration tester, to improve your skills and expand your testing
    arsenal. Thank you for reading the book.
  prefs: []
  type: TYPE_NORMAL

- en: '*Chapter 4*: t Quick and QML'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt consists of two different modules for developing a **graphical user interface**
    (**GUI**) application. The first approach is to use Qt Widgets and C++, which
    we learned about in the previous chapter. The second approach is to use Qt Quick
    Controls and the **Qt Modeling Language** (**QML**), which we will be covering
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use Qt Quick Controls and the QML scripting
    language. You will study how to use Qt Quick Layouts and positioners and make
    a responsive GUI application. You will learn to integrate your backend C++ code
    with frontend QML. You will learn the fundamentals of Qt Quick and QML, and how
    to develop touch-friendly and visual-oriented Qt applications. You will also learn
    about mouse and touch events and how to develop a touch-aware application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with QML and Qt Quick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Qt Quick Controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple Qt Quick application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a **user interface** (**UI**) with Qt Quick Designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioners and layouts in QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating QML with C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating QML with **JavaScript** (**JS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling mouse and touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the basics of QML, integration
    with C++, and how to create your own fluid UI.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements for this chapter include minimum versions of Qt 6.0.0
    and Qt Creator 4.14.0 installed on the latest desktop platforms such as Windows
    10, Ubuntu 20.04, or macOS 10.14.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter04](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The screenshots used in this chapter are taken from the Windows platform. You
    will see similar screens based on the underlying platforms in your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with QML and Qt Quick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QML is a UI markup language. It is a declarative language that is part of the
    Qt framework. It enables the building of fluid and touch-friendly UIs and came
    into existence with the evolution of touchscreen mobile devices. It was created
    to be highly dynamic, where developers can easily create fluid UIs with minimal
    coding. The Qt QML module implements the QML architecture and provides a framework
    for developing applications. It defines and implements the language and infrastructure,
    and provides **application programming interfaces** (**APIs**) to integrate the
    QML language with JS and C++.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick provides a library of types and functionality for QML. It comprises
    interactive types, visual types, animations, models, views, and graphics effects.
    It is used for mobile applications where touch input, fluid animations, and user
    experience are crucial. The Qt QML module provides the language and infrastructure
    for QML applications, whereas the Qt Quick module provides many visual elements,
    animation, and many more modules to develop touch-oriented and visually appealing
    applications. Instead of using Qt Widgets for UI design, you can use QML and Qt
    Quick Controls. Qt Quick supports several platforms, such as Windows, Linux, Mac,
    iOS, and Android. You can create a custom class in C++ and port it over to Qt
    Quick to extend its functionality. Furthermore, the language provides a smooth
    integration with C++ and JS.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the QML type system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get familiar with the **QML type system** and various QML types. The
    types in a QML file can originate from various sources. The different types used
    in a QML file are outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic types provided natively by QML such as `int`, `bool`, `real`, and `list`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JS types such as `var`, `Date`, and `Array`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QML object types such as `Item`, `Rectangle`, `Image`, and `Component`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types registered via C++ by QML modules such as `BackendLogic`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types provided as a QML file, such as `MyPushButton`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic type can contain a simple value such as an `int` or a `bool` type. In
    addition to the native basic types, the Qt Quick module also provides additional
    basic types. The QML engine also supports JS objects and arrays. Any standard
    JS type can be created and stored using the generic `var` type. Please note that
    the `variant` type is obsolete and exists only to support older applications.
    A QML object type is a type from which a QML object can be created. Custom QML
    object types can be defined by creating a `.qml` file that defines the type. QML
    object types can have properties, methods, signals, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the basic QML types inside your QML file, import the `QtQml` module
    with the following line of code: `import QtQml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Item` is the base type for all visual elements in Qt Quick. All visual items
    in Qt Quick are inherited from `Item`, which is a transparent visual element that
    can be used as a container. Qt Quick provides `Rectangle` as a visual type to
    draw rectangles, and an `Image` type to display images. `Item` provides a common
    set of properties for the visual elements. We will explore the usage of these
    types throughout the book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about QML types at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/qmltypes.html](https://doc.qt.io/qt-6/qmltypes.html)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned the basics of QML and Qt Quick. In the next section,
    we will discuss Qt Quick Controls.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Qt Quick Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Qt Quick Controls** provides a set of UI elements that can be used to build
    a fluid UI using Qt Quick. To avoid ambiguity with **widgets**, we will use the
    term **controls** for UI elements. **Qt Quick Controls 1** was originally designed
    to support desktop platforms. With the evolution of mobile devices and embedded
    systems, the module required changes to meet performance expectations. Hence,
    **Qt Quick Controls 2** was born, and it further enhanced support for mobile platforms.
    Qt Quick Controls 1 has been deprecated since Qt 5.11 and has been removed from
    Qt 6.0\. Qt Quick Controls 2 is now simply known as Qt Quick Controls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The QML types can be imported into your application using the following `import`
    statement in your `.qml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import QtQuick.Controls`'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In Qt 6, there are certain changes in the QML import and versioning system.
    The version numbers have been kept optional. If you import a module without specifying
    the version number, then the latest version of the module is imported automatically.
    If you import a module with only the major version number, then the module is
    imported with a specified major version and the latest minor version. Qt 6 introduced
    an `import <module> auto`. This ensures the imported module and importing module
    have the same version number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changes to Qt Quick Controls in Qt 6 can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/qtquickcontrols-changes-qt6.html](https://doc.qt.io/qt-6/qtquickcontrols-changes-qt6.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt Quick Controls offers QML types for creating UIs. Example of Qt Quick Controls
    are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ApplicationWindow`: Styled top-level window with support for a header and
    footer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BusyIndicator`: Indicates background activity—for instance, while content
    is being loaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button`: Push button that can be clicked to perform a command or answer a
    question'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CheckBox`: Check button that can be toggled on or off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComboBox`: Combined button and pop-up list for selecting options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dial`: Circular dial that is rotated to set a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dialog`: Pop-up dialog with standard buttons and a title'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Label`: Styled text label with inherited font'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Popup`: Base type of pop-up-like UI controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProgressBar`: Indicates the progress of an operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RadioButton`: Exclusive radio button that can be toggled on or off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScrollBar`: Vertical or horizontal interactive scroll bar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScrollView`: Scrollable view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slider`: Used to select a value by sliding a handle along a track'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpinBox`: Allows the user to select from a set of preset values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Switch`: Button that can be toggled on or off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextArea`: Multiline text-input area'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextField`: Single-line text input field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToolTip`: Provides tool tips for any control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tumbler`: Spinnable wheel of items that can be selected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To configure the Qt Quick Controls module for building with qmake, add the
    following line to the project''s `.pro` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QT += quickcontrols2`'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the different types of UI elements available
    with Qt Quick. In the next section, we will discuss the different styles provided
    by Qt Quick and how to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: Styling Qt Quick Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Qt Quick Controls comes with a standard set of styles. They are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fusion**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Imagine**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Material**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Universal**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two ways to apply styles in Qt Quick Controls, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can apply a compile-time style by importing the corresponding style module,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import QtQuick.Controls.Universal`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply a runtime style by using one of the following approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Different ways to apply a style at runtime'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Different ways to apply a style at runtime
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the available styles in Qt Quick. In the next
    section, we will create our first Qt Quick GUI application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple Qt Quick application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our first Qt Quick application using Qt 6\. A Hello World program
    is a very simple program that displays `Hello World!`. The project uses minimal—and
    the most basic—code. For this project, we will use the **project skeleton** created
    by Qt Creator. So, let''s begin! Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a new Qt Quick application, click on the **File menu** option on the
    menu bar or hit *Ctrl* + *N*. Alternatively, you can also click on the **New Project**
    button located on the welcome screen. Then, a window will pop up for you to choose
    a project template. Select **Qt Quick Application - Empty** and click the **Choose...**
    button, as shown in the following screenshot:![Figure 4.2 – New Qt Quick application
    wizard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.2_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – New Qt Quick application wizard
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, you will be asked to choose a project name and a project location.
    You can navigate to the desired project location by clicking the `SimpleQtQuickApp`.
    Then, click on the **Next** button to proceed to the next screen, as shown in
    the following screenshot:![Figure 4.3 – Project location selection screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.3_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Project location selection screen
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, you can select a kit from a set of kits to build and run your
    project. To build and run a project, at least one kit must be active and selectable.
    Select the default **Desktop Qt 6.0.0 MinGW 64-bit**kit. Click on the **Next**
    button to proceed to the next screen. This can be seen in the following screenshot:![Figure
    4.4 – Kit selection screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Kit selection screen
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to add your Qt Quick project to the installed **version control
    system** (**VCS**). You may skip version control for this project. Click on the
    **Finish** button to create a project with the generated files, as shown in the
    following screenshot:![Figure 4.5 – Project management screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.5_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Project management screen
  prefs: []
  type: TYPE_NORMAL
- en: Once a project has been created, Qt Creator will automatically open up a file
    from your project, called `main.qml`. You will see a type of script that is very
    different from your usual C/C++ projects, as shown in the following screenshot:![Figure
    4.6 – Code editor screen showing the main.qml file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.6_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `QQuickView` class, which provides a window for displaying
    a Qt Quick UI. This approach is little old. `QQmlApplicationEngine` has a convenient
    central application functionality with QML, whereas `QQuickView` is normally controlled
    from C++. The following code snippet shows how to use `QQuickView` to load a `.qml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`QQuickView` doesn''t support using `Window` as a root item. If you want to
    create your root window from QML, then opt for `QQmlApplicationEngine`. While
    using `QQuickView`, you can directly use any Qt Quick element, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, you can build and run the Qt Quick project by clicking on the green arrow
    button located at the bottom-left corner of the **integrated development environment**
    (**IDE**), as shown in the following screenshot:![Figure 4.7 – The build and run
    option in Qt Creator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.7_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – The build and run option in Qt Creator
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, hit the **Run** button to build and run the application. Soon, you will
    see a UI with **Hello World!**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Output of the Hello World UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.8_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Output of the Hello World UI
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the application from the command line on Windows, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run the application from the command line on Linux distributions,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In command-line mode, you may see a few error dialogs if the libraries are
    not found in the application path. You can copy the Qt libraries and plugin files
    to that binary folder to resolve the issue. To avoid these issues, we will stick
    to Qt Creator to build and run our sample programs. You can switch between different
    kits by going to the project interface and selecting a kit based on your preferences.
    Please remember that you need to run `qmake` after you make changes to your `.pro`
    file. If you are using the command line, then proceed with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create a Qt Quick 2 UI project with a QML entry point without
    using any C++ code. To use it, you need to have a QML runtime environment such
    as `qmlscene` set up. Qt Creator uses `.qmlproject` to handle QML-only projects:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a Qt Quick 2 UI project, select **Qt Quick 2 UI Prototype** from the
    new project template screen, as shown in the following screenshot:![Figure 4.9
    – Qt Quick UI Prototype wizard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.9_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Qt Quick UI Prototype wizard
  prefs: []
  type: TYPE_NORMAL
- en: Continue clicking the `QtQuickUIPrototype.qmlproject` and `QtQuickUIPrototype.qml`
    Qt Creator-generated files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's modify the contents of `QtQuickUIPrototype.qml` to add a `Text` element
    and display `Hello World!`, as illustrated in the following screenshot:![Figure
    4.10 – Sample contents of Qt Quick UI Prototype project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.10_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – Sample contents of Qt Quick UI Prototype project
  prefs: []
  type: TYPE_NORMAL
- en: Now, hit the **Run** button to build and run the application. Soon, you will
    see a UI with **Hello World!**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also run the application from the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You may have to mention `qmlscene` and the `qml` file path in the command line.
    Use this only if you are prototyping. You cannot create a full application with
    this. Consider using a Qt Quick application project instead for a full application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create a simple GUI using the Qt Quick module.
    In the next section, we will learn how to design a custom UI using the Qt Quick
    Designer UI.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a UI with Qt Quick Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to use Qt Quick Designer to design your
    UI. Similar to the `.ui` file in Qt Widgets, you can also create a UI file in
    QML. The file has a `.ui.qml` file extension. There are two types of QML file:
    one with a `.qml` extension and another with a `.ui.qml` extension. The QML engine
    treats it as a standard `.qml` file, but it prohibits the logical implementation
    inside it. It creates a reusable UI definition for multiple `.qml` files. Through
    the separation of UI definition and logical implementation, it enhances the maintainability
    of QML code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get familiar with Qt Quick Designer''s interface before we start learning
    how to design our own UI. The following screenshot shows different sections of
    Qt Quick Designer. We will gradually learn about these sections while designing
    our UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Sections of Qt Quick Designer''s UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.11_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Sections of Qt Quick Designer's UI
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt Quick Designer''s UI consists of the following major sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Navigator**: This lists the items in the current QML file as a tree structure.
    It''s similar to the **Object Operator** window in Qt Designer that we learned
    about in the last chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control Library**: This window shows all the Qt Quick controls available
    in QML. You can drag and drop the controls to the canvas window to modify your
    UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resources**: This displays all the resources in a list that can then be used
    for the UI design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Import Browser**: The **Import Browser** facilitates the importing of different
    QML modules into the current QML file, to add new functionality to your QML project.
    You can also create your own custom QML module and import in from here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text Editor**: This has six tool buttons, each for a specific action, such
    as copy and paste.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property Editor**: This is similar to the property editor of Qt Designer.
    The **Properties** section in Qt Quick Designer displays the properties of the
    selected item. You can also change the properties of the items in the **Text Editor**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Form Editor**: The **Form Editor** is a canvas where you design a UI for
    your Qt Quick application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State Editor**: This window lists the different states in a QML project,
    and describes UI definitions and their behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection Editor**: This section is similar to the **Signal/Slot Editor**
    in Qt Designer. Here, you can define the signals and slots mechanism for your
    QML component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You are now familiar with the Qt Quick Designer UI. Let''s create a Qt Quick
    UI file and explore the Qt Quick controls, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a Qt Quick UI, select `ui.qml` file extension. By default, Qt Creator
    will open up Qt Quick Designer. You can switch to code-editing mode by clicking
    the **Edit** button on the left-side panel:![Figure 4.12 – QtQuick UI File wizard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.12_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – QtQuick UI File wizard
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a few QML elements to the `Item`, `Rectangle`, `Image`, `Text`, and
    so on. `Item` is a transparent UI element that can be used as a container:![Figure
    4.13 – Qt Quick Designer showing basic QML types
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.13_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Qt Quick Designer showing basic QML types
  prefs: []
  type: TYPE_NORMAL
- en: By default, the library contains only a few basic QML types. You can import
    Qt Quick modules to Qt Quick Designer through the QML `QtQuick.Controls` packages,
    as shown in the next screenshot:![Figure 4.14 – Qt Quick Designer showing the
    QML module import option
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.14_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – Qt Quick Designer showing the QML module import option
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the module is imported, you can see a section with **Qt Quick - Controls
    2** in the library, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Qt Quick Designer showing Qt Quick Controls'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.15_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – Qt Quick Designer showing Qt Quick Controls
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we got familiar with Qt Quick Designer's interfaces. In the
    next section, you will learn about different positioners and layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Positioners and layouts in QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways to position items in QML. You can manually position
    a control by mentioning *x* and *y* coordinates or by using anchors, positioners,
    or layouts. Let's discuss how to position a control through the aforementioned
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Manual positioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A control can be positioned at specific *x* and *y* coordinates by setting their
    corresponding *x* and *y* properties. As per the visual coordinate system rules,
    this will position the controls relative to the top-left corner of their parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to place a `Rectangle` item at position
    (`50,50`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When you run the preceding code, you will see a blue rectangle created at the
    (`50,50`) position. Change the `x` and `y` values and you will see how the position
    is changed relative to the top-left corner. Qt allows you to write multiple properties
    in a single line separated by a semicolon. You can write `x` and `y` positions
    in the same line, separated by a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to position a visual item by specifying its
    coordinates. In the next section, we will discuss the use of anchors.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning with anchors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Qt Quick provides a way to anchor a control to another control. There are seven
    invisible anchor lines for each item: `left`, `right`, `top`, `bottom`, `baseline`,
    `horizontalCenter`, and `verticalCenter`. You can set margins or different margins
    for each side. If there are multiple anchors for a specific item, they can then
    be grouped.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this example, you will see a red rectangle inside a blue rectangle
    with different margins in the output window, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Anchor positioning a control inside a window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.16_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – Anchor positioning a control inside a window
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to position a visual item by using anchors.
    In the next section, we will discuss the use of positioners.
  prefs: []
  type: TYPE_NORMAL
- en: Positioners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Positioners** are containers that manage the positions of visual elements
    in a declarative UI. Positioners behave in a similar way to layout managers in
    **Qt widgets**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A standard set of positioners is provided in a basic set of Qt Quick elements.
    They are outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Column** positions its children in a column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Row** positions its children in a row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grid** positions its children in a grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flow** positions its children like words on a page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look how to use them in Qt Quick Designer. First, create three
    **Rectangle** items with different colors and then position them inside a **Row**
    element, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Rectangles inside a Row positioner'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.17_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – Rectangles inside a Row positioner
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also write code to position the controls inside a positioner. Qt Creator
    automatically generates code if you use Qt Quick Designer. The generated code
    can be viewed and modified through the **Text Editor** tab next to **Form Editor**.
    The code is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned about different positioners. In the next section,
    we will discuss the use of repeaters and models, along with positioners.
  prefs: []
  type: TYPE_NORMAL
- en: Repeater
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **repeater** creates a number of visual elements using a provided model, as
    well as elements from a template to use with a positioner, and uses data from
    a model. A repeater is placed inside a positioner, and creates visual elements
    that follow the defined positioner arrangement. When there are many similar items,
    then a positioner with a repeater makes it easier to maintain when arranged in
    a regular layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create five rectangles positioned in a row using `Repeater`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding example, you will see five rectangles arranged in
    a row, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Rectangles inside a Row positioner'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.18_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18 – Rectangles inside a Row positioner
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the use of repeaters with positioners. In
    the next section, we will look into Qt Quick Layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick Layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt Quick Layouts are a set of QML types that can be used to arrange visual elements
    in a UI. Qt Quick Layouts can resize their children, hence they are used for resizable
    UIs. The basic difference between positioners and layouts is that layouts can
    resize their children on window resize.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt Quick Layouts can be imported into your QML file by using the following
    `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import QtQuick.Layouts`'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five different type of layouts in QML, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RowLayout`: This arranges elements in a row. It is similar to `GridLayout`
    but only has one row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColumnLayout`: This arranges elements in a column. It is similar to `GridLayout`
    but only has one column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridLayout`: This allows elements to be arranged dynamically in a grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Layout`: This provides attached properties for items pushed onto a `ColumnLayout`,
    `RowLayout`, or `GridLayout` layout type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackLayout`: This arranges elements in a stack-like manner where only one
    element is visible at a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following `RowLayout` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Please note that a `Row` type is a positioner, while a `RowLayout` type is a
    layout. When to use them depends mainly on your goal, as usual. Let's move on
    to the next section to see how to integrate QML with C++.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating QML with C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QML applications often need to handle more advanced and performance-intensive
    tasks in C++. The most common and quickest way to do this is to expose the C++
    class to the QML runtime, provided the C++ implementation is derived from `QObject`.
  prefs: []
  type: TYPE_NORMAL
- en: QML can be easily integrated with C++ code. QML objects can be loaded and manipulated
    from C++. QML integration with Qt's meta-object system allows C++ functionality
    to be invoked from QML. This helps in building hybrid applications with a mixture
    of C++, QML, and JS. To expose C++ data or properties or methods to QML, it should
    be derived from a `QObject` class. This is possible because all QML object types
    are implemented using `QObject`-derived classes, allowing the QML engine to load
    and inspect objects through the Qt meta-object system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can integrate QML with C++ in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding C++ objects into QML with context properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering the type with the QML engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a QML extension plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss each approach one by one in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly determine which integration method is appropriate for your project,
    have a look at the flowchart illustrated in the Qt documentation at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/qtqml-cppintegration-overview.html](https://doc.qt.io/qt-6/qtqml-cppintegration-overview.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding C++ objects into QML with context properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can expose C++ objects into a QML environment by using context properties.
    Context properties are suitable for simple applications. They export your object
    as a global object. Contexts are exposed to the QML environment after being instantiated
    by the QML engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following example, where we have exported `radius`
    to the QML environment. You can also export C++ models in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the exported value directly in the QML file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can also register your C++ class and instantiate it inside the QML environment.
    Let's learn how to achieve that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a C++ class with the QML engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Registering QML types permits a developer to control the life cycle of a C++
    object from the QML environment. This can't be achieved with context properties
    and also doesn't populate the global namespace. Still, all types need to be registered
    first and by this, all libraries need to be linked on application start, which
    in most cases is not really a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods can be public slots or public methods flagged with `Q_INVOKABLE`.
    Now, let''s import the C++ class into the QML file. Have a look at the following
    C++ class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to register the C++ class in the `main.cpp` file as a module using
    `qmlRegisterType()`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Any `Qobject`-derived C++ class can be registered as a QML object type. Once
    a class is registered with the QML type system, the class can be used like any
    other QML type. Now, the C++ class is ready to be instantiated inside your `.qml`
    file. You have to import the module and create an object, as illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When you run the preceding program, you can see that the program is fetching
    data from the backend C++ class and displaying it in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also expose a C++ class as a QML singleton by using `qmlRegisterSingletonType()`.
    By using a QML singleton, you can prevent duplicate objects in the global namespace.
    Let''s skip this part as it requires an understanding of design patterns. Detailed
    documentation can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/qqmlengine.html#qmlRegisterSingletonType](https://doc.qt.io/qt-6/qqmlengine.html#qmlRegisterSingletonType%20)'
  prefs: []
  type: TYPE_NORMAL
- en: In Qt 6, you can achieve C++ integration by using a `QML_ELEMENT` macro. This
    macro declares the enclosing type as available in QML, using its class or namespace
    name as the QML element name. To use this macro in your C++ header file, you will
    have to include the `qml.h` header file as `#include <QtQml>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `.pro` file, you have to add the `qmltypes` option to the `CONFIG` variable
    and `QML_IMPORT_NAME` and `QML_IMPORT_MAJOR_VERSION` are to be mentioned, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Your C++ class is now ready to be instantiated inside your `.qml` file. You
    have to import the module and create an object, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you learned how to export your C++ class into the QML environment
    and access its functions from QML. In this example, the data is retrieved only
    when the method is called. You can also get notified when the data is changed
    inside C++ by adding a `Q_PROPERTY()` macro with a `NOTIFY` signal. You need to
    know about the signals and slots mechanism before using it. So, we will skip this
    part and discuss it further in [*Chapter 6*](B16231_06_Final_ASB_ePub.xhtml#_idTextAnchor123),
    *Signals and Slots*. In the next section, we will discuss how to create a QML
    extension plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a QML extension plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A QML extension plugin provides the most flexible way to integrate with C++.
    It allows you to register types in a plugin that is loaded when the first QML
    file calls the import identifier. You can use plugins across projects, which is
    very convenient when building complex projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt Creator has a wizard to create a `QqmlExtensionPlugin` and should implement
    the `registerTypes()` function. A `Q_PLUGIN_METADATA` macro is required to identify
    the plugin as a QML extension plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Qt Quick 2 QML Extension Plugin wizard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.19_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19 – Qt Quick 2 QML Extension Plugin wizard
  prefs: []
  type: TYPE_NORMAL
- en: 'This section is an advanced Qt topic. You need to understand Qt in depth to
    create your own QML extension plugin. You can skip this section if you are a beginner,
    but you can learn more about the QML extension plugin in the Qt documentation
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/qtqml-modules-cppplugins.html](https://doc.qt.io/qt-6/qtqml-modules-cppplugins.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next section to discover how to invoke a QML method inside
    a C++ class.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking QML methods inside a C++ class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All QML methods are exposed to the meta-object system and can be called from
    C++ using `QMetaObject::invokeMethod()`. You can specify types for the parameters
    and the return value after the colon character, as shown in the next code snippet.
    This can be useful when you want to connect a signal in C++ with a certain signature
    to a QML-defined method, for example. If you omit the types, the C++ signature
    will use `QVariant`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an application that calls a QML method using `QMetaObject::invokeMethod()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the QML file, let''s add a method called `qmlMethod()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main.cpp` file, call `QMetaObject::invokeMethod()` as per the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that the parameter and return type have to be specified. Both basic
    types and object types are allowed as type names. If the type is not mentioned
    in the QML type system, then you must declare `QVariant` as a type with `Q_RETURN_ARG()`
    and `Q_ARG()` when calling `QMetaObject::invokeMethod`. Alternatively, you can
    call `invokeMethod()` with only two parameters if you don''t need any return values,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QMetaObject::invokeMethod(myObject, "qmlMethod");`'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned to receive data from a QML method. In the next
    section, you will learn how to access a QML object pointer inside C++.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing a QML object pointer to C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you may want to modify the properties of a QML object through C++,
    such as modifying the text of a control, changing the visibility of a control,
    or changing a custom property. The QML engine permits you to register your QML
    objects to C++ types, which automatically exposes the QML object's properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following example, where we have exported a QML object
    to the C++ environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the QML file, you need to create an instance of the `C++` class and call
    the `C++` method. As you can see in the following code snippet, the property is
    manipulated inside the `C++` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The Qt QML module provides several macros for registering non-instantiable types.
    `QML_ANONYMOUS` registers a C++ type that is not instantiable and cannot be referred
    to from QML. `QML_INTERFACE` registers an existing Qt interface type. The type
    is not instantiable from QML, and you cannot declare QML properties with it. `QML_UNCREATABLE`
    registers a named C++ type that is not instantiable but should be identifiable
    as a type to the QML type system. `QML_SINGLETON` registers a singleton type that
    can be imported from QML.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have learned how to integrate QML and C++. In the next
    section, we will discuss how to use JS with QML.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating QML with JS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QML has a good integration with JS and uses **JavaScript Object Notation** (**JSON**)-**like
    syntaxes**, allowing expressions and methods to be defined as JS functions. It
    also permits developers to import JS files and use the existing functionality.
    The QML engine provides a JS environment that has some limitations compared to
    the JS environment provided by a web browser. The logic for a Qt Quick application
    can be defined in the JS. The JS code can be written inline inside the QML file,
    or in a separate JS file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use inline JS inside a QML document. The following example
    demonstrates the `btnClicked()` inline JS function. The method is called when
    the `Button` control is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows how to integrate JS code with QML. We have used
    the `btnClicked()` inline JS function. When you run the application, you will
    get a message saying **JS called!**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your logic is very long or has uses in multiple QML documents, then use
    a separate JS file. You can import a JS file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import "<JavaScriptFile>" as <Identifier>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could run the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import "constants.js" as Constants`'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we are importing `constants.js` into the QML environment.
    `Constants` is an identifier for our JS file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create a shared JS library. You just have to include the following
    line of code at the beginning of the JS file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.pragma library`'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If the script is a single expression, then writing it inline is recommended.
    If the script is a few lines long, then use a block. If the script is more than
    several lines long or is required by different objects, then create a function
    and call it as needed. For long scripts, create a JS file and import it inside
    the QML file. Avoid using `Qt.include()` as it is deprecated and will be removed
    from future versions of Qt.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about importing JS in QML, read the following documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/qtqml-javascript-imports.html](https://doc.qt.io/qt-6/qtqml-javascript-imports.html)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to integrate JS with QML. In the next section,
    we will discuss how to import a directory in QML.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a directory in QML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can import a local directory with QML files directly inside another QML
    file without adding in resources. You can use the directory's absolute or relative
    filesystem paths to do this, providing a convenient way for QML types to be arranged
    as reusable directories on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common form of a directory import is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import "<DirectoryPath>" [as <Qualifier>]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if your directory name is `customqmlelements`, then you can import
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import "../customqmlelements"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to import the directory as a qualified local namespace,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import "../customqmlelements" as CustomQMLElements`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also import a file from the resource path, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import "qrc:/qml/customqmlelements"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also import a directory of QML files from a remote server. There are
    two different types of `qmldir` files: a QML directory listing file and a QML
    module definition file. Here, we are discussing the use of the `qmldir` QML directory
    listing file. The directory can be imported using the `qmldir` file can be accessed.
    To avoid malicious code, you have to be careful with the network files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following documentation provides further information about the `qmldir`
    QML directory listing file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/qtqml-syntax-directoryimports.html](https://doc.qt.io/qt-6/qtqml-syntax-directoryimports.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the different types of `qmldir` files at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/qtqml-modules-qmldir.html](https://doc.qt.io/qt-6/qtqml-modules-qmldir.html)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to import a directory in QML. In the next section,
    we will discuss how to handle mouse and touch events in QML.
  prefs: []
  type: TYPE_NORMAL
- en: Handling mouse and touch events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QML provides excellent support for mouse and touch events through input handlers
    that let QML applications handle mouse and touch events. QML types such as `MouseArea`,
    `MultiPointTouchArea`, and `TapHandler` are used to detect mouse and touch events.
    We will have a look at these QML types in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: MouseArea
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`MouseArea` is an invisible item that is used with a visible item such as `Item`
    or `Rectangle` in order to provide mouse and touch handling events for that item.
    `MouseArea` receives mouse events within the defined area of `Item`. You can define
    this area by anchoring `MouseArea` to its parent''s area using the `anchors.fill`
    property. If you set the visible property to `false`, then the mouse area becomes
    transparent to mouse events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use `MouseArea` in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you can see that only the `rectangle` area received
    the mouse event. Other parts of window didn't get the mouse events. You can perform
    actions accordingly based on the mouse events. `MouseArea` also provides convenient
    signals that give us information about mouse events such as mouse hover, mouse
    press, press and hold, mouse exit, and mouse release events. Write the corresponding
    signal handlers and experiment with the `entered()`, `exited()`, `pressed()`,
    and `released()` signals. You can also detect which mouse button was pressed and
    execute a corresponding action.
  prefs: []
  type: TYPE_NORMAL
- en: MultiPointTouchArea
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MultiPointTouchArea` QML type enables handling of multiple touch points
    in a multi-touch screen. Just as with `MouseArea`, `MultiPointTouchArea` is an
    invisible item. You can track multiple touch points and process the gesture accordingly.
    When it is disabled, the touch area becomes transparent to both touch and mouse
    events. In a `MultiPointTouchArea` type, a mouse event is handled as a single
    touch point. You can set the `mouseEnabled` property to `false` to stop processing
    the mouse events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example, where we have two rectangles that follow
    our touch points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In a `MultiPointTouchArea` type, `TouchPoint` defines a touch point. It contains
    details about the touch point, such as the pressure, current position, and area.
    Now, run the application on your mobile device and verify it!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about the use of `MouseArea` and `MultiPointTouchArea`
    to handle mouse and touch events. Let's learn about `TapHandler` in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: TapHandler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TapHandler` is a handler for click events on a mouse and tap events on a touchscreen.
    You can use `TapHandler` to react to taps and touch gestures, and it allows you
    to handle events in multiple nested items simultaneously. Recognition of a valid
    tap gesture depends on `gesturePolicy`. The default value of `gesturePolicy` is
    `TapHandler.DragThreshold`, for which the event point must not move significantly.
    If `gesturePolicy` is set to `TapHandler.WithinBounds`, then `TapHandler` takes
    an exclusive grab on the press event, but releases the grab as soon as the event
    point leaves the boundary of the parent item. Similarly, if `gesturePolicy` is
    set to `TapHandler.ReleaseWithinBounds`, then `TapHandler` takes an exclusive
    grab on the press and retains it until release in order to detect this gesture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `TapHandler` type that recognizes different mouse button events
    and stylus taps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can use `MouseArea`. Input handlers make the formation of complex touch
    interactions simpler, which is difficult to achieve with either `MouseArea` or
    `TouchArea`.
  prefs: []
  type: TYPE_NORMAL
- en: Qt provides some ready-made controls to handle generic gestures such as pinch,
    flick, and swipe. `PinchArea` is a convenient QML type to handle simple pinch
    gestures. It is an invisible item that is used with another visible item. `Flickable`
    is another convenient QML type that provides a surface for a flick gesture. Explore
    the related documentation and examples to understand more about these QML elements.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at `SwipeView` in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: SwipeView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `SwipeView` to navigate pages by swiping sideways. It uses a swipe-based navigation
    model and provides a simplified way for horizontal-paged scrolling. You can add
    a page indicator at the bottom to display the current active page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we just have to add child items to `SwipeView`. You can set
    the `SwipeView` current index as the `PageIndicator` current index. `SwipeView`
    is one of the navigation models, which also include `StackView` and `Drawer`.
    You can explore these QML types to experience gestures on your mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about the use of various QML types to handle mouse,
    touch, and gesture events. Next, we will summarize what we learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained the fundamentals of the Qt Quick module and how to create
    a custom UI. You learned to design and build GUIs with Qt Quick Designer and learned
    about Qt Quick Controls, and how to build a custom Qt Quick application. You also
    learned how to integrate QML with C++ and JS. You should now understand the similarities
    and differences between Qt Widgets and Qt Quick and be able to choose the most
    suitable framework for your project. In this chapter, we have learned about Qt
    Quick and how to create an application using QML. You also learned how to integrate
    QML with JS and learned about mouse and touch events.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss cross-platform development using Qt Creator.
    You will learn to configure and build applications on Windows, Linux, Android,
    and macOS **operating systems** (**OSes**). We are going to learn how to port
    our Qt application to different platforms without too many challenges. Let's go!
  prefs: []
  type: TYPE_NORMAL

- en: '*Chapter 12*: Performance Considerations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will give you an overview of performance optimization techniques
    and how you can apply them in the context of Qt-based application development.
    Performance is a very important factor in the success of your application. Performance
    failures can result in business failures, poor customer relationships, a reduction
    in competitiveness, and revenue loss. Delaying performance optimization can have
    a huge cost in terms of your reputation and organizational image. Therefore, it
    is important to do performance tuning.
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn about performance bottlenecks and how to overcome them.
    We will discuss different profiling tools to diagnose performance problems, focusing
    specifically on some popular tools. Then, you will learn how to profile and benchmark
    performance. The chapter also introduces **Qt Modeling Language** (**QML**) Profiler
    and Flame Graph to find underlying bottlenecks in your Qt Quick application. You
    will also learn about some best practices that you should follow while developing
    your Qt application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding performance optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing C++ code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using concurrency, parallelism, and multithreading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling a Qt Quick application using QML Profiler and Flame Graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other Qt Creator analysis tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing graphical performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating benchmarks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different analysis tools and optimization strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance considerations for Qt Widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning best practices of QML coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have learned to write high-performance optimized
    code for both C++- and QML-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements for this chapter include minimum versions of Qt 6.0.0
    and Qt Creator 4.14.0 installed on the latest desktop platform such as Windows
    10, Ubuntu 20.04, or macOS 10.14.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter12/QMLPerformanceDemo](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter12/QMLPerformanceDemo).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The screenshots used in this chapter are taken on the Windows platform. You
    will see similar screens based on the underlying platforms in your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding performance optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance optimization is done to improve an application's performance. You
    may be wondering why this is necessary. There are many reasons why an application
    requires performance optimization. When there is a performance problem reported
    by your users or the **quality assurance** (**QA**) team, the developers may discover
    something affecting the overall application performance. This may occur due to
    underlying hardware limitations, poor implementation of code, or scalability challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization is part of the application development process. This can involve
    optimizing code for performance or optimization for memory usage. Optimization
    aims to optimize an application's behavior so that it satisfies the product requirements
    for speed, memory footprint, power usage, and so on. As a result, optimization
    is almost as crucial as coding functionality in the production phase. Customers
    may report performance problems as glitches, slow response, and missing functionalities.
    A faster application executes more efficiently while consuming fewer resources
    and can handle more tasks in the same amount of time as a slower application.
    In today's competitive world, faster software means a competitive advantage over
    rivals. Performance matters a lot on embedded and mobile platforms, with factors
    such as speed, memory, and power consumption being prevalent.
  prefs: []
  type: TYPE_NORMAL
- en: In a Waterfall process, performance improvement is carried out after application
    development, during the integration and verification phase. However, in today's
    Agile world, code performance should be evaluated every couple of sprints for
    overall application performance. Performance optimization is a continuous process,
    whereas defect fixing is a one-time task. It is an iterative process in which
    you will always find something to improve and there will be always scope for improvement
    in your application. According to the **Theory of Constraints** (**TOC**), there
    is typically one problem in a complex application that restricts the application
    from achieving its optimal performance. Such constraints are known as **bottlenecks**.
    An application's top performance is limited by bottlenecks, hence you should consider
    performance optimization during your application development life cycle. If ignored,
    your new product may become a complete disaster and may even ruin your reputation.
  prefs: []
  type: TYPE_NORMAL
- en: Before you jump into optimization, you should define a goal. Then, you should
    identify the bottleneck or the constraint. After that, think about how you can
    fix the constraint. You can improve your code and re-evaluate the performance.
    If it doesn't meet the set goal, you need to repeat the process. However, remember
    that premature optimization can be the root of all evil. You should implement
    the primary functionalities first before validating your product and implementing
    early users' feedback. Remember to make the application run first, then make its
    functionalities right, and then make it faster.
  prefs: []
  type: TYPE_NORMAL
- en: When you set a performance goal, you need to choose the right technique. There
    can be multiple goals, such as faster launch time, a smaller application binary,
    or less **random-access memory** (**RAM**) usage. One goal can impact another
    goal, so you have to find a balance based on the expected criteria—for example,
    optimizing the code for performance may impact memory optimization. There may
    be different ways to improve overall performance; however, you should also follow
    the organizational coding guidelines and best practices. If you are contributing
    to an open source project or are a freelance application developer, you should
    follow standard coding practices to maintain overall code quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important tricks we will be following for performance improvement
    are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using better algorithms and libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using optimal data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating memory responsibly and optimizing memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding unnecessary copying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing repeated computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using compiler binary optimization flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will discuss opportunities to improve overall
    application performance in our C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing C++ code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most Qt applications, a significant part of the coding is done in C++, hence
    you should be aware of C++ optimization tricks. This section is about implementing
    some of the best practices while writing C++ code. When C++ implementations are
    written without optimization, they run slowly and consume a lot of resources.
    Better optimization of your C++ code also offers better control over memory management
    and copying. There are many opportunities to improve algorithms, ranging from
    small logical blocks to using **Standard Template Libraries** (**STLs**), to writing
    better data structures and libraries. There are several excellent books and articles
    on this topic. We will be discussing a few important points for running code faster
    and using fewer resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important C++ optimization techniques are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Focus on algorithms, not on micro-optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't construct objects and copy unnecessarily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use C++11 features such as move constructor, lambdas, and the `constexpr` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose static linking and position-dependent code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer 64-bit code and 32-bit data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize array writes and prefer array indexing to pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer regular memory access patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce control flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid data dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use optimal algorithms and data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use precomputed tables to avoid repeated computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer buffering and batching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this book requires previous knowledge of C++, we expect that you will
    be aware of these best practices. As a C++ programmer, always stay updated with
    the latest C++ standards such as C++17 and C++20\. These will help you in writing
    efficient code with great features. We won't be discussing these in detail in
    this section, but will leave this for your self-exploration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about C++ core guidelines at the following link: [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about optimizing C++ code at the following link: [https://www.agner.org/optimize/](https://www.agner.org/optimize/).'
  prefs: []
  type: TYPE_NORMAL
- en: Go through the listed approaches to improve your C++ code. Next, we will discuss
    how to improve application performance with concurrency and multithreading in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using concurrency, parallelism, and multithreading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since you are already a C++ developer, you might be aware of these terms, which
    may be used interchangeably. However, there are differences in these terms. Let''s
    revisit these terms here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrency** is the execution of multiple programs at the same time (concurrent).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallelism** is the simultaneous running of a portion of your program in
    parallel, utilizing the multiple cores in a multi-core processor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multithreading** is the capability of a **central processing unit** (**CPU**)
    to run multiple threads for the same program, concurrently supported by the operating
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, you may launch multiple instances of a **Portable Document Format**
    (**PDF**) reader and Qt Creator. Qt Creator can run multiple tools by itself.
    Your system Task Manager can show you all the processes running simultaneously.
    This is known as concurrency. It is also commonly known as multitasking.
  prefs: []
  type: TYPE_NORMAL
- en: But if you use parallel computing techniques to process your data, then this
    is called parallelism. Complex applications with huge data processing requirements
    use this technique. Note that parallel computing on a single-core processor is
    an illusion.
  prefs: []
  type: TYPE_NORMAL
- en: A thread is the smallest executable unit of a process. There can be several
    threads in a process, but there is only one main thread. Multithreading is concurrency
    within the same process. Only one core is used by a conventional single-threaded
    application. A program with multiple threads can be distributed to multiple cores,
    allowing true concurrency. As a result, a multithreaded application provides better
    performance on multi-core hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss a few important classes in Qt that provide concurrency and multithreading,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QThread` is used to manage one thread of control within a program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QThreadPool` is used to manage and recycle individual `QThread` objects to
    help reduce thread creation costs in a multithreaded application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QRunnable` is an interface class for representing a task or piece of code
    that needs to be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtConcurrent` offers high-level **application programming interfaces** (**APIs**)
    that help in writing multithreaded programs without using low-level threading
    primitives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QFuture` permits threads to be synchronized against multiple computational
    results that will be available at a later point in time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QFutureWatcher` provides information and notifications about a `QFuture` object
    using signals and slots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QFutureSynchronizer` is a convenience class that simplifies the synchronization
    of one or more `QFuture` objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Threads are primarily used in two scenarios, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To make use of multi-core CPUs to speed up processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offload long-running processing or blocking calls to other threads to keep the
    **graphical user interface** (**GUI**) thread or other time-critical threads responsive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s briefly discuss the most basic concurrency concept known as a `QThread`
    class offers a thread abstraction in Qt with convenience methods. You can start
    a new custom thread by subclassing the `QThread` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can create a new instance of this class and invoke its `start()` function.
    This will create a new thread and then call the `run()` function in the context
    of this new thread. Another approach is to directly create a `QThread` object
    and invoke the `start()` function, which will start an event loop. In comparison
    to a conventional C++ thread class, `QThread` supports thread interruption, which
    isn't supported in C++11 and later. You may wonder why we can't just use the C++
    standard thread class. This is because you can use the signals and slots mechanism
    with `QThread` in a multithread-safe way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the multithreading mechanism in QML using `WorkerScript`.
    JavaScript code can execute in parallel with the GUI thread using the `WorkerScript`
    QML type. To enable the use of threads in a Qt Quick application, import the module
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'One JavaScript can be attached to each `WorkerScript` object. The script will
    run in a different thread and QML context when `WorkerScript.sendMessage()` is
    called. When the script is finished, it can send a response to the GUI thread,
    invoking the `WorkerScript.onMessage()` signal handler. You can exchange data
    between threads by using signals and signal handlers. Let''s have a look at a
    simple `WorkerScript` usage, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet uses a JavaScript file, `messaging.mjs`, which performs
    the operations in a new thread. Let''s look at the sample script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can send a message from the click of a button or based on some user action.
    It will invoke the `sendMessage(jsobject message)` method, where your complex
    messaging operations will take place. You can read more about different threading
    mechanisms and use cases at the following link: [https://doc.qt.io/qt-6/threads-technologies.html](https://doc.qt.io/qt-6/threads-technologies.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this book is written for experienced C++ developers, it is expected that
    you will be familiar with terms such as `mutex`, `semaphore`, `read-write lock`,
    and so on. Qt provides convenience classes to use these mechanisms while implementing
    a multithreading application. We won''t deep dive into these Qt classes with examples.
    You can learn more about the use of `QMutex`, `QSemaPhore`, `QReadWriteLock`,
    and `QWaitCondition` at the following link: [https://doc.qt.io/qt-6/threads-synchronizing.html](https://doc.qt.io/qt-6/threads-synchronizing.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how concurrency mechanisms can be used to improve
    overall application performance. Don't implement it unnecessarily for simple tasks
    as this may result in degraded performance. In the next section, we will discuss
    the use of the QML Profiler tool for profiling a Qt Quick application.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling a Qt Quick application using QML Profiler and Flame Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QML in Qt 6 takes advantage of **graphics processing units** (**GPUs**) and
    uses hardware acceleration for rendering. This feature makes QML superior to Qt
    Widgets in terms of performance. However, there can be bottlenecks in your QML
    code that may impact overall application performance. In this section, we will
    focus on using the built-in tool to find these bottlenecks. Qt Creator provides
    seamless integration with multiple tools. The most important tool is **QML Profiler**.
    It is provided by Qt and works on all Qt-supported platforms. Other than QML Profiler,
    Qt Creator also provides third-party tools such as **Valgrind**, **Heob**, and
    **Performance Analyzer**. You can enable new plugins or remove some plugins from
    **About Plugins…**, available under the **Help** menu.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss QML Profiler, which you will be using most of the time to find
    the bottlenecks in your QML code. The goal of QML Profiler is to help you identify
    bottlenecks by providing you with details such as the time taken by a code block
    to do a certain operation, after which you can decide to reimplement the code
    with suitable GUI elements or better data structures or algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to start profiling and optimizing your Qt Quick application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open an existing Qt Quick project or create a new Qt Quick application using
    Qt Creator's **New Project** creation wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project is created, add some code to it. Then, select **QML Profiler**
    under the **Analyze** menu to run the QML Profiler tool. The **Analyze** context
    menu can differ from platform to platform based on installed plugins. The following
    screenshot shows the **QML Profiler** option in the Windows platform. In Linux,
    you may see a few more options, such as **Valgrind Memory Analyzer**, **Valgrind
    Memory Analyzer with GDB**, and **Valgrind Function Profiler**:![Figure 12.1 –
    QML Profiler option in Qt Creator integrated development environment (IDE)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.1_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – QML Profiler option in Qt Creator integrated development environment
    (IDE)
  prefs: []
  type: TYPE_NORMAL
- en: When you hit the **QML Profiler** option, your Qt Quick application will run
    by QML Profiler. You will see the **QML Profiler** window appear below the code
    editor. You may also see the following message:![Figure 12.2 – QML Profiler retry
    message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.2_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – QML Profiler retry message
  prefs: []
  type: TYPE_NORMAL
- en: If you get this popup, just hit **Retry**. You will notice that the profiling
    will begin and you will also notice the output screen. In the sample application,
    we are creating new rectangles on a mouse click, as illustrated in the following
    screenshot:![Figure 12.3 – Output of sample Qt Quick application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.3_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Output of sample Qt Quick application
  prefs: []
  type: TYPE_NORMAL
- en: On the **user interface** (**UI**), perform some user interactions—such as click
    a button—to do a certain operation. Then, click the **Stop** button located on
    the title bar of the profiler window. You will also see two more buttons on both
    sides of the **Stop** button. If you hover your mouse over them, you will see
    their functionalities, such as **Start QML Profiler analysis** and **Disable Profiling**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An overview of the **QML Profiler** window is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – QML Profiler window showing Stop button and tabbed views'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.4_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – QML Profiler window showing Stop button and tabbed views
  prefs: []
  type: TYPE_NORMAL
- en: Once you stop the profiler, you will see the **QML Profiler** window is updated
    with some views. You will notice that there are three tabs under the profiler
    window—namely **Timeline**, **Flame Graph**, and **Statistics**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's look at the first tab on QML Profiler—click on the **Timeline** tab. The
    following screenshot shows a sample view of the output:![Figure 12.5 – QML Profiler
    showing timeline details
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.5_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – QML Profiler showing timeline details
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that there are six different sections under the timeline display:
    **Scene Graph**, **Memory Usage**, **Compiling**, **Creating**, **Binding**, and
    **JavaScript**. These sections give us an overview of the different stages of
    application processing such as compilation, component creation, and logical execution.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find colorful bars on the timeline. You can use the mouse wheel to zoom
    in and zoom out on specific timeline sections. You can also move the timeline
    by pressing the left mouse button at the bottom region of the timeline and move
    in either direction to locate an area of interest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The different sections of the **Timeline** tab are illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Timeline tab showing different sections'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.6_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Timeline tab showing different sections
  prefs: []
  type: TYPE_NORMAL
- en: You can click on the **Expand** button to see further details under each section,
    as illustrated in the following screenshot:![Figure 12.7 – Timeline tab showing
    different subsections under Scene Graph and profiling options
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.7_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – Timeline tab showing different subsections under Scene Graph and
    profiling options
  prefs: []
  type: TYPE_NORMAL
- en: If you click on one of the bars under the `QtQuick/Rectangle` type, total duration
    taken for creating an object, and the location of code displayed on a pop-up window,
    over the **QML Profiler** window. You can use the yellow arrows in the top-left
    corner to jump to previous or next events. This section is illustrated in the
    following screenshot:![Figure 12.8 – Details of an object under the Creating section
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.8_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – Details of an object under the Creating section
  prefs: []
  type: TYPE_NORMAL
- en: You can switch between different tabs at the bottom of the **QML Profiler**
    window. Once you have explored the **Timeline** tab, let's open up the **Flame
    Graph** tab. Under this tab, you will find a visualization of the **Total Time**,
    **Memory**, and **Allocations** of your application as a percentage. You can switch
    between these views by clicking on the dropdown located in the top-right corner
    of the **QML Profiler** window, as shown in the following screenshot:![Figure
    12.9 – Flame Graph showing Allocations view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.9_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.9 – Flame Graph showing Allocations view
  prefs: []
  type: TYPE_NORMAL
- en: The **Flame Graph** view provides a more compact statistics summary. The horizontal
    bars depict one aspect of the samples gathered for a certain function in comparison
    to the same aspect of all samples combined. The nesting indicates a call tree
    that shows, for example, which functions call the other function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As seen in the following screenshot, you can also see the percentage value displayed
    on the left side of the code editor. Based on which component is consuming more
    time, you can tweak your code:![Figure 12.10 – QML Profiler showing percentage
    time spent for a specific portion of the code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.10_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.10 – QML Profiler showing percentage time spent for a specific portion
    of the code
  prefs: []
  type: TYPE_NORMAL
- en: Since data collection takes time, you may notice a little lag before the data
    is displayed. When you click the **Enable Profiling** button, data is transferred
    to QML Profiler, therefore don't terminate the application immediately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To disable the automatic start of data collection when an application is launched,
    select the **Disable Profiling** button. When you toggle the button, data collection
    will start again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s move to the next tab: the **QML Profiler** window. This tab reveals
    statistical details about the processes in a table structure. The following screenshot
    illustrates the statistics of the code execution for our sample code:![Figure
    12.11 – QML Profiler showing statistics of code execution'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.11_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.11 – QML Profiler showing statistics of code execution
  prefs: []
  type: TYPE_NORMAL
- en: You can also attach QML Profiler to an externally started application through
    **QML Profiler (Attach to Waiting Application)** under the **Analyze** menu. Once
    you select the option, you will see the following dialog:![Figure 12.12 – QML
    Profiler showing remote execution option
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.12_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.12 – QML Profiler showing remote execution option
  prefs: []
  type: TYPE_NORMAL
- en: To save all of the data collected, right-click on any QML Profiler view and
    select **Save QML Trace** in the context menu. You can select **Load QML Trace**
    to see the saved data. You can also send the saved data to others for review or
    load data that they have saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this section, we discussed different options available in QML Profiler.
    By using this tool, you can easily find code that is causing performance issues.
    More details are available at this link: [https://doc.qt.io/qtcreator/creator-qml-performance-monitor.html](https://doc.qt.io/qtcreator/creator-qml-performance-monitor.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss further how to use other analytical tools
    to optimize your Qt code.
  prefs: []
  type: TYPE_NORMAL
- en: Other Qt Creator analysis tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the earlier section, we discussed QML Profiler, but you may need to analyze
    your C++ and Qt Widgets code. Qt Creator provides integration with some of the
    famous analysis tools to help you analyze your Qt application. Some of the tools
    that come with Qt Creator are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Heob**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance Analyzer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Valgrind**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clang Tools: Clang-Tidy and Clazy**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cppcheck**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chrome Trace Format** (**CTF**) visualizer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's briefly discuss these tools and become familiar with them before getting
    into their documentation.
  prefs: []
  type: TYPE_NORMAL
- en: To use Heob, you first need to download and install it. Buffer overruns and
    memory leaks can be easily detected with Heob. It works by overriding the caller
    process's heap functions. An access violation is raised when a buffer overrun
    occurs, and stack traces of the offending code and buffer allocation are noted.
    You will find the stack traces when the application exits normally. It doesn't
    require any recompilation or relinking of the target application.
  prefs: []
  type: TYPE_NORMAL
- en: You can read about its usage on the official documentation link at [https://doc.qt.io/qtcreator/creator-heob.html](https://doc.qt.io/qtcreator/creator-heob.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the binary from [SourceForge.net](http://SourceForge.net)
    or build it from the source code. The source code of Heob can be found at the
    following link: [https://github.com/ssbssa/heob](https://github.com/ssbssa/heob).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux Performance Analyzer tool is integrated with Qt Creator and can be
    used to analyze an application''s CPU and memory utilization on Linux desktop
    or Linux-based embedded systems. The `perf` tool takes periodic snapshots of an
    application''s call tree and visualizes them in a timeline view or as a flame
    graph, using the utility included with the Linux kernel. You can launch it on
    your Linux machine from the **Performance Analyzer** option under the **Analyze**
    menu, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Qt Creator showing Performance Analyzer option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.13_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.13 – Qt Creator showing Performance Analyzer option
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that the `perf` utility, you will get an equivalent warning dialog,
    as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Qt Creator showing Performance Analyzer warning dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.14_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.14 – Qt Creator showing Performance Analyzer warning dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to install the `perf` tool on your Ubuntu machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using a different Linux distribution, you can use the corresponding
    command. `perf` may fail for the specific Linux kernel, with a warning about the
    kernel version. In that case, type the following command with the appropriate
    kernel version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `perf` setup is done, you can see the predefined events in the command
    prompt with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, launch Qt Creator and open a Qt project. Select `perf` tool and an additional
    assistance program is included with Qt Creator, it may appear in Qt Creator several
    seconds after it was created. The **Processing delay** field contains an estimate
    for this delay. The data collection continues until you click the **Stop collecting
    profile data** button or close the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also load `perf.data` and analyze an application from **Performance
    Analyzer Options** under the **Analyze** menu, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – Context menu showing Performance Analyzer options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.15_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.15 – Context menu showing Performance Analyzer options
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about usage of Performance Analyzer at the following link:
    [https://doc.qt.io/qtcreator/creator-cpu-usage-analyzer.html](https://doc.qt.io/qtcreator/creator-cpu-usage-analyzer.html).'
  prefs: []
  type: TYPE_NORMAL
- en: On macOS, there is an equivalent tool called **Instructions**; however, this
    is not integrated with Qt Creator. You can launch it separately and look at the
    **Time Profiler** section.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux and macOS, `memcheck`. You can change this to `callgrind` from the
    profiler drop-down option.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about Valgrind at the following link: [https://doc.qt.io/qtcreator/creator-valgrind-overview.html](https://doc.qt.io/qtcreator/creator-valgrind-overview.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next tool available in Qt Creator is **Clang-Tidy** and **Clazy…**. These
    tools can be used to locate issues in your C++ code through static analysis. **Clang-Tidy**
    provides diagnostics and fixes for common programming errors such as style violations
    or interface misuse. On the other hand, **Clazy** highlights Qt-related compiler
    errors, such as wasteful memory allocation and API usage, and suggests refactoring
    activities to remedy some of the problems. Clang-Tidy includes the Clang static
    analyzer capabilities. You do not need to set up Clang tools individually because
    they are distributed and integrated with Qt Creator. When you run **Clang-Tidy
    and Clazy…**, as illustrated in the following screenshot, you will see the analysis
    details under the **Profiler** window and the progress under the **Application
    Output** window below the code editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.16 – Context menu showing the Clang-Tidy and Clazy… option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.16_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.16 – Context menu showing the Clang-Tidy and Clazy… option
  prefs: []
  type: TYPE_NORMAL
- en: Let's run the tool on an existing Qt example. In the application window, you
    will see the analysis running, and in the profiler window, you will see the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explore the documentation further at the following link: [https://doc.qt.io/qtcreator/creator-clang-tools.html](https://doc.qt.io/qtcreator/creator-clang-tools.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Qt Creator also includes another tool called **cppcheck**. This tool has experimental
    integration with Qt Creator. You can enable it from **About Plugins…**, available
    under the **Help** menu. You can use this to detect undefined behavior and dangerous
    coding constructs. The tool provides options to check warnings, style, performance,
    portability, and information.
  prefs: []
  type: TYPE_NORMAL
- en: The last analysis tool integrated with Qt Creator is the **CTF visualizer**.
    You can use this along with QML Profiler. Tracing information might provide you
    further insight into the data that QML Profiler collects. You can find why a simple
    binding is taking so long, such as being possibly impacted by the C++ code or
    by slow disk operation. Full stack tracing may be used to trace from the top-level
    QML or JavaScript down to C++ and all the way down to the kernel area. This allows
    you to assess an application's performance and determine if poor performance is
    caused by the CPU or other programs on the same system. Tracing provides insight
    into what the system is doing and why an application is behaving in an undesired
    way. To see Chrome trace events, utilize the CTF visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the CTF visualizer at the following link: [https://doc.qt.io/qtcreator/creator-ctf-visualizer.html](https://doc.qt.io/qtcreator/creator-ctf-visualizer.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed different analysis tools available in Qt
    Creator. In the next section, we will discuss further how to optimize and locate
    graphical performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing graphical performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed graphics and animation in [*Chapter 8*](B16231_08_Final_ASB_ePub.xhtml#_idTextAnchor176),
    *Graphics and Animations*. In this section, we will explore factors that impact
    performance in graphics and animation. Graphics performance is essential in any
    application. If your application is poorly implemented, then users may see flickering
    in the UI or the UI may not update as expected. As a developer, you must make
    every effort to ensure that the rendering engine maintains a 60 **frames-per-second**
    (**FPS**) refresh rate. There are only 16 **milliseconds** (**ms**) between each
    frame in which processing should be done at 60 FPS, which includes the processing
    necessary to upload the draw primitives to the graphics hardware.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid any glitch in graphical performance, you should use asynchronous, event-driven
    programming wherever possible. If your application has huge data processing requirements
    and complex calculations, then use worker threads to do the processing. You should
    never manually spin an event loop. Don't spend more than a few ms per frame in
    blocking functions. If you don't follow these points, the users will see the GUI
    flickering or freezing, resulting in a bad **user experience** (**UX**). When
    it comes to generating graphics and animations on the UI the QML engine is very
    efficient and powerful. However, there are a few tricks you can use to make things
    even go faster. Instead of writing your own, utilize Qt 6's built-in capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: While drawing graphics, you should choose opaque primitives if possible. Opaque
    primitives are faster to render by the renderer and to draw on the GPU. Hence,
    between `QImage::Format_RGB32` when passing photos to a `QQuickImageProvider`.
    Please note that overlapping compound items cannot be batched. Avoid clipping
    if possible as it breaks batching. Instead of clipping an image, use `QQuickImageProvider`
    to generate a cropped image. Applications that require a monochromatic background
    should use `QQuickWindow::setColor()` rather than a top-level `Rectangle` element.
    `QQuickWindow::setColor()` invokes `glClear()`, which is faster.
  prefs: []
  type: TYPE_NORMAL
- en: While using `Image`, make use of the `sourceSize` property. The `sourceSize`
    property enables Qt to downsize the image before loading it into memory, ensuring
    that huge images consume no more memory than is required. When the `smooth` attribute
    is set to `true`, Qt filters the image to make it look smoother when it is scaled
    or changed from its original size. If the image is rendered at the same size as
    its `sourceSize` property, this makes no difference. On some older hardware, this
    property will influence the performance of your application. The `antialiasing`
    property directs Qt to smooth down aliasing artifacts around the edges of the
    image. This property will affect your program's performance.
  prefs: []
  type: TYPE_NORMAL
- en: Better graphical performance can be achieved by effective batching. The renderer
    can provide statistics on how well the batching runs, how many batches are utilized,
    which batches are kept, which are opaque, and which are not. To enable this, add
    an environment variable such as `QSG_RENDERER_DEBUG` and set the value to `render`.
    Unless an image is too huge, a texture atlas is used by the `Image` and `BorderImage`
    QML types. If you are creating textures using C++, then call `QQuickWindow::createTexture()`
    and pass `QQuickWindow::TextureCanUseAtlas`. You can use another environment variable,
    `QSG_ATLAS_OVERLAY`, to colorize the atlas textures, which helps in identifying
    them easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize the various aspects of the scene graph''s default renderer, the
    `QSG_VISUALIZE` environment variable can be set to one of the values. You can
    do this in Qt Creator by going to the `QSG_VISUALIZE` and setting the value for
    that variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QSG_VISUALIZE` = `overdraw`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSG_VISUALIZE` = `batches`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSG_VISUALIZE` = `clip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSG_VISUALIZE` = `changes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `QSG_VISUALIZE` is set to `overdraw`, overdraw is visualized in the renderer.
    To highlight overdraws, all elements are visualized in `Rectangle` just to draw
    a white background, as `Window` also has a white background. In this case, using
    an `Item` property instead of `Rectangle` can improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Setting `QSG_VISUALIZE` to `batches` causes batches to be visualized in the
    renderer. Unmerged batches are drawn with a diagonal line pattern, whereas merged
    batches are drawn with a solid color. A small number of distinct colors indicates
    effective batching. Unmerged batches are undesirable if they contain a large number
    of individual nodes.
  prefs: []
  type: TYPE_NORMAL
- en: All QML components that derive from `Item` have a property called `clip`. By
    default, the `clip` value is set to `false`. This property informs the scene graph
    not to render any child elements that extend beyond the boundaries of their parent.
    When `QSG_VISUALIZE` is set to `clip`, red spots appear on top of the scene to
    indicate clipping. Because Qt Quick `Items` do not clip by default, clipping is
    often not shown. Clipping prevents the ability to batch multiple components together,
    which impacts graphical performance.
  prefs: []
  type: TYPE_NORMAL
- en: When `QSG_VISUALIZE` is set to `changes`, changes in the renderer are shown.
    A flashing overlay of random color is used to highlight changes in the scene graph.
    Modifications to a primitive are shown by a solid color, but changes to an ancestor—
    such as changes to the matrix or opacity—are shown by a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment with these environment variables in your Qt Quick application. You
    can learn more about these rendering flags at the following link: [https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick helps in building great applications with a fluid UI and dynamic transitions.
    However, you should consider some of the factors to avoid performance implications.
    When you add an animation to a property, all bindings are impacted and re-evaluated,
    which references the property. To avoid performance issues, you may remove the
    binding before running the animation and then reassign it after the animation
    is complete. During the animation, avoid using JavaScript. Script animations should
    be used with caution because they run in the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use Qt Quick particles to create a nice particle effect. However, its
    performance depends on underlying hardware capabilities. To render more particles,
    you will need faster graphics hardware. Your graphics hardware should be capable
    to draw at or above 60 FPS. You can learn more about optimizing particle performance
    at the following link: [https://doc.qt.io/qt-6/qtquick-particles-performance.html](https://doc.qt.io/qt-6/qtquick-particles-performance.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed different considerations to optimize graphical
    performance. In the next section, we will discuss further how to benchmark your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating benchmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned about benchmarking in [*Chapter 9*](B16231_09_Final_ASB_ePub.xhtml#_idTextAnchor221),
    *Testing and Debugging*. Let's look at some aspects of benchmarking to evaluate
    performance issues. We've already talked about Qt Test's support for benchmarking,
    which is a calculation of the average time required by a particular task. The
    `QBENCHMARK` macro is used to benchmark a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows benchmarking key clicks on a line edit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also benchmark convenience functions provided by Qt. The following
    code benchmarks the `QString::localeAwareCompare()` function. Let''s look at the
    sample code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can also run benchmark tests in QML. The Qt benchmark framework will run
    functions with names that begin with `benchmark_` several times, with an average
    timing value recorded for the runs. It is similar to the `QBENCHMARK` macro in
    the C++ version of `QTestLib`. You can prefix the test function name with `benchmark_once_`
    to get the effect of the `QBENCHMARK_ONCE` macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `Benchmark` or `CreationBenchmark`. It also allows you
    to perform both automated and manual benchmarking. Automated tests can be used
    for regression testing, whereas manual tests can be done to understand the capabilities
    of new hardware. It comes with built-in features such as the FPS counter, which
    is very important for GUI applications. You can find the frame rate by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run all the automated tests with a simple command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To explore more about the tool and look at the examples, please refer to the
    following link: [https://github.com/qt-labs/qmlbench](https://github.com/qt-labs/qmlbench).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen benchmarking object creation in Qt Widgets and QML and we also
    benchmarked a Qt function. You can also analyze without using any macros. You
    can simply use `QTime` or `QElapsedTimer` to measure the time taken by a portion
    of a code or a function, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have used `elapsed()` to measure the time
    taken for a code segment. The difference is that you can evaluate a few lines
    inside a function—you don't have to write a separate test project. It's a quick
    way to find performance issues without evaluating a whole project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also benchmark your Qt Quick 3D application. Here''s an article on
    how to do it: [https://www.qt.io/blog/introducing-qtquick3d-benchmarking-application](https://www.qt.io/blog/introducing-qtquick3d-benchmarking-application).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed benchmarking techniques. In the next section,
    we will discuss more profiling tools.
  prefs: []
  type: TYPE_NORMAL
- en: Different analysis tools and optimization strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can optimize your application at multiple levels other than just at a code
    level. Optimization can also be done at a memory or binary. You can modify your
    application to make it work more efficiently by using fewer resources. However,
    there can be a trade-off between memory and performance. Based on your hardware
    configuration, you can decide a strategy as to whether memory usage or processing
    time is important. In some embedded platforms with memory limitations, you can
    allow the processing time to be a little longer to use less memory and keep the
    application responsive. You can also delegate some part of the optimization task
    to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at different strategies we can use to build, analyze, and
    deploy faster.
  prefs: []
  type: TYPE_NORMAL
- en: Memory profiling and analysis tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will discuss some additional tools you can use to analyze
    your application. Note that we won't be discussing these tools in detail. You
    can visit the respective tool website and learn from their documentation. In addition
    to the available tools in Qt Creator, you can use the following tools on your
    Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the list of tools, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AddressSanitizer** (**ASan**) is an address monitoring tool built by Google
    and part of Sanitizers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AQTime Pro** finds issues and memory leaks with application runtime analysis
    and performance profiling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deleaker** is a tool for C++ developers who want to find all possible known
    leaks in their projects. It can detect memory leaks, **Graphics Device Interface**
    (**GDI**) leaks, and other leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intel Inspector XE** is a memory and thread debugger from Intel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PurifyPlus** is a runtime analysis tool suite that monitors your program
    as it runs and reports on key aspects of its behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Leak Detector** is a free, robust, open-source memory leak detection
    system for Visual C++.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Very Sleepy** is a CPU profiler based on sampling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Profiler** (**VSTS**) can be used for CPU sampling, instrumentation,
    and memory allocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MTuner** utilizes a novel approach to memory profiling and analysis, keeping
    an entire time-based history of memory operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory Leak Detection Tool** is a high-performance memory leak detection
    tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heob** detects buffer overruns and memory leaks. Integrated into Qt Creator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process Explorer** can query and visualize several systems and performance
    counters for each process, and I regularly use it for preliminary investigations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System Explorer** shows all system calls issued by any running processes
    in a long list and supports filters to select processes we''d like to observe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAMMap** examines a system''s global memory usage, which requires quite a
    bit of Windows internal knowledge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VMMap** shows detailed information on a single application''s memory usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coreinfo** gives detailed information about the processor, information you
    might need when doing low-level optimization work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bloaty** performs a deep analysis of the binary. It aims to accurately attribute
    every byte of the binary to a symbol or compile the unit that produced it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we briefed you about some of the third-party profiling tools.
    In the next section, we will discuss how to optimize your binary during linking.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing during linking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In earlier sections, we discussed how to find bottlenecks and optimize a code
    segment that is impacting an application's performance. Fortunately, most compilers
    now include a mechanism that allows you to do such optimizations while maintaining
    the modularity and cleanliness of your code. This is referred to as **link-time
    code generation** (**LTCG**) or **link-time optimization** (**LTO**). LTO is the
    optimization of a program during the linking process. The linker collects all
    object files and integrates them into a single program. Because the linker can
    view the entire program, it can do whole-program analysis and optimization. However,
    the linker generally only sees the program after it has been translated into machine
    code. Rather than converting each source file to machine code one by one, we postpone
    the code-generation procedure until the very end—linking time. Code generation
    at linking time enables not just smart inlining of code but also does optimizations
    such as devirtualizing functions and better elimination of redundant code. This
    technique can be used to improve application launch time.
  prefs: []
  type: TYPE_NORMAL
- en: To enable this mechanism in Qt, you have to build from the source code. At the
    configure step, add `-ltcg` to the command-line options. Compiling all of your
    source code at once during the compilation stage will provide you all of the optimization
    benefits of full LTO. You can optimize your application launch time at a toolchain,
    platform, and application level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn more about these performance tips at the following link: [https://wiki.qt.io/Performance_Tip_Startup_Time](https://wiki.qt.io/Performance_Tip_Startup_Time).'
  prefs: []
  type: TYPE_NORMAL
- en: You can delegate the optimization task to the compiler at times. When you enable
    optimization flags, the compiler will try to boost the performance and optimize
    the code block, at the cost of compilation time and—probably—debugging capability.
    You can enable compiler-level optimization flags for your desired compilers such
    as **GNU Compiler Collection** (**GCC**) or Clang.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at GCC optimization options for available C++ compilers at the following
    link: [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html](http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn about different flags in Clang at the following link: [https://clang.llvm.org/docs/CommandGuide/clang.html](https://clang.llvm.org/docs/CommandGuide/clang.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about link-time optimization. In the next section,
    we will discuss how to build your Qt application faster.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Qt application faster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a large complex project, the time spent on building a project is increasingly
    becoming valuable. In general, the longer the build time, the more time you lose
    every day. If you multiply that by the time for a complete team, you lose a lot
    of time just waiting for the build to finish. While having to wait hours for each
    small change to be rebuilt might make you more careful about details and drive
    you to think about each step in depth, it may also limit a more Agile process
    or collaboration. In this section, we will provide a short guide for dealing with
    optimization in C++ using Qt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note the following points you should follow to speed up your build process:'
  prefs: []
  type: TYPE_NORMAL
- en: Use parallel building flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make use of a precompiled header (`pch`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove redundant targets from makefile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use forward declarations in classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most effective way while building a large project is to use a parallel-build
    approach. A parallel build can be enabled by passing an additional parameter.
    In Qt Creator, you can enable `-j8`. You can instruct your compiler to build in
    a parallel way through the following command-line statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The last number depends on your hardware. `-j8` instructs to run eight threads
    in parallel. Based on your machine configuration, you may use `-j4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also enable a parallel build for the `-MP` flag. You can instruct `cl`
    to run parallel by adding the following flag in the `.pro` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A precompiled header is an excellent technique to drastically minimize a compiler's
    load. When a compiler parses a file, it must parse the entire code, along with
    the standard headers and other third-party sources. `pch` allows you to define
    which files are frequently used so that the compiler may precompile them before
    starting a build and utilize the results while building each `.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a precompiled header file, add the following lines of code to the `.pro`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you use the `Q_OBJECT` macro, the meta-object compiler generates additional
    files. Don't use the `Q_OBJECT` macro unnecessarily, unless you require relevant
    features such as the signals and slots mechanism or translation. When you add
    the `Q_OBJECT` macro, `moc` will generate a `moc_<ClassName>.cpp` file, which
    adds to the compilation complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can include this file at the end of your `.cpp` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can also lower the dependencies of each `.cpp` file by using forward declarations
    for small projects and a forward header in large projects. Forwarding classes
    will shorten the duration of a partial build during standard work. Most classes
    can contain forward declarations in the `forwards.h` file. By having such a file,
    you may drastically minimize the number of includes in header files, usually by
    including `forwards.h`.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, `qmake` will notice this and remove this file from the list of
    targets. This will reduce the load on the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to reduce the application build time. In the
    next section, we will discuss some of the best practices in the Qt Widgets-based
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations for Qt Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt Widgets module renders widgets utilizing the raster engine, a software
    renders using CPU rather than GPU. In most cases, it can provide the desired performance.
    However, the Qt Widgets module is very old and lacks the latest capabilities.
    Since QML is entirely hardware-accelerated, you should consider adopting it for
    your application's UI.
  prefs: []
  type: TYPE_NORMAL
- en: If your widgets don't need `mouseTracking`, `tabletTracking`, or similar event
    capturing, turn it off. Your application will use more CPU time as a result of
    this tracking. Maintain a smaller style sheet and keep it all in one style sheet
    instead of applying it to individual widgets. A large style sheet will take longer
    for Qt to process the information into the rendering system, which may affect
    the application's performance. Use custom styles instead of a style sheet as this
    can provide you better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Don't create screens unnecessarily and keep them hidden. Create a screen only
    when it is required. While using `QStackedWidget`, avoid adding too many pages
    and populating them with many widgets. It requires Qt to discover them all recursively
    during the rendering and event handling stages, causing the program to run slowly.
  prefs: []
  type: TYPE_NORMAL
- en: Use asynchronous methods wherever feasible for huge operations, to avoid blocking
    the main process, and keep your software running smoothly. Multithreading is extremely
    useful for parallelizing several processes in event loops. However, if not done
    correctly, such as by repeatedly creating and removing threads or by poorly implemented
    inter-thread communications, it may result in undesired outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Different C++ containers yield different speeds. Qt's vector container is slightly
    slower than the one in the STL. Overall, the old C++ array is still the fastest,
    but it lacks sorting capabilities. Use what is most appropriate for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about best practices while using the Qt Widgets
    module. In the next section, we will discuss best practices in QML.
  prefs: []
  type: TYPE_NORMAL
- en: Learning best practices of QML coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to follow certain best practices while coding in QML. You should
    keep the file under a certain line limit and should have consistent indentation
    and structural attributes, as well as following a standard naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can structure your QML object attributes in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using multiple properties from a group of properties, then use group
    notation, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Treating groups of properties as a block can ease confusion and help relate
    the properties with other properties.
  prefs: []
  type: TYPE_NORMAL
- en: QML and JavaScript do not enforce private properties like C++ does. There is
    a need to hide these private properties—for example, when the properties are part
    of the implementation. To effectively gain private properties in a QML item, you
    can embed inside a `QtObject{...}` to hide the properties. This prevents the properties
    from being accessed outside of the QML file and JavaScript. To minimize the impact
    on performance, try to group all private properties into the same `QtObject` scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet illustrates the use of `QtObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It takes time for property resolution. While the result of a lookup can sometimes
    be cached and reused, it is generally preferable to avoid doing extra work if
    at all feasible. You should try to use the common base just once in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: If any of the properties change, the property binding expression is re-evaluated.
    If you have a loop where you do some processing but only the result matters, then
    it is better to create a temporary accumulator then assign it to the property
    you want to update, rather than incrementally updating the property itself, to
    prevent triggering re-evaluation of binding expressions.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent a continuous overhead of leaving items that are invisible because
    they are children of a non-visible active element, they should be initialized
    lazily and destroyed when no longer in use. An object loaded using a `Loader`
    element may be released by resetting the `source` or `sourceComponent` property
    of `Loader`, but other items can be explicitly destroyed. It may be required to
    keep the item active in some situations, in which case it should be made invisible.
  prefs: []
  type: TYPE_NORMAL
- en: In general, opaque content is much faster to draw than translucent content.
    The reason for this is that translucent content requires blending, and the renderer
    may be able to better optimize opaque content. Even if an image has only one translucent
    pixel, it is viewed as totally transparent. The same may be said for a `BorderImage`
    element with translucent edges.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid doing long logical calculations in QML. Use C++ for implementing business
    logic. If you still need to use JavaScript-based implementation for doing some
    complex operation or processing, then use `WorkerScript`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Qt Quick Compiler lets you compile QML source code into a final binary.
    The application''s launch time can be greatly reduced by enabling this. You do
    not have to deploy the `.qml` files along with the application. You can enable
    Qt Quick Compiler by adding the following line to your Qt project (`.pro`) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To learn more about Qt Quick best practices, read the documentation at the
    following link: [https://doc.qt.io/qt-6/qtquick-bestpractices.html](https://doc.qt.io/qt-6/qtquick-bestpractices.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also explore more about Qt Quick performance in the documentation found
    at the following link: [https://doc.qt.io/qt-6/qtquick-performance.html](https://doc.qt.io/qt-6/qtquick-performance.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned some of the best practices while coding in QML.
    We will now summarize our learning in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed performance considerations and how to improve
    your overall application performance. We started with improving C++ code. Then,
    we explained how concurrency techniques can help in making your application faster.
    You learned about QML Profiler and other profiling tools. You also understood
    the importance of using best practices while coding in Qt. Now, you can use these
    techniques in everyday coding. You don't have to be an extraordinary application
    developer to do performance optimization. If you follow best practices, design
    patterns, and write better algorithms, then your application will have fewer defects
    and fewer customer complaints. It is a continuous process, and you will gradually
    become better at it.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have learned the basics of performance optimization. If
    you are curious to know more, then you can read more books specifically written
    for performance tuning. Happy coding in Qt. Remember—writing better and high-performant
    code can reduce the CPU cycle, which in turn reduces the carbon footprint, hence
    effectively, if you code better, you can save the planet and fight climate change!
  prefs: []
  type: TYPE_NORMAL

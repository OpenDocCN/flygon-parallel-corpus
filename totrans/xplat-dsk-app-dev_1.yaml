- en: Creating a File Explorer with NW.js-Planning, Designing, and Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, when speaking of HTML5 desktop application development, one implies
    either **NW.js** or **Electron**. The first one has a shorter learning curve,
    which makes it a better choice for the beginning. Our first application will be
    a File Explorer. This sort of software is traditionally considered as a classical
    desktop application. I believe that you will find it exciting to build a File
    Explorer with HTML, CSS, and JavaScript. This chapter requires no skills in JavaScript
    frameworks, as we will use none. All you need is a basic knowledge of HTML, CSS,
    and plain JavaScript (including Node.js).
  prefs: []
  type: TYPE_NORMAL
- en: So, what are we up to? We will plan and sketch the project. We will set up the
    development environment and create a static prototype and run it with NW.js. We
    will implement the basic functionality, making it ready to be enhanced in [Chapter
    2](013f4079-2a91-4776-a2bb-82e9ff5eb552.xhtml), *Creating a File Explorer with
    NW.js Enhancement and Delivery*.
  prefs: []
  type: TYPE_NORMAL
- en: The application blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By File Explorer, I mean a small program that allows navigating through the
    filesystem and performs basic operations on the files, which can be expressed
    with the following user stories:'
  prefs: []
  type: TYPE_NORMAL
- en: As a user, I can see the content of the current directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can navigate through the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can open a file in the default associated program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can delete a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can copy a file in the clipboard and paste it later in a new location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can open the folder containing the file with the system file manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can close the application window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can minimize the application window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can maximize and restore the application window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can change the application language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It would be easier to perceive it in a visual form, wouldn''t it? Wireframes
    come in handy here. Wireframe is a skeletal framework of the application that
    depicts the arrangement of the application''s content, including UI elements and
    navigation system. Wireframe has no real graphics, typography, or even colors.
    It shows schematically, what the application does. As you know, drawing with a
    pencil on a paper is possible, but it is not the best way to create a wireframe;
    what we need is a prototyping tool. Today, there are plenty of solutions on the
    market. Here, I use an impressive, but affordable tool called **WireframeSketcher**
    ([http://wireframesketcher.com/](http://wireframesketcher.com/)). It allows you
    to sketch web, desktop, and mobile applications (just what we need). It also has
    a rich mock-up gallery of stencils, widgets, icons, and templates that makes prototyping
    fast and easy. Besides, the wireframes look nice in a sketchy style:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62a85392-9053-4bf9-bf43-2098db164c19.png)'
  prefs: []
  type: TYPE_IMG
- en: What we can see on the wireframe is often called a **Holy Grail Layout**. In
    our case, the header serves as the window title bar. There, we keep our controls
    for window actions such as close, maximize, and minimize. Besides that, in the
    title bar, we display the path to the current directory. In the sidebar, we have
    our filesystem navigation. The main section contains a table that represents files
    of the current directory. It has columns--Name, Size, and Modified. A right-click
    on a file opens a context menu with available file operations. The footer comprises
    the application title and a language selector combo box.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an NW.js project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NW.js is an open source framework for building HTML, CSS, and JavaScript applications.
    You can also see it as a headless browser (based on Chromium [https://www.chromium.org/](https://www.chromium.org/))
    that includes Node.js runtime and provides desktop environment integration API.
    Actually, the framework is very easy to start with. What we need is just a start
    page HTML file and project manifest file (`package.json`).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4582a55-4af3-4b8c-be20-8c116005485b.png)'
  prefs: []
  type: TYPE_IMG
- en: To see it in action, we will create a project folder named `file-explorer` at
    an arbitrary location. The choice of the folder location is up to you, but I personally
    prefer to keep web projects in `/<username>/Sites` on Linux/macOS and `%USERPROFILE%Sites`
    on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we enter the directory, we create placeholder folders for JavaScript and
    CSS sources (`js` and `assets/css`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d4d3068-5cd0-42f3-aed4-28355b90a084.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also place a start page HTML (`index.html`) that consists of just a few
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can guess, we shall see just this text--File Explorer-- when feeding
    this file to a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need the Node.js manifest file (`package.json`). Node.js, embedded in
    the framework, will use it to resolve dependency package names when called with
    a `require` function or from an npm script. In addition, NW.js takes from it the
    project configuration data.
  prefs: []
  type: TYPE_NORMAL
- en: Why not create the manifest file and populate it with dependencies using the
    npm tool?
  prefs: []
  type: TYPE_NORMAL
- en: Node Package Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, **Node Package Manager** (**npm**) is one of the most demanded gadgets
    in the web developer tool belt. It's a command-line utility connected with the
    corresponding online repository of packages and is capable of package installation,
    version management, and dependency management. So, when we need a package (library,
    framework, and module), we will check whether it's available in the npm repository
    and run npm to bring it into our project. It not only downloads the package, it
    also resolves its dependencies and does it pretty smartly. Furthermore, npm is
    pretty handy as an automation tool. We can set various command-line tasks to refer
    any of the locally installed packages by name. The npm tool will find the executable
    package among installed packages and run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The npm tool is distributed together with Node.js. So, you can find an installer
    for Windows or for macOS on the Node.js download page ([https://nodejs.org/en/download](https://nodejs.org/en/download)).
    It is also available as an APT package, so you can install it for Linux with the
    `apt-get` tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have already installed npm, ensure that it''s up to date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As I have already said, we can install packages with npm-- for example, NW.js.
    If we want to do it globally, we will run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will download the latest build of NW.js in `{prefix}/lib/node_modules/`
    and place the executable file in `{prefix}/bin`. It adds the binary to the `PATH`
    environment variable, so one can call `nw` in any location in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: '`{prefix}` In order to find out what `{prefix}` is one can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm config get prefix`. On Linux/macOS it will be `/usr/local`. On Windows
    `%APPDATA%npm`'
  prefs: []
  type: TYPE_NORMAL
- en: This way, we will have a single instance of NW.js across the system, but what
    if an application requires a specific version of NW.js? Luckily, with npm, we
    can also install a package locally, and therefore, rely on a particular version
    that addresses our application. In addition, we can manage local dependencies
    in the `package.json` file. With a single command, npm can install/update all
    the dependencies enlisted there at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how it works on our project. We go to the project root
    (the `file-explorer` folder) and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces a `package.json` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the `name` field, we set our application name. Beware that NW.js will
    use the provided value to name the directory in a system-dependent path for the
    project persistent data (`nw.App.dataPath`). So, it shall be a unique, lowercase
    alpha-numeric, but may include a few special symbols, such as `.`, `_`, and `-`.
  prefs: []
  type: TYPE_NORMAL
- en: Field version expects the application version as a string, conforming to the
    Semantic Versioning standard ([http://semver.org/](http://semver.org/)). What
    it all boils down to is a composite product version out of three numbers separated
    with dots. The first number (MAJOR) increments when we make incompatible API changes,
    the second number (MINOR) increases when we introduce a new functionality, and
    the last one (PATCH) identifies bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` field, we let NW.js know where to find our start page HTML. We
    have to edit the manifest to change its value with `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The field `scripts` accepts a key value object with automation scripts for
    the project. By default, it has a placeholder for tests. Now, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The Shell responds with an error message saying no test specified, as we have
    no test yet. However, we will need a script to start the application. So, we edit
    `package.json` again and add to `scripts` field the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can type `npm run start` or `npm start` to run NW.js on the project
    root, but we do not have the framework installed, yet. We are just about to bring
    it in.
  prefs: []
  type: TYPE_NORMAL
- en: Manifest fields--such as description/keywords and author--help other people
    to discover the application as a package. The `license` field tells people how
    they are permitted to use the package. You can find more about these fields and
    other possible options at [https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before telling npm to install the framework, we note that the standard version
    of NW.js doesn''t include DevTools, which we definitely will need for development.
    So, we look for a specific version, the so-called SDK flavor. To find out the
    package versions that are available for the NW.JS package (`nw`), we run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This receives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'From this payload, we can assume that the latest version at the time of writing
    is `0.20.3` and that it is accompanied with `0.20.3-sdk`. So, we can install the
    framework, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively,we can install it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, since we know that the package has a dist-tag called `sdk`, we can
    also do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Just after running any of these commands, we can find a new subdirectory named
    `node_modules`. There, npm installs local dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you noticed that we applied the `--save-dev (-D)` option? This way, we
    requested npm to save the package in our development dependency list. Observe
    that `package.json` is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We installed the package as a development dependency because this SDK version
    is meant only for development. In [Chapter 2](013f4079-2a91-4776-a2bb-82e9ff5eb552.xhtml),
    *Creating a File Explorer with NW.jsâ€“Enhancement and Delivery* we will examine
    the distribution and packaging techniques. So, you will see how we can bundle
    the application with a platform-specific NW.js production build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have reflected our dependency in the manifest file, we can update
    this and any further packages any time by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we lose `node_modules`(for example after cloning the project from remote
    GIT repository given the dependency folder is usually in the ignore list), we
    can install all the dependencies through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Have you noticed? In the `package.json`, we assigned `nw` package with version
    in, so called, caret range `^0.20.3-sdk`. That means during the install/update
    process, npm will accept new versions with patch and minor updates, but no major
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some useful npm commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm i pkg-name`: Installs the latest available version of a package'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm i pkg-name@version`: Installs a concrete version of the package'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm i pkg-name -S`: Installs package as a dependency and saves it in `package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm i pkg-name -D`: Installs package as a development dependency and save
    in `package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm i`: Installs all the dependencies (including development ones) enlisted
    in `package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm i --production`: Installs dependencies but not development ones'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm list`: Shows all the installed dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm uninstall nw --save`: uninstalls a package and removes it from'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm un nw -S`: shorter syntax'
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have the framework instance and `package.json` pointing to
    `index.html`. So, we can run the only script we have defined in the manifest file
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'First, run it on NW.JS in Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dca42a1-2a57-41f1-87ee-4778c664da85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, run it on NW.JS in windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb55a82c-1398-4579-ae5e-156ba77dae6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we run it in macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6478710c-4847-418f-9d91-3b667083b9dc.png)'
  prefs: []
  type: TYPE_IMG
- en: NW.js created a window and rendered `index.html` in it. It took the default
    Window parameters. If we want to customize them, we will need to edit `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add the `window` field that accepts an object with the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`window.icon`: This specifies a relative path to the window icon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.show`: This indicates whether the window is visible when the application
    starts or not. For instance, you can set it to false in the manifest and then
    change it programmatically with JavaScript (`nw.Window.get().show( true )`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.frame`: This makes the window frameless when set to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.width / window.height`: This sets the window default size in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.min_width / window.min_height`: This sets a minimal acceptable size
    to the window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.position`: This specifies where the window shall be placed. The value
    can be `null`, `center`, or `mouse`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.resizable`: When set to `true`, this property makes the window resizable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also use the `chromium-args` field to specify the command-line arguments
    that we want to pass to chromium. Here, we set it to `--mixed-context` to switch
    NW.js into the corresponding mode. So, we could access the browser and the NW.js
    API directly from Node.js modules. NW.js introduces Node.js context in addition
    to the browser context and keep them separate. After extending it with NWJS meta-data
    the manifest looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These are just a few preferences set for our simple application. All the available
    options can be found at [https://github.com/nwjs/nw.js/wiki/manifest-format](https://github.com/nwjs/nw.js/wiki/manifest-format).
  prefs: []
  type: TYPE_NORMAL
- en: An HTML prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've just reached the point where we can start templating our application.
    Using HTML and CSS, we will achieve the intended look and feel. Later, we will
    bind JavaScript modules to the acting elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by replacing the content of `index.html` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just defined the page layout with semantically meaningful HTML tags.
    As you can see, we refer to `./assets/css/app.css` that we are about to create.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainable CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start styling, I would like to talk briefly about the importance of
    maintainability in CSS. Despite the fact that CSS is a declarative language, it
    requires no less diligence than any other code in general. When browsing a public
    repository, such as GitHub, you can still find plenty of projects where all the
    styles are put in a single file that is full of code smells ([https://csswizardry.com/2012/11/code-smells-in-css/](https://csswizardry.com/2012/11/code-smells-in-css/))
    and has no consistency in class naming.
  prefs: []
  type: TYPE_NORMAL
- en: Well, it will not be much of a problem at the beginning, but CSS as any other
    code tends to grow. Eventually, you will end up with thousands of lines of rotting
    code often written by different people.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you have to fix the UI element appearance, but you realize that dozens
    of existing CSS declarations across the cascade impact this element. You change
    one, and styles break unpredictably on other elements. So, you will likely decide
    to add your own rules overriding existing styles. After that, you may find out
    that some of the existing rules have a higher specificity, and you will have to
    use brute force through the cascade; every time it is going to be worse.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this maintainability problem, we have to break the entire application
    UI into components and design the CSS code so as to keep them reusable, portable,
    and conflict free; the following heuristics may come in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: Split the whole CSS code into modules that represent components, layouts, and
    states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use classes for styling (not IDs or attributes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid qualified selectors (selectors with tags such as `nav`, `ul`, `li`, and
    `h2`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid location dependency (long selectors such as `.foo`, `.bar`, `.baz`, and
    `article`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep selectors short
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use `!important` reactively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are different methodologies that help to improve CSS maintainability.
    Probably, the most popular approach is **Blocks** **Elements** **Modifiers** (**BEM**).
    It introduces a surprisingly simple, but powerful concept ([https://en.bem.info/methodology/key-concepts/](https://en.bem.info/methodology/key-concepts/)).
    It describes a pattern for class names that encourages readability and portability.
    I believe that the best way to explain it is by an example. Let''s say we have
    a component representing a blog post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In BEM terminology, this markup represents a block that we can define with a
    class name `post`. The block has two elements--`post__title` and `post_time`.
    Elements are integral parts of a block; you cannot use them out of the parent
    block context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now imagine that we have to highlight one post of the list. So, we add a `post--sponsored`
    modifier to the block''s classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At first, class names containing double dashes and underscores may make you
    dizzy, but after a while you will get used to it. The BEM naming convention helps
    developers remarkably by showing indention. So when reading your own or somebody
    else's code, you can quickly figure out by its name what the purpose of a class
    is.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the BEM naming convention, we will use a few ideas from the Pragmatic
    CSS styleguide ([https://github.com/dsheiko/pcss](https://github.com/dsheiko/pcss)).
    We will give names prefixed with `is-` and `has-` to the classes representing
    global states (for example, `is-hidden` and `has-error`); we will prefix layout-related
    classes with `l-` (for example, `l-app`). Finally, we will amalgamate all CSS
    files in two folders (`Component` and `Base`).
  prefs: []
  type: TYPE_NORMAL
- en: Defining base rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, we will create a `Base` directory and place the reset styles in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Base/base.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: For HTML scope, we will enable font smoothing for better font rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will set box sizing of every element (`*`) in `border-box`. The default
    CSS box model is `content-box`, where width and height set to an element do not
    include padding and border. However, if we are setting, let's say, a sidebar width
    `250px`, I would expect it to cover this length. With `border-box`, the box's
    size is always exactly what we set it, regardless of padding or border, but if
    you ask me, the `border-box` mode feels more natural.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will reset indents and markers--for an unordered list--that are used for
    navigation (`nav > ul`). We make body element span the height of the entire viewport
    (`min-height: 100vh`), remove the default margin, and define the font family.'
  prefs: []
  type: TYPE_NORMAL
- en: We will also introduce a global state `is-hidden` that can be applied on any
    element to remove it from the page flow. By the way, that is a good example of
    proactive and, therefore, permissible use of `!important`. By adding an `is-hidden`
    class (with JavaScript), we state that we want the element to hide, with no exceptions.
    Thus, we will never run into a specificity problem.
  prefs: []
  type: TYPE_NORMAL
- en: Defining layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That''s enough for base styles; now, we will start on the layout. First, we
    will arrange the title bar, main section, and footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b48b067-df09-4346-8598-7e78060099b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To achieve this design, we should preferably use Flexbox. If you are not familiar
    with this layout mode, I will recommend the article, *Understanding Flexbox: Everything
    you need to know* ([http://bit.ly/2m3zmc1](http://bit.ly/2m3zmc1)). It provides
    probably the most clear and easy-to-catch-up way of explaining what a Flexbox
    is, what options are available, and how to use them efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can define the application layout like that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/l-app.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We make `.l-app` a flex container that arranges inner items along a cross axis,
    vertically (`flex-flow: column nowrap`). In addition, we request the flex items
    to fill in the full height of the container (`align-items: stretch`). We set the
    title bar and footer to a fixed height always (`flex: 0 0 40px`). However, the
    main section may shrink and grow depending on the viewport size (`flex: 1 1 auto`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have an application layout, let''s define the inner layout for the
    main section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e6327d8-6dc1-4d44-bcb1-2ddc77b39764.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What we need to do is to make items--`dir-list` and `file-list`--to arrange
    horizontally one after another:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/l-main.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we set the flex items to line up along an main axis
    horizontally using `flex-flow: row nowrap`. The `l-main__dir-list` item has a
    fixed width and its width depends on the viewport.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, it''s hard to see any results of our work until we give the components
    some colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/titlebar.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We also colorise the `footer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/footer.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'and the `file-list` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/file-list.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'and eventually the `dir-list` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/dir-list.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only need to include all the modules in the index file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/app.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As it''s done, we launch the application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It launches the application and shows the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29793a5c-e5ee-4901-b083-f3d13c1d5979.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For font sizes and related parameters such as padding, we use relative units
    (em). It means that we set these values relative to the parent font size:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.component { font-size: 10px; } .component__part { font-size: 1.6em; /* computed
    font-size is 10*1.6=16px */ }`'
  prefs: []
  type: TYPE_NORMAL
- en: This trick allows us to efficiently scale components. For example, when using
    the **Responsive Web Design** (**RWD**) approach, we may need to reduce the font
    sizes and spacing proportionally for a smaller viewport width. When using ems,
    we just change font size for a target component, and values of subordinated rules
    will adapt.
  prefs: []
  type: TYPE_NORMAL
- en: Defining CSS variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NW.js releases quite frequently, basically updating with every new version of
    Chromium. That means we can safely use the latest CSS features. The one I'm most
    excited about is called **Custom Properties** ([https://www.w3.org/TR/css-variables](https://www.w3.org/TR/css-variables)),
    which were formerly known as CSS variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, variables are one of the main reasons CSS preprocessors exist. With
    NW.js, we can set variables natively in CSS, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can use the variable instead of real values across all the modules
    in the document scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So if we decide now to change one of defined colors, we need to do it once,
    and any rules relying on the variable receives the new value. Let's adopt this
    technology for our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create definitions for the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Base/defenitions.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define variables representing colors and fixed sizes in the root scope.
    This new file gets included to the CSS index file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/app.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to modify our components. First we take care of the top level
    application layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/l-app.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we layout the main section that consists of two columns with dir and file
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/l-main.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We style the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/titlebar.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And the footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/footer.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to set colors for the child components of the main section. So
    style the file list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/file-list.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'and directory list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/dir-list.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can run the application to observe that it looks the same. All the colors
    and sizes are successfully extrapolated from the variables.
  prefs: []
  type: TYPE_NORMAL
- en: Sticking the title bar and header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The layout looks fine without any content, but what happens to the layout if
    it receives content that is too long?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf75cef3-8c6b-439f-986f-067ab9c7b1bd.png)'
  prefs: []
  type: TYPE_IMG
- en: In fact, we will have a header and footer shifting out of the view when scrolling.
    It doesn't look user-friendly. Fortunately, we can change it easily using another
    fresh addition to CSS called **Sticky positioning** ([https://www.w3.org/TR/css-position-3/#sticky-pos](https://www.w3.org/TR/css-position-3/#sticky-pos)).
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is to modify slightly the title bar component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/titlebar.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'and the footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/footer.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we declared that the title bar will stick to the top
    and footer to the bottom. Run the application now, and you will note that both
    boxes are always visible, regardless of scrolling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e710942-25dd-40f5-b47d-ab66107b65a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Styling the title bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Speaking of the view content, we are ready to populate the layout slots. We
    will start with the title bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we want the current path to be displayed on the left and window
    controls on the right. It can be achieved with Flexbox. It''s a tiny layout that
    won''t be reused, so it won''t hurt if we mix it in the component module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/titlebar.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f6745676-f99a-4c8d-9547-326cb32d1044.png)'
  prefs: []
  type: TYPE_IMG
- en: Styling the directory list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The directory list will be used for navigation through the file system, so
    we will wrap it with the `nav > ul` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To support it with styles, we go with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/dir-list.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we''ve just introduced a couple of variables. Let''s add them in
    the definitions module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Base/definitions.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As we ruin the application we can observe the new contents in the directory
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11a5efa6-e530-4c6d-9712-3a848f5887e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Styling a file list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The file list will be represented as a table, but we will build it out of an
    unordered list. The`./index.html` file contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, here **Grid Layout** ([https://www.w3.org/TR/css3-grid-layout/](https://www.w3.org/TR/css3-grid-layout/))
    would probably suit better; however, at the time of writing, this CSS module was
    not yet available in NW.js. So, we go on again with Flexbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/file-list.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: I believe that everything is clear with the preceding code, except that you
    might not be familiar with the `pseudo-class :not()`. I want to change the color
    and mouse cursor on hover for all the file list items, except the table header.
    So, I achieve it with a selector that can be read like any `.file-list__li` that
    is not `.file-list__head`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following assignment goes to the definitions file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Base/definitions.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As we run the application we can see the table with the file list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/795a6487-fe3a-4393-9b4b-fcb43fae7a37.png)'
  prefs: []
  type: TYPE_IMG
- en: Styling the footer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Eventually, we now reached the footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We arrange the application title to the left and language selector to the right.
    What do we use to lay this out? Obviously, Flexbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/footer.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a special case. We set items to align right in general, but have reset
    it for the `.footer__header` item that snuggles against the left border driven
    by `margin-right: auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da3040e4-fbf6-418e-a825-51513fa803d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While looking at the result, I think it would be nice to emphasize the functional
    meaning of some UI elements with icons. I personally prefer the icon font of **Material
    Design system** ([https://material.io/icons/](https://material.io/icons/)). So,
    as described in the Developer Guide ([http://google.github.io/material-design-icons/](http://google.github.io/material-design-icons/)),
    we include the corresponding Google Web Font to `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'I would suggest that you dedicate a component that will represent an icon and
    fill it with the rule set suggested by Material Design:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/icon.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add an icon anywhere in HTML, as simple as that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Why not then make a folder icon accompanying items in the directory list?:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'I believe that a globe icon will get along nicely with the language selector.
    So we modify the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'and we add a class in the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/footer.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As we run the application we can see an icon rendered next to the language
    selector control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b909a6d5-3d0d-46d4-ab5c-19e5cc8e82f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If something went wrong after running the application, you can always call
    for Developer Tools--just press *F12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0aac4d8b-a258-47b0-a736-74be5e385114.png)'
  prefs: []
  type: TYPE_IMG
- en: Fulfilling the functional requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve described the semantic structure of our application with HTML. We have
    defined with CSS how our UI elements shall look. Now, we will teach our application
    to retrieve and update the content as well as to respond to user events. Actually,
    we will allocate the following tasks to several modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DirService`: This provides control on directory navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileService`: This handles file operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileListView`: This updates the file list with the data received from DirService,
    handles user events (open file, delete file, and so on) using FileService'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DirListView`: This updates the directory list with the data received from
    DirService and handles navigation events using DirService'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TitleBarPath`: This updates the current location with the path received from
    DirService'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TitleBarActions`: This handles user iteration with title bar buttons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LangSelector`: This handles user iteration with language selector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, before we start coding, let's see what we have in our arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: NW.js gets distributed together with the latest stable version of Node.js, which
    has a great support for ES2015/ES2016 ([http://node.green](http://node.green)).
    It means that we can use any of the inherent new JavaScript features, but modules
    ([http://bit.ly/2moblwB](http://bit.ly/2moblwB)). Node.js has its own CommonJS-compliant
    module loading system. When we request a module by path, for example, `require(
    "./foo" )`, the runtime searches for a corresponding file (`foo.js`, `foo.json`,
    or `foo.node`) or a directory (`./foo/index.js`). Then, Node.js evaluates the
    module code and returns the exported type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a module that exports a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./foo.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'and another one, which imports from the first module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./bar.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run it, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: One should note here that regardless of how many times we require a module,
    it gets executed just once, and every time, its exports are taken from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with ES2015
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I have already mentioned, NW.js provides a complete support of JavaScript
    of ES2015 and ES2016 editions. To understand what it really means, we need a brief
    excursion into the history of the language. The standardized specification for
    JavaScript was first released in 1997 (ECMA-262 1st Edition).
  prefs: []
  type: TYPE_NORMAL
- en: Since then, the language has not really changed for 10 years. The 4th edition
    proposed in 2007 called for drastic changes. However, the working group (TC39)
    failed to agree on the feature set. Some proposals have been deemed unsound for
    the Web, but some were adopted in a new project code named Harmony. The project
    turned into the 6th edition of the language specification and was released in
    2015 under the official name ES2015\. Now, the committee is releasing a new specification
    every year.
  prefs: []
  type: TYPE_NORMAL
- en: New JavaScript is backward compatible with an earlier version. So, you can still
    write code with the syntax of the ECMAScript 5th edition or even 3rd one, but
    why should we lose the opportunity to work with the new advanced syntax and feature
    set? I think it would be helpful if we now go through some new language aspects
    that will be used in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the old days, we used to always go with the `var` statement for variable
    declarations. ES2015 introduces two new declaration variables--`let` and `const`.
    The `var` statement declares a variable in a function scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A variable declared with `var` (`foo`) spans the entire function scope, meaning
    that every time we reference it by name, we target the same variable. Both `let`
    and `const` operate on block scopes (`if` statement, `for/while` loops, and so
    on) as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding example, we can declare a new variable in
    a block and it will exist only within that block. The statement `const` works
    the same, except it defines a constant that cannot be reassigned after it was
    declared.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript implies a prototype-based, object-oriented programming style. It
    differs from class-based OOP that is used in other popular programming languages,
    such as C++, C#, Objective-C, Java, and PHP. This used to confuse newcomer developers.
    ES2015 offers a syntactic sugar over the prototype, which looks pretty much like
    canonical classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declare a `Machine` class that during instantiation assigns a value
    to a prototype property, `name`. A `Robot` class extends `Machine` and, therefore,
    inherits the prototype. In subtype, we can invoke the parent constructor with
    the `super` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: We also define a prototype method--`move`--and a static method--`normalizeDirection`.
    The `move` method has a so-called **default function parameter**. So, if we omit
    the direction argument while calling move method, the parameter automatically
    sets to `"left"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ES2015, we can use a short syntax for the methods and do not need to repeat
    function keywords with every declaration. It''s also available for object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The template literal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another great addition to JavaScript is **template literals**. These are string
    literals that can be multiline and can include interpolated expressions (``${expression}``).
    For example, we can refactor our move method body, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getters and setters were added back in ES5.1\. In ES2015, it was extended for
    computed property names and goes hand in hand with a short method notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function declaration also obtained syntactic sugar. We write it now with
    a shorter syntax. It''s remarkable that a function defined this way (fat arrow
    function) automatically picks up the surrounding context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: When using old function syntax, the callback function passed to an array's method,
    `find`, would lose the context of the `Robot` instance. Arrow functions, though,
    do not create their own context and, therefore, outer context (`this`) gets in
    the closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this particular example, as it often goes with array extras, the callback
    body is extremely short. So, we can use an even shorter syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In new JavaScript, we can extract specific data from arrays and objects. Let''s
    say, we have an array that could be built by an external function, and we want
    its first and second elements. We can extract them as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: So here, we declare two new constants--`r2d2` and `c3po`--and assign the first
    and the second array elements to them, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do the same with objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: What did we do? We declared two constants--`occupation` and `homeworld`--that
    receive values from correspondingly named object members.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is more, we can even alias an object member while extracting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In the last example, we delegated the values of object members--`occupation`
    and `homeworld`--to newly created constants--`affair` and `home`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling windowing actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Coming back to the `file-explorer`, we can start with the `TitleBarActions`
    module that listens to user click events on title bar buttons and performs the
    corresponding windowing action. First, we need to mark the action nodes in HTML.
    The `./index.html` file contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we specify our bounding box (`data-bind="titlebar"`) and the close window
    button (`data-bind="close"`). Let''s begin with the only button. The `./js/View/TitleBarActions.js`
    file contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a `TitleBarActionView` class that accepts an HTML element as
    a parameter. This element represents the view bounding box, meaning that the instance
    of this class will take care only of the passed in element and its descendants.
    During construction, the class will search for the first element in the scope
    of the bounding box that matches `selector [data-bind=close]`--the close window
    button of the title bar. In the `bindUI` method, we subscribe for clicks events
    on the Close button. When the button is clicked, the `onClose` method is called
    in the context of a `TitleBarActionView` instance, as we bound it in `bindUi`
    (`this.onClose.bind( this )`). The `onClose` method closes the window using the
    NW.js Window API ([http://docs.nwjs.io/en/latest/References/Window/](http://docs.nwjs.io/en/latest/References/Window/)),
    namely it requests a current window object `nw.Window.get()` and calls its close
    method.
  prefs: []
  type: TYPE_NORMAL
- en: NW.js doesn't provide a module for the API, but exposes the `nw` variable in
    the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have the first view module and can use it the main script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Here, we import the `TileBarActionView` class from the `./js/View/TitleBarActions`
    module and make an instance of it. We pass the first document element matching
    selector `[data-bind=titlebar]` to the class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed that we used destructuring while importing from the module?
    Particularly, we extracted the `TitleBarActionsView` class into a respectively
    called constant.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can launch the application and observe, as clicking on the close button
    really closes the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further, we take care of other title bar buttons. So, we adapt our `index.html`
    file to identify the buttons, nodes with `unmaximize`, `maximize`, and `minimize`
    values for the `data-bind` attribute. Then, we collect in the `TileBarActionView`
    constructor references to the corresponding HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we have to add new listeners in the `bindUi` module, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The handler for minimizing the window button looks pretty much the same as
    the one we have already examined previously. It just uses the corresponding method
    of the NW.js Window API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'With maximize and minimize (restore) window buttons, we need to take the fact
    that while one button is visible the second one shall be hidden into account.
    This we achieve with the `toggleMaximize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Event handler for these buttons calls this method to the toggle buttons view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Writing a service to navigate through directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other modules, such as `FileListView`, `DirListView`, and `TitleBarPath`, consume
    the data from the filesystem, such as directory list, file list, and the current
    path. So we need to create a service that will provide this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/Dir.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we import Node.js core module `fs` that provides us access to
    the filesystem. We also extract functions--`join` and `parse`--from the `path`
    module. We will need them for manipulations in the file/directory path.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we declare the `DirService` class. On construction, it creates a `dir`
    property, which takes either a passed-in value or the current working directory
    (`process.cwd()`). We add a static method--`readDir`--to the class that reads
    the directory content on a given location. The `fs.readdirSync` method retrieves
    the content of a directory, but we extend the payload with file/directory stats
    (`https://nodejs.org/api/fs.html#fs_class_fs_stats`). In case the stats cannot
    be obtained, we replace its array element with `false`. To avoid such gaps in
    the output array, we will run the array `filter` method. Thus, on the exit point,
    we have a clean array of filenames and file stats.
  prefs: []
  type: TYPE_NORMAL
- en: The `getFileList` method requests `readDir` for the current directory content
    and filters the list to leave only files in there.
  prefs: []
  type: TYPE_NORMAL
- en: The `getDirList` method filters, evidently, the list for directories only. Besides,
    it prepends the list with a `..` directory for upward navigation, but only if
    we are not in the system root.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can get both lists from the modules consuming them. When the location
    changes and new directory and file lists get available, each of these modules
    have to update. To implement it, we will use the observe pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/Dir.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We export from events, core module the `EventEmitter` class (`https://nodejs.org/api/events.html`).
    By extending it with `DirService`, we make the service an event emitter. It gives
    us the possibility to fire service events and to subscribe on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: So whenever the `setDir` method is called to change the current location, it
    fires an event of type `"update"`. Given the consuming modules are subscribed,
    they respond to the event by updating their views.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've written a service and assume that it fulfills the functional requirements,
    but we do not know it for sure, yet. To check it, we will create a unit-test.
  prefs: []
  type: TYPE_NORMAL
- en: We do not have any test environment so far. I would suggest going with the **Jasmine**
    test framework ([https://jasmine.github.io/](https://jasmine.github.io/)). We
    will create in our `tests/unit-tests` subfolder a dedicated NW.js project, which
    will be used for the testing. This way, we get the runtime environment for tests,
    identical to what we have in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we create the test project manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./tests/unit-tests/package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: It points at the Jasmine test runner page, the one we placed next to `package.json:`
  prefs: []
  type: TYPE_NORMAL
- en: '`./tests/unit-tests/specs.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: What does this runner do? It loads Jasmine, and with help of the `fs-jetpack`
    npm module ([https://www.npmjs.com/package/fs-jetpack](https://www.npmjs.com/package/fs-jetpack)),
    it traverses the source directory recursively for all the files matching `"*.spec.js"`
    pattern. All these files get added to the test suite. Thus, it assumes that we
    keep our test specifications next to the target source modules.
  prefs: []
  type: TYPE_NORMAL
- en: '`fs-jetpack` is an external module, and we need to install the package and
    add it to the development dependencies list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Jasmine implements a wide-spread, frontend development testing paradigm **Behavior-driven
    Development** (**BDD**) that can be described with the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'As it is generally accepted in unit testing, a suite may have setup and teardown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'When testing a service that touches the filesystem or communicates across the
    network or talks to databases, we have to be careful. A good unit test is independent
    from the environment. So, to test our `DirService`, we have to mock the filesystem.
    Let''s test the `getFileList` method of the service class to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/Dir.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Before running a test, we point the `fs` method to a virtual filesystem with
    the folder `/foo/bar/` that contains the `baz` and `qux` files. After every test,
    we restore access to the original filesystem. In the first test, we instantiate
    the service on the `foo/bar` location and read the content with the `getFileList()`
    method. We assert the number of found files as `2` (as we defined in `beforeEach`).
    In the second test, we take the first element of the list and assert that it contains
    the intended filename and stats.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we use an external npm package ([https://www.npmjs.com/package/mock-fs](https://www.npmjs.com/package/mock-fs))
    for mocking, we need to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'As we came up with the first test suite, we can modify our project manifest
    file for a proper test runner script. The `./package.json` file contains the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'NW.js will load and render the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/379b57ff-9df5-41cb-ba06-0ee2106eb355.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Ideally, unit tests cover all the available functions/methods in the context.
    I believe that from the preceding code you will get an idea of how to write the
    tests. However, you may stumble over testing the `EventEmitter` interface; consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '`EventEmitter` works asynchronously. When we have asynchronous calls in the
    test body, we shall explicitly inform Jasmin when the test is ready so that the
    framework could proceed to the next one. That happens when we invoke the callback
    passed to its function. In the preceding sample, we subscribe the `"update"` event
    on the service and call `notify` to make it fire the event. As soon as the event
    is captured, we invoke the `done` callback.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing view modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, we have the service, so we can implement the view modules consuming it.
    However, first we have to mark the bounding boxes for the view in the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The DirList module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What are our requirements for the `DirList` view? It renders the list of directories
    in the current path. When a user selects a directory from the list, it changes
    the current path. Subsequently, it updates the list to match the content of the
    new location:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/DirList.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: In the class constructor, we subscribe for the `DirService` `"update"` event.
    So, the view gets updated every time the event fired. Method update performs view
    update. It populates the bounding box with list items built of data received from
    `DirService` . As it is done, it calls the `bindUi` method to subscribe the `openDir`
    handler for click events on newly created items. As you may know, `Element.querySelectorAll`
    returns not an array, but a non-live `NodeList` collection. It can be iterated
    in a `for..of` loop, but I prefer the `forEach` array method. That is why I convert
    the `NodeList` collection into an array.
  prefs: []
  type: TYPE_NORMAL
- en: The `onOpenDir` handler method extracts target directory name from the `data-file`
    attribute and passes it to `DirList` in order to change the current path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have new modules, so we need to initialize them in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Here, we require new acting classes, create an instance of service, and pass
    it to the `DirListView` constructor together with a view bounding box element.
    At the end of the script, we call `dirService.notify()` to make all available
    views update for the current path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run the application and observe as the directory list updates as
    we navigate through the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Unit-testing a view module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Seemingly, we are expected to write unit test, not just for services, but for
    other modules as well. When testing a view we have to check whether it renders
    correctly in response to specified events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/DirList.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: If you might remember in the test runner HTML, we had a hidden `div` element
    with `sandbox` for id. Before every test, we populate that element with the HTML
    fragment the view expects. So, we can point the view to the bounding box with
    the sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: After creating a view instance, we can call its methods, supplying them with
    an arbitrary input data (here, a collection to update from). At the end of a test,
    we assert whether the method produced the intended elements within the sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding test for simplicity's sake, I injected a fixture array straight
    to the update method of the view. In general, it would be better to stub `getDirList`
    of `DirService` using the **Sinon** library ([http://sinonjs.org/](http://sinonjs.org/)).
    So, we could also test the view behavior by calling the notify method of `DirService`--the
    same as it happens in the application.
  prefs: []
  type: TYPE_NORMAL
- en: The FileList module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The module handling the file list works pretty similar to the one we have just
    examined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/FileList.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, in the constructor, we again subscribed the `"update"`
    event, and when it was captured, we run the update method on a collection received
    from the `getFileList` method of `DirService`. It renders the file table header
    first and then the rows with file information. The passed-in collection contains
    raw file sizes and modification times. So, we format these in a human-readable
    form. File size gets beautified with an external module--`filesize` ([https://www.npmjs.com/package/filesize](https://www.npmjs.com/package/filesize))--and
    the timestamp we shape up with the `formatTime` static method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Certainly, we shall load and initialize the newly created module in the main
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The title bar path module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So we have a directory and file lists responding to the navigation event, but
    the current path in the title bar is still not affected. To fix it, we will make
    a small view class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/TitleBarPathView.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: You can note that the class simply subscribes for an update event and modifies
    the current path accordingly to `DirService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get it live, we will add the following lines to the main script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So we've made it to the milestone and have now a working version of the File
    Explorer providing basic functionality. What have we achieved so far?
  prefs: []
  type: TYPE_NORMAL
- en: 'We went together though the traditional development routine: we planned, sketched,
    set up, templated, styled, and programmed. On the way, we discussed the best practices
    of writing maintainable and conflict-free CSS. We have discovered that NW.js enables
    the features of the latest CSS and JavaScript specifications. So while refactoring
    our CSS code, we exploited new aspects, such as custom properties and position
    sticky. We also had a tour of the basics of ES2015, which helped us to build our
    JavaScript modules in a cleaner syntax using classes, arrow functions, destructuring,
    and block scope declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: What is more, we explored a few of the goodies normally unavailable in the browser,
    such as Node.js core and external modules, and the desktop environment integration
    API. Thus, we were able to access the filesystem and implement windowing actions
    (close, minimize, maximize, and restore). We made a service extending Node.js
    EventEmitter and incorporated the event-based architecture to serve our needs.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't forget about unit-testing. We set up Jasmine testing runner and discussed
    the essentials of BDD specifications. While writing the application unit tests,
    we examined an approach to mock the filesystem and one to test **Document Object
    Model** (**DOM**) manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Evidently, there's still much left for the second chapter, where we will augment
    the existing functionality, dive deeper into NW.js API, and go through the preproduction
    steps. Yet, I hope that you have already accrued a grasp on NW.js and HTML5 desktop
    development basics. See? It doesn't differ much from traditional web development
    after all, just unlocks new exciting possibilities.
  prefs: []
  type: TYPE_NORMAL

- en: 'Creating RSS Aggregator with Electron, TypeScript , React, and Redux: Planning,
    Design, and Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wading through the previous chapters, we created an application with pure JavaScript,
    React and React + Redux. We are now coming to the optimal technology stack for
    large scalable web applications--TypeScript + React + Redux. We are going to develop
    the RSS Aggregator. I find it a good example to show TypeScript in action as well
    as to examine asynchronous actions. Besides, you will learn to use a new component
    library, React MDL. We will also extend it with custom styles written in SASS
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Application blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We develop a typical tool that aggregates syndicated content from a manageable
    list of sources. If we split the requirements into user stories, we will get something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: As a user, I can see the list of earlier added sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can see the aggregated content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can filter the content items by selecting a source in the menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s again use **WireframeSketcher** ([http://wireframesketcher.com/](http://wireframesketcher.com/))
    and put it on a wireframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28b5d0ec-abbb-4bb7-88cc-e860dd4d1059.png)'
  prefs: []
  type: TYPE_IMG
- en: As a user, I can open the item link next to the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4a27075f-f019-4693-9055-72eeb410078f.png)'
  prefs: []
  type: TYPE_IMG
- en: As a user, I can add a source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can remove a source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can update aggregated content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0969303e-c65b-496e-a481-e123b717a0e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Welcome to TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working on a large scalable application, it's essential that established
    architecture has been followed by all the team members. In other languages, such
    as Java, C++, C#, and PHP, we can declare types and interfaces. So, no one can
    go with a new functionality unless it fully satisfies the interface intended by
    the system architect. JavaScript has neither strict types nor interfaces. That
    why, in 2012, engineers of Microsoft developed a superset of JavaScript (ES2015)
    called **TypeScript.** This language extends JavaScript with optional static typing
    and compiles back to JavaScript, so is acceptable by any browser and operating
    system. It is similar to how we compile ES.Next to ECMAScript of the fifth edition
    with Babel, but in addition, brings us features that are unlikely to be integrated
    into ECMAScript in the foreseeable future. The language is exceptionally great
    and is documented at [https://www.typescriptlang.org/docs/home.html](https://www.typescriptlang.org/docs/home.html)
    and provided with an excellent specification [http://bit.ly/2qDmdXj](http://bit.ly/2qDmdXj).
    The language is supported by the mainstream IDEs and code editors, and can be
    integrated through plugins in automation tools, such as Grunt, Gulp, Apache Maven,
    Gradle, and others. Some major frameworks are considering migrating to TypeScript,
    while Angular 2+ and Dojo 2 have already embraced it. Other frameworks expose
    their interfaces to TypeScript through definition files.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively for static type checking, one can go with **Flow** ([https://flow.org](https://flow.org))
    by Facebook. Unlike TypeScript, Flow is no compiler, but a checker. Basic typings
    in Flow are pretty similar to the ones of TypeScript, achieved by almost the same
    syntax. Flow also introduces advanced types, such as array, union, intersection,
    and generics, but does it in its own ways. According to Facebook, they created
    Flow because "TypeScript isn't built around bug finding as much as they wanted."
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment for TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript makes alluring promises regarding one''s development experience.
    Why not fiddle with the code to see it in practice? First, we have to create a
    dedicated directory for upcoming samples. We initialize the project by running
    `npm init -y` and install `typescript` as a dev dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the manifest `scripts` section, we add a command to compile sources with
    TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to let TypeScript know what exactly we want from it. We will describe
    that in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tsconfig.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set the TypeScript compiler to search for `ts` sources anywhere within
    the project directory except `node_modules`. In `compilerOptions`, we specify
    how we want it to treat our sources during compilation. Field `target` is set
    in `ES6`, meaning TypeScript will compile into the ES6/ES2016 syntax, which is
    already fully supported in all the modern browsers. In the field `module`, we
    have `CommonJS`. Thus, TypeScript will bundle sources into CommonJS-compliant
    modules that play nicely with the Node.js environment. With the field `moduleResolution`,
    we choose in favor of the Node.js modules resolution style. In the field `outDir`,
    we determine where TypeScript will store the compiled modules. More information
    about compiler options is available at [http://bit.ly/2t9fckV](http://bit.ly/2t9fckV).
  prefs: []
  type: TYPE_NORMAL
- en: Basic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The development environment now seems ready, so we can try it out with an elementary
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`example.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We use the type annotation feature of TypeScript to set a constraint on the
    variable. That's so easy; we just extend the declaration with the so-called **declaration
    space** like `:type`, where type can be one of the basic types (boolean, number,
    string, array, void, any, and a few others), class, interface, type alias, enum,
    and import. Here, we applied `string`, meaning title accepts only strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'After compiling with `npm run build`, we can find file `example.js` in the
    `./build` directory with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build/example.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You see it doesn't do much; it simply removes the type hinting. That's something
    amazing about TypeScript - type checking happens at compilation time and disappears
    by runtime. So, we benefit from TypeScript without any impact on the application's
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, let''s do a nasty thing and set a value to the variable violating the
    given constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '`example.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'On compilation, we receive an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Hmm; TypeScript warns us when we do something wrong. What is even more exciting
    is if your IDE supports TypeScript, you get notified on the fly while typing.
    I suggest to check against the list [http://bit.ly/2a8rmTl](http://bit.ly/2a8rmTl)
    and pick up the most suitable IDE for you if, by chance, yours isn't there. I
    would recommend **Alm** ([http://alm.tools](http://alm.tools)) as a great example
    of using TypeScript, React, and Redux together. However, I, myself, pulled in
    **NetBeans** ([https://netbeans.org/](https://netbeans.org/)) a decade ago and
    it has never disappointed me. It does not have native TypeScript support, but
    one can easily get it by installing the **TypeScript Editor plugin** ([https://github.com/Everlaw/nbts](https://github.com/Everlaw/nbts)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s play with type annotation more. We take a function and define a contract
    for entry and exit points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`example.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, we state here that the function accepts two numbers and shall return
    a number. Now, if we even think of giving the function any type different from
    number, the IDE immediately alerts us about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4711d30-5ae2-4723-abea-9a9d85bfdf83.png)'
  prefs: []
  type: TYPE_IMG
- en: Array, plain objects, and indexable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, I believe, with primitive types, it''s more or less clear, but what about
    the others, for example, arrays? By combining basic type with `[]`, we define
    an array type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we declare the variable `arr` that is an array of string. We can achieve
    the same with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can do it with interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'While declaring the `StringArray` interface by using the so-called **index
    signature**, we set constraints on the type structure. It accepts numeric indexes
    and string values. In other words, it''s a string array. We can go further and
    set a constraint on the array length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As for plain objects, we can go with an interface describing the intended shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we can set constraints inline with the object type literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are able to declare a value object ([http://bit.ly/2khKSBg](http://bit.ly/2khKSBg)),
    we need to ensure immutability. Fortunately, TypeScript allows us to specify that
    members of an object are `readonly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access a percentage, for example, red in a color of the `RGB` type.
    But we cannot change the RGB levels for a declared color. If we try this, we will
    get an error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For an object of arbitrary properties, we can use an index signature to target
    string keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in `DataMap`, we set `any` for member type. By this, we allow any
    value types.
  prefs: []
  type: TYPE_NORMAL
- en: Function type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can set constraints on a function by using the function type literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'I find it quite discouraging and prefer to use interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You may now ask, what if the function has optional parameters? TypeScript makes
    it very simple to define an optional parameter. You just need to append the parameter
    with a question mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We made `description` optional, so we can call the function both ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: None of these violates the declared interface; so far, we give it string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In pretty much the same way, we can define optional object members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Class type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In other languages, we are used to considering interfaces as closely related
    to classes. TypeScript brings a similar development experience. What is more,
    while Java and PHP interfaces cannot contain instance properties, TypeScript has
    no such limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With the advance of ES2015/2016, classes are used widely in JavaScript. Yet,
    TypeScript allows us to set member accessibility. So, we declare a member as `public`
    when we permit access to it from the code consuming object instance. We use `private`
    to ensure the member will not be accessible outside its containing class. In addition,
    the `protected` members are similar to `private`, except they can be accessed
    in any of the derived class instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the value for `speed` is hardcoded. It would be just proper
    if our class could be configured for the initial speed during initialization.
    Let''s do the refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use another nice feature of TypeScript that I am personally excited
    about. It's called **parameter property**. We often declare private properties
    and populate them from constructor parameters. In TypeScript, we can simply prepend
    the parameter with an accessibility modifier and it will result in a respectively
    named property taking in the value of the parameter. So, in the previous code,
    using `private speed` in the parameter list, we declare the `speed` parameter
    and assign a passed in value to it. By using the ES6 syntax for the default parameter,
    we set `speed` to zero when nothing has passed in the constructor `constructor(
    speed = 0 )`.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to what you might be used to in other languages, in TypeScript, we
    can use abstract classes and methods. The abstract class is meant only for extending.
    One cannot create instances of the abstract class. Methods defined as abstract
    are required for implementation in any subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Abstract classes are quite similar to interfaces, except a class can implement
    multiple interfaces, but extend only one abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: Enum type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time after time, we use constants to define a set of logically related entities.
    With TypeScript, we can declare an enumerated type populated with immutable data
    and then refer to the whole set by the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we declare a type `Status` that accepts one of the predefined values
    (`NEEDS_PATCH`, `UP_TO_DATE`, and `NOT_INSTALLED`). The function `setStatus` expects
    the `status` parameter to be of the `Status` type. If you pass in any other value,
    TypeScript reports an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use a string literal type that refers to any string value
    of a group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Union and intersection types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Interesting so far, isn''t it? What would you say then to it: in TypeScript,
    we can refer to multiple types at once. For example, we have two interfaces `Anakin`
    and `Padm√©` and need a new type (`Luke`) that inherits from both of them. We can
    achieve it as easily as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides, we can do the intersection without explicitly declaring the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We can also define a union type that allows any type of a group. You know the
    `jQuery` library, right? The function `jQuery` accepts for a selector parameter
    a number of diverse types and returns the `jQuery` instance. How could it possibly
    be covered with an interface?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When a function returns a type depending on a passed-in type, we can declare
    an interface that describes all the possible use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A function implementing this interface accepts a string for the `tagName` parameter.
    If the value is `"button"`, the function returns the `Button` element. If `"a"`,
    then it returns the `Anchor` element.
  prefs: []
  type: TYPE_NORMAL
- en: One can find available DOM-related interfaces in the specification at [https://www.w3.org/TR/DOM-Level-2-HTML/html.html](https://www.w3.org/TR/DOM-Level-2-HTML/html.html).
  prefs: []
  type: TYPE_NORMAL
- en: Generic type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The types we have just examined refer to a concrete type combination. In addition,
    TypeScript supports a so-called **generic type** that helps reusing the once created
    interface in different contexts. For example, if we want an interface for a data
    map, we can make it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'But this `NumberDataMap` accepts only numbers for the member values. Let''s
    say, for string values, we have to create a new interface, such as `StringDataMap`.
    Alternatively, we can declare a generic `DataMap` that sets an arbitrary value
    type constraint when referred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Global libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yeah, TypeScript is, indeed, an impressive language when it comes to writing
    a new code. But what about existing none-TypeScript libraries? For example, we
    are going to use React and Redux modules. They are written in JavaScript, not
    in TypeScript. Luckily, mainstream libraries are already provided with TypeScript
    declaration files. We can install these files per module using npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we try something stupid with any of these modules, we get immediately
    notified about the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'On compiling or even while typing, you will get the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Fair enough; instead of the HTML element (for example, `document.getElementById(
    "root" )`) I passed to `ReactDOM.render` a string as the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, to be honest, not every library is provided with TypeScript declarations.
    For example, in the *RSS Aggregator* application, I am going to use the `feedme`
    library ([https://www.npmjs.com/package/feedme](https://www.npmjs.com/package/feedme))
    to fetch and parse RSS by a URL. As it happens, the library has no declaration
    file. Fortunately, we can quickly create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`feedme.d.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The module `feedme` exposes a class `FeedMe`, but TypeScript doesn't know about
    these modules; it is not yet declared in the TypeScript scope. So, we use ambient
    declaration in `feedme.d.ts (declare class FeedMe)` to introduce a new value in
    the scope. We state the class constructor that accepts an optional flag of the
    type `boolean` and returns the Node.js `WriteStream` object. We use overloading
    to describe two cases of function usage. In the first, it receives a string `"title"`
    for `event` and expects a callback for handling the RSS title. In the second,
    it takes in the event `"title"` and then expects a callback to handle the RSS
    entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can consume the newly created declaration file from the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Using a triple-slash directive, we include `feedme.d.ts` in the project. After
    it's done, TypeScript validates if `FeedMe` is used according to its interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating static prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I assume, at this point, we are quite enough into TypeScript to start with the
    application. As with to the previous examples, first what we do is the static
    prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment for the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to set up our development environment for the project. So, we dedicate
    a directory and put the following manifest there:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As requested by any Electron application, we set the path to our main process
    script in the `main` field. We also define scripts commands to run Webpack for
    building and for watching. We set one scripts command for running the application
    with Electron. Now, we can install the dependencies. We definitely need TypeScript,
    as we are going to build the application using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For bundling, we will use Webpack as we did for Chat and for Screen Capturer
    applications, but this time, instead of `babel-loader`, we go with `ts-loader`,
    because our sources are in the TypeScript syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We also install Electron and the accompanying modules that we already examined
    while creating the Chat application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we install the React declaration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to access interfaces of Node.js, we also install the corresponding
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can configure Webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./webpack.config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here we set the entry script as `app/ts/index.tsx` and `./app/build/js/bundle.js`
    as the output. We target Webpack on Electron (`electron-renderer`) and enable
    source map generation. Finally, we specify a rule, that makes Webpack process
    any `.ts`/`.tsx` files with the `ts-loader` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we request a file, such as `require("./path/file.ts")` or `import {member}
    from "./path/file.ts"`, Webpack will compile it with TypeScript during the bundling.
    We can make it more convenient using the Webpack option `resolve`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./webpack.config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we state that any encountered module name Webpack tries to resolve against
    both `node_modules` and `app/ts` directories. So, if we access a module like that,
    we will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'According to our configuration, Webpack first checks the existence of `node_modules/file.ts`
    and then `app/ts/file.ts`. Since we enlisted the `.ts` extension as resolvable,
    we can omit it from the module name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s left is just configuration for TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tsconfig.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty much the same as we created for the TypeScript introduction examples,
    except that, here, we do not point the compiler to a directory, but explicitly
    to the entry script. We also inform the compiler that it shall expect JSX.
  prefs: []
  type: TYPE_NORMAL
- en: React-MDL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, while working on Screen Capturer, we examined the component library
    Material UI. That''s not the only implementation of material design available
    for React. This time, let''s try another one--**React MDL** ([https://react-mdl.github.io/react-mdl/](https://react-mdl.github.io/react-mdl/)).
    So, we install the library and the accompanying declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the documentation, we enable the library via imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Oh! Oh! Webpack won''t be able to resolve the CSS module until we configure
    it accordingly. First, we have to tell Webpack to look for `react-mdl/extra/material.css`
    and `react-mdl/extra/material.js` in the `node_modules` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we add a rule to handle CSS with the `css-loader` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./webpack.config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, now, when meeting `import "react-mdl/extra/material.css"`, Webpack loads
    the styles and embeds them into the page. But within the CSS content, there are
    links to a custom `.woff` fonts. We need to make Webpack load the referred font
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./webpack.config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to install both the mentioned loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Creating the index.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we usually take care of in the Electron application is the main
    process script that basically creates the application window. For this application,
    we do not introduce any new concepts about it, so we can reuse `main.js` of the
    Chat application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `index.html` will be very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we load Google's Material Icons font and declare out the bounding
    element (`div#root`). Of course, we have to load the generated by the Webpack/TypeScipt
    JavaScript. It is located at `build/js/bundle.js,`, exactly as we configured it
    in `./webpack.config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we compose the entry script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/index.tsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you see, it's similar to what we had in the Screen Capturer static prototype,
    except for importing React-MDL assets. As for TypeScript, it doesn't really require
    any changes in the code. Yet, now we definitely have typed interfaces for the
    module we use (`./node_modules/@types/react-dom/index.d.ts`), meaning if we violate
    a constraint, for example, of `ReactDOM.render`, we get an error.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the container component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create the `container` component that we referred to in the entry
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Containers/App.tsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, we import the components `Layout` and `Content` from the React-MDL library.
    We use them to layout our custom components `TitleBar`, `Menu`, and `Feed`. According
    to the React declaration file `(./node_modules/@types/react/index.d.ts`), `React.Component`
    is a generic type, so we have to provide it with interfaces for the state and
    props `React.Component<IState, IProps>.` In the static prototype, we have neither
    states nor props, so we can go with empty types.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the TitleBar component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next component will represent the title bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Components/TitleBar.tsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set up the look and feel using the `Header`, `Navigation`, and `Icon`
    components of React MDL and subscribe for the click event on the close icon. Furthermore,
    we import the `remote` object of the `electron` module and, by using the `getCurrentWindow`
    method, we access the current window object. It has the method `close` that we
    apply to close the window.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Menu` component will contain the list of aggregated feeds. With the buttons
    `add` and `remove`, users will be able to manage the list. The button `autorenew`
    serves to update all the feeds.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Menu component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to keep the feed menu in the `Drawer` component of React MDL that
    shows up automatically on wide screens and hides in the burger menu on smaller
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./ts/Components/Menu.tsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Creating the feed component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we take care of the main section where we are going display active
    feed content:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Components/Feed.tsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the `.feed-list` container, we display the list of RSS items, each wrapped
    with the `Card` component of React MDL. The container `.feed-contents` is a placeholder
    for the item content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything is ready. We can build and start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6d5f4f5-5d11-4fc4-ba26-2c08655f35b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding custom styles with SASS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Seemingly, the resulting UI needs additional styling. I suggest that we code
    our custom styles in SASS:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/sass/app.scss`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we make the top level element (`./app/ts/Containers/App.tsx`)
    always adapt to the actually window height.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, we declare a variable for the fixed height of the title bar and set
    the layout for feed items and item content containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/sass/app.scss`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Initially, the width of the feed items container (`.feed-list`) is 100%, while
    item content one (`.feed-contents`) is hidden (`width:0`). When the parent container
    (`.feed-index`) receives the new state with the `is-open` class, both the child
    containers shift to `50%` width gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we layout the action buttons in the Menu component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/sass/app.scss`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, we have introduced a new source type (SASS), so we have to adjust the
    Webpack configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./webpack.config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, Webpack accepts `.scss` module names and look for the source in `app/sass`.
    We also have to configure Webpack to compile SASS in CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./webpack.config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we determine that, when resolving the `.scss` file, Webpack uses the
    `sass-loader` plugin to convert SASS to CSS and then `css-loader` and `style-loader`
    to load the generated CSS. So, we now have a missing dependency - `sass-loader`;
    let''s install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This module relies on the `node-sass` compiler, so we need it also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Why not to check what we get. So we build and start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The application looks better now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8abe2f4f-53e7-4037-ba53-f9dac45751a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dived into TypeScript. We examined basic types in variable
    declarations and in parameter constraints. We fiddled with interfaces for arrays
    and plain objects. You learned to interface functions and classes. We took note
    of abstraction features, such as member accessibility modifiers, parameter property,
    abstract classes, and methods. You learned to handle group entities with the enum
    type and string literals. We examined the reuse of interfaces with generic type.
    We have also seen how to install TypeScript declarations for global libraries
    and how to write our own when none is available. We started to work on the application.
    So, we set up Webpack to find and process the `.ts`/`.tsx` modules as well as
    to load CSS and web fonts. We used components of the React MDL library to create
    the UI. We extended the Webpack configuration with the SASS loader to process
    our custom styles. We ended up with a working static prototype.
  prefs: []
  type: TYPE_NORMAL

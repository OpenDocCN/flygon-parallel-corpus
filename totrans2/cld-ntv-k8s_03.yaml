- en: '*Chapter 2*: Setting Up Your Kubernetes Cluster'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains a review of some of the possibilities for creating a Kubernetes
    cluster, which we'll need to be able to learn the rest of the concepts in this
    book. We'll start with minikube, a tool to create a simple local cluster, then
    touch on some additional, more advanced (and production-ready) tools and review
    the major managed Kubernetes services from public cloud providers, before we finally
    introduce the strategies for creating a cluster from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Options for creating your first cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: minikube – an easy way to start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed services – EKS, GKE, AKS, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubeadm – simple conformance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kops – infrastructure bootstrapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubespray – Ansible-powered cluster creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a cluster completely from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to run the commands in this chapter, you will need to have the kubectl
    tool installed. Installation instructions are available in [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016),
    *Communicating with Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: If you are actually going to create a cluster using any of the methods in this
    chapter, you will need to review the specific technical requirements for each
    method in the relevant project's documentation. For minikube specifically, most
    machines running Linux, macOS, or Windows will work. For large clusters, please
    review the specific documentation of the tool you plan to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code used in this chapter can be found in the book''s GitHub repository
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter2](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter2)'
  prefs: []
  type: TYPE_NORMAL
- en: Options for creating a cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to create a Kubernetes cluster, ranging from simple local
    tools all the way to fully creating a cluster from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: If you're just getting started with learning Kubernetes, you'll probably want
    to spin up a simple local cluster with a tool such as minikube.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re looking to build a production cluster for an application, you have
    several options:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use a tool such as Kops, Kubespray, or Kubeadm to create the cluster
    programmatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a managed Kubernetes service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create a cluster completely from scratch on VMs or physical hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless you have extremely specific demands in terms of cluster configuration
    (and even then), it is not usually recommended to create your cluster completely
    from scratch without using a bootstrapping tool.
  prefs: []
  type: TYPE_NORMAL
- en: For most use cases, the decision will be between using a managed Kubernetes
    service on a cloud provider and using a bootstrapping tool.
  prefs: []
  type: TYPE_NORMAL
- en: In air-gapped systems, using a bootstrapping tool is the only way to go – but
    some are better than others for particular use cases. In particular, Kops is aimed
    at making it easier to create and manage clusters on cloud providers such as AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Not included in this section is a discussion of alternative third-party managed
    services or cluster creation and administration tools such as Rancher or OpenShift.
    When making a selection for running clusters in production, it is important to
    take into account a large variety of factors including the current infrastructure,
    business requirements, and much more. To keep things simple, in this book we will
    focus on production clusters, assuming no other infrastructure or hyper-specific
    business needs – a "clean slate," so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: minikube – an easy way to start
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: minikube is the easiest way to get started with a simple local cluster. This
    cluster won't be set up for high availability, and is not aimed at production
    uses, but it is a great way to get started running workloads on Kubernetes in
    minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: minikube can be installed on Windows, macOS, and Linux. What follows is the
    installation instructions for all three platforms, which you can also find by
    navigating to [https://minikube.sigs.k8s.io/docs/start](https://minikube.sigs.k8s.io/docs/start).
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest installation method on Windows is to download and run the minikube
    installer from [https://storage.googleapis.com/minikube/releases/latest/minikube-installer.exe](https://storage.googleapis.com/minikube/releases/latest/minikube-installer.exe).
  prefs: []
  type: TYPE_NORMAL
- en: Installing on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the following command to download and install the binary. You can find
    it in the code repository as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Minikube-install-mac.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the following command to download and install the binary:'
  prefs: []
  type: TYPE_NORMAL
- en: Minikube-install-linux.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating a cluster on minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with a cluster on minikube, simply run `minikube start`, which
    will create a simple local cluster with the default VirtualBox VM driver. minikube
    also has several additional configuration options that can be reviewed at the
    documentation site.
  prefs: []
  type: TYPE_NORMAL
- en: Running the `minikube` `start` command will automatically configure your `kubeconfig`
    file so you can run `kubectl` commands without any further configuration on your
    newly created cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Managed Kubernetes services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The number of managed cloud providers that offer a managed Kubernetes service
    is always growing. However, for the purposes of this book, we will focus on the
    major public clouds and their particular Kubernetes offerings. This includes the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Web Services** (**AWS**) – **Elastic Kubernetes Service** (**EKS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud – **Google Kubernetes Engine** (**GKE**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Azure – **Azure Kubernetes Service** (**AKS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The number and implementation of managed Kubernetes services is always changing.
    AWS, Google Cloud, and Azure were selected for this section of the book because
    they are very likely to continue working in the same manner. Whatever managed
    service you use, make sure to check the official documentation provided with the
    service to ensure that the cluster creation procedure is still the same as what
    is presented in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of managed Kubernetes services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, the major managed Kubernetes service offerings provide a few benefits.
    Firstly, all three of the managed service offerings we're reviewing provide a
    completely managed Kubernetes control plane.
  prefs: []
  type: TYPE_NORMAL
- en: This means that when you use one of these managed Kubernetes services, you do
    not need to worry about your master nodes. They are abstracted away and may as
    well not exist. All three of these managed clusters allow you to choose the number
    of worker nodes when creating a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of a managed cluster is seamless upgrades from one version of
    Kubernetes to another. Generally, once a new version of Kubernetes (not always
    the newest version) is validated for the managed service, you should be able to
    upgrade using a push button or a reasonably simple procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks of managed Kubernetes services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although a managed Kubernetes cluster can make operations easier in many respects,
    there are also some downsides.
  prefs: []
  type: TYPE_NORMAL
- en: For many of the managed Kubernetes services available, the minimum cost for
    a managed cluster far exceeds the cost of a minimal cluster created manually or
    with a tool such as Kops. For production use cases, this is generally not as much
    of an issue because a production cluster should contain a minimum amount of nodes
    anyway, but for development environments or test clusters, the additional cost
    may not be worth the ease of operations depending on the budget.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, though abstracting away master nodes makes operations easier,
    it also prevents fine tuning or advanced master node functionality that may otherwise
    be available on clusters with defined masters.
  prefs: []
  type: TYPE_NORMAL
- en: AWS – Elastic Kubernetes Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS' managed Kubernetes service is called EKS, or Elastic Kubernetes Service.
    There are a few different ways to get started with EKS, but we'll cover the simplest
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create an EKS cluster, you must provision the proper **Virtual Private
    Cloud (VPC)** and **Identity and Access Management (IAM)** role settings – at
    which point you can create a cluster through the console. These settings can be
    created manually through the console, or through infrastructure provisioning tools
    such as CloudFormation and Terraform. Full instructions for creating a cluster
    through the console can be found at [https://docs.aws.amazon.com/en_pv/eks/latest/userguide/getting-started-console.html](https://docs.aws.amazon.com/en_pv/eks/latest/userguide/getting-started-console.html).
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you're creating a cluster and VPC from scratch, however, you can instead
    use a tool called `eksctl` to provision your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: To install `eksctl`, you can find installation instructions for macOS, Linux,
    and Windows at [https://docs.aws.amazon.com/eks/latest/userguide/getting-started-eksctl.html](https://docs.aws.amazon.com/eks/latest/userguide/getting-started-eksctl.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have `eksctl` installed, creating a cluster is as simple as using
    the `eksctl create cluster` command:'
  prefs: []
  type: TYPE_NORMAL
- en: Eks-create-cluster.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will create a cluster of three `t2.small` instances as worker nodes set
    up in an autoscaling group with a minimum of one node and a maximum of four. The
    Kubernetes version that is used will be `1.17`. Importantly, `eksctl` starts with
    a default region, and depending on the number of nodes chosen, they will be spread
    throughout multiple availability zones in that region.
  prefs: []
  type: TYPE_NORMAL
- en: '`eksctl` will also automatically update your `kubeconfig` file, so you should
    be able to run `kubectl` commands immediately after the cluster creation process
    is finished.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the configuration with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should see a list of your nodes and their associated IPs. Your cluster is
    ready! Next, let's take a look at Google's GKE setup process.
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud – Google Kubernetes Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GKE is Google Cloud's managed Kubernetes service. With the gcloud command-line
    tool, it is very easy to quickly spin up a GKE cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a cluster on GKE using gcloud, you can either use Google Cloud's Cloud
    Shell service, or run the commands locally. If you want to run the commands locally,
    you must install the gcloud CLI via the Google Cloud SDK. See [https://cloud.google.com/sdk/docs/quickstarts](https://cloud.google.com/sdk/docs/quickstarts)
    for installation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have gcloud installed, you need to ensure that you have activated the
    GKE API in your Google Cloud account.
  prefs: []
  type: TYPE_NORMAL
- en: To easily accomplish this, navigate to [https://console.cloud.google.com/apis/library](https://console.cloud.google.com/apis/library),
    then search for `kubernetes` in the search bar. Click on **Kubernetes Engine API**
    and then click **Enable**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the API is activated, set your project and compute zone in Google
    Cloud by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the commands, `proj_id` corresponds to the project ID in Google Cloud that
    you want to create your cluster in, and `compute_zone` corresponds to your desired
    compute zone in Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are actually three types of clusters on GKE, each with different (increasing)
    levels of reliability and fault tolerance:'
  prefs: []
  type: TYPE_NORMAL
- en: Single-zone clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-zonal clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regional clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **single-zone** cluster in GKE means a cluster that has a single control plane
    replica and one or more worker nodes running in the same Google Cloud zone. If
    something happens to the zone, both the control plane and the workers (and thus
    the workloads) will go down.
  prefs: []
  type: TYPE_NORMAL
- en: A **multi-zonal** cluster in GKE means a cluster that has a single control plane
    replica and two or more worker nodes running in different Google Cloud zones.
    This means that if a single zone (even the zone containing the control plane)
    goes down, the workloads running in the cluster will still persist, but the Kubernetes
    API will be unavailable until the control plane zone comes back up.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a **regional cluster** in GKE means a cluster that has both a multi-zonal
    control plane and multi-zonal worker nodes. If any zone goes down, both the control
    plane and the workloads on the worker nodes will persist. This is the most expensive
    and reliable option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to actually create your cluster, you can run the following command to
    create a cluster named `dev` with the default settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a single-zone cluster in your chosen compute zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a multi-zonal cluster, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, `compute_zone_1` and `compute_zone_2` are disparate Google Cloud zones.
    In addition, more zones can be added via the `node-locations` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to create a regional cluster, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `node-locations` flag is actually optional. If left out, the
    cluster will be created with worker nodes in all the zones within the region.
    If you'd like to change this default behavior, you can override it using the `node-locations`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a cluster running, you need to configure your `kubeconfig`
    file to communicate with the cluster. To do this, simply pass the cluster name
    into the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, test the configuration with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As with EKS, you should see a list of all your provisioned nodes. Success! Finally,
    let's take a look at Azure's managed offering.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Azure – Azure Kubernetes Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft Azure's managed Kubernetes service is called AKS. Creating a cluster
    on AKS can be done via the Azure CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a cluster on AKS, you can use the Azure CLI tool and run the following
    command to create a service principal (a role that the cluster will use to access
    Azure resources):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this command will be a JSON object with information on the service
    principal, which we will use in the next step. This JSON object looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use the values from the previous JSON command to actually create
    your AKS cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: Aks-create-cluster.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This command assumes a resource group named `devResourceGroup`, and a cluster
    named `devCluster`. For `appId` and `password`, use the values from the service
    principal creation step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to generate the proper `kubectl` configuration on your machine, you
    can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should be able to properly run `kubectl` commands. Test the
    configuration with the `kubectl get nodes` command.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic cluster creation tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several tools available that will bootstrap a Kubernetes cluster
    in various non-managed environments. We''ll focus on three of the most popular:
    Kubeadm, Kops, and Kubespray. Each tool is aimed at a different use case and generally
    works by a different method.'
  prefs: []
  type: TYPE_NORMAL
- en: Kubeadm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubeadm is a tool created by the Kubernetes community to simplify cluster creation
    on infrastructure that is already provisioned. Unlike Kops, Kubeadm does not have
    the ability to provision infrastructure on cloud services. It simply creates a
    best-practices cluster that will pass Kubernetes conformance tests. Kubeadm is
    agnostic to infrastructure – it should work anywhere you can run Linux VMs.
  prefs: []
  type: TYPE_NORMAL
- en: Kops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kops is a popular cluster provisioning tool. It provisions the underlying infrastructure
    for your cluster, installs all cluster components, and validates the functionality
    of your cluster. It can also be used to perform various cluster operations such
    as upgrades, node rotations, and more. Kops currently supports AWS, with (as of
    the time of writing this book) beta support for Google Compute Engine and OpenStack,
    and alpha support for VMware vSphere and DigitalOcean.
  prefs: []
  type: TYPE_NORMAL
- en: Kubespray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubespray is different to both Kops and Kubeadm. Unlike Kops, Kubespray does
    not inherently provision cluster resources. Instead, Kubespray allows you to choose
    between Ansible and Vagrant in order to perform provisioning, orchestration, and
    node setup.
  prefs: []
  type: TYPE_NORMAL
- en: When compared to Kubeadm, Kubespray has far fewer integrated cluster creation
    and life cycle processes. Newer versions of Kubespray allow you to use Kubeadm
    specifically for cluster creation after node setup.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Since creating a cluster with Kubespray requires some Ansible-specific domain
    knowledge, we will keep that discussion out of this book – but a guide to all
    things Kubespray can be found at [https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md](https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cluster with Kubeadm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a cluster with Kubeadm, you will need your nodes provisioned ahead
    of time. As with any other Kubernetes cluster, we'll need VMs or bare-metal servers
    running Linux.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this book, we will show how to bootstrap a Kubeadm cluster
    with only a single master node. For highly available setups, you'll need to run
    additional join commands on the other master nodes, which you can find at [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubeadm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First things first – you'll need to install Kubeadm on all nodes. The installation
    instructions for each supported operating system can be found at [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm).
  prefs: []
  type: TYPE_NORMAL
- en: For each node, also make sure to check that all the required ports are open,
    and that you've installed your intended container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the master nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To quickly start master nodes with Kubeadm, you only need to run a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This initialization command can take in several optional arguments – depending
    on your preferred cluster setup, networking, and so on, you may need to use them.
  prefs: []
  type: TYPE_NORMAL
- en: In the output of the `init` command, you'll see a `kubeadm join` command. Make
    sure to save this command.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the worker nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to bootstrap the worker nodes, you need to run the `join` command
    you saved. The command will be of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The token in this command is a bootstrap token. It is used to authenticate nodes
    with each other and join new nodes to the cluster. With access to this token comes
    the power to join new nodes to the cluster, so treat it as such.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up kubectl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Kubeadm, kubectl will already be properly set up on the master node. However,
    to use kubectl from any other machine or outside the cluster, you can copy the
    config from the master to your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This `kubeconfig` will be the cluster administrator config – in order to specify
    other users (and permissions), you will need to add new service accounts and generate
    `kubeconfig` files for them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cluster with Kops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Kops will provision infrastructure for you, there is no need to pre-create
    any nodes. All you need to do is install Kops, ensure your cloud platform credentials
    are working, and create your cluster all at once. Kops can be installed on Linux,
    macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: For this tutorial, we will go through creating a cluster on AWS, but you can
    find instructions for other supported Kops platforms in the Kops documentation
    at [https://github.com/kubernetes/kops/tree/master/docs](https://github.com/kubernetes/kops/tree/master/docs).
  prefs: []
  type: TYPE_NORMAL
- en: Installing on macOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On OS X, the easiest way to install Kops is using Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can grab the newest stable Kops binary from the Kops GitHub
    page at [https://github.com/kubernetes/kops/releases/tag/1.12.3](https://github.com/kubernetes/kops/releases/tag/1.12.3).
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On Linux, you can install Kops via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: Kops-linux-install.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Installing on Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install Kops on Windows, you'll need to download the newest Windows release
    from [https://github.com/kubernetes/kops/releases/latest](https://github.com/kubernetes/kops/releases/latest),
    rename it to `kops.exe`, and add it to your `path` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up credentials for Kops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for Kops to work, you'll need AWS credentials on your machine with
    a few required IAM permissions. To do this safely, you will want to create an
    IAM user specifically for Kops.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create an IAM group for the `kops` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, attach the required roles for the `kops_users` group. To function properly,
    Kops will need `AmazonEC2FullAccess`, `AmazonRoute53FullAccess`, `AmazonS3FullAccess`,
    `IAMFullAccess`, and `AmazonVPCFullAccess`. We can accomplish this by running
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide-aws-policies-to-kops.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create the `kops` user, add it to the `kops_users` group, and create
    programmatic access keys, which you should save:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow Kops to access your new IAM credentials, you can use the following
    commands to configure your AWS CLI with the access key and secret from the previous
    command (`create-access-key`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Setting up state storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the proper credentials set up, we can start creating our cluster. In this
    case, we're going to build a simple gossip-based cluster so we won't need to mess
    around with DNS. To see the possible DNS setups, you can look at the Kops documentation
    ([https://github.com/kubernetes/kops/tree/master/docs](https://github.com/kubernetes/kops/tree/master/docs)).
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll need a location to store our cluster spec. S3 is perfect for this
    since we're on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual with S3, bucket names need to be unique. You can easily create a bucket
    using the AWS SDK (make sure to replace `my-domain-dev-state-store` with your
    desired S3 bucket name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a best practice to enable bucket encryption and versioning as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to set up variables for Kops, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Kops supports several state storage locations such as AWS S3, Google Cloud Storage,
    Kubernetes, DigitalOcean, OpenStack Swift, Alibaba Cloud, and memfs. However,
    you can just save the Kops state to a local file and use that instead. The benefit
    of having a cloud-based state store is the ability for multiple infrastructure
    developers to access and update it with versioning controls.
  prefs: []
  type: TYPE_NORMAL
- en: Creating clusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Kops, we can deploy clusters of any size. For the purposes of this guide,
    we will deploy a production-ready cluster by having both worker and master nodes
    span three availability zones. We're going to use the US-East-1 region, and both
    the masters and workers will be `t2.medium` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the config for this cluster, you can run the following `kops create`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: Kops-create-cluster.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the config that has been created, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to create our cluster, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The cluster creation process may take some time, but once it is complete, your
    `kubeconfig` should be properly configured to use kubectl with your new cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cluster completely from scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster entirely from scratch is a multi-step endeavor
    that could likely span multiple chapters of this book. However, since our purpose
    is to get you up and running with Kubernetes as quickly as possible, we will refrain
    from describing the entire process.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in creating a cluster from scratch, either for educational
    reasons or a need to finely customize your cluster, a great guide is *Kubernetes
    The Hard Way*, which is a full cluster creation tutorial written by *Kelsey Hightower*.
    It can be found at [https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've gotten that out of the way, we can proceed with an overview of
    the manual cluster creation process.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning your nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First things first – you'll need some infrastructure to run Kubernetes on. Generally,
    VMs are a good candidate for this, though Kubernetes can be run on bare metal
    as well. If you're working in an environment where you cannot easily add nodes
    (which removes many of the scaling benefits of the cloud, but is definitely possible
    in enterprise settings), you'll need enough nodes to meet your application demands.
    This is more likely to be an issue in air-gapped environments.
  prefs: []
  type: TYPE_NORMAL
- en: Some of your nodes will be used for the master control plane, while others will
    solely be used as workers. There is no need to make the master and worker nodes
    identical from a memory or CPU perspective – you could even have some weaker and
    some more powerful workers. This pattern results in a non-homogeneous cluster,
    in which certain nodes are better suited to particular workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Kubernetes certificate authority for TLS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to function properly, all major control plane components will need
    a TLS certificate. To create these, a **Certificate Authority** (**CA**) needs
    to be created, which will in turn create the TLS certificates.
  prefs: []
  type: TYPE_NORMAL
- en: To create the CA, a **Public Key Infrastructure** (**PKI**) needs to be bootstrapped.
    For this task, you can use any PKI tool, but the one used in the Kubernetes docs
    is cfssl.
  prefs: []
  type: TYPE_NORMAL
- en: Once the PKI, CA, and TLS certificates have been created for all components,
    the next step is to create config files for the control plane and worker node
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Creating config files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Config files need to be created for the `kubelet`, `kube-proxy`, `kube-controller-manager`,
    and `kube-scheduler` components. They will use the certificates in these config
    files to authenticate with `kube-apiserver`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an etcd cluster and configuring encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the data encryption config is handled via a YAML file with a data encryption
    secret. At this point, it is required to start the `etcd` cluster.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, `systemd` files are created on each node with the `etcd` process
    config. Then `systemctl` is used on each node to start the `etcd` servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample `systemd` file for `etcd`. The `systemd` files for the other
    control plane components will be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: Example-systemd-control-plane
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This service file provides a runtime definition for our `etcd` component, which
    will be started on each master node. To actually start `etcd` on our node, we
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This enables the `etcd` service along with automatic restarts when the node
    is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the control plane component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bootstrapping the control plane components on the master nodes is similar to
    the process used to create the `etcd` cluster. `systemd` files are created for
    each component – the API server, the controller manager, and the scheduler – and
    then a `systemctl` command is used to start each component.
  prefs: []
  type: TYPE_NORMAL
- en: The previously created config files and certificates also need to be included
    on each master node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our service file definition for the `kube-apiserver`
    component, broken down into its sections as follows. The `Unit` section is just
    a quick description of our `systemd` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Api-server-systemd-example
  prefs: []
  type: TYPE_NORMAL
- en: 'This second piece is the actual start command for the services, along with
    any variables to be passed to the services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `Install` section allows us to specify a `WantedBy` target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The service files for `kube-scheduler` and `kube-controller-manager` will be
    very similar to the `kube-apiserver` definition, and once we''re ready to start
    the components on the node, the process is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Similarly to `etcd`, we want to ensure the services restart on a node shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the worker node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's a similar story on the worker nodes. Service specs for `kubelet`, the container
    runtime, `cni`, and `kube-proxy` need to be created and run using `systemctl`.
    The `kubelet` config will specify the aforementioned TLS certificate so that it
    can communicate with the control plane via the API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what our `kubelet` service definition looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubelet-systemd-example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this service definition references `cni`, the container runtime,
    and the `kubelet-config` file. The `kubelet-config` file contains the TLS information
    we need for our workers.
  prefs: []
  type: TYPE_NORMAL
- en: After bootstrapping the workers and master, the cluster should be functional
    via the use of the admin `kubeconfig` file that was created as part of the TLS
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed several methods for creating a Kubernetes cluster.
    We looked at minimal local cluster creation using minikube, setting up clusters
    on managed Kubernetes services on Azure, AWS, and Google Cloud, creating clusters
    using the Kops provisioning tool, and finally, manually creating a cluster from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the skills to create a Kubernetes cluster in several different
    environments, we can move on to using Kubernetes to run applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to start running applications on Kubernetes.
    The knowledge you've gained about how Kubernetes works at the architectural level
    should make it much easier to understand the concepts in the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What purpose does minikube serve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some downsides to using a managed Kubernetes service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Kops compare to Kubeadm? What are the major differences?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which platforms does Kops support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When manually creating a cluster, how are the major cluster components specified?
    How are they run on each node?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official Kubernetes documentation: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kubernetes The Hard Way*: [https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

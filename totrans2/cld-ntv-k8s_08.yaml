- en: '*Chapter 6*: Kubernetes Application Configuration'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes the main configuration tools that Kubernetes provides.
    We'll start by discussing some best practices for injecting configuration into
    containerized applications. Next, we will discuss ConfigMaps, a Kubernetes resource
    aimed at providing applications with configuration data. Finally, we will cover
    Secrets, a secure way to store and provide sensitive data to applications running
    on Kubernetes. Altogether, this chapter should give you a great toolset for configuring
    your production applications on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring containerized applications using best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing ConfigMaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to run the commands detailed in this chapter, you will need a computer
    that supports the `kubectl` command-line tool, along with a working Kubernetes
    cluster. Review [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016),
    *Communicating with Kubernetes*, to find several methods for getting up and running
    with Kubernetes quickly, and for instructions on how to install the `kubectl`
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: The code used in this chapter can be found in the book's GitHub repository at
    [https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter6](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter6).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring containerized applications using best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we know how to effectively deploy (as covered in [*Chapter 4*](B14790_04_Final_PG_ePub.xhtml#_idTextAnchor106),
    *Scaling and Deploying Your Application*) and expose (as covered in [*Chapter
    5*](B14790_05_Final_PG_ePub.xhtml#_idTextAnchor127), *Services and Ingress* –
    *Communicating with the outside world*) containerized applications on Kubernetes.
    This is enough to run non-trivial stateless containerized applications on Kubernetes.
    However, Kubernetes also provides additional tooling for application configuration
    and Secrets management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Kubernetes runs containers, you could always configure your application
    to use environment variables baked into your Dockerfile. But this sidesteps some
    of the real value of an orchestrator like Kubernetes. We want to be able to change
    our application container without rebuilding a Docker image. For this purpose,
    Kubernetes gives us two configuration-focused resources: ConfigMaps and Secrets.
    Let''s first look at ConfigMaps.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ConfigMaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When running applications in production, developers want the ability to quickly
    and easily inject application configuration information. There are many patterns
    for doing this – from using a separate configuration server that is queried, to
    using environment variables or environment files. These strategies vary in the
    security and usability they offer.
  prefs: []
  type: TYPE_NORMAL
- en: For containerized applications, environment variables are often the easiest
    way to go – but injecting these variables in a secure way can require additional
    tooling or scripts. In Kubernetes, the ConfigMap resource lets us do this in a
    flexible, easy way. ConfigMaps allow Kubernetes administrators to specify and
    inject configuration information as either files or environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: For highly sensitive information such as secret keys, Kubernetes gives us another,
    similar resource – Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secrets refer to additional application configuration items that need to be
    stored in a slightly more secure way – for instance, master keys to restricted
    APIs, database passwords, and more. Kubernetes provides a resource called a Secret,
    which stores application configuration information in an encoded fashion. This
    does not inherently make the Secret more secure, but Kubernetes respects the concept
    of a secret by not automatically printing secret information in the `kubectl get`
    or `kubectl describe` commands. This prevents the Secret from being accidentally
    printed to a log.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that Secrets are actually secret, encryption at rest must be enabled
    on your cluster for secret data – we'll review how to do this later in this chapter.
    Available from Kubernetes 1.13, this functionality lets Kubernetes administrators
    prevent Secrets from being stored unencrypted in `etcd`, and limits access to
    `etcd` admins.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do a deep dive into Secrets, let's start by discussing ConfigMaps,
    which are better for non-sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing ConfigMaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ConfigMaps provide an easy way to store and inject application configuration
    data for containers running on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a ConfigMap is simple – and they enable two possibilities for actually
    injecting the application configuration data:'
  prefs: []
  type: TYPE_NORMAL
- en: Injecting as an environment variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting as a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the first option operates simply using container environment variables
    in memory, the latter option touches on some facets of volumes – a Kubernetes
    storage medium that will be covered in the next chapter. We will keep the review
    short for now and use it as an introduction to volumes, which will be expanded
    on in the following chapter, [*Chapter 7*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166),
    *Storage on Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: When working with ConfigMaps, it can be easier to create them using an imperative
    `Kubectl` command. There are a few possible ways to create ConfigMaps, which also
    result in differences in the way data is stored and accessed from the ConfigMap
    itself. The first way is to simply create it from a text value, as we will see
    next.
  prefs: []
  type: TYPE_NORMAL
- en: From text values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a ConfigMap from a text value in a command is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command creates a `configmap` named `myapp-config` with a single
    key, called `mycategory.mykey`, that has a value of `myvalue`. You can also create
    a ConfigMap with multiple keys and values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command results in a ConfigMap with two values in the `data` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what your ConfigMap looks like, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: configmap-output.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When your ConfigMap data is long, it does not make as much sense to create it
    directly from a text value. For longer configs, we can create our ConfigMap from
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: From files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to make it easier to create a ConfigMap with many different values,
    or reuse existing environment files you already have, you can create a ConfigMap
    from a file by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating our file, which we''ll name `env.properties`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create our ConfigMap by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether our `kubectl create` command correctly made our ConfigMap,
    let''s describe it using `kubectl describe`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this ConfigMap contains our text file (and the number of bytes).
    Our file in this case could be any text file – but if you know that your file
    is formatted properly as an environment file, you can let Kubernetes know that,
    in order to make your ConfigMap a bit easier to read. Let's learn how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: From environment files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we know that our file is formatted as a normal environment file with key
    pairs, we can use a slightly different method to create our ConfigMap – the environment
    file method. This method will make our data more obvious in the ConfigMap object,
    rather than being hidden inside the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the exact same file as before with our environment-specific creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s describe our ConfigMap using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, by using the `-from-env-file` method, the data in the `env`
    file is easily viewable when you run `kubectl describe`. This also means we can
    mount our ConfigMap directly as environment variables – more on that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a ConfigMap as a volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To consume data from a ConfigMap in a Pod, you need to mount it to the Pod in
    the spec. This mirrors (for good reason, as we'll find out) the way to mount a
    volume in Kubernetes, which is a resource that provides storage. For now, however,
    don't worry about volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our Pod spec, which mounts our `my-config-map` ConfigMap
    as a volume on our Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-mounting-cm.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `my-config-map` ConfigMap is mounted as a volume (`my-config-volume`)
    on the `/app/config` path for our container to access. We'll get to know more
    about how this works in the next chapter on storage.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you may want to mount a ConfigMap as environment variables in
    your container – we will learn how to do this next.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a ConfigMap as an environment variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also mount a ConfigMap as an environment variable. This process is pretty
    similar to mounting a ConfigMap as a volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our Pod spec:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-mounting-cm-as-env.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, instead of mounting our ConfigMap as a volume, we are simply
    referencing it in a container environment variable – `MY_ENV_VAR`. To do this,
    we need to use `configMapRef` in our `valueFrom` key and reference the name of
    our ConfigMap as well as the key to look at inside the ConfigMap itself.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of the chapter in the *Configuring containerized
    applications using best practices* section, ConfigMaps are not secure by default,
    and their data is stored as plaintext. For an added layer of security, we can
    use Secrets instead of ConfigMaps.
  prefs: []
  type: TYPE_NORMAL
- en: Using Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secrets work very similarly to ConfigMaps, except that they are stored as encoded
    text (specifically, Base64) instead of plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Secret is therefore very similar to creating a ConfigMap, with a
    few key differences. For starters, creating a Secret imperatively will automatically
    Base64-encode the data in the Secret. First, let's look at creating a Secret imperatively
    from a pair of files.
  prefs: []
  type: TYPE_NORMAL
- en: From files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s try creating a Secret from a file (this also works with multiple
    files). We can do this using the `kubectl create` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what our Secret looks like using `kubectl describe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `describe` command shows the number of bytes contained in
    the Secret, and its type `Opaque`.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to create a Secret is to manually create it using a declarative
    approach. Let's look at how to do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Manual declarative approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a Secret declaratively from a YAML file, you'll need to pre-encode
    the data to be stored using an encoding utility, such as the `base64` pipe on
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s encode our password here using the Linux `base64` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can declaratively create our Secret using a Kubernetes YAML spec, which
    we can name `secret.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our `secret.yaml` spec contains the Base64-encoded string that we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the Secret, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to create Secrets. Next, let's learn how to mount a Secret
    for use by a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a Secret as a volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mounting Secrets is very similar to mounting ConfigMaps. First, let's take a
    look at how to mount a Secret to a Pod as a volume (file).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our Pod spec. In this case, we are running an example
    application in order to test our Secret. Here is the YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-mounting-secret.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The one difference from ConfigMap here is that we specify `readOnly` on the
    volume to prevent any changes to the Secret while the Pod is running. Everything
    else is the same as far as how we are mounting the Secret.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we will review volumes in depth in the next chapter, [*Chapter 7*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166),
    *Storage on Kubernetes*, but for a simple explanation, volumes are a way to add
    storage to your Pods. In this example, we mounted our volume, which you can consider
    a filesystem, to our Pod. Our Secret is then created as a file in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a Secret as an environment variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to file mounting, we can mount our Secret as an environment variable
    in much the same way that ConfigMap mounting works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another Pod YAML. In this case, we will mount our Secret
    as an environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-mounting-secret-env.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the preceding Pod with `kubectl apply`, let''s run a command
    to look into our Pod to see if the variable was properly initialized. This works
    exactly the same way as `docker exec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It works! You should now have a good understanding of how to create, mount,
    and use ConfigMaps and Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: As the final topic concerning Secrets, we will learn how to create secure, encrypted
    Secrets using the Kubernetes `EncryptionConfig`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing encrypted Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several managed Kubernetes services (including Amazon''s **Elastic Kubernetes
    Service** (**EKS**)) automatically encrypt `etcd` data at rest – so you don''t
    need to do anything in order to implement encrypted Secrets. Cluster provisioners
    such as Kops have a simple flag (such as `encryptionConfig: true`). But if you''re
    creating your cluster *the hard way*, you''ll need to start the Kubernetes API
    server with a flag, `--encryption-provider-config`, and an `EncryptionConfig`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cluster completely from scratch is outside the scope of this book
    (take a look at *Kubernetes The Hard Way* for a great guide on that, at [https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)).
  prefs: []
  type: TYPE_NORMAL
- en: 'For a quick look at how encryption is handled, take a look at the following
    `EncryptionConfiguration` YAML, which is passed to `kube-apiserver` on start:'
  prefs: []
  type: TYPE_NORMAL
- en: encryption-config.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `EncryptionConfiguration` YAML takes a list of the resources
    that should be encrypted in `etcd`, and one or more providers that can be used
    to encrypt data. The following providers are allowed as of Kubernetes `1.17`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity**: No encryption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aescbc**: The recommended encryption provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secretbox**: Faster than Aescbc, and newer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aesgcm**: Note that you will need to implement key rotation yourself with
    Aesgcm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kms**: Used with a third-party Secrets store, such as Vault or AWS KMS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To see the full list, see https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/#providers.
    When multiple providers are added to the list, Kubernetes will use the first configured
    provider to encrypt objects. When decrypting, Kubernetes will go down the list
    and attempt decryption with each provider – if none work, it will return an error.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have created a secret (look at any of our previous examples of how to
    do so), and our `EncryptionConfig` is active, we can check whether our Secrets
    are actually encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether your Secrets are encrypted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to check whether your secret is actually encrypted in `etcd`
    is to fetch the value directly from `etcd` and check the encryption prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s go ahead and make a secret key using `base64`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `secret_to_test.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Secret:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With our Secret created, let''s check if it is encrypted in `etcd` by directly
    querying it. You shouldn''t need to directly query `etcd` very often, but if you
    have access to the certificates used to bootstrap the cluster, it is an easy process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your configured encryption provider, your Secret's data will start
    with a provider tag. For instance, a Secret encrypted with the Azure KMS provider
    will start with `k8s:enc:kms:v1:azurekmsprovider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, check to see if the Secret is correctly decrypted (it will still be encoded)
    via `kubectl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be `myencsecret: c2VjcmV0dG90ZXN0`, which is our unencrypted,
    encoded Secret value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Success!
  prefs: []
  type: TYPE_NORMAL
- en: We now have encryption running on our cluster. Let's find out how to remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling cluster encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also remove encryption from our Kubernetes resources fairly easily.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to restart the Kubernetes API server with a blank encryption
    configuration YAML. If you self-provisioned your cluster, this should be easy,
    but on EKS or AKS, this isn't possible manually. You'll need to follow the cloud
    provider-specific documentation on how to disable encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve self-provisioned your cluster or used a tool such as Kops or Kubeadm,
    then you can restart your `kube-apiserver` process on all master nodes with the
    following `EncryptionConfiguration`:'
  prefs: []
  type: TYPE_NORMAL
- en: encryption-reset.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that the identity provider does not need to be the only provider listed,
    but it does need to be first, since as we mentioned previously, Kubernetes uses
    the first provider to encrypt new/updated objects in `etcd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will manually recreate all our Secrets, upon which point they will
    automatically use the identity provider (unencrypted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: At this point, all of our Secrets are unencrypted!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the methods Kubernetes provides for injecting
    application configuration. First, we looked at some best practices for configuring
    containerized applications. Then, we reviewed the first method that Kubernetes
    gives us, ConfigMaps, along with several options for creating and mounting them
    to Pods. Finally, we looked at Secrets, which when encrypted are a more secure
    way to handle sensitive configurations. By now, you should have all the tools
    you need to provide secure and insecure configuration values to your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll delve into a topic we already touched on by mounting
    our Secrets and ConfigMaps – the Kubernetes volume resource and, more generally,
    storage on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the differences between Secrets and ConfigMaps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are Secrets encoded?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the major difference between creating a ConfigMap from a regular file,
    and creating one from an environment file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you make Secrets secure on Kubernetes? Why aren't they secure by default?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Info on data encryption configuration for Kubernetes can be found in the official
    documentation at [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

- en: '*Chapter 7*: Storage on Kubernetes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to provide application storage on Kubernetes.
    We'll review two storage resources on Kubernetes, volumes and persistent volumes.
    Volumes are great for transient data needs, but persistent volumes are necessary
    for running any serious stateful workload on Kubernetes. With the skills you'll
    learn in this chapter, you will be able to configure storage for your applications
    running on Kubernetes in several different ways and environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between volumes and persistent volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating persistent volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent volume claims
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to run the commands detailed in this chapter, you will need a computer
    that supports the `kubectl` command-line tool along with a working Kubernetes
    cluster. See [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016), *Communicating
    with Kubernetes*, for several methods to get up and running with Kubernetes quickly,
    and for instructions on how to install the `kubectl` tool.
  prefs: []
  type: TYPE_NORMAL
- en: The code used in this chapter can be found in the book's GitHub repository at
    [https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter7](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter7).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between volumes and persistent volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A completely stateless, containerized application may only need disk space for
    the container files themselves. When running applications of this type, no additional
    configuration is required on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not always true in the real world. Legacy apps that are being
    moved to containers may need disk space volumes for many possible reasons. In
    order to hold files for use by containers, you need the Kubernetes volume resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main storage resources that can be created in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: Volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The distinction between the two is in the name: while volumes are tied to the
    lifecycle of a particular Pod, persistent volumes stay alive until deleted and
    can be shared across different Pods. Volumes can be handy in sharing data across
    containers within a Pod, while persistent volumes can be used for many possible
    advanced purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to implement volumes first.
  prefs: []
  type: TYPE_NORMAL
- en: Volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes supports many different subtypes of volumes. Most can be used for
    either volumes or persistent volumes, but some are specific to either resource.
    We'll start with the simplest and review a few types.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can see the full current list of volume types at https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a short list of volume subtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`awsElasticBlockStore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cephfs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConfigMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emptyDir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hostPath`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nfs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`persistentVolumeClaim`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rbd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Secret`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, both ConfigMaps and Secrets are actually implemented as *types*
    of volume. Additionally, the list includes cloud provider volume types such as
    `awsElasticBlockStore`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike persistent volumes, which are created separately from any one Pod, creating
    a volume is most often done in the context of a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a simple volume, you can use the following Pod YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-vol.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This YAML will create a Pod along with a volume of type `emptyDir`. Volumes
    of type `emptyDir` are provisioned using whatever storage already exists on the
    node that the Pod is assigned to. As mentioned previously, the volume is tied
    to the lifecycle of the Pod, not its containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that in a Pod with multiple containers, all containers will be able
    to access volume data. Let''s take the following example YAML file for a Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-multiple-containers.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, both containers in the Pod can access the volume data, though
    at different paths. Containers can even communicate via files in the shared volume.
  prefs: []
  type: TYPE_NORMAL
- en: The important parts of the spec are the `volume spec` itself (the list item
    under `volumes`) and the `mount` for the volume (the list item under `volumeMounts`).
  prefs: []
  type: TYPE_NORMAL
- en: Each mount item contains a name, which corresponds to the name of the volume
    in the `volumes` section, and a `mountPath`, which will dictate to which file
    path on the container the volume gets mounted. For instance, in the preceding
    YAML, the volume `config-volume` will be accessible from within the `busybox`
    Pod at `/shared-config`, and within the `busybox2` Pod at `/myconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: The volume spec itself takes a name – in this case, `my-storage`, and additional
    keys/values specific to the volume type, which in this case is `emptyDir` and
    just takes empty brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s address the example of a cloud-provisioned volume mounted to a
    Pod. To mount an AWS **Elastic Block Storage** (**EBS**) volume, for instance,
    the following YAML can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-ebs.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This YAML will, as long as your cluster is set up correctly to authenticate
    with AWS, attach your existing EBS volume to the Pod. As you can see, we use the
    `awsElasticBlockStore` key to specifically configure the exact volume ID to be
    used. In this case, the EBS volume must already exist on your AWS account and
    region. This is much easier with AWS **Elastic Kubernetes Service** (**EKS**)
    since it allows us to automatically provision EBS volumes from within Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes also includes features within the Kubernetes AWS cloud provider to
    automatically provision volumes – but these are for use with persistent volumes.
    We'll look at how to get these automatically provisioned volumes in the *Persistent
    volumes* section.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Persistent volumes hold some key advantages over regular Kubernetes volumes.
    As mentioned previously, their (persistent volumes) lifecycle is tied to the life
    of the cluster, not the life of a single Pod. This means that persistent volumes
    can be shared between Pods and reused as long as the cluster is running. For this
    reason, the pattern matches much better to external stores such as EBS (a block
    storage service on AWS) since the storage itself outlasts a single Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using persistent volumes actually requires two resources: the `PersistentVolume`
    itself and a `PersistentVolumeClaim`, which is used to mount a `PersistentVolume`
    to a Pod.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `PersistentVolume` itself – take a look at the basic
    YAML for creating a `PersistentVolume`:'
  prefs: []
  type: TYPE_NORMAL
- en: pv.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now let's pick this apart. Starting with the first line in the spec – `storageClassName`.
  prefs: []
  type: TYPE_NORMAL
- en: This first config, `storageClassName`, represents the type of storage we want
    to use. For the `hostPath` volume type, we simply specify `manual`, but for AWS
    EBS, for instance, you could create and use a storage class called `gp2Encrypted`
    to match the `gp2` storage type in AWS with EBS encryption enabled. Storage classes
    are therefore combinations of configuration that are available for a particular
    volume type – which can be referenced in the volume spec.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward with our AWS `StorageClass` example, let''s provision a new
    `StorageClass` for `gp2Encrypted`:'
  prefs: []
  type: TYPE_NORMAL
- en: gp2-storageclass.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can create our `PersistentVolume` using the `gp2Encrypted` storage class.
    However, there's a shortcut to creating `PersistentVolumes` using dynamically
    provisioned EBS (or other cloud) volumes. When using dynamically provisioned volumes,
    we create the `PersistentVolumeClaim` first, which then automatically generates
    the `PersistentVolume`.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent volume claims
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now know that you can easily create persistent volumes in Kubernetes, however,
    that does not allow you to bind storage to a Pod. You need to create a `PersistentVolumeClaim`,
    which claims a `PersistentVolume` and allows you to bind that claim to a Pod or
    multiple Pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on our new `StorageClass` from the last section, let''s make a claim
    that will automatically result in a new `PersistentVolume` being created since
    there are no other persistent volumes with our desired `StorageClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: pvc.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Running `kubectl apply -f` on this file should result in a new, autogenerated
    **Persistent Volume** (**PV**) being created. If your AWS cloud provider is set
    up correctly, this will result in the creation of a new EBS volume with type GP2
    and encryption enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Before we attach our EBS-backed persistent volume to our Pod, let's confirm
    that the EBS volume was created correctly in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we can navigate to our AWS console and ensure we are in the same
    region that our EKS cluster is running in. Then go to **Services** > **EC2** and
    click on **Volumes** in the left menu under **Elastic Block Store**. In this section,
    we should see a line item with an autogenerated volume of the same size (**1 GiB**)
    as our PVC states. It should have the class of GP2, and it should have encryption
    enabled. Let''s see what this would look like in the AWS console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – AWS console with autocreated EBS volume](image/B14790_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – AWS console with autocreated EBS volume
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have our dynamically generated EBS volume properly created
    in AWS, with encryption enabled and the **gp2** volume type assigned. Now that
    we have our volume created, and we've confirmed that it has been created in AWS,
    we can attach it to our Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching Persistent Volume Claims (PVCs) to Pods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have both a `PersistentVolume` and a `PersistentVolumeClaim`, we can
    attach them to a Pod for consumption. This process is very similar to attaching
    a ConfigMap or Secret – which makes sense, because ConfigMaps and Secrets are
    essentially types of volumes!
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the YAML that allows us to attach our encrypted EBS volume to a Pod
    and name it `pod-with-attachment.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: Pod-with-attachment.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Running `kubectl apply -f pod-with-attachment.yaml` will result in the creation
    of a Pod that has our `PersistentVolume` mounted via our claim to `/usr/data`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that the volume has been successfully created, let''s `exec` into
    our Pod and create a file in the location that our volume has been mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s delete the Pod using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And recreate it again using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we''ve done our job right, we should be able to see our file when running
    `kubectl exec` to get into the Pod again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Success!
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to create a cloud-storage-provided persistent volume for Kubernetes.
    However, you may be running Kubernetes on-premise or on your laptop using minikube.
    Let's look at some alternate persistent volume subtypes that you can use instead.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent volumes without cloud storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our previous examples assume that you are running Kubernetes in a cloud environment
    and can make use of storage services provided by the cloud platform (AWS EBS and
    others). This, however, is not always possible. You may be running Kubernetes
    in a data center environment, or on dedicated hardware.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, there are many potential solutions for providing storage to Kubernetes.
    A simple one is to change the volume type to `hostPath`, which works within the
    node's existing storage devices to create persistent volumes. This is great when
    running on minikube, for instance, but does not provide as powerful an abstraction
    as something like AWS EBS. For a tool with on-premise capabilities similar to
    cloud storage tools like EBS, let's look at using Ceph with Rook. For the full
    documentation, check out the Rook docs (which will teach you Ceph as well) at
    [https://rook.io/docs/rook/v1.3/ceph-quickstart.html](https://rook.io/docs/rook/v1.3/ceph-quickstart.html).
  prefs: []
  type: TYPE_NORMAL
- en: Rook is a popular open source Kubernetes storage abstraction layer. It can provide
    persistent volumes through a variety of providers, such as EdgeFS and NFS. In
    this case, we'll use Ceph, an open source storage project that provides object,
    block, and file storage. For simplicity, we'll use block mode.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rook on Kubernetes is actually pretty simple. We'll take you from
    installing Rook to setting up a Ceph cluster, to finally provisioning persistent
    volumes on our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to use a typical Rook installation default setup provided by the
    Rook GitHub repository. This could be highly customized depending on the use case
    but will allow us to quickly set up block storage for our workloads. Please refer
    to the following steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s clone the Rook repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step is to create all the relevant Kubernetes resources, including
    several **Custom Resource Definitions** (**CRDs**). We''ll talk about these in
    later chapters, but for now, consider them new Kubernetes resources that are specific
    to Rook, outside of the typical Pods, Services, and so on. To create common resources,
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s start our Rook operator, which will handle provisioning all the
    necessary resources for a particular Rook provider, which in this case will be
    Ceph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the next step, ensure that the Rook operator Pod is actually running
    by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the Rook Pod is in the `Running` state, we can set up our Ceph cluster!
    The YAML for this is also in the folder we''ve cloned from Git. Create it using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This process can take a few minutes. The Ceph cluster is comprised of several
    different Pod types, including the operator, **Object Storage Devices** (**OSDs**),
    and managers.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that our Ceph cluster is working properly, Rook provides a toolbox
    container image that allows you to use the Rook and Ceph command-line tools. To
    start the toolbox, you can use the toolbox Pod spec provided by the Rook project
    at [https://rook.io/docs/rook/v0.7/toolbox.html](https://rook.io/docs/rook/v0.7/toolbox.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample of the spec for the toolbox Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: rook-toolbox-pod.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this Pod uses a special container image provided by Rook. The
    image comes with all the tools you need to investigate Rook and Ceph pre-installed.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the toolbox Pod running, you can use the `rookctl` and `ceph`
    commands to check on the cluster status (check the Rook docs for specifics).
  prefs: []
  type: TYPE_NORMAL
- en: The rook-ceph-block storage class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now our cluster is working, we can create our storage class that will be used
    by our PVs. We will call this storage class `rook-ceph-block`. Here''s our YAML
    file (`ceph-rook-combined.yaml`), which will include our `CephBlockPool` (which
    will handle our block storage in Ceph – see [https://rook.io/docs/rook/v0.9/ceph-pool-crd.html](https://rook.io/docs/rook/v0.9/ceph-pool-crd.html)
    for more information) as well as the storage class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: ceph-rook-combined.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the YAML spec defines both our `StorageClass` and the `CephBlockPool`
    resource. As we mentioned earlier in this chapter, `StorageClass` is how we tell
    Kubernetes how to fulfill a `PersistentVolumeClaim`. The `CephBlockPool` resource,
    on the other hand, tells Ceph how and where to create distributed storage resources
    – in this case, how much to replicate the storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can give some storage to our Pod! Let''s create a new PVC with our new
    storage class:'
  prefs: []
  type: TYPE_NORMAL
- en: rook-ceph-pvc.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our PVC is of storage class `rook-ceph-block`, so it will use the new storage
    class we just created. Now, let''s give the PVC to our Pod in our YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: rook-ceph-pod.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the Pod is created, Rook should spin up a new persistent volume and attach
    it to the Pod. Let''s peer into the Pod to see if it worked properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Success!
  prefs: []
  type: TYPE_NORMAL
- en: Though we just used Rook's and Ceph's block storage functionality with Ceph,
    it also has a filesystem mode, which has some benefits – let's discuss why you
    may want to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The Rook Ceph filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The downside of Rook's Ceph Block provider is that it can only be written to
    by one Pod at a time. In order to create a `ReadWriteMany` persistent volume with
    Rook/Ceph, we need to use the filesystem provider, which supports RWX mode. For
    more information, check out the Rook/Ceph docs at [https://rook.io/docs/rook/v1.3/ceph-quickstart.html](https://rook.io/docs/rook/v1.3/ceph-quickstart.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Up to creating the Ceph cluster, all the previous steps apply. At this point,
    we need to create our filesystem. Let''s use the following YAML file to create
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: rook-ceph-fs.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're replicating metadata and data to at least two pools for
    reliability, as configured in the `metadataPool` and `dataPool` blocks. We are
    also preserving the pools on delete using the `preservePoolsOnDelete` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create our new storage class specifically for Rook/Ceph filesystem
    storage. The following YAML does this:'
  prefs: []
  type: TYPE_NORMAL
- en: rook-ceph-fs-storageclass.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This `rook-cephfs` storage class specifies our previously created pool and
    describes the reclaim policy of our storage class. Finally, it uses a few annotations
    that are explained in the Rook/Ceph documentation. Now, we can attach this via
    a PVC to a deployment, not just a Pod! Take a look at our PV:'
  prefs: []
  type: TYPE_NORMAL
- en: rook-cephfs-pvc.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This persistent volume references our new `rook-cephfs` storage class in `ReadWriteMany`
    mode – we''re asking for `1 Gi` of this data. Next, we can create our `Deployment`:'
  prefs: []
  type: TYPE_NORMAL
- en: rook-cephfs-deployment.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This `Deployment` references our `ReadWriteMany` persistent volume claim using
    the `persistentVolumeClaim` block under `volumes`. When deployed, all of our Pods
    can now read and write to the same persistent volume.
  prefs: []
  type: TYPE_NORMAL
- en: After this, you should have a good understanding of how to create persistent
    volumes and attach them to Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we reviewed two methods of providing storage on Kubernetes
    – volumes and persistent volumes. First, we discussed the difference between these
    two methods: while volumes are tied to the lifetime of the Pod, persistent volumes
    last until they or the cluster is deleted. Then, we looked at how to implement
    volumes and attach them to our Pods. Lastly, we extended our learning on volumes
    to persistent volumes, and discovered how to use several different types of persistent
    volumes. These skills will help you assign persistent and non-persistent storage
    to your applications in many possible environments – from on-premises to the cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a detour from application concerns and discuss
    how to control Pod placement on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the differences between volumes and persistent volumes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a `StorageClass`, and how does it relate to a volume?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you automatically provision cloud resources when creating Kubernetes
    resources such as a persistent volume?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In which use cases do you think that using volumes instead of persistent volumes
    would be prohibitive?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ceph Storage Quickstart for Rook: [https://github.com/rook/rook/blob/master/Documentation/ceph-quickstart.md](https://github.com/rook/rook/blob/master/Documentation/ceph-quickstart.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rook Toolbox: [https://rook.io/docs/rook/v0.7/toolbox.html](https://rook.io/docs/rook/v0.7/toolbox.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cloud providers: https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

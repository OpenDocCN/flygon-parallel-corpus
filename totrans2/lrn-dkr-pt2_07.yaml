- en: Chapter 7. Sharing Data with Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do one thing at a time and do it well, is one of the successful mantras of
    the information technology (IT) sector for quite a long time now. This widely
    used tenet fits nicely with the building and exposing of Docker containers too
    and is being prescribed as one of the best practices to avail the originally envisaged
    benefits of the Docker-inspired containerization paradigm. That is, inscribe a
    single application along with its direct dependencies and libraries inside a Docker
    container in order to ensure the container''s independence, self-sufficiency,
    and maneuverability. Let''s see why containers are that important:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The temporal nature of containers**: The container typically lives as long
    as the application lives and vice versa. However, this has some negative implications
    for the application data. It is natural that applications go through a variety
    of changes in order to accommodate both businesses, as well as technical changes,
    even in their production environments. There are other causes, such as application
    malfunction, version changes, application maintenance, and so on, for applications
    to be updated and upgraded consistently. In the case of a general-purpose computing
    model, even when an application dies for any reason, the persistent data associated
    with this application would be preserved in the filesystem. However, in the case
    of the container paradigm, the application upgrades are usually performed by crafting
    a new container with the newer version of the application, by discarding the old
    one. Similarly, when an application malfunctions, a new container needs to be
    launched and the old one has to be discarded. To sum it up, containers are temporal
    in nature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The need for business continuity**: In the container landscape, the complete
    execution environment, including its data files are usually bundled and encapsulated
    inside the container. For any reason, when a container gets discarded, the application
    data files also perish along with the container. However, in order to provide
    a seamless service, these application data files must be preserved outside the
    container and passed on to the container that will be continuing with the service.
    Some application data files, such as the log files, need to be accessed outside
    the container for various posterior-analyses. The Docker technology addresses
    this file persistence issue very innovatively through a new building block called
    data volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Data volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing host data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data between containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The avoidable common pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data volume is the fundamental building block of data sharing in the Docker
    environment. Before getting into the details of data sharing, it is imperative
    to gain a good understanding of the Data Volume concept. Until now, all the files
    that we created in an image or a container are part and parcel of the Union filesystem.
    However, the data volume is part of the Docker host filesystem, and it simply
    gets mounted inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'A data volume can be inscribed in a Docker image using the `VOLUME` instruction
    of the `Dockerfile`. Also, it can be prescribed during the launch of a container
    using the `-v` option of the `docker run` subcommand. Here, in the following example,
    the implication of the `VOLUME` instruction in the `Dockerfile` is illustrated
    in detail, in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a very simple `Dockerfile` with the instruction of the base image (`ubuntu:14.04`)
    and the data volume (`/MountPointDemo`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the image with the name `mount-point-demo` using the `docker build` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Having built the image, let''s quickly inspect the image for our data volume
    using the `docker inspect` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, in the preceding output, the data volume is inscribed in the image
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s launch an interactive container using the `docker run` subcommand
    from the earlier crafted image, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From the container''s prompt, let''s check the presence of the data volume
    using the `ls -ld` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, the data volume is part of the Docker host filesystem
    and it gets mounted, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we inspected the image to find out about the data volume declaration
    in the image. Now that we have launched the container, let''s inspect the container''s
    data volume using the `docker inspect` subcommand with the container ID as its
    argument in a different terminal. We created a few containers previously and for
    this purpose, let''s take the container ID `8d22f73b5b46` directly from the container''s
    prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, here, the data volume is mapped to a directory in the Docker host,
    and the directory is mounted in read-write mode. This directory is created by
    the Docker engine automatically during the container launch time.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have seen the implication of the `VOLUME` instruction in the `Dockerfile`,
    and how Docker manages the data volume. Like the `VOLUME` instruction of the `Dockerfile`,
    we can use the `–v <container mount point path>` option of the `docker run` subcommand,
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Having launched the container, we encourage you to try the `ls -ld /MountPointDemo`
    and `mount` commands in the newly launched container, and then also, inspect the
    container, as shown in the preceding step, step 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both the scenarios described here, the Docker engine automatically creates
    the directory under `/var/lib/docker/vfs/` and mounts it to the container. When
    a container is removed using the `docker rm` subcommand, the Docker engine does
    not remove the directory that was automatically created during the container launch
    time. This behavior is innately designed to preserve the state of the container''s
    application that was stored in the directory. If you want to remove the directory
    that was automatically created by the Docker engine, you can do so while removing
    the container by providing a `-v` option to the `docker rm` subcommand, on an
    already stopped container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the container is still running, then you can remove the container as well
    as the auto-generated directory by adding a `-f` option to the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have taken you through the techniques and tips to auto-generate a directory
    in the Docker host and mount it to the data volume in the container. However,
    with the `-v` option of the `docker run` subcommand, a user-defined directory
    can be mounted to the data volume. In such cases, the Docker engine would not
    auto-generate any directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The system-generated directory has a caveat of directory leak. In other words,
    if you forget to delete the system-generated directories, you may face some unwanted
    issues. For further information, you can read the *Avoiding common pitfalls* section
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing host data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, we described the steps towards creating a data volume in a Docker
    image using the `VOLUME` instruction in the `Dockerfile`. However, Docker does
    not provide any mechanism to mount the host directory or file during the build
    time in order to ensure the Docker images are portable. The only provision Docker
    provides is to mount the host directory or file to a container''s data volume
    during the container''s launch time. Docker exposes the host directory or file
    mounting facility through the `-v` option of the `docker run` subcommand. The
    `–v` option has three different formats enumerated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-v <container mount path>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-v <host path>/<container mount path>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-v <host path>/<container mount path>:<read write mode>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `<host path>` is an absolute path in the Docker host, `<container mount
    path>` is an absolute path in the container filesystem, and `<read write mode>`
    can be either read-only (`ro`) or read-write (`rw`) mode. The first `-v <container
    mount path>` format has already been explained in the *Data Volume* section in
    this chapter, as a method to create a mount point during the container launch
    time. The second and third options enable us to mount a file or directory from
    the Docker host to the container mount point.
  prefs: []
  type: TYPE_NORMAL
- en: We would like to dig deeper to gain a better understanding of the host's data
    sharing through a couple of examples. In the first example, we will demonstrate
    how to share a directory between the Docker host and the container, and in the
    second example, we will demonstrate file sharing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, in the first example, we mount a directory from the Docker host to a
    container, perform a few basic file operations on the container, and verify these
    operations from the Docker host, as detailed in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s launch an interactive container with the `–v` option of the `docker
    run` subcommand to mount `/tmp/hostdir` of the Docker host directory to `/MountPoint`
    of the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `/tmp/hostdir` is not found on the Docker host, the Docker engine will create
    the directory itself. However, the problem is that the system-generated directory
    cannot be deleted using the `-v` option of the `docker rm` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having successfully launched the container, we can check the presence of `/MountPoint`
    using the `ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can proceed to checking the mount details using the `mount` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are going to validate `/MountPoint`, change to the `/MountPoint` directory
    using the `cd` command, create a few files using the `touch` command, and list
    the files using the `ls` command, as shown in the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It might be worth the effort to verify the files in the `/tmp/hostdir` Docker
    host directory using the `ls` command on a new terminal, as our container is running
    in an interactive mode on the existing terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the same set of files, as we can see in step 4\. However, you
    might have noticed the difference in the time stamp of the files. This time difference
    is due to the time-zone difference between the Docker host and the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s run the `docker inspect` subcommand with the container ID `4a018d99c133`
    as an argument to see whether the directory mapping is set up between the Docker
    host and the container mount point, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, in the preceding output of the `docker inspect` subcommand, the
    `/tmp/hostdir` directory of the Docker host is mounted on the `/MountPoint` mount
    point of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second example, we can mount a file from the Docker host to a container,
    update the file from the container, and verify these operations from the Docker
    host, as detailed in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to mount a file from the Docker host to the container, the file must
    preexist in the Docker host. Otherwise, the Docker engine will create a new directory
    with the specified name, and mount it as a directory. We can start by creating
    a file on the Docker host using the `touch` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch an interactive container with the `–v` option of the `docker run` subcommand
    to mount the `/tmp/hostfile.txt` Docker host file to the container as `/tmp/mntfile.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Having successfully launched the container, now let''s check the presence of
    `/mountedfile.txt` using the `ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, proceed to check the mount details using the `mount` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update some text to `/mountedfile.txt` using the `echo` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Meanwhile, switch to a different terminal in the Docker host, and print the
    `/tmp/hostfile.txt` Docker host file using the `cat` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the `docker inspect` subcommand with the container ID `d23a15527eeb`
    as it''s argument to see the file mapping between the Docker host and the container
    mount point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, it is evident that the `/tmp/hostfile.txt` file from
    the Docker host is mounted as `/mountedfile.txt` inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the case of file sharing between the Docker host and container, the file
    must exist before launching the container. However, in the case of directory sharing,
    if the directory does not exist in the Docker host, then the Docker engine would
    create a new directory in the Docker host, as explained earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The practicality of host data sharing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we launched an `HTTP` service in a Docker container.
    However, if you remember correctly, the log file for the `HTTP` service is still
    inside the container, and it cannot be accessed directly from the Docker host.
    Here, in this section, we elucidate the procedure of accessing the log files from
    the Docker host in a step-by-step manner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with launching an Apache2 HTTP service container by mounting the
    `/var/log/myhttpd` directory of the Docker host to the `/var/log/apache2` directory
    of the container, using the `–v` option of the `docker run` subcommand. In this
    example, we are leveraging the `apache2` image, which we had built in the previous
    chapter, by invoking the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you recall the `Dockerfile` in [Chapter 6](ch06.html "Chapter 6. Running
    Services in a Container"), *Running Services in a Container*, the `APACHE_LOG_DIR`
    environment variable is set to the `/var/log/apache2` directory, using the `ENV`
    instruction. This would make the Apache2 HTTP service route all log messages to
    the `/var/log/apache2` data volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the container is launched, we can change the directory to `/var/log/myhttpd`
    on the Docker host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Perhaps, a quick check of the files present in the `/var/log/myhttpd` directory
    is appropriate here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `access.log` contains all the access requests handled by the Apache2
    HTTP server. The `error.log` is a very important log file, where our HTTP server
    records the errors it encounters while processing any HTTP requests. The `other_vhosts_access.log`
    file is the virtual host log, which will always be empty in our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can display the content of all the log files in the `/var/log/myhttpd` directory
    using the `tail` command with the `–f` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `tail -f` command will run continuously and display the content of the files,
    as soon as they get updated. Here, both `access.log` and `other_vhosts_access.log`
    are empty, and there are a few error messages on the `error.log` file. Apparently,
    these error logs are generated by the HTTP service running inside the container.
    The logs are then stocked in the Docker host directory, which is mounted during
    the launch time of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we continue to run `tail –f *`, let''s connect to the HTTP service from
    a web browser running inside the container, and observe the log files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP service updates the `access.log` file, which we can manipulate from
    the host directory mounted through the `–v` option of the `docker run` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing data between containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learnt how seamlessly the Docker engine enables
    data sharing between the Docker host and the container. Even though it is a very
    effective solution, it tightly couples the container to the host filesystem. These
    directories might leave a nasty footprint because the user has to manually remove
    them once their purpose is met. So, the Docker's prescription to solve this issue
    is to create data-only containers as a base container, and then mount the Data
    Volume of that container to other containers using the `--volume-from` option
    of the `docker run` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: Data-only containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prime responsibility of a data-only container is to preserve the data.
    Creating a data-only container is very similar to the method illustrated in the
    data volume section. In addition, the containers are named explicitly for other
    containers to mount the data volume using the container''s name. The container''s
    data volumes are accessible from other containers even when the data-only containers
    are in the stopped state. The data-only containers can be created in two ways,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: During the container's launch time by configuring the data volume and container's
    name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data volume can also be inscribed with `Dockerfile` during the image-building
    time, and later the container can be named during the container's launch time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we are launching a data-only container by configuring
    the container launch with the `–v` and `--name` options of the `docker run` subcommand,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, the container is launched from the `busybox` image, which is widely used
    for its smaller footprint. Here, we choose to execute the `/bin/true` command
    because we don't intend to do any operations on the container. Therefore, we named
    the container `datavol` using the `--name` option and created a new `/DataMount`
    data volume using the `-v` option of the `docker run` subcommand. The `/bin/true`
    command exits immediately with the exit status `0`, which in turn will stop the
    container and continue to be in the stopped state.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting data volume from other containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker engine provides a nifty interface to mount (share) the data volume
    from one container to another. Docker makes this interface available through the
    `--volumes-from` option of the `docker run` subcommand. The `--volumes-from` option
    takes a container name or container ID as its input and automatically mounts all
    the data volumes available on the specified container. Docker allows you to mount
    multiple containers with the data volume using the `--volumes-from` option multiple
    times.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a practical example that demonstrates how to mount the data volume from
    another container and showcases the data volume mount process, step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with launching an interactive Ubuntu container by mounting the data
    volume from the data-only container (`datavol`), which we launched in the previous
    section, as explained here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now from the container''s prompt, let''s verify the data volume mounts using
    the `mount` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we successfully mounted the data volume from the `datavol` data-only container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to inspect the data volume of this container from another terminal
    using the `docker inspect` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, the data volume from the `datavol` data-only container is mounted
    as if they were mounted directly on to this container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can mount a data volume from another container and also showcase the mount
    points. We can make the mounted data volume work by sharing data between containers
    using the data volume, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reuse the container that we launched in the previous example and create
    a `/DataMount/testfile` file in the data volume `/DataMount` by writing some text
    to the file, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Just spin off a container to display the text that we wrote in the previous
    step, using the `cat` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the typical output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, the preceding output `Data Sharing between Container` of our newly
    containerized `cat` command is the text that we have written in `/DataMount/testfile`
    of the `datavol` container in step 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cool, isn''t it? You can share data seamlessly between containers by sharing
    the data volumes. Here, in this example, we used data-only containers as the base
    container for data sharing. However, Docker allows us to share any type of data
    volumes and to mount data volumes one after another, as depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the `vol1` container, we can mount the data volume from the `datavol`
    container.Then, in the `vol2` container,we mounted the data volume from the `vol1`
    container, which is originally from the `datavol` container.
  prefs: []
  type: TYPE_NORMAL
- en: The practicality of data sharing between containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, in this chapter, we learnt the mechanism of accessing the log files
    of the Apache2 HTTP service from the Docker host. Although it was fairly convenient
    to share data by mounting the Docker host directory to a container, later we came
    to realise that data can be shared between containers by just using the data volumes.
    So here, we are bringing in a twist to the method of the Apache2 HTTP service
    log handling by sharing data between containers. To share log files between containers,
    we will spin off the following containers as enlisted in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, a data-only container that would expose the data volume to other containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, an Apache2 HTTP service container leveraging the data volume of the data-only
    container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A container to view the log files generated by our Apache2 HTTP service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: If you are running any HTTP service on the port number `80` of your Docker
    host machine, pick any other unused port number for the following example. If
    not, first stop the HTTP service, then proceed with the example in order to avoid
    any port conflict.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we meticulously walk you through the steps to craft the respective images
    and launch the containers to view the log files, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we begin with crafting a `Dockerfile` with the `/var/log/apache2` data
    volume using the `VOLUME` instruction. The /`var/log/apache2` data volume is a
    direct mapping to `APACHE_LOG_DIR`, the environment variable set in the `Dockerfile`
    in [Chapter 6](ch06.html "Chapter 6. Running Services in a Container"), *Running
    Services in a Container*, using the `ENV` instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Since this `Dockerfile` is crafted to launch data-only containers, the default
    execution command is set to `/bin/true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will continue to build a Docker image with the name `apache2log` from the
    preceding `Dockerfile` using `docker build`, as presented here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch a data-only container from the `apache2log` image using the `docker
    run` subcommand and name the resulting container `log_vol`, using the `--name`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Acting on the preceding command, the container will create a data volume in
    `/var/log/apache2` and move it to a stop state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, you can run the `docker ps` subcommand with the `-a` option to verify
    the container''s state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As per the output, the container exits with the exit value `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the Apache2 HTTP service using the `docker run` subcommand. Here, we
    are reusing the `apache2` image we crafted in [Chapter 6](ch06.html "Chapter 6. Running
    Services in a Container"), *Running Services in a Container*. In this container,
    we will mount the `/var/log/apache2` data volume from `log_vol`, the data-only
    container that we launched in step 3, using the `--volumes-from` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: With the successful launch of the Apache2 HTTP service with the `/var/log/apache2`
    data volume mounted from `log_vol`, we can access the log files using transient
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are listing the files stored by the Apache2 HTTP service using a transient
    container. This transient container is spun off by mounting the `/var/log/apache2`
    data volume from `log_vol`,and the files in `/var/log/apache2` are listed using
    the `ls` command. Further, the `--rm` option of the `docker run` subcommand is
    used to remove the container once it is done executing the `ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the error log produced by the Apache2 HTTP service is accessed using
    the `tail` command, as highlighted in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding common pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we discussed how effectively data volumes can be used to share data
    between the Docker host and the containers as well as between containers. Data
    sharing using data volumes is turning out to be a very powerful and essential
    tool in the Docker paradigm. However, it does carry a few pitfalls that are to
    be carefully identified and eliminated. In this section, we make an attempt to
    list out a few common issues associated with data sharing and the ways and means
    to overcome them.
  prefs: []
  type: TYPE_NORMAL
- en: Directory leaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in the data volume section, we learnt that the Docker engine automatically
    creates directories based on the `VOLUME` instruction in `Dockerfile` as well
    as the `-v` option of the `docker run` subcommand. We also understood that the
    Docker engine does not automatically delete these auto-generated directories in
    order to preserve the state of the application(s) run inside the container. We
    can force Docker to remove these directories using the `–v` option of the `docker
    rm` subcommand. This process of manual deletion poses two major challenges enumerated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Undeleted directories:** There could be scenarios where you may intentionally
    or unintentionally choose not to remove the generated directory while removing
    the container.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Third-party images:** Quite often, we leverage third-party Docker images
    that could have been built with the `VOLUME` instruction. Likewise, we might also
    have our own Docker images with `VOLUME` inscribed in it. When we launch containers
    using such Docker images, the Docker engine will auto-generate the prescribed
    directories. Since we are not aware of the data volume creation, we may not call
    the `docker rm` subcommand with the -v option to delete the auto-generated directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the previously mentioned scenarios, once the associated container is removed,
    there is no direct way to identify the directories whose containers were removed.
    Here are a few recommendations on how to avoid this pitfall:'
  prefs: []
  type: TYPE_NORMAL
- en: Always inspect the Docker images using the `docker inspect` subcommand and check
    whether any data volume is inscribed in the image or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always run the `docker rm` subcommand with the `-v` option to remove any data
    volume (directory) created for the container. Even if the data volume is shared
    by multiple containers, it is still safe to run the `docker rm` subcommand with
    the `-v` option because the directory associated with the data volume will be
    deleted only when the last container sharing that data volume is removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any reason, if you choose to preserve the auto-generated directory, you
    must keep a clear record so that you can remove them at a later point of time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an audit framework that will audit and find out the directories that
    do not have any container association.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The undesirable effect of data volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, Docker enables us to etch data volumes in a Docker image
    using the `VOLUME` instruction during the build time. Nonetheless, the data volumes
    should never be used to store any data during the build time, otherwise it will
    result in an unwanted effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will demonstrate the undesirable effect of using the data
    volume during the build time by crafting a `Dockerfile`, and then showcase the
    implication by building this `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the details of `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the image using `Ubuntu 14.04` as the base image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `/MountPointDemo` data volume using the `VOLUME` instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file in the `/MountPointDemo` data volume using the `RUN` instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the file in the `/MountPointDemo` data volume using the `RUN` instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Proceed to build an image from this `Dockerfile` using the `docker build` subcommand,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output of the `docker build` subcommand, you would have noticed
    that the build fails at step 3 because it cannot find the file created in step
    2\. Apparently, the file that was created in step 2 vanishes when it reaches step
    3\. This undesirable effect is due to the approach Docker uses to build its images.
    An understanding of the Docker image-building process would unravel the mystery.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the build process, for every instruction in a `Dockerfile`, the following
    steps are followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new container by translating the `Dockerfile` instruction to an equivalent
    `docker run` subcommand
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the newly-created container to an image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 1 and step 2, by treating the newly-created image as the base image
    for step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a container is committed, it saves the container's filesystem and, deliberately,
    does not save the data volume's filesystem. Therefore, any data stored in the
    data volume will be lost in this process. So never use a data volume as storage
    during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For enterprise-scale distributed applications to be distinct in their operations
    and outputs, data is the most important instrument and ingredient. With IT containerization,
    the journey takes off in a brisk and bright fashion. IT as well as business software
    solutions are intelligently containerized through the smart leverage of the Docker
    engine. However, the original instigation is the need for a faster and flawless
    realization of application-aware Docker containers, and hence, the data is tightly
    coupled with the application within the container. However, this closeness brings
    in some real risks. If the application collapses, then the data is also gone.
    Also, multiple applications might depend on the same data and hence, data has
    to be shared across.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we discussed the capabilities of the Docker engine in facilitating
    the seamless data sharing between the Docker host and container as well as between
    containers. The data volume is being prescribed as the foundational building block
    for enabling data sharing among the constituents of the growing Docker ecosystem.
    In the next chapter, we will explain the concept behind the container orchestration,
    and see how this complicated aspect gets simplified through a few automated tools.
    Orchestration is indispensable for realizing composite containers.
  prefs: []
  type: TYPE_NORMAL
